// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/topology/types.proto

package topology

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	_ "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	dc_cluster_group "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/dc_cluster_group"
	site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/site"
	site_mesh_group "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/site_mesh_group"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ProviderType
//
// x-displayName: "Provider Type"
// provider type
type ProviderType int32

const (
	// x-displayName: "Unspecified"
	// ProviderType unspecified
	PROVIDER_TYPE_UNSPECIFIED ProviderType = 0
	// x-displayName: "AWS"
	// AWS backend
	PROVIDER_TYPE_AWS ProviderType = 1
	// x-displayName: "GCP"
	// GCP backend
	PROVIDER_TYPE_GCP ProviderType = 2
	// x-displayName: "Azure"
	// Azure backend
	PROVIDER_TYPE_AZURE ProviderType = 3
	// x-displayName: "Volterra"
	// F5XC backend
	PROVIDER_TYPE_VOLTERRA ProviderType = 4
)

var ProviderType_name = map[int32]string{
	0: "PROVIDER_TYPE_UNSPECIFIED",
	1: "PROVIDER_TYPE_AWS",
	2: "PROVIDER_TYPE_GCP",
	3: "PROVIDER_TYPE_AZURE",
	4: "PROVIDER_TYPE_VOLTERRA",
}

var ProviderType_value = map[string]int32{
	"PROVIDER_TYPE_UNSPECIFIED": 0,
	"PROVIDER_TYPE_AWS":         1,
	"PROVIDER_TYPE_GCP":         2,
	"PROVIDER_TYPE_AZURE":       3,
	"PROVIDER_TYPE_VOLTERRA":    4,
}

func (ProviderType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{0}
}

// SiteEnumType
//
// x-displayName: "Site Type"
// Site Specific type
type SiteEnumType int32

const (
	// x-displayName: "Unspecified"
	// SiteType unspecified
	SITE_TYPE_UNSPECIFIED SiteEnumType = 0
	// x-displayName: "RE"
	// RE SiteType
	SITE_TYPE_RE SiteEnumType = 1
	// x-displayName: "AWS TGW Site CE"
	// AWS TGW Site CE
	SITE_TYPE_AWS_TGW SiteEnumType = 2
)

var SiteEnumType_name = map[int32]string{
	0: "SITE_TYPE_UNSPECIFIED",
	1: "SITE_TYPE_RE",
	2: "SITE_TYPE_AWS_TGW",
}

var SiteEnumType_value = map[string]int32{
	"SITE_TYPE_UNSPECIFIED": 0,
	"SITE_TYPE_RE":          1,
	"SITE_TYPE_AWS_TGW":     2,
}

func (SiteEnumType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{1}
}

// RouteTableTypeEnum
//
// x-displayName: "Route Table Type"
// Route table backend.
type RouteTableTypeEnum int32

const (
	// x-displayName: "Route table for network"
	// Route table for network
	ROUTE_TABLE_NETWORK RouteTableTypeEnum = 0
	// x-displayName: "Route Table for transit gateway"
	// Route Table for transit gateway
	ROUTE_TABLE_TGW RouteTableTypeEnum = 1
)

var RouteTableTypeEnum_name = map[int32]string{
	0: "ROUTE_TABLE_NETWORK",
	1: "ROUTE_TABLE_TGW",
}

var RouteTableTypeEnum_value = map[string]int32{
	"ROUTE_TABLE_NETWORK": 0,
	"ROUTE_TABLE_TGW":     1,
}

func (RouteTableTypeEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{2}
}

type InterfaceTypeEnum int32

const (
	// OUTSIDE Interface
	//
	// x-displayName: "Outside Interface"
	OUTSIDE InterfaceTypeEnum = 0
	// INSIDE Interface
	//
	// x-displayName: "Inside Interface"
	INSIDE InterfaceTypeEnum = 1
	// Workload Interface
	//
	// x-displayName: "Workload Interface"
	WORKLOAD InterfaceTypeEnum = 2
	// NOT_APPLICABLE
	//
	// x-displayName: "NOT_APPLICABLE"
	// Ex - When the subnet belongs to a azure spoke vnet
	NOT_APPLICABLE InterfaceTypeEnum = 3
)

var InterfaceTypeEnum_name = map[int32]string{
	0: "OUTSIDE",
	1: "INSIDE",
	2: "WORKLOAD",
	3: "NOT_APPLICABLE",
}

var InterfaceTypeEnum_value = map[string]int32{
	"OUTSIDE":        0,
	"INSIDE":         1,
	"WORKLOAD":       2,
	"NOT_APPLICABLE": 3,
}

func (InterfaceTypeEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{3}
}

// RouteSourceTypeEnum
//
// x-displayName: RouteSourceTypeEnum
// RouteSourceTypeEnum
type RouteSourceTypeEnum int32

const (
	// INVALID_SOURCE
	//
	// x-displayName: INVALID_SOURCE
	// INVALID_SOURCE
	INVALID_SOURCE RouteSourceTypeEnum = 0
	// DEFAULT
	//
	// x-displayName: DEFAULT
	// DEFAULT
	DEFAULT RouteSourceTypeEnum = 1
	// USER
	//
	// x-displayName: USER
	// USER
	USER RouteSourceTypeEnum = 2
	// UNKNOWN
	//
	// x-displayName: UNKNOWN
	// UNKNOWN
	UNKNOWN RouteSourceTypeEnum = 3
	// VIRTUAL_NETWORK_GATEWAY_SOURCE
	//
	// x-displayName: VIRTUAL_NETWORK_GATEWAY_SOURCE
	// VIRTUAL_NETWORK_GATEWAY_SOURCE
	VIRTUAL_NETWORK_GATEWAY_SOURCE RouteSourceTypeEnum = 4
	// SOURCE_NOT_APPLICABLE
	//
	// x-displayName: SOURCE_NOT_APPLICABLE
	// SOURCE_NOT_APPLICABLE should be used when the cloud provider does not supports this.
	SOURCE_NOT_APPLICABLE RouteSourceTypeEnum = 5
)

var RouteSourceTypeEnum_name = map[int32]string{
	0: "INVALID_SOURCE",
	1: "DEFAULT",
	2: "USER",
	3: "UNKNOWN",
	4: "VIRTUAL_NETWORK_GATEWAY_SOURCE",
	5: "SOURCE_NOT_APPLICABLE",
}

var RouteSourceTypeEnum_value = map[string]int32{
	"INVALID_SOURCE":                 0,
	"DEFAULT":                        1,
	"USER":                           2,
	"UNKNOWN":                        3,
	"VIRTUAL_NETWORK_GATEWAY_SOURCE": 4,
	"SOURCE_NOT_APPLICABLE":          5,
}

func (RouteSourceTypeEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{4}
}

// RouteStateTypeEnum
//
// x-displayName: RouteStateTypeEnum
// RouteStateTypeEnum
type RouteStateTypeEnum int32

const (
	// ACTIVE_STATE
	//
	// x-displayName: ACTIVE_STATE
	// ACTIVE_STATE
	ACTIVE_STATE RouteStateTypeEnum = 0
	// INVALID_STATE
	//
	// x-displayName: INVALID_STATE
	// INVALID_STATE
	INVALID_STATE RouteStateTypeEnum = 1
	// STATE_NOT_APPLICABLE
	//
	// x-displayName: STATE_NOT_APPLICABLE
	// STATE_NOT_APPLICABLE should be used when the cloud provider doesn't supports this
	STATE_NOT_APPLICABLE RouteStateTypeEnum = 2
)

var RouteStateTypeEnum_name = map[int32]string{
	0: "ACTIVE_STATE",
	1: "INVALID_STATE",
	2: "STATE_NOT_APPLICABLE",
}

var RouteStateTypeEnum_value = map[string]int32{
	"ACTIVE_STATE":         0,
	"INVALID_STATE":        1,
	"STATE_NOT_APPLICABLE": 2,
}

func (RouteStateTypeEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{5}
}

// RouteNextHopTypeEnum
//
// x-displayName: RouteNextHopTypeEnum
// RouteNextHopTypeEnum
type RouteNextHopTypeEnum int32

const (
	// VIRTUAL NETWORK GATEWAY
	//
	// x-displayName: VIRTUAL NETWORK GATEWAY
	// VIRTUAL NETWORK GATEWAY
	VIRTUAL_NETWORK_GATEWAY RouteNextHopTypeEnum = 0
	// VNET LOCAL
	//
	// x-displayName: VNET LOCAL
	// VNET LOCAL
	VNET_LOCAL RouteNextHopTypeEnum = 1
	// INTERNET
	//
	// x-displayName: INTERNET
	// INTERNET
	INTERNET RouteNextHopTypeEnum = 2
	// VIRTUAL APPLIANCE
	//
	// x-displayName: VIRTUAL APPLIANCE
	// VIRTUAL APPLIANCE
	VIRTUAL_APPLIANCE RouteNextHopTypeEnum = 3
	// NONE
	//
	// x-displayName: NONE
	// NONE
	NONE RouteNextHopTypeEnum = 4
	// VNET PEERING
	//
	// x-displayName: VNET PEERING
	// VNET PEERING
	VNET_PEERING RouteNextHopTypeEnum = 5
	// VIRTUAL NETWORK SERVICE ENDPOINT
	//
	// x-displayName: VIRTUAL NETWORK SERVICE ENDPOINT
	// VIRTUAL NETWORK SERVICE ENDPOINT
	VIRTUAL_NETWORK_SERVICE_ENDPOINT RouteNextHopTypeEnum = 6
	// NEXT_HOP_TYPE_NOT_APPLICABLE
	//
	// x-displayName: NEXT_HOP_TYPE_NOT_APPLICABLE
	// NEXT_HOP_TYPE_NOT_APPLICABLE should be used when the cloud provider doesn't support this.
	NEXT_HOP_TYPE_NOT_APPLICABLE RouteNextHopTypeEnum = 7
)

var RouteNextHopTypeEnum_name = map[int32]string{
	0: "VIRTUAL_NETWORK_GATEWAY",
	1: "VNET_LOCAL",
	2: "INTERNET",
	3: "VIRTUAL_APPLIANCE",
	4: "NONE",
	5: "VNET_PEERING",
	6: "VIRTUAL_NETWORK_SERVICE_ENDPOINT",
	7: "NEXT_HOP_TYPE_NOT_APPLICABLE",
}

var RouteNextHopTypeEnum_value = map[string]int32{
	"VIRTUAL_NETWORK_GATEWAY":          0,
	"VNET_LOCAL":                       1,
	"INTERNET":                         2,
	"VIRTUAL_APPLIANCE":                3,
	"NONE":                             4,
	"VNET_PEERING":                     5,
	"VIRTUAL_NETWORK_SERVICE_ENDPOINT": 6,
	"NEXT_HOP_TYPE_NOT_APPLICABLE":     7,
}

func (RouteNextHopTypeEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{6}
}

// PeeringState
//
// x-displayName: PeeringState
// Network Peering Status
type PeeringStateEnum int32

const (
	// Connected
	//
	// x-displayName: CONNECTED
	// CONNECTED Peering Status
	CONNECTED PeeringStateEnum = 0
	// DISCONNECTED
	//
	// x-displayName: DISCONNECTED
	// DISCONNECTED Peering Status
	DISCONNECTED PeeringStateEnum = 1
	// PEERING_INITIATED
	//
	// x-displayName: PEERING_INITIATED
	// PEERING_INITIATED
	PEERING_INITIATED PeeringStateEnum = 3
	// PEERING_STATE_NOT_APPLICABLE
	//
	// x-displayName: PEERING_STATE_NOT_APPLICABLE
	// PEERING_STATE_NOT_APPLICABLE should be used when a cloud provider does not supports it.
	PEERING_STATE_NOT_APPLICABLE PeeringStateEnum = 4
)

var PeeringStateEnum_name = map[int32]string{
	0: "CONNECTED",
	1: "DISCONNECTED",
	3: "PEERING_INITIATED",
	4: "PEERING_STATE_NOT_APPLICABLE",
}

var PeeringStateEnum_value = map[string]int32{
	"CONNECTED":                    0,
	"DISCONNECTED":                 1,
	"PEERING_INITIATED":            3,
	"PEERING_STATE_NOT_APPLICABLE": 4,
}

func (PeeringStateEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{7}
}

// Metadata
//
// x-displayName: "MetaType"
// A metadata for topology objects.
type MetaType struct {
	// ID
	//
	// x-displayName: "ID"
	// ID in the external system (such as cloud specific ID).
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	// Name in the external system.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Cloud Credentials
	//
	// x-displayName: "Cloud Credentials"
	// Reference to cloud credentials to fetch cloud resources.
	Creds []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=creds,proto3" json:"creds,omitempty"`
	// Raw JSON
	//
	// x-displayName: "Raw JSON"
	// raw json string
	RawJson string `protobuf:"bytes,5,opt,name=raw_json,json=rawJson,proto3" json:"raw_json,omitempty"`
	// Status
	//
	// x-displayName: "Status"
	// status of topology node
	Status string `protobuf:"bytes,6,opt,name=status,proto3" json:"status,omitempty"`
	// tags
	//
	// x-displayName: "Tags"
	// x-example: "value"
	// Map of string keys and values that annotated in the topology node.
	Tags map[string]string `protobuf:"bytes,7,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// OwnerID
	//
	// x-displayName: "Owner ID"
	// owner id in the cloud side.
	OwnerId string `protobuf:"bytes,8,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	// Provider Type
	//
	// x-displayName: "Provider Type"
	// provider type
	ProviderType ProviderType `protobuf:"varint,9,opt,name=provider_type,json=providerType,proto3,enum=ves.io.schema.topology.ProviderType" json:"provider_type,omitempty"`
}

func (m *MetaType) Reset()      { *m = MetaType{} }
func (*MetaType) ProtoMessage() {}
func (*MetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{0}
}
func (m *MetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaType.Merge(m, src)
}
func (m *MetaType) XXX_Size() int {
	return m.Size()
}
func (m *MetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaType.DiscardUnknown(m)
}

var xxx_messageInfo_MetaType proto.InternalMessageInfo

func (m *MetaType) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MetaType) GetCreds() []*schema.ObjectRefType {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *MetaType) GetRawJson() string {
	if m != nil {
		return m.RawJson
	}
	return ""
}

func (m *MetaType) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *MetaType) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *MetaType) GetOwnerId() string {
	if m != nil {
		return m.OwnerId
	}
	return ""
}

func (m *MetaType) GetProviderType() ProviderType {
	if m != nil {
		return m.ProviderType
	}
	return PROVIDER_TYPE_UNSPECIFIED
}

// Network
//
// x-displayName: "network"
// A canonical form of the network.
type NetworkType struct {
	// Region
	//
	// x-displayName: "Region"
	// Reference to the regions
	Region []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=region,proto3" json:"region,omitempty"`
	// IPv4 Cidr
	//
	// x-displayName: "IPv4 Cidr"
	// IPv4 Cidr
	CidrV4 []string `protobuf:"bytes,2,rep,name=cidr_v4,json=cidrV4,proto3" json:"cidr_v4,omitempty"`
	// IPv6 Cidr
	//
	// x-displayName: "IPv6 Cidr"
	// IPv6 Cidr
	CidrV6 []string `protobuf:"bytes,3,rep,name=cidr_v6,json=cidrV6,proto3" json:"cidr_v6,omitempty"`
	// Network peers
	//
	// x-displayName: "Network Peers"
	// Reference to the network peers
	NetworkPeers []*schema.ObjectRefType `protobuf:"bytes,4,rep,name=network_peers,json=networkPeers,proto3" json:"network_peers,omitempty"`
	// Load Balancer
	//
	// x-displayName: "Load Balancer"
	// Load Balancer Present in this Network
	LoadBalancer []*LoadBalancer `protobuf:"bytes,5,rep,name=load_balancer,json=loadBalancer,proto3" json:"load_balancer,omitempty"`
}

func (m *NetworkType) Reset()      { *m = NetworkType{} }
func (*NetworkType) ProtoMessage() {}
func (*NetworkType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{1}
}
func (m *NetworkType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkType.Merge(m, src)
}
func (m *NetworkType) XXX_Size() int {
	return m.Size()
}
func (m *NetworkType) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkType.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkType proto.InternalMessageInfo

func (m *NetworkType) GetRegion() []*schema.ObjectRefType {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *NetworkType) GetCidrV4() []string {
	if m != nil {
		return m.CidrV4
	}
	return nil
}

func (m *NetworkType) GetCidrV6() []string {
	if m != nil {
		return m.CidrV6
	}
	return nil
}

func (m *NetworkType) GetNetworkPeers() []*schema.ObjectRefType {
	if m != nil {
		return m.NetworkPeers
	}
	return nil
}

func (m *NetworkType) GetLoadBalancer() []*LoadBalancer {
	if m != nil {
		return m.LoadBalancer
	}
	return nil
}

// LB
//
// x-displayName: "Load Balancer"
// Load Balancer
type LoadBalancer struct {
	// Name
	//
	// x-displayName: "Name"
	// Name of the LB
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Id
	//
	// x-displayName: "Id"
	// Id of the LB
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *LoadBalancer) Reset()      { *m = LoadBalancer{} }
func (*LoadBalancer) ProtoMessage() {}
func (*LoadBalancer) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{2}
}
func (m *LoadBalancer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadBalancer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LoadBalancer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadBalancer.Merge(m, src)
}
func (m *LoadBalancer) XXX_Size() int {
	return m.Size()
}
func (m *LoadBalancer) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadBalancer.DiscardUnknown(m)
}

var xxx_messageInfo_LoadBalancer proto.InternalMessageInfo

func (m *LoadBalancer) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LoadBalancer) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Subnet
//
// x-displayName: "subnet"
// A canonical form of the subnet.
type SubnetType struct {
	// Network
	//
	// x-displayName: "Network"
	// Reference to the network
	Network []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=network,proto3" json:"network,omitempty"`
	// Region
	//
	// x-displayName: "Region"
	// Reference to the regions. (Used for GCP)
	Region []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=region,proto3" json:"region,omitempty"`
	// Availability Zone
	//
	// x-displayName: "Availability Zone"
	// Availability zone
	AvailabilityZone string `protobuf:"bytes,4,opt,name=availability_zone,json=availabilityZone,proto3" json:"availability_zone,omitempty"`
	// IPv4 Cidr
	//
	// x-displayName: "IPv4 Cidr"
	// IPv4 Cidr
	CidrV4 []string `protobuf:"bytes,5,rep,name=cidr_v4,json=cidrV4,proto3" json:"cidr_v4,omitempty"`
	// IPv6 Cidr
	//
	// x-displayName: "IPv6 Cidr"
	// IPv6 Cidr
	CidrV6 []string `protobuf:"bytes,6,rep,name=cidr_v6,json=cidrV6,proto3" json:"cidr_v6,omitempty"`
	// Subnet Type
	//
	// x-displayName: "Subnet Type"
	// Subnet Type
	InterfaceType InterfaceTypeEnum `protobuf:"varint,7,opt,name=interface_type,json=interfaceType,proto3,enum=ves.io.schema.topology.InterfaceTypeEnum" json:"interface_type,omitempty"`
}

func (m *SubnetType) Reset()      { *m = SubnetType{} }
func (*SubnetType) ProtoMessage() {}
func (*SubnetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{3}
}
func (m *SubnetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SubnetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetType.Merge(m, src)
}
func (m *SubnetType) XXX_Size() int {
	return m.Size()
}
func (m *SubnetType) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetType.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetType proto.InternalMessageInfo

func (m *SubnetType) GetNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *SubnetType) GetRegion() []*schema.ObjectRefType {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *SubnetType) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *SubnetType) GetCidrV4() []string {
	if m != nil {
		return m.CidrV4
	}
	return nil
}

func (m *SubnetType) GetCidrV6() []string {
	if m != nil {
		return m.CidrV6
	}
	return nil
}

func (m *SubnetType) GetInterfaceType() InterfaceTypeEnum {
	if m != nil {
		return m.InterfaceType
	}
	return OUTSIDE
}

// Instance
//
// x-displayName: "instance"
// A canonical form of the instance.
type InstanceType struct {
	// Interfaces
	//
	// x-displayName: "Network Interfaces"
	// A list of network interfaces
	Interfaces []*NetworkInterfaceType `protobuf:"bytes,1,rep,name=interfaces,proto3" json:"interfaces,omitempty"`
	// Architecture
	//
	// x-displayName: "Architecture"
	// Architecture
	Architecture string `protobuf:"bytes,2,opt,name=architecture,proto3" json:"architecture,omitempty"`
	// CPU
	//
	// x-displayName: "CPU Count"
	// CPU Count
	Cpu uint32 `protobuf:"varint,3,opt,name=cpu,proto3" json:"cpu,omitempty"`
	// Instance type
	//
	// x-displayName: "Instance type"
	// Instance type
	InstanceType string `protobuf:"bytes,4,opt,name=instance_type,json=instanceType,proto3" json:"instance_type,omitempty"`
	// Platform
	//
	// x-displayName: "Platform"
	// Platform
	Platform string `protobuf:"bytes,5,opt,name=platform,proto3" json:"platform,omitempty"`
	// Private addresse
	//
	// x-displayName: "Private Address"
	// Private Address
	PrivateAddress string `protobuf:"bytes,6,opt,name=private_address,json=privateAddress,proto3" json:"private_address,omitempty"`
	// Public address
	//
	// x-displayName: "Public Address"
	// Public address
	PublicAddress string `protobuf:"bytes,7,opt,name=public_address,json=publicAddress,proto3" json:"public_address,omitempty"`
	// Private DNS Name
	//
	// x-displayName: "Private DNS Name"
	// Private DNS Name
	PrivateDnsName string `protobuf:"bytes,8,opt,name=private_dns_name,json=privateDnsName,proto3" json:"private_dns_name,omitempty"`
	// Public DNS Name
	//
	// x-displayName: "Public DNS Name"
	// Public DNS Name
	PublicDnsName string `protobuf:"bytes,9,opt,name=public_dns_name,json=publicDnsName,proto3" json:"public_dns_name,omitempty"`
	// Security Groups
	//
	// x-displayName: "Security Groups"
	// Security groups
	SecurityGroup []string `protobuf:"bytes,10,rep,name=security_group,json=securityGroup,proto3" json:"security_group,omitempty"`
	// Availability Zone
	//
	// x-displayName: "Availability Zone"
	// Availability Zone
	AvailabilityZone string `protobuf:"bytes,11,opt,name=availability_zone,json=availabilityZone,proto3" json:"availability_zone,omitempty"`
}

func (m *InstanceType) Reset()      { *m = InstanceType{} }
func (*InstanceType) ProtoMessage() {}
func (*InstanceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{4}
}
func (m *InstanceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InstanceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceType.Merge(m, src)
}
func (m *InstanceType) XXX_Size() int {
	return m.Size()
}
func (m *InstanceType) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceType.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceType proto.InternalMessageInfo

func (m *InstanceType) GetInterfaces() []*NetworkInterfaceType {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

func (m *InstanceType) GetArchitecture() string {
	if m != nil {
		return m.Architecture
	}
	return ""
}

func (m *InstanceType) GetCpu() uint32 {
	if m != nil {
		return m.Cpu
	}
	return 0
}

func (m *InstanceType) GetInstanceType() string {
	if m != nil {
		return m.InstanceType
	}
	return ""
}

func (m *InstanceType) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *InstanceType) GetPrivateAddress() string {
	if m != nil {
		return m.PrivateAddress
	}
	return ""
}

func (m *InstanceType) GetPublicAddress() string {
	if m != nil {
		return m.PublicAddress
	}
	return ""
}

func (m *InstanceType) GetPrivateDnsName() string {
	if m != nil {
		return m.PrivateDnsName
	}
	return ""
}

func (m *InstanceType) GetPublicDnsName() string {
	if m != nil {
		return m.PublicDnsName
	}
	return ""
}

func (m *InstanceType) GetSecurityGroup() []string {
	if m != nil {
		return m.SecurityGroup
	}
	return nil
}

func (m *InstanceType) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

// TransitGateway
//
// x-displayName: "transit gateway"
// A canonical form of the transit gateway.
type TransitGatewayType struct {
	// Network
	//
	// x-displayName: "Network"
	// Reference to the network
	Network []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=network,proto3" json:"network,omitempty"`
	// Auto accept shared attachment
	//
	// x-displayName: "Auto accept shared attachment"
	// Auto accept shared attachment
	AutoAcceptSharedAttachments bool `protobuf:"varint,2,opt,name=auto_accept_shared_attachments,json=autoAcceptSharedAttachments,proto3" json:"auto_accept_shared_attachments,omitempty"`
	// DNS support
	//
	// x-displayName: "DNS Support"
	// DNS support
	DnsSupport bool `protobuf:"varint,3,opt,name=dns_support,json=dnsSupport,proto3" json:"dns_support,omitempty"`
	// vpn ecmp support
	//
	// x-displayName: "VpnEcmpSupport Support"
	// vpn ecmp support
	VpnEcmpSupport bool `protobuf:"varint,4,opt,name=vpn_ecmp_support,json=vpnEcmpSupport,proto3" json:"vpn_ecmp_support,omitempty"`
}

func (m *TransitGatewayType) Reset()      { *m = TransitGatewayType{} }
func (*TransitGatewayType) ProtoMessage() {}
func (*TransitGatewayType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{5}
}
func (m *TransitGatewayType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransitGatewayType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TransitGatewayType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransitGatewayType.Merge(m, src)
}
func (m *TransitGatewayType) XXX_Size() int {
	return m.Size()
}
func (m *TransitGatewayType) XXX_DiscardUnknown() {
	xxx_messageInfo_TransitGatewayType.DiscardUnknown(m)
}

var xxx_messageInfo_TransitGatewayType proto.InternalMessageInfo

func (m *TransitGatewayType) GetNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *TransitGatewayType) GetAutoAcceptSharedAttachments() bool {
	if m != nil {
		return m.AutoAcceptSharedAttachments
	}
	return false
}

func (m *TransitGatewayType) GetDnsSupport() bool {
	if m != nil {
		return m.DnsSupport
	}
	return false
}

func (m *TransitGatewayType) GetVpnEcmpSupport() bool {
	if m != nil {
		return m.VpnEcmpSupport
	}
	return false
}

// RouteTableType
//
// x-displayName: "Route Table"
// A canonical form of the route table.
type RouteTableType struct {
	// Subnet
	//
	// x-displayName: "Subnet"
	// Reference to the subnet.
	Subnet []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=subnet,proto3" json:"subnet,omitempty"`
	// Network
	//
	// x-displayName: "Network"
	// Reference to the network.
	Network []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=network,proto3" json:"network,omitempty"`
	// Transit Gateway
	//
	// x-displayName: "Transit Gateway"
	// Reference to the transit gateway if a transit gateway owns this resource.
	TransitGateway []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=transit_gateway,json=transitGateway,proto3" json:"transit_gateway,omitempty"`
	// Rotues
	//
	// x-displayName: "Routes"
	// list of routes
	Routes []*RouteType `protobuf:"bytes,4,rep,name=routes,proto3" json:"routes,omitempty"`
	// Rotue Table type
	//
	// x-displayName: "Route table type"
	// type of this route table.
	RouteTableType RouteTableTypeEnum `protobuf:"varint,5,opt,name=route_table_type,json=routeTableType,proto3,enum=ves.io.schema.topology.RouteTableTypeEnum" json:"route_table_type,omitempty"`
	// Implicit Subnet Association
	//
	// x-displayName: "Implicit Subnet Association"
	// Reference to the subnet implicitly accociated.
	ImplicitSubnet []*schema.ObjectRefType `protobuf:"bytes,7,rep,name=implicit_subnet,json=implicitSubnet,proto3" json:"implicit_subnet,omitempty"`
	// Explicit Subnet Association
	//
	// x-displayName: "Explicit Subnet Association"
	// Reference to the subnet explicitly accociated.
	ExplicitSubnet []*schema.ObjectRefType `protobuf:"bytes,8,rep,name=explicit_subnet,json=explicitSubnet,proto3" json:"explicit_subnet,omitempty"`
}

func (m *RouteTableType) Reset()      { *m = RouteTableType{} }
func (*RouteTableType) ProtoMessage() {}
func (*RouteTableType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{6}
}
func (m *RouteTableType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTableType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteTableType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTableType.Merge(m, src)
}
func (m *RouteTableType) XXX_Size() int {
	return m.Size()
}
func (m *RouteTableType) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTableType.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTableType proto.InternalMessageInfo

func (m *RouteTableType) GetSubnet() []*schema.ObjectRefType {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *RouteTableType) GetNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *RouteTableType) GetTransitGateway() []*schema.ObjectRefType {
	if m != nil {
		return m.TransitGateway
	}
	return nil
}

func (m *RouteTableType) GetRoutes() []*RouteType {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *RouteTableType) GetRouteTableType() RouteTableTypeEnum {
	if m != nil {
		return m.RouteTableType
	}
	return ROUTE_TABLE_NETWORK
}

func (m *RouteTableType) GetImplicitSubnet() []*schema.ObjectRefType {
	if m != nil {
		return m.ImplicitSubnet
	}
	return nil
}

func (m *RouteTableType) GetExplicitSubnet() []*schema.ObjectRefType {
	if m != nil {
		return m.ExplicitSubnet
	}
	return nil
}

// RouteType
//
// x-displayName: "Route Type"
// A canonical form of the route.
type RouteType struct {
	// Destination
	//
	// x-displayName: "Destination"
	// Destination
	Destination string `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	// Nexthop
	//
	// x-displayName: "Nexthop"
	// Nexthop (IP subnet or gateway ID)
	Nexthop string `protobuf:"bytes,2,opt,name=nexthop,proto3" json:"nexthop,omitempty"`
	// Source
	//
	// x-displayName: "Source"
	// Source of route entry
	Source RouteSourceTypeEnum `protobuf:"varint,3,opt,name=source,proto3,enum=ves.io.schema.topology.RouteSourceTypeEnum" json:"source,omitempty"`
	// State
	//
	// x-displayName: "State"
	// State of the route entry
	State RouteStateTypeEnum `protobuf:"varint,4,opt,name=state,proto3,enum=ves.io.schema.topology.RouteStateTypeEnum" json:"state,omitempty"`
	// Next Hop Type
	//
	// x-displayName: "Next Hop Type"
	// Next Hop Type of the route
	NextHopType RouteNextHopTypeEnum `protobuf:"varint,5,opt,name=next_hop_type,json=nextHopType,proto3,enum=ves.io.schema.topology.RouteNextHopTypeEnum" json:"next_hop_type,omitempty"`
	// User Defined Route Name
	//
	// x-displayName: "User Defined Route Name"
	// User Defined Route Name
	UserDefinedRouteName string `protobuf:"bytes,6,opt,name=user_defined_route_name,json=userDefinedRouteName,proto3" json:"user_defined_route_name,omitempty"`
}

func (m *RouteType) Reset()      { *m = RouteType{} }
func (*RouteType) ProtoMessage() {}
func (*RouteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{7}
}
func (m *RouteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteType.Merge(m, src)
}
func (m *RouteType) XXX_Size() int {
	return m.Size()
}
func (m *RouteType) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteType.DiscardUnknown(m)
}

var xxx_messageInfo_RouteType proto.InternalMessageInfo

func (m *RouteType) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *RouteType) GetNexthop() string {
	if m != nil {
		return m.Nexthop
	}
	return ""
}

func (m *RouteType) GetSource() RouteSourceTypeEnum {
	if m != nil {
		return m.Source
	}
	return INVALID_SOURCE
}

func (m *RouteType) GetState() RouteStateTypeEnum {
	if m != nil {
		return m.State
	}
	return ACTIVE_STATE
}

func (m *RouteType) GetNextHopType() RouteNextHopTypeEnum {
	if m != nil {
		return m.NextHopType
	}
	return VIRTUAL_NETWORK_GATEWAY
}

func (m *RouteType) GetUserDefinedRouteName() string {
	if m != nil {
		return m.UserDefinedRouteName
	}
	return ""
}

// Site
//
// x-displayName: "site"
// A canonical form of the site.
type SiteType struct {
	// Network
	//
	// x-displayName: "Network"
	// Reference to the network.
	Network []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=network,proto3" json:"network,omitempty"`
	// TransitGateway
	//
	// x-displayName: "TransitGateway"
	// Reference to the transit gateway
	Tgw []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=tgw,proto3" json:"tgw,omitempty"`
	// DC Cluster Group
	//
	// x-displayName: "DC Cluster Group"
	// Reference to the DC Cluster group
	DcClusterGroup []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=dc_cluster_group,json=dcClusterGroup,proto3" json:"dc_cluster_group,omitempty"`
	// Site type
	//
	// x-displayName: "Site Type"
	// Site type indicates whether the site is CUSTOMER_EDGE or REGIONAL_EDGE
	SiteType site.SiteType `protobuf:"varint,4,opt,name=site_type,json=siteType,proto3,enum=ves.io.schema.site.SiteType" json:"site_type,omitempty"`
}

func (m *SiteType) Reset()      { *m = SiteType{} }
func (*SiteType) ProtoMessage() {}
func (*SiteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{8}
}
func (m *SiteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SiteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteType.Merge(m, src)
}
func (m *SiteType) XXX_Size() int {
	return m.Size()
}
func (m *SiteType) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteType.DiscardUnknown(m)
}

var xxx_messageInfo_SiteType proto.InternalMessageInfo

func (m *SiteType) GetNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *SiteType) GetTgw() []*schema.ObjectRefType {
	if m != nil {
		return m.Tgw
	}
	return nil
}

func (m *SiteType) GetDcClusterGroup() []*schema.ObjectRefType {
	if m != nil {
		return m.DcClusterGroup
	}
	return nil
}

func (m *SiteType) GetSiteType() site.SiteType {
	if m != nil {
		return m.SiteType
	}
	return site.INVALID
}

// Site Mesh Group
//
// x-displayName: "site Mesh Group"
// A canonical form of the site mesh group.
type SiteMeshGroupType struct {
	// Type
	//
	// x-displayName: "Type"
	// Site Mesh Group Type
	Type site_mesh_group.SiteMeshGroupType `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.site_mesh_group.SiteMeshGroupType" json:"type,omitempty"`
	// site_type
	//
	// x-displayName: "Site Type"
	// Site type for sites in the virtual site
	SiteType site.SiteType `protobuf:"varint,4,opt,name=site_type,json=siteType,proto3,enum=ves.io.schema.site.SiteType" json:"site_type,omitempty"`
	// virtual_site
	//
	// x-displayName: "Virtual Site"
	// Virtual Site referenced in this site_mesh_group
	VirtualSite []*schema.ObjectRefType `protobuf:"bytes,9,rep,name=virtual_site,json=virtualSite,proto3" json:"virtual_site,omitempty"`
	// Hub
	//
	// x-displayName: "Hub (site mesh group)"
	// If 'Type' is Spoke, 'Hub' refers to a Site Mesh Group of 'type' Hub.
	// Spoke sites connect to all the member sites of Hub Site Mesh Group.
	// Hub will be empty when Site Mesh Group type is Hub or Full Mesh.
	Hub []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=hub,proto3" json:"hub,omitempty"`
	// Mesh Choice
	//
	// x-displayName: "Mesh Choice"
	// Type of Site to Site connectivity (Spoke, Hub or Full Mesh)
	//
	// Types that are valid to be assigned to MeshChoice:
	//	*SiteMeshGroupType_HubMesh
	//	*SiteMeshGroupType_SpokeMesh
	//	*SiteMeshGroupType_FullMesh
	MeshChoice isSiteMeshGroupType_MeshChoice `protobuf_oneof:"mesh_choice"`
	// Topology Site Reference
	//
	// x-displayName: "Topology Site"
	// Topology Sites referenced in this site_mesh_group
	TopologySite []*schema.ObjectRefType `protobuf:"bytes,10,rep,name=topology_site,json=topologySite,proto3" json:"topology_site,omitempty"`
}

func (m *SiteMeshGroupType) Reset()      { *m = SiteMeshGroupType{} }
func (*SiteMeshGroupType) ProtoMessage() {}
func (*SiteMeshGroupType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{9}
}
func (m *SiteMeshGroupType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteMeshGroupType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SiteMeshGroupType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteMeshGroupType.Merge(m, src)
}
func (m *SiteMeshGroupType) XXX_Size() int {
	return m.Size()
}
func (m *SiteMeshGroupType) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteMeshGroupType.DiscardUnknown(m)
}

var xxx_messageInfo_SiteMeshGroupType proto.InternalMessageInfo

type isSiteMeshGroupType_MeshChoice interface {
	isSiteMeshGroupType_MeshChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SiteMeshGroupType_HubMesh struct {
	HubMesh *site_mesh_group.HubFullMeshGroupType `protobuf:"bytes,6,opt,name=hub_mesh,json=hubMesh,proto3,oneof" json:"hub_mesh,omitempty"`
}
type SiteMeshGroupType_SpokeMesh struct {
	SpokeMesh *site_mesh_group.SpokeMeshGroupType `protobuf:"bytes,7,opt,name=spoke_mesh,json=spokeMesh,proto3,oneof" json:"spoke_mesh,omitempty"`
}
type SiteMeshGroupType_FullMesh struct {
	FullMesh *site_mesh_group.FullMeshGroupType `protobuf:"bytes,8,opt,name=full_mesh,json=fullMesh,proto3,oneof" json:"full_mesh,omitempty"`
}

func (*SiteMeshGroupType_HubMesh) isSiteMeshGroupType_MeshChoice()   {}
func (*SiteMeshGroupType_SpokeMesh) isSiteMeshGroupType_MeshChoice() {}
func (*SiteMeshGroupType_FullMesh) isSiteMeshGroupType_MeshChoice()  {}

func (m *SiteMeshGroupType) GetMeshChoice() isSiteMeshGroupType_MeshChoice {
	if m != nil {
		return m.MeshChoice
	}
	return nil
}

func (m *SiteMeshGroupType) GetType() site_mesh_group.SiteMeshGroupType {
	if m != nil {
		return m.Type
	}
	return site_mesh_group.SITE_MESH_GROUP_TYPE_INVALID
}

func (m *SiteMeshGroupType) GetSiteType() site.SiteType {
	if m != nil {
		return m.SiteType
	}
	return site.INVALID
}

func (m *SiteMeshGroupType) GetVirtualSite() []*schema.ObjectRefType {
	if m != nil {
		return m.VirtualSite
	}
	return nil
}

func (m *SiteMeshGroupType) GetHub() []*schema.ObjectRefType {
	if m != nil {
		return m.Hub
	}
	return nil
}

func (m *SiteMeshGroupType) GetHubMesh() *site_mesh_group.HubFullMeshGroupType {
	if x, ok := m.GetMeshChoice().(*SiteMeshGroupType_HubMesh); ok {
		return x.HubMesh
	}
	return nil
}

func (m *SiteMeshGroupType) GetSpokeMesh() *site_mesh_group.SpokeMeshGroupType {
	if x, ok := m.GetMeshChoice().(*SiteMeshGroupType_SpokeMesh); ok {
		return x.SpokeMesh
	}
	return nil
}

func (m *SiteMeshGroupType) GetFullMesh() *site_mesh_group.FullMeshGroupType {
	if x, ok := m.GetMeshChoice().(*SiteMeshGroupType_FullMesh); ok {
		return x.FullMesh
	}
	return nil
}

func (m *SiteMeshGroupType) GetTopologySite() []*schema.ObjectRefType {
	if m != nil {
		return m.TopologySite
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SiteMeshGroupType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SiteMeshGroupType_HubMesh)(nil),
		(*SiteMeshGroupType_SpokeMesh)(nil),
		(*SiteMeshGroupType_FullMesh)(nil),
	}
}

// DC Cluster Group
//
// x-displayName: "DC Cluster Group"
// A canonical form of the DC cluster group.
type DCClusterGroupType struct {
	Type *dc_cluster_group.DCClusterGroupMeshType `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *DCClusterGroupType) Reset()      { *m = DCClusterGroupType{} }
func (*DCClusterGroupType) ProtoMessage() {}
func (*DCClusterGroupType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{10}
}
func (m *DCClusterGroupType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DCClusterGroupType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DCClusterGroupType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DCClusterGroupType.Merge(m, src)
}
func (m *DCClusterGroupType) XXX_Size() int {
	return m.Size()
}
func (m *DCClusterGroupType) XXX_DiscardUnknown() {
	xxx_messageInfo_DCClusterGroupType.DiscardUnknown(m)
}

var xxx_messageInfo_DCClusterGroupType proto.InternalMessageInfo

func (m *DCClusterGroupType) GetType() *dc_cluster_group.DCClusterGroupMeshType {
	if m != nil {
		return m.Type
	}
	return nil
}

// Network Interface
//
// x-displayName: "Network Interface"
// A canonical form of the network interface.
type NetworkInterfaceType struct {
	// Subnets
	//
	// x-displayName: "Subnets"
	// Reference to the subnets connected
	Subnet []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=subnet,proto3" json:"subnet,omitempty"`
	// Status
	//
	// x-displayName: "Status"
	// Status
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// Private addresses
	//
	// x-displayName: "Private Addresses"
	// Private Address
	PrivateAddresses []*AddressInfoType `protobuf:"bytes,3,rep,name=private_addresses,json=privateAddresses,proto3" json:"private_addresses,omitempty"`
	// Public address
	//
	// x-displayName: "Public Address"
	// Public address
	PublicAddress []*AddressInfoType `protobuf:"bytes,4,rep,name=public_address,json=publicAddress,proto3" json:"public_address,omitempty"`
	// Security Groups
	//
	// x-displayName: "Security Groups"
	// Security groups
	SecurityGroup []string `protobuf:"bytes,5,rep,name=security_group,json=securityGroup,proto3" json:"security_group,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	// Name of this interface
	Name string `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *NetworkInterfaceType) Reset()      { *m = NetworkInterfaceType{} }
func (*NetworkInterfaceType) ProtoMessage() {}
func (*NetworkInterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{11}
}
func (m *NetworkInterfaceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkInterfaceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkInterfaceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInterfaceType.Merge(m, src)
}
func (m *NetworkInterfaceType) XXX_Size() int {
	return m.Size()
}
func (m *NetworkInterfaceType) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInterfaceType.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInterfaceType proto.InternalMessageInfo

func (m *NetworkInterfaceType) GetSubnet() []*schema.ObjectRefType {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *NetworkInterfaceType) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *NetworkInterfaceType) GetPrivateAddresses() []*AddressInfoType {
	if m != nil {
		return m.PrivateAddresses
	}
	return nil
}

func (m *NetworkInterfaceType) GetPublicAddress() []*AddressInfoType {
	if m != nil {
		return m.PublicAddress
	}
	return nil
}

func (m *NetworkInterfaceType) GetSecurityGroup() []string {
	if m != nil {
		return m.SecurityGroup
	}
	return nil
}

func (m *NetworkInterfaceType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Address Info Type
//
// x-displayName: "Address Info Type"
// Address with additional information
type AddressInfoType struct {
	// Address
	//
	// x-displayName: "Address"
	// Address
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// DNS Name
	//
	// x-displayName: "Public Address"
	// Address type
	DnsName string `protobuf:"bytes,3,opt,name=dns_name,json=dnsName,proto3" json:"dns_name,omitempty"`
	// Primary
	//
	// x-displayName: "Primary"
	// Indicate this address is primary or not
	Primary bool `protobuf:"varint,4,opt,name=primary,proto3" json:"primary,omitempty"`
}

func (m *AddressInfoType) Reset()      { *m = AddressInfoType{} }
func (*AddressInfoType) ProtoMessage() {}
func (*AddressInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{12}
}
func (m *AddressInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AddressInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressInfoType.Merge(m, src)
}
func (m *AddressInfoType) XXX_Size() int {
	return m.Size()
}
func (m *AddressInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_AddressInfoType proto.InternalMessageInfo

func (m *AddressInfoType) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *AddressInfoType) GetDnsName() string {
	if m != nil {
		return m.DnsName
	}
	return ""
}

func (m *AddressInfoType) GetPrimary() bool {
	if m != nil {
		return m.Primary
	}
	return false
}

// TunnelSetType
//
// x-displayName: "tunnel set type"
// A canonical form of the tunnel set of the site.
type TunnelSetType struct {
	// Site
	//
	// x-displayName: "Site"
	// Reference to source of tunnels.
	Site []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=site,proto3" json:"site,omitempty"`
	// Tunnnels
	//
	// x-displayName: "Tunnels"
	// Tunnel status.
	Tunnels []*TunnelType `protobuf:"bytes,2,rep,name=tunnels,proto3" json:"tunnels,omitempty"`
}

func (m *TunnelSetType) Reset()      { *m = TunnelSetType{} }
func (*TunnelSetType) ProtoMessage() {}
func (*TunnelSetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{13}
}
func (m *TunnelSetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelSetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TunnelSetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelSetType.Merge(m, src)
}
func (m *TunnelSetType) XXX_Size() int {
	return m.Size()
}
func (m *TunnelSetType) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelSetType.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelSetType proto.InternalMessageInfo

func (m *TunnelSetType) GetSite() []*schema.ObjectRefType {
	if m != nil {
		return m.Site
	}
	return nil
}

func (m *TunnelSetType) GetTunnels() []*TunnelType {
	if m != nil {
		return m.Tunnels
	}
	return nil
}

// NetworkPeerType
//
// x-displayName: "NetworkPeerType"
// A canonical form of the NetworkPeerType
type NetworkPeerType struct {
	// Peer Choice
	//
	// x-displayName: "Peer Choice"
	// Specify the Peer
	//
	// Types that are valid to be assigned to PeerChoice:
	//	*NetworkPeerType_VnetPeer
	PeerChoice isNetworkPeerType_PeerChoice `protobuf_oneof:"peer_choice"`
}

func (m *NetworkPeerType) Reset()      { *m = NetworkPeerType{} }
func (*NetworkPeerType) ProtoMessage() {}
func (*NetworkPeerType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{14}
}
func (m *NetworkPeerType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkPeerType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkPeerType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkPeerType.Merge(m, src)
}
func (m *NetworkPeerType) XXX_Size() int {
	return m.Size()
}
func (m *NetworkPeerType) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkPeerType.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkPeerType proto.InternalMessageInfo

type isNetworkPeerType_PeerChoice interface {
	isNetworkPeerType_PeerChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type NetworkPeerType_VnetPeer struct {
	VnetPeer *AzureVnetPeer `protobuf:"bytes,2,opt,name=vnet_peer,json=vnetPeer,proto3,oneof" json:"vnet_peer,omitempty"`
}

func (*NetworkPeerType_VnetPeer) isNetworkPeerType_PeerChoice() {}

func (m *NetworkPeerType) GetPeerChoice() isNetworkPeerType_PeerChoice {
	if m != nil {
		return m.PeerChoice
	}
	return nil
}

func (m *NetworkPeerType) GetVnetPeer() *AzureVnetPeer {
	if x, ok := m.GetPeerChoice().(*NetworkPeerType_VnetPeer); ok {
		return x.VnetPeer
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NetworkPeerType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NetworkPeerType_VnetPeer)(nil),
	}
}

// AzureVnetPeer
//
// x-displayName: "AzureVnetPeer"
// AzureVnetPeer
type AzureVnetPeer struct {
	// Azure VNET Peer Network
	//
	// x-displayName: "Azure VNET Peer Network"
	// Reference to source of Network.
	PeerNetwork []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=peer_network,json=peerNetwork,proto3" json:"peer_network,omitempty"`
	// Peering State
	//
	// x-displayName: "Peering State"
	// Peering State
	PeeringState PeeringStateEnum `protobuf:"varint,2,opt,name=peering_state,json=peeringState,proto3,enum=ves.io.schema.topology.PeeringStateEnum" json:"peering_state,omitempty"`
}

func (m *AzureVnetPeer) Reset()      { *m = AzureVnetPeer{} }
func (*AzureVnetPeer) ProtoMessage() {}
func (*AzureVnetPeer) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{15}
}
func (m *AzureVnetPeer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureVnetPeer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureVnetPeer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureVnetPeer.Merge(m, src)
}
func (m *AzureVnetPeer) XXX_Size() int {
	return m.Size()
}
func (m *AzureVnetPeer) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureVnetPeer.DiscardUnknown(m)
}

var xxx_messageInfo_AzureVnetPeer proto.InternalMessageInfo

func (m *AzureVnetPeer) GetPeerNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.PeerNetwork
	}
	return nil
}

func (m *AzureVnetPeer) GetPeeringState() PeeringStateEnum {
	if m != nil {
		return m.PeeringState
	}
	return CONNECTED
}

// TunnelType
//
// x-displayName: "tunnel type"
// A canonical form of the tunnel.
type TunnelType struct {
	// Connection Status
	//
	// x-displayName: "Connection Status"
	// Connection status.
	Connection *site.TunnelConnectionStatus `protobuf:"bytes,1,opt,name=connection,proto3" json:"connection,omitempty"`
	// Site
	//
	// x-displayName: "Site"
	// Reference to the connected site.
	Site []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=site,proto3" json:"site,omitempty"`
	// TransitGateway
	//
	// x-displayName: "TransitGateway"
	// Reference to the connected transit gateway
	Tgw []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=tgw,proto3" json:"tgw,omitempty"`
}

func (m *TunnelType) Reset()      { *m = TunnelType{} }
func (*TunnelType) ProtoMessage() {}
func (*TunnelType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{16}
}
func (m *TunnelType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TunnelType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelType.Merge(m, src)
}
func (m *TunnelType) XXX_Size() int {
	return m.Size()
}
func (m *TunnelType) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelType.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelType proto.InternalMessageInfo

func (m *TunnelType) GetConnection() *site.TunnelConnectionStatus {
	if m != nil {
		return m.Connection
	}
	return nil
}

func (m *TunnelType) GetSite() []*schema.ObjectRefType {
	if m != nil {
		return m.Site
	}
	return nil
}

func (m *TunnelType) GetTgw() []*schema.ObjectRefType {
	if m != nil {
		return m.Tgw
	}
	return nil
}

// CloudPolicyType
//
// x-displayName: "Cloud Policy Type"
// Cloud related policy info
type CloudPolicyType struct {
	// Cloud Provider Policy Type
	//
	// x-displayName: "Cloud Provider Policy Type"
	// Specify one of the policy types
	//
	// Types that are valid to be assigned to CloudType:
	//	*CloudPolicyType_Aws
	CloudType isCloudPolicyType_CloudType `protobuf_oneof:"cloud_type"`
	//"Are Permissions Populated"
	//
	// x-displayName: "Are Permissions Populated"
	// Are Permissions populated
	PermissionsPopulated bool `protobuf:"varint,5,opt,name=permissions_populated,json=permissionsPopulated,proto3" json:"permissions_populated,omitempty"`
	//"Cloud Provider Error"
	//
	// x-displayName: "Cloud Provider Error"
	// Cloud provider error when retreiving permissions
	CloudProviderError string `protobuf:"bytes,6,opt,name=cloud_provider_error,json=cloudProviderError,proto3" json:"cloud_provider_error,omitempty"`
}

func (m *CloudPolicyType) Reset()      { *m = CloudPolicyType{} }
func (*CloudPolicyType) ProtoMessage() {}
func (*CloudPolicyType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{17}
}
func (m *CloudPolicyType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudPolicyType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloudPolicyType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudPolicyType.Merge(m, src)
}
func (m *CloudPolicyType) XXX_Size() int {
	return m.Size()
}
func (m *CloudPolicyType) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudPolicyType.DiscardUnknown(m)
}

var xxx_messageInfo_CloudPolicyType proto.InternalMessageInfo

type isCloudPolicyType_CloudType interface {
	isCloudPolicyType_CloudType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CloudPolicyType_Aws struct {
	Aws *AWSPolicyType `protobuf:"bytes,2,opt,name=aws,proto3,oneof" json:"aws,omitempty"`
}

func (*CloudPolicyType_Aws) isCloudPolicyType_CloudType() {}

func (m *CloudPolicyType) GetCloudType() isCloudPolicyType_CloudType {
	if m != nil {
		return m.CloudType
	}
	return nil
}

func (m *CloudPolicyType) GetAws() *AWSPolicyType {
	if x, ok := m.GetCloudType().(*CloudPolicyType_Aws); ok {
		return x.Aws
	}
	return nil
}

func (m *CloudPolicyType) GetPermissionsPopulated() bool {
	if m != nil {
		return m.PermissionsPopulated
	}
	return false
}

func (m *CloudPolicyType) GetCloudProviderError() string {
	if m != nil {
		return m.CloudProviderError
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CloudPolicyType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CloudPolicyType_Aws)(nil),
	}
}

// AWSPolicyType
//
// x-displayName: "AWS Policy Type"
// AWS policy info
type AWSPolicyType struct {
	// AWS VPC Site Support
	//
	// x-displayName: "AWS VPC Site Support"
	// Is aws vpc site enabled
	SupportAwsVpcSite bool `protobuf:"varint,1,opt,name=support_aws_vpc_site,json=supportAwsVpcSite,proto3" json:"support_aws_vpc_site,omitempty"`
	// "Missing Permissions At AWS VPC Site"
	//
	// x-displayName: "Missing Permissions At AWS VPC Site"
	// List of missing permissions at AWS VPC Site"
	MissingPermissionsAwsVpcSite []string `protobuf:"bytes,2,rep,name=missing_permissions_aws_vpc_site,json=missingPermissionsAwsVpcSite,proto3" json:"missing_permissions_aws_vpc_site,omitempty"`
	// "AWS TGW Site Support"
	//
	// x-displayName: "AWS TGW Site Support"
	// Is aws tgw site enabled
	SupportAwsTgwSite bool `protobuf:"varint,3,opt,name=support_aws_tgw_site,json=supportAwsTgwSite,proto3" json:"support_aws_tgw_site,omitempty"`
	// "Missing Permissions At AWS TGW Site"
	//
	// x-displayName: "Missing Permissions At AWS TGW Site"
	// List of missing permissions at AWS TGW Site"
	MissingPermissionsAwsTgwSite []string `protobuf:"bytes,4,rep,name=missing_permissions_aws_tgw_site,json=missingPermissionsAwsTgwSite,proto3" json:"missing_permissions_aws_tgw_site,omitempty"`
}

func (m *AWSPolicyType) Reset()      { *m = AWSPolicyType{} }
func (*AWSPolicyType) ProtoMessage() {}
func (*AWSPolicyType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{18}
}
func (m *AWSPolicyType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSPolicyType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSPolicyType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSPolicyType.Merge(m, src)
}
func (m *AWSPolicyType) XXX_Size() int {
	return m.Size()
}
func (m *AWSPolicyType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSPolicyType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSPolicyType proto.InternalMessageInfo

func (m *AWSPolicyType) GetSupportAwsVpcSite() bool {
	if m != nil {
		return m.SupportAwsVpcSite
	}
	return false
}

func (m *AWSPolicyType) GetMissingPermissionsAwsVpcSite() []string {
	if m != nil {
		return m.MissingPermissionsAwsVpcSite
	}
	return nil
}

func (m *AWSPolicyType) GetSupportAwsTgwSite() bool {
	if m != nil {
		return m.SupportAwsTgwSite
	}
	return false
}

func (m *AWSPolicyType) GetMissingPermissionsAwsTgwSite() []string {
	if m != nil {
		return m.MissingPermissionsAwsTgwSite
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.topology.ProviderType", ProviderType_name, ProviderType_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.ProviderType", ProviderType_name, ProviderType_value)
	proto.RegisterEnum("ves.io.schema.topology.SiteEnumType", SiteEnumType_name, SiteEnumType_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.SiteEnumType", SiteEnumType_name, SiteEnumType_value)
	proto.RegisterEnum("ves.io.schema.topology.RouteTableTypeEnum", RouteTableTypeEnum_name, RouteTableTypeEnum_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.RouteTableTypeEnum", RouteTableTypeEnum_name, RouteTableTypeEnum_value)
	proto.RegisterEnum("ves.io.schema.topology.InterfaceTypeEnum", InterfaceTypeEnum_name, InterfaceTypeEnum_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.InterfaceTypeEnum", InterfaceTypeEnum_name, InterfaceTypeEnum_value)
	proto.RegisterEnum("ves.io.schema.topology.RouteSourceTypeEnum", RouteSourceTypeEnum_name, RouteSourceTypeEnum_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.RouteSourceTypeEnum", RouteSourceTypeEnum_name, RouteSourceTypeEnum_value)
	proto.RegisterEnum("ves.io.schema.topology.RouteStateTypeEnum", RouteStateTypeEnum_name, RouteStateTypeEnum_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.RouteStateTypeEnum", RouteStateTypeEnum_name, RouteStateTypeEnum_value)
	proto.RegisterEnum("ves.io.schema.topology.RouteNextHopTypeEnum", RouteNextHopTypeEnum_name, RouteNextHopTypeEnum_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.RouteNextHopTypeEnum", RouteNextHopTypeEnum_name, RouteNextHopTypeEnum_value)
	proto.RegisterEnum("ves.io.schema.topology.PeeringStateEnum", PeeringStateEnum_name, PeeringStateEnum_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.PeeringStateEnum", PeeringStateEnum_name, PeeringStateEnum_value)
	proto.RegisterType((*MetaType)(nil), "ves.io.schema.topology.MetaType")
	golang_proto.RegisterType((*MetaType)(nil), "ves.io.schema.topology.MetaType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.topology.MetaType.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.topology.MetaType.TagsEntry")
	proto.RegisterType((*NetworkType)(nil), "ves.io.schema.topology.NetworkType")
	golang_proto.RegisterType((*NetworkType)(nil), "ves.io.schema.topology.NetworkType")
	proto.RegisterType((*LoadBalancer)(nil), "ves.io.schema.topology.LoadBalancer")
	golang_proto.RegisterType((*LoadBalancer)(nil), "ves.io.schema.topology.LoadBalancer")
	proto.RegisterType((*SubnetType)(nil), "ves.io.schema.topology.SubnetType")
	golang_proto.RegisterType((*SubnetType)(nil), "ves.io.schema.topology.SubnetType")
	proto.RegisterType((*InstanceType)(nil), "ves.io.schema.topology.InstanceType")
	golang_proto.RegisterType((*InstanceType)(nil), "ves.io.schema.topology.InstanceType")
	proto.RegisterType((*TransitGatewayType)(nil), "ves.io.schema.topology.TransitGatewayType")
	golang_proto.RegisterType((*TransitGatewayType)(nil), "ves.io.schema.topology.TransitGatewayType")
	proto.RegisterType((*RouteTableType)(nil), "ves.io.schema.topology.RouteTableType")
	golang_proto.RegisterType((*RouteTableType)(nil), "ves.io.schema.topology.RouteTableType")
	proto.RegisterType((*RouteType)(nil), "ves.io.schema.topology.RouteType")
	golang_proto.RegisterType((*RouteType)(nil), "ves.io.schema.topology.RouteType")
	proto.RegisterType((*SiteType)(nil), "ves.io.schema.topology.SiteType")
	golang_proto.RegisterType((*SiteType)(nil), "ves.io.schema.topology.SiteType")
	proto.RegisterType((*SiteMeshGroupType)(nil), "ves.io.schema.topology.SiteMeshGroupType")
	golang_proto.RegisterType((*SiteMeshGroupType)(nil), "ves.io.schema.topology.SiteMeshGroupType")
	proto.RegisterType((*DCClusterGroupType)(nil), "ves.io.schema.topology.DCClusterGroupType")
	golang_proto.RegisterType((*DCClusterGroupType)(nil), "ves.io.schema.topology.DCClusterGroupType")
	proto.RegisterType((*NetworkInterfaceType)(nil), "ves.io.schema.topology.NetworkInterfaceType")
	golang_proto.RegisterType((*NetworkInterfaceType)(nil), "ves.io.schema.topology.NetworkInterfaceType")
	proto.RegisterType((*AddressInfoType)(nil), "ves.io.schema.topology.AddressInfoType")
	golang_proto.RegisterType((*AddressInfoType)(nil), "ves.io.schema.topology.AddressInfoType")
	proto.RegisterType((*TunnelSetType)(nil), "ves.io.schema.topology.TunnelSetType")
	golang_proto.RegisterType((*TunnelSetType)(nil), "ves.io.schema.topology.TunnelSetType")
	proto.RegisterType((*NetworkPeerType)(nil), "ves.io.schema.topology.NetworkPeerType")
	golang_proto.RegisterType((*NetworkPeerType)(nil), "ves.io.schema.topology.NetworkPeerType")
	proto.RegisterType((*AzureVnetPeer)(nil), "ves.io.schema.topology.AzureVnetPeer")
	golang_proto.RegisterType((*AzureVnetPeer)(nil), "ves.io.schema.topology.AzureVnetPeer")
	proto.RegisterType((*TunnelType)(nil), "ves.io.schema.topology.TunnelType")
	golang_proto.RegisterType((*TunnelType)(nil), "ves.io.schema.topology.TunnelType")
	proto.RegisterType((*CloudPolicyType)(nil), "ves.io.schema.topology.CloudPolicyType")
	golang_proto.RegisterType((*CloudPolicyType)(nil), "ves.io.schema.topology.CloudPolicyType")
	proto.RegisterType((*AWSPolicyType)(nil), "ves.io.schema.topology.AWSPolicyType")
	golang_proto.RegisterType((*AWSPolicyType)(nil), "ves.io.schema.topology.AWSPolicyType")
}

func init() {
	proto.RegisterFile("ves.io/schema/topology/types.proto", fileDescriptor_e89c101129b5baba)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/topology/types.proto", fileDescriptor_e89c101129b5baba)
}

var fileDescriptor_e89c101129b5baba = []byte{
	// 2608 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x59, 0xcd, 0x6f, 0xe3, 0xc6,
	0x15, 0x17, 0x29, 0xc9, 0x96, 0x9f, 0x3e, 0x4c, 0xcf, 0x7a, 0x77, 0xb5, 0x1f, 0x51, 0x5d, 0x35,
	0x69, 0x36, 0x4e, 0x22, 0xa7, 0x4e, 0x9a, 0x36, 0x45, 0x51, 0x54, 0x96, 0xb9, 0x6b, 0x79, 0x1d,
	0x4a, 0xa0, 0x68, 0xbb, 0x49, 0x81, 0x32, 0x14, 0x35, 0x96, 0x98, 0xa5, 0x48, 0x82, 0x1c, 0xca,
	0xeb, 0x00, 0x06, 0xd2, 0x6b, 0xd1, 0x02, 0x69, 0xef, 0xbd, 0x17, 0xbe, 0x15, 0x28, 0x7a, 0x68,
	0x72, 0xd8, 0x4b, 0x80, 0x16, 0xe8, 0x61, 0x7b, 0xea, 0xb6, 0xa7, 0xac, 0xf7, 0xd2, 0xdc, 0xd2,
	0xff, 0xa0, 0x98, 0x21, 0x29, 0x91, 0xb2, 0xbd, 0xf6, 0x76, 0xf7, 0x36, 0xf3, 0x3e, 0x7e, 0xf3,
	0xe6, 0xbd, 0x37, 0x6f, 0xde, 0x90, 0x50, 0x1d, 0x61, 0xaf, 0x66, 0xd8, 0x2b, 0x9e, 0x3e, 0xc0,
	0x43, 0x6d, 0x85, 0xd8, 0x8e, 0x6d, 0xda, 0xfd, 0x83, 0x15, 0x72, 0xe0, 0x60, 0xaf, 0xe6, 0xb8,
	0x36, 0xb1, 0xd1, 0x95, 0x40, 0xa6, 0x16, 0xc8, 0xd4, 0x22, 0x99, 0xeb, 0x6f, 0xf6, 0x0d, 0x32,
	0xf0, 0xbb, 0x35, 0xdd, 0x1e, 0xae, 0xf4, 0xed, 0xbe, 0xbd, 0xc2, 0xc4, 0xbb, 0xfe, 0x1e, 0x9b,
	0xb1, 0x09, 0x1b, 0x05, 0x30, 0xd7, 0xaf, 0xf5, 0x6d, 0xbb, 0x6f, 0xe2, 0x89, 0x94, 0x66, 0x1d,
	0x84, 0xac, 0xe5, 0xa4, 0x15, 0x3d, 0x5d, 0xd5, 0x4d, 0xdf, 0x23, 0xd8, 0x55, 0xfb, 0xae, 0xed,
	0x3b, 0x71, 0x6b, 0xae, 0x5f, 0x4d, 0xca, 0x5a, 0x98, 0x84, 0x8c, 0x1b, 0x49, 0x86, 0xed, 0x10,
	0xc3, 0xb6, 0x22, 0xad, 0x4a, 0x92, 0xe9, 0x19, 0x04, 0x27, 0x50, 0x5f, 0x3b, 0xc9, 0x57, 0x87,
	0xd8, 0x1b, 0x9c, 0x62, 0xc0, 0xb5, 0x29, 0x97, 0xc5, 0x58, 0x37, 0x93, 0xac, 0x91, 0x66, 0x1a,
	0x3d, 0x8d, 0xe0, 0x90, 0xbb, 0x34, 0xc5, 0x35, 0xf0, 0xbe, 0x9a, 0xb0, 0xb2, 0xfa, 0xfb, 0x34,
	0xe4, 0xde, 0xc7, 0x44, 0x53, 0x0e, 0x1c, 0x8c, 0x4a, 0xc0, 0x1b, 0xbd, 0x32, 0xb7, 0xc4, 0xdd,
	0x9a, 0x93, 0x79, 0xa3, 0x87, 0x10, 0x64, 0x2c, 0x6d, 0x88, 0xcb, 0x3c, 0xa3, 0xb0, 0x31, 0xda,
	0x80, 0xac, 0xee, 0xe2, 0x9e, 0x57, 0x4e, 0x2f, 0xa5, 0x6f, 0xe5, 0x57, 0x6f, 0xd6, 0x92, 0xa1,
	0x6a, 0x75, 0x3f, 0xc6, 0x3a, 0x91, 0xf1, 0x1e, 0x05, 0x5c, 0x5b, 0x3c, 0x3a, 0x5c, 0xd0, 0x4d,
	0xdb, 0xef, 0xa9, 0x54, 0x07, 0x5b, 0xc4, 0xd0, 0x4c, 0x4f, 0x0e, 0x00, 0xd0, 0x35, 0xc8, 0xb9,
	0xda, 0xbe, 0xfa, 0xb1, 0x67, 0x5b, 0xe5, 0x2c, 0x5b, 0x61, 0xd6, 0xd5, 0xf6, 0x37, 0x3d, 0xdb,
	0x42, 0x57, 0x60, 0xc6, 0x23, 0x1a, 0xf1, 0xbd, 0xf2, 0x0c, 0x63, 0x84, 0x33, 0x74, 0x17, 0x32,
	0x44, 0xeb, 0x7b, 0xe5, 0x59, 0xb6, 0xf6, 0x72, 0xed, 0xf4, 0x34, 0xa9, 0x45, 0x1b, 0xaa, 0x29,
	0x5a, 0xdf, 0x13, 0x2d, 0xe2, 0x1e, 0xac, 0xe5, 0x8f, 0xbf, 0xfa, 0x32, 0x3d, 0xf3, 0xab, 0x2f,
	0x38, 0x3e, 0x97, 0x92, 0x19, 0x08, 0x5d, 0xdf, 0xde, 0xb7, 0xb0, 0xab, 0x1a, 0xbd, 0x72, 0x2e,
	0x58, 0x9f, 0xcd, 0x9b, 0x3d, 0xd4, 0x84, 0xa2, 0xe3, 0xda, 0x23, 0xa3, 0x87, 0x5d, 0x95, 0x7a,
	0xbb, 0x3c, 0xb7, 0xc4, 0xdd, 0x2a, 0xad, 0xbe, 0x7c, 0xd6, 0x82, 0xed, 0x50, 0x98, 0x2e, 0x2a,
	0x17, 0x9c, 0xd8, 0xec, 0xfa, 0x0f, 0x60, 0x6e, 0x6c, 0x05, 0x12, 0x20, 0x7d, 0x0f, 0x1f, 0x84,
	0x1e, 0xa6, 0x43, 0xb4, 0x08, 0xd9, 0x91, 0x66, 0xfa, 0x91, 0x8f, 0x83, 0xc9, 0x8f, 0xf8, 0x1f,
	0x72, 0x9b, 0x99, 0x5c, 0x46, 0xc8, 0x56, 0xff, 0xc8, 0x43, 0x5e, 0xc2, 0x64, 0xdf, 0x76, 0xef,
	0xb1, 0x10, 0x6d, 0xc0, 0x8c, 0x8b, 0xfb, 0x86, 0x6d, 0x95, 0xb9, 0x0b, 0xf8, 0x1f, 0x1d, 0x1d,
	0xce, 0x47, 0x46, 0xaa, 0x81, 0x9e, 0x1c, 0xea, 0xa3, 0xab, 0x30, 0xab, 0x1b, 0x3d, 0x57, 0x1d,
	0xbd, 0x53, 0xe6, 0x97, 0xd2, 0xd4, 0xc9, 0x74, 0xba, 0xf3, 0xce, 0x84, 0xf1, 0x2e, 0x8b, 0x71,
	0xc4, 0x78, 0x17, 0xfd, 0x1c, 0x8a, 0x56, 0x60, 0x8a, 0xea, 0x60, 0xec, 0x7a, 0xe5, 0xcc, 0x05,
	0x4c, 0x28, 0x1f, 0x1d, 0x5e, 0x1e, 0x9b, 0x10, 0x57, 0x97, 0x0b, 0xe1, 0xac, 0x4d, 0xb1, 0xa8,
	0xcb, 0x4d, 0x5b, 0xeb, 0xa9, 0x5d, 0xcd, 0xd4, 0x2c, 0x1d, 0xbb, 0xe5, 0x2c, 0x03, 0x3f, 0xd3,
	0xe5, 0x5b, 0xb6, 0xd6, 0x5b, 0x0b, 0x65, 0xe5, 0x82, 0x19, 0x9b, 0x55, 0x57, 0xa1, 0x10, 0xe7,
	0x8e, 0xd3, 0x98, 0x8b, 0xa5, 0x71, 0x90, 0xea, 0x7c, 0x94, 0xea, 0xd5, 0x7f, 0xf3, 0x00, 0x1d,
	0xbf, 0x6b, 0x61, 0xc2, 0xdc, 0x7c, 0x17, 0x66, 0x43, 0xeb, 0x98, 0x73, 0xce, 0xdb, 0xe4, 0xa5,
	0xa3, 0x43, 0x61, 0x7a, 0x93, 0x72, 0x84, 0x10, 0x8b, 0x59, 0xfa, 0x39, 0x63, 0xf6, 0x3a, 0x2c,
	0x68, 0x23, 0xcd, 0x30, 0xb5, 0xae, 0x61, 0x1a, 0xe4, 0x40, 0xfd, 0xc4, 0xb6, 0x70, 0x39, 0xc3,
	0x36, 0x21, 0xc4, 0x19, 0x1f, 0xda, 0x16, 0x8e, 0x07, 0x38, 0x7b, 0x56, 0x80, 0x67, 0x12, 0x01,
	0x6e, 0x43, 0xc9, 0xb0, 0x08, 0x76, 0xf7, 0x34, 0x1d, 0x07, 0x79, 0x3f, 0xcb, 0xf2, 0xfe, 0xb5,
	0xb3, 0x82, 0xd0, 0x8c, 0xa4, 0xa9, 0xe5, 0xa2, 0xe5, 0x0f, 0xe5, 0xa2, 0x11, 0x27, 0x6d, 0x66,
	0x72, 0x9c, 0xc0, 0x57, 0xff, 0x96, 0x86, 0x42, 0xd3, 0xf2, 0x08, 0x0d, 0x07, 0x73, 0xef, 0x16,
	0xc0, 0x58, 0xce, 0x0b, 0x33, 0xf9, 0x8d, 0xb3, 0x16, 0x09, 0xd3, 0x3f, 0xb1, 0x96, 0x1c, 0xd3,
	0x47, 0x55, 0x28, 0x68, 0xae, 0x3e, 0x30, 0x08, 0xd6, 0x89, 0xef, 0x46, 0x47, 0x29, 0x41, 0xa3,
	0x27, 0x4f, 0x77, 0xfc, 0x72, 0x7a, 0x89, 0xbb, 0x55, 0x94, 0xe9, 0x10, 0x7d, 0x07, 0x8a, 0x46,
	0x68, 0x53, 0xb0, 0xd7, 0xc0, 0x8f, 0x05, 0x23, 0x6e, 0xe8, 0x75, 0xc8, 0x39, 0xa6, 0x46, 0xf6,
	0x6c, 0x77, 0x18, 0xd6, 0xa8, 0xf1, 0x1c, 0xbd, 0x0a, 0xf3, 0x8e, 0x6b, 0x8c, 0x34, 0x82, 0x55,
	0xad, 0xd7, 0x73, 0xb1, 0x17, 0x55, 0xab, 0x52, 0x48, 0xae, 0x07, 0x54, 0xf4, 0x0a, 0x94, 0x1c,
	0xbf, 0x6b, 0x1a, 0xfa, 0x58, 0x6e, 0x96, 0xc9, 0x15, 0x03, 0x6a, 0x24, 0x76, 0x0b, 0x84, 0x08,
	0xaf, 0x67, 0x79, 0x2a, 0x4b, 0xd9, 0x5c, 0x02, 0x70, 0xdd, 0xf2, 0x24, 0x9a, 0xbc, 0xdf, 0x85,
	0xf9, 0x10, 0x70, 0x2c, 0x38, 0x17, 0x47, 0x8c, 0xe4, 0x5e, 0x81, 0x92, 0x87, 0x75, 0xdf, 0xa5,
	0xa9, 0xc2, 0x6e, 0x95, 0x32, 0xb0, 0x78, 0x17, 0x23, 0xea, 0x1d, 0x4a, 0x3c, 0x3d, 0xab, 0xf2,
	0xa7, 0x67, 0x55, 0xf5, 0xbf, 0x1c, 0x20, 0xc5, 0xd5, 0x2c, 0xcf, 0x20, 0x77, 0x34, 0x82, 0xf7,
	0xb5, 0x83, 0xe9, 0x03, 0xc3, 0x3d, 0xf7, 0x81, 0x69, 0x40, 0x45, 0xf3, 0x89, 0xad, 0x6a, 0xba,
	0x8e, 0x1d, 0xa2, 0x7a, 0x03, 0xcd, 0xc5, 0x3d, 0x55, 0x23, 0x44, 0xd3, 0x07, 0x43, 0x6c, 0x11,
	0x8f, 0x85, 0x38, 0x27, 0xdf, 0xa0, 0x52, 0x75, 0x26, 0xd4, 0x61, 0x32, 0xf5, 0x89, 0x08, 0xfa,
	0x16, 0xe4, 0xa9, 0x77, 0x3c, 0xdf, 0x71, 0x6c, 0x97, 0xb0, 0xc8, 0xe7, 0x64, 0xe8, 0x59, 0x5e,
	0x27, 0xa0, 0x50, 0x7f, 0x8f, 0x1c, 0x4b, 0xc5, 0xfa, 0xd0, 0x19, 0x4b, 0x65, 0x98, 0x54, 0x69,
	0xe4, 0x58, 0xa2, 0x3e, 0x74, 0x42, 0xc9, 0xea, 0xa3, 0x0c, 0x94, 0x64, 0xdb, 0x27, 0x58, 0xd1,
	0xba, 0x26, 0x8e, 0xea, 0xb0, 0xc7, 0xca, 0xc5, 0xb3, 0xd7, 0xe1, 0x40, 0x4f, 0x0e, 0xf5, 0x5f,
	0x6c, 0xa9, 0xe9, 0xc2, 0x3c, 0x09, 0x82, 0xa3, 0xf6, 0x83, 0xe8, 0x5c, 0xa8, 0xe6, 0xdc, 0x38,
	0x3a, 0x2c, 0x8f, 0x41, 0xa7, 0x00, 0xe4, 0x12, 0x49, 0x84, 0x1b, 0xbd, 0x07, 0x33, 0x2e, 0x75,
	0x46, 0x54, 0xff, 0xbf, 0x7d, 0xd6, 0xc1, 0x0d, 0x5c, 0x46, 0x4f, 0x6b, 0xa8, 0x80, 0x14, 0x10,
	0xd8, 0x48, 0x25, 0xd4, 0x91, 0xc1, 0xb1, 0xcb, 0xb2, 0x12, 0xb3, 0xfc, 0x74, 0x90, 0xc8, 0xef,
	0xac, 0xc6, 0x94, 0xdc, 0x64, 0x2c, 0x3e, 0x80, 0x79, 0x63, 0xe8, 0x98, 0x86, 0x6e, 0x90, 0xd0,
	0xb9, 0x61, 0x83, 0xf0, 0xec, 0x41, 0x29, 0x45, 0x40, 0xc1, 0x5d, 0x40, 0xa1, 0xf1, 0xfd, 0x24,
	0x74, 0xee, 0xff, 0x85, 0x8e, 0x80, 0x02, 0xe8, 0xcd, 0x4c, 0x6e, 0x46, 0x98, 0xad, 0xfe, 0x93,
	0x87, 0xb9, 0xb1, 0x9f, 0xd0, 0x12, 0xe4, 0x7b, 0xd8, 0x23, 0x86, 0xa5, 0x91, 0xe0, 0x8a, 0xa7,
	0x67, 0x30, 0x4e, 0x42, 0x65, 0x9a, 0x2d, 0xf7, 0xc9, 0xc0, 0x76, 0xc2, 0x32, 0x17, 0x4d, 0x51,
	0x03, 0x66, 0x3c, 0xdb, 0x77, 0x75, 0xcc, 0x52, 0xbd, 0xb4, 0xfa, 0xfa, 0x53, 0x3d, 0xda, 0x61,
	0xa2, 0x63, 0x97, 0x86, 0xaa, 0xe8, 0xa7, 0x90, 0xa5, 0xad, 0x56, 0x50, 0x0c, 0xcf, 0x8b, 0x4a,
	0x87, 0x4a, 0x8e, 0x21, 0x02, 0x45, 0xd4, 0xa6, 0x4d, 0xc2, 0x7d, 0xa2, 0x0e, 0x6c, 0x27, 0x1e,
	0xdf, 0x37, 0x9e, 0x8a, 0x24, 0xe1, 0xfb, 0x64, 0xc3, 0x76, 0xc6, 0x58, 0x79, 0x6b, 0x42, 0x40,
	0xdf, 0x87, 0xab, 0xbe, 0x87, 0x5d, 0xb5, 0x87, 0xf7, 0x0c, 0x0b, 0xf7, 0xd4, 0x20, 0x83, 0x58,
	0xd5, 0x0b, 0xea, 0xed, 0x22, 0x65, 0xaf, 0x07, 0xdc, 0x00, 0x4e, 0x1b, 0xe2, 0xea, 0x97, 0x3c,
	0xe4, 0x3a, 0x46, 0xe8, 0xd8, 0x17, 0x5a, 0x9e, 0xee, 0x42, 0x9a, 0xf4, 0xf7, 0x2f, 0x74, 0x5a,
	0x9f, 0x7a, 0xb0, 0x28, 0x0a, 0xea, 0x81, 0x30, 0xfd, 0xf8, 0xb8, 0xd0, 0x91, 0xbd, 0x79, 0x74,
	0x78, 0x6d, 0x8c, 0x3c, 0x8d, 0x20, 0x97, 0x7a, 0x7a, 0x23, 0x20, 0x04, 0x25, 0xfe, 0x3d, 0x98,
	0x63, 0x0f, 0x8c, 0xf1, 0x45, 0x57, 0x3a, 0x01, 0x4f, 0xf9, 0xb5, 0xc8, 0x61, 0x72, 0xce, 0x0b,
	0x47, 0xd5, 0x3f, 0x67, 0x61, 0x81, 0x92, 0xdf, 0xc7, 0xde, 0x80, 0x81, 0x31, 0x87, 0xae, 0x43,
	0x86, 0x61, 0x71, 0x0c, 0xeb, 0xad, 0x53, 0xb0, 0x62, 0x8f, 0x99, 0xda, 0x09, 0x7d, 0x99, 0x69,
	0x3f, 0x87, 0x59, 0xe8, 0x17, 0x50, 0x18, 0x19, 0x2e, 0xf1, 0x35, 0x53, 0xa5, 0xb4, 0xf2, 0xdc,
	0x05, 0x7c, 0xf6, 0xd2, 0xd1, 0x61, 0x42, 0xe9, 0xd3, 0x2f, 0x38, 0xee, 0x2f, 0x5f, 0x3f, 0x48,
	0x67, 0x7f, 0xc7, 0xf1, 0x02, 0x27, 0xe7, 0x43, 0x1e, 0x5d, 0x8d, 0x06, 0x79, 0xe0, 0x77, 0x9f,
	0xbd, 0x7a, 0x4e, 0x6d, 0x5d, 0xa6, 0x28, 0xa8, 0x0d, 0xb9, 0x81, 0xdf, 0x65, 0x64, 0x96, 0xb3,
	0xf9, 0xd5, 0xb7, 0xcf, 0xf1, 0xd8, 0x86, 0xdf, 0xbd, 0xed, 0x9b, 0x66, 0xc2, 0x69, 0x1b, 0x29,
	0x79, 0x76, 0xe0, 0x77, 0x29, 0x0d, 0xc9, 0x00, 0x9e, 0x63, 0xdf, 0x0b, 0x74, 0x58, 0x3f, 0x91,
	0x5f, 0xfd, 0xde, 0x79, 0x51, 0xa0, 0x0a, 0xd3, 0x88, 0x73, 0x5e, 0x44, 0x45, 0x2d, 0x98, 0xdb,
	0xf3, 0x4d, 0x33, 0x80, 0xcc, 0x31, 0xc8, 0xf3, 0x02, 0x7b, 0x9a, 0x8d, 0xb9, 0xbd, 0x90, 0x88,
	0x76, 0xa1, 0x98, 0xf0, 0x0b, 0x6b, 0x3f, 0x2e, 0xf0, 0x66, 0x4c, 0x6a, 0xd1, 0x28, 0xc9, 0x85,
	0x88, 0x44, 0x83, 0xb3, 0x76, 0x15, 0xf2, 0xcc, 0x08, 0x7d, 0x60, 0x1b, 0x3a, 0x46, 0xb9, 0x07,
	0x9f, 0x73, 0xb9, 0x87, 0x9f, 0x73, 0xd9, 0xcd, 0x4c, 0x8e, 0x17, 0xd2, 0x9b, 0x99, 0x5c, 0x56,
	0x98, 0xa9, 0x7e, 0x04, 0x68, 0xbd, 0x11, 0x3f, 0x05, 0x2c, 0x6f, 0x36, 0x63, 0x89, 0x9b, 0x5f,
	0x7d, 0x77, 0xca, 0x94, 0xe9, 0x83, 0x54, 0x4b, 0x22, 0xd0, 0x5d, 0x4d, 0xd2, 0xb7, 0xfa, 0x2f,
	0x1e, 0x16, 0x4f, 0xeb, 0x4e, 0x5f, 0x60, 0x77, 0x30, 0x79, 0x09, 0xf3, 0x89, 0x97, 0xb0, 0x02,
	0x0b, 0x53, 0xcd, 0x27, 0x8e, 0x9e, 0xe4, 0xaf, 0x9e, 0x55, 0x6a, 0xc3, 0x46, 0xb3, 0x69, 0xed,
	0xd9, 0x6c, 0x13, 0x42, 0xb2, 0x4f, 0xc5, 0x1e, 0x92, 0x4e, 0x74, 0xaa, 0x99, 0x67, 0x83, 0x9c,
	0x6a, 0x69, 0x4f, 0x36, 0xa0, 0xd9, 0xd3, 0x1a, 0xd0, 0xe8, 0x81, 0x36, 0x33, 0x79, 0xa0, 0x55,
	0x3f, 0x82, 0xf9, 0x29, 0x70, 0x7a, 0xf7, 0x45, 0x66, 0x05, 0x37, 0x63, 0x34, 0xa5, 0x4f, 0xf9,
	0x71, 0x27, 0x9c, 0x0e, 0x58, 0xbd, 0xb0, 0x07, 0x2e, 0xc3, 0xac, 0xe3, 0x1a, 0x43, 0xcd, 0x3d,
	0x08, 0x9b, 0xbb, 0x68, 0x5a, 0xfd, 0x2d, 0x07, 0x45, 0xc5, 0xb7, 0x2c, 0x6c, 0x76, 0xc2, 0x57,
	0xdf, 0x1a, 0x64, 0x58, 0x9a, 0x5e, 0x24, 0x68, 0xc2, 0x74, 0x9a, 0xca, 0x4c, 0x17, 0xfd, 0x18,
	0x66, 0x09, 0x03, 0xf5, 0xc2, 0x0b, 0xa2, 0x7a, 0x96, 0xef, 0x82, 0xb5, 0x99, 0xdb, 0x22, 0x95,
	0xaa, 0x0b, 0xf3, 0xd2, 0xe4, 0x55, 0x1c, 0x56, 0xda, 0xb9, 0x91, 0x85, 0x09, 0x7b, 0x33, 0xb3,
	0x24, 0xc8, 0xaf, 0xbe, 0x72, 0x66, 0x38, 0x3e, 0xf1, 0x5d, 0xbc, 0x63, 0x61, 0x42, 0xb5, 0xe9,
	0x51, 0x1c, 0x85, 0xe3, 0xb5, 0x4b, 0x90, 0xa7, 0x00, 0xd1, 0x89, 0xc9, 0x3c, 0xfc, 0x9c, 0xe3,
	0xc2, 0xd7, 0xd9, 0x9f, 0x38, 0x28, 0x26, 0x14, 0x91, 0x02, 0x05, 0x26, 0xfc, 0xdc, 0x57, 0x26,
	0x5b, 0x33, 0xdc, 0x10, 0x7a, 0x1f, 0x8a, 0x74, 0x6a, 0x58, 0x7d, 0x35, 0xe8, 0x31, 0x78, 0x56,
	0xf0, 0x6f, 0x9d, 0xf9, 0x51, 0x25, 0x10, 0x66, 0x5d, 0x06, 0xeb, 0x0a, 0x0a, 0x4e, 0x8c, 0x52,
	0xfd, 0x9a, 0x03, 0x98, 0xb8, 0x10, 0x6d, 0x02, 0xe8, 0xb6, 0x65, 0x61, 0x7d, 0xdc, 0x39, 0x9d,
	0xfc, 0x40, 0xc4, 0xee, 0x92, 0x40, 0xa7, 0x31, 0x96, 0xed, 0xb0, 0x03, 0x25, 0xc7, 0xb4, 0xc7,
	0x79, 0xc0, 0x3f, 0x47, 0x1e, 0x84, 0x4d, 0x42, 0xfa, 0x45, 0x34, 0x09, 0xd5, 0x7f, 0x70, 0x30,
	0xdf, 0x30, 0x6d, 0xbf, 0xd7, 0xb6, 0x4d, 0x43, 0x0f, 0x5e, 0x5c, 0xef, 0x41, 0x5a, 0xdb, 0xf7,
	0xce, 0xcd, 0x88, 0xdd, 0xce, 0x44, 0x67, 0x23, 0x25, 0x53, 0x1d, 0xf4, 0x36, 0x5c, 0x76, 0xb0,
	0x3b, 0x34, 0x3c, 0xcf, 0xb0, 0x2d, 0x4f, 0x75, 0x6c, 0xc7, 0x37, 0x35, 0x82, 0x7b, 0xac, 0x57,
	0xcb, 0xc9, 0x8b, 0x31, 0x66, 0x3b, 0xe2, 0xa1, 0xb7, 0x60, 0x31, 0xf8, 0x94, 0x37, 0xfe, 0x32,
	0x86, 0x5d, 0xd7, 0x76, 0xc3, 0x43, 0x8b, 0x18, 0x2f, 0xfa, 0x0e, 0x26, 0x52, 0xce, 0xda, 0x15,
	0x80, 0x40, 0x83, 0xdd, 0xf5, 0xb4, 0x48, 0xf3, 0xb1, 0xb4, 0xfb, 0x25, 0x0f, 0xc5, 0x84, 0x75,
	0x68, 0x05, 0x16, 0xc3, 0x77, 0x98, 0xaa, 0xed, 0x7b, 0xea, 0xc8, 0xd1, 0xd5, 0xf0, 0x38, 0x52,
	0xab, 0x16, 0x42, 0x5e, 0x7d, 0xdf, 0xdb, 0x71, 0x74, 0x76, 0x47, 0xdf, 0x86, 0x25, 0x66, 0xa7,
	0xd5, 0x57, 0xe3, 0xfb, 0x49, 0x28, 0x07, 0xdf, 0xb6, 0x6e, 0x86, 0x72, 0xed, 0x89, 0x58, 0x0c,
	0x67, 0x6a, 0x61, 0xd2, 0xdf, 0x0f, 0x74, 0xd3, 0xd3, 0x0b, 0x2b, 0xfd, 0xfd, 0xf3, 0x16, 0x1e,
	0x2b, 0x67, 0x9e, 0xb2, 0x70, 0x88, 0xb3, 0xfc, 0x19, 0x07, 0x85, 0xf8, 0xb7, 0x43, 0xf4, 0x12,
	0x5c, 0x6b, 0xcb, 0xad, 0x9d, 0xe6, 0xba, 0x28, 0xab, 0xca, 0x07, 0x6d, 0x51, 0xdd, 0x96, 0x3a,
	0x6d, 0xb1, 0xd1, 0xbc, 0xdd, 0x14, 0xd7, 0x85, 0x14, 0xba, 0x0c, 0x0b, 0x49, 0x76, 0x7d, 0xb7,
	0x23, 0x70, 0x27, 0xc9, 0x77, 0x1a, 0x6d, 0x81, 0x47, 0x57, 0xe1, 0xd2, 0x94, 0xf4, 0x87, 0xdb,
	0xb2, 0x28, 0xa4, 0xd1, 0x75, 0xb8, 0x92, 0x64, 0xec, 0xb4, 0xb6, 0x14, 0x51, 0x96, 0xeb, 0x42,
	0x66, 0x59, 0x86, 0x02, 0x35, 0x8d, 0x1e, 0x38, 0x66, 0xd1, 0x35, 0xb8, 0xdc, 0x69, 0x2a, 0xe2,
	0x69, 0xd6, 0x08, 0x50, 0x98, 0xb0, 0x64, 0x31, 0x30, 0x64, 0x42, 0xa9, 0xef, 0x76, 0x54, 0xe5,
	0xce, 0xae, 0xc0, 0x2f, 0xaf, 0x01, 0x3a, 0xf9, 0x8c, 0xa3, 0xe6, 0xc9, 0xad, 0x6d, 0x2a, 0x5d,
	0x5f, 0xdb, 0x12, 0x55, 0x49, 0x54, 0x76, 0x5b, 0xf2, 0x5d, 0x21, 0x85, 0x2e, 0xc1, 0x7c, 0x9c,
	0x41, 0x31, 0xb8, 0x65, 0x09, 0x16, 0x4e, 0x7c, 0x6d, 0x42, 0x79, 0x98, 0x6d, 0x6d, 0x2b, 0x9d,
	0xe6, 0xba, 0x28, 0xa4, 0x10, 0xc0, 0x4c, 0x53, 0x62, 0x63, 0x0e, 0x15, 0x20, 0x47, 0xc1, 0xb6,
	0x5a, 0xf5, 0x75, 0x81, 0x47, 0x08, 0x4a, 0x52, 0x4b, 0x51, 0xeb, 0xed, 0xf6, 0x56, 0xb3, 0x41,
	0x31, 0x85, 0xf4, 0xf2, 0xaf, 0x39, 0xb8, 0x74, 0xca, 0x4b, 0x88, 0xca, 0x36, 0xa5, 0x9d, 0xfa,
	0x56, 0x73, 0x5d, 0xed, 0xb4, 0xb6, 0xe5, 0x06, 0x45, 0xce, 0xc3, 0xec, 0xba, 0x78, 0xbb, 0xbe,
	0xbd, 0xa5, 0x08, 0x1c, 0xca, 0x41, 0x66, 0xbb, 0x23, 0xca, 0x02, 0x4f, 0xc9, 0xdb, 0xd2, 0x5d,
	0xa9, 0xb5, 0x2b, 0x09, 0x69, 0x54, 0x85, 0xca, 0x4e, 0x53, 0x56, 0xb6, 0xeb, 0x5b, 0xd1, 0x4e,
	0xd4, 0x3b, 0x75, 0x45, 0xdc, 0xad, 0x7f, 0x10, 0xe1, 0x64, 0x98, 0x2f, 0xd9, 0x58, 0x9d, 0x32,
	0x27, 0xbb, 0xdc, 0x09, 0x5d, 0x94, 0x78, 0x53, 0x51, 0x0f, 0xd7, 0x1b, 0x4a, 0x73, 0x47, 0x54,
	0x3b, 0x4a, 0x5d, 0xa1, 0xa6, 0x2c, 0x40, 0x71, 0x6c, 0x1e, 0x23, 0x71, 0xa8, 0x0c, 0x8b, 0x6c,
	0x38, 0x0d, 0xca, 0x2f, 0xff, 0x9d, 0x83, 0xc5, 0xd3, 0xde, 0x57, 0xe8, 0x06, 0x5c, 0x3d, 0xc3,
	0x58, 0x21, 0x85, 0x4a, 0x00, 0x3b, 0x92, 0xa8, 0xa8, 0x5b, 0xad, 0x46, 0x7d, 0x2b, 0xf0, 0x65,
	0x53, 0x52, 0x44, 0x59, 0x12, 0x15, 0x81, 0xa7, 0x21, 0x8e, 0x54, 0xd9, 0x5a, 0x75, 0xa9, 0x41,
	0x53, 0x2a, 0x07, 0x19, 0xa9, 0x25, 0xd1, 0x4d, 0x0a, 0x50, 0x60, 0xea, 0x6d, 0x51, 0x94, 0x9b,
	0xd2, 0x1d, 0x21, 0x8b, 0x5e, 0x86, 0xa5, 0xe9, 0xd5, 0x3a, 0xa2, 0xbc, 0xd3, 0x6c, 0x88, 0xaa,
	0x28, 0xad, 0xb7, 0x5b, 0x4d, 0x49, 0x11, 0x66, 0xd0, 0x12, 0xdc, 0x94, 0xc4, 0x9f, 0x29, 0xea,
	0x46, 0xab, 0x1d, 0xe4, 0xcf, 0xd4, 0x76, 0x66, 0x97, 0x4d, 0x10, 0xa6, 0xef, 0x04, 0x54, 0x84,
	0xb9, 0x46, 0x4b, 0x92, 0xc4, 0x86, 0x12, 0xa5, 0xe4, 0x7a, 0xb3, 0x33, 0xa1, 0x04, 0x67, 0x23,
	0xb0, 0x44, 0x6d, 0x4a, 0x4d, 0xa5, 0x59, 0xa7, 0xe4, 0x34, 0x5d, 0x2d, 0x22, 0x9f, 0xea, 0xbc,
	0xcc, 0xda, 0x6f, 0xb8, 0x07, 0x3f, 0x49, 0x3d, 0x7c, 0x5c, 0x49, 0x3d, 0x7a, 0x5c, 0x49, 0x7d,
	0xf3, 0xb8, 0xc2, 0x7d, 0x7a, 0x5c, 0xe1, 0xfe, 0x70, 0x5c, 0xe1, 0xfe, 0x7a, 0x5c, 0xe1, 0x1e,
	0x1e, 0x57, 0xb8, 0x47, 0xc7, 0x15, 0xee, 0xab, 0xe3, 0x0a, 0xf7, 0x9f, 0xe3, 0x4a, 0xea, 0x9b,
	0xe3, 0x0a, 0xf7, 0xd9, 0x93, 0x4a, 0xea, 0xc1, 0x93, 0x0a, 0xf7, 0xf0, 0x49, 0x25, 0xf5, 0xe8,
	0x49, 0x25, 0xf5, 0xe1, 0x56, 0xdf, 0x76, 0xee, 0xf5, 0x6b, 0x23, 0xdb, 0x24, 0xd8, 0x75, 0xb5,
	0x9a, 0xef, 0xad, 0xb0, 0xc1, 0x9e, 0xed, 0x0e, 0xdf, 0x8c, 0xaa, 0xe8, 0x9b, 0x11, 0x7b, 0xc5,
	0xe9, 0xf6, 0xed, 0x15, 0x7c, 0x9f, 0x44, 0x3f, 0x84, 0x92, 0xff, 0xc7, 0xba, 0x33, 0xec, 0x87,
	0xcd, 0xdb, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x9b, 0x85, 0x48, 0xce, 0x40, 0x1b, 0x00, 0x00,
}

func (x ProviderType) String() string {
	s, ok := ProviderType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SiteEnumType) String() string {
	s, ok := SiteEnumType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RouteTableTypeEnum) String() string {
	s, ok := RouteTableTypeEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x InterfaceTypeEnum) String() string {
	s, ok := InterfaceTypeEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RouteSourceTypeEnum) String() string {
	s, ok := RouteSourceTypeEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RouteStateTypeEnum) String() string {
	s, ok := RouteStateTypeEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RouteNextHopTypeEnum) String() string {
	s, ok := RouteNextHopTypeEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PeeringStateEnum) String() string {
	s, ok := PeeringStateEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *MetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetaType)
	if !ok {
		that2, ok := that.(MetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Creds) != len(that1.Creds) {
		return false
	}
	for i := range this.Creds {
		if !this.Creds[i].Equal(that1.Creds[i]) {
			return false
		}
	}
	if this.RawJson != that1.RawJson {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if this.OwnerId != that1.OwnerId {
		return false
	}
	if this.ProviderType != that1.ProviderType {
		return false
	}
	return true
}
func (this *NetworkType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkType)
	if !ok {
		that2, ok := that.(NetworkType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Region) != len(that1.Region) {
		return false
	}
	for i := range this.Region {
		if !this.Region[i].Equal(that1.Region[i]) {
			return false
		}
	}
	if len(this.CidrV4) != len(that1.CidrV4) {
		return false
	}
	for i := range this.CidrV4 {
		if this.CidrV4[i] != that1.CidrV4[i] {
			return false
		}
	}
	if len(this.CidrV6) != len(that1.CidrV6) {
		return false
	}
	for i := range this.CidrV6 {
		if this.CidrV6[i] != that1.CidrV6[i] {
			return false
		}
	}
	if len(this.NetworkPeers) != len(that1.NetworkPeers) {
		return false
	}
	for i := range this.NetworkPeers {
		if !this.NetworkPeers[i].Equal(that1.NetworkPeers[i]) {
			return false
		}
	}
	if len(this.LoadBalancer) != len(that1.LoadBalancer) {
		return false
	}
	for i := range this.LoadBalancer {
		if !this.LoadBalancer[i].Equal(that1.LoadBalancer[i]) {
			return false
		}
	}
	return true
}
func (this *LoadBalancer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoadBalancer)
	if !ok {
		that2, ok := that.(LoadBalancer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *SubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubnetType)
	if !ok {
		that2, ok := that.(SubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Network) != len(that1.Network) {
		return false
	}
	for i := range this.Network {
		if !this.Network[i].Equal(that1.Network[i]) {
			return false
		}
	}
	if len(this.Region) != len(that1.Region) {
		return false
	}
	for i := range this.Region {
		if !this.Region[i].Equal(that1.Region[i]) {
			return false
		}
	}
	if this.AvailabilityZone != that1.AvailabilityZone {
		return false
	}
	if len(this.CidrV4) != len(that1.CidrV4) {
		return false
	}
	for i := range this.CidrV4 {
		if this.CidrV4[i] != that1.CidrV4[i] {
			return false
		}
	}
	if len(this.CidrV6) != len(that1.CidrV6) {
		return false
	}
	for i := range this.CidrV6 {
		if this.CidrV6[i] != that1.CidrV6[i] {
			return false
		}
	}
	if this.InterfaceType != that1.InterfaceType {
		return false
	}
	return true
}
func (this *InstanceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InstanceType)
	if !ok {
		that2, ok := that.(InstanceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Interfaces) != len(that1.Interfaces) {
		return false
	}
	for i := range this.Interfaces {
		if !this.Interfaces[i].Equal(that1.Interfaces[i]) {
			return false
		}
	}
	if this.Architecture != that1.Architecture {
		return false
	}
	if this.Cpu != that1.Cpu {
		return false
	}
	if this.InstanceType != that1.InstanceType {
		return false
	}
	if this.Platform != that1.Platform {
		return false
	}
	if this.PrivateAddress != that1.PrivateAddress {
		return false
	}
	if this.PublicAddress != that1.PublicAddress {
		return false
	}
	if this.PrivateDnsName != that1.PrivateDnsName {
		return false
	}
	if this.PublicDnsName != that1.PublicDnsName {
		return false
	}
	if len(this.SecurityGroup) != len(that1.SecurityGroup) {
		return false
	}
	for i := range this.SecurityGroup {
		if this.SecurityGroup[i] != that1.SecurityGroup[i] {
			return false
		}
	}
	if this.AvailabilityZone != that1.AvailabilityZone {
		return false
	}
	return true
}
func (this *TransitGatewayType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TransitGatewayType)
	if !ok {
		that2, ok := that.(TransitGatewayType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Network) != len(that1.Network) {
		return false
	}
	for i := range this.Network {
		if !this.Network[i].Equal(that1.Network[i]) {
			return false
		}
	}
	if this.AutoAcceptSharedAttachments != that1.AutoAcceptSharedAttachments {
		return false
	}
	if this.DnsSupport != that1.DnsSupport {
		return false
	}
	if this.VpnEcmpSupport != that1.VpnEcmpSupport {
		return false
	}
	return true
}
func (this *RouteTableType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteTableType)
	if !ok {
		that2, ok := that.(RouteTableType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Subnet) != len(that1.Subnet) {
		return false
	}
	for i := range this.Subnet {
		if !this.Subnet[i].Equal(that1.Subnet[i]) {
			return false
		}
	}
	if len(this.Network) != len(that1.Network) {
		return false
	}
	for i := range this.Network {
		if !this.Network[i].Equal(that1.Network[i]) {
			return false
		}
	}
	if len(this.TransitGateway) != len(that1.TransitGateway) {
		return false
	}
	for i := range this.TransitGateway {
		if !this.TransitGateway[i].Equal(that1.TransitGateway[i]) {
			return false
		}
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	if this.RouteTableType != that1.RouteTableType {
		return false
	}
	if len(this.ImplicitSubnet) != len(that1.ImplicitSubnet) {
		return false
	}
	for i := range this.ImplicitSubnet {
		if !this.ImplicitSubnet[i].Equal(that1.ImplicitSubnet[i]) {
			return false
		}
	}
	if len(this.ExplicitSubnet) != len(that1.ExplicitSubnet) {
		return false
	}
	for i := range this.ExplicitSubnet {
		if !this.ExplicitSubnet[i].Equal(that1.ExplicitSubnet[i]) {
			return false
		}
	}
	return true
}
func (this *RouteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteType)
	if !ok {
		that2, ok := that.(RouteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Destination != that1.Destination {
		return false
	}
	if this.Nexthop != that1.Nexthop {
		return false
	}
	if this.Source != that1.Source {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.NextHopType != that1.NextHopType {
		return false
	}
	if this.UserDefinedRouteName != that1.UserDefinedRouteName {
		return false
	}
	return true
}
func (this *SiteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteType)
	if !ok {
		that2, ok := that.(SiteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Network) != len(that1.Network) {
		return false
	}
	for i := range this.Network {
		if !this.Network[i].Equal(that1.Network[i]) {
			return false
		}
	}
	if len(this.Tgw) != len(that1.Tgw) {
		return false
	}
	for i := range this.Tgw {
		if !this.Tgw[i].Equal(that1.Tgw[i]) {
			return false
		}
	}
	if len(this.DcClusterGroup) != len(that1.DcClusterGroup) {
		return false
	}
	for i := range this.DcClusterGroup {
		if !this.DcClusterGroup[i].Equal(that1.DcClusterGroup[i]) {
			return false
		}
	}
	if this.SiteType != that1.SiteType {
		return false
	}
	return true
}
func (this *SiteMeshGroupType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteMeshGroupType)
	if !ok {
		that2, ok := that.(SiteMeshGroupType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.SiteType != that1.SiteType {
		return false
	}
	if len(this.VirtualSite) != len(that1.VirtualSite) {
		return false
	}
	for i := range this.VirtualSite {
		if !this.VirtualSite[i].Equal(that1.VirtualSite[i]) {
			return false
		}
	}
	if len(this.Hub) != len(that1.Hub) {
		return false
	}
	for i := range this.Hub {
		if !this.Hub[i].Equal(that1.Hub[i]) {
			return false
		}
	}
	if that1.MeshChoice == nil {
		if this.MeshChoice != nil {
			return false
		}
	} else if this.MeshChoice == nil {
		return false
	} else if !this.MeshChoice.Equal(that1.MeshChoice) {
		return false
	}
	if len(this.TopologySite) != len(that1.TopologySite) {
		return false
	}
	for i := range this.TopologySite {
		if !this.TopologySite[i].Equal(that1.TopologySite[i]) {
			return false
		}
	}
	return true
}
func (this *SiteMeshGroupType_HubMesh) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteMeshGroupType_HubMesh)
	if !ok {
		that2, ok := that.(SiteMeshGroupType_HubMesh)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HubMesh.Equal(that1.HubMesh) {
		return false
	}
	return true
}
func (this *SiteMeshGroupType_SpokeMesh) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteMeshGroupType_SpokeMesh)
	if !ok {
		that2, ok := that.(SiteMeshGroupType_SpokeMesh)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SpokeMesh.Equal(that1.SpokeMesh) {
		return false
	}
	return true
}
func (this *SiteMeshGroupType_FullMesh) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteMeshGroupType_FullMesh)
	if !ok {
		that2, ok := that.(SiteMeshGroupType_FullMesh)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FullMesh.Equal(that1.FullMesh) {
		return false
	}
	return true
}
func (this *DCClusterGroupType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DCClusterGroupType)
	if !ok {
		that2, ok := that.(DCClusterGroupType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *NetworkInterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkInterfaceType)
	if !ok {
		that2, ok := that.(NetworkInterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Subnet) != len(that1.Subnet) {
		return false
	}
	for i := range this.Subnet {
		if !this.Subnet[i].Equal(that1.Subnet[i]) {
			return false
		}
	}
	if this.Status != that1.Status {
		return false
	}
	if len(this.PrivateAddresses) != len(that1.PrivateAddresses) {
		return false
	}
	for i := range this.PrivateAddresses {
		if !this.PrivateAddresses[i].Equal(that1.PrivateAddresses[i]) {
			return false
		}
	}
	if len(this.PublicAddress) != len(that1.PublicAddress) {
		return false
	}
	for i := range this.PublicAddress {
		if !this.PublicAddress[i].Equal(that1.PublicAddress[i]) {
			return false
		}
	}
	if len(this.SecurityGroup) != len(that1.SecurityGroup) {
		return false
	}
	for i := range this.SecurityGroup {
		if this.SecurityGroup[i] != that1.SecurityGroup[i] {
			return false
		}
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *AddressInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddressInfoType)
	if !ok {
		that2, ok := that.(AddressInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.DnsName != that1.DnsName {
		return false
	}
	if this.Primary != that1.Primary {
		return false
	}
	return true
}
func (this *TunnelSetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelSetType)
	if !ok {
		that2, ok := that.(TunnelSetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Site) != len(that1.Site) {
		return false
	}
	for i := range this.Site {
		if !this.Site[i].Equal(that1.Site[i]) {
			return false
		}
	}
	if len(this.Tunnels) != len(that1.Tunnels) {
		return false
	}
	for i := range this.Tunnels {
		if !this.Tunnels[i].Equal(that1.Tunnels[i]) {
			return false
		}
	}
	return true
}
func (this *NetworkPeerType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPeerType)
	if !ok {
		that2, ok := that.(NetworkPeerType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PeerChoice == nil {
		if this.PeerChoice != nil {
			return false
		}
	} else if this.PeerChoice == nil {
		return false
	} else if !this.PeerChoice.Equal(that1.PeerChoice) {
		return false
	}
	return true
}
func (this *NetworkPeerType_VnetPeer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPeerType_VnetPeer)
	if !ok {
		that2, ok := that.(NetworkPeerType_VnetPeer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VnetPeer.Equal(that1.VnetPeer) {
		return false
	}
	return true
}
func (this *AzureVnetPeer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetPeer)
	if !ok {
		that2, ok := that.(AzureVnetPeer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.PeerNetwork) != len(that1.PeerNetwork) {
		return false
	}
	for i := range this.PeerNetwork {
		if !this.PeerNetwork[i].Equal(that1.PeerNetwork[i]) {
			return false
		}
	}
	if this.PeeringState != that1.PeeringState {
		return false
	}
	return true
}
func (this *TunnelType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelType)
	if !ok {
		that2, ok := that.(TunnelType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Connection.Equal(that1.Connection) {
		return false
	}
	if len(this.Site) != len(that1.Site) {
		return false
	}
	for i := range this.Site {
		if !this.Site[i].Equal(that1.Site[i]) {
			return false
		}
	}
	if len(this.Tgw) != len(that1.Tgw) {
		return false
	}
	for i := range this.Tgw {
		if !this.Tgw[i].Equal(that1.Tgw[i]) {
			return false
		}
	}
	return true
}
func (this *CloudPolicyType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudPolicyType)
	if !ok {
		that2, ok := that.(CloudPolicyType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.CloudType == nil {
		if this.CloudType != nil {
			return false
		}
	} else if this.CloudType == nil {
		return false
	} else if !this.CloudType.Equal(that1.CloudType) {
		return false
	}
	if this.PermissionsPopulated != that1.PermissionsPopulated {
		return false
	}
	if this.CloudProviderError != that1.CloudProviderError {
		return false
	}
	return true
}
func (this *CloudPolicyType_Aws) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudPolicyType_Aws)
	if !ok {
		that2, ok := that.(CloudPolicyType_Aws)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Aws.Equal(that1.Aws) {
		return false
	}
	return true
}
func (this *AWSPolicyType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSPolicyType)
	if !ok {
		that2, ok := that.(AWSPolicyType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SupportAwsVpcSite != that1.SupportAwsVpcSite {
		return false
	}
	if len(this.MissingPermissionsAwsVpcSite) != len(that1.MissingPermissionsAwsVpcSite) {
		return false
	}
	for i := range this.MissingPermissionsAwsVpcSite {
		if this.MissingPermissionsAwsVpcSite[i] != that1.MissingPermissionsAwsVpcSite[i] {
			return false
		}
	}
	if this.SupportAwsTgwSite != that1.SupportAwsTgwSite {
		return false
	}
	if len(this.MissingPermissionsAwsTgwSite) != len(that1.MissingPermissionsAwsTgwSite) {
		return false
	}
	for i := range this.MissingPermissionsAwsTgwSite {
		if this.MissingPermissionsAwsTgwSite[i] != that1.MissingPermissionsAwsTgwSite[i] {
			return false
		}
	}
	return true
}
func (this *MetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&topology.MetaType{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Creds != nil {
		s = append(s, "Creds: "+fmt.Sprintf("%#v", this.Creds)+",\n")
	}
	s = append(s, "RawJson: "+fmt.Sprintf("%#v", this.RawJson)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	s = append(s, "OwnerId: "+fmt.Sprintf("%#v", this.OwnerId)+",\n")
	s = append(s, "ProviderType: "+fmt.Sprintf("%#v", this.ProviderType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&topology.NetworkType{")
	if this.Region != nil {
		s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	}
	s = append(s, "CidrV4: "+fmt.Sprintf("%#v", this.CidrV4)+",\n")
	s = append(s, "CidrV6: "+fmt.Sprintf("%#v", this.CidrV6)+",\n")
	if this.NetworkPeers != nil {
		s = append(s, "NetworkPeers: "+fmt.Sprintf("%#v", this.NetworkPeers)+",\n")
	}
	if this.LoadBalancer != nil {
		s = append(s, "LoadBalancer: "+fmt.Sprintf("%#v", this.LoadBalancer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoadBalancer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.LoadBalancer{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&topology.SubnetType{")
	if this.Network != nil {
		s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	}
	if this.Region != nil {
		s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	}
	s = append(s, "AvailabilityZone: "+fmt.Sprintf("%#v", this.AvailabilityZone)+",\n")
	s = append(s, "CidrV4: "+fmt.Sprintf("%#v", this.CidrV4)+",\n")
	s = append(s, "CidrV6: "+fmt.Sprintf("%#v", this.CidrV6)+",\n")
	s = append(s, "InterfaceType: "+fmt.Sprintf("%#v", this.InterfaceType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InstanceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&topology.InstanceType{")
	if this.Interfaces != nil {
		s = append(s, "Interfaces: "+fmt.Sprintf("%#v", this.Interfaces)+",\n")
	}
	s = append(s, "Architecture: "+fmt.Sprintf("%#v", this.Architecture)+",\n")
	s = append(s, "Cpu: "+fmt.Sprintf("%#v", this.Cpu)+",\n")
	s = append(s, "InstanceType: "+fmt.Sprintf("%#v", this.InstanceType)+",\n")
	s = append(s, "Platform: "+fmt.Sprintf("%#v", this.Platform)+",\n")
	s = append(s, "PrivateAddress: "+fmt.Sprintf("%#v", this.PrivateAddress)+",\n")
	s = append(s, "PublicAddress: "+fmt.Sprintf("%#v", this.PublicAddress)+",\n")
	s = append(s, "PrivateDnsName: "+fmt.Sprintf("%#v", this.PrivateDnsName)+",\n")
	s = append(s, "PublicDnsName: "+fmt.Sprintf("%#v", this.PublicDnsName)+",\n")
	s = append(s, "SecurityGroup: "+fmt.Sprintf("%#v", this.SecurityGroup)+",\n")
	s = append(s, "AvailabilityZone: "+fmt.Sprintf("%#v", this.AvailabilityZone)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TransitGatewayType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&topology.TransitGatewayType{")
	if this.Network != nil {
		s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	}
	s = append(s, "AutoAcceptSharedAttachments: "+fmt.Sprintf("%#v", this.AutoAcceptSharedAttachments)+",\n")
	s = append(s, "DnsSupport: "+fmt.Sprintf("%#v", this.DnsSupport)+",\n")
	s = append(s, "VpnEcmpSupport: "+fmt.Sprintf("%#v", this.VpnEcmpSupport)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteTableType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&topology.RouteTableType{")
	if this.Subnet != nil {
		s = append(s, "Subnet: "+fmt.Sprintf("%#v", this.Subnet)+",\n")
	}
	if this.Network != nil {
		s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	}
	if this.TransitGateway != nil {
		s = append(s, "TransitGateway: "+fmt.Sprintf("%#v", this.TransitGateway)+",\n")
	}
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	s = append(s, "RouteTableType: "+fmt.Sprintf("%#v", this.RouteTableType)+",\n")
	if this.ImplicitSubnet != nil {
		s = append(s, "ImplicitSubnet: "+fmt.Sprintf("%#v", this.ImplicitSubnet)+",\n")
	}
	if this.ExplicitSubnet != nil {
		s = append(s, "ExplicitSubnet: "+fmt.Sprintf("%#v", this.ExplicitSubnet)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&topology.RouteType{")
	s = append(s, "Destination: "+fmt.Sprintf("%#v", this.Destination)+",\n")
	s = append(s, "Nexthop: "+fmt.Sprintf("%#v", this.Nexthop)+",\n")
	s = append(s, "Source: "+fmt.Sprintf("%#v", this.Source)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "NextHopType: "+fmt.Sprintf("%#v", this.NextHopType)+",\n")
	s = append(s, "UserDefinedRouteName: "+fmt.Sprintf("%#v", this.UserDefinedRouteName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&topology.SiteType{")
	if this.Network != nil {
		s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	}
	if this.Tgw != nil {
		s = append(s, "Tgw: "+fmt.Sprintf("%#v", this.Tgw)+",\n")
	}
	if this.DcClusterGroup != nil {
		s = append(s, "DcClusterGroup: "+fmt.Sprintf("%#v", this.DcClusterGroup)+",\n")
	}
	s = append(s, "SiteType: "+fmt.Sprintf("%#v", this.SiteType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteMeshGroupType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&topology.SiteMeshGroupType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "SiteType: "+fmt.Sprintf("%#v", this.SiteType)+",\n")
	if this.VirtualSite != nil {
		s = append(s, "VirtualSite: "+fmt.Sprintf("%#v", this.VirtualSite)+",\n")
	}
	if this.Hub != nil {
		s = append(s, "Hub: "+fmt.Sprintf("%#v", this.Hub)+",\n")
	}
	if this.MeshChoice != nil {
		s = append(s, "MeshChoice: "+fmt.Sprintf("%#v", this.MeshChoice)+",\n")
	}
	if this.TopologySite != nil {
		s = append(s, "TopologySite: "+fmt.Sprintf("%#v", this.TopologySite)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteMeshGroupType_HubMesh) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&topology.SiteMeshGroupType_HubMesh{` +
		`HubMesh:` + fmt.Sprintf("%#v", this.HubMesh) + `}`}, ", ")
	return s
}
func (this *SiteMeshGroupType_SpokeMesh) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&topology.SiteMeshGroupType_SpokeMesh{` +
		`SpokeMesh:` + fmt.Sprintf("%#v", this.SpokeMesh) + `}`}, ", ")
	return s
}
func (this *SiteMeshGroupType_FullMesh) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&topology.SiteMeshGroupType_FullMesh{` +
		`FullMesh:` + fmt.Sprintf("%#v", this.FullMesh) + `}`}, ", ")
	return s
}
func (this *DCClusterGroupType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&topology.DCClusterGroupType{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkInterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&topology.NetworkInterfaceType{")
	if this.Subnet != nil {
		s = append(s, "Subnet: "+fmt.Sprintf("%#v", this.Subnet)+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	if this.PrivateAddresses != nil {
		s = append(s, "PrivateAddresses: "+fmt.Sprintf("%#v", this.PrivateAddresses)+",\n")
	}
	if this.PublicAddress != nil {
		s = append(s, "PublicAddress: "+fmt.Sprintf("%#v", this.PublicAddress)+",\n")
	}
	s = append(s, "SecurityGroup: "+fmt.Sprintf("%#v", this.SecurityGroup)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AddressInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&topology.AddressInfoType{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "DnsName: "+fmt.Sprintf("%#v", this.DnsName)+",\n")
	s = append(s, "Primary: "+fmt.Sprintf("%#v", this.Primary)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TunnelSetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.TunnelSetType{")
	if this.Site != nil {
		s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	}
	if this.Tunnels != nil {
		s = append(s, "Tunnels: "+fmt.Sprintf("%#v", this.Tunnels)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkPeerType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&topology.NetworkPeerType{")
	if this.PeerChoice != nil {
		s = append(s, "PeerChoice: "+fmt.Sprintf("%#v", this.PeerChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkPeerType_VnetPeer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&topology.NetworkPeerType_VnetPeer{` +
		`VnetPeer:` + fmt.Sprintf("%#v", this.VnetPeer) + `}`}, ", ")
	return s
}
func (this *AzureVnetPeer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.AzureVnetPeer{")
	if this.PeerNetwork != nil {
		s = append(s, "PeerNetwork: "+fmt.Sprintf("%#v", this.PeerNetwork)+",\n")
	}
	s = append(s, "PeeringState: "+fmt.Sprintf("%#v", this.PeeringState)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TunnelType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&topology.TunnelType{")
	if this.Connection != nil {
		s = append(s, "Connection: "+fmt.Sprintf("%#v", this.Connection)+",\n")
	}
	if this.Site != nil {
		s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	}
	if this.Tgw != nil {
		s = append(s, "Tgw: "+fmt.Sprintf("%#v", this.Tgw)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudPolicyType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&topology.CloudPolicyType{")
	if this.CloudType != nil {
		s = append(s, "CloudType: "+fmt.Sprintf("%#v", this.CloudType)+",\n")
	}
	s = append(s, "PermissionsPopulated: "+fmt.Sprintf("%#v", this.PermissionsPopulated)+",\n")
	s = append(s, "CloudProviderError: "+fmt.Sprintf("%#v", this.CloudProviderError)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudPolicyType_Aws) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&topology.CloudPolicyType_Aws{` +
		`Aws:` + fmt.Sprintf("%#v", this.Aws) + `}`}, ", ")
	return s
}
func (this *AWSPolicyType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&topology.AWSPolicyType{")
	s = append(s, "SupportAwsVpcSite: "+fmt.Sprintf("%#v", this.SupportAwsVpcSite)+",\n")
	s = append(s, "MissingPermissionsAwsVpcSite: "+fmt.Sprintf("%#v", this.MissingPermissionsAwsVpcSite)+",\n")
	s = append(s, "SupportAwsTgwSite: "+fmt.Sprintf("%#v", this.SupportAwsTgwSite)+",\n")
	s = append(s, "MissingPermissionsAwsTgwSite: "+fmt.Sprintf("%#v", this.MissingPermissionsAwsTgwSite)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *MetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProviderType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ProviderType))
		i--
		dAtA[i] = 0x48
	}
	if len(m.OwnerId) > 0 {
		i -= len(m.OwnerId)
		copy(dAtA[i:], m.OwnerId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OwnerId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Tags) > 0 {
		keysForTags := make([]string, 0, len(m.Tags))
		for k := range m.Tags {
			keysForTags = append(keysForTags, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
		for iNdEx := len(keysForTags) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tags[string(keysForTags[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTags[iNdEx])
			copy(dAtA[i:], keysForTags[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForTags[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.RawJson) > 0 {
		i -= len(m.RawJson)
		copy(dAtA[i:], m.RawJson)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RawJson)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Creds) > 0 {
		for iNdEx := len(m.Creds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Creds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LoadBalancer) > 0 {
		for iNdEx := len(m.LoadBalancer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LoadBalancer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.NetworkPeers) > 0 {
		for iNdEx := len(m.NetworkPeers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NetworkPeers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CidrV6) > 0 {
		for iNdEx := len(m.CidrV6) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CidrV6[iNdEx])
			copy(dAtA[i:], m.CidrV6[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.CidrV6[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CidrV4) > 0 {
		for iNdEx := len(m.CidrV4) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CidrV4[iNdEx])
			copy(dAtA[i:], m.CidrV4[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.CidrV4[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Region) > 0 {
		for iNdEx := len(m.Region) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Region[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LoadBalancer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadBalancer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadBalancer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterfaceType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.InterfaceType))
		i--
		dAtA[i] = 0x38
	}
	if len(m.CidrV6) > 0 {
		for iNdEx := len(m.CidrV6) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CidrV6[iNdEx])
			copy(dAtA[i:], m.CidrV6[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.CidrV6[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.CidrV4) > 0 {
		for iNdEx := len(m.CidrV4) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CidrV4[iNdEx])
			copy(dAtA[i:], m.CidrV4[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.CidrV4[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.AvailabilityZone) > 0 {
		i -= len(m.AvailabilityZone)
		copy(dAtA[i:], m.AvailabilityZone)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AvailabilityZone)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Region) > 0 {
		for iNdEx := len(m.Region) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Region[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Network) > 0 {
		for iNdEx := len(m.Network) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Network[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *InstanceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstanceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AvailabilityZone) > 0 {
		i -= len(m.AvailabilityZone)
		copy(dAtA[i:], m.AvailabilityZone)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AvailabilityZone)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.SecurityGroup) > 0 {
		for iNdEx := len(m.SecurityGroup) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SecurityGroup[iNdEx])
			copy(dAtA[i:], m.SecurityGroup[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.SecurityGroup[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.PublicDnsName) > 0 {
		i -= len(m.PublicDnsName)
		copy(dAtA[i:], m.PublicDnsName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicDnsName)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.PrivateDnsName) > 0 {
		i -= len(m.PrivateDnsName)
		copy(dAtA[i:], m.PrivateDnsName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PrivateDnsName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.PublicAddress) > 0 {
		i -= len(m.PublicAddress)
		copy(dAtA[i:], m.PublicAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PrivateAddress) > 0 {
		i -= len(m.PrivateAddress)
		copy(dAtA[i:], m.PrivateAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PrivateAddress)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Platform) > 0 {
		i -= len(m.Platform)
		copy(dAtA[i:], m.Platform)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Platform)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.InstanceType) > 0 {
		i -= len(m.InstanceType)
		copy(dAtA[i:], m.InstanceType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InstanceType)))
		i--
		dAtA[i] = 0x22
	}
	if m.Cpu != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Cpu))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Architecture) > 0 {
		i -= len(m.Architecture)
		copy(dAtA[i:], m.Architecture)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Architecture)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Interfaces) > 0 {
		for iNdEx := len(m.Interfaces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Interfaces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TransitGatewayType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransitGatewayType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransitGatewayType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VpnEcmpSupport {
		i--
		if m.VpnEcmpSupport {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.DnsSupport {
		i--
		if m.DnsSupport {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AutoAcceptSharedAttachments {
		i--
		if m.AutoAcceptSharedAttachments {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Network) > 0 {
		for iNdEx := len(m.Network) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Network[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RouteTableType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTableType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExplicitSubnet) > 0 {
		for iNdEx := len(m.ExplicitSubnet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExplicitSubnet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ImplicitSubnet) > 0 {
		for iNdEx := len(m.ImplicitSubnet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ImplicitSubnet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.RouteTableType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RouteTableType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TransitGateway) > 0 {
		for iNdEx := len(m.TransitGateway) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransitGateway[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Network) > 0 {
		for iNdEx := len(m.Network) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Network[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Subnet) > 0 {
		for iNdEx := len(m.Subnet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subnet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RouteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UserDefinedRouteName) > 0 {
		i -= len(m.UserDefinedRouteName)
		copy(dAtA[i:], m.UserDefinedRouteName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserDefinedRouteName)))
		i--
		dAtA[i] = 0x32
	}
	if m.NextHopType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NextHopType))
		i--
		dAtA[i] = 0x28
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if m.Source != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Nexthop) > 0 {
		i -= len(m.Nexthop)
		copy(dAtA[i:], m.Nexthop)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Nexthop)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SiteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SiteType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DcClusterGroup) > 0 {
		for iNdEx := len(m.DcClusterGroup) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DcClusterGroup[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Tgw) > 0 {
		for iNdEx := len(m.Tgw) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tgw[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Network) > 0 {
		for iNdEx := len(m.Network) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Network[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SiteMeshGroupType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteMeshGroupType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteMeshGroupType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TopologySite) > 0 {
		for iNdEx := len(m.TopologySite) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TopologySite[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.VirtualSite) > 0 {
		for iNdEx := len(m.VirtualSite) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VirtualSite[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.MeshChoice != nil {
		{
			size := m.MeshChoice.Size()
			i -= size
			if _, err := m.MeshChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SiteType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Hub) > 0 {
		for iNdEx := len(m.Hub) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Hub[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SiteMeshGroupType_HubMesh) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteMeshGroupType_HubMesh) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HubMesh != nil {
		{
			size, err := m.HubMesh.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *SiteMeshGroupType_SpokeMesh) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteMeshGroupType_SpokeMesh) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SpokeMesh != nil {
		{
			size, err := m.SpokeMesh.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *SiteMeshGroupType_FullMesh) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteMeshGroupType_FullMesh) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FullMesh != nil {
		{
			size, err := m.FullMesh.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *DCClusterGroupType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DCClusterGroupType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DCClusterGroupType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkInterfaceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SecurityGroup) > 0 {
		for iNdEx := len(m.SecurityGroup) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SecurityGroup[iNdEx])
			copy(dAtA[i:], m.SecurityGroup[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.SecurityGroup[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.PublicAddress) > 0 {
		for iNdEx := len(m.PublicAddress) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PublicAddress[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PrivateAddresses) > 0 {
		for iNdEx := len(m.PrivateAddresses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PrivateAddresses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Subnet) > 0 {
		for iNdEx := len(m.Subnet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subnet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AddressInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Primary {
		i--
		if m.Primary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.DnsName) > 0 {
		i -= len(m.DnsName)
		copy(dAtA[i:], m.DnsName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DnsName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TunnelSetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelSetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelSetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tunnels) > 0 {
		for iNdEx := len(m.Tunnels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tunnels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Site) > 0 {
		for iNdEx := len(m.Site) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Site[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NetworkPeerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkPeerType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPeerType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PeerChoice != nil {
		{
			size := m.PeerChoice.Size()
			i -= size
			if _, err := m.PeerChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *NetworkPeerType_VnetPeer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPeerType_VnetPeer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VnetPeer != nil {
		{
			size, err := m.VnetPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AzureVnetPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetPeer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetPeer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PeeringState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PeeringState))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PeerNetwork) > 0 {
		for iNdEx := len(m.PeerNetwork) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PeerNetwork[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TunnelType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tgw) > 0 {
		for iNdEx := len(m.Tgw) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tgw[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Site) > 0 {
		for iNdEx := len(m.Site) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Site[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Connection != nil {
		{
			size, err := m.Connection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudPolicyType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudPolicyType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudPolicyType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CloudProviderError) > 0 {
		i -= len(m.CloudProviderError)
		copy(dAtA[i:], m.CloudProviderError)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CloudProviderError)))
		i--
		dAtA[i] = 0x32
	}
	if m.PermissionsPopulated {
		i--
		if m.PermissionsPopulated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.CloudType != nil {
		{
			size := m.CloudType.Size()
			i -= size
			if _, err := m.CloudType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CloudPolicyType_Aws) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudPolicyType_Aws) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Aws != nil {
		{
			size, err := m.Aws.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AWSPolicyType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSPolicyType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSPolicyType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MissingPermissionsAwsTgwSite) > 0 {
		for iNdEx := len(m.MissingPermissionsAwsTgwSite) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MissingPermissionsAwsTgwSite[iNdEx])
			copy(dAtA[i:], m.MissingPermissionsAwsTgwSite[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.MissingPermissionsAwsTgwSite[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.SupportAwsTgwSite {
		i--
		if m.SupportAwsTgwSite {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.MissingPermissionsAwsVpcSite) > 0 {
		for iNdEx := len(m.MissingPermissionsAwsVpcSite) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MissingPermissionsAwsVpcSite[iNdEx])
			copy(dAtA[i:], m.MissingPermissionsAwsVpcSite[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.MissingPermissionsAwsVpcSite[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.SupportAwsVpcSite {
		i--
		if m.SupportAwsVpcSite {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Creds) > 0 {
		for _, e := range m.Creds {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.RawJson)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.OwnerId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ProviderType != 0 {
		n += 1 + sovTypes(uint64(m.ProviderType))
	}
	return n
}

func (m *NetworkType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Region) > 0 {
		for _, e := range m.Region {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CidrV4) > 0 {
		for _, s := range m.CidrV4 {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CidrV6) > 0 {
		for _, s := range m.CidrV6 {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.NetworkPeers) > 0 {
		for _, e := range m.NetworkPeers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.LoadBalancer) > 0 {
		for _, e := range m.LoadBalancer {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *LoadBalancer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SubnetType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Network) > 0 {
		for _, e := range m.Network {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Region) > 0 {
		for _, e := range m.Region {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.AvailabilityZone)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CidrV4) > 0 {
		for _, s := range m.CidrV4 {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CidrV6) > 0 {
		for _, s := range m.CidrV6 {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InterfaceType != 0 {
		n += 1 + sovTypes(uint64(m.InterfaceType))
	}
	return n
}

func (m *InstanceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for _, e := range m.Interfaces {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Architecture)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cpu != 0 {
		n += 1 + sovTypes(uint64(m.Cpu))
	}
	l = len(m.InstanceType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PrivateAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PrivateDnsName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicDnsName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.SecurityGroup) > 0 {
		for _, s := range m.SecurityGroup {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.AvailabilityZone)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TransitGatewayType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Network) > 0 {
		for _, e := range m.Network {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.AutoAcceptSharedAttachments {
		n += 2
	}
	if m.DnsSupport {
		n += 2
	}
	if m.VpnEcmpSupport {
		n += 2
	}
	return n
}

func (m *RouteTableType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Subnet) > 0 {
		for _, e := range m.Subnet {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Network) > 0 {
		for _, e := range m.Network {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.TransitGateway) > 0 {
		for _, e := range m.TransitGateway {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.RouteTableType != 0 {
		n += 1 + sovTypes(uint64(m.RouteTableType))
	}
	if len(m.ImplicitSubnet) > 0 {
		for _, e := range m.ImplicitSubnet {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ExplicitSubnet) > 0 {
		for _, e := range m.ExplicitSubnet {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *RouteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Nexthop)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Source != 0 {
		n += 1 + sovTypes(uint64(m.Source))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	if m.NextHopType != 0 {
		n += 1 + sovTypes(uint64(m.NextHopType))
	}
	l = len(m.UserDefinedRouteName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SiteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Network) > 0 {
		for _, e := range m.Network {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Tgw) > 0 {
		for _, e := range m.Tgw {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.DcClusterGroup) > 0 {
		for _, e := range m.DcClusterGroup {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.SiteType != 0 {
		n += 1 + sovTypes(uint64(m.SiteType))
	}
	return n
}

func (m *SiteMeshGroupType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if len(m.Hub) > 0 {
		for _, e := range m.Hub {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.SiteType != 0 {
		n += 1 + sovTypes(uint64(m.SiteType))
	}
	if m.MeshChoice != nil {
		n += m.MeshChoice.Size()
	}
	if len(m.VirtualSite) > 0 {
		for _, e := range m.VirtualSite {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.TopologySite) > 0 {
		for _, e := range m.TopologySite {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SiteMeshGroupType_HubMesh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HubMesh != nil {
		l = m.HubMesh.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SiteMeshGroupType_SpokeMesh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpokeMesh != nil {
		l = m.SpokeMesh.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SiteMeshGroupType_FullMesh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FullMesh != nil {
		l = m.FullMesh.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DCClusterGroupType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *NetworkInterfaceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Subnet) > 0 {
		for _, e := range m.Subnet {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.PrivateAddresses) > 0 {
		for _, e := range m.PrivateAddresses {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.PublicAddress) > 0 {
		for _, e := range m.PublicAddress {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.SecurityGroup) > 0 {
		for _, s := range m.SecurityGroup {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AddressInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DnsName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Primary {
		n += 2
	}
	return n
}

func (m *TunnelSetType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Site) > 0 {
		for _, e := range m.Site {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Tunnels) > 0 {
		for _, e := range m.Tunnels {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *NetworkPeerType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PeerChoice != nil {
		n += m.PeerChoice.Size()
	}
	return n
}

func (m *NetworkPeerType_VnetPeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VnetPeer != nil {
		l = m.VnetPeer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AzureVnetPeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PeerNetwork) > 0 {
		for _, e := range m.PeerNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.PeeringState != 0 {
		n += 1 + sovTypes(uint64(m.PeeringState))
	}
	return n
}

func (m *TunnelType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connection != nil {
		l = m.Connection.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Site) > 0 {
		for _, e := range m.Site {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Tgw) > 0 {
		for _, e := range m.Tgw {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CloudPolicyType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudType != nil {
		n += m.CloudType.Size()
	}
	if m.PermissionsPopulated {
		n += 2
	}
	l = len(m.CloudProviderError)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CloudPolicyType_Aws) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aws != nil {
		l = m.Aws.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSPolicyType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SupportAwsVpcSite {
		n += 2
	}
	if len(m.MissingPermissionsAwsVpcSite) > 0 {
		for _, s := range m.MissingPermissionsAwsVpcSite {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.SupportAwsTgwSite {
		n += 2
	}
	if len(m.MissingPermissionsAwsTgwSite) > 0 {
		for _, s := range m.MissingPermissionsAwsTgwSite {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *MetaType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCreds := "[]*ObjectRefType{"
	for _, f := range this.Creds {
		repeatedStringForCreds += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCreds += "}"
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&MetaType{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Creds:` + repeatedStringForCreds + `,`,
		`RawJson:` + fmt.Sprintf("%v", this.RawJson) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`OwnerId:` + fmt.Sprintf("%v", this.OwnerId) + `,`,
		`ProviderType:` + fmt.Sprintf("%v", this.ProviderType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRegion := "[]*ObjectRefType{"
	for _, f := range this.Region {
		repeatedStringForRegion += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRegion += "}"
	repeatedStringForNetworkPeers := "[]*ObjectRefType{"
	for _, f := range this.NetworkPeers {
		repeatedStringForNetworkPeers += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForNetworkPeers += "}"
	repeatedStringForLoadBalancer := "[]*LoadBalancer{"
	for _, f := range this.LoadBalancer {
		repeatedStringForLoadBalancer += strings.Replace(f.String(), "LoadBalancer", "LoadBalancer", 1) + ","
	}
	repeatedStringForLoadBalancer += "}"
	s := strings.Join([]string{`&NetworkType{`,
		`Region:` + repeatedStringForRegion + `,`,
		`CidrV4:` + fmt.Sprintf("%v", this.CidrV4) + `,`,
		`CidrV6:` + fmt.Sprintf("%v", this.CidrV6) + `,`,
		`NetworkPeers:` + repeatedStringForNetworkPeers + `,`,
		`LoadBalancer:` + repeatedStringForLoadBalancer + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoadBalancer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoadBalancer{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SubnetType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNetwork := "[]*ObjectRefType{"
	for _, f := range this.Network {
		repeatedStringForNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForNetwork += "}"
	repeatedStringForRegion := "[]*ObjectRefType{"
	for _, f := range this.Region {
		repeatedStringForRegion += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRegion += "}"
	s := strings.Join([]string{`&SubnetType{`,
		`Network:` + repeatedStringForNetwork + `,`,
		`Region:` + repeatedStringForRegion + `,`,
		`AvailabilityZone:` + fmt.Sprintf("%v", this.AvailabilityZone) + `,`,
		`CidrV4:` + fmt.Sprintf("%v", this.CidrV4) + `,`,
		`CidrV6:` + fmt.Sprintf("%v", this.CidrV6) + `,`,
		`InterfaceType:` + fmt.Sprintf("%v", this.InterfaceType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InstanceType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInterfaces := "[]*NetworkInterfaceType{"
	for _, f := range this.Interfaces {
		repeatedStringForInterfaces += strings.Replace(f.String(), "NetworkInterfaceType", "NetworkInterfaceType", 1) + ","
	}
	repeatedStringForInterfaces += "}"
	s := strings.Join([]string{`&InstanceType{`,
		`Interfaces:` + repeatedStringForInterfaces + `,`,
		`Architecture:` + fmt.Sprintf("%v", this.Architecture) + `,`,
		`Cpu:` + fmt.Sprintf("%v", this.Cpu) + `,`,
		`InstanceType:` + fmt.Sprintf("%v", this.InstanceType) + `,`,
		`Platform:` + fmt.Sprintf("%v", this.Platform) + `,`,
		`PrivateAddress:` + fmt.Sprintf("%v", this.PrivateAddress) + `,`,
		`PublicAddress:` + fmt.Sprintf("%v", this.PublicAddress) + `,`,
		`PrivateDnsName:` + fmt.Sprintf("%v", this.PrivateDnsName) + `,`,
		`PublicDnsName:` + fmt.Sprintf("%v", this.PublicDnsName) + `,`,
		`SecurityGroup:` + fmt.Sprintf("%v", this.SecurityGroup) + `,`,
		`AvailabilityZone:` + fmt.Sprintf("%v", this.AvailabilityZone) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TransitGatewayType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNetwork := "[]*ObjectRefType{"
	for _, f := range this.Network {
		repeatedStringForNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForNetwork += "}"
	s := strings.Join([]string{`&TransitGatewayType{`,
		`Network:` + repeatedStringForNetwork + `,`,
		`AutoAcceptSharedAttachments:` + fmt.Sprintf("%v", this.AutoAcceptSharedAttachments) + `,`,
		`DnsSupport:` + fmt.Sprintf("%v", this.DnsSupport) + `,`,
		`VpnEcmpSupport:` + fmt.Sprintf("%v", this.VpnEcmpSupport) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteTableType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSubnet := "[]*ObjectRefType{"
	for _, f := range this.Subnet {
		repeatedStringForSubnet += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSubnet += "}"
	repeatedStringForNetwork := "[]*ObjectRefType{"
	for _, f := range this.Network {
		repeatedStringForNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForNetwork += "}"
	repeatedStringForTransitGateway := "[]*ObjectRefType{"
	for _, f := range this.TransitGateway {
		repeatedStringForTransitGateway += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForTransitGateway += "}"
	repeatedStringForRoutes := "[]*RouteType{"
	for _, f := range this.Routes {
		repeatedStringForRoutes += strings.Replace(f.String(), "RouteType", "RouteType", 1) + ","
	}
	repeatedStringForRoutes += "}"
	repeatedStringForImplicitSubnet := "[]*ObjectRefType{"
	for _, f := range this.ImplicitSubnet {
		repeatedStringForImplicitSubnet += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForImplicitSubnet += "}"
	repeatedStringForExplicitSubnet := "[]*ObjectRefType{"
	for _, f := range this.ExplicitSubnet {
		repeatedStringForExplicitSubnet += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForExplicitSubnet += "}"
	s := strings.Join([]string{`&RouteTableType{`,
		`Subnet:` + repeatedStringForSubnet + `,`,
		`Network:` + repeatedStringForNetwork + `,`,
		`TransitGateway:` + repeatedStringForTransitGateway + `,`,
		`Routes:` + repeatedStringForRoutes + `,`,
		`RouteTableType:` + fmt.Sprintf("%v", this.RouteTableType) + `,`,
		`ImplicitSubnet:` + repeatedStringForImplicitSubnet + `,`,
		`ExplicitSubnet:` + repeatedStringForExplicitSubnet + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteType{`,
		`Destination:` + fmt.Sprintf("%v", this.Destination) + `,`,
		`Nexthop:` + fmt.Sprintf("%v", this.Nexthop) + `,`,
		`Source:` + fmt.Sprintf("%v", this.Source) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`NextHopType:` + fmt.Sprintf("%v", this.NextHopType) + `,`,
		`UserDefinedRouteName:` + fmt.Sprintf("%v", this.UserDefinedRouteName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNetwork := "[]*ObjectRefType{"
	for _, f := range this.Network {
		repeatedStringForNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForNetwork += "}"
	repeatedStringForTgw := "[]*ObjectRefType{"
	for _, f := range this.Tgw {
		repeatedStringForTgw += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForTgw += "}"
	repeatedStringForDcClusterGroup := "[]*ObjectRefType{"
	for _, f := range this.DcClusterGroup {
		repeatedStringForDcClusterGroup += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForDcClusterGroup += "}"
	s := strings.Join([]string{`&SiteType{`,
		`Network:` + repeatedStringForNetwork + `,`,
		`Tgw:` + repeatedStringForTgw + `,`,
		`DcClusterGroup:` + repeatedStringForDcClusterGroup + `,`,
		`SiteType:` + fmt.Sprintf("%v", this.SiteType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteMeshGroupType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHub := "[]*ObjectRefType{"
	for _, f := range this.Hub {
		repeatedStringForHub += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForHub += "}"
	repeatedStringForVirtualSite := "[]*ObjectRefType{"
	for _, f := range this.VirtualSite {
		repeatedStringForVirtualSite += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForVirtualSite += "}"
	repeatedStringForTopologySite := "[]*ObjectRefType{"
	for _, f := range this.TopologySite {
		repeatedStringForTopologySite += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForTopologySite += "}"
	s := strings.Join([]string{`&SiteMeshGroupType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Hub:` + repeatedStringForHub + `,`,
		`SiteType:` + fmt.Sprintf("%v", this.SiteType) + `,`,
		`MeshChoice:` + fmt.Sprintf("%v", this.MeshChoice) + `,`,
		`VirtualSite:` + repeatedStringForVirtualSite + `,`,
		`TopologySite:` + repeatedStringForTopologySite + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteMeshGroupType_HubMesh) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteMeshGroupType_HubMesh{`,
		`HubMesh:` + strings.Replace(fmt.Sprintf("%v", this.HubMesh), "HubFullMeshGroupType", "site_mesh_group.HubFullMeshGroupType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteMeshGroupType_SpokeMesh) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteMeshGroupType_SpokeMesh{`,
		`SpokeMesh:` + strings.Replace(fmt.Sprintf("%v", this.SpokeMesh), "SpokeMeshGroupType", "site_mesh_group.SpokeMeshGroupType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteMeshGroupType_FullMesh) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteMeshGroupType_FullMesh{`,
		`FullMesh:` + strings.Replace(fmt.Sprintf("%v", this.FullMesh), "FullMeshGroupType", "site_mesh_group.FullMeshGroupType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DCClusterGroupType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DCClusterGroupType{`,
		`Type:` + strings.Replace(fmt.Sprintf("%v", this.Type), "DCClusterGroupMeshType", "dc_cluster_group.DCClusterGroupMeshType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkInterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSubnet := "[]*ObjectRefType{"
	for _, f := range this.Subnet {
		repeatedStringForSubnet += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSubnet += "}"
	repeatedStringForPrivateAddresses := "[]*AddressInfoType{"
	for _, f := range this.PrivateAddresses {
		repeatedStringForPrivateAddresses += strings.Replace(f.String(), "AddressInfoType", "AddressInfoType", 1) + ","
	}
	repeatedStringForPrivateAddresses += "}"
	repeatedStringForPublicAddress := "[]*AddressInfoType{"
	for _, f := range this.PublicAddress {
		repeatedStringForPublicAddress += strings.Replace(f.String(), "AddressInfoType", "AddressInfoType", 1) + ","
	}
	repeatedStringForPublicAddress += "}"
	s := strings.Join([]string{`&NetworkInterfaceType{`,
		`Subnet:` + repeatedStringForSubnet + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`PrivateAddresses:` + repeatedStringForPrivateAddresses + `,`,
		`PublicAddress:` + repeatedStringForPublicAddress + `,`,
		`SecurityGroup:` + fmt.Sprintf("%v", this.SecurityGroup) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AddressInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AddressInfoType{`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`DnsName:` + fmt.Sprintf("%v", this.DnsName) + `,`,
		`Primary:` + fmt.Sprintf("%v", this.Primary) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelSetType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSite := "[]*ObjectRefType{"
	for _, f := range this.Site {
		repeatedStringForSite += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSite += "}"
	repeatedStringForTunnels := "[]*TunnelType{"
	for _, f := range this.Tunnels {
		repeatedStringForTunnels += strings.Replace(f.String(), "TunnelType", "TunnelType", 1) + ","
	}
	repeatedStringForTunnels += "}"
	s := strings.Join([]string{`&TunnelSetType{`,
		`Site:` + repeatedStringForSite + `,`,
		`Tunnels:` + repeatedStringForTunnels + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPeerType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPeerType{`,
		`PeerChoice:` + fmt.Sprintf("%v", this.PeerChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPeerType_VnetPeer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPeerType_VnetPeer{`,
		`VnetPeer:` + strings.Replace(fmt.Sprintf("%v", this.VnetPeer), "AzureVnetPeer", "AzureVnetPeer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetPeer) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPeerNetwork := "[]*ObjectRefType{"
	for _, f := range this.PeerNetwork {
		repeatedStringForPeerNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForPeerNetwork += "}"
	s := strings.Join([]string{`&AzureVnetPeer{`,
		`PeerNetwork:` + repeatedStringForPeerNetwork + `,`,
		`PeeringState:` + fmt.Sprintf("%v", this.PeeringState) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSite := "[]*ObjectRefType{"
	for _, f := range this.Site {
		repeatedStringForSite += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSite += "}"
	repeatedStringForTgw := "[]*ObjectRefType{"
	for _, f := range this.Tgw {
		repeatedStringForTgw += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForTgw += "}"
	s := strings.Join([]string{`&TunnelType{`,
		`Connection:` + strings.Replace(fmt.Sprintf("%v", this.Connection), "TunnelConnectionStatus", "site.TunnelConnectionStatus", 1) + `,`,
		`Site:` + repeatedStringForSite + `,`,
		`Tgw:` + repeatedStringForTgw + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudPolicyType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudPolicyType{`,
		`CloudType:` + fmt.Sprintf("%v", this.CloudType) + `,`,
		`PermissionsPopulated:` + fmt.Sprintf("%v", this.PermissionsPopulated) + `,`,
		`CloudProviderError:` + fmt.Sprintf("%v", this.CloudProviderError) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudPolicyType_Aws) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudPolicyType_Aws{`,
		`Aws:` + strings.Replace(fmt.Sprintf("%v", this.Aws), "AWSPolicyType", "AWSPolicyType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSPolicyType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSPolicyType{`,
		`SupportAwsVpcSite:` + fmt.Sprintf("%v", this.SupportAwsVpcSite) + `,`,
		`MissingPermissionsAwsVpcSite:` + fmt.Sprintf("%v", this.MissingPermissionsAwsVpcSite) + `,`,
		`SupportAwsTgwSite:` + fmt.Sprintf("%v", this.SupportAwsTgwSite) + `,`,
		`MissingPermissionsAwsTgwSite:` + fmt.Sprintf("%v", this.MissingPermissionsAwsTgwSite) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *MetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creds = append(m.Creds, &schema.ObjectRefType{})
			if err := m.Creds[len(m.Creds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawJson = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderType", wireType)
			}
			m.ProviderType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProviderType |= ProviderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = append(m.Region, &schema.ObjectRefType{})
			if err := m.Region[len(m.Region)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CidrV4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CidrV4 = append(m.CidrV4, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CidrV6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CidrV6 = append(m.CidrV6, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkPeers = append(m.NetworkPeers, &schema.ObjectRefType{})
			if err := m.NetworkPeers[len(m.NetworkPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadBalancer = append(m.LoadBalancer, &LoadBalancer{})
			if err := m.LoadBalancer[len(m.LoadBalancer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadBalancer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadBalancer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadBalancer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = append(m.Network, &schema.ObjectRefType{})
			if err := m.Network[len(m.Network)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = append(m.Region, &schema.ObjectRefType{})
			if err := m.Region[len(m.Region)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CidrV4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CidrV4 = append(m.CidrV4, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CidrV6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CidrV6 = append(m.CidrV6, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceType", wireType)
			}
			m.InterfaceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceType |= InterfaceTypeEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interfaces = append(m.Interfaces, &NetworkInterfaceType{})
			if err := m.Interfaces[len(m.Interfaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Architecture = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			m.Cpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateDnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateDnsName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicDnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicDnsName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityGroup = append(m.SecurityGroup, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransitGatewayType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransitGatewayType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransitGatewayType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = append(m.Network, &schema.ObjectRefType{})
			if err := m.Network[len(m.Network)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoAcceptSharedAttachments", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoAcceptSharedAttachments = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsSupport", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DnsSupport = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpnEcmpSupport", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VpnEcmpSupport = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnet = append(m.Subnet, &schema.ObjectRefType{})
			if err := m.Subnet[len(m.Subnet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = append(m.Network, &schema.ObjectRefType{})
			if err := m.Network[len(m.Network)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransitGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransitGateway = append(m.TransitGateway, &schema.ObjectRefType{})
			if err := m.TransitGateway[len(m.TransitGateway)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &RouteType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTableType", wireType)
			}
			m.RouteTableType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteTableType |= RouteTableTypeEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplicitSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImplicitSubnet = append(m.ImplicitSubnet, &schema.ObjectRefType{})
			if err := m.ImplicitSubnet[len(m.ImplicitSubnet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExplicitSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExplicitSubnet = append(m.ExplicitSubnet, &schema.ObjectRefType{})
			if err := m.ExplicitSubnet[len(m.ExplicitSubnet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nexthop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nexthop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= RouteSourceTypeEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= RouteStateTypeEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHopType", wireType)
			}
			m.NextHopType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextHopType |= RouteNextHopTypeEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDefinedRouteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserDefinedRouteName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = append(m.Network, &schema.ObjectRefType{})
			if err := m.Network[len(m.Network)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tgw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tgw = append(m.Tgw, &schema.ObjectRefType{})
			if err := m.Tgw[len(m.Tgw)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DcClusterGroup = append(m.DcClusterGroup, &schema.ObjectRefType{})
			if err := m.DcClusterGroup[len(m.DcClusterGroup)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteType", wireType)
			}
			m.SiteType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteType |= site.SiteType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteMeshGroupType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteMeshGroupType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteMeshGroupType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= site_mesh_group.SiteMeshGroupType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hub", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hub = append(m.Hub, &schema.ObjectRefType{})
			if err := m.Hub[len(m.Hub)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteType", wireType)
			}
			m.SiteType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteType |= site.SiteType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HubMesh", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &site_mesh_group.HubFullMeshGroupType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MeshChoice = &SiteMeshGroupType_HubMesh{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpokeMesh", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &site_mesh_group.SpokeMeshGroupType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MeshChoice = &SiteMeshGroupType_SpokeMesh{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullMesh", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &site_mesh_group.FullMeshGroupType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MeshChoice = &SiteMeshGroupType_FullMesh{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualSite = append(m.VirtualSite, &schema.ObjectRefType{})
			if err := m.VirtualSite[len(m.VirtualSite)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopologySite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopologySite = append(m.TopologySite, &schema.ObjectRefType{})
			if err := m.TopologySite[len(m.TopologySite)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DCClusterGroupType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DCClusterGroupType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DCClusterGroupType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &dc_cluster_group.DCClusterGroupMeshType{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnet = append(m.Subnet, &schema.ObjectRefType{})
			if err := m.Subnet[len(m.Subnet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateAddresses = append(m.PrivateAddresses, &AddressInfoType{})
			if err := m.PrivateAddresses[len(m.PrivateAddresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicAddress = append(m.PublicAddress, &AddressInfoType{})
			if err := m.PublicAddress[len(m.PublicAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityGroup = append(m.SecurityGroup, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Primary = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelSetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelSetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelSetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = append(m.Site, &schema.ObjectRefType{})
			if err := m.Site[len(m.Site)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tunnels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tunnels = append(m.Tunnels, &TunnelType{})
			if err := m.Tunnels[len(m.Tunnels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkPeerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkPeerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkPeerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnetPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureVnetPeer{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PeerChoice = &NetworkPeerType_VnetPeer{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetPeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerNetwork = append(m.PeerNetwork, &schema.ObjectRefType{})
			if err := m.PeerNetwork[len(m.PeerNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeeringState", wireType)
			}
			m.PeeringState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeeringState |= PeeringStateEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connection == nil {
				m.Connection = &site.TunnelConnectionStatus{}
			}
			if err := m.Connection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = append(m.Site, &schema.ObjectRefType{})
			if err := m.Site[len(m.Site)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tgw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tgw = append(m.Tgw, &schema.ObjectRefType{})
			if err := m.Tgw[len(m.Tgw)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudPolicyType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudPolicyType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudPolicyType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aws", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSPolicyType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudType = &CloudPolicyType_Aws{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermissionsPopulated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PermissionsPopulated = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudProviderError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudProviderError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSPolicyType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSPolicyType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSPolicyType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportAwsVpcSite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportAwsVpcSite = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingPermissionsAwsVpcSite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MissingPermissionsAwsVpcSite = append(m.MissingPermissionsAwsVpcSite, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportAwsTgwSite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportAwsTgwSite = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingPermissionsAwsTgwSite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MissingPermissionsAwsTgwSite = append(m.MissingPermissionsAwsTgwSite, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
