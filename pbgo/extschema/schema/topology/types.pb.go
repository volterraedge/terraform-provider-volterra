// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/topology/types.proto

package topology

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	_ "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	dc_cluster_group "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/dc_cluster_group"
	site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/site"
	site_mesh_group "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/site_mesh_group"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ProviderType
//
// x-displayName: "Provider Type"
// provider type
type ProviderType int32

const (
	// x-displayName: "Unspecified"
	// ProviderType unspecified
	PROVIDER_TYPE_UNSPECIFIED ProviderType = 0
	// x-displayName: "AWS"
	// AWS backend
	PROVIDER_TYPE_AWS ProviderType = 1
	// x-displayName: "GCP"
	// GCP backend
	PROVIDER_TYPE_GCP ProviderType = 2
	// x-displayName: "Azure"
	// Azure backend
	PROVIDER_TYPE_AZURE ProviderType = 3
	// x-displayName: "Volterra"
	// F5XC backend
	PROVIDER_TYPE_VOLTERRA ProviderType = 4
)

var ProviderType_name = map[int32]string{
	0: "PROVIDER_TYPE_UNSPECIFIED",
	1: "PROVIDER_TYPE_AWS",
	2: "PROVIDER_TYPE_GCP",
	3: "PROVIDER_TYPE_AZURE",
	4: "PROVIDER_TYPE_VOLTERRA",
}

var ProviderType_value = map[string]int32{
	"PROVIDER_TYPE_UNSPECIFIED": 0,
	"PROVIDER_TYPE_AWS":         1,
	"PROVIDER_TYPE_GCP":         2,
	"PROVIDER_TYPE_AZURE":       3,
	"PROVIDER_TYPE_VOLTERRA":    4,
}

func (ProviderType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{0}
}

// SiteEnumType
//
// x-displayName: "Site Type"
// Site Specific type
type SiteEnumType int32

const (
	// x-displayName: "Unspecified"
	// SiteType unspecified
	SITE_TYPE_UNSPECIFIED SiteEnumType = 0
	// x-displayName: "RE"
	// RE SiteType
	SITE_TYPE_RE SiteEnumType = 1
	// x-displayName: "AWS TGW Site CE"
	// AWS TGW Site CE
	SITE_TYPE_AWS_TGW SiteEnumType = 2
)

var SiteEnumType_name = map[int32]string{
	0: "SITE_TYPE_UNSPECIFIED",
	1: "SITE_TYPE_RE",
	2: "SITE_TYPE_AWS_TGW",
}

var SiteEnumType_value = map[string]int32{
	"SITE_TYPE_UNSPECIFIED": 0,
	"SITE_TYPE_RE":          1,
	"SITE_TYPE_AWS_TGW":     2,
}

func (SiteEnumType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{1}
}

// RouteTableStateEnum
//
// x-displayName: "Route Table State"
// Route table state
type RouteTableStateEnum int32

const (
	// x-displayName: "Route table state None"
	// Route table state None
	ROUTE_TABLE_STATE_NONE RouteTableStateEnum = 0
	// x-displayName: "Route table state Pending"
	// Route table state Pending
	ROUTE_TABLE_STATE_PENDING RouteTableStateEnum = 1
	// x-displayName: "Route table state Available"
	// Route table state Availble
	ROUTE_TABLE_STATE_AVAILABLE RouteTableStateEnum = 2
	// x-displayName: "Route table state Deleting"
	// Route table state Deleting
	ROUTE_TABLE_STATE_DELETING RouteTableStateEnum = 3
	// x-displayName: "Route table state Deleted"
	// Route table state Deleted
	ROUTE_TABLE_STATE_DELETED RouteTableStateEnum = 4
)

var RouteTableStateEnum_name = map[int32]string{
	0: "ROUTE_TABLE_STATE_NONE",
	1: "ROUTE_TABLE_STATE_PENDING",
	2: "ROUTE_TABLE_STATE_AVAILABLE",
	3: "ROUTE_TABLE_STATE_DELETING",
	4: "ROUTE_TABLE_STATE_DELETED",
}

var RouteTableStateEnum_value = map[string]int32{
	"ROUTE_TABLE_STATE_NONE":      0,
	"ROUTE_TABLE_STATE_PENDING":   1,
	"ROUTE_TABLE_STATE_AVAILABLE": 2,
	"ROUTE_TABLE_STATE_DELETING":  3,
	"ROUTE_TABLE_STATE_DELETED":   4,
}

func (RouteTableStateEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{2}
}

// RouteTableTypeEnum
//
// x-displayName: "Route Table Type"
// Route table backend.
type RouteTableTypeEnum int32

const (
	// x-displayName: "Route table for network"
	// Route table for network
	ROUTE_TABLE_NETWORK RouteTableTypeEnum = 0
	// x-displayName: "Route Table for transit gateway"
	// Route Table for transit gateway
	ROUTE_TABLE_TGW RouteTableTypeEnum = 1
)

var RouteTableTypeEnum_name = map[int32]string{
	0: "ROUTE_TABLE_NETWORK",
	1: "ROUTE_TABLE_TGW",
}

var RouteTableTypeEnum_value = map[string]int32{
	"ROUTE_TABLE_NETWORK": 0,
	"ROUTE_TABLE_TGW":     1,
}

func (RouteTableTypeEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{3}
}

// Cloud NetworkType
//
// x-displayName: "Cloud Network Type"
// Cloud Network Type.
type CloudNetworkType int32

const (
	// x-displayName: "Network Type None"
	// Network None
	NETWORK_TYPE_NONE CloudNetworkType = 0
	// x-displayName: "Network Type Azure Hub VNET"
	// Network Type Azure Hub VNET
	NETWORK_TYPE_HUB_VNET CloudNetworkType = 1
	// x-displayName: "Network Type Spoke VNET"
	// Network Type Spoke VNET
	NETWORK_TYPE_SPOKE_VNET CloudNetworkType = 2
	// x-displayName: "Network Type Service VPC"
	// Network Type Service VPC
	NETWORK_TYPE_SERVICE_VPC CloudNetworkType = 3
	// x-displayName: "Network Type Spoke VPC"
	// Network Type Spoke VPC
	NETWORK_TYPE_SPOKE_VPC CloudNetworkType = 4
)

var CloudNetworkType_name = map[int32]string{
	0: "NETWORK_TYPE_NONE",
	1: "NETWORK_TYPE_HUB_VNET",
	2: "NETWORK_TYPE_SPOKE_VNET",
	3: "NETWORK_TYPE_SERVICE_VPC",
	4: "NETWORK_TYPE_SPOKE_VPC",
}

var CloudNetworkType_value = map[string]int32{
	"NETWORK_TYPE_NONE":        0,
	"NETWORK_TYPE_HUB_VNET":    1,
	"NETWORK_TYPE_SPOKE_VNET":  2,
	"NETWORK_TYPE_SERVICE_VPC": 3,
	"NETWORK_TYPE_SPOKE_VPC":   4,
}

func (CloudNetworkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{4}
}

type InterfaceTypeEnum int32

const (
	// OUTSIDE Interface
	//
	// x-displayName: "Outside Interface"
	OUTSIDE InterfaceTypeEnum = 0
	// INSIDE Interface
	//
	// x-displayName: "Inside Interface"
	INSIDE InterfaceTypeEnum = 1
	// Workload Interface
	//
	// x-displayName: "Workload Interface"
	WORKLOAD InterfaceTypeEnum = 2
	// NOT_APPLICABLE
	//
	// x-displayName: "NOT_APPLICABLE"
	// Ex - When the subnet belongs to a azure spoke vnet
	NOT_APPLICABLE InterfaceTypeEnum = 3
)

var InterfaceTypeEnum_name = map[int32]string{
	0: "OUTSIDE",
	1: "INSIDE",
	2: "WORKLOAD",
	3: "NOT_APPLICABLE",
}

var InterfaceTypeEnum_value = map[string]int32{
	"OUTSIDE":        0,
	"INSIDE":         1,
	"WORKLOAD":       2,
	"NOT_APPLICABLE": 3,
}

func (InterfaceTypeEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{5}
}

// RouteSourceTypeEnum
//
// x-displayName: RouteSourceTypeEnum
// RouteSourceTypeEnum
type RouteSourceTypeEnum int32

const (
	// INVALID_SOURCE
	//
	// x-displayName: INVALID_SOURCE
	// INVALID_SOURCE
	INVALID_SOURCE RouteSourceTypeEnum = 0
	// DEFAULT
	//
	// x-displayName: DEFAULT
	// DEFAULT
	DEFAULT RouteSourceTypeEnum = 1
	// USER
	//
	// x-displayName: USER
	// USER
	USER RouteSourceTypeEnum = 2
	// UNKNOWN
	//
	// x-displayName: UNKNOWN
	// UNKNOWN
	UNKNOWN RouteSourceTypeEnum = 3
	// VIRTUAL_NETWORK_GATEWAY_SOURCE
	//
	// x-displayName: VIRTUAL_NETWORK_GATEWAY_SOURCE
	// VIRTUAL_NETWORK_GATEWAY_SOURCE
	VIRTUAL_NETWORK_GATEWAY_SOURCE RouteSourceTypeEnum = 4
	// SOURCE_NOT_APPLICABLE
	//
	// x-displayName: SOURCE_NOT_APPLICABLE
	// SOURCE_NOT_APPLICABLE should be used when the cloud provider does not supports this.
	SOURCE_NOT_APPLICABLE RouteSourceTypeEnum = 5
)

var RouteSourceTypeEnum_name = map[int32]string{
	0: "INVALID_SOURCE",
	1: "DEFAULT",
	2: "USER",
	3: "UNKNOWN",
	4: "VIRTUAL_NETWORK_GATEWAY_SOURCE",
	5: "SOURCE_NOT_APPLICABLE",
}

var RouteSourceTypeEnum_value = map[string]int32{
	"INVALID_SOURCE":                 0,
	"DEFAULT":                        1,
	"USER":                           2,
	"UNKNOWN":                        3,
	"VIRTUAL_NETWORK_GATEWAY_SOURCE": 4,
	"SOURCE_NOT_APPLICABLE":          5,
}

func (RouteSourceTypeEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{6}
}

// RouteStateTypeEnum
//
// x-displayName: RouteStateTypeEnum
// RouteStateTypeEnum
type RouteStateTypeEnum int32

const (
	// ACTIVE_STATE
	//
	// x-displayName: ACTIVE_STATE
	// ACTIVE_STATE
	ACTIVE_STATE RouteStateTypeEnum = 0
	// INVALID_STATE
	//
	// x-displayName: INVALID_STATE
	// INVALID_STATE
	INVALID_STATE RouteStateTypeEnum = 1
	// STATE_NOT_APPLICABLE
	//
	// x-displayName: STATE_NOT_APPLICABLE
	// STATE_NOT_APPLICABLE should be used when the cloud provider doesn't supports this
	STATE_NOT_APPLICABLE RouteStateTypeEnum = 2
	// STATE_BLACKHOLE
	//
	// x-displayName: STATE_BLACKHOLE
	// STATE_BLACKHOLE
	STATE_BLACKHOLE RouteStateTypeEnum = 3
	// STATE_UNAVAILABLE
	//
	// x-displayName: STATE_UNAVAILABLE
	// STATE_UNAVAILABLE
	STATE_UNAVAILABLE RouteStateTypeEnum = 4
	// STATE_PENDING
	//
	// x-displayName: STATE_PENDING
	// STATE_PENDING
	STATE_PENDING RouteStateTypeEnum = 5
	// STATE_DELETING
	//
	// x-displayName: STATE_DELETING
	// STATE_DELETING
	STATE_DELETING RouteStateTypeEnum = 6
	// STATE_DELETING
	//
	// x-displayName: STATE_DELETED
	// STATE_DELETED
	STATE_DELETED RouteStateTypeEnum = 7
)

var RouteStateTypeEnum_name = map[int32]string{
	0: "ACTIVE_STATE",
	1: "INVALID_STATE",
	2: "STATE_NOT_APPLICABLE",
	3: "STATE_BLACKHOLE",
	4: "STATE_UNAVAILABLE",
	5: "STATE_PENDING",
	6: "STATE_DELETING",
	7: "STATE_DELETED",
}

var RouteStateTypeEnum_value = map[string]int32{
	"ACTIVE_STATE":         0,
	"INVALID_STATE":        1,
	"STATE_NOT_APPLICABLE": 2,
	"STATE_BLACKHOLE":      3,
	"STATE_UNAVAILABLE":    4,
	"STATE_PENDING":        5,
	"STATE_DELETING":       6,
	"STATE_DELETED":        7,
}

func (RouteStateTypeEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{7}
}

// RouteNextHopTypeEnum
//
// x-displayName: RouteNextHopTypeEnum
// RouteNextHopTypeEnum
type RouteNextHopTypeEnum int32

const (
	// VIRTUAL NETWORK GATEWAY
	//
	// x-displayName: VIRTUAL NETWORK GATEWAY
	// VIRTUAL NETWORK GATEWAY
	VIRTUAL_NETWORK_GATEWAY RouteNextHopTypeEnum = 0
	// VNET LOCAL
	//
	// x-displayName: VNET LOCAL
	// VNET LOCAL
	VNET_LOCAL RouteNextHopTypeEnum = 1
	// INTERNET
	//
	// x-displayName: INTERNET
	// INTERNET
	INTERNET RouteNextHopTypeEnum = 2
	// VIRTUAL APPLIANCE
	//
	// x-displayName: VIRTUAL APPLIANCE
	// VIRTUAL APPLIANCE
	VIRTUAL_APPLIANCE RouteNextHopTypeEnum = 3
	// NONE
	//
	// x-displayName: NONE
	// NONE
	NONE RouteNextHopTypeEnum = 4
	// VNET PEERING
	//
	// x-displayName: VNET PEERING
	// VNET PEERING
	VNET_PEERING RouteNextHopTypeEnum = 5
	// VIRTUAL NETWORK SERVICE ENDPOINT
	//
	// x-displayName: VIRTUAL NETWORK SERVICE ENDPOINT
	// VIRTUAL NETWORK SERVICE ENDPOINT
	VIRTUAL_NETWORK_SERVICE_ENDPOINT RouteNextHopTypeEnum = 6
	// NEXT_HOP_TYPE_NOT_APPLICABLE
	//
	// x-displayName: NEXT_HOP_TYPE_NOT_APPLICABLE
	// NEXT_HOP_TYPE_NOT_APPLICABLE should be used when the cloud provider doesn't support this.
	NEXT_HOP_TYPE_NOT_APPLICABLE RouteNextHopTypeEnum = 7
	// LOAD BALANCER
	//
	// x-displayName: LOAD BALANCER
	// LOAD BALANCER
	LOADBALANCER RouteNextHopTypeEnum = 8
	// VPC NETWORK
	//
	// x-displayName: VPC NETWORK
	// VPC NETWORK
	VPC_NETWORK RouteNextHopTypeEnum = 9
	// VPC PEERING
	//
	// x-displayName: VPC PEERING
	// VPC PEERING
	VPC_PEERING RouteNextHopTypeEnum = 10
	// INTERNAL LOAD BALANCER
	//
	// x-displayName: INTERNAL LOAD BALANCER
	// INTERNAL LOAD BALANCER
	INTERNAL_LOAD_BALANCER RouteNextHopTypeEnum = 11
	// INSTANCE
	//
	// x-displayName: INSTANCE
	// INSTANCE
	INSTANCE RouteNextHopTypeEnum = 12
	// INTERCONNECT
	//
	// x-displayName: INTERCONNECT
	// INTERCONNECT
	INTERCONNECT RouteNextHopTypeEnum = 13
	// INTERNET GATEWAY
	//
	// x-displayName: INTERNET GATEWAY
	// INTERNET GATEWAY
	INTERNET_GATEWAY RouteNextHopTypeEnum = 14
	// IP
	//
	// x-displayName: IP
	// IP
	IP RouteNextHopTypeEnum = 15
	// VPN TUNNEL
	//
	// x-displayName: VPN TUNNEL
	// VPN TUNNEL
	VPN_TUNNEL RouteNextHopTypeEnum = 16
	// TGW ATTACHMENT
	//
	// x-displayName: TGW ATTACHMENT
	// TGW ATTACHMENT
	TGW_ATTACHMENT RouteNextHopTypeEnum = 17
)

var RouteNextHopTypeEnum_name = map[int32]string{
	0:  "VIRTUAL_NETWORK_GATEWAY",
	1:  "VNET_LOCAL",
	2:  "INTERNET",
	3:  "VIRTUAL_APPLIANCE",
	4:  "NONE",
	5:  "VNET_PEERING",
	6:  "VIRTUAL_NETWORK_SERVICE_ENDPOINT",
	7:  "NEXT_HOP_TYPE_NOT_APPLICABLE",
	8:  "LOADBALANCER",
	9:  "VPC_NETWORK",
	10: "VPC_PEERING",
	11: "INTERNAL_LOAD_BALANCER",
	12: "INSTANCE",
	13: "INTERCONNECT",
	14: "INTERNET_GATEWAY",
	15: "IP",
	16: "VPN_TUNNEL",
	17: "TGW_ATTACHMENT",
}

var RouteNextHopTypeEnum_value = map[string]int32{
	"VIRTUAL_NETWORK_GATEWAY":          0,
	"VNET_LOCAL":                       1,
	"INTERNET":                         2,
	"VIRTUAL_APPLIANCE":                3,
	"NONE":                             4,
	"VNET_PEERING":                     5,
	"VIRTUAL_NETWORK_SERVICE_ENDPOINT": 6,
	"NEXT_HOP_TYPE_NOT_APPLICABLE":     7,
	"LOADBALANCER":                     8,
	"VPC_NETWORK":                      9,
	"VPC_PEERING":                      10,
	"INTERNAL_LOAD_BALANCER":           11,
	"INSTANCE":                         12,
	"INTERCONNECT":                     13,
	"INTERNET_GATEWAY":                 14,
	"IP":                               15,
	"VPN_TUNNEL":                       16,
	"TGW_ATTACHMENT":                   17,
}

func (RouteNextHopTypeEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{8}
}

// GatewayType
//
// x-displayName: Gateway type
// Gateway Type
type GatewayTypeEnum int32

const (
	// Ingress gateway
	//
	// x-displayName: Ingress gateway
	// Ingress gateway (single nic)
	INGRESS_GATEWAY GatewayTypeEnum = 0
	// Ingress and Egress gateway
	//
	// x-displayName: Ingress and Egress gateway
	// Ingress and Egress gateway (dual nic)
	INGRESS_EGRESS_GATEWAY GatewayTypeEnum = 1
)

var GatewayTypeEnum_name = map[int32]string{
	0: "INGRESS_GATEWAY",
	1: "INGRESS_EGRESS_GATEWAY",
}

var GatewayTypeEnum_value = map[string]int32{
	"INGRESS_GATEWAY":        0,
	"INGRESS_EGRESS_GATEWAY": 1,
}

func (GatewayTypeEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{9}
}

// GCPRouteType
//
// x-displayName: GCP Route type
// GCP Route Type
type GCPRouteType int32

const (
	// GCP Route Type None
	//
	// x-displayName: GCP Route Type None
	// GCP Route Type None
	GCP_ROUTE_TYPE_NONE GCPRouteType = 0
	// GCP Route Type Transit
	//
	// x-displayName: GCP Route Type Transit
	// GCP Route Type Transit
	GCP_ROUTE_TYPE_TRANSIT GCPRouteType = 1
	// GCP Route Type Subnet
	//
	// x-displayName: GCP Route Type Subnet
	// GCP Route Type Subnet
	GCP_ROUTE_TYPE_SUBNET GCPRouteType = 2
	// GCP Route Type Static
	//
	// x-displayName: GCP Route Type Static
	// GCP Route Type Static
	GCP_ROUTE_TYPE_STATIC GCPRouteType = 3
	// GCP Route Type BGP
	//
	// x-displayName: GCP Route Type BGP
	// GCP Route Type BGP
	GCP_ROUTE_TYPE_BGP GCPRouteType = 4
)

var GCPRouteType_name = map[int32]string{
	0: "GCP_ROUTE_TYPE_NONE",
	1: "GCP_ROUTE_TYPE_TRANSIT",
	2: "GCP_ROUTE_TYPE_SUBNET",
	3: "GCP_ROUTE_TYPE_STATIC",
	4: "GCP_ROUTE_TYPE_BGP",
}

var GCPRouteType_value = map[string]int32{
	"GCP_ROUTE_TYPE_NONE":    0,
	"GCP_ROUTE_TYPE_TRANSIT": 1,
	"GCP_ROUTE_TYPE_SUBNET":  2,
	"GCP_ROUTE_TYPE_STATIC":  3,
	"GCP_ROUTE_TYPE_BGP":     4,
}

func (GCPRouteType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{10}
}

// Site App Type
//
// x-displayName: Site App type
// Site App Type
type SiteAppTypeEnum int32

const (
	// Not applicable
	//
	// x-displayName: Not applicable
	// Not applicable
	SITE_APPTYPE_NONE SiteAppTypeEnum = 0
	// AppStack Site
	//
	// x-displayName: AppStack Site
	// AppStack Site
	SITE_APPTYPE_APPSTACK SiteAppTypeEnum = 1
	// Mesh site
	//
	// x-displayName: Mesh site
	// Mesh site
	SITE_APPTYPE_MESH SiteAppTypeEnum = 2
)

var SiteAppTypeEnum_name = map[int32]string{
	0: "SITE_APPTYPE_NONE",
	1: "SITE_APPTYPE_APPSTACK",
	2: "SITE_APPTYPE_MESH",
}

var SiteAppTypeEnum_value = map[string]int32{
	"SITE_APPTYPE_NONE":     0,
	"SITE_APPTYPE_APPSTACK": 1,
	"SITE_APPTYPE_MESH":     2,
}

func (SiteAppTypeEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{11}
}

// PeeringState
//
// x-displayName: PeeringState
// Network Peering Status
type PeeringStateEnum int32

const (
	// Connected
	//
	// x-displayName: CONNECTED
	// CONNECTED Peering Status
	CONNECTED PeeringStateEnum = 0
	// DISCONNECTED
	//
	// x-displayName: DISCONNECTED
	// DISCONNECTED Peering Status
	DISCONNECTED PeeringStateEnum = 1
	// PEERING_INITIATED
	//
	// x-displayName: PEERING_INITIATED
	// PEERING_INITIATED
	PEERING_INITIATED PeeringStateEnum = 3
	// PEERING_STATE_NOT_APPLICABLE
	//
	// x-displayName: PEERING_STATE_NOT_APPLICABLE
	// PEERING_STATE_NOT_APPLICABLE should be used when a cloud provider does not supports it.
	PEERING_STATE_NOT_APPLICABLE PeeringStateEnum = 4
)

var PeeringStateEnum_name = map[int32]string{
	0: "CONNECTED",
	1: "DISCONNECTED",
	3: "PEERING_INITIATED",
	4: "PEERING_STATE_NOT_APPLICABLE",
}

var PeeringStateEnum_value = map[string]int32{
	"CONNECTED":                    0,
	"DISCONNECTED":                 1,
	"PEERING_INITIATED":            3,
	"PEERING_STATE_NOT_APPLICABLE": 4,
}

func (PeeringStateEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{12}
}

// Metadata
//
// x-displayName: "MetaType"
// A metadata for topology objects.
type MetaType struct {
	// ID
	//
	// x-displayName: "ID"
	// ID in the external system (such as cloud specific ID).
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	// Name in the external system.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Cloud Credentials
	//
	// x-displayName: "Cloud Credentials"
	// Reference to cloud credentials to fetch cloud resources.
	Creds []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=creds,proto3" json:"creds,omitempty"`
	// Raw JSON
	//
	// x-displayName: "Raw JSON"
	// raw json string
	RawJson string `protobuf:"bytes,5,opt,name=raw_json,json=rawJson,proto3" json:"raw_json,omitempty"`
	// Status
	//
	// x-displayName: "Status"
	// status of topology node
	Status string `protobuf:"bytes,6,opt,name=status,proto3" json:"status,omitempty"`
	// tags
	//
	// x-displayName: "Tags"
	// x-example: "value"
	// Map of string keys and values that annotated in the topology node.
	Tags map[string]string `protobuf:"bytes,7,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// OwnerID
	//
	// x-displayName: "Owner ID"
	// owner id in the cloud side.
	OwnerId string `protobuf:"bytes,8,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	// Provider Type
	//
	// x-displayName: "Provider Type"
	// provider type
	ProviderType ProviderType `protobuf:"varint,9,opt,name=provider_type,json=providerType,proto3,enum=ves.io.schema.topology.ProviderType" json:"provider_type,omitempty"`
}

func (m *MetaType) Reset()      { *m = MetaType{} }
func (*MetaType) ProtoMessage() {}
func (*MetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{0}
}
func (m *MetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaType.Merge(m, src)
}
func (m *MetaType) XXX_Size() int {
	return m.Size()
}
func (m *MetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaType.DiscardUnknown(m)
}

var xxx_messageInfo_MetaType proto.InternalMessageInfo

func (m *MetaType) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MetaType) GetCreds() []*schema.ObjectRefType {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *MetaType) GetRawJson() string {
	if m != nil {
		return m.RawJson
	}
	return ""
}

func (m *MetaType) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *MetaType) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *MetaType) GetOwnerId() string {
	if m != nil {
		return m.OwnerId
	}
	return ""
}

func (m *MetaType) GetProviderType() ProviderType {
	if m != nil {
		return m.ProviderType
	}
	return PROVIDER_TYPE_UNSPECIFIED
}

// Network
//
// x-displayName: "network"
// A canonical form of the network.
type NetworkType struct {
	// Region
	//
	// x-displayName: "Region"
	// Reference to the regions
	Region []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=region,proto3" json:"region,omitempty"`
	// IPv4 Cidr
	//
	// x-displayName: "IPv4 Cidr"
	// IPv4 Cidr
	CidrV4 []string `protobuf:"bytes,2,rep,name=cidr_v4,json=cidrV4,proto3" json:"cidr_v4,omitempty"`
	// IPv6 Cidr
	//
	// x-displayName: "IPv6 Cidr"
	// IPv6 Cidr
	CidrV6 []string `protobuf:"bytes,3,rep,name=cidr_v6,json=cidrV6,proto3" json:"cidr_v6,omitempty"`
	// Network peers
	//
	// x-displayName: "Network Peers"
	// Reference to the network peers
	NetworkPeers []*schema.ObjectRefType `protobuf:"bytes,4,rep,name=network_peers,json=networkPeers,proto3" json:"network_peers,omitempty"`
	// Load Balancer
	//
	// x-displayName: "Load Balancer"
	// Load Balancer Present in this Network
	LoadBalancer []*LoadBalancer `protobuf:"bytes,5,rep,name=load_balancer,json=loadBalancer,proto3" json:"load_balancer,omitempty"`
}

func (m *NetworkType) Reset()      { *m = NetworkType{} }
func (*NetworkType) ProtoMessage() {}
func (*NetworkType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{1}
}
func (m *NetworkType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkType.Merge(m, src)
}
func (m *NetworkType) XXX_Size() int {
	return m.Size()
}
func (m *NetworkType) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkType.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkType proto.InternalMessageInfo

func (m *NetworkType) GetRegion() []*schema.ObjectRefType {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *NetworkType) GetCidrV4() []string {
	if m != nil {
		return m.CidrV4
	}
	return nil
}

func (m *NetworkType) GetCidrV6() []string {
	if m != nil {
		return m.CidrV6
	}
	return nil
}

func (m *NetworkType) GetNetworkPeers() []*schema.ObjectRefType {
	if m != nil {
		return m.NetworkPeers
	}
	return nil
}

func (m *NetworkType) GetLoadBalancer() []*LoadBalancer {
	if m != nil {
		return m.LoadBalancer
	}
	return nil
}

// LB
//
// x-displayName: "Load Balancer"
// Load Balancer
type LoadBalancer struct {
	// Name
	//
	// x-displayName: "Name"
	// Name of the LB
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Id
	//
	// x-displayName: "Id"
	// Id of the LB
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *LoadBalancer) Reset()      { *m = LoadBalancer{} }
func (*LoadBalancer) ProtoMessage() {}
func (*LoadBalancer) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{2}
}
func (m *LoadBalancer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadBalancer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LoadBalancer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadBalancer.Merge(m, src)
}
func (m *LoadBalancer) XXX_Size() int {
	return m.Size()
}
func (m *LoadBalancer) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadBalancer.DiscardUnknown(m)
}

var xxx_messageInfo_LoadBalancer proto.InternalMessageInfo

func (m *LoadBalancer) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LoadBalancer) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Subnet
//
// x-displayName: "subnet"
// A canonical form of the subnet.
type SubnetType struct {
	// Network
	//
	// x-displayName: "Network"
	// Reference to the network
	Network []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=network,proto3" json:"network,omitempty"`
	// Region
	//
	// x-displayName: "Region"
	// Reference to the regions. (Used for GCP)
	Region []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=region,proto3" json:"region,omitempty"`
	// Availability Zone
	//
	// x-displayName: "Availability Zone"
	// Availability zone
	AvailabilityZone string `protobuf:"bytes,4,opt,name=availability_zone,json=availabilityZone,proto3" json:"availability_zone,omitempty"`
	// IPv4 Cidr
	//
	// x-displayName: "IPv4 Cidr"
	// IPv4 Cidr
	CidrV4 []string `protobuf:"bytes,5,rep,name=cidr_v4,json=cidrV4,proto3" json:"cidr_v4,omitempty"`
	// IPv6 Cidr
	//
	// x-displayName: "IPv6 Cidr"
	// IPv6 Cidr
	CidrV6 []string `protobuf:"bytes,6,rep,name=cidr_v6,json=cidrV6,proto3" json:"cidr_v6,omitempty"`
	// Subnet Type
	//
	// x-displayName: "Subnet Type"
	// Subnet Type
	InterfaceType InterfaceTypeEnum `protobuf:"varint,7,opt,name=interface_type,json=interfaceType,proto3,enum=ves.io.schema.topology.InterfaceTypeEnum" json:"interface_type,omitempty"`
}

func (m *SubnetType) Reset()      { *m = SubnetType{} }
func (*SubnetType) ProtoMessage() {}
func (*SubnetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{3}
}
func (m *SubnetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SubnetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetType.Merge(m, src)
}
func (m *SubnetType) XXX_Size() int {
	return m.Size()
}
func (m *SubnetType) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetType.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetType proto.InternalMessageInfo

func (m *SubnetType) GetNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *SubnetType) GetRegion() []*schema.ObjectRefType {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *SubnetType) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *SubnetType) GetCidrV4() []string {
	if m != nil {
		return m.CidrV4
	}
	return nil
}

func (m *SubnetType) GetCidrV6() []string {
	if m != nil {
		return m.CidrV6
	}
	return nil
}

func (m *SubnetType) GetInterfaceType() InterfaceTypeEnum {
	if m != nil {
		return m.InterfaceType
	}
	return OUTSIDE
}

// Instance
//
// x-displayName: "instance"
// A canonical form of the instance.
type InstanceType struct {
	// Interfaces
	//
	// x-displayName: "Network Interfaces"
	// A list of network interfaces
	Interfaces []*NetworkInterfaceType `protobuf:"bytes,1,rep,name=interfaces,proto3" json:"interfaces,omitempty"`
	// Architecture
	//
	// x-displayName: "Architecture"
	// Architecture
	Architecture string `protobuf:"bytes,2,opt,name=architecture,proto3" json:"architecture,omitempty"`
	// CPU
	//
	// x-displayName: "CPU Count"
	// CPU Count
	Cpu uint32 `protobuf:"varint,3,opt,name=cpu,proto3" json:"cpu,omitempty"`
	// Instance type
	//
	// x-displayName: "Instance type"
	// Instance type
	InstanceType string `protobuf:"bytes,4,opt,name=instance_type,json=instanceType,proto3" json:"instance_type,omitempty"`
	// Platform
	//
	// x-displayName: "Platform"
	// Platform
	Platform string `protobuf:"bytes,5,opt,name=platform,proto3" json:"platform,omitempty"`
	// Private addresse
	//
	// x-displayName: "Private Address"
	// Private Address
	PrivateAddress string `protobuf:"bytes,6,opt,name=private_address,json=privateAddress,proto3" json:"private_address,omitempty"`
	// Public address
	//
	// x-displayName: "Public Address"
	// Public address
	PublicAddress string `protobuf:"bytes,7,opt,name=public_address,json=publicAddress,proto3" json:"public_address,omitempty"`
	// Private DNS Name
	//
	// x-displayName: "Private DNS Name"
	// Private DNS Name
	PrivateDnsName string `protobuf:"bytes,8,opt,name=private_dns_name,json=privateDnsName,proto3" json:"private_dns_name,omitempty"`
	// Public DNS Name
	//
	// x-displayName: "Public DNS Name"
	// Public DNS Name
	PublicDnsName string `protobuf:"bytes,9,opt,name=public_dns_name,json=publicDnsName,proto3" json:"public_dns_name,omitempty"`
	// Security Groups
	//
	// x-displayName: "Security Groups"
	// Security groups
	SecurityGroup []string `protobuf:"bytes,10,rep,name=security_group,json=securityGroup,proto3" json:"security_group,omitempty"`
	// Availability Zone
	//
	// x-displayName: "Availability Zone"
	// Availability Zone
	AvailabilityZone string `protobuf:"bytes,11,opt,name=availability_zone,json=availabilityZone,proto3" json:"availability_zone,omitempty"`
	// F5XC Node name
	//
	// x-displayName: "F5XC Node Name"
	// F5XC node name
	F5XcNodeName string `protobuf:"bytes,12,opt,name=f5xc_node_name,json=f5xcNodeName,proto3" json:"f5xc_node_name,omitempty"`
}

func (m *InstanceType) Reset()      { *m = InstanceType{} }
func (*InstanceType) ProtoMessage() {}
func (*InstanceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{4}
}
func (m *InstanceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InstanceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceType.Merge(m, src)
}
func (m *InstanceType) XXX_Size() int {
	return m.Size()
}
func (m *InstanceType) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceType.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceType proto.InternalMessageInfo

func (m *InstanceType) GetInterfaces() []*NetworkInterfaceType {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

func (m *InstanceType) GetArchitecture() string {
	if m != nil {
		return m.Architecture
	}
	return ""
}

func (m *InstanceType) GetCpu() uint32 {
	if m != nil {
		return m.Cpu
	}
	return 0
}

func (m *InstanceType) GetInstanceType() string {
	if m != nil {
		return m.InstanceType
	}
	return ""
}

func (m *InstanceType) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *InstanceType) GetPrivateAddress() string {
	if m != nil {
		return m.PrivateAddress
	}
	return ""
}

func (m *InstanceType) GetPublicAddress() string {
	if m != nil {
		return m.PublicAddress
	}
	return ""
}

func (m *InstanceType) GetPrivateDnsName() string {
	if m != nil {
		return m.PrivateDnsName
	}
	return ""
}

func (m *InstanceType) GetPublicDnsName() string {
	if m != nil {
		return m.PublicDnsName
	}
	return ""
}

func (m *InstanceType) GetSecurityGroup() []string {
	if m != nil {
		return m.SecurityGroup
	}
	return nil
}

func (m *InstanceType) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *InstanceType) GetF5XcNodeName() string {
	if m != nil {
		return m.F5XcNodeName
	}
	return ""
}

// AWSTGWAttachment
//
// x-displayName: "AWS TGW Attachement"
// AWS TGW Attachment
type AWSTGWAttachment struct {
	// ID
	//
	// x-displayName: "ID"
	//TGW Attachment ID
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	//TGW Attachment Name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	//Resource Type
	//
	// x-displayName: "Resource Type"
	//Resource Type
	ResourceType string `protobuf:"bytes,3,opt,name=resource_type,json=resourceType,proto3" json:"resource_type,omitempty"`
	//Resource ID
	//
	// x-displayName: "Resource ID"
	//Resource ID
	ResourceId string `protobuf:"bytes,4,opt,name=resource_id,json=resourceId,proto3" json:"resource_id,omitempty"`
	// Resource Name
	//
	// x-displayName: "Resource Name"
	//Resource Name
	ResourceName string `protobuf:"bytes,5,opt,name=resource_name,json=resourceName,proto3" json:"resource_name,omitempty"`
	// CIDR
	//
	// x-displayName: "CIDR"
	//CIDR
	Cidr string `protobuf:"bytes,6,opt,name=cidr,proto3" json:"cidr,omitempty"`
	// Associated Route Table ID
	//
	// x-displayName: "Associated Route Table ID"
	//Associated Route Table ID
	AssociatedRouteTableId string `protobuf:"bytes,7,opt,name=associated_route_table_id,json=associatedRouteTableId,proto3" json:"associated_route_table_id,omitempty"`
	// Association State
	//
	// x-displayName: "Association State"
	//Association State
	AssociationState string `protobuf:"bytes,8,opt,name=association_state,json=associationState,proto3" json:"association_state,omitempty"`
	// Cloud Connect
	//
	// x-displayName: "Cloud Connect"
	// Reference to the Cloud Connect
	CloudConnect []*schema.ObjectRefType `protobuf:"bytes,9,rep,name=cloud_connect,json=cloudConnect,proto3" json:"cloud_connect,omitempty"`
	// Segment
	//
	// x-displayName: "Segment"
	// Reference to the Segment
	Segment []*schema.ObjectRefType `protobuf:"bytes,10,rep,name=segment,proto3" json:"segment,omitempty"`
}

func (m *AWSTGWAttachment) Reset()      { *m = AWSTGWAttachment{} }
func (*AWSTGWAttachment) ProtoMessage() {}
func (*AWSTGWAttachment) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{5}
}
func (m *AWSTGWAttachment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSTGWAttachment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSTGWAttachment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSTGWAttachment.Merge(m, src)
}
func (m *AWSTGWAttachment) XXX_Size() int {
	return m.Size()
}
func (m *AWSTGWAttachment) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSTGWAttachment.DiscardUnknown(m)
}

var xxx_messageInfo_AWSTGWAttachment proto.InternalMessageInfo

func (m *AWSTGWAttachment) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AWSTGWAttachment) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AWSTGWAttachment) GetResourceType() string {
	if m != nil {
		return m.ResourceType
	}
	return ""
}

func (m *AWSTGWAttachment) GetResourceId() string {
	if m != nil {
		return m.ResourceId
	}
	return ""
}

func (m *AWSTGWAttachment) GetResourceName() string {
	if m != nil {
		return m.ResourceName
	}
	return ""
}

func (m *AWSTGWAttachment) GetCidr() string {
	if m != nil {
		return m.Cidr
	}
	return ""
}

func (m *AWSTGWAttachment) GetAssociatedRouteTableId() string {
	if m != nil {
		return m.AssociatedRouteTableId
	}
	return ""
}

func (m *AWSTGWAttachment) GetAssociationState() string {
	if m != nil {
		return m.AssociationState
	}
	return ""
}

func (m *AWSTGWAttachment) GetCloudConnect() []*schema.ObjectRefType {
	if m != nil {
		return m.CloudConnect
	}
	return nil
}

func (m *AWSTGWAttachment) GetSegment() []*schema.ObjectRefType {
	if m != nil {
		return m.Segment
	}
	return nil
}

// TransitGateway
//
// x-displayName: "transit gateway"
// A canonical form of the transit gateway.
type TransitGatewayType struct {
	// Network
	//
	// x-displayName: "Network"
	// Reference to the network
	Network []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=network,proto3" json:"network,omitempty"`
	// Auto accept shared attachment
	//
	// x-displayName: "Auto accept shared attachment"
	// Auto accept shared attachment
	AutoAcceptSharedAttachments bool `protobuf:"varint,2,opt,name=auto_accept_shared_attachments,json=autoAcceptSharedAttachments,proto3" json:"auto_accept_shared_attachments,omitempty"`
	// DNS support
	//
	// x-displayName: "DNS Support"
	// DNS support
	DnsSupport bool `protobuf:"varint,3,opt,name=dns_support,json=dnsSupport,proto3" json:"dns_support,omitempty"`
	// vpn ecmp support
	//
	// x-displayName: "VpnEcmpSupport Support"
	// vpn ecmp support
	VpnEcmpSupport bool `protobuf:"varint,4,opt,name=vpn_ecmp_support,json=vpnEcmpSupport,proto3" json:"vpn_ecmp_support,omitempty"`
	// Attachments
	//
	// x-displayName: "Attachments"
	//TGW Attachements
	Attachments []*AWSTGWAttachment `protobuf:"bytes,5,rep,name=attachments,proto3" json:"attachments,omitempty"`
}

func (m *TransitGatewayType) Reset()      { *m = TransitGatewayType{} }
func (*TransitGatewayType) ProtoMessage() {}
func (*TransitGatewayType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{6}
}
func (m *TransitGatewayType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransitGatewayType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TransitGatewayType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransitGatewayType.Merge(m, src)
}
func (m *TransitGatewayType) XXX_Size() int {
	return m.Size()
}
func (m *TransitGatewayType) XXX_DiscardUnknown() {
	xxx_messageInfo_TransitGatewayType.DiscardUnknown(m)
}

var xxx_messageInfo_TransitGatewayType proto.InternalMessageInfo

func (m *TransitGatewayType) GetNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *TransitGatewayType) GetAutoAcceptSharedAttachments() bool {
	if m != nil {
		return m.AutoAcceptSharedAttachments
	}
	return false
}

func (m *TransitGatewayType) GetDnsSupport() bool {
	if m != nil {
		return m.DnsSupport
	}
	return false
}

func (m *TransitGatewayType) GetVpnEcmpSupport() bool {
	if m != nil {
		return m.VpnEcmpSupport
	}
	return false
}

func (m *TransitGatewayType) GetAttachments() []*AWSTGWAttachment {
	if m != nil {
		return m.Attachments
	}
	return nil
}

// RouteTableType
//
// x-displayName: "Route Table"
// A canonical form of the route table.
type RouteTableType struct {
	// Subnet
	//
	// x-displayName: "Subnet"
	// Reference to the subnet.
	Subnet []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=subnet,proto3" json:"subnet,omitempty"`
	// Network
	//
	// x-displayName: "Network"
	// Reference to the network.
	Network []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=network,proto3" json:"network,omitempty"`
	// Transit Gateway
	//
	// x-displayName: "Transit Gateway"
	// Reference to the transit gateway if a transit gateway owns this resource.
	TransitGateway []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=transit_gateway,json=transitGateway,proto3" json:"transit_gateway,omitempty"`
	// Routes
	//
	// x-displayName: "Routes"
	// list of routes
	Routes []*RouteType `protobuf:"bytes,4,rep,name=routes,proto3" json:"routes,omitempty"`
	// Rotue Table type
	//
	// x-displayName: "Route table type"
	// type of this route table.
	RouteTableType RouteTableTypeEnum `protobuf:"varint,5,opt,name=route_table_type,json=routeTableType,proto3,enum=ves.io.schema.topology.RouteTableTypeEnum" json:"route_table_type,omitempty"`
	// Implicit Subnet Association
	//
	// x-displayName: "Implicit Subnet Association"
	// Reference to the subnet implicitly accociated.
	ImplicitSubnet []*schema.ObjectRefType `protobuf:"bytes,7,rep,name=implicit_subnet,json=implicitSubnet,proto3" json:"implicit_subnet,omitempty"`
	// Explicit Subnet Association
	//
	// x-displayName: "Explicit Subnet Association"
	// Reference to the subnet explicitly accociated.
	ExplicitSubnet []*schema.ObjectRefType `protobuf:"bytes,8,rep,name=explicit_subnet,json=explicitSubnet,proto3" json:"explicit_subnet,omitempty"`
	// Route Table State
	//
	// x-displayName: "Route Table State"
	// state of the route table.
	RouteTableState RouteTableStateEnum `protobuf:"varint,10,opt,name=route_table_state,json=routeTableState,proto3,enum=ves.io.schema.topology.RouteTableStateEnum" json:"route_table_state,omitempty"`
	// Associations
	//
	// x-displayName: "Associations"
	// list of associations
	Associations []*AWSTGWAttachmentMetaData `protobuf:"bytes,11,rep,name=associations,proto3" json:"associations,omitempty"`
	// Propagations
	//
	// x-displayName: "Propagations"
	// list of propagations
	Propagations []*AWSTGWAttachmentMetaData `protobuf:"bytes,12,rep,name=propagations,proto3" json:"propagations,omitempty"`
}

func (m *RouteTableType) Reset()      { *m = RouteTableType{} }
func (*RouteTableType) ProtoMessage() {}
func (*RouteTableType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{7}
}
func (m *RouteTableType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTableType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteTableType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTableType.Merge(m, src)
}
func (m *RouteTableType) XXX_Size() int {
	return m.Size()
}
func (m *RouteTableType) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTableType.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTableType proto.InternalMessageInfo

func (m *RouteTableType) GetSubnet() []*schema.ObjectRefType {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *RouteTableType) GetNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *RouteTableType) GetTransitGateway() []*schema.ObjectRefType {
	if m != nil {
		return m.TransitGateway
	}
	return nil
}

func (m *RouteTableType) GetRoutes() []*RouteType {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *RouteTableType) GetRouteTableType() RouteTableTypeEnum {
	if m != nil {
		return m.RouteTableType
	}
	return ROUTE_TABLE_NETWORK
}

func (m *RouteTableType) GetImplicitSubnet() []*schema.ObjectRefType {
	if m != nil {
		return m.ImplicitSubnet
	}
	return nil
}

func (m *RouteTableType) GetExplicitSubnet() []*schema.ObjectRefType {
	if m != nil {
		return m.ExplicitSubnet
	}
	return nil
}

func (m *RouteTableType) GetRouteTableState() RouteTableStateEnum {
	if m != nil {
		return m.RouteTableState
	}
	return ROUTE_TABLE_STATE_NONE
}

func (m *RouteTableType) GetAssociations() []*AWSTGWAttachmentMetaData {
	if m != nil {
		return m.Associations
	}
	return nil
}

func (m *RouteTableType) GetPropagations() []*AWSTGWAttachmentMetaData {
	if m != nil {
		return m.Propagations
	}
	return nil
}

// AWSTGWAttachmentMetaData
//
// x-displayName: "AWS TGW AWSTGWAttachment MetaData"
// AWS TGW AWSTGWAttachment MetaData
type AWSTGWAttachmentMetaData struct {
	// Attachment ID
	//
	// x-displayName: "Attachment ID"
	//TGW Attachment ID
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Resource Type
	//
	// x-displayName: "Resource Type"
	//Resource Type
	ResourceType string `protobuf:"bytes,2,opt,name=resource_type,json=resourceType,proto3" json:"resource_type,omitempty"`
	// Resource ID
	//
	// x-displayName: "Resource ID"
	//Resource ID
	ResourceId string `protobuf:"bytes,3,opt,name=resource_id,json=resourceId,proto3" json:"resource_id,omitempty"`
	// Association/Propagation State
	//
	// x-displayName: "Association/Propagation State"
	//Association/Propagation State
	State string `protobuf:"bytes,4,opt,name=state,proto3" json:"state,omitempty"`
	// Resource Name
	//
	// x-displayName: "Resource Name"
	//Resource Name
	ResourceName string `protobuf:"bytes,5,opt,name=resource_name,json=resourceName,proto3" json:"resource_name,omitempty"`
}

func (m *AWSTGWAttachmentMetaData) Reset()      { *m = AWSTGWAttachmentMetaData{} }
func (*AWSTGWAttachmentMetaData) ProtoMessage() {}
func (*AWSTGWAttachmentMetaData) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{8}
}
func (m *AWSTGWAttachmentMetaData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSTGWAttachmentMetaData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSTGWAttachmentMetaData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSTGWAttachmentMetaData.Merge(m, src)
}
func (m *AWSTGWAttachmentMetaData) XXX_Size() int {
	return m.Size()
}
func (m *AWSTGWAttachmentMetaData) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSTGWAttachmentMetaData.DiscardUnknown(m)
}

var xxx_messageInfo_AWSTGWAttachmentMetaData proto.InternalMessageInfo

func (m *AWSTGWAttachmentMetaData) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AWSTGWAttachmentMetaData) GetResourceType() string {
	if m != nil {
		return m.ResourceType
	}
	return ""
}

func (m *AWSTGWAttachmentMetaData) GetResourceId() string {
	if m != nil {
		return m.ResourceId
	}
	return ""
}

func (m *AWSTGWAttachmentMetaData) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *AWSTGWAttachmentMetaData) GetResourceName() string {
	if m != nil {
		return m.ResourceName
	}
	return ""
}

// GCPRouteAttributes
//
// x-displayName: "GCP Route Attributes"
// Route attributes specific to GCP.
type GCPRouteAttributes struct {
	// Priority
	//
	// x-displayName: "Priority"
	// x-example: 1
	// Route Priority
	Priority uint32 `protobuf:"varint,1,opt,name=priority,proto3" json:"priority,omitempty"`
	// IP version
	//
	// x-displayName: "IP version"
	// x-example: "ipv4"
	// Version of IP protocol
	IpVersion string `protobuf:"bytes,2,opt,name=ip_version,json=ipVersion,proto3" json:"ip_version,omitempty"`
	// Scope Limits
	//
	// x-displayName: "Scope Limits"
	// x-example: "tag-1, tag-2"
	// Limits on the scope of route like network tag
	ScopeLimits []string `protobuf:"bytes,3,rep,name=scope_limits,json=scopeLimits,proto3" json:"scope_limits,omitempty"`
	// GCP Route Type
	//
	// x-displayName: "GCP Route Type"
	// x-example: GCP_ROUTE_TYPE_STATIC
	// GCP Route Type
	RouteType GCPRouteType `protobuf:"varint,4,opt,name=route_type,json=routeType,proto3,enum=ves.io.schema.topology.GCPRouteType" json:"route_type,omitempty"`
	// GCP Route Name
	//
	// x-displayName: "GCP Route Name"
	// x-example: "default-route"
	// GCP Route Name
	RouteName string `protobuf:"bytes,5,opt,name=route_name,json=routeName,proto3" json:"route_name,omitempty"`
}

func (m *GCPRouteAttributes) Reset()      { *m = GCPRouteAttributes{} }
func (*GCPRouteAttributes) ProtoMessage() {}
func (*GCPRouteAttributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{9}
}
func (m *GCPRouteAttributes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPRouteAttributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPRouteAttributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPRouteAttributes.Merge(m, src)
}
func (m *GCPRouteAttributes) XXX_Size() int {
	return m.Size()
}
func (m *GCPRouteAttributes) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPRouteAttributes.DiscardUnknown(m)
}

var xxx_messageInfo_GCPRouteAttributes proto.InternalMessageInfo

func (m *GCPRouteAttributes) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *GCPRouteAttributes) GetIpVersion() string {
	if m != nil {
		return m.IpVersion
	}
	return ""
}

func (m *GCPRouteAttributes) GetScopeLimits() []string {
	if m != nil {
		return m.ScopeLimits
	}
	return nil
}

func (m *GCPRouteAttributes) GetRouteType() GCPRouteType {
	if m != nil {
		return m.RouteType
	}
	return GCP_ROUTE_TYPE_NONE
}

func (m *GCPRouteAttributes) GetRouteName() string {
	if m != nil {
		return m.RouteName
	}
	return ""
}

// AWSTgwRouteAttributes
//
// x-displayName: "AWS TGW Route Attributes"
// Route attributes specific to AWS TGW.
type AWSTgwRouteAttributes struct {
	// Route Type
	//
	// x-displayName: "Route Type"
	// x-example: "propagated"
	// Route Type
	RouteType string `protobuf:"bytes,1,opt,name=route_type,json=routeType,proto3" json:"route_type,omitempty"`
	// Next Hop Attachment
	//
	// x-displayName: "Next Hop Attachment"
	// x-example: next_hop_attachment
	// Next Hop Attachment
	NextHopAttachment []*AWSTGWAttachmentMetaData `protobuf:"bytes,3,rep,name=next_hop_attachment,json=nextHopAttachment,proto3" json:"next_hop_attachment,omitempty"`
}

func (m *AWSTgwRouteAttributes) Reset()      { *m = AWSTgwRouteAttributes{} }
func (*AWSTgwRouteAttributes) ProtoMessage() {}
func (*AWSTgwRouteAttributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{10}
}
func (m *AWSTgwRouteAttributes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSTgwRouteAttributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSTgwRouteAttributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSTgwRouteAttributes.Merge(m, src)
}
func (m *AWSTgwRouteAttributes) XXX_Size() int {
	return m.Size()
}
func (m *AWSTgwRouteAttributes) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSTgwRouteAttributes.DiscardUnknown(m)
}

var xxx_messageInfo_AWSTgwRouteAttributes proto.InternalMessageInfo

func (m *AWSTgwRouteAttributes) GetRouteType() string {
	if m != nil {
		return m.RouteType
	}
	return ""
}

func (m *AWSTgwRouteAttributes) GetNextHopAttachment() []*AWSTGWAttachmentMetaData {
	if m != nil {
		return m.NextHopAttachment
	}
	return nil
}

// AWSRouteAttributes
//
// x-displayName: "AWS Route Attributes"
// Route attributes specific to AWS.
type AWSRouteAttributes struct {
	// Propagated
	//
	// x-displayName: "Propagated"
	// x-example: false
	//Is route propagated
	Propagated bool `protobuf:"varint,1,opt,name=propagated,proto3" json:"propagated,omitempty"`
	// TGW
	//
	// x-displayName: "TGW"
	// x-example: tgw
	//TGW Route Attribues
	Tgw *AWSTgwRouteAttributes `protobuf:"bytes,2,opt,name=tgw,proto3" json:"tgw,omitempty"`
}

func (m *AWSRouteAttributes) Reset()      { *m = AWSRouteAttributes{} }
func (*AWSRouteAttributes) ProtoMessage() {}
func (*AWSRouteAttributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{11}
}
func (m *AWSRouteAttributes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSRouteAttributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSRouteAttributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSRouteAttributes.Merge(m, src)
}
func (m *AWSRouteAttributes) XXX_Size() int {
	return m.Size()
}
func (m *AWSRouteAttributes) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSRouteAttributes.DiscardUnknown(m)
}

var xxx_messageInfo_AWSRouteAttributes proto.InternalMessageInfo

func (m *AWSRouteAttributes) GetPropagated() bool {
	if m != nil {
		return m.Propagated
	}
	return false
}

func (m *AWSRouteAttributes) GetTgw() *AWSTgwRouteAttributes {
	if m != nil {
		return m.Tgw
	}
	return nil
}

// RouteType
//
// x-displayName: "Route Type"
// A canonical form of the route.
type RouteType struct {
	// Destination
	//
	// x-displayName: "Destination"
	// Destination
	Destination string `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	// Nexthop
	//
	// x-displayName: "Nexthop"
	// Nexthop (IP subnet or gateway ID)
	Nexthop string `protobuf:"bytes,2,opt,name=nexthop,proto3" json:"nexthop,omitempty"`
	// Source
	//
	// x-displayName: "Source"
	// Source of route entry
	Source RouteSourceTypeEnum `protobuf:"varint,3,opt,name=source,proto3,enum=ves.io.schema.topology.RouteSourceTypeEnum" json:"source,omitempty"`
	// State
	//
	// x-displayName: "State"
	// State of the route entry
	State RouteStateTypeEnum `protobuf:"varint,4,opt,name=state,proto3,enum=ves.io.schema.topology.RouteStateTypeEnum" json:"state,omitempty"`
	// Next Hop Type
	//
	// x-displayName: "Next Hop Type"
	// Next Hop Type of the route
	NextHopType RouteNextHopTypeEnum `protobuf:"varint,5,opt,name=next_hop_type,json=nextHopType,proto3,enum=ves.io.schema.topology.RouteNextHopTypeEnum" json:"next_hop_type,omitempty"`
	// User Defined Route Name
	//
	// x-displayName: "User Defined Route Name"
	// User Defined Route Name
	UserDefinedRouteName string `protobuf:"bytes,6,opt,name=user_defined_route_name,json=userDefinedRouteName,proto3" json:"user_defined_route_name,omitempty"`
	//Cloud Route Attributes
	//
	// x-displayName: "Cloud Route Attributes"
	// Cloud Specific Route Attributes
	//
	// Types that are valid to be assigned to CloudRouteAttributes:
	//	*RouteType_Aws
	//	*RouteType_Gcp
	CloudRouteAttributes isRouteType_CloudRouteAttributes `protobuf_oneof:"cloud_route_attributes"`
}

func (m *RouteType) Reset()      { *m = RouteType{} }
func (*RouteType) ProtoMessage() {}
func (*RouteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{12}
}
func (m *RouteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteType.Merge(m, src)
}
func (m *RouteType) XXX_Size() int {
	return m.Size()
}
func (m *RouteType) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteType.DiscardUnknown(m)
}

var xxx_messageInfo_RouteType proto.InternalMessageInfo

type isRouteType_CloudRouteAttributes interface {
	isRouteType_CloudRouteAttributes()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteType_Aws struct {
	Aws *AWSRouteAttributes `protobuf:"bytes,8,opt,name=aws,proto3,oneof" json:"aws,omitempty"`
}
type RouteType_Gcp struct {
	Gcp *GCPRouteAttributes `protobuf:"bytes,9,opt,name=gcp,proto3,oneof" json:"gcp,omitempty"`
}

func (*RouteType_Aws) isRouteType_CloudRouteAttributes() {}
func (*RouteType_Gcp) isRouteType_CloudRouteAttributes() {}

func (m *RouteType) GetCloudRouteAttributes() isRouteType_CloudRouteAttributes {
	if m != nil {
		return m.CloudRouteAttributes
	}
	return nil
}

func (m *RouteType) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *RouteType) GetNexthop() string {
	if m != nil {
		return m.Nexthop
	}
	return ""
}

func (m *RouteType) GetSource() RouteSourceTypeEnum {
	if m != nil {
		return m.Source
	}
	return INVALID_SOURCE
}

func (m *RouteType) GetState() RouteStateTypeEnum {
	if m != nil {
		return m.State
	}
	return ACTIVE_STATE
}

func (m *RouteType) GetNextHopType() RouteNextHopTypeEnum {
	if m != nil {
		return m.NextHopType
	}
	return VIRTUAL_NETWORK_GATEWAY
}

func (m *RouteType) GetUserDefinedRouteName() string {
	if m != nil {
		return m.UserDefinedRouteName
	}
	return ""
}

func (m *RouteType) GetAws() *AWSRouteAttributes {
	if x, ok := m.GetCloudRouteAttributes().(*RouteType_Aws); ok {
		return x.Aws
	}
	return nil
}

func (m *RouteType) GetGcp() *GCPRouteAttributes {
	if x, ok := m.GetCloudRouteAttributes().(*RouteType_Gcp); ok {
		return x.Gcp
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RouteType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RouteType_Aws)(nil),
		(*RouteType_Gcp)(nil),
	}
}

// Site
//
// x-displayName: "site"
// A canonical form of the site.
type SiteType struct {
	// Network
	//
	// x-displayName: "Network"
	// Reference to the network.
	Network []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=network,proto3" json:"network,omitempty"`
	// TransitGateway
	//
	// x-displayName: "TransitGateway"
	// Reference to the transit gateway
	Tgw []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=tgw,proto3" json:"tgw,omitempty"`
	// DC Cluster Group
	//
	// x-displayName: "DC Cluster Group"
	// Reference to the DC Cluster group
	DcClusterGroup []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=dc_cluster_group,json=dcClusterGroup,proto3" json:"dc_cluster_group,omitempty"`
	// Site type
	//
	// x-displayName: "Site Type"
	// Site type indicates whether the site is CUSTOMER_EDGE or REGIONAL_EDGE
	SiteType site.SiteType `protobuf:"varint,4,opt,name=site_type,json=siteType,proto3,enum=ves.io.schema.site.SiteType" json:"site_type,omitempty"`
	// Provider Info
	//
	// x-displayName: "Provider Info"
	// Information related to the site provider
	ProviderInfo *ProviderInfo `protobuf:"bytes,5,opt,name=provider_info,json=providerInfo,proto3" json:"provider_info,omitempty"`
	// Provider Info
	//
	// x-displayName: "Provider Info"
	// Information related to the site provider
	GatewayType GatewayTypeEnum `protobuf:"varint,6,opt,name=gateway_type,json=gatewayType,proto3,enum=ves.io.schema.topology.GatewayTypeEnum" json:"gateway_type,omitempty"`
	// Site App type
	//
	// x-displayName: "Site App type"
	// Site App Type
	AppType SiteAppTypeEnum `protobuf:"varint,7,opt,name=app_type,json=appType,proto3,enum=ves.io.schema.topology.SiteAppTypeEnum" json:"app_type,omitempty"`
}

func (m *SiteType) Reset()      { *m = SiteType{} }
func (*SiteType) ProtoMessage() {}
func (*SiteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{13}
}
func (m *SiteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SiteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteType.Merge(m, src)
}
func (m *SiteType) XXX_Size() int {
	return m.Size()
}
func (m *SiteType) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteType.DiscardUnknown(m)
}

var xxx_messageInfo_SiteType proto.InternalMessageInfo

func (m *SiteType) GetNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *SiteType) GetTgw() []*schema.ObjectRefType {
	if m != nil {
		return m.Tgw
	}
	return nil
}

func (m *SiteType) GetDcClusterGroup() []*schema.ObjectRefType {
	if m != nil {
		return m.DcClusterGroup
	}
	return nil
}

func (m *SiteType) GetSiteType() site.SiteType {
	if m != nil {
		return m.SiteType
	}
	return site.INVALID
}

func (m *SiteType) GetProviderInfo() *ProviderInfo {
	if m != nil {
		return m.ProviderInfo
	}
	return nil
}

func (m *SiteType) GetGatewayType() GatewayTypeEnum {
	if m != nil {
		return m.GatewayType
	}
	return INGRESS_GATEWAY
}

func (m *SiteType) GetAppType() SiteAppTypeEnum {
	if m != nil {
		return m.AppType
	}
	return SITE_APPTYPE_NONE
}

// Site Mesh Group
//
// x-displayName: "site Mesh Group"
// A canonical form of the site mesh group.
type SiteMeshGroupType struct {
	// Type
	//
	// x-displayName: "Type"
	// Site Mesh Group Type
	Type site_mesh_group.SiteMeshGroupType `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.site_mesh_group.SiteMeshGroupType" json:"type,omitempty"`
	// site_type
	//
	// x-displayName: "Site Type"
	// Site type for sites in the virtual site
	SiteType site.SiteType `protobuf:"varint,4,opt,name=site_type,json=siteType,proto3,enum=ves.io.schema.site.SiteType" json:"site_type,omitempty"`
	// virtual_site
	//
	// x-displayName: "Virtual Site"
	// Virtual Site referenced in this site_mesh_group
	VirtualSite []*schema.ObjectRefType `protobuf:"bytes,9,rep,name=virtual_site,json=virtualSite,proto3" json:"virtual_site,omitempty"`
	// Hub
	//
	// x-displayName: "Hub (site mesh group)"
	// If 'Type' is Spoke, 'Hub' refers to a Site Mesh Group of 'type' Hub.
	// Spoke sites connect to all the member sites of Hub Site Mesh Group.
	// Hub will be empty when Site Mesh Group type is Hub or Full Mesh.
	Hub []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=hub,proto3" json:"hub,omitempty"`
	// Mesh Choice
	//
	// x-displayName: "Mesh Choice"
	// Type of Site to Site connectivity (Spoke, Hub or Full Mesh)
	//
	// Types that are valid to be assigned to MeshChoice:
	//	*SiteMeshGroupType_HubMesh
	//	*SiteMeshGroupType_SpokeMesh
	//	*SiteMeshGroupType_FullMesh
	MeshChoice isSiteMeshGroupType_MeshChoice `protobuf_oneof:"mesh_choice"`
	// Topology Site Reference
	//
	// x-displayName: "Topology Site"
	// Topology Sites referenced in this site_mesh_group
	TopologySite []*schema.ObjectRefType `protobuf:"bytes,10,rep,name=topology_site,json=topologySite,proto3" json:"topology_site,omitempty"`
}

func (m *SiteMeshGroupType) Reset()      { *m = SiteMeshGroupType{} }
func (*SiteMeshGroupType) ProtoMessage() {}
func (*SiteMeshGroupType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{14}
}
func (m *SiteMeshGroupType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteMeshGroupType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SiteMeshGroupType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteMeshGroupType.Merge(m, src)
}
func (m *SiteMeshGroupType) XXX_Size() int {
	return m.Size()
}
func (m *SiteMeshGroupType) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteMeshGroupType.DiscardUnknown(m)
}

var xxx_messageInfo_SiteMeshGroupType proto.InternalMessageInfo

type isSiteMeshGroupType_MeshChoice interface {
	isSiteMeshGroupType_MeshChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SiteMeshGroupType_HubMesh struct {
	HubMesh *site_mesh_group.HubFullMeshGroupType `protobuf:"bytes,6,opt,name=hub_mesh,json=hubMesh,proto3,oneof" json:"hub_mesh,omitempty"`
}
type SiteMeshGroupType_SpokeMesh struct {
	SpokeMesh *site_mesh_group.SpokeMeshGroupType `protobuf:"bytes,7,opt,name=spoke_mesh,json=spokeMesh,proto3,oneof" json:"spoke_mesh,omitempty"`
}
type SiteMeshGroupType_FullMesh struct {
	FullMesh *site_mesh_group.FullMeshGroupType `protobuf:"bytes,8,opt,name=full_mesh,json=fullMesh,proto3,oneof" json:"full_mesh,omitempty"`
}

func (*SiteMeshGroupType_HubMesh) isSiteMeshGroupType_MeshChoice()   {}
func (*SiteMeshGroupType_SpokeMesh) isSiteMeshGroupType_MeshChoice() {}
func (*SiteMeshGroupType_FullMesh) isSiteMeshGroupType_MeshChoice()  {}

func (m *SiteMeshGroupType) GetMeshChoice() isSiteMeshGroupType_MeshChoice {
	if m != nil {
		return m.MeshChoice
	}
	return nil
}

func (m *SiteMeshGroupType) GetType() site_mesh_group.SiteMeshGroupType {
	if m != nil {
		return m.Type
	}
	return site_mesh_group.SITE_MESH_GROUP_TYPE_INVALID
}

func (m *SiteMeshGroupType) GetSiteType() site.SiteType {
	if m != nil {
		return m.SiteType
	}
	return site.INVALID
}

func (m *SiteMeshGroupType) GetVirtualSite() []*schema.ObjectRefType {
	if m != nil {
		return m.VirtualSite
	}
	return nil
}

func (m *SiteMeshGroupType) GetHub() []*schema.ObjectRefType {
	if m != nil {
		return m.Hub
	}
	return nil
}

func (m *SiteMeshGroupType) GetHubMesh() *site_mesh_group.HubFullMeshGroupType {
	if x, ok := m.GetMeshChoice().(*SiteMeshGroupType_HubMesh); ok {
		return x.HubMesh
	}
	return nil
}

func (m *SiteMeshGroupType) GetSpokeMesh() *site_mesh_group.SpokeMeshGroupType {
	if x, ok := m.GetMeshChoice().(*SiteMeshGroupType_SpokeMesh); ok {
		return x.SpokeMesh
	}
	return nil
}

func (m *SiteMeshGroupType) GetFullMesh() *site_mesh_group.FullMeshGroupType {
	if x, ok := m.GetMeshChoice().(*SiteMeshGroupType_FullMesh); ok {
		return x.FullMesh
	}
	return nil
}

func (m *SiteMeshGroupType) GetTopologySite() []*schema.ObjectRefType {
	if m != nil {
		return m.TopologySite
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SiteMeshGroupType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SiteMeshGroupType_HubMesh)(nil),
		(*SiteMeshGroupType_SpokeMesh)(nil),
		(*SiteMeshGroupType_FullMesh)(nil),
	}
}

// DC Cluster Group
//
// x-displayName: "DC Cluster Group"
// A canonical form of the DC cluster group.
type DCClusterGroupType struct {
	Type *dc_cluster_group.DCClusterGroupMeshType `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *DCClusterGroupType) Reset()      { *m = DCClusterGroupType{} }
func (*DCClusterGroupType) ProtoMessage() {}
func (*DCClusterGroupType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{15}
}
func (m *DCClusterGroupType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DCClusterGroupType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DCClusterGroupType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DCClusterGroupType.Merge(m, src)
}
func (m *DCClusterGroupType) XXX_Size() int {
	return m.Size()
}
func (m *DCClusterGroupType) XXX_DiscardUnknown() {
	xxx_messageInfo_DCClusterGroupType.DiscardUnknown(m)
}

var xxx_messageInfo_DCClusterGroupType proto.InternalMessageInfo

func (m *DCClusterGroupType) GetType() *dc_cluster_group.DCClusterGroupMeshType {
	if m != nil {
		return m.Type
	}
	return nil
}

// Network Interface
//
// x-displayName: "Network Interface"
// A canonical form of the network interface.
type NetworkInterfaceType struct {
	// Subnets
	//
	// x-displayName: "Subnets"
	// Reference to the subnets connected
	Subnet []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=subnet,proto3" json:"subnet,omitempty"`
	// Status
	//
	// x-displayName: "Status"
	// Status
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// Private addresses
	//
	// x-displayName: "Private Addresses"
	// Private Address
	PrivateAddresses []*AddressInfoType `protobuf:"bytes,3,rep,name=private_addresses,json=privateAddresses,proto3" json:"private_addresses,omitempty"`
	// Public address
	//
	// x-displayName: "Public Address"
	// Public address
	PublicAddress []*AddressInfoType `protobuf:"bytes,4,rep,name=public_address,json=publicAddress,proto3" json:"public_address,omitempty"`
	// Security Groups
	//
	// x-displayName: "Security Groups"
	// Security groups
	SecurityGroup []string `protobuf:"bytes,5,rep,name=security_group,json=securityGroup,proto3" json:"security_group,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	// Name of this interface
	Name string `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	// F5XC status
	//
	// x-displayName: "f5xc status"
	// F5XC side interface status
	F5XcStatus *site.InterfaceStatus `protobuf:"bytes,7,opt,name=f5xc_status,json=f5xcStatus,proto3" json:"f5xc_status,omitempty"`
}

func (m *NetworkInterfaceType) Reset()      { *m = NetworkInterfaceType{} }
func (*NetworkInterfaceType) ProtoMessage() {}
func (*NetworkInterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{16}
}
func (m *NetworkInterfaceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkInterfaceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkInterfaceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInterfaceType.Merge(m, src)
}
func (m *NetworkInterfaceType) XXX_Size() int {
	return m.Size()
}
func (m *NetworkInterfaceType) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInterfaceType.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInterfaceType proto.InternalMessageInfo

func (m *NetworkInterfaceType) GetSubnet() []*schema.ObjectRefType {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *NetworkInterfaceType) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *NetworkInterfaceType) GetPrivateAddresses() []*AddressInfoType {
	if m != nil {
		return m.PrivateAddresses
	}
	return nil
}

func (m *NetworkInterfaceType) GetPublicAddress() []*AddressInfoType {
	if m != nil {
		return m.PublicAddress
	}
	return nil
}

func (m *NetworkInterfaceType) GetSecurityGroup() []string {
	if m != nil {
		return m.SecurityGroup
	}
	return nil
}

func (m *NetworkInterfaceType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NetworkInterfaceType) GetF5XcStatus() *site.InterfaceStatus {
	if m != nil {
		return m.F5XcStatus
	}
	return nil
}

// Address Info Type
//
// x-displayName: "Address Info Type"
// Address with additional information
type AddressInfoType struct {
	// Address
	//
	// x-displayName: "Address"
	// Address
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// DNS Name
	//
	// x-displayName: "Public Address"
	// Address type
	DnsName string `protobuf:"bytes,3,opt,name=dns_name,json=dnsName,proto3" json:"dns_name,omitempty"`
	// Primary
	//
	// x-displayName: "Primary"
	// Indicate this address is primary or not
	Primary bool `protobuf:"varint,4,opt,name=primary,proto3" json:"primary,omitempty"`
}

func (m *AddressInfoType) Reset()      { *m = AddressInfoType{} }
func (*AddressInfoType) ProtoMessage() {}
func (*AddressInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{17}
}
func (m *AddressInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AddressInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressInfoType.Merge(m, src)
}
func (m *AddressInfoType) XXX_Size() int {
	return m.Size()
}
func (m *AddressInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_AddressInfoType proto.InternalMessageInfo

func (m *AddressInfoType) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *AddressInfoType) GetDnsName() string {
	if m != nil {
		return m.DnsName
	}
	return ""
}

func (m *AddressInfoType) GetPrimary() bool {
	if m != nil {
		return m.Primary
	}
	return false
}

// TunnelSetType
//
// x-displayName: "tunnel set type"
// A canonical form of the tunnel set of the site.
type TunnelSetType struct {
	// Site
	//
	// x-displayName: "Site"
	// Reference to source of tunnels.
	Site []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=site,proto3" json:"site,omitempty"`
	// Tunnnels
	//
	// x-displayName: "Tunnels"
	// Tunnel status.
	Tunnels []*TunnelType `protobuf:"bytes,2,rep,name=tunnels,proto3" json:"tunnels,omitempty"`
}

func (m *TunnelSetType) Reset()      { *m = TunnelSetType{} }
func (*TunnelSetType) ProtoMessage() {}
func (*TunnelSetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{18}
}
func (m *TunnelSetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelSetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TunnelSetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelSetType.Merge(m, src)
}
func (m *TunnelSetType) XXX_Size() int {
	return m.Size()
}
func (m *TunnelSetType) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelSetType.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelSetType proto.InternalMessageInfo

func (m *TunnelSetType) GetSite() []*schema.ObjectRefType {
	if m != nil {
		return m.Site
	}
	return nil
}

func (m *TunnelSetType) GetTunnels() []*TunnelType {
	if m != nil {
		return m.Tunnels
	}
	return nil
}

// NetworkPeerType
//
// x-displayName: "NetworkPeerType"
// A canonical form of the NetworkPeerType
type NetworkPeerType struct {
	// Peer Choice
	//
	// x-displayName: "Peer Choice"
	// Specify the Peer
	//
	// Types that are valid to be assigned to PeerChoice:
	//	*NetworkPeerType_VnetPeer
	PeerChoice isNetworkPeerType_PeerChoice `protobuf_oneof:"peer_choice"`
}

func (m *NetworkPeerType) Reset()      { *m = NetworkPeerType{} }
func (*NetworkPeerType) ProtoMessage() {}
func (*NetworkPeerType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{19}
}
func (m *NetworkPeerType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkPeerType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkPeerType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkPeerType.Merge(m, src)
}
func (m *NetworkPeerType) XXX_Size() int {
	return m.Size()
}
func (m *NetworkPeerType) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkPeerType.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkPeerType proto.InternalMessageInfo

type isNetworkPeerType_PeerChoice interface {
	isNetworkPeerType_PeerChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type NetworkPeerType_VnetPeer struct {
	VnetPeer *AzureVnetPeer `protobuf:"bytes,2,opt,name=vnet_peer,json=vnetPeer,proto3,oneof" json:"vnet_peer,omitempty"`
}

func (*NetworkPeerType_VnetPeer) isNetworkPeerType_PeerChoice() {}

func (m *NetworkPeerType) GetPeerChoice() isNetworkPeerType_PeerChoice {
	if m != nil {
		return m.PeerChoice
	}
	return nil
}

func (m *NetworkPeerType) GetVnetPeer() *AzureVnetPeer {
	if x, ok := m.GetPeerChoice().(*NetworkPeerType_VnetPeer); ok {
		return x.VnetPeer
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NetworkPeerType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NetworkPeerType_VnetPeer)(nil),
	}
}

// AzureVnetPeer
//
// x-displayName: "AzureVnetPeer"
// AzureVnetPeer
type AzureVnetPeer struct {
	// Azure VNET Peer Network
	//
	// x-displayName: "Azure VNET Peer Network"
	// Reference to source of Network.
	PeerNetwork []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=peer_network,json=peerNetwork,proto3" json:"peer_network,omitempty"`
	// Peering State
	//
	// x-displayName: "Peering State"
	// Peering State
	PeeringState PeeringStateEnum `protobuf:"varint,2,opt,name=peering_state,json=peeringState,proto3,enum=ves.io.schema.topology.PeeringStateEnum" json:"peering_state,omitempty"`
}

func (m *AzureVnetPeer) Reset()      { *m = AzureVnetPeer{} }
func (*AzureVnetPeer) ProtoMessage() {}
func (*AzureVnetPeer) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{20}
}
func (m *AzureVnetPeer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureVnetPeer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureVnetPeer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureVnetPeer.Merge(m, src)
}
func (m *AzureVnetPeer) XXX_Size() int {
	return m.Size()
}
func (m *AzureVnetPeer) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureVnetPeer.DiscardUnknown(m)
}

var xxx_messageInfo_AzureVnetPeer proto.InternalMessageInfo

func (m *AzureVnetPeer) GetPeerNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.PeerNetwork
	}
	return nil
}

func (m *AzureVnetPeer) GetPeeringState() PeeringStateEnum {
	if m != nil {
		return m.PeeringState
	}
	return CONNECTED
}

// TunnelType
//
// x-displayName: "tunnel type"
// A canonical form of the tunnel.
type TunnelType struct {
	// Connection Status
	//
	// x-displayName: "Connection Status"
	// Connection status.
	Connection *site.TunnelConnectionStatus `protobuf:"bytes,1,opt,name=connection,proto3" json:"connection,omitempty"`
	// Site
	//
	// x-displayName: "Site"
	// Reference to the connected site.
	Site []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=site,proto3" json:"site,omitempty"`
	// TransitGateway
	//
	// x-displayName: "TransitGateway"
	// Reference to the connected transit gateway
	Tgw []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=tgw,proto3" json:"tgw,omitempty"`
}

func (m *TunnelType) Reset()      { *m = TunnelType{} }
func (*TunnelType) ProtoMessage() {}
func (*TunnelType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{21}
}
func (m *TunnelType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TunnelType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelType.Merge(m, src)
}
func (m *TunnelType) XXX_Size() int {
	return m.Size()
}
func (m *TunnelType) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelType.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelType proto.InternalMessageInfo

func (m *TunnelType) GetConnection() *site.TunnelConnectionStatus {
	if m != nil {
		return m.Connection
	}
	return nil
}

func (m *TunnelType) GetSite() []*schema.ObjectRefType {
	if m != nil {
		return m.Site
	}
	return nil
}

func (m *TunnelType) GetTgw() []*schema.ObjectRefType {
	if m != nil {
		return m.Tgw
	}
	return nil
}

// CloudPolicyType
//
// x-displayName: "Cloud Policy Type"
// Cloud related policy info
type CloudPolicyType struct {
	// Cloud Provider Policy Type
	//
	// x-displayName: "Cloud Provider Policy Type"
	// Specify one of the policy types
	//
	// Types that are valid to be assigned to CloudType:
	//	*CloudPolicyType_Aws
	CloudType isCloudPolicyType_CloudType `protobuf_oneof:"cloud_type"`
	//"Are Permissions Populated"
	//
	// x-displayName: "Are Permissions Populated"
	// Are Permissions populated
	PermissionsPopulated bool `protobuf:"varint,5,opt,name=permissions_populated,json=permissionsPopulated,proto3" json:"permissions_populated,omitempty"`
	//"Cloud Provider Error"
	//
	// x-displayName: "Cloud Provider Error"
	// Cloud provider error when retreiving permissions
	CloudProviderError string `protobuf:"bytes,6,opt,name=cloud_provider_error,json=cloudProviderError,proto3" json:"cloud_provider_error,omitempty"`
}

func (m *CloudPolicyType) Reset()      { *m = CloudPolicyType{} }
func (*CloudPolicyType) ProtoMessage() {}
func (*CloudPolicyType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{22}
}
func (m *CloudPolicyType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudPolicyType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloudPolicyType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudPolicyType.Merge(m, src)
}
func (m *CloudPolicyType) XXX_Size() int {
	return m.Size()
}
func (m *CloudPolicyType) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudPolicyType.DiscardUnknown(m)
}

var xxx_messageInfo_CloudPolicyType proto.InternalMessageInfo

type isCloudPolicyType_CloudType interface {
	isCloudPolicyType_CloudType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CloudPolicyType_Aws struct {
	Aws *AWSPolicyType `protobuf:"bytes,2,opt,name=aws,proto3,oneof" json:"aws,omitempty"`
}

func (*CloudPolicyType_Aws) isCloudPolicyType_CloudType() {}

func (m *CloudPolicyType) GetCloudType() isCloudPolicyType_CloudType {
	if m != nil {
		return m.CloudType
	}
	return nil
}

func (m *CloudPolicyType) GetAws() *AWSPolicyType {
	if x, ok := m.GetCloudType().(*CloudPolicyType_Aws); ok {
		return x.Aws
	}
	return nil
}

func (m *CloudPolicyType) GetPermissionsPopulated() bool {
	if m != nil {
		return m.PermissionsPopulated
	}
	return false
}

func (m *CloudPolicyType) GetCloudProviderError() string {
	if m != nil {
		return m.CloudProviderError
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CloudPolicyType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CloudPolicyType_Aws)(nil),
	}
}

// AWSPolicyType
//
// x-displayName: "AWS Policy Type"
// AWS policy info
type AWSPolicyType struct {
	// AWS VPC Site Support
	//
	// x-displayName: "AWS VPC Site Support"
	// Is aws vpc site enabled
	SupportAwsVpcSite bool `protobuf:"varint,1,opt,name=support_aws_vpc_site,json=supportAwsVpcSite,proto3" json:"support_aws_vpc_site,omitempty"`
	// "Missing Permissions At AWS VPC Site"
	//
	// x-displayName: "Missing Permissions At AWS VPC Site"
	// List of missing permissions at AWS VPC Site"
	MissingPermissionsAwsVpcSite []string `protobuf:"bytes,2,rep,name=missing_permissions_aws_vpc_site,json=missingPermissionsAwsVpcSite,proto3" json:"missing_permissions_aws_vpc_site,omitempty"`
	// "AWS TGW Site Support"
	//
	// x-displayName: "AWS TGW Site Support"
	// Is aws tgw site enabled
	SupportAwsTgwSite bool `protobuf:"varint,3,opt,name=support_aws_tgw_site,json=supportAwsTgwSite,proto3" json:"support_aws_tgw_site,omitempty"`
	// "Missing Permissions At AWS TGW Site"
	//
	// x-displayName: "Missing Permissions At AWS TGW Site"
	// List of missing permissions at AWS TGW Site"
	MissingPermissionsAwsTgwSite []string `protobuf:"bytes,4,rep,name=missing_permissions_aws_tgw_site,json=missingPermissionsAwsTgwSite,proto3" json:"missing_permissions_aws_tgw_site,omitempty"`
}

func (m *AWSPolicyType) Reset()      { *m = AWSPolicyType{} }
func (*AWSPolicyType) ProtoMessage() {}
func (*AWSPolicyType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{23}
}
func (m *AWSPolicyType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSPolicyType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSPolicyType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSPolicyType.Merge(m, src)
}
func (m *AWSPolicyType) XXX_Size() int {
	return m.Size()
}
func (m *AWSPolicyType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSPolicyType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSPolicyType proto.InternalMessageInfo

func (m *AWSPolicyType) GetSupportAwsVpcSite() bool {
	if m != nil {
		return m.SupportAwsVpcSite
	}
	return false
}

func (m *AWSPolicyType) GetMissingPermissionsAwsVpcSite() []string {
	if m != nil {
		return m.MissingPermissionsAwsVpcSite
	}
	return nil
}

func (m *AWSPolicyType) GetSupportAwsTgwSite() bool {
	if m != nil {
		return m.SupportAwsTgwSite
	}
	return false
}

func (m *AWSPolicyType) GetMissingPermissionsAwsTgwSite() []string {
	if m != nil {
		return m.MissingPermissionsAwsTgwSite
	}
	return nil
}

// AzureResourceGroupInfo
//
// x-displayName: "Azure Resource Group Info"
// Azure Site and Virtual Network resource group info
type AzureResourceGroupInfo struct {
	// Site Resource Group
	//
	// x-displayName: "Site Resource Group"
	// Resource group for Site
	SiteRg string `protobuf:"bytes,1,opt,name=site_rg,json=siteRg,proto3" json:"site_rg,omitempty"`
	// Virtual Network Resource Group
	//
	// x-displayName: "Virtual Network Resource Group"
	// Resource group for Virtual Network
	VirtualNetworkRg string `protobuf:"bytes,2,opt,name=virtual_network_rg,json=virtualNetworkRg,proto3" json:"virtual_network_rg,omitempty"`
}

func (m *AzureResourceGroupInfo) Reset()      { *m = AzureResourceGroupInfo{} }
func (*AzureResourceGroupInfo) ProtoMessage() {}
func (*AzureResourceGroupInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{24}
}
func (m *AzureResourceGroupInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureResourceGroupInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureResourceGroupInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureResourceGroupInfo.Merge(m, src)
}
func (m *AzureResourceGroupInfo) XXX_Size() int {
	return m.Size()
}
func (m *AzureResourceGroupInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureResourceGroupInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AzureResourceGroupInfo proto.InternalMessageInfo

func (m *AzureResourceGroupInfo) GetSiteRg() string {
	if m != nil {
		return m.SiteRg
	}
	return ""
}

func (m *AzureResourceGroupInfo) GetVirtualNetworkRg() string {
	if m != nil {
		return m.VirtualNetworkRg
	}
	return ""
}

// ProviderInfo
//
// x-displayName: "Provider Info"
// Cloud provider information
type ProviderInfo struct {
	// Region
	//
	// x-displayName: "Region"
	// Region in which the resource exists
	Region string `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty"`
	// GCP Zones
	//
	// x-displayName: "GCP Zones"
	// GCP Zones for the resource
	GcpZones []string `protobuf:"bytes,2,rep,name=gcp_zones,json=gcpZones,proto3" json:"gcp_zones,omitempty"`
	// Azure Resource Group Info
	//
	// x-displayName: "Azure Resource Group Info"
	// Resource group information for Azure Site and Virtual Network
	AzureRgInfo *AzureResourceGroupInfo `protobuf:"bytes,3,opt,name=azure_rg_info,json=azureRgInfo,proto3" json:"azure_rg_info,omitempty"`
	// Cloud Link
	//
	// x-displayName: "Cloud Link"
	// Reference to cloud link
	CloudLink []*schema.ObjectRefType `protobuf:"bytes,4,rep,name=cloud_link,json=cloudLink,proto3" json:"cloud_link,omitempty"`
}

func (m *ProviderInfo) Reset()      { *m = ProviderInfo{} }
func (*ProviderInfo) ProtoMessage() {}
func (*ProviderInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e89c101129b5baba, []int{25}
}
func (m *ProviderInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProviderInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProviderInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProviderInfo.Merge(m, src)
}
func (m *ProviderInfo) XXX_Size() int {
	return m.Size()
}
func (m *ProviderInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ProviderInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ProviderInfo proto.InternalMessageInfo

func (m *ProviderInfo) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *ProviderInfo) GetGcpZones() []string {
	if m != nil {
		return m.GcpZones
	}
	return nil
}

func (m *ProviderInfo) GetAzureRgInfo() *AzureResourceGroupInfo {
	if m != nil {
		return m.AzureRgInfo
	}
	return nil
}

func (m *ProviderInfo) GetCloudLink() []*schema.ObjectRefType {
	if m != nil {
		return m.CloudLink
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.topology.ProviderType", ProviderType_name, ProviderType_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.ProviderType", ProviderType_name, ProviderType_value)
	proto.RegisterEnum("ves.io.schema.topology.SiteEnumType", SiteEnumType_name, SiteEnumType_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.SiteEnumType", SiteEnumType_name, SiteEnumType_value)
	proto.RegisterEnum("ves.io.schema.topology.RouteTableStateEnum", RouteTableStateEnum_name, RouteTableStateEnum_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.RouteTableStateEnum", RouteTableStateEnum_name, RouteTableStateEnum_value)
	proto.RegisterEnum("ves.io.schema.topology.RouteTableTypeEnum", RouteTableTypeEnum_name, RouteTableTypeEnum_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.RouteTableTypeEnum", RouteTableTypeEnum_name, RouteTableTypeEnum_value)
	proto.RegisterEnum("ves.io.schema.topology.CloudNetworkType", CloudNetworkType_name, CloudNetworkType_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.CloudNetworkType", CloudNetworkType_name, CloudNetworkType_value)
	proto.RegisterEnum("ves.io.schema.topology.InterfaceTypeEnum", InterfaceTypeEnum_name, InterfaceTypeEnum_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.InterfaceTypeEnum", InterfaceTypeEnum_name, InterfaceTypeEnum_value)
	proto.RegisterEnum("ves.io.schema.topology.RouteSourceTypeEnum", RouteSourceTypeEnum_name, RouteSourceTypeEnum_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.RouteSourceTypeEnum", RouteSourceTypeEnum_name, RouteSourceTypeEnum_value)
	proto.RegisterEnum("ves.io.schema.topology.RouteStateTypeEnum", RouteStateTypeEnum_name, RouteStateTypeEnum_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.RouteStateTypeEnum", RouteStateTypeEnum_name, RouteStateTypeEnum_value)
	proto.RegisterEnum("ves.io.schema.topology.RouteNextHopTypeEnum", RouteNextHopTypeEnum_name, RouteNextHopTypeEnum_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.RouteNextHopTypeEnum", RouteNextHopTypeEnum_name, RouteNextHopTypeEnum_value)
	proto.RegisterEnum("ves.io.schema.topology.GatewayTypeEnum", GatewayTypeEnum_name, GatewayTypeEnum_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.GatewayTypeEnum", GatewayTypeEnum_name, GatewayTypeEnum_value)
	proto.RegisterEnum("ves.io.schema.topology.GCPRouteType", GCPRouteType_name, GCPRouteType_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.GCPRouteType", GCPRouteType_name, GCPRouteType_value)
	proto.RegisterEnum("ves.io.schema.topology.SiteAppTypeEnum", SiteAppTypeEnum_name, SiteAppTypeEnum_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.SiteAppTypeEnum", SiteAppTypeEnum_name, SiteAppTypeEnum_value)
	proto.RegisterEnum("ves.io.schema.topology.PeeringStateEnum", PeeringStateEnum_name, PeeringStateEnum_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.PeeringStateEnum", PeeringStateEnum_name, PeeringStateEnum_value)
	proto.RegisterType((*MetaType)(nil), "ves.io.schema.topology.MetaType")
	golang_proto.RegisterType((*MetaType)(nil), "ves.io.schema.topology.MetaType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.topology.MetaType.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.topology.MetaType.TagsEntry")
	proto.RegisterType((*NetworkType)(nil), "ves.io.schema.topology.NetworkType")
	golang_proto.RegisterType((*NetworkType)(nil), "ves.io.schema.topology.NetworkType")
	proto.RegisterType((*LoadBalancer)(nil), "ves.io.schema.topology.LoadBalancer")
	golang_proto.RegisterType((*LoadBalancer)(nil), "ves.io.schema.topology.LoadBalancer")
	proto.RegisterType((*SubnetType)(nil), "ves.io.schema.topology.SubnetType")
	golang_proto.RegisterType((*SubnetType)(nil), "ves.io.schema.topology.SubnetType")
	proto.RegisterType((*InstanceType)(nil), "ves.io.schema.topology.InstanceType")
	golang_proto.RegisterType((*InstanceType)(nil), "ves.io.schema.topology.InstanceType")
	proto.RegisterType((*AWSTGWAttachment)(nil), "ves.io.schema.topology.AWSTGWAttachment")
	golang_proto.RegisterType((*AWSTGWAttachment)(nil), "ves.io.schema.topology.AWSTGWAttachment")
	proto.RegisterType((*TransitGatewayType)(nil), "ves.io.schema.topology.TransitGatewayType")
	golang_proto.RegisterType((*TransitGatewayType)(nil), "ves.io.schema.topology.TransitGatewayType")
	proto.RegisterType((*RouteTableType)(nil), "ves.io.schema.topology.RouteTableType")
	golang_proto.RegisterType((*RouteTableType)(nil), "ves.io.schema.topology.RouteTableType")
	proto.RegisterType((*AWSTGWAttachmentMetaData)(nil), "ves.io.schema.topology.AWSTGWAttachmentMetaData")
	golang_proto.RegisterType((*AWSTGWAttachmentMetaData)(nil), "ves.io.schema.topology.AWSTGWAttachmentMetaData")
	proto.RegisterType((*GCPRouteAttributes)(nil), "ves.io.schema.topology.GCPRouteAttributes")
	golang_proto.RegisterType((*GCPRouteAttributes)(nil), "ves.io.schema.topology.GCPRouteAttributes")
	proto.RegisterType((*AWSTgwRouteAttributes)(nil), "ves.io.schema.topology.AWSTgwRouteAttributes")
	golang_proto.RegisterType((*AWSTgwRouteAttributes)(nil), "ves.io.schema.topology.AWSTgwRouteAttributes")
	proto.RegisterType((*AWSRouteAttributes)(nil), "ves.io.schema.topology.AWSRouteAttributes")
	golang_proto.RegisterType((*AWSRouteAttributes)(nil), "ves.io.schema.topology.AWSRouteAttributes")
	proto.RegisterType((*RouteType)(nil), "ves.io.schema.topology.RouteType")
	golang_proto.RegisterType((*RouteType)(nil), "ves.io.schema.topology.RouteType")
	proto.RegisterType((*SiteType)(nil), "ves.io.schema.topology.SiteType")
	golang_proto.RegisterType((*SiteType)(nil), "ves.io.schema.topology.SiteType")
	proto.RegisterType((*SiteMeshGroupType)(nil), "ves.io.schema.topology.SiteMeshGroupType")
	golang_proto.RegisterType((*SiteMeshGroupType)(nil), "ves.io.schema.topology.SiteMeshGroupType")
	proto.RegisterType((*DCClusterGroupType)(nil), "ves.io.schema.topology.DCClusterGroupType")
	golang_proto.RegisterType((*DCClusterGroupType)(nil), "ves.io.schema.topology.DCClusterGroupType")
	proto.RegisterType((*NetworkInterfaceType)(nil), "ves.io.schema.topology.NetworkInterfaceType")
	golang_proto.RegisterType((*NetworkInterfaceType)(nil), "ves.io.schema.topology.NetworkInterfaceType")
	proto.RegisterType((*AddressInfoType)(nil), "ves.io.schema.topology.AddressInfoType")
	golang_proto.RegisterType((*AddressInfoType)(nil), "ves.io.schema.topology.AddressInfoType")
	proto.RegisterType((*TunnelSetType)(nil), "ves.io.schema.topology.TunnelSetType")
	golang_proto.RegisterType((*TunnelSetType)(nil), "ves.io.schema.topology.TunnelSetType")
	proto.RegisterType((*NetworkPeerType)(nil), "ves.io.schema.topology.NetworkPeerType")
	golang_proto.RegisterType((*NetworkPeerType)(nil), "ves.io.schema.topology.NetworkPeerType")
	proto.RegisterType((*AzureVnetPeer)(nil), "ves.io.schema.topology.AzureVnetPeer")
	golang_proto.RegisterType((*AzureVnetPeer)(nil), "ves.io.schema.topology.AzureVnetPeer")
	proto.RegisterType((*TunnelType)(nil), "ves.io.schema.topology.TunnelType")
	golang_proto.RegisterType((*TunnelType)(nil), "ves.io.schema.topology.TunnelType")
	proto.RegisterType((*CloudPolicyType)(nil), "ves.io.schema.topology.CloudPolicyType")
	golang_proto.RegisterType((*CloudPolicyType)(nil), "ves.io.schema.topology.CloudPolicyType")
	proto.RegisterType((*AWSPolicyType)(nil), "ves.io.schema.topology.AWSPolicyType")
	golang_proto.RegisterType((*AWSPolicyType)(nil), "ves.io.schema.topology.AWSPolicyType")
	proto.RegisterType((*AzureResourceGroupInfo)(nil), "ves.io.schema.topology.AzureResourceGroupInfo")
	golang_proto.RegisterType((*AzureResourceGroupInfo)(nil), "ves.io.schema.topology.AzureResourceGroupInfo")
	proto.RegisterType((*ProviderInfo)(nil), "ves.io.schema.topology.ProviderInfo")
	golang_proto.RegisterType((*ProviderInfo)(nil), "ves.io.schema.topology.ProviderInfo")
}

func init() {
	proto.RegisterFile("ves.io/schema/topology/types.proto", fileDescriptor_e89c101129b5baba)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/topology/types.proto", fileDescriptor_e89c101129b5baba)
}

var fileDescriptor_e89c101129b5baba = []byte{
	// 3645 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x5a, 0xdd, 0x6f, 0xe3, 0xd8,
	0x75, 0x37, 0x25, 0x59, 0x1f, 0x47, 0x1f, 0xa6, 0xef, 0xd8, 0x1e, 0x79, 0x66, 0x56, 0x71, 0xb4,
	0xbb, 0xcd, 0xc4, 0xd9, 0xb5, 0xd3, 0xd9, 0x64, 0xdb, 0x2d, 0x8a, 0xb4, 0x94, 0xc4, 0xb5, 0xe5,
	0xd1, 0x50, 0x02, 0x45, 0xdb, 0xdd, 0x29, 0x50, 0x2e, 0x4d, 0xd1, 0x34, 0x33, 0x32, 0x49, 0x90,
	0x94, 0x3d, 0x0e, 0x60, 0x20, 0x7d, 0x2d, 0x5a, 0x20, 0xe9, 0x6b, 0xd1, 0xf6, 0xb5, 0x75, 0x5f,
	0x5a, 0xa0, 0x08, 0xd0, 0x6e, 0x0a, 0xec, 0x4b, 0x81, 0x3e, 0x4e, 0x5f, 0x8a, 0x45, 0x9f, 0xb2,
	0x9e, 0x97, 0xe4, 0xa9, 0xf9, 0x07, 0x5a, 0x14, 0xf7, 0x4b, 0x22, 0x25, 0x7b, 0xec, 0xc9, 0xcc,
	0x1b, 0x79, 0xbe, 0xee, 0xb9, 0xe7, 0xfc, 0xee, 0xb9, 0x87, 0x47, 0x82, 0xfa, 0x89, 0x15, 0x6e,
	0x38, 0xde, 0x66, 0x68, 0x1e, 0x59, 0xc7, 0xc6, 0x66, 0xe4, 0xf9, 0xde, 0xd0, 0xb3, 0xcf, 0x36,
	0xa3, 0x33, 0xdf, 0x0a, 0x37, 0xfc, 0xc0, 0x8b, 0x3c, 0xb4, 0x42, 0x65, 0x36, 0xa8, 0xcc, 0x06,
	0x97, 0xb9, 0xf7, 0xa1, 0xed, 0x44, 0x47, 0xa3, 0x83, 0x0d, 0xd3, 0x3b, 0xde, 0xb4, 0x3d, 0xdb,
	0xdb, 0x24, 0xe2, 0x07, 0xa3, 0x43, 0xf2, 0x46, 0x5e, 0xc8, 0x13, 0x35, 0x73, 0x6f, 0xd5, 0xf6,
	0x3c, 0x7b, 0x68, 0x4d, 0xa4, 0x0c, 0xf7, 0x8c, 0xb1, 0xd6, 0x93, 0x5e, 0x0c, 0x4c, 0xdd, 0x1c,
	0x8e, 0xc2, 0xc8, 0x0a, 0x74, 0x3b, 0xf0, 0x46, 0x7e, 0xdc, 0x9b, 0x7b, 0x77, 0x93, 0xb2, 0xae,
	0x15, 0x31, 0xc6, 0xfd, 0x24, 0xc3, 0xf3, 0x23, 0xc7, 0x73, 0xb9, 0x56, 0x2d, 0xc9, 0x0c, 0x9d,
	0xc8, 0x4a, 0x58, 0xfd, 0xf6, 0x2c, 0x5f, 0x3f, 0xb6, 0xc2, 0xa3, 0x2b, 0x1c, 0x58, 0x9d, 0x0a,
	0x59, 0x8c, 0xf5, 0x20, 0xc9, 0x3a, 0x31, 0x86, 0xce, 0xc0, 0x88, 0x2c, 0xc6, 0x5d, 0x9b, 0xe2,
	0x3a, 0xd6, 0xa9, 0x9e, 0xf0, 0xb2, 0xfe, 0xd7, 0x69, 0xc8, 0x3f, 0xb1, 0x22, 0x43, 0x3b, 0xf3,
	0x2d, 0x54, 0x81, 0x94, 0x33, 0xa8, 0x0a, 0x6b, 0xc2, 0xc3, 0x82, 0x9a, 0x72, 0x06, 0x08, 0x41,
	0xc6, 0x35, 0x8e, 0xad, 0x6a, 0x8a, 0x50, 0xc8, 0x33, 0xda, 0x86, 0x79, 0x33, 0xb0, 0x06, 0x61,
	0x35, 0xbd, 0x96, 0x7e, 0x58, 0x7c, 0xf4, 0x60, 0x23, 0x99, 0xaa, 0xee, 0xc1, 0x0f, 0x2d, 0x33,
	0x52, 0xad, 0x43, 0x6c, 0xb0, 0xb1, 0x74, 0x71, 0xbe, 0x68, 0x0e, 0xbd, 0xd1, 0x40, 0xc7, 0x3a,
	0x96, 0x1b, 0x39, 0xc6, 0x30, 0x54, 0xa9, 0x01, 0xb4, 0x0a, 0xf9, 0xc0, 0x38, 0xd5, 0x7f, 0x18,
	0x7a, 0x6e, 0x75, 0x9e, 0xac, 0x90, 0x0b, 0x8c, 0xd3, 0x9d, 0xd0, 0x73, 0xd1, 0x0a, 0x64, 0xc3,
	0xc8, 0x88, 0x46, 0x61, 0x35, 0x4b, 0x18, 0xec, 0x0d, 0x3d, 0x86, 0x4c, 0x64, 0xd8, 0x61, 0x35,
	0x47, 0xd6, 0x5e, 0xdf, 0xb8, 0x1a, 0x26, 0x1b, 0x7c, 0x43, 0x1b, 0x9a, 0x61, 0x87, 0xb2, 0x1b,
	0x05, 0x67, 0x8d, 0xe2, 0xe5, 0x2f, 0xfe, 0x3d, 0x9d, 0xfd, 0xb3, 0x9f, 0x0b, 0xa9, 0xfc, 0x9c,
	0x4a, 0x8c, 0xe0, 0xf5, 0xbd, 0x53, 0xd7, 0x0a, 0x74, 0x67, 0x50, 0xcd, 0xd3, 0xf5, 0xc9, 0x7b,
	0x7b, 0x80, 0xda, 0x50, 0xf6, 0x03, 0xef, 0xc4, 0x19, 0x58, 0x81, 0x8e, 0xa3, 0x5d, 0x2d, 0xac,
	0x09, 0x0f, 0x2b, 0x8f, 0xde, 0xbb, 0x6e, 0xc1, 0x1e, 0x13, 0xc6, 0x8b, 0xaa, 0x25, 0x3f, 0xf6,
	0x76, 0xef, 0x77, 0xa0, 0x30, 0xf6, 0x02, 0x89, 0x90, 0x7e, 0x66, 0x9d, 0xb1, 0x08, 0xe3, 0x47,
	0xb4, 0x04, 0xf3, 0x27, 0xc6, 0x70, 0xc4, 0x63, 0x4c, 0x5f, 0x7e, 0x2f, 0xf5, 0xbb, 0xc2, 0x4e,
	0x26, 0x9f, 0x11, 0xe7, 0xeb, 0xff, 0x94, 0x82, 0xa2, 0x62, 0x45, 0xa7, 0x5e, 0xf0, 0x8c, 0xa4,
	0x68, 0x1b, 0xb2, 0x81, 0x65, 0x3b, 0x9e, 0x5b, 0x15, 0x6e, 0x11, 0x7f, 0x74, 0x71, 0xbe, 0xc0,
	0x9d, 0xd4, 0xa9, 0x9e, 0xca, 0xf4, 0xd1, 0x5d, 0xc8, 0x99, 0xce, 0x20, 0xd0, 0x4f, 0xbe, 0x57,
	0x4d, 0xad, 0xa5, 0x71, 0x90, 0xf1, 0xeb, 0xde, 0xf7, 0x26, 0x8c, 0x8f, 0x49, 0x8e, 0x39, 0xe3,
	0x63, 0xf4, 0xc7, 0x50, 0x76, 0xa9, 0x2b, 0xba, 0x6f, 0x59, 0x41, 0x58, 0xcd, 0xdc, 0xc2, 0x85,
	0xea, 0xc5, 0xf9, 0xf2, 0xd8, 0x85, 0xb8, 0xba, 0x5a, 0x62, 0x6f, 0x3d, 0x6c, 0x0b, 0x87, 0x7c,
	0xe8, 0x19, 0x03, 0xfd, 0xc0, 0x18, 0x1a, 0xae, 0x69, 0x05, 0xd5, 0x79, 0x62, 0xfc, 0xda, 0x90,
	0x77, 0x3c, 0x63, 0xd0, 0x60, 0xb2, 0x6a, 0x69, 0x18, 0x7b, 0xab, 0x3f, 0x82, 0x52, 0x9c, 0x3b,
	0x86, 0xb1, 0x10, 0x83, 0x31, 0x85, 0x7a, 0x8a, 0x43, 0xbd, 0xfe, 0xdf, 0x29, 0x80, 0xfe, 0xe8,
	0xc0, 0xb5, 0x22, 0x12, 0xe6, 0xc7, 0x90, 0x63, 0xde, 0x91, 0xe0, 0xdc, 0xb4, 0xc9, 0x3b, 0x17,
	0xe7, 0xe2, 0xf4, 0x26, 0x55, 0x6e, 0x21, 0x96, 0xb3, 0xf4, 0x1b, 0xe6, 0xec, 0x3b, 0xb0, 0x68,
	0x9c, 0x18, 0xce, 0xd0, 0x38, 0x70, 0x86, 0x4e, 0x74, 0xa6, 0xff, 0xc8, 0x73, 0xad, 0x6a, 0x86,
	0x6c, 0x42, 0x8c, 0x33, 0x9e, 0x7a, 0xae, 0x15, 0x4f, 0xf0, 0xfc, 0x75, 0x09, 0xce, 0x26, 0x12,
	0xdc, 0x83, 0x8a, 0xe3, 0x46, 0x56, 0x70, 0x68, 0x98, 0x16, 0xc5, 0x7d, 0x8e, 0xe0, 0xfe, 0xdb,
	0xd7, 0x25, 0xa1, 0xcd, 0xa5, 0xb1, 0xe7, 0xb2, 0x3b, 0x3a, 0x56, 0xcb, 0x4e, 0x9c, 0xb4, 0x93,
	0xc9, 0x0b, 0x62, 0xaa, 0xfe, 0x3f, 0x69, 0x28, 0xb5, 0xdd, 0x30, 0xc2, 0xe9, 0x20, 0xe1, 0xed,
	0x00, 0x8c, 0xe5, 0x42, 0x86, 0xe4, 0x0f, 0xae, 0x5b, 0x84, 0xc1, 0x3f, 0xb1, 0x96, 0x1a, 0xd3,
	0x47, 0x75, 0x28, 0x19, 0x81, 0x79, 0xe4, 0x44, 0x96, 0x19, 0x8d, 0x02, 0x7e, 0x94, 0x12, 0x34,
	0x7c, 0xf2, 0x4c, 0x7f, 0x54, 0x4d, 0xaf, 0x09, 0x0f, 0xcb, 0x2a, 0x7e, 0x44, 0xef, 0x42, 0xd9,
	0x61, 0x3e, 0xd1, 0xbd, 0xd2, 0x38, 0x96, 0x9c, 0xb8, 0xa3, 0xf7, 0x20, 0xef, 0x0f, 0x8d, 0xe8,
	0xd0, 0x0b, 0x8e, 0x59, 0x8d, 0x1a, 0xbf, 0xa3, 0x6f, 0xc1, 0x82, 0x1f, 0x38, 0x27, 0x46, 0x64,
	0xe9, 0xc6, 0x60, 0x10, 0x58, 0x21, 0xaf, 0x56, 0x15, 0x46, 0x96, 0x28, 0x15, 0xbd, 0x0f, 0x15,
	0x7f, 0x74, 0x30, 0x74, 0xcc, 0xb1, 0x5c, 0x8e, 0xc8, 0x95, 0x29, 0x95, 0x8b, 0x3d, 0x04, 0x91,
	0xdb, 0x1b, 0xb8, 0xa1, 0x4e, 0x20, 0x9b, 0x4f, 0x18, 0x6c, 0xb9, 0xa1, 0x82, 0xc1, 0xfb, 0x5b,
	0xb0, 0xc0, 0x0c, 0x8e, 0x05, 0x0b, 0x71, 0x8b, 0x5c, 0xee, 0x7d, 0xa8, 0x84, 0x96, 0x39, 0x0a,
	0x30, 0x54, 0xc8, 0xad, 0x52, 0x05, 0x92, 0xef, 0x32, 0xa7, 0x6e, 0x61, 0xe2, 0xd5, 0xa8, 0x2a,
	0x5e, 0x83, 0xaa, 0xf7, 0xa0, 0x72, 0xf8, 0xfd, 0xe7, 0xa6, 0xee, 0x7a, 0x03, 0x8b, 0x2e, 0x5d,
	0xa2, 0x71, 0xc3, 0x54, 0xc5, 0x1b, 0x58, 0x78, 0xe5, 0xfa, 0xcf, 0xd2, 0x20, 0x4a, 0xfb, 0x7d,
	0x6d, 0x6b, 0x5f, 0x8a, 0x22, 0xc3, 0x3c, 0x3a, 0xb6, 0xdc, 0xe8, 0x56, 0xd7, 0xcb, 0xbb, 0x50,
	0x0e, 0xac, 0xd0, 0x1b, 0x05, 0x3c, 0x2b, 0x69, 0x6a, 0x9d, 0x13, 0x49, 0x56, 0xbe, 0x01, 0xc5,
	0xb1, 0x90, 0x33, 0x60, 0x89, 0x03, 0x4e, 0x6a, 0x0f, 0x12, 0x56, 0xc8, 0x12, 0xf3, 0x49, 0x2b,
	0x24, 0x3a, 0x08, 0x32, 0x18, 0xf7, 0x2c, 0x69, 0xe4, 0x19, 0x7d, 0x02, 0xab, 0x46, 0x18, 0x7a,
	0xa6, 0x63, 0x44, 0xd6, 0x40, 0x0f, 0xbc, 0x51, 0x64, 0xe9, 0x91, 0x71, 0x30, 0x24, 0xeb, 0xd0,
	0xac, 0xad, 0x4c, 0x04, 0x54, 0xcc, 0xd7, 0x30, 0xbb, 0x3d, 0x20, 0x51, 0x64, 0x1c, 0xc7, 0x73,
	0x75, 0x7c, 0x63, 0xf1, 0xfc, 0x89, 0x31, 0x46, 0x1f, 0xd3, 0x51, 0x1f, 0xca, 0xec, 0x5e, 0xf4,
	0x5c, 0xd7, 0x32, 0xa3, 0x6a, 0xe1, 0x16, 0x95, 0x41, 0xbc, 0x38, 0x4f, 0x6a, 0xa9, 0x25, 0xf2,
	0xda, 0xa4, 0x6f, 0xa8, 0x01, 0xb9, 0xd0, 0xb2, 0x71, 0xa8, 0x49, 0x9e, 0x6f, 0x32, 0x07, 0x17,
	0xe7, 0x5c, 0x5e, 0xe5, 0x0f, 0xf5, 0x7f, 0x4b, 0x01, 0xd2, 0x02, 0xc3, 0x0d, 0x9d, 0x68, 0xcb,
	0x88, 0xac, 0x53, 0xe3, 0x6c, 0xba, 0x1e, 0x0a, 0x6f, 0x5c, 0x0f, 0x9b, 0x50, 0x33, 0x46, 0x91,
	0xa7, 0x1b, 0xa6, 0x69, 0xf9, 0x91, 0x1e, 0x1e, 0x19, 0x81, 0x35, 0xd0, 0x8d, 0x31, 0x50, 0x42,
	0x82, 0x88, 0xbc, 0x7a, 0x1f, 0x4b, 0x49, 0x44, 0xa8, 0x4f, 0x64, 0x26, 0x58, 0x0a, 0x31, 0x06,
	0x30, 0xf8, 0xc3, 0x91, 0xef, 0x7b, 0x41, 0x44, 0x60, 0x92, 0x57, 0x61, 0xe0, 0x86, 0x7d, 0x4a,
	0xc1, 0xc7, 0xe9, 0xc4, 0x77, 0x75, 0xcb, 0x3c, 0xf6, 0xc7, 0x52, 0x19, 0x22, 0x55, 0x39, 0xf1,
	0x5d, 0xd9, 0x3c, 0xf6, 0xb9, 0xe4, 0x0e, 0x14, 0xe3, 0x8b, 0xd3, 0x8b, 0xe7, 0xe1, 0x75, 0xe5,
	0x68, 0x1a, 0xd6, 0x6a, 0x5c, 0xb9, 0xfe, 0x32, 0x0b, 0x95, 0x09, 0x2c, 0xf8, 0x95, 0x1d, 0x92,
	0x9b, 0xe5, 0xf5, 0xaf, 0x6c, 0xaa, 0xa7, 0x32, 0xfd, 0xb7, 0x7b, 0x2b, 0x1d, 0xc0, 0x42, 0x44,
	0x13, 0xad, 0xdb, 0x34, 0xd3, 0xb7, 0xba, 0x9e, 0xee, 0x5f, 0x9c, 0x57, 0xc7, 0x46, 0xa7, 0x0c,
	0xa8, 0x95, 0x28, 0x01, 0x1d, 0xf4, 0x09, 0x64, 0xc9, 0x19, 0xe2, 0xad, 0xc2, 0x37, 0xaf, 0x0b,
	0x2a, 0x0d, 0x19, 0x2e, 0xec, 0x4c, 0x01, 0x69, 0x20, 0xc6, 0x8f, 0x1f, 0xa9, 0x05, 0xf3, 0xe4,
	0x36, 0x5a, 0x7f, 0xb5, 0x11, 0x1e, 0x77, 0x72, 0x1d, 0x55, 0x82, 0x64, 0x2e, 0x3e, 0x83, 0x05,
	0xe7, 0xd8, 0x1f, 0x3a, 0xa6, 0x13, 0xb1, 0xe0, 0xb2, 0x5e, 0xf2, 0xf5, 0x93, 0x52, 0xe1, 0x86,
	0x68, 0xdb, 0x80, 0x4d, 0x5b, 0xcf, 0x93, 0xa6, 0xf3, 0xbf, 0xa9, 0x69, 0x6e, 0x88, 0x99, 0xde,
	0x87, 0xc5, 0x78, 0x2c, 0x68, 0x69, 0x01, 0x12, 0x8c, 0xef, 0xdc, 0x1c, 0x0c, 0x52, 0x71, 0x48,
	0x34, 0x16, 0x82, 0x24, 0x11, 0x69, 0x50, 0x8a, 0x95, 0xa6, 0xb0, 0x5a, 0x24, 0x0e, 0x7f, 0xf7,
	0xb6, 0xd0, 0xc7, 0x7d, 0x76, 0xcb, 0x88, 0x0c, 0x35, 0x61, 0x05, 0x5b, 0xf5, 0x03, 0xcf, 0x37,
	0x6c, 0x66, 0xb5, 0xf4, 0x9b, 0x5a, 0x8d, 0x5b, 0xd9, 0xc9, 0xe4, 0xb3, 0x62, 0x6e, 0x27, 0x93,
	0x2f, 0x88, 0x50, 0xff, 0x07, 0x01, 0xaa, 0xd7, 0xa9, 0xcd, 0x5c, 0x33, 0x33, 0x57, 0x4a, 0xea,
	0xe6, 0x2b, 0x25, 0x3d, 0x73, 0xa5, 0x2c, 0xc1, 0x3c, 0x8d, 0x3b, 0xbd, 0x6d, 0xe8, 0xcb, 0xad,
	0x2e, 0x9a, 0xfa, 0x7f, 0x09, 0x80, 0xb6, 0x9a, 0x3d, 0x92, 0x11, 0x29, 0x8a, 0x02, 0xe7, 0x80,
	0x20, 0x1c, 0xf7, 0x16, 0x81, 0xe3, 0xe1, 0x7b, 0x98, 0x78, 0x5b, 0x56, 0xc7, 0xef, 0xe8, 0x1d,
	0x00, 0xc7, 0xd7, 0x4f, 0xac, 0x20, 0xc4, 0x6d, 0x23, 0x75, 0xb8, 0xe0, 0xf8, 0x7b, 0x94, 0x80,
	0xbe, 0x09, 0xa5, 0xd0, 0xf4, 0x7c, 0x4b, 0x1f, 0x3a, 0xc7, 0x4e, 0x14, 0xb2, 0x3e, 0xbd, 0x48,
	0x68, 0x1d, 0x42, 0x42, 0x4d, 0x00, 0x86, 0x19, 0xde, 0xdb, 0xbc, 0xe2, 0xfb, 0x85, 0x7b, 0x47,
	0x4e, 0x60, 0x21, 0xe0, 0x8f, 0xd8, 0x0d, 0x6a, 0x24, 0xb6, 0x37, 0xca, 0x26, 0x1b, 0xfb, 0x1b,
	0x01, 0x96, 0x71, 0x1a, 0xec, 0xd3, 0xe9, 0xbd, 0xbd, 0x93, 0x58, 0x5d, 0x88, 0x29, 0x12, 0xbb,
	0x9f, 0xc3, 0x1d, 0xd7, 0x7a, 0x1e, 0xe9, 0x47, 0x9e, 0x1f, 0xab, 0xfb, 0xac, 0xfe, 0xbc, 0x3e,
	0x50, 0x16, 0xb1, 0xb1, 0x6d, 0xcf, 0x9f, 0xb0, 0x76, 0x32, 0xf9, 0x94, 0x98, 0xae, 0x8f, 0x00,
	0x49, 0xfb, 0xfd, 0x69, 0xe7, 0x6a, 0x00, 0x1c, 0x59, 0x16, 0x05, 0x4a, 0x5e, 0x8d, 0x51, 0xd0,
	0x1f, 0x40, 0x3a, 0xb2, 0x4f, 0x49, 0xd4, 0x8b, 0x8f, 0x3e, 0x7c, 0x95, 0x37, 0x33, 0x1b, 0x57,
	0xb1, 0x66, 0xfd, 0x7f, 0xd3, 0x50, 0x18, 0xc7, 0x13, 0xad, 0x41, 0x71, 0x60, 0x85, 0x91, 0xe3,
	0x12, 0x20, 0xb3, 0x60, 0xc4, 0x49, 0xa8, 0x8a, 0xeb, 0xfa, 0xf3, 0xe8, 0xc8, 0xf3, 0x59, 0xaa,
	0xf9, 0x2b, 0x6a, 0x42, 0x96, 0x02, 0x89, 0x20, 0xf2, 0xa6, 0xe3, 0xde, 0x1f, 0xe3, 0x99, 0x1c,
	0x77, 0xa6, 0x8a, 0xfe, 0x30, 0x0e, 0xdd, 0x9b, 0xea, 0x27, 0x29, 0x0c, 0x63, 0x13, 0x0c, 0xe6,
	0x3d, 0xfc, 0xe5, 0xc7, 0xf2, 0x15, 0xab, 0xc4, 0x1f, 0xbc, 0xd2, 0x92, 0x42, 0x93, 0x32, 0xb6,
	0x55, 0x74, 0x27, 0x04, 0xf4, 0x7d, 0xb8, 0x3b, 0x0a, 0xad, 0x40, 0x1f, 0x58, 0x87, 0x8e, 0x3b,
	0x6e, 0xb5, 0x08, 0xcc, 0x68, 0x3f, 0xb6, 0x84, 0xd9, 0x2d, 0xca, 0x55, 0x39, 0xe2, 0xd0, 0x0f,
	0x20, 0x6d, 0x9c, 0x86, 0xa4, 0xad, 0x7a, 0xc5, 0xf7, 0xff, 0x6c, 0xce, 0xb7, 0xe7, 0x54, 0xac,
	0x88, 0xf5, 0x6d, 0xd3, 0x27, 0xdd, 0xf2, 0x2b, 0xf4, 0x67, 0x0f, 0x2b, 0xd6, 0xb7, 0x4d, 0xbf,
	0x51, 0x83, 0x15, 0xda, 0x81, 0x51, 0x7f, 0x8d, 0x09, 0xa8, 0x32, 0x2f, 0xbe, 0x10, 0x70, 0x79,
	0xca, 0x89, 0xf9, 0xfa, 0xdf, 0x67, 0x20, 0xdf, 0x77, 0x58, 0xfa, 0xdf, 0x6a, 0xeb, 0xf4, 0x98,
	0x43, 0xf3, 0x0d, 0x2f, 0x6a, 0x6c, 0x05, 0x0d, 0x40, 0x9c, 0x9e, 0x7b, 0xdd, 0xaa, 0x05, 0x78,
	0x70, 0x71, 0xbe, 0x3a, 0xb6, 0x3c, 0x6d, 0x41, 0xad, 0x0c, 0xcc, 0x26, 0x25, 0xd0, 0xaf, 0x8b,
	0x4f, 0xa0, 0x40, 0x66, 0x5b, 0xb1, 0x3a, 0x34, 0x6d, 0x1e, 0xf3, 0x37, 0x78, 0xc0, 0xd4, 0x7c,
	0xc8, 0x43, 0xa7, 0xc6, 0xc6, 0x30, 0x8e, 0x7b, 0xe8, 0x11, 0xd8, 0x15, 0x6f, 0x1e, 0xc3, 0xb4,
	0xdd, 0x43, 0xaf, 0x91, 0xfb, 0xea, 0x5c, 0xf8, 0xe5, 0x17, 0x82, 0x30, 0x99, 0xc7, 0x60, 0x32,
	0xda, 0x81, 0x12, 0x0b, 0x02, 0xf5, 0x28, 0x4b, 0x3c, 0xfa, 0xd6, 0xb5, 0x50, 0x98, 0x34, 0xc1,
	0x14, 0xc4, 0x76, 0xac, 0x2b, 0x6e, 0x40, 0xde, 0xf0, 0xfd, 0xf8, 0x97, 0xf2, 0xb5, 0x76, 0xf0,
	0xee, 0x24, 0x7f, 0x72, 0x18, 0x72, 0x06, 0x7d, 0xa9, 0xff, 0x6c, 0x1e, 0x16, 0x31, 0xf3, 0x89,
	0x15, 0x1e, 0x91, 0x80, 0x11, 0xcb, 0x2d, 0xc8, 0x8c, 0x2b, 0x67, 0x65, 0xa6, 0x22, 0x4e, 0xcd,
	0x0a, 0x37, 0x66, 0xf4, 0x55, 0xa2, 0xfd, 0x26, 0xa1, 0xff, 0x13, 0x28, 0x9d, 0x38, 0x41, 0x34,
	0x32, 0x86, 0x3a, 0xa6, 0xdd, 0xea, 0xfb, 0xe4, 0x9d, 0x8b, 0xf3, 0x84, 0xd2, 0x8f, 0x7f, 0x2e,
	0x08, 0xff, 0xfa, 0xab, 0x2f, 0xd3, 0xf3, 0x7f, 0x29, 0xa4, 0x44, 0x41, 0x2d, 0x32, 0x1e, 0x5e,
	0x0d, 0x03, 0xf9, 0x68, 0x74, 0xf0, 0xfa, 0x1d, 0xe7, 0xd4, 0xd6, 0x55, 0x6c, 0x05, 0xf5, 0x20,
	0x7f, 0x34, 0x3a, 0x20, 0x64, 0x92, 0xcf, 0xe2, 0xa3, 0x8f, 0x6e, 0x88, 0xd8, 0xf6, 0xe8, 0xe0,
	0xd3, 0xd1, 0x70, 0x98, 0x08, 0xda, 0xf6, 0x9c, 0x9a, 0x3b, 0x1a, 0x1d, 0x60, 0x1a, 0x52, 0x01,
	0x42, 0xdf, 0x7b, 0x46, 0x75, 0x48, 0x6e, 0x8b, 0x8f, 0x7e, 0xfb, 0xa6, 0x2c, 0x60, 0x85, 0x69,
	0x8b, 0x85, 0x90, 0x53, 0x51, 0x17, 0x0a, 0x87, 0xa3, 0xe1, 0x90, 0x9a, 0xa4, 0x15, 0xec, 0xa6,
	0xc4, 0x5e, 0xe5, 0x63, 0xfe, 0x90, 0x11, 0xd1, 0x3e, 0x94, 0x13, 0x71, 0xb9, 0xd5, 0x57, 0xdf,
	0xd2, 0xc5, 0x79, 0x52, 0x0b, 0x67, 0x49, 0x2d, 0x71, 0x12, 0x4e, 0x4e, 0xe3, 0x2e, 0x14, 0x89,
	0x13, 0xe6, 0x91, 0xe7, 0x98, 0x16, 0xca, 0x7f, 0xf9, 0x85, 0x90, 0x7f, 0xf1, 0x85, 0x30, 0x4f,
	0x6f, 0xd5, 0x9d, 0x4c, 0x7e, 0x5e, 0xcc, 0xd6, 0x3f, 0x07, 0xd4, 0x6a, 0xc6, 0x4f, 0x3a, 0xc1,
	0xcd, 0x4e, 0x0c, 0xb8, 0xc5, 0x47, 0x1f, 0x4f, 0xb9, 0x32, 0x5d, 0x2c, 0x36, 0x92, 0x16, 0xf0,
	0xae, 0x26, 0xf0, 0xad, 0xff, 0x6d, 0x1a, 0x96, 0xae, 0x1a, 0xfe, 0xbc, 0xc5, 0x2f, 0xaa, 0xc9,
	0xa0, 0x39, 0x95, 0x18, 0x34, 0x6b, 0xb0, 0x38, 0x35, 0xdb, 0xb1, 0xf8, 0xc4, 0xfb, 0xda, 0x23,
	0xce, 0xe6, 0x38, 0xb8, 0xca, 0x90, 0x4d, 0x88, 0xc9, 0x31, 0x90, 0x15, 0x22, 0x65, 0x66, 0x10,
	0x94, 0x79, 0x3d, 0x93, 0x53, 0x13, 0xa3, 0xd9, 0xf9, 0xce, 0xfc, 0x55, 0xf3, 0x1d, 0x3e, 0x67,
	0xc9, 0xc6, 0xe6, 0x2c, 0x2d, 0x28, 0x92, 0x31, 0x0e, 0xdb, 0x3d, 0x45, 0xf8, 0xbb, 0x57, 0x15,
	0x87, 0x71, 0xe8, 0xfb, 0x44, 0x54, 0x05, 0xac, 0x47, 0x9f, 0xeb, 0x9f, 0xc3, 0xc2, 0x94, 0x8b,
	0xb8, 0x97, 0xe1, 0x9b, 0xa3, 0x9d, 0x0e, 0x7f, 0x45, 0xab, 0x90, 0x1f, 0x8f, 0xab, 0x68, 0x7f,
	0x9d, 0x1b, 0xb0, 0x41, 0x55, 0x15, 0x72, 0x7e, 0xe0, 0x1c, 0x1b, 0xc1, 0x19, 0xfb, 0x44, 0xe7,
	0xaf, 0xf5, 0x9f, 0x0a, 0x50, 0xd6, 0x46, 0xae, 0x6b, 0x0d, 0xfb, 0x6c, 0x34, 0xdb, 0x80, 0x0c,
	0x01, 0xbb, 0x70, 0xcb, 0x89, 0x49, 0x02, 0xec, 0x2a, 0xd1, 0x45, 0xbf, 0x0f, 0xb9, 0x88, 0x18,
	0x0d, 0xd9, 0x55, 0x5a, 0xbf, 0x2e, 0x03, 0x74, 0x6d, 0x12, 0x7c, 0xae, 0x52, 0x0f, 0x60, 0x41,
	0x99, 0x8c, 0xae, 0x59, 0xbd, 0x2e, 0x9c, 0xb8, 0x56, 0x44, 0x06, 0xdb, 0xac, 0x71, 0x7c, 0xff,
	0xda, 0xa4, 0xfe, 0x68, 0x14, 0x58, 0x7b, 0xae, 0x15, 0x61, 0x6d, 0x7c, 0xa0, 0x4f, 0xd8, 0x73,
	0xe3, 0x0e, 0x14, 0xb1, 0x01, 0x7e, 0xee, 0x70, 0x4b, 0x21, 0xb0, 0x11, 0xea, 0x3f, 0x0b, 0x50,
	0x4e, 0x28, 0x92, 0xaf, 0x2c, 0x2c, 0xfc, 0xc6, 0xcd, 0x05, 0x59, 0x93, 0x6d, 0x08, 0x3d, 0x81,
	0x32, 0x7e, 0x75, 0x5c, 0x9b, 0x7d, 0x66, 0xa6, 0xc8, 0xb5, 0x71, 0xed, 0x34, 0xa4, 0x47, 0x85,
	0x27, 0xdf, 0x98, 0x25, 0x3f, 0x46, 0xa9, 0xff, 0x4a, 0x00, 0x98, 0x84, 0x10, 0xed, 0x00, 0xb0,
	0xd1, 0x15, 0xef, 0x84, 0x67, 0xbb, 0x30, 0x02, 0x3a, 0xaa, 0xd3, 0x1c, 0xcb, 0x72, 0xec, 0x4d,
	0xb4, 0xc7, 0x38, 0x48, 0xbd, 0x01, 0x0e, 0x58, 0x3b, 0x95, 0x7e, 0x1b, 0xed, 0x54, 0xfd, 0x3f,
	0x05, 0x58, 0x68, 0xe2, 0xe6, 0xb0, 0xe7, 0x0d, 0x1d, 0x93, 0x76, 0x08, 0x9f, 0xd0, 0x7e, 0xf5,
	0x26, 0x44, 0xec, 0xf7, 0x27, 0x3a, 0xbc, 0x55, 0xfd, 0x08, 0x96, 0x7d, 0x2b, 0x38, 0x76, 0x42,
	0xfc, 0xc5, 0x17, 0xea, 0xbe, 0xe7, 0x8f, 0x86, 0xe4, 0x83, 0x65, 0x9e, 0x9c, 0x90, 0xa5, 0x18,
	0xb3, 0xc7, 0x79, 0xe8, 0xbb, 0xb0, 0x44, 0xfb, 0xd3, 0x71, 0xdf, 0x64, 0x05, 0x81, 0xc7, 0x67,
	0x9c, 0x88, 0xf0, 0x78, 0x97, 0x24, 0x63, 0x4e, 0x63, 0x05, 0x80, 0x6a, 0x90, 0x8e, 0x01, 0x97,
	0xfa, 0x54, 0x0c, 0x76, 0x7f, 0x9a, 0x82, 0x72, 0xc2, 0x3b, 0xb4, 0x09, 0x4b, 0x6c, 0x9a, 0xa6,
	0x1b, 0xa7, 0xa1, 0x7e, 0xe2, 0x9b, 0x3a, 0x3b, 0x8e, 0xd8, 0xab, 0x45, 0xc6, 0x93, 0x4e, 0xc3,
	0x3d, 0xdf, 0x24, 0x37, 0xfd, 0xa7, 0xb0, 0x46, 0xfc, 0x74, 0x6d, 0x3d, 0xbe, 0x9f, 0x84, 0x32,
	0xfd, 0x01, 0xea, 0x01, 0x93, 0xeb, 0x4d, 0xc4, 0x62, 0x76, 0xa6, 0x16, 0x8e, 0xec, 0x53, 0xaa,
	0x9b, 0x9e, 0x5e, 0x58, 0xb3, 0x4f, 0x6f, 0x5a, 0x78, 0xac, 0x9c, 0x79, 0xc5, 0xc2, 0xcc, 0x4e,
	0x5d, 0x87, 0x15, 0x72, 0xf2, 0x54, 0xf6, 0x4d, 0x4f, 0x8a, 0x2a, 0xe9, 0x25, 0xef, 0x42, 0x8e,
	0xdc, 0xd8, 0x81, 0xcd, 0x6a, 0x5d, 0x96, 0x60, 0xcb, 0x46, 0x1f, 0x00, 0xe2, 0x8d, 0x10, 0xff,
	0xc9, 0x2b, 0xb0, 0xd9, 0x15, 0x23, 0x32, 0x0e, 0x3b, 0x71, 0xaa, 0x5d, 0x7f, 0x29, 0x40, 0x29,
	0xde, 0xba, 0xe2, 0x5b, 0x69, 0xfc, 0x23, 0x1f, 0x31, 0xcb, 0x7e, 0xfe, 0xb9, 0x0f, 0x05, 0xdb,
	0xf4, 0xc9, 0x7c, 0x3e, 0x64, 0x31, 0xcb, 0xdb, 0xa6, 0xff, 0x14, 0xbf, 0xe3, 0x66, 0xd9, 0xc0,
	0x6e, 0xea, 0x81, 0x4d, 0x9b, 0xe5, 0x34, 0x01, 0xdd, 0xc6, 0x2b, 0xcb, 0xd0, 0xcc, 0x9e, 0xd4,
	0x22, 0x31, 0xa2, 0xda, 0xac, 0x59, 0x66, 0xe0, 0x18, 0x3a, 0xee, 0xb3, 0x5b, 0xfd, 0xdc, 0x57,
	0xbe, 0x38, 0x8f, 0xa9, 0xa8, 0x05, 0xf2, 0xdc, 0x71, 0xdc, 0x67, 0xeb, 0x3f, 0x89, 0xed, 0x92,
	0x0d, 0x17, 0x56, 0x7b, 0x6a, 0x77, 0xaf, 0xdd, 0x92, 0x55, 0x5d, 0xfb, 0xac, 0x27, 0xeb, 0xbb,
	0x4a, 0xbf, 0x27, 0x37, 0xdb, 0x9f, 0xb6, 0xe5, 0x96, 0x38, 0x87, 0x96, 0x61, 0x31, 0xc9, 0x96,
	0xf6, 0xfb, 0xa2, 0x30, 0x4b, 0xde, 0x6a, 0xf6, 0xc4, 0x14, 0xba, 0x0b, 0x77, 0xa6, 0xa4, 0x9f,
	0xee, 0xaa, 0xb2, 0x98, 0x46, 0xf7, 0x60, 0x25, 0xc9, 0xd8, 0xeb, 0x76, 0x34, 0x59, 0x55, 0x25,
	0x31, 0xb3, 0xae, 0x42, 0x09, 0x67, 0x18, 0xd7, 0x2d, 0xe2, 0xd1, 0x2a, 0x2c, 0xf7, 0xdb, 0x9a,
	0x7c, 0x95, 0x37, 0x22, 0x94, 0x26, 0x2c, 0x55, 0xa6, 0x8e, 0x4c, 0x28, 0xd2, 0x7e, 0x5f, 0xd7,
	0xb6, 0xf6, 0xc5, 0xd4, 0xfa, 0x3f, 0x0a, 0x70, 0xe7, 0x8a, 0xd9, 0x1b, 0xf6, 0x43, 0xed, 0xee,
	0x62, 0x79, 0xa9, 0xd1, 0x91, 0xf5, 0xbe, 0x26, 0x69, 0xb2, 0xae, 0x74, 0x15, 0x59, 0x9c, 0xc3,
	0x91, 0x98, 0xe5, 0xf5, 0x64, 0xa5, 0xd5, 0x56, 0xb6, 0x44, 0x01, 0x7d, 0x03, 0xee, 0xcf, 0xb2,
	0xa5, 0x3d, 0xa9, 0xdd, 0xc1, 0xef, 0x62, 0x0a, 0xd5, 0xe0, 0xde, 0xac, 0x40, 0x4b, 0xee, 0xc8,
	0x1a, 0x36, 0x90, 0xbe, 0xda, 0x3e, 0xe1, 0xcb, 0x2d, 0x31, 0xb3, 0xde, 0x00, 0x34, 0x3b, 0x3a,
	0xc5, 0x11, 0x8d, 0x2b, 0x29, 0xb2, 0xb6, 0xdf, 0x55, 0x1f, 0x8b, 0x73, 0xe8, 0x0e, 0x2c, 0xc4,
	0x19, 0x78, 0xdb, 0xc2, 0xfa, 0x5f, 0x09, 0x20, 0x92, 0xe2, 0x17, 0xff, 0xb1, 0x7a, 0x19, 0x16,
	0x99, 0x1a, 0x8d, 0x12, 0xdb, 0xee, 0x2a, 0x2c, 0x27, 0xc8, 0xdb, 0xbb, 0x0d, 0x7d, 0x4f, 0x91,
	0x35, 0x51, 0x40, 0xf7, 0xe1, 0x6e, 0x82, 0xd5, 0xef, 0x75, 0x1f, 0xcb, 0x94, 0x99, 0x42, 0x0f,
	0xa0, 0x9a, 0x64, 0xca, 0xea, 0x5e, 0xbb, 0x29, 0xeb, 0x7b, 0xbd, 0x26, 0x4d, 0xf4, 0x55, 0xaa,
	0xbd, 0xa6, 0x98, 0x59, 0x57, 0x60, 0x71, 0xe6, 0xa7, 0x4a, 0x54, 0x84, 0x5c, 0x77, 0x57, 0xeb,
	0xb7, 0x5b, 0xd8, 0x27, 0x80, 0x6c, 0x5b, 0x21, 0xcf, 0x02, 0x2a, 0x41, 0x1e, 0x9b, 0xe9, 0x74,
	0xa5, 0x96, 0x98, 0x42, 0x08, 0x2a, 0x4a, 0x57, 0xd3, 0xa5, 0x5e, 0xaf, 0xd3, 0x6e, 0x92, 0x80,
	0xa7, 0xd7, 0xff, 0x9c, 0x27, 0x39, 0x39, 0x71, 0xc1, 0xb2, 0x6d, 0x65, 0x4f, 0xea, 0xb4, 0x5b,
	0x7a, 0xbf, 0xbb, 0xab, 0x36, 0xb1, 0xe5, 0x22, 0xe4, 0x5a, 0xf2, 0xa7, 0xd2, 0x6e, 0x07, 0xef,
	0x2f, 0x0f, 0x99, 0xdd, 0xbe, 0xac, 0x8a, 0x29, 0x4c, 0xde, 0x55, 0x1e, 0x2b, 0xdd, 0x7d, 0x45,
	0x4c, 0xa3, 0x3a, 0xd4, 0xf6, 0xda, 0xaa, 0xb6, 0x2b, 0x75, 0x78, 0x9c, 0xf5, 0x2d, 0x49, 0x93,
	0xf7, 0xa5, 0xcf, 0xb8, 0x9d, 0x0c, 0x01, 0x27, 0x79, 0xd6, 0xa7, 0xdc, 0x99, 0x5f, 0xff, 0x17,
	0x81, 0x65, 0x30, 0x31, 0xbc, 0xc1, 0x98, 0x95, 0x9a, 0x5a, 0x7b, 0x8f, 0x65, 0x5c, 0x9c, 0x43,
	0x8b, 0x50, 0x1e, 0xfb, 0x47, 0x48, 0x02, 0xaa, 0xc2, 0x12, 0xc7, 0x62, 0xc2, 0x6a, 0x0a, 0xe7,
	0x99, 0x72, 0x1a, 0x1d, 0xa9, 0xf9, 0x78, 0xbb, 0x8b, 0x77, 0x4e, 0x50, 0x4f, 0x88, 0xbb, 0xca,
	0x04, 0x81, 0x19, 0x6c, 0x38, 0x89, 0xda, 0x79, 0x1c, 0x8b, 0x29, 0x20, 0x66, 0x27, 0x62, 0x1c,
	0x7c, 0xb9, 0xf5, 0xff, 0x4b, 0xc1, 0xd2, 0x55, 0xe3, 0x22, 0x0c, 0x85, 0x6b, 0x62, 0x22, 0xce,
	0xa1, 0x0a, 0x00, 0x06, 0x85, 0xde, 0xe9, 0x36, 0xa5, 0x0e, 0x4d, 0x59, 0x5b, 0xd1, 0x64, 0x95,
	0x02, 0x65, 0x19, 0x16, 0xb9, 0x2a, 0xd9, 0x91, 0xa4, 0x34, 0xb1, 0xef, 0x79, 0xc8, 0x10, 0x04,
	0x66, 0x70, 0x64, 0x88, 0x7a, 0x4f, 0x96, 0x55, 0xea, 0xed, 0x7b, 0xb0, 0x36, 0xbd, 0x1a, 0x87,
	0x97, 0xac, 0xb4, 0x7a, 0xdd, 0xb6, 0xa2, 0x89, 0x59, 0xb4, 0x06, 0x0f, 0x14, 0xf9, 0x8f, 0x34,
	0x7d, 0xbb, 0xdb, 0xe3, 0x88, 0x4e, 0x04, 0x2d, 0x87, 0x2d, 0x63, 0xdc, 0x34, 0xa4, 0x0e, 0x5e,
	0x54, 0x15, 0xf3, 0x68, 0x01, 0x8a, 0x7b, 0xbd, 0xe6, 0xf8, 0xfc, 0x14, 0x38, 0x81, 0xaf, 0x0d,
	0x18, 0xb9, 0xd4, 0x79, 0xa9, 0xa3, 0x63, 0x65, 0x7d, 0xac, 0x5d, 0xa4, 0x1b, 0xeb, 0x6b, 0x64,
	0x07, 0x25, 0x6c, 0x9d, 0x48, 0x36, 0xbb, 0x8a, 0x22, 0x37, 0x35, 0xb1, 0x8c, 0x96, 0x40, 0xe4,
	0x1b, 0x1f, 0x87, 0xa7, 0x82, 0xb2, 0x90, 0x6a, 0xf7, 0xc4, 0x05, 0x12, 0xa6, 0x9e, 0xa2, 0x6b,
	0xbb, 0x8a, 0x22, 0x77, 0x44, 0x11, 0xe7, 0x44, 0xdb, 0xda, 0xd7, 0x25, 0x4d, 0x93, 0x9a, 0xdb,
	0x4f, 0x64, 0x45, 0x13, 0x17, 0xd7, 0x1b, 0xb0, 0x30, 0x35, 0xe4, 0xc0, 0x99, 0x6f, 0x2b, 0x5b,
	0xaa, 0xdc, 0xef, 0xc7, 0x42, 0x4e, 0xbc, 0xa4, 0x44, 0x39, 0xc9, 0x13, 0xd6, 0x7f, 0x2a, 0x40,
	0x29, 0x3e, 0x43, 0xc6, 0xc5, 0x63, 0xab, 0xd9, 0xd3, 0x59, 0x9d, 0x88, 0x9d, 0xfd, 0x7b, 0xb0,
	0x32, 0xc5, 0xd0, 0x54, 0x49, 0xe9, 0xb7, 0xf1, 0xe1, 0x58, 0x85, 0xe5, 0x29, 0x5e, 0x7f, 0xb7,
	0x41, 0x33, 0x7a, 0x05, 0x4b, 0x93, 0xb4, 0x36, 0x3e, 0xf7, 0x2b, 0x64, 0xb8, 0x1e, 0x67, 0x35,
	0xb6, 0x7a, 0x62, 0x66, 0xfd, 0x29, 0x2c, 0x4c, 0x0d, 0x5d, 0xc6, 0x25, 0x5b, 0xea, 0xf5, 0xa6,
	0xea, 0x51, 0x82, 0x2c, 0xf5, 0x7a, 0x7d, 0x4d, 0x6a, 0x3e, 0x8e, 0x15, 0x79, 0xce, 0x7a, 0x22,
	0xf7, 0xb7, 0xc5, 0xd4, 0xfa, 0x10, 0xc4, 0xe9, 0xc6, 0x17, 0x95, 0xa1, 0xc0, 0xd2, 0xc2, 0x2f,
	0x8c, 0x56, 0xbb, 0x3f, 0xa1, 0xd0, 0x9b, 0x8b, 0xe6, 0x5c, 0x6f, 0x2b, 0x6d, 0xad, 0x2d, 0x61,
	0x72, 0x1a, 0x63, 0x8a, 0x93, 0xaf, 0x3c, 0x88, 0x99, 0xc6, 0x5f, 0x08, 0x5f, 0xfe, 0x60, 0xee,
	0xc5, 0xd7, 0xb5, 0xb9, 0xaf, 0xbe, 0xae, 0xcd, 0xfd, 0xfa, 0xeb, 0x9a, 0xf0, 0xe3, 0xcb, 0x9a,
	0xf0, 0x77, 0x97, 0x35, 0xe1, 0x3f, 0x2e, 0x6b, 0xc2, 0x8b, 0xcb, 0x9a, 0xf0, 0xd5, 0x65, 0x4d,
	0xf8, 0xc5, 0x65, 0x4d, 0xf8, 0xe5, 0x65, 0x6d, 0xee, 0xd7, 0x97, 0x35, 0xe1, 0x27, 0x2f, 0x6b,
	0x73, 0x5f, 0xbe, 0xac, 0x09, 0x2f, 0x5e, 0xd6, 0xe6, 0xbe, 0x7a, 0x59, 0x9b, 0x7b, 0xda, 0xb1,
	0x3d, 0xff, 0x99, 0xbd, 0x71, 0xe2, 0x0d, 0x23, 0x2b, 0x08, 0x8c, 0x8d, 0x51, 0xb8, 0x49, 0x1e,
	0x0e, 0xbd, 0xe0, 0xf8, 0x43, 0xde, 0x2a, 0x7e, 0xc8, 0xd9, 0x9b, 0xfe, 0x81, 0xed, 0x6d, 0x5a,
	0xcf, 0x23, 0xfe, 0xd7, 0xb4, 0xe4, 0x3f, 0xf5, 0x0e, 0xb2, 0xe4, 0xaf, 0x63, 0x1f, 0xfd, 0x7f,
	0x00, 0x00, 0x00, 0xff, 0xff, 0xbd, 0x60, 0xfb, 0xea, 0xca, 0x27, 0x00, 0x00,
}

func (x ProviderType) String() string {
	s, ok := ProviderType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SiteEnumType) String() string {
	s, ok := SiteEnumType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RouteTableStateEnum) String() string {
	s, ok := RouteTableStateEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RouteTableTypeEnum) String() string {
	s, ok := RouteTableTypeEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CloudNetworkType) String() string {
	s, ok := CloudNetworkType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x InterfaceTypeEnum) String() string {
	s, ok := InterfaceTypeEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RouteSourceTypeEnum) String() string {
	s, ok := RouteSourceTypeEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RouteStateTypeEnum) String() string {
	s, ok := RouteStateTypeEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RouteNextHopTypeEnum) String() string {
	s, ok := RouteNextHopTypeEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x GatewayTypeEnum) String() string {
	s, ok := GatewayTypeEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x GCPRouteType) String() string {
	s, ok := GCPRouteType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SiteAppTypeEnum) String() string {
	s, ok := SiteAppTypeEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PeeringStateEnum) String() string {
	s, ok := PeeringStateEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *MetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetaType)
	if !ok {
		that2, ok := that.(MetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Creds) != len(that1.Creds) {
		return false
	}
	for i := range this.Creds {
		if !this.Creds[i].Equal(that1.Creds[i]) {
			return false
		}
	}
	if this.RawJson != that1.RawJson {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if this.OwnerId != that1.OwnerId {
		return false
	}
	if this.ProviderType != that1.ProviderType {
		return false
	}
	return true
}
func (this *NetworkType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkType)
	if !ok {
		that2, ok := that.(NetworkType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Region) != len(that1.Region) {
		return false
	}
	for i := range this.Region {
		if !this.Region[i].Equal(that1.Region[i]) {
			return false
		}
	}
	if len(this.CidrV4) != len(that1.CidrV4) {
		return false
	}
	for i := range this.CidrV4 {
		if this.CidrV4[i] != that1.CidrV4[i] {
			return false
		}
	}
	if len(this.CidrV6) != len(that1.CidrV6) {
		return false
	}
	for i := range this.CidrV6 {
		if this.CidrV6[i] != that1.CidrV6[i] {
			return false
		}
	}
	if len(this.NetworkPeers) != len(that1.NetworkPeers) {
		return false
	}
	for i := range this.NetworkPeers {
		if !this.NetworkPeers[i].Equal(that1.NetworkPeers[i]) {
			return false
		}
	}
	if len(this.LoadBalancer) != len(that1.LoadBalancer) {
		return false
	}
	for i := range this.LoadBalancer {
		if !this.LoadBalancer[i].Equal(that1.LoadBalancer[i]) {
			return false
		}
	}
	return true
}
func (this *LoadBalancer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoadBalancer)
	if !ok {
		that2, ok := that.(LoadBalancer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *SubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubnetType)
	if !ok {
		that2, ok := that.(SubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Network) != len(that1.Network) {
		return false
	}
	for i := range this.Network {
		if !this.Network[i].Equal(that1.Network[i]) {
			return false
		}
	}
	if len(this.Region) != len(that1.Region) {
		return false
	}
	for i := range this.Region {
		if !this.Region[i].Equal(that1.Region[i]) {
			return false
		}
	}
	if this.AvailabilityZone != that1.AvailabilityZone {
		return false
	}
	if len(this.CidrV4) != len(that1.CidrV4) {
		return false
	}
	for i := range this.CidrV4 {
		if this.CidrV4[i] != that1.CidrV4[i] {
			return false
		}
	}
	if len(this.CidrV6) != len(that1.CidrV6) {
		return false
	}
	for i := range this.CidrV6 {
		if this.CidrV6[i] != that1.CidrV6[i] {
			return false
		}
	}
	if this.InterfaceType != that1.InterfaceType {
		return false
	}
	return true
}
func (this *InstanceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InstanceType)
	if !ok {
		that2, ok := that.(InstanceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Interfaces) != len(that1.Interfaces) {
		return false
	}
	for i := range this.Interfaces {
		if !this.Interfaces[i].Equal(that1.Interfaces[i]) {
			return false
		}
	}
	if this.Architecture != that1.Architecture {
		return false
	}
	if this.Cpu != that1.Cpu {
		return false
	}
	if this.InstanceType != that1.InstanceType {
		return false
	}
	if this.Platform != that1.Platform {
		return false
	}
	if this.PrivateAddress != that1.PrivateAddress {
		return false
	}
	if this.PublicAddress != that1.PublicAddress {
		return false
	}
	if this.PrivateDnsName != that1.PrivateDnsName {
		return false
	}
	if this.PublicDnsName != that1.PublicDnsName {
		return false
	}
	if len(this.SecurityGroup) != len(that1.SecurityGroup) {
		return false
	}
	for i := range this.SecurityGroup {
		if this.SecurityGroup[i] != that1.SecurityGroup[i] {
			return false
		}
	}
	if this.AvailabilityZone != that1.AvailabilityZone {
		return false
	}
	if this.F5XcNodeName != that1.F5XcNodeName {
		return false
	}
	return true
}
func (this *AWSTGWAttachment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSTGWAttachment)
	if !ok {
		that2, ok := that.(AWSTGWAttachment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.ResourceType != that1.ResourceType {
		return false
	}
	if this.ResourceId != that1.ResourceId {
		return false
	}
	if this.ResourceName != that1.ResourceName {
		return false
	}
	if this.Cidr != that1.Cidr {
		return false
	}
	if this.AssociatedRouteTableId != that1.AssociatedRouteTableId {
		return false
	}
	if this.AssociationState != that1.AssociationState {
		return false
	}
	if len(this.CloudConnect) != len(that1.CloudConnect) {
		return false
	}
	for i := range this.CloudConnect {
		if !this.CloudConnect[i].Equal(that1.CloudConnect[i]) {
			return false
		}
	}
	if len(this.Segment) != len(that1.Segment) {
		return false
	}
	for i := range this.Segment {
		if !this.Segment[i].Equal(that1.Segment[i]) {
			return false
		}
	}
	return true
}
func (this *TransitGatewayType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TransitGatewayType)
	if !ok {
		that2, ok := that.(TransitGatewayType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Network) != len(that1.Network) {
		return false
	}
	for i := range this.Network {
		if !this.Network[i].Equal(that1.Network[i]) {
			return false
		}
	}
	if this.AutoAcceptSharedAttachments != that1.AutoAcceptSharedAttachments {
		return false
	}
	if this.DnsSupport != that1.DnsSupport {
		return false
	}
	if this.VpnEcmpSupport != that1.VpnEcmpSupport {
		return false
	}
	if len(this.Attachments) != len(that1.Attachments) {
		return false
	}
	for i := range this.Attachments {
		if !this.Attachments[i].Equal(that1.Attachments[i]) {
			return false
		}
	}
	return true
}
func (this *RouteTableType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteTableType)
	if !ok {
		that2, ok := that.(RouteTableType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Subnet) != len(that1.Subnet) {
		return false
	}
	for i := range this.Subnet {
		if !this.Subnet[i].Equal(that1.Subnet[i]) {
			return false
		}
	}
	if len(this.Network) != len(that1.Network) {
		return false
	}
	for i := range this.Network {
		if !this.Network[i].Equal(that1.Network[i]) {
			return false
		}
	}
	if len(this.TransitGateway) != len(that1.TransitGateway) {
		return false
	}
	for i := range this.TransitGateway {
		if !this.TransitGateway[i].Equal(that1.TransitGateway[i]) {
			return false
		}
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	if this.RouteTableType != that1.RouteTableType {
		return false
	}
	if len(this.ImplicitSubnet) != len(that1.ImplicitSubnet) {
		return false
	}
	for i := range this.ImplicitSubnet {
		if !this.ImplicitSubnet[i].Equal(that1.ImplicitSubnet[i]) {
			return false
		}
	}
	if len(this.ExplicitSubnet) != len(that1.ExplicitSubnet) {
		return false
	}
	for i := range this.ExplicitSubnet {
		if !this.ExplicitSubnet[i].Equal(that1.ExplicitSubnet[i]) {
			return false
		}
	}
	if this.RouteTableState != that1.RouteTableState {
		return false
	}
	if len(this.Associations) != len(that1.Associations) {
		return false
	}
	for i := range this.Associations {
		if !this.Associations[i].Equal(that1.Associations[i]) {
			return false
		}
	}
	if len(this.Propagations) != len(that1.Propagations) {
		return false
	}
	for i := range this.Propagations {
		if !this.Propagations[i].Equal(that1.Propagations[i]) {
			return false
		}
	}
	return true
}
func (this *AWSTGWAttachmentMetaData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSTGWAttachmentMetaData)
	if !ok {
		that2, ok := that.(AWSTGWAttachmentMetaData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.ResourceType != that1.ResourceType {
		return false
	}
	if this.ResourceId != that1.ResourceId {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.ResourceName != that1.ResourceName {
		return false
	}
	return true
}
func (this *GCPRouteAttributes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPRouteAttributes)
	if !ok {
		that2, ok := that.(GCPRouteAttributes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if this.IpVersion != that1.IpVersion {
		return false
	}
	if len(this.ScopeLimits) != len(that1.ScopeLimits) {
		return false
	}
	for i := range this.ScopeLimits {
		if this.ScopeLimits[i] != that1.ScopeLimits[i] {
			return false
		}
	}
	if this.RouteType != that1.RouteType {
		return false
	}
	if this.RouteName != that1.RouteName {
		return false
	}
	return true
}
func (this *AWSTgwRouteAttributes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSTgwRouteAttributes)
	if !ok {
		that2, ok := that.(AWSTgwRouteAttributes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RouteType != that1.RouteType {
		return false
	}
	if len(this.NextHopAttachment) != len(that1.NextHopAttachment) {
		return false
	}
	for i := range this.NextHopAttachment {
		if !this.NextHopAttachment[i].Equal(that1.NextHopAttachment[i]) {
			return false
		}
	}
	return true
}
func (this *AWSRouteAttributes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSRouteAttributes)
	if !ok {
		that2, ok := that.(AWSRouteAttributes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Propagated != that1.Propagated {
		return false
	}
	if !this.Tgw.Equal(that1.Tgw) {
		return false
	}
	return true
}
func (this *RouteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteType)
	if !ok {
		that2, ok := that.(RouteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Destination != that1.Destination {
		return false
	}
	if this.Nexthop != that1.Nexthop {
		return false
	}
	if this.Source != that1.Source {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.NextHopType != that1.NextHopType {
		return false
	}
	if this.UserDefinedRouteName != that1.UserDefinedRouteName {
		return false
	}
	if that1.CloudRouteAttributes == nil {
		if this.CloudRouteAttributes != nil {
			return false
		}
	} else if this.CloudRouteAttributes == nil {
		return false
	} else if !this.CloudRouteAttributes.Equal(that1.CloudRouteAttributes) {
		return false
	}
	return true
}
func (this *RouteType_Aws) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteType_Aws)
	if !ok {
		that2, ok := that.(RouteType_Aws)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Aws.Equal(that1.Aws) {
		return false
	}
	return true
}
func (this *RouteType_Gcp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteType_Gcp)
	if !ok {
		that2, ok := that.(RouteType_Gcp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Gcp.Equal(that1.Gcp) {
		return false
	}
	return true
}
func (this *SiteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteType)
	if !ok {
		that2, ok := that.(SiteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Network) != len(that1.Network) {
		return false
	}
	for i := range this.Network {
		if !this.Network[i].Equal(that1.Network[i]) {
			return false
		}
	}
	if len(this.Tgw) != len(that1.Tgw) {
		return false
	}
	for i := range this.Tgw {
		if !this.Tgw[i].Equal(that1.Tgw[i]) {
			return false
		}
	}
	if len(this.DcClusterGroup) != len(that1.DcClusterGroup) {
		return false
	}
	for i := range this.DcClusterGroup {
		if !this.DcClusterGroup[i].Equal(that1.DcClusterGroup[i]) {
			return false
		}
	}
	if this.SiteType != that1.SiteType {
		return false
	}
	if !this.ProviderInfo.Equal(that1.ProviderInfo) {
		return false
	}
	if this.GatewayType != that1.GatewayType {
		return false
	}
	if this.AppType != that1.AppType {
		return false
	}
	return true
}
func (this *SiteMeshGroupType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteMeshGroupType)
	if !ok {
		that2, ok := that.(SiteMeshGroupType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.SiteType != that1.SiteType {
		return false
	}
	if len(this.VirtualSite) != len(that1.VirtualSite) {
		return false
	}
	for i := range this.VirtualSite {
		if !this.VirtualSite[i].Equal(that1.VirtualSite[i]) {
			return false
		}
	}
	if len(this.Hub) != len(that1.Hub) {
		return false
	}
	for i := range this.Hub {
		if !this.Hub[i].Equal(that1.Hub[i]) {
			return false
		}
	}
	if that1.MeshChoice == nil {
		if this.MeshChoice != nil {
			return false
		}
	} else if this.MeshChoice == nil {
		return false
	} else if !this.MeshChoice.Equal(that1.MeshChoice) {
		return false
	}
	if len(this.TopologySite) != len(that1.TopologySite) {
		return false
	}
	for i := range this.TopologySite {
		if !this.TopologySite[i].Equal(that1.TopologySite[i]) {
			return false
		}
	}
	return true
}
func (this *SiteMeshGroupType_HubMesh) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteMeshGroupType_HubMesh)
	if !ok {
		that2, ok := that.(SiteMeshGroupType_HubMesh)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HubMesh.Equal(that1.HubMesh) {
		return false
	}
	return true
}
func (this *SiteMeshGroupType_SpokeMesh) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteMeshGroupType_SpokeMesh)
	if !ok {
		that2, ok := that.(SiteMeshGroupType_SpokeMesh)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SpokeMesh.Equal(that1.SpokeMesh) {
		return false
	}
	return true
}
func (this *SiteMeshGroupType_FullMesh) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteMeshGroupType_FullMesh)
	if !ok {
		that2, ok := that.(SiteMeshGroupType_FullMesh)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FullMesh.Equal(that1.FullMesh) {
		return false
	}
	return true
}
func (this *DCClusterGroupType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DCClusterGroupType)
	if !ok {
		that2, ok := that.(DCClusterGroupType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *NetworkInterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkInterfaceType)
	if !ok {
		that2, ok := that.(NetworkInterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Subnet) != len(that1.Subnet) {
		return false
	}
	for i := range this.Subnet {
		if !this.Subnet[i].Equal(that1.Subnet[i]) {
			return false
		}
	}
	if this.Status != that1.Status {
		return false
	}
	if len(this.PrivateAddresses) != len(that1.PrivateAddresses) {
		return false
	}
	for i := range this.PrivateAddresses {
		if !this.PrivateAddresses[i].Equal(that1.PrivateAddresses[i]) {
			return false
		}
	}
	if len(this.PublicAddress) != len(that1.PublicAddress) {
		return false
	}
	for i := range this.PublicAddress {
		if !this.PublicAddress[i].Equal(that1.PublicAddress[i]) {
			return false
		}
	}
	if len(this.SecurityGroup) != len(that1.SecurityGroup) {
		return false
	}
	for i := range this.SecurityGroup {
		if this.SecurityGroup[i] != that1.SecurityGroup[i] {
			return false
		}
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.F5XcStatus.Equal(that1.F5XcStatus) {
		return false
	}
	return true
}
func (this *AddressInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddressInfoType)
	if !ok {
		that2, ok := that.(AddressInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.DnsName != that1.DnsName {
		return false
	}
	if this.Primary != that1.Primary {
		return false
	}
	return true
}
func (this *TunnelSetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelSetType)
	if !ok {
		that2, ok := that.(TunnelSetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Site) != len(that1.Site) {
		return false
	}
	for i := range this.Site {
		if !this.Site[i].Equal(that1.Site[i]) {
			return false
		}
	}
	if len(this.Tunnels) != len(that1.Tunnels) {
		return false
	}
	for i := range this.Tunnels {
		if !this.Tunnels[i].Equal(that1.Tunnels[i]) {
			return false
		}
	}
	return true
}
func (this *NetworkPeerType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPeerType)
	if !ok {
		that2, ok := that.(NetworkPeerType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PeerChoice == nil {
		if this.PeerChoice != nil {
			return false
		}
	} else if this.PeerChoice == nil {
		return false
	} else if !this.PeerChoice.Equal(that1.PeerChoice) {
		return false
	}
	return true
}
func (this *NetworkPeerType_VnetPeer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPeerType_VnetPeer)
	if !ok {
		that2, ok := that.(NetworkPeerType_VnetPeer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VnetPeer.Equal(that1.VnetPeer) {
		return false
	}
	return true
}
func (this *AzureVnetPeer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetPeer)
	if !ok {
		that2, ok := that.(AzureVnetPeer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.PeerNetwork) != len(that1.PeerNetwork) {
		return false
	}
	for i := range this.PeerNetwork {
		if !this.PeerNetwork[i].Equal(that1.PeerNetwork[i]) {
			return false
		}
	}
	if this.PeeringState != that1.PeeringState {
		return false
	}
	return true
}
func (this *TunnelType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelType)
	if !ok {
		that2, ok := that.(TunnelType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Connection.Equal(that1.Connection) {
		return false
	}
	if len(this.Site) != len(that1.Site) {
		return false
	}
	for i := range this.Site {
		if !this.Site[i].Equal(that1.Site[i]) {
			return false
		}
	}
	if len(this.Tgw) != len(that1.Tgw) {
		return false
	}
	for i := range this.Tgw {
		if !this.Tgw[i].Equal(that1.Tgw[i]) {
			return false
		}
	}
	return true
}
func (this *CloudPolicyType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudPolicyType)
	if !ok {
		that2, ok := that.(CloudPolicyType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.CloudType == nil {
		if this.CloudType != nil {
			return false
		}
	} else if this.CloudType == nil {
		return false
	} else if !this.CloudType.Equal(that1.CloudType) {
		return false
	}
	if this.PermissionsPopulated != that1.PermissionsPopulated {
		return false
	}
	if this.CloudProviderError != that1.CloudProviderError {
		return false
	}
	return true
}
func (this *CloudPolicyType_Aws) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudPolicyType_Aws)
	if !ok {
		that2, ok := that.(CloudPolicyType_Aws)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Aws.Equal(that1.Aws) {
		return false
	}
	return true
}
func (this *AWSPolicyType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSPolicyType)
	if !ok {
		that2, ok := that.(AWSPolicyType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SupportAwsVpcSite != that1.SupportAwsVpcSite {
		return false
	}
	if len(this.MissingPermissionsAwsVpcSite) != len(that1.MissingPermissionsAwsVpcSite) {
		return false
	}
	for i := range this.MissingPermissionsAwsVpcSite {
		if this.MissingPermissionsAwsVpcSite[i] != that1.MissingPermissionsAwsVpcSite[i] {
			return false
		}
	}
	if this.SupportAwsTgwSite != that1.SupportAwsTgwSite {
		return false
	}
	if len(this.MissingPermissionsAwsTgwSite) != len(that1.MissingPermissionsAwsTgwSite) {
		return false
	}
	for i := range this.MissingPermissionsAwsTgwSite {
		if this.MissingPermissionsAwsTgwSite[i] != that1.MissingPermissionsAwsTgwSite[i] {
			return false
		}
	}
	return true
}
func (this *AzureResourceGroupInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureResourceGroupInfo)
	if !ok {
		that2, ok := that.(AzureResourceGroupInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SiteRg != that1.SiteRg {
		return false
	}
	if this.VirtualNetworkRg != that1.VirtualNetworkRg {
		return false
	}
	return true
}
func (this *ProviderInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProviderInfo)
	if !ok {
		that2, ok := that.(ProviderInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if len(this.GcpZones) != len(that1.GcpZones) {
		return false
	}
	for i := range this.GcpZones {
		if this.GcpZones[i] != that1.GcpZones[i] {
			return false
		}
	}
	if !this.AzureRgInfo.Equal(that1.AzureRgInfo) {
		return false
	}
	if len(this.CloudLink) != len(that1.CloudLink) {
		return false
	}
	for i := range this.CloudLink {
		if !this.CloudLink[i].Equal(that1.CloudLink[i]) {
			return false
		}
	}
	return true
}
func (this *MetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&topology.MetaType{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Creds != nil {
		s = append(s, "Creds: "+fmt.Sprintf("%#v", this.Creds)+",\n")
	}
	s = append(s, "RawJson: "+fmt.Sprintf("%#v", this.RawJson)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	s = append(s, "OwnerId: "+fmt.Sprintf("%#v", this.OwnerId)+",\n")
	s = append(s, "ProviderType: "+fmt.Sprintf("%#v", this.ProviderType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&topology.NetworkType{")
	if this.Region != nil {
		s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	}
	s = append(s, "CidrV4: "+fmt.Sprintf("%#v", this.CidrV4)+",\n")
	s = append(s, "CidrV6: "+fmt.Sprintf("%#v", this.CidrV6)+",\n")
	if this.NetworkPeers != nil {
		s = append(s, "NetworkPeers: "+fmt.Sprintf("%#v", this.NetworkPeers)+",\n")
	}
	if this.LoadBalancer != nil {
		s = append(s, "LoadBalancer: "+fmt.Sprintf("%#v", this.LoadBalancer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoadBalancer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.LoadBalancer{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&topology.SubnetType{")
	if this.Network != nil {
		s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	}
	if this.Region != nil {
		s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	}
	s = append(s, "AvailabilityZone: "+fmt.Sprintf("%#v", this.AvailabilityZone)+",\n")
	s = append(s, "CidrV4: "+fmt.Sprintf("%#v", this.CidrV4)+",\n")
	s = append(s, "CidrV6: "+fmt.Sprintf("%#v", this.CidrV6)+",\n")
	s = append(s, "InterfaceType: "+fmt.Sprintf("%#v", this.InterfaceType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InstanceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&topology.InstanceType{")
	if this.Interfaces != nil {
		s = append(s, "Interfaces: "+fmt.Sprintf("%#v", this.Interfaces)+",\n")
	}
	s = append(s, "Architecture: "+fmt.Sprintf("%#v", this.Architecture)+",\n")
	s = append(s, "Cpu: "+fmt.Sprintf("%#v", this.Cpu)+",\n")
	s = append(s, "InstanceType: "+fmt.Sprintf("%#v", this.InstanceType)+",\n")
	s = append(s, "Platform: "+fmt.Sprintf("%#v", this.Platform)+",\n")
	s = append(s, "PrivateAddress: "+fmt.Sprintf("%#v", this.PrivateAddress)+",\n")
	s = append(s, "PublicAddress: "+fmt.Sprintf("%#v", this.PublicAddress)+",\n")
	s = append(s, "PrivateDnsName: "+fmt.Sprintf("%#v", this.PrivateDnsName)+",\n")
	s = append(s, "PublicDnsName: "+fmt.Sprintf("%#v", this.PublicDnsName)+",\n")
	s = append(s, "SecurityGroup: "+fmt.Sprintf("%#v", this.SecurityGroup)+",\n")
	s = append(s, "AvailabilityZone: "+fmt.Sprintf("%#v", this.AvailabilityZone)+",\n")
	s = append(s, "F5XcNodeName: "+fmt.Sprintf("%#v", this.F5XcNodeName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSTGWAttachment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&topology.AWSTGWAttachment{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "ResourceType: "+fmt.Sprintf("%#v", this.ResourceType)+",\n")
	s = append(s, "ResourceId: "+fmt.Sprintf("%#v", this.ResourceId)+",\n")
	s = append(s, "ResourceName: "+fmt.Sprintf("%#v", this.ResourceName)+",\n")
	s = append(s, "Cidr: "+fmt.Sprintf("%#v", this.Cidr)+",\n")
	s = append(s, "AssociatedRouteTableId: "+fmt.Sprintf("%#v", this.AssociatedRouteTableId)+",\n")
	s = append(s, "AssociationState: "+fmt.Sprintf("%#v", this.AssociationState)+",\n")
	if this.CloudConnect != nil {
		s = append(s, "CloudConnect: "+fmt.Sprintf("%#v", this.CloudConnect)+",\n")
	}
	if this.Segment != nil {
		s = append(s, "Segment: "+fmt.Sprintf("%#v", this.Segment)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TransitGatewayType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&topology.TransitGatewayType{")
	if this.Network != nil {
		s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	}
	s = append(s, "AutoAcceptSharedAttachments: "+fmt.Sprintf("%#v", this.AutoAcceptSharedAttachments)+",\n")
	s = append(s, "DnsSupport: "+fmt.Sprintf("%#v", this.DnsSupport)+",\n")
	s = append(s, "VpnEcmpSupport: "+fmt.Sprintf("%#v", this.VpnEcmpSupport)+",\n")
	if this.Attachments != nil {
		s = append(s, "Attachments: "+fmt.Sprintf("%#v", this.Attachments)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteTableType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&topology.RouteTableType{")
	if this.Subnet != nil {
		s = append(s, "Subnet: "+fmt.Sprintf("%#v", this.Subnet)+",\n")
	}
	if this.Network != nil {
		s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	}
	if this.TransitGateway != nil {
		s = append(s, "TransitGateway: "+fmt.Sprintf("%#v", this.TransitGateway)+",\n")
	}
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	s = append(s, "RouteTableType: "+fmt.Sprintf("%#v", this.RouteTableType)+",\n")
	if this.ImplicitSubnet != nil {
		s = append(s, "ImplicitSubnet: "+fmt.Sprintf("%#v", this.ImplicitSubnet)+",\n")
	}
	if this.ExplicitSubnet != nil {
		s = append(s, "ExplicitSubnet: "+fmt.Sprintf("%#v", this.ExplicitSubnet)+",\n")
	}
	s = append(s, "RouteTableState: "+fmt.Sprintf("%#v", this.RouteTableState)+",\n")
	if this.Associations != nil {
		s = append(s, "Associations: "+fmt.Sprintf("%#v", this.Associations)+",\n")
	}
	if this.Propagations != nil {
		s = append(s, "Propagations: "+fmt.Sprintf("%#v", this.Propagations)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSTGWAttachmentMetaData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&topology.AWSTGWAttachmentMetaData{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "ResourceType: "+fmt.Sprintf("%#v", this.ResourceType)+",\n")
	s = append(s, "ResourceId: "+fmt.Sprintf("%#v", this.ResourceId)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "ResourceName: "+fmt.Sprintf("%#v", this.ResourceName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPRouteAttributes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&topology.GCPRouteAttributes{")
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	s = append(s, "IpVersion: "+fmt.Sprintf("%#v", this.IpVersion)+",\n")
	s = append(s, "ScopeLimits: "+fmt.Sprintf("%#v", this.ScopeLimits)+",\n")
	s = append(s, "RouteType: "+fmt.Sprintf("%#v", this.RouteType)+",\n")
	s = append(s, "RouteName: "+fmt.Sprintf("%#v", this.RouteName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSTgwRouteAttributes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.AWSTgwRouteAttributes{")
	s = append(s, "RouteType: "+fmt.Sprintf("%#v", this.RouteType)+",\n")
	if this.NextHopAttachment != nil {
		s = append(s, "NextHopAttachment: "+fmt.Sprintf("%#v", this.NextHopAttachment)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSRouteAttributes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.AWSRouteAttributes{")
	s = append(s, "Propagated: "+fmt.Sprintf("%#v", this.Propagated)+",\n")
	if this.Tgw != nil {
		s = append(s, "Tgw: "+fmt.Sprintf("%#v", this.Tgw)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&topology.RouteType{")
	s = append(s, "Destination: "+fmt.Sprintf("%#v", this.Destination)+",\n")
	s = append(s, "Nexthop: "+fmt.Sprintf("%#v", this.Nexthop)+",\n")
	s = append(s, "Source: "+fmt.Sprintf("%#v", this.Source)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "NextHopType: "+fmt.Sprintf("%#v", this.NextHopType)+",\n")
	s = append(s, "UserDefinedRouteName: "+fmt.Sprintf("%#v", this.UserDefinedRouteName)+",\n")
	if this.CloudRouteAttributes != nil {
		s = append(s, "CloudRouteAttributes: "+fmt.Sprintf("%#v", this.CloudRouteAttributes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteType_Aws) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&topology.RouteType_Aws{` +
		`Aws:` + fmt.Sprintf("%#v", this.Aws) + `}`}, ", ")
	return s
}
func (this *RouteType_Gcp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&topology.RouteType_Gcp{` +
		`Gcp:` + fmt.Sprintf("%#v", this.Gcp) + `}`}, ", ")
	return s
}
func (this *SiteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&topology.SiteType{")
	if this.Network != nil {
		s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	}
	if this.Tgw != nil {
		s = append(s, "Tgw: "+fmt.Sprintf("%#v", this.Tgw)+",\n")
	}
	if this.DcClusterGroup != nil {
		s = append(s, "DcClusterGroup: "+fmt.Sprintf("%#v", this.DcClusterGroup)+",\n")
	}
	s = append(s, "SiteType: "+fmt.Sprintf("%#v", this.SiteType)+",\n")
	if this.ProviderInfo != nil {
		s = append(s, "ProviderInfo: "+fmt.Sprintf("%#v", this.ProviderInfo)+",\n")
	}
	s = append(s, "GatewayType: "+fmt.Sprintf("%#v", this.GatewayType)+",\n")
	s = append(s, "AppType: "+fmt.Sprintf("%#v", this.AppType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteMeshGroupType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&topology.SiteMeshGroupType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "SiteType: "+fmt.Sprintf("%#v", this.SiteType)+",\n")
	if this.VirtualSite != nil {
		s = append(s, "VirtualSite: "+fmt.Sprintf("%#v", this.VirtualSite)+",\n")
	}
	if this.Hub != nil {
		s = append(s, "Hub: "+fmt.Sprintf("%#v", this.Hub)+",\n")
	}
	if this.MeshChoice != nil {
		s = append(s, "MeshChoice: "+fmt.Sprintf("%#v", this.MeshChoice)+",\n")
	}
	if this.TopologySite != nil {
		s = append(s, "TopologySite: "+fmt.Sprintf("%#v", this.TopologySite)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteMeshGroupType_HubMesh) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&topology.SiteMeshGroupType_HubMesh{` +
		`HubMesh:` + fmt.Sprintf("%#v", this.HubMesh) + `}`}, ", ")
	return s
}
func (this *SiteMeshGroupType_SpokeMesh) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&topology.SiteMeshGroupType_SpokeMesh{` +
		`SpokeMesh:` + fmt.Sprintf("%#v", this.SpokeMesh) + `}`}, ", ")
	return s
}
func (this *SiteMeshGroupType_FullMesh) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&topology.SiteMeshGroupType_FullMesh{` +
		`FullMesh:` + fmt.Sprintf("%#v", this.FullMesh) + `}`}, ", ")
	return s
}
func (this *DCClusterGroupType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&topology.DCClusterGroupType{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkInterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&topology.NetworkInterfaceType{")
	if this.Subnet != nil {
		s = append(s, "Subnet: "+fmt.Sprintf("%#v", this.Subnet)+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	if this.PrivateAddresses != nil {
		s = append(s, "PrivateAddresses: "+fmt.Sprintf("%#v", this.PrivateAddresses)+",\n")
	}
	if this.PublicAddress != nil {
		s = append(s, "PublicAddress: "+fmt.Sprintf("%#v", this.PublicAddress)+",\n")
	}
	s = append(s, "SecurityGroup: "+fmt.Sprintf("%#v", this.SecurityGroup)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.F5XcStatus != nil {
		s = append(s, "F5XcStatus: "+fmt.Sprintf("%#v", this.F5XcStatus)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AddressInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&topology.AddressInfoType{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "DnsName: "+fmt.Sprintf("%#v", this.DnsName)+",\n")
	s = append(s, "Primary: "+fmt.Sprintf("%#v", this.Primary)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TunnelSetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.TunnelSetType{")
	if this.Site != nil {
		s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	}
	if this.Tunnels != nil {
		s = append(s, "Tunnels: "+fmt.Sprintf("%#v", this.Tunnels)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkPeerType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&topology.NetworkPeerType{")
	if this.PeerChoice != nil {
		s = append(s, "PeerChoice: "+fmt.Sprintf("%#v", this.PeerChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkPeerType_VnetPeer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&topology.NetworkPeerType_VnetPeer{` +
		`VnetPeer:` + fmt.Sprintf("%#v", this.VnetPeer) + `}`}, ", ")
	return s
}
func (this *AzureVnetPeer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.AzureVnetPeer{")
	if this.PeerNetwork != nil {
		s = append(s, "PeerNetwork: "+fmt.Sprintf("%#v", this.PeerNetwork)+",\n")
	}
	s = append(s, "PeeringState: "+fmt.Sprintf("%#v", this.PeeringState)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TunnelType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&topology.TunnelType{")
	if this.Connection != nil {
		s = append(s, "Connection: "+fmt.Sprintf("%#v", this.Connection)+",\n")
	}
	if this.Site != nil {
		s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	}
	if this.Tgw != nil {
		s = append(s, "Tgw: "+fmt.Sprintf("%#v", this.Tgw)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudPolicyType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&topology.CloudPolicyType{")
	if this.CloudType != nil {
		s = append(s, "CloudType: "+fmt.Sprintf("%#v", this.CloudType)+",\n")
	}
	s = append(s, "PermissionsPopulated: "+fmt.Sprintf("%#v", this.PermissionsPopulated)+",\n")
	s = append(s, "CloudProviderError: "+fmt.Sprintf("%#v", this.CloudProviderError)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudPolicyType_Aws) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&topology.CloudPolicyType_Aws{` +
		`Aws:` + fmt.Sprintf("%#v", this.Aws) + `}`}, ", ")
	return s
}
func (this *AWSPolicyType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&topology.AWSPolicyType{")
	s = append(s, "SupportAwsVpcSite: "+fmt.Sprintf("%#v", this.SupportAwsVpcSite)+",\n")
	s = append(s, "MissingPermissionsAwsVpcSite: "+fmt.Sprintf("%#v", this.MissingPermissionsAwsVpcSite)+",\n")
	s = append(s, "SupportAwsTgwSite: "+fmt.Sprintf("%#v", this.SupportAwsTgwSite)+",\n")
	s = append(s, "MissingPermissionsAwsTgwSite: "+fmt.Sprintf("%#v", this.MissingPermissionsAwsTgwSite)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureResourceGroupInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.AzureResourceGroupInfo{")
	s = append(s, "SiteRg: "+fmt.Sprintf("%#v", this.SiteRg)+",\n")
	s = append(s, "VirtualNetworkRg: "+fmt.Sprintf("%#v", this.VirtualNetworkRg)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProviderInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&topology.ProviderInfo{")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	s = append(s, "GcpZones: "+fmt.Sprintf("%#v", this.GcpZones)+",\n")
	if this.AzureRgInfo != nil {
		s = append(s, "AzureRgInfo: "+fmt.Sprintf("%#v", this.AzureRgInfo)+",\n")
	}
	if this.CloudLink != nil {
		s = append(s, "CloudLink: "+fmt.Sprintf("%#v", this.CloudLink)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *MetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProviderType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ProviderType))
		i--
		dAtA[i] = 0x48
	}
	if len(m.OwnerId) > 0 {
		i -= len(m.OwnerId)
		copy(dAtA[i:], m.OwnerId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OwnerId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Tags) > 0 {
		keysForTags := make([]string, 0, len(m.Tags))
		for k := range m.Tags {
			keysForTags = append(keysForTags, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
		for iNdEx := len(keysForTags) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tags[string(keysForTags[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTags[iNdEx])
			copy(dAtA[i:], keysForTags[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForTags[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.RawJson) > 0 {
		i -= len(m.RawJson)
		copy(dAtA[i:], m.RawJson)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RawJson)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Creds) > 0 {
		for iNdEx := len(m.Creds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Creds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LoadBalancer) > 0 {
		for iNdEx := len(m.LoadBalancer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LoadBalancer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.NetworkPeers) > 0 {
		for iNdEx := len(m.NetworkPeers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NetworkPeers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CidrV6) > 0 {
		for iNdEx := len(m.CidrV6) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CidrV6[iNdEx])
			copy(dAtA[i:], m.CidrV6[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.CidrV6[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CidrV4) > 0 {
		for iNdEx := len(m.CidrV4) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CidrV4[iNdEx])
			copy(dAtA[i:], m.CidrV4[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.CidrV4[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Region) > 0 {
		for iNdEx := len(m.Region) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Region[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LoadBalancer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadBalancer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadBalancer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterfaceType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.InterfaceType))
		i--
		dAtA[i] = 0x38
	}
	if len(m.CidrV6) > 0 {
		for iNdEx := len(m.CidrV6) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CidrV6[iNdEx])
			copy(dAtA[i:], m.CidrV6[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.CidrV6[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.CidrV4) > 0 {
		for iNdEx := len(m.CidrV4) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CidrV4[iNdEx])
			copy(dAtA[i:], m.CidrV4[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.CidrV4[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.AvailabilityZone) > 0 {
		i -= len(m.AvailabilityZone)
		copy(dAtA[i:], m.AvailabilityZone)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AvailabilityZone)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Region) > 0 {
		for iNdEx := len(m.Region) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Region[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Network) > 0 {
		for iNdEx := len(m.Network) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Network[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *InstanceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstanceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.F5XcNodeName) > 0 {
		i -= len(m.F5XcNodeName)
		copy(dAtA[i:], m.F5XcNodeName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.F5XcNodeName)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.AvailabilityZone) > 0 {
		i -= len(m.AvailabilityZone)
		copy(dAtA[i:], m.AvailabilityZone)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AvailabilityZone)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.SecurityGroup) > 0 {
		for iNdEx := len(m.SecurityGroup) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SecurityGroup[iNdEx])
			copy(dAtA[i:], m.SecurityGroup[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.SecurityGroup[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.PublicDnsName) > 0 {
		i -= len(m.PublicDnsName)
		copy(dAtA[i:], m.PublicDnsName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicDnsName)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.PrivateDnsName) > 0 {
		i -= len(m.PrivateDnsName)
		copy(dAtA[i:], m.PrivateDnsName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PrivateDnsName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.PublicAddress) > 0 {
		i -= len(m.PublicAddress)
		copy(dAtA[i:], m.PublicAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PrivateAddress) > 0 {
		i -= len(m.PrivateAddress)
		copy(dAtA[i:], m.PrivateAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PrivateAddress)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Platform) > 0 {
		i -= len(m.Platform)
		copy(dAtA[i:], m.Platform)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Platform)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.InstanceType) > 0 {
		i -= len(m.InstanceType)
		copy(dAtA[i:], m.InstanceType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InstanceType)))
		i--
		dAtA[i] = 0x22
	}
	if m.Cpu != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Cpu))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Architecture) > 0 {
		i -= len(m.Architecture)
		copy(dAtA[i:], m.Architecture)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Architecture)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Interfaces) > 0 {
		for iNdEx := len(m.Interfaces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Interfaces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSTGWAttachment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSTGWAttachment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSTGWAttachment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Segment) > 0 {
		for iNdEx := len(m.Segment) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Segment[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.CloudConnect) > 0 {
		for iNdEx := len(m.CloudConnect) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CloudConnect[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.AssociationState) > 0 {
		i -= len(m.AssociationState)
		copy(dAtA[i:], m.AssociationState)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AssociationState)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AssociatedRouteTableId) > 0 {
		i -= len(m.AssociatedRouteTableId)
		copy(dAtA[i:], m.AssociatedRouteTableId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AssociatedRouteTableId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Cidr) > 0 {
		i -= len(m.Cidr)
		copy(dAtA[i:], m.Cidr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Cidr)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ResourceName) > 0 {
		i -= len(m.ResourceName)
		copy(dAtA[i:], m.ResourceName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ResourceId) > 0 {
		i -= len(m.ResourceId)
		copy(dAtA[i:], m.ResourceId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ResourceType) > 0 {
		i -= len(m.ResourceType)
		copy(dAtA[i:], m.ResourceType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransitGatewayType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransitGatewayType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransitGatewayType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attachments) > 0 {
		for iNdEx := len(m.Attachments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attachments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.VpnEcmpSupport {
		i--
		if m.VpnEcmpSupport {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.DnsSupport {
		i--
		if m.DnsSupport {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AutoAcceptSharedAttachments {
		i--
		if m.AutoAcceptSharedAttachments {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Network) > 0 {
		for iNdEx := len(m.Network) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Network[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RouteTableType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTableType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Propagations) > 0 {
		for iNdEx := len(m.Propagations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Propagations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.Associations) > 0 {
		for iNdEx := len(m.Associations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Associations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.RouteTableState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RouteTableState))
		i--
		dAtA[i] = 0x50
	}
	if len(m.ExplicitSubnet) > 0 {
		for iNdEx := len(m.ExplicitSubnet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExplicitSubnet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ImplicitSubnet) > 0 {
		for iNdEx := len(m.ImplicitSubnet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ImplicitSubnet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.RouteTableType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RouteTableType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TransitGateway) > 0 {
		for iNdEx := len(m.TransitGateway) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransitGateway[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Network) > 0 {
		for iNdEx := len(m.Network) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Network[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Subnet) > 0 {
		for iNdEx := len(m.Subnet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subnet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSTGWAttachmentMetaData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSTGWAttachmentMetaData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSTGWAttachmentMetaData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResourceName) > 0 {
		i -= len(m.ResourceName)
		copy(dAtA[i:], m.ResourceName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ResourceId) > 0 {
		i -= len(m.ResourceId)
		copy(dAtA[i:], m.ResourceId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ResourceType) > 0 {
		i -= len(m.ResourceType)
		copy(dAtA[i:], m.ResourceType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCPRouteAttributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPRouteAttributes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPRouteAttributes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RouteName) > 0 {
		i -= len(m.RouteName)
		copy(dAtA[i:], m.RouteName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RouteName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RouteType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RouteType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ScopeLimits) > 0 {
		for iNdEx := len(m.ScopeLimits) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ScopeLimits[iNdEx])
			copy(dAtA[i:], m.ScopeLimits[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ScopeLimits[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.IpVersion) > 0 {
		i -= len(m.IpVersion)
		copy(dAtA[i:], m.IpVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IpVersion)))
		i--
		dAtA[i] = 0x12
	}
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AWSTgwRouteAttributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSTgwRouteAttributes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSTgwRouteAttributes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextHopAttachment) > 0 {
		for iNdEx := len(m.NextHopAttachment) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NextHopAttachment[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.RouteType) > 0 {
		i -= len(m.RouteType)
		copy(dAtA[i:], m.RouteType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RouteType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSRouteAttributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSRouteAttributes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSRouteAttributes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tgw != nil {
		{
			size, err := m.Tgw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Propagated {
		i--
		if m.Propagated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RouteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CloudRouteAttributes != nil {
		{
			size := m.CloudRouteAttributes.Size()
			i -= size
			if _, err := m.CloudRouteAttributes.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.UserDefinedRouteName) > 0 {
		i -= len(m.UserDefinedRouteName)
		copy(dAtA[i:], m.UserDefinedRouteName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserDefinedRouteName)))
		i--
		dAtA[i] = 0x32
	}
	if m.NextHopType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NextHopType))
		i--
		dAtA[i] = 0x28
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if m.Source != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Nexthop) > 0 {
		i -= len(m.Nexthop)
		copy(dAtA[i:], m.Nexthop)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Nexthop)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteType_Aws) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteType_Aws) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Aws != nil {
		{
			size, err := m.Aws.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *RouteType_Gcp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteType_Gcp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Gcp != nil {
		{
			size, err := m.Gcp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *SiteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AppType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AppType))
		i--
		dAtA[i] = 0x38
	}
	if m.GatewayType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GatewayType))
		i--
		dAtA[i] = 0x30
	}
	if m.ProviderInfo != nil {
		{
			size, err := m.ProviderInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.SiteType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DcClusterGroup) > 0 {
		for iNdEx := len(m.DcClusterGroup) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DcClusterGroup[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Tgw) > 0 {
		for iNdEx := len(m.Tgw) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tgw[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Network) > 0 {
		for iNdEx := len(m.Network) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Network[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SiteMeshGroupType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteMeshGroupType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteMeshGroupType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TopologySite) > 0 {
		for iNdEx := len(m.TopologySite) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TopologySite[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.VirtualSite) > 0 {
		for iNdEx := len(m.VirtualSite) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VirtualSite[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.MeshChoice != nil {
		{
			size := m.MeshChoice.Size()
			i -= size
			if _, err := m.MeshChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SiteType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Hub) > 0 {
		for iNdEx := len(m.Hub) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Hub[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SiteMeshGroupType_HubMesh) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteMeshGroupType_HubMesh) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HubMesh != nil {
		{
			size, err := m.HubMesh.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *SiteMeshGroupType_SpokeMesh) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteMeshGroupType_SpokeMesh) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SpokeMesh != nil {
		{
			size, err := m.SpokeMesh.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *SiteMeshGroupType_FullMesh) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteMeshGroupType_FullMesh) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FullMesh != nil {
		{
			size, err := m.FullMesh.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *DCClusterGroupType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DCClusterGroupType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DCClusterGroupType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkInterfaceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.F5XcStatus != nil {
		{
			size, err := m.F5XcStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SecurityGroup) > 0 {
		for iNdEx := len(m.SecurityGroup) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SecurityGroup[iNdEx])
			copy(dAtA[i:], m.SecurityGroup[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.SecurityGroup[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.PublicAddress) > 0 {
		for iNdEx := len(m.PublicAddress) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PublicAddress[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PrivateAddresses) > 0 {
		for iNdEx := len(m.PrivateAddresses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PrivateAddresses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Subnet) > 0 {
		for iNdEx := len(m.Subnet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subnet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AddressInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Primary {
		i--
		if m.Primary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.DnsName) > 0 {
		i -= len(m.DnsName)
		copy(dAtA[i:], m.DnsName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DnsName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TunnelSetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelSetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelSetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tunnels) > 0 {
		for iNdEx := len(m.Tunnels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tunnels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Site) > 0 {
		for iNdEx := len(m.Site) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Site[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NetworkPeerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkPeerType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPeerType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PeerChoice != nil {
		{
			size := m.PeerChoice.Size()
			i -= size
			if _, err := m.PeerChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *NetworkPeerType_VnetPeer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPeerType_VnetPeer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VnetPeer != nil {
		{
			size, err := m.VnetPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AzureVnetPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetPeer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetPeer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PeeringState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PeeringState))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PeerNetwork) > 0 {
		for iNdEx := len(m.PeerNetwork) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PeerNetwork[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TunnelType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tgw) > 0 {
		for iNdEx := len(m.Tgw) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tgw[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Site) > 0 {
		for iNdEx := len(m.Site) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Site[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Connection != nil {
		{
			size, err := m.Connection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudPolicyType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudPolicyType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudPolicyType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CloudProviderError) > 0 {
		i -= len(m.CloudProviderError)
		copy(dAtA[i:], m.CloudProviderError)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CloudProviderError)))
		i--
		dAtA[i] = 0x32
	}
	if m.PermissionsPopulated {
		i--
		if m.PermissionsPopulated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.CloudType != nil {
		{
			size := m.CloudType.Size()
			i -= size
			if _, err := m.CloudType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CloudPolicyType_Aws) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudPolicyType_Aws) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Aws != nil {
		{
			size, err := m.Aws.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AWSPolicyType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSPolicyType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSPolicyType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MissingPermissionsAwsTgwSite) > 0 {
		for iNdEx := len(m.MissingPermissionsAwsTgwSite) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MissingPermissionsAwsTgwSite[iNdEx])
			copy(dAtA[i:], m.MissingPermissionsAwsTgwSite[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.MissingPermissionsAwsTgwSite[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.SupportAwsTgwSite {
		i--
		if m.SupportAwsTgwSite {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.MissingPermissionsAwsVpcSite) > 0 {
		for iNdEx := len(m.MissingPermissionsAwsVpcSite) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MissingPermissionsAwsVpcSite[iNdEx])
			copy(dAtA[i:], m.MissingPermissionsAwsVpcSite[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.MissingPermissionsAwsVpcSite[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.SupportAwsVpcSite {
		i--
		if m.SupportAwsVpcSite {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AzureResourceGroupInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureResourceGroupInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureResourceGroupInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VirtualNetworkRg) > 0 {
		i -= len(m.VirtualNetworkRg)
		copy(dAtA[i:], m.VirtualNetworkRg)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VirtualNetworkRg)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SiteRg) > 0 {
		i -= len(m.SiteRg)
		copy(dAtA[i:], m.SiteRg)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SiteRg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProviderInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CloudLink) > 0 {
		for iNdEx := len(m.CloudLink) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CloudLink[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.AzureRgInfo != nil {
		{
			size, err := m.AzureRgInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.GcpZones) > 0 {
		for iNdEx := len(m.GcpZones) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GcpZones[iNdEx])
			copy(dAtA[i:], m.GcpZones[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.GcpZones[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Creds) > 0 {
		for _, e := range m.Creds {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.RawJson)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.OwnerId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ProviderType != 0 {
		n += 1 + sovTypes(uint64(m.ProviderType))
	}
	return n
}

func (m *NetworkType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Region) > 0 {
		for _, e := range m.Region {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CidrV4) > 0 {
		for _, s := range m.CidrV4 {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CidrV6) > 0 {
		for _, s := range m.CidrV6 {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.NetworkPeers) > 0 {
		for _, e := range m.NetworkPeers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.LoadBalancer) > 0 {
		for _, e := range m.LoadBalancer {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *LoadBalancer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SubnetType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Network) > 0 {
		for _, e := range m.Network {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Region) > 0 {
		for _, e := range m.Region {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.AvailabilityZone)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CidrV4) > 0 {
		for _, s := range m.CidrV4 {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CidrV6) > 0 {
		for _, s := range m.CidrV6 {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InterfaceType != 0 {
		n += 1 + sovTypes(uint64(m.InterfaceType))
	}
	return n
}

func (m *InstanceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for _, e := range m.Interfaces {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Architecture)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cpu != 0 {
		n += 1 + sovTypes(uint64(m.Cpu))
	}
	l = len(m.InstanceType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PrivateAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PrivateDnsName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicDnsName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.SecurityGroup) > 0 {
		for _, s := range m.SecurityGroup {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.AvailabilityZone)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.F5XcNodeName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AWSTGWAttachment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ResourceType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ResourceId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ResourceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Cidr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AssociatedRouteTableId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AssociationState)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CloudConnect) > 0 {
		for _, e := range m.CloudConnect {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Segment) > 0 {
		for _, e := range m.Segment {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *TransitGatewayType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Network) > 0 {
		for _, e := range m.Network {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.AutoAcceptSharedAttachments {
		n += 2
	}
	if m.DnsSupport {
		n += 2
	}
	if m.VpnEcmpSupport {
		n += 2
	}
	if len(m.Attachments) > 0 {
		for _, e := range m.Attachments {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *RouteTableType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Subnet) > 0 {
		for _, e := range m.Subnet {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Network) > 0 {
		for _, e := range m.Network {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.TransitGateway) > 0 {
		for _, e := range m.TransitGateway {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.RouteTableType != 0 {
		n += 1 + sovTypes(uint64(m.RouteTableType))
	}
	if len(m.ImplicitSubnet) > 0 {
		for _, e := range m.ImplicitSubnet {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ExplicitSubnet) > 0 {
		for _, e := range m.ExplicitSubnet {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.RouteTableState != 0 {
		n += 1 + sovTypes(uint64(m.RouteTableState))
	}
	if len(m.Associations) > 0 {
		for _, e := range m.Associations {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Propagations) > 0 {
		for _, e := range m.Propagations {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSTGWAttachmentMetaData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ResourceType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ResourceId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ResourceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GCPRouteAttributes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	l = len(m.IpVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ScopeLimits) > 0 {
		for _, s := range m.ScopeLimits {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.RouteType != 0 {
		n += 1 + sovTypes(uint64(m.RouteType))
	}
	l = len(m.RouteName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AWSTgwRouteAttributes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RouteType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.NextHopAttachment) > 0 {
		for _, e := range m.NextHopAttachment {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSRouteAttributes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Propagated {
		n += 2
	}
	if m.Tgw != nil {
		l = m.Tgw.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RouteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Nexthop)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Source != 0 {
		n += 1 + sovTypes(uint64(m.Source))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	if m.NextHopType != 0 {
		n += 1 + sovTypes(uint64(m.NextHopType))
	}
	l = len(m.UserDefinedRouteName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CloudRouteAttributes != nil {
		n += m.CloudRouteAttributes.Size()
	}
	return n
}

func (m *RouteType_Aws) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aws != nil {
		l = m.Aws.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteType_Gcp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gcp != nil {
		l = m.Gcp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SiteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Network) > 0 {
		for _, e := range m.Network {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Tgw) > 0 {
		for _, e := range m.Tgw {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.DcClusterGroup) > 0 {
		for _, e := range m.DcClusterGroup {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.SiteType != 0 {
		n += 1 + sovTypes(uint64(m.SiteType))
	}
	if m.ProviderInfo != nil {
		l = m.ProviderInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.GatewayType != 0 {
		n += 1 + sovTypes(uint64(m.GatewayType))
	}
	if m.AppType != 0 {
		n += 1 + sovTypes(uint64(m.AppType))
	}
	return n
}

func (m *SiteMeshGroupType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if len(m.Hub) > 0 {
		for _, e := range m.Hub {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.SiteType != 0 {
		n += 1 + sovTypes(uint64(m.SiteType))
	}
	if m.MeshChoice != nil {
		n += m.MeshChoice.Size()
	}
	if len(m.VirtualSite) > 0 {
		for _, e := range m.VirtualSite {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.TopologySite) > 0 {
		for _, e := range m.TopologySite {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SiteMeshGroupType_HubMesh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HubMesh != nil {
		l = m.HubMesh.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SiteMeshGroupType_SpokeMesh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpokeMesh != nil {
		l = m.SpokeMesh.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SiteMeshGroupType_FullMesh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FullMesh != nil {
		l = m.FullMesh.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DCClusterGroupType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *NetworkInterfaceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Subnet) > 0 {
		for _, e := range m.Subnet {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.PrivateAddresses) > 0 {
		for _, e := range m.PrivateAddresses {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.PublicAddress) > 0 {
		for _, e := range m.PublicAddress {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.SecurityGroup) > 0 {
		for _, s := range m.SecurityGroup {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.F5XcStatus != nil {
		l = m.F5XcStatus.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AddressInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DnsName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Primary {
		n += 2
	}
	return n
}

func (m *TunnelSetType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Site) > 0 {
		for _, e := range m.Site {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Tunnels) > 0 {
		for _, e := range m.Tunnels {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *NetworkPeerType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PeerChoice != nil {
		n += m.PeerChoice.Size()
	}
	return n
}

func (m *NetworkPeerType_VnetPeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VnetPeer != nil {
		l = m.VnetPeer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AzureVnetPeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PeerNetwork) > 0 {
		for _, e := range m.PeerNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.PeeringState != 0 {
		n += 1 + sovTypes(uint64(m.PeeringState))
	}
	return n
}

func (m *TunnelType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connection != nil {
		l = m.Connection.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Site) > 0 {
		for _, e := range m.Site {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Tgw) > 0 {
		for _, e := range m.Tgw {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CloudPolicyType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudType != nil {
		n += m.CloudType.Size()
	}
	if m.PermissionsPopulated {
		n += 2
	}
	l = len(m.CloudProviderError)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CloudPolicyType_Aws) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aws != nil {
		l = m.Aws.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSPolicyType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SupportAwsVpcSite {
		n += 2
	}
	if len(m.MissingPermissionsAwsVpcSite) > 0 {
		for _, s := range m.MissingPermissionsAwsVpcSite {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.SupportAwsTgwSite {
		n += 2
	}
	if len(m.MissingPermissionsAwsTgwSite) > 0 {
		for _, s := range m.MissingPermissionsAwsTgwSite {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AzureResourceGroupInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SiteRg)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VirtualNetworkRg)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ProviderInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.GcpZones) > 0 {
		for _, s := range m.GcpZones {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.AzureRgInfo != nil {
		l = m.AzureRgInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CloudLink) > 0 {
		for _, e := range m.CloudLink {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *MetaType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCreds := "[]*ObjectRefType{"
	for _, f := range this.Creds {
		repeatedStringForCreds += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCreds += "}"
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&MetaType{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Creds:` + repeatedStringForCreds + `,`,
		`RawJson:` + fmt.Sprintf("%v", this.RawJson) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`OwnerId:` + fmt.Sprintf("%v", this.OwnerId) + `,`,
		`ProviderType:` + fmt.Sprintf("%v", this.ProviderType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRegion := "[]*ObjectRefType{"
	for _, f := range this.Region {
		repeatedStringForRegion += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRegion += "}"
	repeatedStringForNetworkPeers := "[]*ObjectRefType{"
	for _, f := range this.NetworkPeers {
		repeatedStringForNetworkPeers += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForNetworkPeers += "}"
	repeatedStringForLoadBalancer := "[]*LoadBalancer{"
	for _, f := range this.LoadBalancer {
		repeatedStringForLoadBalancer += strings.Replace(f.String(), "LoadBalancer", "LoadBalancer", 1) + ","
	}
	repeatedStringForLoadBalancer += "}"
	s := strings.Join([]string{`&NetworkType{`,
		`Region:` + repeatedStringForRegion + `,`,
		`CidrV4:` + fmt.Sprintf("%v", this.CidrV4) + `,`,
		`CidrV6:` + fmt.Sprintf("%v", this.CidrV6) + `,`,
		`NetworkPeers:` + repeatedStringForNetworkPeers + `,`,
		`LoadBalancer:` + repeatedStringForLoadBalancer + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoadBalancer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoadBalancer{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SubnetType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNetwork := "[]*ObjectRefType{"
	for _, f := range this.Network {
		repeatedStringForNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForNetwork += "}"
	repeatedStringForRegion := "[]*ObjectRefType{"
	for _, f := range this.Region {
		repeatedStringForRegion += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRegion += "}"
	s := strings.Join([]string{`&SubnetType{`,
		`Network:` + repeatedStringForNetwork + `,`,
		`Region:` + repeatedStringForRegion + `,`,
		`AvailabilityZone:` + fmt.Sprintf("%v", this.AvailabilityZone) + `,`,
		`CidrV4:` + fmt.Sprintf("%v", this.CidrV4) + `,`,
		`CidrV6:` + fmt.Sprintf("%v", this.CidrV6) + `,`,
		`InterfaceType:` + fmt.Sprintf("%v", this.InterfaceType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InstanceType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInterfaces := "[]*NetworkInterfaceType{"
	for _, f := range this.Interfaces {
		repeatedStringForInterfaces += strings.Replace(f.String(), "NetworkInterfaceType", "NetworkInterfaceType", 1) + ","
	}
	repeatedStringForInterfaces += "}"
	s := strings.Join([]string{`&InstanceType{`,
		`Interfaces:` + repeatedStringForInterfaces + `,`,
		`Architecture:` + fmt.Sprintf("%v", this.Architecture) + `,`,
		`Cpu:` + fmt.Sprintf("%v", this.Cpu) + `,`,
		`InstanceType:` + fmt.Sprintf("%v", this.InstanceType) + `,`,
		`Platform:` + fmt.Sprintf("%v", this.Platform) + `,`,
		`PrivateAddress:` + fmt.Sprintf("%v", this.PrivateAddress) + `,`,
		`PublicAddress:` + fmt.Sprintf("%v", this.PublicAddress) + `,`,
		`PrivateDnsName:` + fmt.Sprintf("%v", this.PrivateDnsName) + `,`,
		`PublicDnsName:` + fmt.Sprintf("%v", this.PublicDnsName) + `,`,
		`SecurityGroup:` + fmt.Sprintf("%v", this.SecurityGroup) + `,`,
		`AvailabilityZone:` + fmt.Sprintf("%v", this.AvailabilityZone) + `,`,
		`F5XcNodeName:` + fmt.Sprintf("%v", this.F5XcNodeName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSTGWAttachment) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCloudConnect := "[]*ObjectRefType{"
	for _, f := range this.CloudConnect {
		repeatedStringForCloudConnect += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCloudConnect += "}"
	repeatedStringForSegment := "[]*ObjectRefType{"
	for _, f := range this.Segment {
		repeatedStringForSegment += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSegment += "}"
	s := strings.Join([]string{`&AWSTGWAttachment{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ResourceType:` + fmt.Sprintf("%v", this.ResourceType) + `,`,
		`ResourceId:` + fmt.Sprintf("%v", this.ResourceId) + `,`,
		`ResourceName:` + fmt.Sprintf("%v", this.ResourceName) + `,`,
		`Cidr:` + fmt.Sprintf("%v", this.Cidr) + `,`,
		`AssociatedRouteTableId:` + fmt.Sprintf("%v", this.AssociatedRouteTableId) + `,`,
		`AssociationState:` + fmt.Sprintf("%v", this.AssociationState) + `,`,
		`CloudConnect:` + repeatedStringForCloudConnect + `,`,
		`Segment:` + repeatedStringForSegment + `,`,
		`}`,
	}, "")
	return s
}
func (this *TransitGatewayType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNetwork := "[]*ObjectRefType{"
	for _, f := range this.Network {
		repeatedStringForNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForNetwork += "}"
	repeatedStringForAttachments := "[]*AWSTGWAttachment{"
	for _, f := range this.Attachments {
		repeatedStringForAttachments += strings.Replace(f.String(), "AWSTGWAttachment", "AWSTGWAttachment", 1) + ","
	}
	repeatedStringForAttachments += "}"
	s := strings.Join([]string{`&TransitGatewayType{`,
		`Network:` + repeatedStringForNetwork + `,`,
		`AutoAcceptSharedAttachments:` + fmt.Sprintf("%v", this.AutoAcceptSharedAttachments) + `,`,
		`DnsSupport:` + fmt.Sprintf("%v", this.DnsSupport) + `,`,
		`VpnEcmpSupport:` + fmt.Sprintf("%v", this.VpnEcmpSupport) + `,`,
		`Attachments:` + repeatedStringForAttachments + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteTableType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSubnet := "[]*ObjectRefType{"
	for _, f := range this.Subnet {
		repeatedStringForSubnet += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSubnet += "}"
	repeatedStringForNetwork := "[]*ObjectRefType{"
	for _, f := range this.Network {
		repeatedStringForNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForNetwork += "}"
	repeatedStringForTransitGateway := "[]*ObjectRefType{"
	for _, f := range this.TransitGateway {
		repeatedStringForTransitGateway += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForTransitGateway += "}"
	repeatedStringForRoutes := "[]*RouteType{"
	for _, f := range this.Routes {
		repeatedStringForRoutes += strings.Replace(f.String(), "RouteType", "RouteType", 1) + ","
	}
	repeatedStringForRoutes += "}"
	repeatedStringForImplicitSubnet := "[]*ObjectRefType{"
	for _, f := range this.ImplicitSubnet {
		repeatedStringForImplicitSubnet += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForImplicitSubnet += "}"
	repeatedStringForExplicitSubnet := "[]*ObjectRefType{"
	for _, f := range this.ExplicitSubnet {
		repeatedStringForExplicitSubnet += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForExplicitSubnet += "}"
	repeatedStringForAssociations := "[]*AWSTGWAttachmentMetaData{"
	for _, f := range this.Associations {
		repeatedStringForAssociations += strings.Replace(f.String(), "AWSTGWAttachmentMetaData", "AWSTGWAttachmentMetaData", 1) + ","
	}
	repeatedStringForAssociations += "}"
	repeatedStringForPropagations := "[]*AWSTGWAttachmentMetaData{"
	for _, f := range this.Propagations {
		repeatedStringForPropagations += strings.Replace(f.String(), "AWSTGWAttachmentMetaData", "AWSTGWAttachmentMetaData", 1) + ","
	}
	repeatedStringForPropagations += "}"
	s := strings.Join([]string{`&RouteTableType{`,
		`Subnet:` + repeatedStringForSubnet + `,`,
		`Network:` + repeatedStringForNetwork + `,`,
		`TransitGateway:` + repeatedStringForTransitGateway + `,`,
		`Routes:` + repeatedStringForRoutes + `,`,
		`RouteTableType:` + fmt.Sprintf("%v", this.RouteTableType) + `,`,
		`ImplicitSubnet:` + repeatedStringForImplicitSubnet + `,`,
		`ExplicitSubnet:` + repeatedStringForExplicitSubnet + `,`,
		`RouteTableState:` + fmt.Sprintf("%v", this.RouteTableState) + `,`,
		`Associations:` + repeatedStringForAssociations + `,`,
		`Propagations:` + repeatedStringForPropagations + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSTGWAttachmentMetaData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSTGWAttachmentMetaData{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`ResourceType:` + fmt.Sprintf("%v", this.ResourceType) + `,`,
		`ResourceId:` + fmt.Sprintf("%v", this.ResourceId) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`ResourceName:` + fmt.Sprintf("%v", this.ResourceName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPRouteAttributes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPRouteAttributes{`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`IpVersion:` + fmt.Sprintf("%v", this.IpVersion) + `,`,
		`ScopeLimits:` + fmt.Sprintf("%v", this.ScopeLimits) + `,`,
		`RouteType:` + fmt.Sprintf("%v", this.RouteType) + `,`,
		`RouteName:` + fmt.Sprintf("%v", this.RouteName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSTgwRouteAttributes) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNextHopAttachment := "[]*AWSTGWAttachmentMetaData{"
	for _, f := range this.NextHopAttachment {
		repeatedStringForNextHopAttachment += strings.Replace(f.String(), "AWSTGWAttachmentMetaData", "AWSTGWAttachmentMetaData", 1) + ","
	}
	repeatedStringForNextHopAttachment += "}"
	s := strings.Join([]string{`&AWSTgwRouteAttributes{`,
		`RouteType:` + fmt.Sprintf("%v", this.RouteType) + `,`,
		`NextHopAttachment:` + repeatedStringForNextHopAttachment + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSRouteAttributes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSRouteAttributes{`,
		`Propagated:` + fmt.Sprintf("%v", this.Propagated) + `,`,
		`Tgw:` + strings.Replace(this.Tgw.String(), "AWSTgwRouteAttributes", "AWSTgwRouteAttributes", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteType{`,
		`Destination:` + fmt.Sprintf("%v", this.Destination) + `,`,
		`Nexthop:` + fmt.Sprintf("%v", this.Nexthop) + `,`,
		`Source:` + fmt.Sprintf("%v", this.Source) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`NextHopType:` + fmt.Sprintf("%v", this.NextHopType) + `,`,
		`UserDefinedRouteName:` + fmt.Sprintf("%v", this.UserDefinedRouteName) + `,`,
		`CloudRouteAttributes:` + fmt.Sprintf("%v", this.CloudRouteAttributes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteType_Aws) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteType_Aws{`,
		`Aws:` + strings.Replace(fmt.Sprintf("%v", this.Aws), "AWSRouteAttributes", "AWSRouteAttributes", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteType_Gcp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteType_Gcp{`,
		`Gcp:` + strings.Replace(fmt.Sprintf("%v", this.Gcp), "GCPRouteAttributes", "GCPRouteAttributes", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNetwork := "[]*ObjectRefType{"
	for _, f := range this.Network {
		repeatedStringForNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForNetwork += "}"
	repeatedStringForTgw := "[]*ObjectRefType{"
	for _, f := range this.Tgw {
		repeatedStringForTgw += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForTgw += "}"
	repeatedStringForDcClusterGroup := "[]*ObjectRefType{"
	for _, f := range this.DcClusterGroup {
		repeatedStringForDcClusterGroup += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForDcClusterGroup += "}"
	s := strings.Join([]string{`&SiteType{`,
		`Network:` + repeatedStringForNetwork + `,`,
		`Tgw:` + repeatedStringForTgw + `,`,
		`DcClusterGroup:` + repeatedStringForDcClusterGroup + `,`,
		`SiteType:` + fmt.Sprintf("%v", this.SiteType) + `,`,
		`ProviderInfo:` + strings.Replace(this.ProviderInfo.String(), "ProviderInfo", "ProviderInfo", 1) + `,`,
		`GatewayType:` + fmt.Sprintf("%v", this.GatewayType) + `,`,
		`AppType:` + fmt.Sprintf("%v", this.AppType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteMeshGroupType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHub := "[]*ObjectRefType{"
	for _, f := range this.Hub {
		repeatedStringForHub += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForHub += "}"
	repeatedStringForVirtualSite := "[]*ObjectRefType{"
	for _, f := range this.VirtualSite {
		repeatedStringForVirtualSite += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForVirtualSite += "}"
	repeatedStringForTopologySite := "[]*ObjectRefType{"
	for _, f := range this.TopologySite {
		repeatedStringForTopologySite += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForTopologySite += "}"
	s := strings.Join([]string{`&SiteMeshGroupType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Hub:` + repeatedStringForHub + `,`,
		`SiteType:` + fmt.Sprintf("%v", this.SiteType) + `,`,
		`MeshChoice:` + fmt.Sprintf("%v", this.MeshChoice) + `,`,
		`VirtualSite:` + repeatedStringForVirtualSite + `,`,
		`TopologySite:` + repeatedStringForTopologySite + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteMeshGroupType_HubMesh) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteMeshGroupType_HubMesh{`,
		`HubMesh:` + strings.Replace(fmt.Sprintf("%v", this.HubMesh), "HubFullMeshGroupType", "site_mesh_group.HubFullMeshGroupType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteMeshGroupType_SpokeMesh) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteMeshGroupType_SpokeMesh{`,
		`SpokeMesh:` + strings.Replace(fmt.Sprintf("%v", this.SpokeMesh), "SpokeMeshGroupType", "site_mesh_group.SpokeMeshGroupType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteMeshGroupType_FullMesh) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteMeshGroupType_FullMesh{`,
		`FullMesh:` + strings.Replace(fmt.Sprintf("%v", this.FullMesh), "FullMeshGroupType", "site_mesh_group.FullMeshGroupType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DCClusterGroupType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DCClusterGroupType{`,
		`Type:` + strings.Replace(fmt.Sprintf("%v", this.Type), "DCClusterGroupMeshType", "dc_cluster_group.DCClusterGroupMeshType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkInterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSubnet := "[]*ObjectRefType{"
	for _, f := range this.Subnet {
		repeatedStringForSubnet += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSubnet += "}"
	repeatedStringForPrivateAddresses := "[]*AddressInfoType{"
	for _, f := range this.PrivateAddresses {
		repeatedStringForPrivateAddresses += strings.Replace(f.String(), "AddressInfoType", "AddressInfoType", 1) + ","
	}
	repeatedStringForPrivateAddresses += "}"
	repeatedStringForPublicAddress := "[]*AddressInfoType{"
	for _, f := range this.PublicAddress {
		repeatedStringForPublicAddress += strings.Replace(f.String(), "AddressInfoType", "AddressInfoType", 1) + ","
	}
	repeatedStringForPublicAddress += "}"
	s := strings.Join([]string{`&NetworkInterfaceType{`,
		`Subnet:` + repeatedStringForSubnet + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`PrivateAddresses:` + repeatedStringForPrivateAddresses + `,`,
		`PublicAddress:` + repeatedStringForPublicAddress + `,`,
		`SecurityGroup:` + fmt.Sprintf("%v", this.SecurityGroup) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`F5XcStatus:` + strings.Replace(fmt.Sprintf("%v", this.F5XcStatus), "InterfaceStatus", "site.InterfaceStatus", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AddressInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AddressInfoType{`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`DnsName:` + fmt.Sprintf("%v", this.DnsName) + `,`,
		`Primary:` + fmt.Sprintf("%v", this.Primary) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelSetType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSite := "[]*ObjectRefType{"
	for _, f := range this.Site {
		repeatedStringForSite += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSite += "}"
	repeatedStringForTunnels := "[]*TunnelType{"
	for _, f := range this.Tunnels {
		repeatedStringForTunnels += strings.Replace(f.String(), "TunnelType", "TunnelType", 1) + ","
	}
	repeatedStringForTunnels += "}"
	s := strings.Join([]string{`&TunnelSetType{`,
		`Site:` + repeatedStringForSite + `,`,
		`Tunnels:` + repeatedStringForTunnels + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPeerType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPeerType{`,
		`PeerChoice:` + fmt.Sprintf("%v", this.PeerChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPeerType_VnetPeer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPeerType_VnetPeer{`,
		`VnetPeer:` + strings.Replace(fmt.Sprintf("%v", this.VnetPeer), "AzureVnetPeer", "AzureVnetPeer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetPeer) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPeerNetwork := "[]*ObjectRefType{"
	for _, f := range this.PeerNetwork {
		repeatedStringForPeerNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForPeerNetwork += "}"
	s := strings.Join([]string{`&AzureVnetPeer{`,
		`PeerNetwork:` + repeatedStringForPeerNetwork + `,`,
		`PeeringState:` + fmt.Sprintf("%v", this.PeeringState) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSite := "[]*ObjectRefType{"
	for _, f := range this.Site {
		repeatedStringForSite += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSite += "}"
	repeatedStringForTgw := "[]*ObjectRefType{"
	for _, f := range this.Tgw {
		repeatedStringForTgw += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForTgw += "}"
	s := strings.Join([]string{`&TunnelType{`,
		`Connection:` + strings.Replace(fmt.Sprintf("%v", this.Connection), "TunnelConnectionStatus", "site.TunnelConnectionStatus", 1) + `,`,
		`Site:` + repeatedStringForSite + `,`,
		`Tgw:` + repeatedStringForTgw + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudPolicyType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudPolicyType{`,
		`CloudType:` + fmt.Sprintf("%v", this.CloudType) + `,`,
		`PermissionsPopulated:` + fmt.Sprintf("%v", this.PermissionsPopulated) + `,`,
		`CloudProviderError:` + fmt.Sprintf("%v", this.CloudProviderError) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudPolicyType_Aws) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudPolicyType_Aws{`,
		`Aws:` + strings.Replace(fmt.Sprintf("%v", this.Aws), "AWSPolicyType", "AWSPolicyType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSPolicyType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSPolicyType{`,
		`SupportAwsVpcSite:` + fmt.Sprintf("%v", this.SupportAwsVpcSite) + `,`,
		`MissingPermissionsAwsVpcSite:` + fmt.Sprintf("%v", this.MissingPermissionsAwsVpcSite) + `,`,
		`SupportAwsTgwSite:` + fmt.Sprintf("%v", this.SupportAwsTgwSite) + `,`,
		`MissingPermissionsAwsTgwSite:` + fmt.Sprintf("%v", this.MissingPermissionsAwsTgwSite) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureResourceGroupInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureResourceGroupInfo{`,
		`SiteRg:` + fmt.Sprintf("%v", this.SiteRg) + `,`,
		`VirtualNetworkRg:` + fmt.Sprintf("%v", this.VirtualNetworkRg) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProviderInfo) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCloudLink := "[]*ObjectRefType{"
	for _, f := range this.CloudLink {
		repeatedStringForCloudLink += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCloudLink += "}"
	s := strings.Join([]string{`&ProviderInfo{`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`GcpZones:` + fmt.Sprintf("%v", this.GcpZones) + `,`,
		`AzureRgInfo:` + strings.Replace(this.AzureRgInfo.String(), "AzureResourceGroupInfo", "AzureResourceGroupInfo", 1) + `,`,
		`CloudLink:` + repeatedStringForCloudLink + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *MetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creds = append(m.Creds, &schema.ObjectRefType{})
			if err := m.Creds[len(m.Creds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawJson = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderType", wireType)
			}
			m.ProviderType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProviderType |= ProviderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = append(m.Region, &schema.ObjectRefType{})
			if err := m.Region[len(m.Region)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CidrV4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CidrV4 = append(m.CidrV4, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CidrV6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CidrV6 = append(m.CidrV6, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkPeers = append(m.NetworkPeers, &schema.ObjectRefType{})
			if err := m.NetworkPeers[len(m.NetworkPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadBalancer = append(m.LoadBalancer, &LoadBalancer{})
			if err := m.LoadBalancer[len(m.LoadBalancer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadBalancer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadBalancer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadBalancer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = append(m.Network, &schema.ObjectRefType{})
			if err := m.Network[len(m.Network)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = append(m.Region, &schema.ObjectRefType{})
			if err := m.Region[len(m.Region)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CidrV4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CidrV4 = append(m.CidrV4, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CidrV6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CidrV6 = append(m.CidrV6, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceType", wireType)
			}
			m.InterfaceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceType |= InterfaceTypeEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interfaces = append(m.Interfaces, &NetworkInterfaceType{})
			if err := m.Interfaces[len(m.Interfaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Architecture = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			m.Cpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateDnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateDnsName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicDnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicDnsName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityGroup = append(m.SecurityGroup, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field F5XcNodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.F5XcNodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSTGWAttachment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSTGWAttachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSTGWAttachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cidr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cidr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssociatedRouteTableId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssociatedRouteTableId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssociationState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssociationState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudConnect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudConnect = append(m.CloudConnect, &schema.ObjectRefType{})
			if err := m.CloudConnect[len(m.CloudConnect)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Segment = append(m.Segment, &schema.ObjectRefType{})
			if err := m.Segment[len(m.Segment)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransitGatewayType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransitGatewayType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransitGatewayType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = append(m.Network, &schema.ObjectRefType{})
			if err := m.Network[len(m.Network)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoAcceptSharedAttachments", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoAcceptSharedAttachments = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsSupport", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DnsSupport = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpnEcmpSupport", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VpnEcmpSupport = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attachments = append(m.Attachments, &AWSTGWAttachment{})
			if err := m.Attachments[len(m.Attachments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnet = append(m.Subnet, &schema.ObjectRefType{})
			if err := m.Subnet[len(m.Subnet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = append(m.Network, &schema.ObjectRefType{})
			if err := m.Network[len(m.Network)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransitGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransitGateway = append(m.TransitGateway, &schema.ObjectRefType{})
			if err := m.TransitGateway[len(m.TransitGateway)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &RouteType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTableType", wireType)
			}
			m.RouteTableType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteTableType |= RouteTableTypeEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplicitSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImplicitSubnet = append(m.ImplicitSubnet, &schema.ObjectRefType{})
			if err := m.ImplicitSubnet[len(m.ImplicitSubnet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExplicitSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExplicitSubnet = append(m.ExplicitSubnet, &schema.ObjectRefType{})
			if err := m.ExplicitSubnet[len(m.ExplicitSubnet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTableState", wireType)
			}
			m.RouteTableState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteTableState |= RouteTableStateEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Associations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Associations = append(m.Associations, &AWSTGWAttachmentMetaData{})
			if err := m.Associations[len(m.Associations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Propagations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Propagations = append(m.Propagations, &AWSTGWAttachmentMetaData{})
			if err := m.Propagations[len(m.Propagations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSTGWAttachmentMetaData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSTGWAttachmentMetaData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSTGWAttachmentMetaData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPRouteAttributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPRouteAttributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPRouteAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeLimits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeLimits = append(m.ScopeLimits, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteType", wireType)
			}
			m.RouteType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteType |= GCPRouteType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSTgwRouteAttributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSTgwRouteAttributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSTgwRouteAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHopAttachment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextHopAttachment = append(m.NextHopAttachment, &AWSTGWAttachmentMetaData{})
			if err := m.NextHopAttachment[len(m.NextHopAttachment)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSRouteAttributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSRouteAttributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSRouteAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Propagated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Propagated = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tgw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tgw == nil {
				m.Tgw = &AWSTgwRouteAttributes{}
			}
			if err := m.Tgw.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nexthop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nexthop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= RouteSourceTypeEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= RouteStateTypeEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHopType", wireType)
			}
			m.NextHopType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextHopType |= RouteNextHopTypeEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDefinedRouteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserDefinedRouteName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aws", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSRouteAttributes{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudRouteAttributes = &RouteType_Aws{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gcp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPRouteAttributes{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudRouteAttributes = &RouteType_Gcp{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = append(m.Network, &schema.ObjectRefType{})
			if err := m.Network[len(m.Network)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tgw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tgw = append(m.Tgw, &schema.ObjectRefType{})
			if err := m.Tgw[len(m.Tgw)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DcClusterGroup = append(m.DcClusterGroup, &schema.ObjectRefType{})
			if err := m.DcClusterGroup[len(m.DcClusterGroup)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteType", wireType)
			}
			m.SiteType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteType |= site.SiteType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProviderInfo == nil {
				m.ProviderInfo = &ProviderInfo{}
			}
			if err := m.ProviderInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayType", wireType)
			}
			m.GatewayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GatewayType |= GatewayTypeEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppType", wireType)
			}
			m.AppType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppType |= SiteAppTypeEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteMeshGroupType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteMeshGroupType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteMeshGroupType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= site_mesh_group.SiteMeshGroupType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hub", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hub = append(m.Hub, &schema.ObjectRefType{})
			if err := m.Hub[len(m.Hub)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteType", wireType)
			}
			m.SiteType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteType |= site.SiteType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HubMesh", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &site_mesh_group.HubFullMeshGroupType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MeshChoice = &SiteMeshGroupType_HubMesh{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpokeMesh", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &site_mesh_group.SpokeMeshGroupType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MeshChoice = &SiteMeshGroupType_SpokeMesh{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullMesh", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &site_mesh_group.FullMeshGroupType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MeshChoice = &SiteMeshGroupType_FullMesh{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualSite = append(m.VirtualSite, &schema.ObjectRefType{})
			if err := m.VirtualSite[len(m.VirtualSite)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopologySite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopologySite = append(m.TopologySite, &schema.ObjectRefType{})
			if err := m.TopologySite[len(m.TopologySite)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DCClusterGroupType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DCClusterGroupType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DCClusterGroupType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &dc_cluster_group.DCClusterGroupMeshType{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnet = append(m.Subnet, &schema.ObjectRefType{})
			if err := m.Subnet[len(m.Subnet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateAddresses = append(m.PrivateAddresses, &AddressInfoType{})
			if err := m.PrivateAddresses[len(m.PrivateAddresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicAddress = append(m.PublicAddress, &AddressInfoType{})
			if err := m.PublicAddress[len(m.PublicAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityGroup = append(m.SecurityGroup, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field F5XcStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.F5XcStatus == nil {
				m.F5XcStatus = &site.InterfaceStatus{}
			}
			if err := m.F5XcStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Primary = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelSetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelSetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelSetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = append(m.Site, &schema.ObjectRefType{})
			if err := m.Site[len(m.Site)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tunnels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tunnels = append(m.Tunnels, &TunnelType{})
			if err := m.Tunnels[len(m.Tunnels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkPeerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkPeerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkPeerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnetPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureVnetPeer{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PeerChoice = &NetworkPeerType_VnetPeer{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetPeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerNetwork = append(m.PeerNetwork, &schema.ObjectRefType{})
			if err := m.PeerNetwork[len(m.PeerNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeeringState", wireType)
			}
			m.PeeringState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeeringState |= PeeringStateEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connection == nil {
				m.Connection = &site.TunnelConnectionStatus{}
			}
			if err := m.Connection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = append(m.Site, &schema.ObjectRefType{})
			if err := m.Site[len(m.Site)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tgw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tgw = append(m.Tgw, &schema.ObjectRefType{})
			if err := m.Tgw[len(m.Tgw)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudPolicyType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudPolicyType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudPolicyType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aws", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSPolicyType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudType = &CloudPolicyType_Aws{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermissionsPopulated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PermissionsPopulated = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudProviderError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudProviderError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSPolicyType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSPolicyType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSPolicyType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportAwsVpcSite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportAwsVpcSite = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingPermissionsAwsVpcSite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MissingPermissionsAwsVpcSite = append(m.MissingPermissionsAwsVpcSite, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportAwsTgwSite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportAwsTgwSite = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingPermissionsAwsTgwSite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MissingPermissionsAwsTgwSite = append(m.MissingPermissionsAwsTgwSite, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureResourceGroupInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureResourceGroupInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureResourceGroupInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteRg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteRg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetworkRg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualNetworkRg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpZones", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcpZones = append(m.GcpZones, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureRgInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AzureRgInfo == nil {
				m.AzureRgInfo = &AzureResourceGroupInfo{}
			}
			if err := m.AzureRgInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudLink", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudLink = append(m.CloudLink, &schema.ObjectRefType{})
			if err := m.CloudLink[len(m.CloudLink)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
