// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package topology

import (
	"bytes"
	"context"
	"fmt"
	io "io"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create CustomDataAPI GRPC Client satisfying server.CustomClient
type CustomDataAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient CustomDataAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *CustomDataAPIGrpcClient) doRPCDCClusterGroupsSummary(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &DCClusterGroupsSummaryRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.DCClusterGroupsSummaryRequest", yamlReq)
	}
	rsp, err := c.grpcClient.DCClusterGroupsSummary(ctx, req, opts...)
	return rsp, err
}

func (c *CustomDataAPIGrpcClient) doRPCDCClusterTopology(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &DCClusterTopologyRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.DCClusterTopologyRequest", yamlReq)
	}
	rsp, err := c.grpcClient.DCClusterTopology(ctx, req, opts...)
	return rsp, err
}

func (c *CustomDataAPIGrpcClient) doRPCGetRouteTable(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &RouteTableRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.RouteTableRequest", yamlReq)
	}
	rsp, err := c.grpcClient.GetRouteTable(ctx, req, opts...)
	return rsp, err
}

func (c *CustomDataAPIGrpcClient) doRPCSiteMeshGroupsSummary(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SiteMeshGroupsSummaryRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.SiteMeshGroupsSummaryRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SiteMeshGroupsSummary(ctx, req, opts...)
	return rsp, err
}

func (c *CustomDataAPIGrpcClient) doRPCSiteMeshTopology(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SiteMeshTopologyRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.SiteMeshTopologyRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SiteMeshTopology(ctx, req, opts...)
	return rsp, err
}

func (c *CustomDataAPIGrpcClient) doRPCSiteTopology(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SiteTopologyRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.SiteTopologyRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SiteTopology(ctx, req, opts...)
	return rsp, err
}

func (c *CustomDataAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func NewCustomDataAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &CustomDataAPIGrpcClient{
		conn:       cc,
		grpcClient: NewCustomDataAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["DCClusterGroupsSummary"] = ccl.doRPCDCClusterGroupsSummary

	rpcFns["DCClusterTopology"] = ccl.doRPCDCClusterTopology

	rpcFns["GetRouteTable"] = ccl.doRPCGetRouteTable

	rpcFns["SiteMeshGroupsSummary"] = ccl.doRPCSiteMeshGroupsSummary

	rpcFns["SiteMeshTopology"] = ccl.doRPCSiteMeshTopology

	rpcFns["SiteTopology"] = ccl.doRPCSiteTopology

	ccl.rpcFns = rpcFns

	return ccl
}

// Create CustomDataAPI REST Client satisfying server.CustomClient
type CustomDataAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *CustomDataAPIRestClient) doRPCDCClusterGroupsSummary(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &DCClusterGroupsSummaryRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.DCClusterGroupsSummaryRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &TopologyResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.topology.TopologyResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomDataAPIRestClient) doRPCDCClusterTopology(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &DCClusterTopologyRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.DCClusterTopologyRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("dc_cluster_group", fmt.Sprintf("%v", req.DcClusterGroup))
		q.Add("metric_selector", fmt.Sprintf("%v", req.MetricSelector))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &TopologyResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.topology.TopologyResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomDataAPIRestClient) doRPCGetRouteTable(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &RouteTableRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.RouteTableRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("name", fmt.Sprintf("%v", req.Name))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &RouteTableResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.topology.RouteTableResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomDataAPIRestClient) doRPCSiteMeshGroupsSummary(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SiteMeshGroupsSummaryRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.SiteMeshGroupsSummaryRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &TopologyResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.topology.TopologyResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomDataAPIRestClient) doRPCSiteMeshTopology(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SiteMeshTopologyRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.SiteMeshTopologyRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("metric_selector", fmt.Sprintf("%v", req.MetricSelector))
		q.Add("site_mesh_group", fmt.Sprintf("%v", req.SiteMeshGroup))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &TopologyResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.topology.TopologyResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomDataAPIRestClient) doRPCSiteTopology(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SiteTopologyRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.SiteTopologyRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("group_dc_cluster_nodes", fmt.Sprintf("%v", req.GroupDcClusterNodes))
		q.Add("group_site_mesh_nodes", fmt.Sprintf("%v", req.GroupSiteMeshNodes))
		q.Add("level", fmt.Sprintf("%v", req.Level))
		q.Add("metric_selector", fmt.Sprintf("%v", req.MetricSelector))
		q.Add("node_id", fmt.Sprintf("%v", req.NodeId))
		q.Add("site", fmt.Sprintf("%v", req.Site))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &TopologyResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.topology.TopologyResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomDataAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewCustomDataAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &CustomDataAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["DCClusterGroupsSummary"] = ccl.doRPCDCClusterGroupsSummary

	rpcFns["DCClusterTopology"] = ccl.doRPCDCClusterTopology

	rpcFns["GetRouteTable"] = ccl.doRPCGetRouteTable

	rpcFns["SiteMeshGroupsSummary"] = ccl.doRPCSiteMeshGroupsSummary

	rpcFns["SiteMeshTopology"] = ccl.doRPCSiteMeshTopology

	rpcFns["SiteTopology"] = ccl.doRPCSiteTopology

	ccl.rpcFns = rpcFns

	return ccl
}

// Create customDataAPIInprocClient

// INPROC Client (satisfying CustomDataAPIClient interface)
type customDataAPIInprocClient struct {
	CustomDataAPIServer
}

func (c *customDataAPIInprocClient) DCClusterGroupsSummary(ctx context.Context, in *DCClusterGroupsSummaryRequest, opts ...grpc.CallOption) (*TopologyResponse, error) {
	ctx = server.ContextFromInprocReq(ctx, "ves.io.schema.topology.CustomDataAPI.DCClusterGroupsSummary", nil)
	return c.CustomDataAPIServer.DCClusterGroupsSummary(ctx, in)
}
func (c *customDataAPIInprocClient) DCClusterTopology(ctx context.Context, in *DCClusterTopologyRequest, opts ...grpc.CallOption) (*TopologyResponse, error) {
	ctx = server.ContextFromInprocReq(ctx, "ves.io.schema.topology.CustomDataAPI.DCClusterTopology", nil)
	return c.CustomDataAPIServer.DCClusterTopology(ctx, in)
}
func (c *customDataAPIInprocClient) GetRouteTable(ctx context.Context, in *RouteTableRequest, opts ...grpc.CallOption) (*RouteTableResponse, error) {
	ctx = server.ContextFromInprocReq(ctx, "ves.io.schema.topology.CustomDataAPI.GetRouteTable", nil)
	return c.CustomDataAPIServer.GetRouteTable(ctx, in)
}
func (c *customDataAPIInprocClient) SiteMeshGroupsSummary(ctx context.Context, in *SiteMeshGroupsSummaryRequest, opts ...grpc.CallOption) (*TopologyResponse, error) {
	ctx = server.ContextFromInprocReq(ctx, "ves.io.schema.topology.CustomDataAPI.SiteMeshGroupsSummary", nil)
	return c.CustomDataAPIServer.SiteMeshGroupsSummary(ctx, in)
}
func (c *customDataAPIInprocClient) SiteMeshTopology(ctx context.Context, in *SiteMeshTopologyRequest, opts ...grpc.CallOption) (*TopologyResponse, error) {
	ctx = server.ContextFromInprocReq(ctx, "ves.io.schema.topology.CustomDataAPI.SiteMeshTopology", nil)
	return c.CustomDataAPIServer.SiteMeshTopology(ctx, in)
}
func (c *customDataAPIInprocClient) SiteTopology(ctx context.Context, in *SiteTopologyRequest, opts ...grpc.CallOption) (*TopologyResponse, error) {
	ctx = server.ContextFromInprocReq(ctx, "ves.io.schema.topology.CustomDataAPI.SiteTopology", nil)
	return c.CustomDataAPIServer.SiteTopology(ctx, in)
}

func NewCustomDataAPIInprocClient(svc svcfw.Service) CustomDataAPIClient {
	return &customDataAPIInprocClient{CustomDataAPIServer: NewCustomDataAPIServer(svc)}
}

// RegisterGwCustomDataAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwCustomDataAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterCustomDataAPIHandlerClient(ctx, mux, NewCustomDataAPIInprocClient(s))
}

// Create customDataAPISrv

// SERVER (satisfying CustomDataAPIServer interface)
type customDataAPISrv struct {
	svc svcfw.Service
}

func (s *customDataAPISrv) DCClusterGroupsSummary(ctx context.Context, in *DCClusterGroupsSummaryRequest) (*TopologyResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.topology.CustomDataAPI")
	cah, ok := ah.(CustomDataAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomDataAPIServer", ah)
	}

	var (
		rsp *TopologyResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.topology.DCClusterGroupsSummaryRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomDataAPI.DCClusterGroupsSummary' operation on 'topology'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.topology.CustomDataAPI.DCClusterGroupsSummary"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.DCClusterGroupsSummary(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.topology.TopologyResponse", rsp)...)

	return rsp, nil
}
func (s *customDataAPISrv) DCClusterTopology(ctx context.Context, in *DCClusterTopologyRequest) (*TopologyResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.topology.CustomDataAPI")
	cah, ok := ah.(CustomDataAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomDataAPIServer", ah)
	}

	var (
		rsp *TopologyResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.topology.DCClusterTopologyRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomDataAPI.DCClusterTopology' operation on 'topology'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.topology.CustomDataAPI.DCClusterTopology"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.DCClusterTopology(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.topology.TopologyResponse", rsp)...)

	return rsp, nil
}
func (s *customDataAPISrv) GetRouteTable(ctx context.Context, in *RouteTableRequest) (*RouteTableResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.topology.CustomDataAPI")
	cah, ok := ah.(CustomDataAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomDataAPIServer", ah)
	}

	var (
		rsp *RouteTableResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.topology.RouteTableRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomDataAPI.GetRouteTable' operation on 'topology'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.topology.CustomDataAPI.GetRouteTable"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetRouteTable(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.topology.RouteTableResponse", rsp)...)

	return rsp, nil
}
func (s *customDataAPISrv) SiteMeshGroupsSummary(ctx context.Context, in *SiteMeshGroupsSummaryRequest) (*TopologyResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.topology.CustomDataAPI")
	cah, ok := ah.(CustomDataAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomDataAPIServer", ah)
	}

	var (
		rsp *TopologyResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.topology.SiteMeshGroupsSummaryRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomDataAPI.SiteMeshGroupsSummary' operation on 'topology'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.topology.CustomDataAPI.SiteMeshGroupsSummary"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SiteMeshGroupsSummary(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.topology.TopologyResponse", rsp)...)

	return rsp, nil
}
func (s *customDataAPISrv) SiteMeshTopology(ctx context.Context, in *SiteMeshTopologyRequest) (*TopologyResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.topology.CustomDataAPI")
	cah, ok := ah.(CustomDataAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomDataAPIServer", ah)
	}

	var (
		rsp *TopologyResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.topology.SiteMeshTopologyRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomDataAPI.SiteMeshTopology' operation on 'topology'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.topology.CustomDataAPI.SiteMeshTopology"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SiteMeshTopology(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.topology.TopologyResponse", rsp)...)

	return rsp, nil
}
func (s *customDataAPISrv) SiteTopology(ctx context.Context, in *SiteTopologyRequest) (*TopologyResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.topology.CustomDataAPI")
	cah, ok := ah.(CustomDataAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomDataAPIServer", ah)
	}

	var (
		rsp *TopologyResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.topology.SiteTopologyRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomDataAPI.SiteTopology' operation on 'topology'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.topology.CustomDataAPI.SiteTopology"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SiteTopology(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.topology.TopologyResponse", rsp)...)

	return rsp, nil
}

func NewCustomDataAPIServer(svc svcfw.Service) CustomDataAPIServer {
	return &customDataAPISrv{svc: svc}
}

var CustomDataAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "Topology",
        "description": "APIs to get topology of all the resources associated/connected to a site such as other CEs (Customer Edge),\nREs (Regional Edge), VPCs (Virtual Private Cloud) networks, etc., and the associated metrics. Relationship between\nthe resources associated with a site is represented as a graph, where each resource/entity is represented as a node\n(example: CE, RE, VPC, Subnet, etc.,) and their association is represented as edge (example: CE - RE connection,\nNetwork - Subnets association, etc.,)",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/public/namespaces/system/topology/dc_cluster_group/{dc_cluster_group}": {
            "post": {
                "summary": "DC Cluster Topology",
                "description": "Get topology of a DC Cluster.",
                "operationId": "ves.io.schema.topology.CustomDataAPI.DCClusterTopology",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/topologyTopologyResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "dc_cluster_group",
                        "description": "DC Cluster group\n\nx-example: \"dcg-1\"\nName of the DC Cluster group",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "DC Cluster group"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/topologyDCClusterTopologyRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomDataAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-topology-customdataapi-dcclustertopology"
                },
                "x-ves-proto-rpc": "ves.io.schema.topology.CustomDataAPI.DCClusterTopology"
            },
            "x-displayname": "Topology APIs",
            "x-ves-proto-service": "ves.io.schema.topology.CustomDataAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/topology/dc_cluster_groups": {
            "get": {
                "summary": "DC Cluster Groups Summary",
                "description": "Get summary of all DC Cluster groups.",
                "operationId": "ves.io.schema.topology.CustomDataAPI.DCClusterGroupsSummary",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/topologyTopologyResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "tags": [
                    "CustomDataAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-topology-customdataapi-dcclustergroupssummary"
                },
                "x-ves-proto-rpc": "ves.io.schema.topology.CustomDataAPI.DCClusterGroupsSummary"
            },
            "x-displayname": "Topology APIs",
            "x-ves-proto-service": "ves.io.schema.topology.CustomDataAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/topology/route_table/{name}": {
            "get": {
                "summary": "Get Route Table",
                "description": "Get Route Table",
                "operationId": "ves.io.schema.topology.CustomDataAPI.GetRouteTable",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/topologyRouteTableResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "name",
                        "description": "Name\n\nx-required\nx-example: \"rt-1\"\nRoute table name",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Name"
                    }
                ],
                "tags": [
                    "CustomDataAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-topology-customdataapi-getroutetable"
                },
                "x-ves-proto-rpc": "ves.io.schema.topology.CustomDataAPI.GetRouteTable"
            },
            "x-displayname": "Topology APIs",
            "x-ves-proto-service": "ves.io.schema.topology.CustomDataAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/topology/site/{site}": {
            "post": {
                "summary": "Site Topology",
                "description": "Get topology of a site and the resources associated/connected to the site such as other Customer sites,\nRegional Sites, VPCs (Virtual Private Cloud) networks, etc., and the associated metrics.",
                "operationId": "ves.io.schema.topology.CustomDataAPI.SiteTopology",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/topologyTopologyResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "site",
                        "description": "Site\n\n\nx-example: \"ce01\"\nName of the site",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Site"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/topologySiteTopologyRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomDataAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-topology-customdataapi-sitetopology"
                },
                "x-ves-proto-rpc": "ves.io.schema.topology.CustomDataAPI.SiteTopology"
            },
            "x-displayname": "Topology APIs",
            "x-ves-proto-service": "ves.io.schema.topology.CustomDataAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/topology/site_mesh_group/{site_mesh_group}": {
            "post": {
                "summary": "Site Mesh Topology",
                "description": "Get topology of a site mesh.",
                "operationId": "ves.io.schema.topology.CustomDataAPI.SiteMeshTopology",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/topologyTopologyResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "site_mesh_group",
                        "description": "Site Mesh Group\n\n\nx-example: \"smg-1\"\nName of the site mesh group",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Site Mesh Group"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/topologySiteMeshTopologyRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomDataAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-topology-customdataapi-sitemeshtopology"
                },
                "x-ves-proto-rpc": "ves.io.schema.topology.CustomDataAPI.SiteMeshTopology"
            },
            "x-displayname": "Topology APIs",
            "x-ves-proto-service": "ves.io.schema.topology.CustomDataAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/topology/site_mesh_groups": {
            "get": {
                "summary": "Site Mesh Groups Summary",
                "description": "Get summary of all site mesh groups.",
                "operationId": "ves.io.schema.topology.CustomDataAPI.SiteMeshGroupsSummary",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/topologyTopologyResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "tags": [
                    "CustomDataAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-topology-customdataapi-sitemeshgroupssummary"
                },
                "x-ves-proto-rpc": "ves.io.schema.topology.CustomDataAPI.SiteMeshGroupsSummary"
            },
            "x-displayname": "Topology APIs",
            "x-ves-proto-service": "ves.io.schema.topology.CustomDataAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        }
    },
    "definitions": {
        "dc_cluster_groupDCClusterGroupMeshType": {
            "type": "object",
            "description": "Details of DC Cluster Group Mesh Type",
            "title": "DC Cluster Group Mesh Type",
            "x-displayname": "DC Cluster Group Mesh Type",
            "x-ves-oneof-field-dc_cluster_group_mesh_choice": "[\"control_and_data_plane_mesh\",\"data_plane_mesh\"]",
            "x-ves-proto-message": "ves.io.schema.dc_cluster_group.DCClusterGroupMeshType",
            "properties": {
                "control_and_data_plane_mesh": {
                    "description": "Exclusive with [data_plane_mesh]\n Full Mesh of data plane connectivity across sites\n and control plane peering across sites",
                    "title": "Control and Data Plane Mesh",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Control and Data Plane Mesh"
                },
                "data_plane_mesh": {
                    "description": "Exclusive with [control_and_data_plane_mesh]\n Full Mesh of Data plane connectivity across sites",
                    "title": "Data Plane Mesh",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Data Plane Mesh"
                }
            }
        },
        "ioschemaEmpty": {
            "type": "object",
            "description": "This can be used for messages where no values are needed",
            "title": "Empty",
            "x-displayname": "Empty",
            "x-ves-proto-message": "ves.io.schema.Empty"
        },
        "ioschemaObjectRefType": {
            "type": "object",
            "description": "This type establishes a 'direct reference' from one object(the referrer) to another(the referred).\nSuch a reference is in form of tenant/namespace/name for public API and Uid for private API\nThis type of reference is called direct because the relation is explicit and concrete (as opposed\nto selector reference which builds a group based on labels of selectee objects)",
            "title": "ObjectRefType",
            "x-displayname": "Object reference",
            "x-ves-proto-message": "ves.io.schema.ObjectRefType",
            "properties": {
                "kind": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then kind will hold the referred object's kind (e.g. \"route\")\n\nExample: - \"virtual_site\"-",
                    "title": "kind",
                    "x-displayname": "Kind",
                    "x-ves-example": "virtual_site"
                },
                "name": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then name will hold the referred object's(e.g. route's) name.\n\nExample: - \"contactus-route\"-",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "contactus-route"
                },
                "namespace": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then namespace will hold the referred object's(e.g. route's) namespace.\n\nExample: - \"ns1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1"
                },
                "tenant": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then tenant will hold the referred object's(e.g. route's) tenant.\n\nExample: - \"acmecorp\"-",
                    "title": "tenant",
                    "x-displayname": "Tenant",
                    "x-ves-example": "acmecorp"
                },
                "uid": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then uid will hold the referred object's(e.g. route's) uid.\n\nExample: - \"d15f1fad-4d37-48c0-8706-df1824d76d31\"-",
                    "title": "uid",
                    "x-displayname": "UID",
                    "x-ves-example": "d15f1fad-4d37-48c0-8706-df1824d76d31"
                }
            }
        },
        "schemaLabelSelectorType": {
            "type": "object",
            "description": "This type can be used to establish a 'selector reference' from one object(called selector) to\na set of other objects(called selectees) based on the value of expresssions.\nA label selector is a label query over a set of resources. An empty label selector matches all objects.\nA null label selector matches no objects. Label selector is immutable.\nexpressions is a list of strings of label selection expression.\nEach string has \",\" separated values which are \"AND\" and all strings are logically \"OR\".\nBNF for expression string\n\u003cselector-syntax\u003e         ::= \u003crequirement\u003e | \u003crequirement\u003e \",\" \u003cselector-syntax\u003e\n\u003crequirement\u003e             ::= [!] KEY [ \u003cset-based-restriction\u003e | \u003cexact-match-restriction\u003e ]\n\u003cset-based-restriction\u003e   ::= \"\" | \u003cinclusion-exclusion\u003e \u003cvalue-set\u003e\n\u003cinclusion-exclusion\u003e     ::= \u003cinclusion\u003e | \u003cexclusion\u003e\n\u003cexclusion\u003e               ::= \"notin\"\n\u003cinclusion\u003e               ::= \"in\"\n\u003cvalue-set\u003e               ::= \"(\" \u003cvalues\u003e \")\"\n\u003cvalues\u003e                  ::= VALUE | VALUE \",\" \u003cvalues\u003e\n\u003cexact-match-restriction\u003e ::= [\"=\"|\"==\"|\"!=\"] VALUE",
            "title": "LabelSelectorType",
            "x-displayname": "Label Selector",
            "x-ves-proto-message": "ves.io.schema.LabelSelectorType",
            "properties": {
                "expressions": {
                    "type": "array",
                    "description": " expressions contains the kubernetes style label expression for selections.\n\nExample: - \"region in (us-west1, us-west2),tier in (staging)\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.string.k8s_label_selector: true\n  ves.io.schema.rules.repeated.items.string.max_len: 4096\n  ves.io.schema.rules.repeated.items.string.min_len: 1\n  ves.io.schema.rules.repeated.max_items: 1\n",
                    "title": "expressions",
                    "maxItems": 1,
                    "items": {
                        "type": "string",
                        "minLength": 1,
                        "maxLength": 4096
                    },
                    "x-displayname": "Selector Expression",
                    "x-ves-example": "region in (us-west1, us-west2),tier in (staging)",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.string.k8s_label_selector": "true",
                        "ves.io.schema.rules.repeated.items.string.max_len": "4096",
                        "ves.io.schema.rules.repeated.items.string.min_len": "1",
                        "ves.io.schema.rules.repeated.max_items": "1"
                    }
                }
            }
        },
        "schemaMetricValue": {
            "type": "object",
            "description": "Metric data contains timestamp and the value.",
            "title": "Metric Value",
            "x-displayname": "Metric Value",
            "x-ves-proto-message": "ves.io.schema.MetricValue",
            "properties": {
                "timestamp": {
                    "type": "number",
                    "description": " timestamp\n\nExample: - \"1570007981\"-",
                    "title": "Timestamp",
                    "format": "double",
                    "x-displayname": "Timestamp",
                    "x-ves-example": "1570007981"
                },
                "trend_value": {
                    "description": " trend value for the metric\n\nExample: - \"100.000000\"-",
                    "title": "Trend value",
                    "$ref": "#/definitions/schemaTrendValue",
                    "x-displayname": "Trend Value",
                    "x-ves-example": "100.000000"
                },
                "value": {
                    "type": "string",
                    "description": "\n\nExample: - \"15\"-",
                    "title": "Value",
                    "x-displayname": "Value",
                    "x-ves-example": "15"
                }
            }
        },
        "schemaTrendSentiment": {
            "type": "string",
            "description": "trend sentiment\n\nIndicates trend sentiment is positive\nIndicates trend sentiment is negative.",
            "title": "Trend Sentiment",
            "enum": [
                "TREND_SENTIMENT_NONE",
                "TREND_SENTIMENT_POSITIVE",
                "TREND_SENTIMENT_NEGATIVE"
            ],
            "default": "TREND_SENTIMENT_NONE",
            "x-displayname": "Trend Sentiment",
            "x-ves-proto-enum": "ves.io.schema.TrendSentiment"
        },
        "schemaTrendValue": {
            "type": "object",
            "description": "Trend value contains trend value, trend sentiment and trend calculation description and window size.",
            "title": "Trend Value",
            "x-displayname": "Trend Value",
            "x-ves-proto-message": "ves.io.schema.TrendValue",
            "properties": {
                "description": {
                    "type": "string",
                    "description": " description of the method used to calculate trend.\n\nExample: - \"Trend was calculated by comparing the avg of window size intervals of end-start Time and last window time interval\"-",
                    "title": "Description",
                    "x-displayname": "Description",
                    "x-ves-example": "Trend was calculated by comparing the avg of window size intervals of end-start Time and last window time interval"
                },
                "previous_value": {
                    "type": "string",
                    "description": "\n\nExample: - \"200.00\"-",
                    "title": "Previous Value",
                    "x-displayname": "Previous Value",
                    "x-ves-example": "200.00"
                },
                "sentiment": {
                    "description": "\n\nExample: - \"Positive\"-",
                    "title": "Sentiment",
                    "$ref": "#/definitions/schemaTrendSentiment",
                    "x-displayname": "Sentiment",
                    "x-ves-example": "Positive"
                },
                "value": {
                    "type": "string",
                    "description": "\n\nExample: - \"-15\"-",
                    "title": "Value",
                    "x-displayname": "Value",
                    "x-ves-example": "-15"
                }
            }
        },
        "schemaUnitType": {
            "type": "string",
            "description": "UnitType is enumeration of units for scalar fields",
            "title": "UnitType",
            "enum": [
                "UNIT_MILLISECONDS",
                "UNIT_SECONDS",
                "UNIT_MINUTES",
                "UNIT_HOURS",
                "UNIT_DAYS",
                "UNIT_BYTES",
                "UNIT_KBYTES",
                "UNIT_MBYTES",
                "UNIT_GBYTES",
                "UNIT_TBYTES",
                "UNIT_KIBIBYTES",
                "UNIT_MIBIBYTES",
                "UNIT_GIBIBYTES",
                "UNIT_TEBIBYTES",
                "UNIT_BITS_PER_SECOND",
                "UNIT_BYTES_PER_SECOND",
                "UNIT_KBITS_PER_SECOND",
                "UNIT_KBYTES_PER_SECOND",
                "UNIT_MBITS_PER_SECOND",
                "UNIT_MBYTES_PER_SECOND",
                "UNIT_CONNECTIONS_PER_SECOND",
                "UNIT_ERRORS_PER_SECOND",
                "UNIT_PACKETS_PER_SECOND",
                "UNIT_REQUESTS_PER_SECOND",
                "UNIT_PACKETS",
                "UNIT_PERCENTAGE",
                "UNIT_COUNT"
            ],
            "default": "UNIT_MILLISECONDS",
            "x-displayname": "Unit",
            "x-ves-proto-enum": "ves.io.schema.UnitType"
        },
        "schemasiteSiteType": {
            "type": "string",
            "description": "Site Type which can either RE or CE\n\nInvalid type of site\nRegional Edge site\nCustomer Edge site",
            "title": "SiteType",
            "enum": [
                "INVALID",
                "REGIONAL_EDGE",
                "CUSTOMER_EDGE"
            ],
            "default": "INVALID",
            "x-displayname": "Site Type",
            "x-ves-proto-enum": "ves.io.schema.site.SiteType"
        },
        "schemasite_mesh_groupSiteMeshGroupType": {
            "type": "string",
            "description": "Defines different types of Mesh\n\nInvalid mesh type\nMesh of type Hub\nMesh of type Spoke\nFull mesh of tunnels are created between all sites",
            "title": "Site Mesh Group Type",
            "enum": [
                "SITE_MESH_GROUP_TYPE_INVALID",
                "SITE_MESH_GROUP_TYPE_HUB_FULL_MESH",
                "SITE_MESH_GROUP_TYPE_SPOKE",
                "SITE_MESH_GROUP_TYPE_FULL_MESH"
            ],
            "default": "SITE_MESH_GROUP_TYPE_INVALID",
            "x-displayname": "Mesh Type",
            "x-ves-proto-enum": "ves.io.schema.site_mesh_group.SiteMeshGroupType"
        },
        "schematopologyLinkType": {
            "type": "string",
            "description": "Enumerates the association/relationship between 2 nodes.\n\nIndicates that 2 nodes are connected using a tunnel\nIndicates network connection\nIndicates connection to subnet\nIndicates connection to instance\nIndicates association with site mesh group\nIndicates association with DC Cluster group\nIndicates L3 connection between the nodes\nIndicates the Control plane connection between the nodes\nIndicates the BGP connection between the tgw and site",
            "title": "LinkType",
            "enum": [
                "LINK_TYPE_TUNNEL",
                "LINK_TYPE_NETWORK",
                "LINK_TYPE_SUBNET",
                "LINK_TYPE_INSTANCE",
                "LINK_TYPE_SITE_MESH_GROUP",
                "LINK_TYPE_DC_CLUSTER_GROUP",
                "LINK_TYPE_L3",
                "LINK_TYPE_CONTROL_PLANE",
                "LINK_TYPE_BGP_CONNECTION"
            ],
            "default": "LINK_TYPE_TUNNEL",
            "x-displayname": "Link Type",
            "x-ves-proto-enum": "ves.io.schema.topology.LinkType"
        },
        "schematopologyMetricType": {
            "type": "string",
            "description": "List of metric types applicable for the nodes and edges in the topology graph.\nNot all metric types are applicable for all nodes or edges. For example, LATENCY metric\nis applicable only for the edges where both the vertices are sites and CPU_USAGE metric is\napplicable only for node of type instance. This list is a union of all metric types.\n\nTotal incoming traffic in bytes\nTotal outgoing traffic in bytes\nTotal incoming packets dropped\nTotal outgoing packets dropped\nReachability based on probes sent periodically\nAverage latency in seconds\nAverage CPU utilization in percentage\nAverage Memory utilization in percentage\nAverage Disk utilization in percentage\nConnection status of the tunnel\nControl plane connection status of the tunnel",
            "title": "Metric Type",
            "enum": [
                "METRIC_TYPE_IN_BYTES",
                "METRIC_TYPE_OUT_BYTES",
                "METRIC_TYPE_IN_DROP_PACKETS",
                "METRIC_TYPE_OUT_DROP_PACKETS",
                "METRIC_TYPE_REACHABILITY_PERCENT",
                "METRIC_TYPE_LATENCY_SECONDS",
                "METRIC_TYPE_CPU_USAGE_PERCENT",
                "METRIC_TYPE_MEMORY_USAGE_PERCENT",
                "METRIC_TYPE_DISK_USAGE_PERCENT",
                "METRIC_TYPE_DATA_PLANE_CONNECTION_STATUS",
                "METRIC_TYPE_CONTROL_PLANE_CONNECTION_STATUS"
            ],
            "default": "METRIC_TYPE_IN_BYTES",
            "x-displayname": "Metric Type",
            "x-ves-proto-enum": "ves.io.schema.topology.MetricType"
        },
        "schematopologyMetricTypeData": {
            "type": "object",
            "description": "Metric Type Data contains key that uniquely identifies individual entity and its corresponding metric values.\nFor example, if an instance contains multiple interfaces, then the key contains the name/value pair that identifies\nthe interface name of the instance.",
            "title": "Metric Type Data",
            "x-displayname": "Metric Type Data",
            "x-ves-proto-message": "ves.io.schema.topology.MetricTypeData",
            "properties": {
                "labels": {
                    "type": "object",
                    "description": " Labels contains the name/value pair that uniquely identifies an entity whose metric is being reported.\n If the Labels is empty, then the metric value is for the corresponding node or edge.\n For example, if an instance contains multiple interfaces, then the labels contains the name/value pairs that identifies\n the interface name of the instance.",
                    "title": "Labels",
                    "x-displayname": "Labels"
                },
                "values": {
                    "type": "array",
                    "description": " List of metric values. May contain more than one value if timeseries data is requested.",
                    "title": "Value",
                    "items": {
                        "$ref": "#/definitions/schemaMetricValue"
                    },
                    "x-displayname": "Value"
                }
            }
        },
        "schematopologyNode": {
            "type": "object",
            "description": "Canonical representation of Node in the topology graph.",
            "title": "Node",
            "x-displayname": "Node",
            "x-ves-oneof-field-node_type": "[\"dc_cluster_group\",\"instance\",\"network\",\"site\",\"site_mesh_group\",\"subnet\",\"transit_gateway\"]",
            "x-ves-proto-message": "ves.io.schema.topology.Node",
            "properties": {
                "dc_cluster_group": {
                    "description": "Exclusive with [instance network site site_mesh_group subnet transit_gateway]\n DC Cluster Group data.",
                    "title": "DC Cluster Group",
                    "$ref": "#/definitions/topologyNodeTypeDCClusterGroup",
                    "x-displayname": "DC Cluster Group"
                },
                "id": {
                    "type": "string",
                    "description": " Identifier for the node.",
                    "title": "Id",
                    "x-displayname": "Id"
                },
                "instance": {
                    "description": "Exclusive with [dc_cluster_group network site site_mesh_group subnet transit_gateway]\n Instance data.",
                    "title": "Instance",
                    "$ref": "#/definitions/topologyNodeTypeInstance",
                    "x-displayname": "Instance"
                },
                "metadata": {
                    "description": " Metadata for the node.",
                    "title": "Metadata",
                    "$ref": "#/definitions/topologyNodeMetaData",
                    "x-displayname": "Metadata"
                },
                "network": {
                    "description": "Exclusive with [dc_cluster_group instance site site_mesh_group subnet transit_gateway]\n Network data.",
                    "title": "Network",
                    "$ref": "#/definitions/topologyNodeTypeNetwork",
                    "x-displayname": "Network"
                },
                "site": {
                    "description": "Exclusive with [dc_cluster_group instance network site_mesh_group subnet transit_gateway]\n Site data.",
                    "title": "Site",
                    "$ref": "#/definitions/topologyNodeTypeSite",
                    "x-displayname": "Site"
                },
                "site_mesh_group": {
                    "description": "Exclusive with [dc_cluster_group instance network site subnet transit_gateway]\n Site Mesh Group data.",
                    "title": "Site Mesh Group",
                    "$ref": "#/definitions/topologyNodeTypeSiteMeshGroup",
                    "x-displayname": "Site Mesh Group"
                },
                "subnet": {
                    "description": "Exclusive with [dc_cluster_group instance network site site_mesh_group transit_gateway]\n Subnet data.",
                    "title": "Subnet",
                    "$ref": "#/definitions/topologyNodeTypeSubnet",
                    "x-displayname": "Subnet"
                },
                "transit_gateway": {
                    "description": "Exclusive with [dc_cluster_group instance network site site_mesh_group subnet]\n Transit Gateway data.",
                    "title": "Transit Gateway",
                    "$ref": "#/definitions/topologyNodeTypeTransitGateway",
                    "x-displayname": "Transit Gateway"
                }
            }
        },
        "schematopologySiteMeshGroupType": {
            "type": "object",
            "description": "A canonical form of the site mesh group.",
            "title": "Site Mesh Group",
            "x-displayname": "site Mesh Group",
            "x-ves-oneof-field-mesh_choice": "[\"full_mesh\",\"hub_mesh\",\"spoke_mesh\"]",
            "x-ves-proto-message": "ves.io.schema.topology.SiteMeshGroupType",
            "properties": {
                "full_mesh": {
                    "description": "Exclusive with [hub_mesh spoke_mesh]\n Full mesh of tunnels are created between all sites",
                    "title": "full_mesh",
                    "$ref": "#/definitions/site_mesh_groupFullMeshGroupType",
                    "x-displayname": "Full Mesh"
                },
                "hub": {
                    "type": "array",
                    "description": " If 'Type' is Spoke, 'Hub' refers to a Site Mesh Group of 'type' Hub.\n Spoke sites connect to all the member sites of Hub Site Mesh Group.\n Hub will be empty when Site Mesh Group type is Hub or Full Mesh.",
                    "title": "Hub",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Hub (site mesh group)"
                },
                "hub_mesh": {
                    "description": "Exclusive with [full_mesh spoke_mesh]\n Mesh of Type Hub",
                    "title": "hub",
                    "$ref": "#/definitions/site_mesh_groupHubFullMeshGroupType",
                    "x-displayname": "Hub"
                },
                "site_selector": {
                    "description": " Label selector for virtual site",
                    "title": "Site Selector",
                    "$ref": "#/definitions/schemaLabelSelectorType",
                    "x-displayname": "Site Selector Expression"
                },
                "site_type": {
                    "description": " Site type for sites in the virtual site",
                    "title": "site_type",
                    "$ref": "#/definitions/schemasiteSiteType",
                    "x-displayname": "Site Type"
                },
                "spoke_mesh": {
                    "description": "Exclusive with [full_mesh hub_mesh]\n Mesh of Type Spoke",
                    "title": "spoke",
                    "$ref": "#/definitions/site_mesh_groupSpokeMeshGroupType",
                    "x-displayname": "Spoke"
                },
                "type": {
                    "description": " Site Mesh Group Type",
                    "title": "Type",
                    "$ref": "#/definitions/schemasite_mesh_groupSiteMeshGroupType",
                    "x-displayname": "Type"
                }
            }
        },
        "schematopologySiteType": {
            "type": "object",
            "description": "A canonical form of the site.",
            "title": "Site",
            "x-displayname": "site",
            "x-ves-proto-message": "ves.io.schema.topology.SiteType",
            "properties": {
                "dc_cluster_group": {
                    "type": "array",
                    "description": " Reference to the DC Cluster group",
                    "title": "DC Cluster Group",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "DC Cluster Group"
                },
                "network": {
                    "type": "array",
                    "description": " Reference to the network.",
                    "title": "Network",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Network"
                },
                "site_type": {
                    "description": " Site type indicates whether the site is CUSTOMER_EDGE or REGIONAL_EDGE",
                    "title": "Site type",
                    "$ref": "#/definitions/schemasiteSiteType",
                    "x-displayname": "Site Type"
                },
                "tgw": {
                    "type": "array",
                    "description": " Reference to the transit gateway",
                    "title": "TransitGateway",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "TransitGateway"
                }
            }
        },
        "schemaviewsObjectRefType": {
            "type": "object",
            "description": "This type establishes a direct reference from one object(the referrer) to another(the referred).\nSuch a reference is in form of tenant/namespace/name",
            "title": "ObjectRefType",
            "x-displayname": "Object reference",
            "x-ves-proto-message": "ves.io.schema.views.ObjectRefType",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then name will hold the referred object's(e.g. route's) name.\n\nExample: - \"contacts-route\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 128\n  ves.io.schema.rules.string.min_bytes: 1\n",
                    "title": "name",
                    "minLength": 1,
                    "maxLength": 128,
                    "x-displayname": "Name",
                    "x-ves-example": "contacts-route",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "128",
                        "ves.io.schema.rules.string.min_bytes": "1"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then namespace will hold the referred object's(e.g. route's) namespace.\n\nExample: - \"ns1\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 64\n",
                    "title": "namespace",
                    "maxLength": 64,
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "64"
                    }
                },
                "tenant": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then tenant will hold the referred object's(e.g. route's) tenant.\n\nExample: - \"acmecorp\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 64\n",
                    "title": "tenant",
                    "maxLength": 64,
                    "x-displayname": "Tenant",
                    "x-ves-example": "acmecorp",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "64"
                    }
                }
            }
        },
        "site_mesh_groupFullMeshGroupType": {
            "type": "object",
            "description": "Details of Full Mesh Group Type",
            "title": "Full Mesh Group Type",
            "x-displayname": "Full Mesh",
            "x-ves-oneof-field-full_mesh_choice": "[\"control_and_data_plane_mesh\",\"data_plane_mesh\"]",
            "x-ves-proto-message": "ves.io.schema.site_mesh_group.FullMeshGroupType",
            "properties": {
                "control_and_data_plane_mesh": {
                    "description": "Exclusive with [data_plane_mesh]\n Full mesh of data plane tunnels across sites\n and control plane peering across sites",
                    "title": "Control and Data Plane Mesh",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Control and Data Plane Mesh"
                },
                "data_plane_mesh": {
                    "description": "Exclusive with [control_and_data_plane_mesh]\n Full Mesh of data plane tunnels across sites",
                    "title": "Data Plane Mesh",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Data Plane Mesh"
                }
            }
        },
        "site_mesh_groupHubFullMeshGroupType": {
            "type": "object",
            "description": "Details of Hub Full Mesh Group Type",
            "title": "Hub Full Mesh Group Type",
            "x-displayname": "Hub Full Mesh",
            "x-ves-oneof-field-hub_full_mesh_choice": "[\"control_and_data_plane_mesh\",\"data_plane_mesh\"]",
            "x-ves-proto-message": "ves.io.schema.site_mesh_group.HubFullMeshGroupType",
            "properties": {
                "control_and_data_plane_mesh": {
                    "description": "Exclusive with [data_plane_mesh]\n Hub Full mesh of data plane tunnels across sites\n and control plane peering across sites",
                    "title": "Control and Data Plane Mesh",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Control and Data Plane Mesh"
                },
                "data_plane_mesh": {
                    "description": "Exclusive with [control_and_data_plane_mesh]\n Hub Full Mesh of data plane tunnels across sites",
                    "title": "Data Plane Mesh",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Data Plane Mesh"
                }
            }
        },
        "site_mesh_groupSpokeMeshGroupType": {
            "type": "object",
            "description": "Details of Spoke Mesh Group Type",
            "title": "Spoke Mesh Group Type",
            "x-displayname": "Spoke",
            "x-ves-oneof-field-spoke_hub_mesh_choice": "[\"control_and_data_plane_mesh\",\"data_plane_mesh\"]",
            "x-ves-proto-message": "ves.io.schema.site_mesh_group.SpokeMeshGroupType",
            "properties": {
                "control_and_data_plane_mesh": {
                    "description": "Exclusive with [data_plane_mesh]\n Mesh of data plane tunnels to the hub site/s\n and control plane peering with the hub site/s",
                    "title": "Control and Data Plane Mesh",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Control and Data Plane Mesh"
                },
                "data_plane_mesh": {
                    "description": "Exclusive with [control_and_data_plane_mesh]\n Mesh of data plane tunnels to the hub site/s",
                    "title": "Data Plane Mesh",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Data Plane Mesh"
                },
                "hub_mesh_group": {
                    "description": " 'hub_mesh_group' refers to a Site Mesh Group of 'type' Hub.\n Spoke sites will connect to all the member sites of Hub Site Mesh Group\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "hub_mesh_group",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "hub_mesh_group (site mesh group)",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "topologyAddressInfoType": {
            "type": "object",
            "description": "Address with additional information",
            "title": "Address Info Type",
            "x-displayname": "Address Info Type",
            "x-ves-proto-message": "ves.io.schema.topology.AddressInfoType",
            "properties": {
                "address": {
                    "type": "string",
                    "description": " Address",
                    "title": "Address",
                    "x-displayname": "Address"
                },
                "dns_name": {
                    "type": "string",
                    "description": " Address type",
                    "title": "DNS Name",
                    "x-displayname": "Public Address"
                },
                "primary": {
                    "type": "boolean",
                    "description": " Indicate this address is primary or not",
                    "title": "Primary",
                    "format": "boolean",
                    "x-displayname": "Primary"
                }
            }
        },
        "topologyDCClusterGroupSummaryInfo": {
            "type": "object",
            "description": "Summary information related to the DC Cluster Group",
            "title": "DCClusterGroupSummaryInfo",
            "x-displayname": "DC Cluster Group Summary",
            "x-ves-proto-message": "ves.io.schema.topology.DCClusterGroupSummaryInfo",
            "properties": {
                "sites": {
                    "type": "integer",
                    "description": " This field indicates the number of sites that are part of this DC Cluster group.",
                    "title": "Sites",
                    "format": "int64",
                    "x-displayname": "Sites"
                }
            }
        },
        "topologyDCClusterGroupType": {
            "type": "object",
            "description": "A canonical form of the DC cluster group.",
            "title": "DC Cluster Group",
            "x-displayname": "DC Cluster Group",
            "x-ves-proto-message": "ves.io.schema.topology.DCClusterGroupType",
            "properties": {
                "type": {
                    "$ref": "#/definitions/dc_cluster_groupDCClusterGroupMeshType"
                }
            }
        },
        "topologyDCClusterTopologyRequest": {
            "type": "object",
            "description": "Request to get DC Cluster group topology and the associated metrics.",
            "title": "DC Cluster Group Topology Request",
            "x-displayname": "DC Cluster Group Topology Request",
            "x-ves-proto-message": "ves.io.schema.topology.DCClusterTopologyRequest",
            "properties": {
                "dc_cluster_group": {
                    "type": "string",
                    "description": " Name of the DC Cluster group\n\nExample: - \"dcg-1\"-",
                    "title": "DC Cluster group",
                    "x-displayname": "DC Cluster group",
                    "x-ves-example": "dcg-1"
                },
                "metric_selector": {
                    "description": " Metric fields to be returned in the response. If no metric fields are specified in the request,\n then the response will not contain any metric data.",
                    "title": "Metric Selector",
                    "$ref": "#/definitions/topologyMetricSelector",
                    "x-displayname": "Metric Selector"
                }
            }
        },
        "topologyEdge": {
            "type": "object",
            "description": "Canonical representation of Edge in the topology graph.",
            "title": "Edge",
            "x-displayname": "Edge",
            "x-ves-proto-message": "ves.io.schema.topology.Edge",
            "properties": {
                "links": {
                    "type": "array",
                    "description": " An edge may be composed of multiple links.\n For example, there may be multiple tunnels between a transit gateway and a site and each tunnel\n is represented as individual links. In some cases, we may want to show only one link between 2 nodes,\n eventhough there may be multiple connections/tunnels between these nodes.",
                    "title": "Links",
                    "items": {
                        "$ref": "#/definitions/topologyLinkTypeData"
                    },
                    "x-displayname": "Links"
                },
                "node_id1": {
                    "type": "string",
                    "description": " Node identifier.",
                    "title": "Node Id1",
                    "x-displayname": "Node Id1"
                },
                "node_id2": {
                    "type": "string",
                    "description": " Node identifier.",
                    "title": "Node Id2",
                    "x-displayname": "Node Id2"
                },
                "status": {
                    "description": " Indicates the overall status of the edge.\n An edge may be have multiple links (dataplane tunnels, control plane connections).\n The status of an edge indicates the overall health of the edge.",
                    "title": "Status",
                    "$ref": "#/definitions/topologyLinkStatus",
                    "x-displayname": "Status"
                }
            }
        },
        "topologyEdgeInfoSummary": {
            "type": "object",
            "description": "Summary information for an edge",
            "title": "EdgeInfoSummary",
            "x-displayname": "Edge Info Summary",
            "x-ves-proto-message": "ves.io.schema.topology.EdgeInfoSummary",
            "properties": {
                "count": {
                    "type": "integer",
                    "description": " Links count.",
                    "title": "Count",
                    "format": "int64",
                    "x-displayname": "Count"
                },
                "status": {
                    "description": " Edge status.",
                    "title": "Status",
                    "$ref": "#/definitions/topologyLinkStatus",
                    "x-displayname": "Status"
                }
            }
        },
        "topologyInstanceType": {
            "type": "object",
            "description": "A canonical form of the instance.",
            "title": "Instance",
            "x-displayname": "instance",
            "x-ves-proto-message": "ves.io.schema.topology.InstanceType",
            "properties": {
                "architecture": {
                    "type": "string",
                    "description": " Architecture",
                    "title": "Architecture",
                    "x-displayname": "Architecture"
                },
                "availability_zone": {
                    "type": "string",
                    "description": " Availability Zone",
                    "title": "Availability Zone",
                    "x-displayname": "Availability Zone"
                },
                "cpu": {
                    "type": "integer",
                    "description": " CPU Count",
                    "title": "CPU",
                    "format": "int64",
                    "x-displayname": "CPU Count"
                },
                "instance_type": {
                    "type": "string",
                    "description": " Instance type",
                    "title": "Instance type",
                    "x-displayname": "Instance type"
                },
                "interfaces": {
                    "type": "array",
                    "description": " A list of network interfaces",
                    "title": "Interfaces",
                    "items": {
                        "$ref": "#/definitions/topologyNetworkInterfaceType"
                    },
                    "x-displayname": "Network Interfaces"
                },
                "platform": {
                    "type": "string",
                    "description": " Platform",
                    "title": "Platform",
                    "x-displayname": "Platform"
                },
                "private_address": {
                    "type": "string",
                    "description": " Private Address",
                    "title": "Private addresse",
                    "x-displayname": "Private Address"
                },
                "private_dns_name": {
                    "type": "string",
                    "description": " Private DNS Name",
                    "title": "Private DNS Name",
                    "x-displayname": "Private DNS Name"
                },
                "public_address": {
                    "type": "string",
                    "description": " Public address",
                    "title": "Public address",
                    "x-displayname": "Public Address"
                },
                "public_dns_name": {
                    "type": "string",
                    "description": " Public DNS Name",
                    "title": "Public DNS Name",
                    "x-displayname": "Public DNS Name"
                },
                "security_group": {
                    "type": "array",
                    "description": " Security groups",
                    "title": "Security Groups",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Security Groups"
                }
            }
        },
        "topologyInterfaceTypeEnum": {
            "type": "string",
            "description": " - INSIDE: INSIDE Interface\n\n - WORKLOAD: Workload Interface\n\n - NOT_APPLICABLE: NOT_APPLICABLE\n\nEx - When the subnet belongs to a azure spoke vnet",
            "title": "- OUTSIDE: OUTSIDE Interface",
            "enum": [
                "OUTSIDE",
                "INSIDE",
                "WORKLOAD",
                "NOT_APPLICABLE"
            ],
            "default": "OUTSIDE",
            "x-displayname": "",
            "x-ves-proto-enum": "ves.io.schema.topology.InterfaceTypeEnum"
        },
        "topologyLinkInfo": {
            "type": "object",
            "description": "Information about the link that connects 2 nodes in the topology graph.",
            "title": "LinkInfo",
            "x-displayname": "Link Info",
            "x-ves-proto-message": "ves.io.schema.topology.LinkInfo",
            "properties": {
                "dst_id": {
                    "type": "string",
                    "description": " Endpoint identifier. dst_id is the destination endpoint for the link is between src_id and dst_id.\n\nExample: - \"master-0\"-",
                    "title": "Destination ID",
                    "x-displayname": "Destination ID",
                    "x-ves-example": "master-0"
                },
                "name": {
                    "type": "string",
                    "description": " Name of the link.\n Link name may or may not be present depending on the type of link.\n\nExample: - \"tunnel-1\"-",
                    "title": "Name",
                    "x-displayname": "Name",
                    "x-ves-example": "tunnel-1"
                },
                "src_id": {
                    "type": "string",
                    "description": " Endpoint identifier. src_id is the source endpoint for the link is between src_id and dst_id.\n\nExample: - \"master-0\"-",
                    "title": "Source ID",
                    "x-displayname": "Source ID",
                    "x-ves-example": "master-0"
                },
                "status": {
                    "description": " Link status.",
                    "title": "Status",
                    "$ref": "#/definitions/topologyLinkStatus",
                    "x-displayname": "Status"
                },
                "type": {
                    "description": " Link type.",
                    "title": "Type",
                    "$ref": "#/definitions/schematopologyLinkType",
                    "x-displayname": "Type"
                }
            }
        },
        "topologyLinkInfoSummary": {
            "type": "object",
            "description": "Summary information for a link type",
            "title": "LinkInfoSummary",
            "x-displayname": "Link Info Summary",
            "x-ves-proto-message": "ves.io.schema.topology.LinkInfoSummary",
            "properties": {
                "count": {
                    "type": "integer",
                    "description": " Links count.",
                    "title": "Count",
                    "format": "int64",
                    "x-displayname": "Count"
                },
                "status": {
                    "description": " Link status.",
                    "title": "Status",
                    "$ref": "#/definitions/topologyLinkStatus",
                    "x-displayname": "Status"
                },
                "type": {
                    "description": " Link type.",
                    "title": "Type",
                    "$ref": "#/definitions/schematopologyLinkType",
                    "x-displayname": "Type"
                }
            }
        },
        "topologyLinkStatus": {
            "type": "string",
            "description": "Enumerates link status.\n\nStatus not applicable for this link\nStatus unknown for this link\nIndicates status up/active\nIndicates status down/inactive",
            "title": "LinkStatus",
            "enum": [
                "LINK_STATUS_NOT_APPLICABLE",
                "LINK_STATUS_UNKNOWN",
                "LINK_STATUS_UP",
                "LINK_STATUS_DOWN"
            ],
            "default": "LINK_STATUS_NOT_APPLICABLE",
            "x-displayname": "Link Status",
            "x-ves-proto-enum": "ves.io.schema.topology.LinkStatus"
        },
        "topologyLinkTypeData": {
            "type": "object",
            "description": "LinkTypeData contains details about the link and the metrics (if requested/available).",
            "title": "LinkTypeData",
            "x-displayname": "Link Type Data",
            "x-ves-proto-message": "ves.io.schema.topology.LinkTypeData",
            "properties": {
                "info": {
                    "description": " Information about the link.",
                    "title": "Info",
                    "$ref": "#/definitions/topologyLinkInfo",
                    "x-displayname": "Info"
                },
                "metric": {
                    "type": "array",
                    "description": " Metric data for the link.",
                    "title": "Metric",
                    "items": {
                        "$ref": "#/definitions/topologyMetricData"
                    },
                    "x-displayname": "Metric"
                }
            }
        },
        "topologyLoadBalancer": {
            "type": "object",
            "description": "Load Balancer",
            "title": "LB",
            "x-displayname": "Load Balancer",
            "x-ves-proto-message": "ves.io.schema.topology.LoadBalancer",
            "properties": {
                "id": {
                    "type": "string",
                    "description": " Id of the LB",
                    "title": "Id",
                    "x-displayname": "Id"
                },
                "name": {
                    "type": "string",
                    "description": " Name of the LB",
                    "title": "Name",
                    "x-displayname": "Name"
                }
            }
        },
        "topologyMetricData": {
            "type": "object",
            "description": "Metric Data contains the metric type and the metric data.",
            "title": "Metric Data",
            "x-displayname": "Metric Data",
            "x-ves-proto-message": "ves.io.schema.topology.MetricData",
            "properties": {
                "data": {
                    "type": "array",
                    "description": " Metric Data",
                    "title": "Data",
                    "items": {
                        "$ref": "#/definitions/schematopologyMetricTypeData"
                    },
                    "x-displayname": "Data"
                },
                "type": {
                    "description": " Metric Type",
                    "title": "Type",
                    "$ref": "#/definitions/schematopologyMetricType",
                    "x-displayname": "Type"
                },
                "unit": {
                    "description": " Unit for the metric value",
                    "title": "Unit",
                    "$ref": "#/definitions/schemaUnitType",
                    "x-displayname": "Unit"
                }
            }
        },
        "topologyMetricSelector": {
            "type": "object",
            "description": "MetricSelector is used to specify the list of metrics to be returned in the response.",
            "title": "Metric Selector",
            "x-displayname": "Metric Selector",
            "x-ves-proto-message": "ves.io.schema.topology.MetricSelector",
            "properties": {
                "edge": {
                    "type": "array",
                    "description": " List of metrics to be returned for the edges\n\nValidation Rules:\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Edge Metric Types",
                    "items": {
                        "$ref": "#/definitions/schematopologyMetricType"
                    },
                    "x-displayname": "Edge Metric Types",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "end_time": {
                    "type": "string",
                    "description": " End time of metric data. This field is applicable only if \"include_metrics\" is set to true.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"1570197600\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "End time",
                    "x-displayname": "End Time",
                    "x-ves-example": "1570197600",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "node": {
                    "type": "array",
                    "description": " List of metrics to be returned for the nodes\n\nValidation Rules:\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Node Metric Types",
                    "items": {
                        "$ref": "#/definitions/schematopologyMetricType"
                    },
                    "x-displayname": "Node Metric Types",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "start_time": {
                    "type": "string",
                    "description": " Start time of metric data. This field is applicable only if \"include_metrics\" is set to true.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"1570194000\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "Start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "1570194000",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "step": {
                    "type": "string",
                    "description": " step is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\n The timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\n Optional: If not specified, then step size is evaluated to \u003cend_time - start_time\u003e\n\nExample: - \"5m\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_step: true\n",
                    "title": "Step",
                    "x-displayname": "Step",
                    "x-ves-example": "5m",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_step": "true"
                    }
                }
            }
        },
        "topologyNetworkInterfaceType": {
            "type": "object",
            "description": "A canonical form of the network interface.",
            "title": "Network Interface",
            "x-displayname": "Network Interface",
            "x-ves-proto-message": "ves.io.schema.topology.NetworkInterfaceType",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " Name of this interface",
                    "title": "Name",
                    "x-displayname": "Name"
                },
                "private_addresses": {
                    "type": "array",
                    "description": " Private Address",
                    "title": "Private addresses",
                    "items": {
                        "$ref": "#/definitions/topologyAddressInfoType"
                    },
                    "x-displayname": "Private Addresses"
                },
                "public_address": {
                    "type": "array",
                    "description": " Public address",
                    "title": "Public address",
                    "items": {
                        "$ref": "#/definitions/topologyAddressInfoType"
                    },
                    "x-displayname": "Public Address"
                },
                "security_group": {
                    "type": "array",
                    "description": " Security groups",
                    "title": "Security Groups",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Security Groups"
                },
                "status": {
                    "type": "string",
                    "description": " Status",
                    "title": "Status",
                    "x-displayname": "Status"
                },
                "subnet": {
                    "type": "array",
                    "description": " Reference to the subnets connected",
                    "title": "Subnets",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Subnets"
                }
            }
        },
        "topologyNetworkSummaryInfo": {
            "type": "object",
            "description": "Summary information related to the network",
            "title": "NetworkSummaryInfo",
            "x-displayname": "Network Summary",
            "x-ves-proto-message": "ves.io.schema.topology.NetworkSummaryInfo",
            "properties": {
                "route_tables": {
                    "type": "array",
                    "description": " List of route tables associated with the network",
                    "title": "Route Tables",
                    "items": {
                        "$ref": "#/definitions/topologyRouteTableMetaData"
                    },
                    "x-displayname": "Route Tables"
                }
            }
        },
        "topologyNetworkType": {
            "type": "object",
            "description": "A canonical form of the network.",
            "title": "Network",
            "x-displayname": "network",
            "x-ves-proto-message": "ves.io.schema.topology.NetworkType",
            "properties": {
                "cidr_v4": {
                    "type": "array",
                    "description": " IPv4 Cidr",
                    "title": "IPv4 Cidr",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv4 Cidr"
                },
                "cidr_v6": {
                    "type": "array",
                    "description": " IPv6 Cidr",
                    "title": "IPv6 Cidr",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv6 Cidr"
                },
                "load_balancer": {
                    "type": "array",
                    "description": " Load Balancer Present in this Network",
                    "title": "Load Balancer",
                    "items": {
                        "$ref": "#/definitions/topologyLoadBalancer"
                    },
                    "x-displayname": "Load Balancer"
                },
                "network_peers": {
                    "type": "array",
                    "description": " Reference to the network peers",
                    "title": "Network peers",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Network Peers"
                },
                "region": {
                    "type": "array",
                    "description": " Reference to the regions",
                    "title": "Region",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Region"
                }
            }
        },
        "topologyNodeMetaData": {
            "type": "object",
            "description": "Metadata for node",
            "title": "Node Metadata",
            "x-displayname": "Node Metadata",
            "x-ves-proto-message": "ves.io.schema.topology.NodeMetaData",
            "properties": {
                "cloud_resource_id": {
                    "type": "string",
                    "description": " Cloud Resource Identifier for the node. This is only used for node which represent the cloud resource",
                    "title": "Cloud Resource Id",
                    "x-displayname": "Cloud Resource Id"
                },
                "description": {
                    "type": "string",
                    "description": " Description of the node.\n This field may or may not be populated depending on the node type and if the user provided description\n while creating the resource.",
                    "title": "Description",
                    "x-displayname": "Description"
                },
                "level": {
                    "type": "integer",
                    "description": " Level indicates the distance of the node from the root node. A value of 0 indicates the root node.\n\nExample: - \"1\"-",
                    "title": "Level",
                    "format": "int64",
                    "x-displayname": "Level",
                    "x-ves-example": "1"
                },
                "name": {
                    "type": "string",
                    "description": " Name of the node.\n\nExample: - \"site-1\"-",
                    "title": "Name",
                    "x-displayname": "Name",
                    "x-ves-example": "site-1"
                },
                "owner_id": {
                    "type": "string",
                    "description": " Owner id\n\nExample: - \"owner-1\"-",
                    "title": "Owner Id",
                    "x-displayname": "Owner Id",
                    "x-ves-example": "owner-1"
                },
                "provider_type": {
                    "description": " Provider type",
                    "title": "Provider Type",
                    "$ref": "#/definitions/topologyProviderType",
                    "x-displayname": "Provider Type"
                },
                "status": {
                    "type": "string",
                    "description": " status in the node",
                    "title": "Status",
                    "x-displayname": "Status"
                },
                "tags": {
                    "type": "object",
                    "description": " List of key/value pairs associated with the node",
                    "title": "Tags",
                    "x-displayname": "Tags"
                }
            }
        },
        "topologyNodeTypeDCClusterGroup": {
            "type": "object",
            "description": "DC Cluster group is represented as a node in the site topology graph.\nIn the DCClusterTopology API, dc_cluster_group is represented as a node and all the sites\nthat are part of the DC Cluster group are represented as edges (site -\u003e dc_cluster_group) in\naddition to the edges between the sites (site \u003c-\u003e site).",
            "title": "NodeTypeDCClusterGroup",
            "x-displayname": "DC Cluster Group",
            "x-ves-proto-message": "ves.io.schema.topology.NodeTypeDCClusterGroup",
            "properties": {
                "info": {
                    "description": " Information about the DC Cluster group.",
                    "title": "Info",
                    "$ref": "#/definitions/topologyDCClusterGroupType",
                    "x-displayname": "Info"
                },
                "summary": {
                    "description": " Summary information related to the DC Cluster group",
                    "title": "Summary",
                    "$ref": "#/definitions/topologyDCClusterGroupSummaryInfo",
                    "x-displayname": "Summary"
                }
            }
        },
        "topologyNodeTypeInstance": {
            "type": "object",
            "description": "NodeTypeInstance contains details about the instance and the metrics (if requested/available).",
            "title": "NodeTypeInstance",
            "x-displayname": "Instance",
            "x-ves-proto-message": "ves.io.schema.topology.NodeTypeInstance",
            "properties": {
                "info": {
                    "description": " Information about the Instance.",
                    "title": "Info",
                    "$ref": "#/definitions/topologyInstanceType",
                    "x-displayname": "Info"
                },
                "metric": {
                    "type": "array",
                    "description": " Metric data for the Instance.",
                    "title": "Metric",
                    "items": {
                        "$ref": "#/definitions/topologyMetricData"
                    },
                    "x-displayname": "Metric"
                }
            }
        },
        "topologyNodeTypeNetwork": {
            "type": "object",
            "description": "NodeTypeNetwork contains details about the network and the metrics (if requested/available).",
            "title": "NodeTypeNetwork",
            "x-displayname": "Network",
            "x-ves-proto-message": "ves.io.schema.topology.NodeTypeNetwork",
            "properties": {
                "info": {
                    "description": " Information about the Network.",
                    "title": "Info",
                    "$ref": "#/definitions/topologyNetworkType",
                    "x-displayname": "Info"
                },
                "metric": {
                    "type": "array",
                    "description": " Metric data for the Network.",
                    "title": "Metric",
                    "items": {
                        "$ref": "#/definitions/topologyMetricData"
                    },
                    "x-displayname": "Metric"
                },
                "summary": {
                    "description": " Network summary contains additional fields that are not part of the \"info\" field",
                    "title": "Summary",
                    "$ref": "#/definitions/topologyNetworkSummaryInfo",
                    "x-displayname": "Summary"
                }
            }
        },
        "topologyNodeTypeSite": {
            "type": "object",
            "description": "NodeTypeSite contains details about the site and the metrics (if requested/available).",
            "title": "NodeTypeSite",
            "x-displayname": "Site",
            "x-ves-proto-message": "ves.io.schema.topology.NodeTypeSite",
            "properties": {
                "info": {
                    "description": " Information about the site.",
                    "title": "Info",
                    "$ref": "#/definitions/schematopologySiteType",
                    "x-displayname": "Info"
                },
                "metric": {
                    "type": "array",
                    "description": " Metric data for the Site.",
                    "title": "Metric",
                    "items": {
                        "$ref": "#/definitions/topologyMetricData"
                    },
                    "x-displayname": "Metric"
                },
                "summary": {
                    "description": " Site summary contains additional fields that are not part of the \"info\" field",
                    "title": "Summary",
                    "$ref": "#/definitions/topologySiteSummaryInfo",
                    "x-displayname": "Summary"
                }
            }
        },
        "topologyNodeTypeSiteMeshGroup": {
            "type": "object",
            "description": "Site mesh group is represented as a node in the site topology graph.\nIn the SiteMeshTopology API, site_mesh_group is represented as a node and all the sites\nthat are part of the site mesh group are represented as edges (site -\u003e site_mesh_group) in\naddition to the edges between the sites (site \u003c-\u003e site). If the site_mesh_group is of type \"Spoke\",\nthen the node representing the site_mesh_group will have an edge with another site_mesh_group node\nthat represents the \"Hub\" and vice-versa.",
            "title": "NodeTypeSiteMeshGroup",
            "x-displayname": "Site Mesh Group",
            "x-ves-proto-message": "ves.io.schema.topology.NodeTypeSiteMeshGroup",
            "properties": {
                "info": {
                    "description": " Information about the site mesh group.",
                    "title": "Info",
                    "$ref": "#/definitions/schematopologySiteMeshGroupType",
                    "x-displayname": "Info"
                },
                "summary": {
                    "description": " Summary information related to the site mesh group",
                    "title": "Summary",
                    "$ref": "#/definitions/topologySiteMeshGroupSummaryInfo",
                    "x-displayname": "Summary"
                }
            }
        },
        "topologyNodeTypeSubnet": {
            "type": "object",
            "description": "NodeTypeSubnet contains details about the subnet and the metrics (if requested/available).",
            "title": "NodeTypeSubnet",
            "x-displayname": "Subnet",
            "x-ves-proto-message": "ves.io.schema.topology.NodeTypeSubnet",
            "properties": {
                "info": {
                    "description": " Information about the Subnet.",
                    "title": "Info",
                    "$ref": "#/definitions/topologySubnetType",
                    "x-displayname": "Info"
                },
                "metric": {
                    "type": "array",
                    "description": " Metric data for the Subnet.",
                    "title": "Metric",
                    "items": {
                        "$ref": "#/definitions/topologyMetricData"
                    },
                    "x-displayname": "Metric"
                },
                "summary": {
                    "description": " Subnet summary contains additional fields that are not part of the \"info\" field",
                    "title": "Summary",
                    "$ref": "#/definitions/topologySubnetSummaryInfo",
                    "x-displayname": "Summary"
                }
            }
        },
        "topologyNodeTypeTransitGateway": {
            "type": "object",
            "description": "NodeTypeTransitGateway contains details about the transit gateway and the metrics (if requested/available).",
            "title": "NodeTypeTransitGateway",
            "x-displayname": "Transit Gateway",
            "x-ves-proto-message": "ves.io.schema.topology.NodeTypeTransitGateway",
            "properties": {
                "info": {
                    "description": " Information about the Transit Gateway.",
                    "title": "Info",
                    "$ref": "#/definitions/topologyTransitGatewayType",
                    "x-displayname": "Info"
                },
                "metric": {
                    "type": "array",
                    "description": " Metric data for the Transit Gateway.",
                    "title": "Metric",
                    "items": {
                        "$ref": "#/definitions/topologyMetricData"
                    },
                    "x-displayname": "Metric"
                }
            }
        },
        "topologyProviderType": {
            "type": "string",
            "description": "provider type\n\nProviderType unspecified\nAWS backend\nGCP backend\nAzure backend\nF5XC backend",
            "title": "ProviderType",
            "enum": [
                "PROVIDER_TYPE_UNSPECIFIED",
                "PROVIDER_TYPE_AWS",
                "PROVIDER_TYPE_GCP",
                "PROVIDER_TYPE_AZURE",
                "PROVIDER_TYPE_VOLTERRA"
            ],
            "default": "PROVIDER_TYPE_UNSPECIFIED",
            "x-displayname": "Provider Type",
            "x-ves-proto-enum": "ves.io.schema.topology.ProviderType"
        },
        "topologyRouteNextHopTypeEnum": {
            "type": "string",
            "description": "x-displayName: RouteNextHopTypeEnum\nRouteNextHopTypeEnum\n\n - VIRTUAL_NETWORK_GATEWAY: VIRTUAL NETWORK GATEWAY\n\nx-displayName: VIRTUAL NETWORK GATEWAY\nVIRTUAL NETWORK GATEWAY\n - VNET_LOCAL: VNET LOCAL\n\nx-displayName: VNET LOCAL\nVNET LOCAL\n - INTERNET: INTERNET\n\nx-displayName: INTERNET\nINTERNET\n - VIRTUAL_APPLIANCE: VIRTUAL APPLIANCE\n\nx-displayName: VIRTUAL APPLIANCE\nVIRTUAL APPLIANCE\n - NONE: NONE\n\nx-displayName: NONE\nNONE\n - VNET_PEERING: VNET PEERING\n\nx-displayName: VNET PEERING\nVNET PEERING\n - VIRTUAL_NETWORK_SERVICE_ENDPOINT: VIRTUAL NETWORK SERVICE ENDPOINT\n\nx-displayName: VIRTUAL NETWORK SERVICE ENDPOINT\nVIRTUAL NETWORK SERVICE ENDPOINT\n - NEXT_HOP_TYPE_NOT_APPLICABLE: NEXT_HOP_TYPE_NOT_APPLICABLE\n\nx-displayName: NEXT_HOP_TYPE_NOT_APPLICABLE\nNEXT_HOP_TYPE_NOT_APPLICABLE should be used when the cloud provider doesn't support this.",
            "title": "RouteNextHopTypeEnum",
            "enum": [
                "VIRTUAL_NETWORK_GATEWAY",
                "VNET_LOCAL",
                "INTERNET",
                "VIRTUAL_APPLIANCE",
                "NONE",
                "VNET_PEERING",
                "VIRTUAL_NETWORK_SERVICE_ENDPOINT",
                "NEXT_HOP_TYPE_NOT_APPLICABLE"
            ],
            "default": "VIRTUAL_NETWORK_GATEWAY",
            "x-displayname": "",
            "x-ves-proto-enum": "ves.io.schema.topology.RouteNextHopTypeEnum"
        },
        "topologyRouteSourceTypeEnum": {
            "type": "string",
            "description": "x-displayName: RouteSourceTypeEnum\nRouteSourceTypeEnum\n\n - INVALID_SOURCE: INVALID_SOURCE\n\nx-displayName: INVALID_SOURCE\nINVALID_SOURCE\n - DEFAULT: DEFAULT\n\nx-displayName: DEFAULT\nDEFAULT\n - USER: USER\n\nx-displayName: USER\nUSER\n - UNKNOWN: UNKNOWN\n\nx-displayName: UNKNOWN\nUNKNOWN\n - VIRTUAL_NETWORK_GATEWAY_SOURCE: VIRTUAL_NETWORK_GATEWAY_SOURCE\n\nx-displayName: VIRTUAL_NETWORK_GATEWAY_SOURCE\nVIRTUAL_NETWORK_GATEWAY_SOURCE\n - SOURCE_NOT_APPLICABLE: SOURCE_NOT_APPLICABLE\n\nx-displayName: SOURCE_NOT_APPLICABLE\nSOURCE_NOT_APPLICABLE should be used when the cloud provider does not supports this.",
            "title": "RouteSourceTypeEnum",
            "enum": [
                "INVALID_SOURCE",
                "DEFAULT",
                "USER",
                "UNKNOWN",
                "VIRTUAL_NETWORK_GATEWAY_SOURCE",
                "SOURCE_NOT_APPLICABLE"
            ],
            "default": "INVALID_SOURCE",
            "x-displayname": "",
            "x-ves-proto-enum": "ves.io.schema.topology.RouteSourceTypeEnum"
        },
        "topologyRouteStateTypeEnum": {
            "type": "string",
            "description": "x-displayName: RouteStateTypeEnum\nRouteStateTypeEnum\n\n - ACTIVE_STATE: ACTIVE_STATE\n\nx-displayName: ACTIVE_STATE\nACTIVE_STATE\n - INVALID_STATE: INVALID_STATE\n\nx-displayName: INVALID_STATE\nINVALID_STATE\n - STATE_NOT_APPLICABLE: STATE_NOT_APPLICABLE\n\nx-displayName: STATE_NOT_APPLICABLE\nSTATE_NOT_APPLICABLE should be used when the cloud provider doesn't supports this",
            "title": "RouteStateTypeEnum",
            "enum": [
                "ACTIVE_STATE",
                "INVALID_STATE",
                "STATE_NOT_APPLICABLE"
            ],
            "default": "ACTIVE_STATE",
            "x-displayname": "",
            "x-ves-proto-enum": "ves.io.schema.topology.RouteStateTypeEnum"
        },
        "topologyRouteTableMetaData": {
            "type": "object",
            "description": "Metadata associated with the route table",
            "title": "RouteTableMetaData",
            "x-displayname": "Route Table Metadata",
            "x-ves-proto-message": "ves.io.schema.topology.RouteTableMetaData",
            "properties": {
                "cloud_resource_id": {
                    "type": "string",
                    "description": " Cloud Resource Identifier this route table",
                    "title": "Cloud Resource Id",
                    "x-displayname": "Cloud Resource Id"
                },
                "name": {
                    "type": "string",
                    "description": " Name of the route table\n\nExample: - \"rt-1\"-",
                    "title": "Name",
                    "x-displayname": "Name",
                    "x-ves-example": "rt-1"
                },
                "tags": {
                    "type": "object",
                    "description": " Map of string keys and values that annotated in the topology node.\n\nExample: - \"value\"-",
                    "title": "tags",
                    "x-displayname": "Tags",
                    "x-ves-example": "value"
                }
            }
        },
        "topologyRouteTableResponse": {
            "type": "object",
            "description": "Route table",
            "title": "Route Table Response",
            "x-displayname": "Route Table Response",
            "x-ves-proto-message": "ves.io.schema.topology.RouteTableResponse",
            "properties": {
                "metadata": {
                    "description": " Route table metadata",
                    "title": "Metadata",
                    "$ref": "#/definitions/topologyRouteTableMetaData",
                    "x-displayname": "Metadata"
                },
                "route_table": {
                    "description": " Route table",
                    "title": "Route Table",
                    "$ref": "#/definitions/topologyRouteTableType",
                    "x-displayname": "Route Table"
                }
            }
        },
        "topologyRouteTableType": {
            "type": "object",
            "description": "A canonical form of the route table.",
            "title": "RouteTableType",
            "x-displayname": "Route Table",
            "x-ves-proto-message": "ves.io.schema.topology.RouteTableType",
            "properties": {
                "explicit_subnet": {
                    "type": "array",
                    "description": " Reference to the subnet explicitly accociated.",
                    "title": "Explicit Subnet Association",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Explicit Subnet Association"
                },
                "implicit_subnet": {
                    "type": "array",
                    "description": " Reference to the subnet implicitly accociated.",
                    "title": "Implicit Subnet Association",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Implicit Subnet Association"
                },
                "network": {
                    "type": "array",
                    "description": " Reference to the network.",
                    "title": "Network",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Network"
                },
                "route_table_type": {
                    "description": " type of this route table.",
                    "title": "Rotue Table type",
                    "$ref": "#/definitions/topologyRouteTableTypeEnum",
                    "x-displayname": "Route table type"
                },
                "routes": {
                    "type": "array",
                    "description": " list of routes",
                    "title": "Rotues",
                    "items": {
                        "$ref": "#/definitions/topologyRouteType"
                    },
                    "x-displayname": "Routes"
                },
                "subnet": {
                    "type": "array",
                    "description": " Reference to the subnet.",
                    "title": "Subnet",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Subnet"
                },
                "transit_gateway": {
                    "type": "array",
                    "description": " Reference to the transit gateway if a transit gateway owns this resource.",
                    "title": "Transit Gateway",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Transit Gateway"
                }
            }
        },
        "topologyRouteTableTypeEnum": {
            "type": "string",
            "description": "Route table backend.\n\nRoute table for network\nRoute Table for transit gateway",
            "title": "RouteTableTypeEnum",
            "enum": [
                "ROUTE_TABLE_NETWORK",
                "ROUTE_TABLE_TGW"
            ],
            "default": "ROUTE_TABLE_NETWORK",
            "x-displayname": "Route Table Type",
            "x-ves-proto-enum": "ves.io.schema.topology.RouteTableTypeEnum"
        },
        "topologyRouteType": {
            "type": "object",
            "description": "A canonical form of the route.",
            "title": "RouteType",
            "x-displayname": "Route Type",
            "x-ves-proto-message": "ves.io.schema.topology.RouteType",
            "properties": {
                "destination": {
                    "type": "string",
                    "description": " Destination",
                    "title": "Destination",
                    "x-displayname": "Destination"
                },
                "next_hop_type": {
                    "description": " Next Hop Type of the route",
                    "title": "Next Hop Type",
                    "$ref": "#/definitions/topologyRouteNextHopTypeEnum",
                    "x-displayname": "Next Hop Type"
                },
                "nexthop": {
                    "type": "string",
                    "description": " Nexthop (IP subnet or gateway ID)",
                    "title": "Nexthop",
                    "x-displayname": "Nexthop"
                },
                "source": {
                    "description": " Source of route entry",
                    "title": "Source",
                    "$ref": "#/definitions/topologyRouteSourceTypeEnum",
                    "x-displayname": "Source"
                },
                "state": {
                    "description": " State of the route entry",
                    "title": "State",
                    "$ref": "#/definitions/topologyRouteStateTypeEnum",
                    "x-displayname": "State"
                },
                "user_defined_route_name": {
                    "type": "string",
                    "description": " User Defined Route Name",
                    "title": "User Defined Route Name",
                    "x-displayname": "User Defined Route Name"
                }
            }
        },
        "topologySiteMeshGroupSummaryInfo": {
            "type": "object",
            "description": "Summary information related to the site mesh group",
            "title": "SiteMeshGroupSummaryInfo",
            "x-displayname": "Site Mesh Group Summary",
            "x-ves-proto-message": "ves.io.schema.topology.SiteMeshGroupSummaryInfo",
            "properties": {
                "edge_status_summary": {
                    "type": "array",
                    "description": " Summary of the edges status between the sites in the site mesh group.",
                    "title": "Edge Summary",
                    "items": {
                        "$ref": "#/definitions/topologyEdgeInfoSummary"
                    },
                    "x-displayname": "Edge Summary"
                },
                "link_status_summary": {
                    "type": "array",
                    "description": " Summary of the link status between the sites in the site mesh group.",
                    "title": "Link Status Summary",
                    "items": {
                        "$ref": "#/definitions/topologyLinkInfoSummary"
                    },
                    "x-displayname": "Link Status Summary"
                },
                "other_connected_site_mesh_group_sites": {
                    "type": "integer",
                    "description": " If the site mesh group is of type \"Hub\", this field indicates the number of sites in all the spoke mesh groups\n that are connected to this site mesh group.\n If the site mesh group is of type \"Spoke\", this field indicates the number of sites in the hub as well as the sites\n in other spoke groups that are attached to this hub.",
                    "title": "Other Connected Site Mesh Group Sites",
                    "format": "int64",
                    "x-displayname": "Other Connected Site Mesh Group Sites"
                },
                "sites": {
                    "type": "integer",
                    "description": " This field indicates the number of sites that are part of this site mesh group.",
                    "title": "Sites",
                    "format": "int64",
                    "x-displayname": "Sites"
                }
            }
        },
        "topologySiteMeshTopologyRequest": {
            "type": "object",
            "description": "Request to get site mesh group topology and the associated metrics.",
            "title": "Site Mesh Group Topology Request",
            "x-displayname": "Site Mesh Group Topology Request",
            "x-ves-proto-message": "ves.io.schema.topology.SiteMeshTopologyRequest",
            "properties": {
                "metric_selector": {
                    "description": " Metric fields to be returned in the response. If no metric fields are specified in the request,\n then the response will not contain any metric data.",
                    "title": "Metric Selector",
                    "$ref": "#/definitions/topologyMetricSelector",
                    "x-displayname": "Metric Selector"
                },
                "site_mesh_group": {
                    "type": "string",
                    "description": "\n Name of the site mesh group\n\nExample: - \"smg-1\"-",
                    "title": "Site Mesh Group",
                    "x-displayname": "Site Mesh Group",
                    "x-ves-example": "smg-1"
                }
            }
        },
        "topologySiteSummaryInfo": {
            "type": "object",
            "description": "Summary information related to the site",
            "title": "SiteSummaryInfo",
            "x-displayname": "Site Summary",
            "x-ves-proto-message": "ves.io.schema.topology.SiteSummaryInfo",
            "properties": {
                "availability_zone": {
                    "type": "array",
                    "description": " Availability zone",
                    "title": "Availability Zone",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Availability Zone"
                },
                "node_count": {
                    "type": "integer",
                    "description": " Site Node Count.",
                    "title": "Node Count",
                    "format": "int64",
                    "x-displayname": "Node Count"
                }
            }
        },
        "topologySiteTopologyRequest": {
            "type": "object",
            "description": "Request to get site topology and the associated metrics.",
            "title": "Site Topology Request",
            "x-displayname": "Site Topology Request",
            "x-ves-proto-message": "ves.io.schema.topology.SiteTopologyRequest",
            "properties": {
                "group_dc_cluster_nodes": {
                    "type": "boolean",
                    "description": " Option to enable or disable grouping of sites in a DC Cluster group.\n If enabled, then all the sites in a DC Cluster group are returned as a single node in the response.",
                    "title": "Group DC Cluster nodes",
                    "format": "boolean",
                    "x-displayname": "Group DC Cluster nodes"
                },
                "group_site_mesh_nodes": {
                    "type": "boolean",
                    "description": " Option to enable or disable grouping of sites in a site mesh group.\n If enabled, then all the sites in a site mesh group are returned as a single node in the response.",
                    "title": "Group Site Mesh nodes",
                    "format": "boolean",
                    "x-displayname": "Group Site Mesh nodes"
                },
                "level": {
                    "type": "integer",
                    "description": " Level determines the nodes and the corresponding edges to be returned in the response based on its distance from the root node.\n If the level specified in the request is 1, then the response contains the root node (level:0) and all its immediate neighbors (level:1).\n If the level is set to -1, then all the nodes and edges in the topology graph will be returned in the response.\n\nExample: - \"2\"-",
                    "title": "Level",
                    "format": "int32",
                    "x-displayname": "Level",
                    "x-ves-example": "2"
                },
                "metric_selector": {
                    "description": " Metric fields to be returned in the response. If no metric fields are specified in the request,\n then the response will not contain any metric data.",
                    "title": "Metric Selector",
                    "$ref": "#/definitions/topologyMetricSelector",
                    "x-displayname": "Metric Selector"
                },
                "node_id": {
                    "type": "string",
                    "description": " Specifies the node in the topology graph to start the graph traversal.\n\nExample: - \"site:site-1\"-",
                    "title": "Node Id",
                    "x-displayname": "Node Id",
                    "x-ves-example": "site:site-1"
                },
                "site": {
                    "type": "string",
                    "description": "\n Name of the site\n\nExample: - \"ce01\"-",
                    "title": "Site",
                    "x-displayname": "Site",
                    "x-ves-example": "ce01"
                }
            }
        },
        "topologySubnetSummaryInfo": {
            "type": "object",
            "description": "Summary information related to the subnet",
            "title": "SubnetSummaryInfo",
            "x-displayname": "Subnet Summary",
            "x-ves-proto-message": "ves.io.schema.topology.SubnetSummaryInfo",
            "properties": {
                "route_tables": {
                    "type": "array",
                    "description": " List of route tables associated with the subnet",
                    "title": "Route Tables",
                    "items": {
                        "$ref": "#/definitions/topologyRouteTableMetaData"
                    },
                    "x-displayname": "Route Tables"
                }
            }
        },
        "topologySubnetType": {
            "type": "object",
            "description": "A canonical form of the subnet.",
            "title": "Subnet",
            "x-displayname": "subnet",
            "x-ves-proto-message": "ves.io.schema.topology.SubnetType",
            "properties": {
                "availability_zone": {
                    "type": "string",
                    "description": " Availability zone",
                    "title": "Availability Zone",
                    "x-displayname": "Availability Zone"
                },
                "cidr_v4": {
                    "type": "array",
                    "description": " IPv4 Cidr",
                    "title": "IPv4 Cidr",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv4 Cidr"
                },
                "cidr_v6": {
                    "type": "array",
                    "description": " IPv6 Cidr",
                    "title": "IPv6 Cidr",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv6 Cidr"
                },
                "interface_type": {
                    "description": " Subnet Type",
                    "title": "Subnet Type",
                    "$ref": "#/definitions/topologyInterfaceTypeEnum",
                    "x-displayname": "Subnet Type"
                },
                "network": {
                    "type": "array",
                    "description": " Reference to the network",
                    "title": "Network",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Network"
                },
                "region": {
                    "type": "array",
                    "description": " Reference to the regions. (Used for GCP)",
                    "title": "Region",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Region"
                }
            }
        },
        "topologyTopologyResponse": {
            "type": "object",
            "description": "Relationship between the resources associated with a site is represented as a graph, where each resource/entity is\nrepresented as a node (example: Site (CE, RE), Network (VPC, Virtual Network), Subnet, etc.,) and their association is\nrepresented as edges (example: Site (CE) - Site (CE, RE), Network (VPC) - Subnets, etc.,). All edges are directed.\nHowever if 2 nodes have bidirectional connection, (example: Site - Site), there may be 2 edges in the response for the same\npair of nodes.",
            "title": "Topology Response",
            "x-displayname": "Topology Response",
            "x-ves-proto-message": "ves.io.schema.topology.TopologyResponse",
            "properties": {
                "edges": {
                    "type": "array",
                    "description": " List of edges in the topology graph",
                    "title": "Edges",
                    "items": {
                        "$ref": "#/definitions/topologyEdge"
                    },
                    "x-displayname": "Edges"
                },
                "nodes": {
                    "type": "array",
                    "description": " List of nodes in the topology graph",
                    "title": "Nodes",
                    "items": {
                        "$ref": "#/definitions/schematopologyNode"
                    },
                    "x-displayname": "Nodes"
                },
                "step": {
                    "type": "string",
                    "description": " Actual step size used in the response. It could be higher than the requested step due to metric rollups and the query duration.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\nExample: - \"30m\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.time_interval: true\n",
                    "title": "step",
                    "x-displayname": "Step",
                    "x-ves-example": "30m",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.time_interval": "true"
                    }
                }
            }
        },
        "topologyTransitGatewayType": {
            "type": "object",
            "description": "A canonical form of the transit gateway.",
            "title": "TransitGateway",
            "x-displayname": "transit gateway",
            "x-ves-proto-message": "ves.io.schema.topology.TransitGatewayType",
            "properties": {
                "auto_accept_shared_attachments": {
                    "type": "boolean",
                    "description": " Auto accept shared attachment",
                    "title": "Auto accept shared attachment",
                    "format": "boolean",
                    "x-displayname": "Auto accept shared attachment"
                },
                "dns_support": {
                    "type": "boolean",
                    "description": " DNS support",
                    "title": "DNS support",
                    "format": "boolean",
                    "x-displayname": "DNS Support"
                },
                "network": {
                    "type": "array",
                    "description": " Reference to the network",
                    "title": "Network",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Network"
                },
                "vpn_ecmp_support": {
                    "type": "boolean",
                    "description": " vpn ecmp support",
                    "title": "vpn ecmp support",
                    "format": "boolean",
                    "x-displayname": "VpnEcmpSupport Support"
                }
            }
        }
    },
    "x-displayname": "Topology",
    "x-ves-proto-file": "ves.io/schema/topology/public_custom_data_api.proto"
}`
