// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package topology

import (
	"bytes"
	"context"
	"fmt"
	io "io"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create CustomDataAPI GRPC Client satisfying server.CustomClient
type CustomDataAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient CustomDataAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *CustomDataAPIGrpcClient) doRPCDCClusterGroupsSummary(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &DCClusterGroupsSummaryRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.DCClusterGroupsSummaryRequest", yamlReq)
	}
	rsp, err := c.grpcClient.DCClusterGroupsSummary(ctx, req, opts...)
	return rsp, err
}

func (c *CustomDataAPIGrpcClient) doRPCDCClusterTopology(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &DCClusterTopologyRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.DCClusterTopologyRequest", yamlReq)
	}
	rsp, err := c.grpcClient.DCClusterTopology(ctx, req, opts...)
	return rsp, err
}

func (c *CustomDataAPIGrpcClient) doRPCGetNetworkRouteTables(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &NetworkRouteTablesRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.NetworkRouteTablesRequest", yamlReq)
	}
	rsp, err := c.grpcClient.GetNetworkRouteTables(ctx, req, opts...)
	return rsp, err
}

func (c *CustomDataAPIGrpcClient) doRPCGetRouteTable(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &RouteTableRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.RouteTableRequest", yamlReq)
	}
	rsp, err := c.grpcClient.GetRouteTable(ctx, req, opts...)
	return rsp, err
}

func (c *CustomDataAPIGrpcClient) doRPCGetSiteNetworks(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SiteNetworksRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.SiteNetworksRequest", yamlReq)
	}
	rsp, err := c.grpcClient.GetSiteNetworks(ctx, req, opts...)
	return rsp, err
}

func (c *CustomDataAPIGrpcClient) doRPCGetTGWRouteTables(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &TGWRouteTablesRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.TGWRouteTablesRequest", yamlReq)
	}
	rsp, err := c.grpcClient.GetTGWRouteTables(ctx, req, opts...)
	return rsp, err
}

func (c *CustomDataAPIGrpcClient) doRPCSiteMeshGroupsSummary(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SiteMeshGroupsSummaryRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.SiteMeshGroupsSummaryRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SiteMeshGroupsSummary(ctx, req, opts...)
	return rsp, err
}

func (c *CustomDataAPIGrpcClient) doRPCSiteMeshTopology(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SiteMeshTopologyRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.SiteMeshTopologyRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SiteMeshTopology(ctx, req, opts...)
	return rsp, err
}

func (c *CustomDataAPIGrpcClient) doRPCSiteTopology(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SiteTopologyRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.SiteTopologyRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SiteTopology(ctx, req, opts...)
	return rsp, err
}

func (c *CustomDataAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func NewCustomDataAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &CustomDataAPIGrpcClient{
		conn:       cc,
		grpcClient: NewCustomDataAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["DCClusterGroupsSummary"] = ccl.doRPCDCClusterGroupsSummary

	rpcFns["DCClusterTopology"] = ccl.doRPCDCClusterTopology

	rpcFns["GetNetworkRouteTables"] = ccl.doRPCGetNetworkRouteTables

	rpcFns["GetRouteTable"] = ccl.doRPCGetRouteTable

	rpcFns["GetSiteNetworks"] = ccl.doRPCGetSiteNetworks

	rpcFns["GetTGWRouteTables"] = ccl.doRPCGetTGWRouteTables

	rpcFns["SiteMeshGroupsSummary"] = ccl.doRPCSiteMeshGroupsSummary

	rpcFns["SiteMeshTopology"] = ccl.doRPCSiteMeshTopology

	rpcFns["SiteTopology"] = ccl.doRPCSiteTopology

	ccl.rpcFns = rpcFns

	return ccl
}

// Create CustomDataAPI REST Client satisfying server.CustomClient
type CustomDataAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *CustomDataAPIRestClient) doRPCDCClusterGroupsSummary(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &DCClusterGroupsSummaryRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.DCClusterGroupsSummaryRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &TopologyResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.topology.TopologyResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomDataAPIRestClient) doRPCDCClusterTopology(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &DCClusterTopologyRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.DCClusterTopologyRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("dc_cluster_group", fmt.Sprintf("%v", req.DcClusterGroup))
		q.Add("metric_selector", fmt.Sprintf("%v", req.MetricSelector))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &TopologyResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.topology.TopologyResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomDataAPIRestClient) doRPCGetNetworkRouteTables(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &NetworkRouteTablesRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.NetworkRouteTablesRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("id", fmt.Sprintf("%v", req.Id))
		for _, item := range req.Regions {
			q.Add("regions", fmt.Sprintf("%v", item))
		}
		for _, item := range req.RouteTableIds {
			q.Add("route_table_ids", fmt.Sprintf("%v", item))
		}
		q.Add("site", fmt.Sprintf("%v", req.Site))
		for _, item := range req.SubnetCidrs {
			q.Add("subnet_cidrs", fmt.Sprintf("%v", item))
		}
		for _, item := range req.SubnetIds {
			q.Add("subnet_ids", fmt.Sprintf("%v", item))
		}

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &NetworkRouteTablesResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.topology.NetworkRouteTablesResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomDataAPIRestClient) doRPCGetRouteTable(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &RouteTableRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.RouteTableRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("name", fmt.Sprintf("%v", req.Name))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &RouteTableResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.topology.RouteTableResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomDataAPIRestClient) doRPCGetSiteNetworks(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SiteNetworksRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.SiteNetworksRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("name", fmt.Sprintf("%v", req.Name))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SiteNetworksResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.topology.SiteNetworksResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomDataAPIRestClient) doRPCGetTGWRouteTables(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &TGWRouteTablesRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.TGWRouteTablesRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		for _, item := range req.AttachmentIds {
			q.Add("attachment_ids", fmt.Sprintf("%v", item))
		}
		q.Add("id", fmt.Sprintf("%v", req.Id))
		for _, item := range req.RouteTableIds {
			q.Add("route_table_ids", fmt.Sprintf("%v", item))
		}

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &TGWRouteTablesResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.topology.TGWRouteTablesResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomDataAPIRestClient) doRPCSiteMeshGroupsSummary(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SiteMeshGroupsSummaryRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.SiteMeshGroupsSummaryRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &TopologyResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.topology.TopologyResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomDataAPIRestClient) doRPCSiteMeshTopology(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SiteMeshTopologyRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.SiteMeshTopologyRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("metric_selector", fmt.Sprintf("%v", req.MetricSelector))
		q.Add("site_mesh_group", fmt.Sprintf("%v", req.SiteMeshGroup))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &TopologyResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.topology.TopologyResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomDataAPIRestClient) doRPCSiteTopology(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SiteTopologyRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.topology.SiteTopologyRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("group_dc_cluster_nodes", fmt.Sprintf("%v", req.GroupDcClusterNodes))
		q.Add("group_site_mesh_nodes", fmt.Sprintf("%v", req.GroupSiteMeshNodes))
		q.Add("level", fmt.Sprintf("%v", req.Level))
		q.Add("metric_selector", fmt.Sprintf("%v", req.MetricSelector))
		q.Add("node_id", fmt.Sprintf("%v", req.NodeId))
		q.Add("site", fmt.Sprintf("%v", req.Site))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &TopologyResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.topology.TopologyResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomDataAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewCustomDataAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &CustomDataAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["DCClusterGroupsSummary"] = ccl.doRPCDCClusterGroupsSummary

	rpcFns["DCClusterTopology"] = ccl.doRPCDCClusterTopology

	rpcFns["GetNetworkRouteTables"] = ccl.doRPCGetNetworkRouteTables

	rpcFns["GetRouteTable"] = ccl.doRPCGetRouteTable

	rpcFns["GetSiteNetworks"] = ccl.doRPCGetSiteNetworks

	rpcFns["GetTGWRouteTables"] = ccl.doRPCGetTGWRouteTables

	rpcFns["SiteMeshGroupsSummary"] = ccl.doRPCSiteMeshGroupsSummary

	rpcFns["SiteMeshTopology"] = ccl.doRPCSiteMeshTopology

	rpcFns["SiteTopology"] = ccl.doRPCSiteTopology

	ccl.rpcFns = rpcFns

	return ccl
}

// Create customDataAPIInprocClient

// INPROC Client (satisfying CustomDataAPIClient interface)
type customDataAPIInprocClient struct {
	CustomDataAPIServer
}

func (c *customDataAPIInprocClient) DCClusterGroupsSummary(ctx context.Context, in *DCClusterGroupsSummaryRequest, opts ...grpc.CallOption) (*TopologyResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.topology.CustomDataAPI.DCClusterGroupsSummary")
	return c.CustomDataAPIServer.DCClusterGroupsSummary(ctx, in)
}
func (c *customDataAPIInprocClient) DCClusterTopology(ctx context.Context, in *DCClusterTopologyRequest, opts ...grpc.CallOption) (*TopologyResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.topology.CustomDataAPI.DCClusterTopology")
	return c.CustomDataAPIServer.DCClusterTopology(ctx, in)
}
func (c *customDataAPIInprocClient) GetNetworkRouteTables(ctx context.Context, in *NetworkRouteTablesRequest, opts ...grpc.CallOption) (*NetworkRouteTablesResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.topology.CustomDataAPI.GetNetworkRouteTables")
	return c.CustomDataAPIServer.GetNetworkRouteTables(ctx, in)
}
func (c *customDataAPIInprocClient) GetRouteTable(ctx context.Context, in *RouteTableRequest, opts ...grpc.CallOption) (*RouteTableResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.topology.CustomDataAPI.GetRouteTable")
	return c.CustomDataAPIServer.GetRouteTable(ctx, in)
}
func (c *customDataAPIInprocClient) GetSiteNetworks(ctx context.Context, in *SiteNetworksRequest, opts ...grpc.CallOption) (*SiteNetworksResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.topology.CustomDataAPI.GetSiteNetworks")
	return c.CustomDataAPIServer.GetSiteNetworks(ctx, in)
}
func (c *customDataAPIInprocClient) GetTGWRouteTables(ctx context.Context, in *TGWRouteTablesRequest, opts ...grpc.CallOption) (*TGWRouteTablesResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.topology.CustomDataAPI.GetTGWRouteTables")
	return c.CustomDataAPIServer.GetTGWRouteTables(ctx, in)
}
func (c *customDataAPIInprocClient) SiteMeshGroupsSummary(ctx context.Context, in *SiteMeshGroupsSummaryRequest, opts ...grpc.CallOption) (*TopologyResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.topology.CustomDataAPI.SiteMeshGroupsSummary")
	return c.CustomDataAPIServer.SiteMeshGroupsSummary(ctx, in)
}
func (c *customDataAPIInprocClient) SiteMeshTopology(ctx context.Context, in *SiteMeshTopologyRequest, opts ...grpc.CallOption) (*TopologyResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.topology.CustomDataAPI.SiteMeshTopology")
	return c.CustomDataAPIServer.SiteMeshTopology(ctx, in)
}
func (c *customDataAPIInprocClient) SiteTopology(ctx context.Context, in *SiteTopologyRequest, opts ...grpc.CallOption) (*TopologyResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.topology.CustomDataAPI.SiteTopology")
	return c.CustomDataAPIServer.SiteTopology(ctx, in)
}

func NewCustomDataAPIInprocClient(svc svcfw.Service) CustomDataAPIClient {
	return &customDataAPIInprocClient{CustomDataAPIServer: NewCustomDataAPIServer(svc)}
}

// RegisterGwCustomDataAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwCustomDataAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterCustomDataAPIHandlerClient(ctx, mux, NewCustomDataAPIInprocClient(s))
}

// Create customDataAPISrv

// SERVER (satisfying CustomDataAPIServer interface)
type customDataAPISrv struct {
	svc svcfw.Service
}

func (s *customDataAPISrv) DCClusterGroupsSummary(ctx context.Context, in *DCClusterGroupsSummaryRequest) (*TopologyResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.topology.CustomDataAPI")
	cah, ok := ah.(CustomDataAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomDataAPIServer", ah)
	}

	var (
		rsp *TopologyResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.topology.DCClusterGroupsSummaryRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomDataAPI.DCClusterGroupsSummary' operation on 'topology'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.topology.CustomDataAPI.DCClusterGroupsSummary"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.DCClusterGroupsSummary(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.topology.TopologyResponse", rsp)...)

	return rsp, nil
}
func (s *customDataAPISrv) DCClusterTopology(ctx context.Context, in *DCClusterTopologyRequest) (*TopologyResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.topology.CustomDataAPI")
	cah, ok := ah.(CustomDataAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomDataAPIServer", ah)
	}

	var (
		rsp *TopologyResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.topology.DCClusterTopologyRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomDataAPI.DCClusterTopology' operation on 'topology'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.topology.CustomDataAPI.DCClusterTopology"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.DCClusterTopology(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.topology.TopologyResponse", rsp)...)

	return rsp, nil
}
func (s *customDataAPISrv) GetNetworkRouteTables(ctx context.Context, in *NetworkRouteTablesRequest) (*NetworkRouteTablesResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.topology.CustomDataAPI")
	cah, ok := ah.(CustomDataAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomDataAPIServer", ah)
	}

	var (
		rsp *NetworkRouteTablesResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.topology.NetworkRouteTablesRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomDataAPI.GetNetworkRouteTables' operation on 'topology'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.topology.CustomDataAPI.GetNetworkRouteTables"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetNetworkRouteTables(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.topology.NetworkRouteTablesResponse", rsp)...)

	return rsp, nil
}
func (s *customDataAPISrv) GetRouteTable(ctx context.Context, in *RouteTableRequest) (*RouteTableResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.topology.CustomDataAPI")
	cah, ok := ah.(CustomDataAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomDataAPIServer", ah)
	}

	var (
		rsp *RouteTableResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.topology.RouteTableRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomDataAPI.GetRouteTable' operation on 'topology'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.topology.CustomDataAPI.GetRouteTable"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetRouteTable(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.topology.RouteTableResponse", rsp)...)

	return rsp, nil
}
func (s *customDataAPISrv) GetSiteNetworks(ctx context.Context, in *SiteNetworksRequest) (*SiteNetworksResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.topology.CustomDataAPI")
	cah, ok := ah.(CustomDataAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomDataAPIServer", ah)
	}

	var (
		rsp *SiteNetworksResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.topology.SiteNetworksRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomDataAPI.GetSiteNetworks' operation on 'topology'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.topology.CustomDataAPI.GetSiteNetworks"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetSiteNetworks(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.topology.SiteNetworksResponse", rsp)...)

	return rsp, nil
}
func (s *customDataAPISrv) GetTGWRouteTables(ctx context.Context, in *TGWRouteTablesRequest) (*TGWRouteTablesResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.topology.CustomDataAPI")
	cah, ok := ah.(CustomDataAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomDataAPIServer", ah)
	}

	var (
		rsp *TGWRouteTablesResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.topology.TGWRouteTablesRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomDataAPI.GetTGWRouteTables' operation on 'topology'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.topology.CustomDataAPI.GetTGWRouteTables"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetTGWRouteTables(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.topology.TGWRouteTablesResponse", rsp)...)

	return rsp, nil
}
func (s *customDataAPISrv) SiteMeshGroupsSummary(ctx context.Context, in *SiteMeshGroupsSummaryRequest) (*TopologyResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.topology.CustomDataAPI")
	cah, ok := ah.(CustomDataAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomDataAPIServer", ah)
	}

	var (
		rsp *TopologyResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.topology.SiteMeshGroupsSummaryRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomDataAPI.SiteMeshGroupsSummary' operation on 'topology'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.topology.CustomDataAPI.SiteMeshGroupsSummary"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SiteMeshGroupsSummary(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.topology.TopologyResponse", rsp)...)

	return rsp, nil
}
func (s *customDataAPISrv) SiteMeshTopology(ctx context.Context, in *SiteMeshTopologyRequest) (*TopologyResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.topology.CustomDataAPI")
	cah, ok := ah.(CustomDataAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomDataAPIServer", ah)
	}

	var (
		rsp *TopologyResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.topology.SiteMeshTopologyRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomDataAPI.SiteMeshTopology' operation on 'topology'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.topology.CustomDataAPI.SiteMeshTopology"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SiteMeshTopology(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.topology.TopologyResponse", rsp)...)

	return rsp, nil
}
func (s *customDataAPISrv) SiteTopology(ctx context.Context, in *SiteTopologyRequest) (*TopologyResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.topology.CustomDataAPI")
	cah, ok := ah.(CustomDataAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomDataAPIServer", ah)
	}

	var (
		rsp *TopologyResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.topology.SiteTopologyRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomDataAPI.SiteTopology' operation on 'topology'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.topology.CustomDataAPI.SiteTopology"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SiteTopology(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.topology.TopologyResponse", rsp)...)

	return rsp, nil
}

func NewCustomDataAPIServer(svc svcfw.Service) CustomDataAPIServer {
	return &customDataAPISrv{svc: svc}
}

var CustomDataAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "Topology",
        "description": "APIs to get topology of all the resources associated/connected to a site such as other CEs (Customer Edge),\nREs (Regional Edge), VPCs (Virtual Private Cloud) networks, etc., and the associated metrics. Relationship between\nthe resources associated with a site is represented as a graph, where each resource/entity is represented as a node\n(example: CE, RE, VPC, Subnet, etc.,) and their association is represented as edge (example: CE - RE connection,\nNetwork - Subnets association, etc.,)",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/public/namespaces/system/topology/dc_cluster_group/{dc_cluster_group}": {
            "post": {
                "summary": "DC Cluster Topology",
                "description": "Get topology of a DC Cluster.",
                "operationId": "ves.io.schema.topology.CustomDataAPI.DCClusterTopology",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/topologyTopologyResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "dc_cluster_group",
                        "description": "DC Cluster group\n\nx-example: \"dcg-1\"\nName of the DC Cluster group",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "DC Cluster group"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/topologyDCClusterTopologyRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomDataAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-topology-customdataapi-dcclustertopology"
                },
                "x-ves-proto-rpc": "ves.io.schema.topology.CustomDataAPI.DCClusterTopology"
            },
            "x-displayname": "Topology APIs",
            "x-ves-proto-service": "ves.io.schema.topology.CustomDataAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/topology/dc_cluster_groups": {
            "get": {
                "summary": "DC Cluster Groups Summary",
                "description": "Get summary of all DC Cluster groups.",
                "operationId": "ves.io.schema.topology.CustomDataAPI.DCClusterGroupsSummary",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/topologyTopologyResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "tags": [
                    "CustomDataAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-topology-customdataapi-dcclustergroupssummary"
                },
                "x-ves-proto-rpc": "ves.io.schema.topology.CustomDataAPI.DCClusterGroupsSummary"
            },
            "x-displayname": "Topology APIs",
            "x-ves-proto-service": "ves.io.schema.topology.CustomDataAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/topology/network/{id}/route_tables": {
            "get": {
                "summary": "Get Network Route Tables",
                "description": "Gets Route Tables Associated with a Network",
                "operationId": "ves.io.schema.topology.CustomDataAPI.GetNetworkRouteTables",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/topologyNetworkRouteTablesResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "id",
                        "description": "Id\n\nx-example: \"vpc-1234567898\"\nx-required\nNetwork Id",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Id"
                    },
                    {
                        "name": "route_table_ids",
                        "description": "x-example: \"rtb-1234567898, rtb-2345678901\"\nRoute Table Ids used as filters",
                        "in": "query",
                        "required": false,
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "collectionFormat": "multi",
                        "x-displayname": "Route Table Ids"
                    },
                    {
                        "name": "subnet_ids",
                        "description": "x-example: \"sub-1234567898, sub-2345678901\"\nSubnet Ids used as filters",
                        "in": "query",
                        "required": false,
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "collectionFormat": "multi",
                        "x-displayname": "Subnet Ids"
                    },
                    {
                        "name": "subnet_cidrs",
                        "description": "x-example: \"10.10.0.0/16, 10.22.0.0/16\"\nSubnet cidrs used as filters",
                        "in": "query",
                        "required": false,
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "collectionFormat": "multi",
                        "x-displayname": "Subnet Cidrs"
                    },
                    {
                        "name": "regions",
                        "description": "x-example: \"us-west1, us-east1\"\nRegions used as filters",
                        "in": "query",
                        "required": false,
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "collectionFormat": "multi",
                        "x-displayname": "Regions"
                    },
                    {
                        "name": "site",
                        "description": "x-example: \"site-name1\"\nSite Name",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Site"
                    }
                ],
                "tags": [
                    "CustomDataAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-topology-customdataapi-getnetworkroutetables"
                },
                "x-ves-proto-rpc": "ves.io.schema.topology.CustomDataAPI.GetNetworkRouteTables"
            },
            "x-displayname": "Topology APIs",
            "x-ves-proto-service": "ves.io.schema.topology.CustomDataAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/topology/route_table/{name}": {
            "get": {
                "summary": "Get Route Table",
                "description": "Get Route Table",
                "operationId": "ves.io.schema.topology.CustomDataAPI.GetRouteTable",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/topologyRouteTableResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "name",
                        "description": "Name\n\nx-required\nx-example: \"rt-1\"\nRoute table name",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Name"
                    }
                ],
                "tags": [
                    "CustomDataAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-topology-customdataapi-getroutetable"
                },
                "x-ves-proto-rpc": "ves.io.schema.topology.CustomDataAPI.GetRouteTable"
            },
            "x-displayname": "Topology APIs",
            "x-ves-proto-service": "ves.io.schema.topology.CustomDataAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/topology/site/{name}/networks": {
            "get": {
                "summary": "Get Site Networks",
                "description": "Gets Networks Associated to Site",
                "operationId": "ves.io.schema.topology.CustomDataAPI.GetSiteNetworks",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/topologySiteNetworksResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "name",
                        "description": "Name\n\nx-required\nx-example: \"site-1\"\nSite name",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Name"
                    }
                ],
                "tags": [
                    "CustomDataAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-topology-customdataapi-getsitenetworks"
                },
                "x-ves-proto-rpc": "ves.io.schema.topology.CustomDataAPI.GetSiteNetworks"
            },
            "x-displayname": "Topology APIs",
            "x-ves-proto-service": "ves.io.schema.topology.CustomDataAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/topology/site/{site}": {
            "post": {
                "summary": "Site Topology",
                "description": "Get topology of a site and the resources associated/connected to the site such as other Customer sites,\nRegional Sites, VPCs (Virtual Private Cloud) networks, etc., and the associated metrics.",
                "operationId": "ves.io.schema.topology.CustomDataAPI.SiteTopology",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/topologyTopologyResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "site",
                        "description": "Site\n\n\nx-example: \"ce01\"\nName of the site",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Site"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/topologySiteTopologyRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomDataAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-topology-customdataapi-sitetopology"
                },
                "x-ves-proto-rpc": "ves.io.schema.topology.CustomDataAPI.SiteTopology"
            },
            "x-displayname": "Topology APIs",
            "x-ves-proto-service": "ves.io.schema.topology.CustomDataAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/topology/site_mesh_group/{site_mesh_group}": {
            "post": {
                "summary": "Site Mesh Topology",
                "description": "Get topology of a site mesh.",
                "operationId": "ves.io.schema.topology.CustomDataAPI.SiteMeshTopology",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/topologyTopologyResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "site_mesh_group",
                        "description": "Site Mesh Group\n\n\nx-example: \"smg-1\"\nName of the site mesh group",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Site Mesh Group"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/topologySiteMeshTopologyRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomDataAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-topology-customdataapi-sitemeshtopology"
                },
                "x-ves-proto-rpc": "ves.io.schema.topology.CustomDataAPI.SiteMeshTopology"
            },
            "x-displayname": "Topology APIs",
            "x-ves-proto-service": "ves.io.schema.topology.CustomDataAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/topology/site_mesh_groups": {
            "get": {
                "summary": "Site Mesh Groups Summary",
                "description": "Get summary of all site mesh groups.",
                "operationId": "ves.io.schema.topology.CustomDataAPI.SiteMeshGroupsSummary",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/topologyTopologyResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "tags": [
                    "CustomDataAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-topology-customdataapi-sitemeshgroupssummary"
                },
                "x-ves-proto-rpc": "ves.io.schema.topology.CustomDataAPI.SiteMeshGroupsSummary"
            },
            "x-displayname": "Topology APIs",
            "x-ves-proto-service": "ves.io.schema.topology.CustomDataAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/topology/tgw/{id}/route_tables": {
            "get": {
                "summary": "Get TGW Route Tables",
                "description": "Gets Route Tables Associated with a TGW",
                "operationId": "ves.io.schema.topology.CustomDataAPI.GetTGWRouteTables",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/topologyTGWRouteTablesResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "id",
                        "description": "Id\n\nx-example: \"tgw-1234567898\"\nx-required\nTGW Id",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Id"
                    },
                    {
                        "name": "route_table_ids",
                        "description": "x-example: \"rtb-1234567898, rtb-2345678901\"\nRoute Table Ids used as filters",
                        "in": "query",
                        "required": false,
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "collectionFormat": "multi",
                        "x-displayname": "Route Table Ids"
                    },
                    {
                        "name": "attachment_ids",
                        "description": "x-example: \"attach-1234567898, attach-2345678901\"\nRoute Table Ids used as filters",
                        "in": "query",
                        "required": false,
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "collectionFormat": "multi",
                        "x-displayname": "TGW Attachment Ids"
                    }
                ],
                "tags": [
                    "CustomDataAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-topology-customdataapi-gettgwroutetables"
                },
                "x-ves-proto-rpc": "ves.io.schema.topology.CustomDataAPI.GetTGWRouteTables"
            },
            "x-displayname": "Topology APIs",
            "x-ves-proto-service": "ves.io.schema.topology.CustomDataAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        }
    },
    "definitions": {
        "dc_cluster_groupDCClusterGroupMeshType": {
            "type": "object",
            "description": "Details of DC Cluster Group Mesh Type",
            "title": "DC Cluster Group Mesh Type",
            "x-displayname": "DC Cluster Group Mesh Type",
            "x-ves-oneof-field-dc_cluster_group_mesh_choice": "[\"control_and_data_plane_mesh\",\"data_plane_mesh\"]",
            "x-ves-proto-message": "ves.io.schema.dc_cluster_group.DCClusterGroupMeshType",
            "properties": {
                "control_and_data_plane_mesh": {
                    "description": "Exclusive with [data_plane_mesh]\n Full Mesh of data plane connectivity across sites\n and control plane peering across sites",
                    "title": "Control and Data Plane Mesh",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Control and Data Plane Mesh"
                },
                "data_plane_mesh": {
                    "description": "Exclusive with [control_and_data_plane_mesh]\n Full Mesh of Data plane connectivity across sites",
                    "title": "Data Plane Mesh",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Data Plane Mesh"
                }
            }
        },
        "ioschemaEmpty": {
            "type": "object",
            "description": "This can be used for messages where no values are needed",
            "title": "Empty",
            "x-displayname": "Empty",
            "x-ves-proto-message": "ves.io.schema.Empty"
        },
        "ioschemaObjectRefType": {
            "type": "object",
            "description": "This type establishes a 'direct reference' from one object(the referrer) to another(the referred).\nSuch a reference is in form of tenant/namespace/name for public API and Uid for private API\nThis type of reference is called direct because the relation is explicit and concrete (as opposed\nto selector reference which builds a group based on labels of selectee objects)",
            "title": "ObjectRefType",
            "x-displayname": "Object reference",
            "x-ves-proto-message": "ves.io.schema.ObjectRefType",
            "properties": {
                "kind": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then kind will hold the referred object's kind (e.g. \"route\")\n\nExample: - \"virtual_site\"-",
                    "title": "kind",
                    "x-displayname": "Kind",
                    "x-ves-example": "virtual_site"
                },
                "name": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then name will hold the referred object's(e.g. route's) name.\n\nExample: - \"contactus-route\"-",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "contactus-route"
                },
                "namespace": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then namespace will hold the referred object's(e.g. route's) namespace.\n\nExample: - \"ns1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1"
                },
                "tenant": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then tenant will hold the referred object's(e.g. route's) tenant.\n\nExample: - \"acmecorp\"-",
                    "title": "tenant",
                    "x-displayname": "Tenant",
                    "x-ves-example": "acmecorp"
                },
                "uid": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then uid will hold the referred object's(e.g. route's) uid.\n\nExample: - \"d15f1fad-4d37-48c0-8706-df1824d76d31\"-",
                    "title": "uid",
                    "x-displayname": "UID",
                    "x-ves-example": "d15f1fad-4d37-48c0-8706-df1824d76d31"
                }
            }
        },
        "schemaIpSubnetType": {
            "type": "object",
            "description": "IP Address used to specify an IPv4 or IPv6 subnet addresses",
            "title": "IP Subnet",
            "x-displayname": "IP Subnet",
            "x-ves-displayorder": "3",
            "x-ves-oneof-field-ver": "[\"ipv4\",\"ipv6\"]",
            "x-ves-proto-message": "ves.io.schema.IpSubnetType",
            "properties": {
                "ipv4": {
                    "description": "Exclusive with [ipv6]\n IPv4 Subnet Address",
                    "title": "IPv4 Subnet",
                    "$ref": "#/definitions/schemaIpv4SubnetType",
                    "x-displayname": "IPv4 Subnet"
                },
                "ipv6": {
                    "description": "Exclusive with [ipv4]\n IPv6 Subnet Address",
                    "title": "IPv6 Subnet",
                    "$ref": "#/definitions/schemaIpv6SubnetType",
                    "x-displayname": "IPv6 Subnet"
                }
            }
        },
        "schemaIpv4SubnetType": {
            "type": "object",
            "description": "IPv4 subnets specified as prefix and prefix-length. Prefix length must be \u003c= 32",
            "title": "IPv4 Subnet",
            "x-displayname": "IPv4 Subnet",
            "x-ves-proto-message": "ves.io.schema.Ipv4SubnetType",
            "properties": {
                "plen": {
                    "type": "integer",
                    "description": " Prefix-length of the IPv4 subnet. Must be \u003c= 32\n\nExample: - \"24\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.lte: 32\n",
                    "title": "Prefix Length",
                    "format": "int64",
                    "x-displayname": "Prefix Length",
                    "x-ves-example": "24",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.lte": "32"
                    }
                },
                "prefix": {
                    "type": "string",
                    "description": " Prefix part of the IPv4 subnet in string form with dot-decimal notation\n\nExample: - \"192.168.1.0\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.ipv4: true\n",
                    "title": "Prefix",
                    "x-displayname": "Prefix",
                    "x-ves-example": "192.168.1.0",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.ipv4": "true"
                    }
                }
            }
        },
        "schemaIpv6SubnetType": {
            "type": "object",
            "description": "IPv6 subnets specified as prefix and prefix-length. prefix-legnth must be \u003c= 128",
            "title": "IPv6 Subnet",
            "x-displayname": "IPv6 Subnet",
            "x-ves-proto-message": "ves.io.schema.Ipv6SubnetType",
            "properties": {
                "plen": {
                    "type": "integer",
                    "description": " Prefix length of the IPv6 subnet. Must be \u003c= 128\n\nExample: - \"38\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.lte: 128\n",
                    "title": "Prefix length",
                    "format": "int64",
                    "x-displayname": "Prefix Length",
                    "x-ves-example": "38",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.lte": "128"
                    }
                },
                "prefix": {
                    "type": "string",
                    "description": " Prefix part of the IPv6 subnet given in form of string.\n IPv6 address must be specified as hexadecimal numbers separated by ':'\n e.g. \"2001:db8:0:0:0:2:0:0\"\n The address can be compacted by suppressing zeros\n e.g. \"2001:db8::2::\"\n\nExample: - \"2001:db8:0:0:0:0:2:0\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.ipv6: true\n",
                    "title": "Prefix",
                    "x-displayname": "Prefix",
                    "x-ves-example": "2001:db8:0:0:0:0:2:0",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.ipv6": "true"
                    }
                }
            }
        },
        "schemaMetricValue": {
            "type": "object",
            "description": "Metric data contains timestamp and the value.",
            "title": "Metric Value",
            "x-displayname": "Metric Value",
            "x-ves-proto-message": "ves.io.schema.MetricValue",
            "properties": {
                "timestamp": {
                    "type": "number",
                    "description": " timestamp\n\nExample: - \"1570007981\"-",
                    "title": "Timestamp",
                    "format": "double",
                    "x-displayname": "Timestamp",
                    "x-ves-example": "1570007981"
                },
                "trend_value": {
                    "description": " trend value for the metric\n\nExample: - \"100.000000\"-",
                    "title": "Trend value",
                    "$ref": "#/definitions/schemaTrendValue",
                    "x-displayname": "Trend Value",
                    "x-ves-example": "100.000000"
                },
                "value": {
                    "type": "string",
                    "description": "\n\nExample: - \"15\"-",
                    "title": "Value",
                    "x-displayname": "Value",
                    "x-ves-example": "15"
                }
            }
        },
        "schemaTrendSentiment": {
            "type": "string",
            "description": "trend sentiment\n\nIndicates trend sentiment is positive\nIndicates trend sentiment is negative.",
            "title": "Trend Sentiment",
            "enum": [
                "TREND_SENTIMENT_NONE",
                "TREND_SENTIMENT_POSITIVE",
                "TREND_SENTIMENT_NEGATIVE"
            ],
            "default": "TREND_SENTIMENT_NONE",
            "x-displayname": "Trend Sentiment",
            "x-ves-proto-enum": "ves.io.schema.TrendSentiment"
        },
        "schemaTrendValue": {
            "type": "object",
            "description": "Trend value contains trend value, trend sentiment and trend calculation description and window size.",
            "title": "Trend Value",
            "x-displayname": "Trend Value",
            "x-ves-proto-message": "ves.io.schema.TrendValue",
            "properties": {
                "description": {
                    "type": "string",
                    "description": " description of the method used to calculate trend.\n\nExample: - \"Trend was calculated by comparing the avg of window size intervals of end-start Time and last window time interval\"-",
                    "title": "Description",
                    "x-displayname": "Description",
                    "x-ves-example": "Trend was calculated by comparing the avg of window size intervals of end-start Time and last window time interval"
                },
                "previous_value": {
                    "type": "string",
                    "description": "\n\nExample: - \"200.00\"-",
                    "title": "Previous Value",
                    "x-displayname": "Previous Value",
                    "x-ves-example": "200.00"
                },
                "sentiment": {
                    "description": "\n\nExample: - \"Positive\"-",
                    "title": "Sentiment",
                    "$ref": "#/definitions/schemaTrendSentiment",
                    "x-displayname": "Sentiment",
                    "x-ves-example": "Positive"
                },
                "value": {
                    "type": "string",
                    "description": "\n\nExample: - \"-15\"-",
                    "title": "Value",
                    "x-displayname": "Value",
                    "x-ves-example": "-15"
                }
            }
        },
        "schemaUnitType": {
            "type": "string",
            "description": "UnitType is enumeration of units for scalar fields",
            "title": "UnitType",
            "enum": [
                "UNIT_MILLISECONDS",
                "UNIT_SECONDS",
                "UNIT_MINUTES",
                "UNIT_HOURS",
                "UNIT_DAYS",
                "UNIT_BYTES",
                "UNIT_KBYTES",
                "UNIT_MBYTES",
                "UNIT_GBYTES",
                "UNIT_TBYTES",
                "UNIT_KIBIBYTES",
                "UNIT_MIBIBYTES",
                "UNIT_GIBIBYTES",
                "UNIT_TEBIBYTES",
                "UNIT_BITS_PER_SECOND",
                "UNIT_BYTES_PER_SECOND",
                "UNIT_KBITS_PER_SECOND",
                "UNIT_KBYTES_PER_SECOND",
                "UNIT_MBITS_PER_SECOND",
                "UNIT_MBYTES_PER_SECOND",
                "UNIT_CONNECTIONS_PER_SECOND",
                "UNIT_ERRORS_PER_SECOND",
                "UNIT_PACKETS_PER_SECOND",
                "UNIT_REQUESTS_PER_SECOND",
                "UNIT_PACKETS",
                "UNIT_PERCENTAGE",
                "UNIT_COUNT"
            ],
            "default": "UNIT_MILLISECONDS",
            "x-displayname": "Unit",
            "x-ves-proto-enum": "ves.io.schema.UnitType"
        },
        "schemaVirtualNetworkType": {
            "type": "string",
            "description": "Different types of virtual networks understood by the system\n\nVirtual-network of type VIRTUAL_NETWORK_SITE_LOCAL provides connectivity to public (outside) network.\nThis is an insecure network and is connected to public internet via NAT Gateways/firwalls\nVirtual-network of this type is local to every site. Two virtual networks of this type on different\nsites are neither related nor connected.\n\nConstraints:\nThere can be atmost one virtual network of this type in a given site.\nThis network type is supported on CE sites. This network is created automatically and present on all sites\nVirtual-network of type VIRTUAL_NETWORK_SITE_LOCAL_INSIDE is a private network inside site.\nIt is a secure network and is not connected to public network.\nVirtual-network of this type is local to every site. Two virtual networks of this type on different\nsites are neither related nor connected.\n\nConstraints:\nThere can be atmost one virtual network of this type in a given site.\nThis network type is supported on CE sites. This network is created during provisioning of site\nUser defined per-site virtual network. Scope of this virtual network is limited to the site.\nThis is not yet supported\nVirtual-network of type VIRTUAL_NETWORK_PUBLIC directly conects to the public internet.\nVirtual-network of this type is local to every site. Two virtual networks of this type on different sites are neither related nor connected.\n\nConstraints:\nThere can be atmost one virtual network of this type in a given site.\nThis network type is supported on RE sites only\nIt is an internally created by the system. They must not be created by user\nVirtual Neworks with global scope across different sites in F5XC domain.\nAn example global virtual-network called \"AIN Network\" is created for every tenant.\nfor volterra fabric\n\nConstraints:\nIt is currently only supported as internally created by the system.\nvK8s service network for a given tenant. Used to advertise a virtual host only to vk8s pods for that tenant\nConstraints:\nIt is an internally created by the system. Must not be created by user\nVER internal network for the site. It can only be used for virtual hosts with SMA_PROXY type proxy\nConstraints:\nIt is an internally created by the system. Must not be created by user\nVirtual-network of type VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE represents both\nVIRTUAL_NETWORK_SITE_LOCAL and VIRTUAL_NETWORK_SITE_LOCAL_INSIDE\n\nConstraints:\nThis network type is only meaningful in an advertise policy\nWhen virtual-network of type VIRTUAL_NETWORK_IP_AUTO is selected for\nan endpoint, VER will try to determine the network based on the provided\nIP address\n\nConstraints:\nThis network type is only meaningful in an endpoint\n\nVoltADN Private Network is used on volterra RE(s) to connect to customer private networks\nThis network is created by opening a support ticket\n\nThis network is per site srv6 network\nVER IP Fabric network for the site.\nThis Virtual network type is used for exposing virtual host on IP Fabric network on the VER site or\nfor endpoint in IP Fabric network\nConstraints:\nIt is an internally created by the system. Must not be created by user\nNetwork internally created for a segment\nConstraints:\nIt is an internally created by the system. Must not be created by user",
            "title": "VirtualNetworkType",
            "enum": [
                "VIRTUAL_NETWORK_SITE_LOCAL",
                "VIRTUAL_NETWORK_SITE_LOCAL_INSIDE",
                "VIRTUAL_NETWORK_PER_SITE",
                "VIRTUAL_NETWORK_PUBLIC",
                "VIRTUAL_NETWORK_GLOBAL",
                "VIRTUAL_NETWORK_SITE_SERVICE",
                "VIRTUAL_NETWORK_VER_INTERNAL",
                "VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE",
                "VIRTUAL_NETWORK_IP_AUTO",
                "VIRTUAL_NETWORK_VOLTADN_PRIVATE_NETWORK",
                "VIRTUAL_NETWORK_SRV6_NETWORK",
                "VIRTUAL_NETWORK_IP_FABRIC",
                "VIRTUAL_NETWORK_SEGMENT"
            ],
            "default": "VIRTUAL_NETWORK_SITE_LOCAL",
            "x-displayname": "Virtual Network Type",
            "x-ves-proto-enum": "ves.io.schema.VirtualNetworkType"
        },
        "schemasiteLinkType": {
            "type": "string",
            "description": "Link type of interface determined operationally\n\nLink type unknown\nLink type ethernet\nWiFi link of type 802.11ac\nWiFi link of type 802.11bgn\nLink type 4G\nWiFi link\nWan link",
            "title": "Link type",
            "enum": [
                "LINK_TYPE_UNKNOWN",
                "LINK_TYPE_ETHERNET",
                "LINK_TYPE_WIFI_802_11AC",
                "LINK_TYPE_WIFI_802_11BGN",
                "LINK_TYPE_4G",
                "LINK_TYPE_WIFI",
                "LINK_TYPE_WAN"
            ],
            "default": "LINK_TYPE_UNKNOWN",
            "x-displayname": "Link type",
            "x-ves-proto-enum": "ves.io.schema.site.LinkType"
        },
        "schemasiteNode": {
            "type": "object",
            "description": "Node Information for connectivity across sites.",
            "title": "Node",
            "x-displayname": "Node",
            "x-ves-proto-message": "ves.io.schema.site.Node",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " Name of the master/main node on the site.",
                    "title": "name",
                    "x-displayname": "Node name"
                },
                "sli_address": {
                    "type": "string",
                    "description": " Site Local Inside IP address.",
                    "title": "sli_address",
                    "x-displayname": "Site Local Inside IP addresses"
                },
                "slo_address": {
                    "type": "string",
                    "description": " Site Local Outside IP address.",
                    "title": "slo_address",
                    "x-displayname": "Site Local Outside IP addresses"
                }
            }
        },
        "schemasiteSiteType": {
            "type": "string",
            "description": "Site Type which can either RE or CE\n\nInvalid type of site\nRegional Edge site\nCustomer Edge site",
            "title": "SiteType",
            "enum": [
                "INVALID",
                "REGIONAL_EDGE",
                "CUSTOMER_EDGE",
                "NGINX_ONE"
            ],
            "default": "INVALID",
            "x-displayname": "Site Type",
            "x-ves-proto-enum": "ves.io.schema.site.SiteType"
        },
        "schemasite_mesh_groupSiteMeshGroupType": {
            "type": "string",
            "description": "Defines different types of Mesh\n\nInvalid mesh type\nMesh of type Hub\nMesh of type Spoke\nFull mesh of tunnels are created between all sites",
            "title": "Site Mesh Group Type",
            "enum": [
                "SITE_MESH_GROUP_TYPE_INVALID",
                "SITE_MESH_GROUP_TYPE_HUB_FULL_MESH",
                "SITE_MESH_GROUP_TYPE_SPOKE",
                "SITE_MESH_GROUP_TYPE_FULL_MESH"
            ],
            "default": "SITE_MESH_GROUP_TYPE_INVALID",
            "x-displayname": "Mesh Type",
            "x-ves-proto-enum": "ves.io.schema.site_mesh_group.SiteMeshGroupType"
        },
        "schematopologyLinkType": {
            "type": "string",
            "description": "Enumerates the association/relationship between 2 nodes.\n\nIndicates that 2 nodes are connected using a tunnel\nIndicates network connection\nIndicates connection to subnet\nIndicates connection to instance\nIndicates association with site mesh group\nIndicates association with DC Cluster group\nIndicates L3 connection between the nodes\nIndicates the Control plane connection between the nodes\nIndicates the BGP connection between the tgw and site",
            "title": "LinkType",
            "enum": [
                "LINK_TYPE_TUNNEL",
                "LINK_TYPE_NETWORK",
                "LINK_TYPE_SUBNET",
                "LINK_TYPE_INSTANCE",
                "LINK_TYPE_SITE_MESH_GROUP",
                "LINK_TYPE_DC_CLUSTER_GROUP",
                "LINK_TYPE_L3",
                "LINK_TYPE_CONTROL_PLANE",
                "LINK_TYPE_BGP_CONNECTION"
            ],
            "default": "LINK_TYPE_TUNNEL",
            "x-displayname": "Link Type",
            "x-ves-proto-enum": "ves.io.schema.topology.LinkType"
        },
        "schematopologyMetricType": {
            "type": "string",
            "description": "List of metric types applicable for the nodes and edges in the topology graph.\nNot all metric types are applicable for all nodes or edges. For example, LATENCY metric\nis applicable only for the edges where both the vertices are sites and CPU_USAGE metric is\napplicable only for node of type instance. This list is a union of all metric types.\n\nTotal incoming traffic in bytes\nTotal outgoing traffic in bytes\nTotal incoming packets dropped\nTotal outgoing packets dropped\nReachability based on probes sent periodically\nAverage latency in seconds\nAverage CPU utilization in percentage\nAverage Memory utilization in percentage\nAverage Disk utilization in percentage\nConnection status of the tunnel\nControl plane connection status of the tunnel",
            "title": "Metric Type",
            "enum": [
                "METRIC_TYPE_IN_BYTES",
                "METRIC_TYPE_OUT_BYTES",
                "METRIC_TYPE_IN_DROP_PACKETS",
                "METRIC_TYPE_OUT_DROP_PACKETS",
                "METRIC_TYPE_REACHABILITY_PERCENT",
                "METRIC_TYPE_LATENCY_SECONDS",
                "METRIC_TYPE_CPU_USAGE_PERCENT",
                "METRIC_TYPE_MEMORY_USAGE_PERCENT",
                "METRIC_TYPE_DISK_USAGE_PERCENT",
                "METRIC_TYPE_DATA_PLANE_CONNECTION_STATUS",
                "METRIC_TYPE_CONTROL_PLANE_CONNECTION_STATUS"
            ],
            "default": "METRIC_TYPE_IN_BYTES",
            "x-displayname": "Metric Type",
            "x-ves-proto-enum": "ves.io.schema.topology.MetricType"
        },
        "schematopologyMetricTypeData": {
            "type": "object",
            "description": "Metric Type Data contains key that uniquely identifies individual entity and its corresponding metric values.\nFor example, if an instance contains multiple interfaces, then the key contains the name/value pair that identifies\nthe interface name of the instance.",
            "title": "Metric Type Data",
            "x-displayname": "Metric Type Data",
            "x-ves-proto-message": "ves.io.schema.topology.MetricTypeData",
            "properties": {
                "labels": {
                    "type": "object",
                    "description": " Labels contains the name/value pair that uniquely identifies an entity whose metric is being reported.\n If the Labels is empty, then the metric value is for the corresponding node or edge.\n For example, if an instance contains multiple interfaces, then the labels contains the name/value pairs that identifies\n the interface name of the instance.",
                    "title": "Labels",
                    "x-displayname": "Labels"
                },
                "values": {
                    "type": "array",
                    "description": " List of metric values. May contain more than one value if timeseries data is requested.",
                    "title": "Value",
                    "items": {
                        "$ref": "#/definitions/schemaMetricValue"
                    },
                    "x-displayname": "Value"
                }
            }
        },
        "schematopologyNode": {
            "type": "object",
            "description": "Canonical representation of Node in the topology graph.",
            "title": "Node",
            "x-displayname": "Node",
            "x-ves-oneof-field-node_type": "[\"dc_cluster_group\",\"instance\",\"network\",\"site\",\"site_mesh_group\",\"subnet\",\"transit_gateway\"]",
            "x-ves-proto-message": "ves.io.schema.topology.Node",
            "properties": {
                "dc_cluster_group": {
                    "description": "Exclusive with [instance network site site_mesh_group subnet transit_gateway]\n DC Cluster Group data.",
                    "title": "DC Cluster Group",
                    "$ref": "#/definitions/topologyNodeTypeDCClusterGroup",
                    "x-displayname": "DC Cluster Group"
                },
                "id": {
                    "type": "string",
                    "description": " Identifier for the node.",
                    "title": "Id",
                    "x-displayname": "Id"
                },
                "instance": {
                    "description": "Exclusive with [dc_cluster_group network site site_mesh_group subnet transit_gateway]\n Instance data.",
                    "title": "Instance",
                    "$ref": "#/definitions/topologyNodeTypeInstance",
                    "x-displayname": "Instance"
                },
                "metadata": {
                    "description": " Metadata for the node.",
                    "title": "Metadata",
                    "$ref": "#/definitions/topologyNodeMetaData",
                    "x-displayname": "Metadata"
                },
                "network": {
                    "description": "Exclusive with [dc_cluster_group instance site site_mesh_group subnet transit_gateway]\n Network data.",
                    "title": "Network",
                    "$ref": "#/definitions/topologyNodeTypeNetwork",
                    "x-displayname": "Network"
                },
                "site": {
                    "description": "Exclusive with [dc_cluster_group instance network site_mesh_group subnet transit_gateway]\n Site data.",
                    "title": "Site",
                    "$ref": "#/definitions/topologyNodeTypeSite",
                    "x-displayname": "Site"
                },
                "site_mesh_group": {
                    "description": "Exclusive with [dc_cluster_group instance network site subnet transit_gateway]\n Site Mesh Group data.",
                    "title": "Site Mesh Group",
                    "$ref": "#/definitions/topologyNodeTypeSiteMeshGroup",
                    "x-displayname": "Site Mesh Group"
                },
                "subnet": {
                    "description": "Exclusive with [dc_cluster_group instance network site site_mesh_group transit_gateway]\n Subnet data.",
                    "title": "Subnet",
                    "$ref": "#/definitions/topologyNodeTypeSubnet",
                    "x-displayname": "Subnet"
                },
                "transit_gateway": {
                    "description": "Exclusive with [dc_cluster_group instance network site site_mesh_group subnet]\n Transit Gateway data.",
                    "title": "Transit Gateway",
                    "$ref": "#/definitions/topologyNodeTypeTransitGateway",
                    "x-displayname": "Transit Gateway"
                }
            }
        },
        "schematopologySiteMeshGroupType": {
            "type": "object",
            "description": "A canonical form of the site mesh group.",
            "title": "Site Mesh Group",
            "x-displayname": "site Mesh Group",
            "x-ves-oneof-field-mesh_choice": "[\"full_mesh\",\"hub_mesh\",\"spoke_mesh\"]",
            "x-ves-proto-message": "ves.io.schema.topology.SiteMeshGroupType",
            "properties": {
                "full_mesh": {
                    "description": "Exclusive with [hub_mesh spoke_mesh]\n Full mesh of tunnels are created between all sites",
                    "title": "full_mesh",
                    "$ref": "#/definitions/site_mesh_groupFullMeshGroupType",
                    "x-displayname": "Full Mesh"
                },
                "hub": {
                    "type": "array",
                    "description": " If 'Type' is Spoke, 'Hub' refers to a Site Mesh Group of 'type' Hub.\n Spoke sites connect to all the member sites of Hub Site Mesh Group.\n Hub will be empty when Site Mesh Group type is Hub or Full Mesh.",
                    "title": "Hub",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Hub (site mesh group)"
                },
                "hub_mesh": {
                    "description": "Exclusive with [full_mesh spoke_mesh]\n Mesh of Type Hub",
                    "title": "hub",
                    "$ref": "#/definitions/site_mesh_groupHubFullMeshGroupType",
                    "x-displayname": "Hub"
                },
                "site_type": {
                    "description": " Site type for sites in the virtual site",
                    "title": "site_type",
                    "$ref": "#/definitions/schemasiteSiteType",
                    "x-displayname": "Site Type"
                },
                "spoke_mesh": {
                    "description": "Exclusive with [full_mesh hub_mesh]\n Mesh of Type Spoke",
                    "title": "spoke",
                    "$ref": "#/definitions/site_mesh_groupSpokeMeshGroupType",
                    "x-displayname": "Spoke"
                },
                "topology_site": {
                    "type": "array",
                    "description": " Topology Sites referenced in this site_mesh_group",
                    "title": "Topology Site Reference",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Topology Site"
                },
                "type": {
                    "description": " Site Mesh Group Type",
                    "title": "Type",
                    "$ref": "#/definitions/schemasite_mesh_groupSiteMeshGroupType",
                    "x-displayname": "Type"
                },
                "virtual_site": {
                    "type": "array",
                    "description": " Virtual Site referenced in this site_mesh_group\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 1\n",
                    "title": "virtual_site",
                    "maxItems": 1,
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Virtual Site",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "1"
                    }
                }
            }
        },
        "schematopologySiteType": {
            "type": "object",
            "description": "A canonical form of the site.",
            "title": "Site",
            "x-displayname": "site",
            "x-ves-proto-message": "ves.io.schema.topology.SiteType",
            "properties": {
                "app_type": {
                    "description": " Site App Type",
                    "title": "Site App type",
                    "$ref": "#/definitions/topologySiteAppTypeEnum",
                    "x-displayname": "Site App type"
                },
                "dc_cluster_group": {
                    "type": "array",
                    "description": " Reference to the DC Cluster group",
                    "title": "DC Cluster Group",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "DC Cluster Group"
                },
                "gateway_type": {
                    "description": " Gateway type of the site",
                    "title": "Gateway Type",
                    "$ref": "#/definitions/topologyGatewayTypeEnum",
                    "x-displayname": "Gateway Type"
                },
                "network": {
                    "type": "array",
                    "description": " Reference to the network.",
                    "title": "Network",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Network"
                },
                "orchestration_mode": {
                    "description": " Whether the site is managed or not managed",
                    "title": "Orchestration Mode",
                    "$ref": "#/definitions/topologyOrchestrationMode",
                    "x-displayname": "Orchestration Mode"
                },
                "site_type": {
                    "description": " Site type indicates whether the site is CUSTOMER_EDGE or REGIONAL_EDGE",
                    "title": "Site type",
                    "$ref": "#/definitions/schemasiteSiteType",
                    "x-displayname": "Site Type"
                },
                "tgw": {
                    "type": "array",
                    "description": " Reference to the transit gateway",
                    "title": "TransitGateway",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "TransitGateway"
                }
            }
        },
        "schemaviewsObjectRefType": {
            "type": "object",
            "description": "This type establishes a direct reference from one object(the referrer) to another(the referred).\nSuch a reference is in form of tenant/namespace/name",
            "title": "ObjectRefType",
            "x-displayname": "Object reference",
            "x-ves-proto-message": "ves.io.schema.views.ObjectRefType",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then name will hold the referred object's(e.g. route's) name.\n\nExample: - \"contacts-route\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 128\n  ves.io.schema.rules.string.min_bytes: 1\n",
                    "title": "name",
                    "minLength": 1,
                    "maxLength": 128,
                    "x-displayname": "Name",
                    "x-ves-example": "contacts-route",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "128",
                        "ves.io.schema.rules.string.min_bytes": "1"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then namespace will hold the referred object's(e.g. route's) namespace.\n\nExample: - \"ns1\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 64\n",
                    "title": "namespace",
                    "maxLength": 64,
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "64"
                    }
                },
                "tenant": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then tenant will hold the referred object's(e.g. route's) tenant.\n\nExample: - \"acmecorp\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 64\n",
                    "title": "tenant",
                    "maxLength": 64,
                    "x-displayname": "Tenant",
                    "x-ves-example": "acmecorp",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "64"
                    }
                }
            }
        },
        "siteActiveState": {
            "type": "string",
            "description": "Active/Backup state for the interface\n\nUnknown state\nInterface in active state\nInterface in backup state",
            "title": "Active State",
            "enum": [
                "STATE_UNKNOWN",
                "STATE_ACTIVE",
                "STATE_BACKUP"
            ],
            "default": "STATE_UNKNOWN",
            "x-displayname": "Active State",
            "x-ves-proto-enum": "ves.io.schema.site.ActiveState"
        },
        "siteAddressMode": {
            "type": "string",
            "description": "AddressMode identifies the mode of address assignment on an interface\n\n - STATIC: Static\n\nInterface Address is assigned statically\n - DHCP: DHCP\n\nInterface Address is obtained via DHCP",
            "title": "Interface Address Mode",
            "enum": [
                "STATIC",
                "DHCP"
            ],
            "default": "STATIC",
            "x-displayname": "AddressMode",
            "x-ves-proto-enum": "ves.io.schema.site.AddressMode"
        },
        "siteBondMembersType": {
            "type": "object",
            "description": "BondMembersType represents the bond interface members  along with the corresponding link state",
            "title": "Bond Interface Members",
            "x-displayname": "Bond Interface Members",
            "x-ves-proto-message": "ves.io.schema.site.BondMembersType",
            "properties": {
                "link_speed": {
                    "type": "integer",
                    "description": " Link speed of Bond Interface Member in Mbps",
                    "title": "Link Speed\nx-displayName: \"Link Speed in Mbps\"\nLink speed of Bond Interface Member in Mbps",
                    "format": "int64",
                    "x-displayname": "Link Speed in Mbps"
                },
                "link_state": {
                    "type": "boolean",
                    "description": " Link state of Bond Interface Member",
                    "title": "Link State\nx-displayName: \"Link State\"\nLink state of Bond Interface Member",
                    "format": "boolean",
                    "x-displayname": "Link State"
                },
                "name": {
                    "type": "string",
                    "description": " Name of the Bond Interface Member",
                    "title": "Name\nx-displayName: \"Name\"\nName of the Bond Interface Member",
                    "x-displayname": "Name"
                }
            }
        },
        "siteInterfaceStatus": {
            "type": "object",
            "description": "Status of Interfaces in ver",
            "title": "Interface Status",
            "x-displayname": "Interface Status",
            "x-ves-proto-message": "ves.io.schema.site.InterfaceStatus",
            "properties": {
                "active_state": {
                    "description": " Active state for the interface",
                    "title": "Active-Backup status\nx-displayName: \"Active/Backup status\"\nActive state for the interface",
                    "$ref": "#/definitions/siteActiveState",
                    "x-displayname": "Active/Backup status"
                },
                "bond_members": {
                    "type": "array",
                    "description": " Members of the Bond interface along with the corresponding link state",
                    "title": "Bond Interface Members\nx-displayName: \"Bond Members\"\nMembers of the Bond interface along with the corresponding link state",
                    "items": {
                        "$ref": "#/definitions/siteBondMembersType"
                    },
                    "x-displayname": "Bond Members"
                },
                "dhcp_server": {
                    "type": "boolean",
                    "description": " Indicate if DHCP server is configured on the interface",
                    "title": "DHCP Server",
                    "format": "boolean",
                    "x-displayname": "DHCP Server"
                },
                "ip": {
                    "description": " IP address of interface",
                    "title": "IP subnet",
                    "$ref": "#/definitions/schemaIpSubnetType",
                    "x-displayname": "IP Subnet"
                },
                "ip_mode": {
                    "description": " Mode of address assignment on the interface",
                    "title": "IP Mode",
                    "$ref": "#/definitions/siteAddressMode",
                    "x-displayname": "IP Mode"
                },
                "ipv6": {
                    "description": " IPv6 address of interface",
                    "title": "IPv6 subnet",
                    "$ref": "#/definitions/schemaIpSubnetType",
                    "x-displayname": "IPv6 Subnet"
                },
                "link_quality": {
                    "description": " Link quality for the interface",
                    "title": "Link quality status\nx-displayName: \"Link Quality\"\nLink quality for the interface",
                    "$ref": "#/definitions/siteLinkQuality",
                    "x-displayname": "Link Quality"
                },
                "link_state": {
                    "type": "boolean",
                    "description": " Link State for the interface",
                    "title": "Link State\nx-displayName: \"Link State\"\nLink State for the interface",
                    "format": "boolean",
                    "x-displayname": "Link State"
                },
                "link_type": {
                    "description": " Link type for the interface",
                    "title": "Link type\nx-displayName: \"Link type\"\nLink type for the interface",
                    "$ref": "#/definitions/schemasiteLinkType",
                    "x-displayname": "Link type"
                },
                "mac": {
                    "type": "string",
                    "description": " Mac Address of interface",
                    "title": "Mac Address",
                    "x-displayname": "Mac Address"
                },
                "name": {
                    "type": "string",
                    "description": " Name of interface",
                    "title": "Name",
                    "x-displayname": "Name"
                },
                "network_name": {
                    "type": "string",
                    "description": " Name of Virtual Network to which the interface belongs",
                    "title": "Virtual Network Name",
                    "x-displayname": "Virtual Network Name"
                },
                "network_type": {
                    "description": " Virtual Network Type of interface",
                    "title": "Virtual Network Type",
                    "$ref": "#/definitions/schemaVirtualNetworkType",
                    "x-displayname": "Virtual Network Type"
                }
            }
        },
        "siteLinkQuality": {
            "type": "string",
            "description": "Link quality determined by VER using different probes\n\nUnknown quality\nLink quality is good\nLink quality is poor\nQuality disabled",
            "title": "Link quality",
            "enum": [
                "QUALITY_UNKNOWN",
                "QUALITY_GOOD",
                "QUALITY_POOR",
                "QUALITY_DISABLED"
            ],
            "default": "QUALITY_UNKNOWN",
            "x-displayname": "Link quality",
            "x-ves-proto-enum": "ves.io.schema.site.LinkQuality"
        },
        "site_mesh_groupFullMeshGroupType": {
            "type": "object",
            "description": "Details of Full Mesh Group Type",
            "title": "Full Mesh Group Type",
            "x-displayname": "Full Mesh",
            "x-ves-oneof-field-full_mesh_choice": "[\"control_and_data_plane_mesh\",\"data_plane_mesh\"]",
            "x-ves-proto-message": "ves.io.schema.site_mesh_group.FullMeshGroupType",
            "properties": {
                "control_and_data_plane_mesh": {
                    "description": "Exclusive with [data_plane_mesh]\n Full mesh of data plane tunnels across sites\n and control plane peering across sites",
                    "title": "Control and Data Plane Mesh",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Control and Data Plane Mesh"
                },
                "data_plane_mesh": {
                    "description": "Exclusive with [control_and_data_plane_mesh]\n Full Mesh of data plane tunnels across sites",
                    "title": "Data Plane Mesh",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Data Plane Mesh"
                }
            }
        },
        "site_mesh_groupHubFullMeshGroupType": {
            "type": "object",
            "description": "Details of Hub Full Mesh Group Type",
            "title": "Hub Full Mesh Group Type",
            "x-displayname": "Hub Full Mesh",
            "x-ves-oneof-field-hub_full_mesh_choice": "[\"control_and_data_plane_mesh\",\"data_plane_mesh\"]",
            "x-ves-proto-message": "ves.io.schema.site_mesh_group.HubFullMeshGroupType",
            "properties": {
                "control_and_data_plane_mesh": {
                    "description": "Exclusive with [data_plane_mesh]\n Hub Full mesh of data plane tunnels across sites\n and control plane peering across sites",
                    "title": "Control and Data Plane Mesh",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Control and Data Plane Mesh"
                },
                "data_plane_mesh": {
                    "description": "Exclusive with [control_and_data_plane_mesh]\n Hub Full Mesh of data plane tunnels across sites",
                    "title": "Data Plane Mesh",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Data Plane Mesh"
                }
            }
        },
        "site_mesh_groupSpokeMeshGroupType": {
            "type": "object",
            "description": "Details of Spoke Mesh Group Type",
            "title": "Spoke Mesh Group Type",
            "x-displayname": "Spoke",
            "x-ves-oneof-field-spoke_hub_mesh_choice": "[\"control_and_data_plane_mesh\",\"data_plane_mesh\"]",
            "x-ves-proto-message": "ves.io.schema.site_mesh_group.SpokeMeshGroupType",
            "properties": {
                "control_and_data_plane_mesh": {
                    "description": "Exclusive with [data_plane_mesh]\n Mesh of data plane tunnels to the hub site/s\n and control plane peering with the hub site/s",
                    "title": "Control and Data Plane Mesh",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Control and Data Plane Mesh"
                },
                "data_plane_mesh": {
                    "description": "Exclusive with [control_and_data_plane_mesh]\n Mesh of data plane tunnels to the hub site/s",
                    "title": "Data Plane Mesh",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Data Plane Mesh"
                },
                "hub_mesh_group": {
                    "description": " 'hub_mesh_group' refers to a Site Mesh Group of 'type' Hub.\n Spoke sites will connect to all the member sites of Hub Site Mesh Group\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "hub_mesh_group",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "hub_mesh_group (site mesh group)",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "topologyAWSNetworkMetaData": {
            "type": "object",
            "description": "Network attributes specific to AWS.",
            "title": "AWSNetworkMetaData",
            "x-displayname": "AWS Network Meta Data",
            "x-ves-proto-message": "ves.io.schema.topology.AWSNetworkMetaData",
            "properties": {
                "metadata": {
                    "description": "AWS TGW Metadata",
                    "title": "AWS TGW Metadata",
                    "$ref": "#/definitions/topologyMetaType",
                    "x-displayname": "AWS TGW Metadata"
                },
                "transit_gateway": {
                    "description": "AWS TGW Data",
                    "title": "AWS TGW Data",
                    "$ref": "#/definitions/topologyTransitGatewayType",
                    "x-displayname": "AWS TGW Data"
                }
            }
        },
        "topologyAWSRouteAttributes": {
            "type": "object",
            "description": "Route attributes specific to AWS.",
            "title": "AWSRouteAttributes",
            "x-displayname": "AWS Route Attributes",
            "x-ves-proto-message": "ves.io.schema.topology.AWSRouteAttributes",
            "properties": {
                "propagated": {
                    "type": "boolean",
                    "description": "Is route propagated\n\nExample: - false-",
                    "title": "Propagated",
                    "format": "boolean",
                    "x-displayname": "Propagated"
                },
                "tgw": {
                    "description": "TGW Route Attribues\n\nExample: - tgw-",
                    "title": "TGW",
                    "$ref": "#/definitions/topologyAWSTgwRouteAttributes",
                    "x-displayname": "TGW"
                }
            }
        },
        "topologyAWSTGWAttachment": {
            "type": "object",
            "description": "AWS TGW Attachment",
            "title": "AWSTGWAttachment",
            "x-displayname": "AWS TGW Attachement",
            "x-ves-proto-message": "ves.io.schema.topology.AWSTGWAttachment",
            "properties": {
                "associated_route_table_id": {
                    "type": "string",
                    "description": "Associated Route Table ID",
                    "title": "Associated Route Table ID",
                    "x-displayname": "Associated Route Table ID"
                },
                "association_state": {
                    "type": "string",
                    "description": "Association State",
                    "title": "Association State",
                    "x-displayname": "Association State"
                },
                "cidr": {
                    "type": "string",
                    "description": "CIDR",
                    "title": "CIDR",
                    "x-displayname": "CIDR"
                },
                "cloud_connect": {
                    "type": "array",
                    "description": " Reference to the Cloud Connect",
                    "title": "Cloud Connect",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Cloud Connect"
                },
                "id": {
                    "type": "string",
                    "description": "TGW Attachment ID",
                    "title": "ID",
                    "x-displayname": "ID"
                },
                "name": {
                    "type": "string",
                    "description": "TGW Attachment Name",
                    "title": "Name",
                    "x-displayname": "Name"
                },
                "resource_id": {
                    "type": "string",
                    "description": "Resource ID",
                    "title": "Resource ID",
                    "x-displayname": "Resource ID"
                },
                "resource_name": {
                    "type": "string",
                    "description": "Resource Name",
                    "title": "Resource Name",
                    "x-displayname": "Resource Name"
                },
                "resource_type": {
                    "type": "string",
                    "description": "Resource Type",
                    "title": "Resource Type",
                    "x-displayname": "Resource Type"
                },
                "segment": {
                    "type": "array",
                    "description": " Reference to the Segment",
                    "title": "Segment",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Segment"
                }
            }
        },
        "topologyAWSTGWAttachmentMetaData": {
            "type": "object",
            "description": "AWS TGW AWSTGWAttachment MetaData",
            "title": "AWSTGWAttachmentMetaData",
            "x-displayname": "AWS TGW AWSTGWAttachment MetaData",
            "x-ves-proto-message": "ves.io.schema.topology.AWSTGWAttachmentMetaData",
            "properties": {
                "id": {
                    "type": "string",
                    "description": "TGW Attachment ID",
                    "title": "Attachment ID",
                    "x-displayname": "Attachment ID"
                },
                "resource_id": {
                    "type": "string",
                    "description": "Resource ID",
                    "title": "Resource ID",
                    "x-displayname": "Resource ID"
                },
                "resource_name": {
                    "type": "string",
                    "description": "Resource Name",
                    "title": "Resource Name",
                    "x-displayname": "Resource Name"
                },
                "resource_type": {
                    "type": "string",
                    "description": "Resource Type",
                    "title": "Resource Type",
                    "x-displayname": "Resource Type"
                },
                "state": {
                    "type": "string",
                    "description": "Association/Propagation State",
                    "title": "Association/Propagation State",
                    "x-displayname": "Association/Propagation State"
                }
            }
        },
        "topologyAWSTgwRouteAttributes": {
            "type": "object",
            "description": "Route attributes specific to AWS TGW.",
            "title": "AWSTgwRouteAttributes",
            "x-displayname": "AWS TGW Route Attributes",
            "x-ves-proto-message": "ves.io.schema.topology.AWSTgwRouteAttributes",
            "properties": {
                "next_hop_attachment": {
                    "type": "array",
                    "description": " Next Hop Attachment\n\nExample: - next_hop_attachment-",
                    "title": "Next Hop Attachment",
                    "items": {
                        "$ref": "#/definitions/topologyAWSTGWAttachmentMetaData"
                    },
                    "x-displayname": "Next Hop Attachment"
                },
                "route_type": {
                    "type": "string",
                    "description": " Route Type\n\nExample: - \"propagated\"-",
                    "title": "Route Type",
                    "x-displayname": "Route Type",
                    "x-ves-example": "propagated"
                }
            }
        },
        "topologyAddressInfoType": {
            "type": "object",
            "description": "Address with additional information",
            "title": "Address Info Type",
            "x-displayname": "Address Info Type",
            "x-ves-proto-message": "ves.io.schema.topology.AddressInfoType",
            "properties": {
                "address": {
                    "type": "string",
                    "description": " Address",
                    "title": "Address",
                    "x-displayname": "Address"
                },
                "dns_name": {
                    "type": "string",
                    "description": " Address type",
                    "title": "DNS Name",
                    "x-displayname": "Public Address"
                },
                "primary": {
                    "type": "boolean",
                    "description": " Indicate this address is primary or not",
                    "title": "Primary",
                    "format": "boolean",
                    "x-displayname": "Primary"
                }
            }
        },
        "topologyAzureResourceGroupInfo": {
            "type": "object",
            "description": "x-displayName: \"Azure Resource Group Info\"\nAzure Site and Virtual Network resource group info",
            "title": "AzureResourceGroupInfo",
            "properties": {
                "site_rg": {
                    "type": "string",
                    "description": "x-displayName: \"Site Resource Group\"\nResource group for Site",
                    "title": "Site Resource Group"
                },
                "virtual_network_rg": {
                    "type": "string",
                    "description": "x-displayName: \"Virtual Network Resource Group\"\nResource group for Virtual Network",
                    "title": "Virtual Network Resource Group"
                }
            }
        },
        "topologyCloudNetworkType": {
            "type": "string",
            "description": "Cloud Network Type.\n\nNetwork None\nNetwork Type Azure Hub VNET\nNetwork Type Spoke VNET\nNetwork Type Service VPC\nNetwork Type Spoke VPC",
            "title": "Cloud NetworkType",
            "enum": [
                "NETWORK_TYPE_NONE",
                "NETWORK_TYPE_HUB_VNET",
                "NETWORK_TYPE_SPOKE_VNET",
                "NETWORK_TYPE_SERVICE_VPC",
                "NETWORK_TYPE_SPOKE_VPC"
            ],
            "default": "NETWORK_TYPE_NONE",
            "x-displayname": "Cloud Network Type",
            "x-ves-proto-enum": "ves.io.schema.topology.CloudNetworkType"
        },
        "topologyDCClusterGroupSummaryInfo": {
            "type": "object",
            "description": "Summary information related to the DC Cluster Group",
            "title": "DCClusterGroupSummaryInfo",
            "x-displayname": "DC Cluster Group Summary",
            "x-ves-proto-message": "ves.io.schema.topology.DCClusterGroupSummaryInfo",
            "properties": {
                "sites": {
                    "type": "integer",
                    "description": " This field indicates the number of sites that are part of this DC Cluster group.",
                    "title": "Sites",
                    "format": "int64",
                    "x-displayname": "Sites"
                }
            }
        },
        "topologyDCClusterGroupType": {
            "type": "object",
            "description": "A canonical form of the DC cluster group.",
            "title": "DC Cluster Group",
            "x-displayname": "DC Cluster Group",
            "x-ves-proto-message": "ves.io.schema.topology.DCClusterGroupType",
            "properties": {
                "type": {
                    "$ref": "#/definitions/dc_cluster_groupDCClusterGroupMeshType"
                }
            }
        },
        "topologyDCClusterTopologyRequest": {
            "type": "object",
            "description": "Request to get DC Cluster group topology and the associated metrics.",
            "title": "DC Cluster Group Topology Request",
            "x-displayname": "DC Cluster Group Topology Request",
            "x-ves-proto-message": "ves.io.schema.topology.DCClusterTopologyRequest",
            "properties": {
                "dc_cluster_group": {
                    "type": "string",
                    "description": " Name of the DC Cluster group\n\nExample: - \"dcg-1\"-",
                    "title": "DC Cluster group",
                    "x-displayname": "DC Cluster group",
                    "x-ves-example": "dcg-1"
                },
                "metric_selector": {
                    "description": " Metric fields to be returned in the response. If no metric fields are specified in the request,\n then the response will not contain any metric data.",
                    "title": "Metric Selector",
                    "$ref": "#/definitions/topologyMetricSelector",
                    "x-displayname": "Metric Selector"
                }
            }
        },
        "topologyEdge": {
            "type": "object",
            "description": "Canonical representation of Edge in the topology graph.",
            "title": "Edge",
            "x-displayname": "Edge",
            "x-ves-proto-message": "ves.io.schema.topology.Edge",
            "properties": {
                "links": {
                    "type": "array",
                    "description": " An edge may be composed of multiple links.\n For example, there may be multiple tunnels between a transit gateway and a site and each tunnel\n is represented as individual links. In some cases, we may want to show only one link between 2 nodes,\n eventhough there may be multiple connections/tunnels between these nodes.",
                    "title": "Links",
                    "items": {
                        "$ref": "#/definitions/topologyLinkTypeData"
                    },
                    "x-displayname": "Links"
                },
                "node_id1": {
                    "type": "string",
                    "description": " Node identifier.",
                    "title": "Node Id1",
                    "x-displayname": "Node Id1"
                },
                "node_id2": {
                    "type": "string",
                    "description": " Node identifier.",
                    "title": "Node Id2",
                    "x-displayname": "Node Id2"
                },
                "status": {
                    "description": " Indicates the overall status of the edge.\n An edge may be have multiple links (dataplane tunnels, control plane connections).\n The status of an edge indicates the overall health of the edge.",
                    "title": "Status",
                    "$ref": "#/definitions/topologyLinkStatus",
                    "x-displayname": "Status"
                }
            }
        },
        "topologyEdgeInfoSummary": {
            "type": "object",
            "description": "Summary information for an edge",
            "title": "EdgeInfoSummary",
            "x-displayname": "Edge Info Summary",
            "x-ves-proto-message": "ves.io.schema.topology.EdgeInfoSummary",
            "properties": {
                "count": {
                    "type": "integer",
                    "description": " Links count.",
                    "title": "Count",
                    "format": "int64",
                    "x-displayname": "Count"
                },
                "status": {
                    "description": " Edge status.",
                    "title": "Status",
                    "$ref": "#/definitions/topologyLinkStatus",
                    "x-displayname": "Status"
                }
            }
        },
        "topologyGCPRouteAttributes": {
            "type": "object",
            "description": "Route attributes specific to GCP.",
            "title": "GCPRouteAttributes",
            "x-displayname": "GCP Route Attributes",
            "x-ves-proto-message": "ves.io.schema.topology.GCPRouteAttributes",
            "properties": {
                "ip_version": {
                    "type": "string",
                    "description": " Version of IP protocol\n\nExample: - \"ipv4\"-",
                    "title": "IP version",
                    "x-displayname": "IP version",
                    "x-ves-example": "ipv4"
                },
                "priority": {
                    "type": "integer",
                    "description": " Route Priority\n\nExample: - 1-",
                    "title": "Priority",
                    "format": "int64",
                    "x-displayname": "Priority"
                },
                "route_name": {
                    "type": "string",
                    "description": " GCP Route Name\n\nExample: - \"default-route\"-",
                    "title": "GCP Route Name",
                    "x-displayname": "GCP Route Name",
                    "x-ves-example": "default-route"
                },
                "route_type": {
                    "description": " GCP Route Type\n\nExample: - GCP_ROUTE_TYPE_STATIC-",
                    "title": "GCP Route Type",
                    "$ref": "#/definitions/topologyGCPRouteType",
                    "x-displayname": "GCP Route Type"
                },
                "scope_limits": {
                    "type": "array",
                    "description": " Limits on the scope of route like network tag\n\nExample: - \"tag-1, tag-2\"-",
                    "title": "Scope Limits",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Scope Limits",
                    "x-ves-example": "tag-1, tag-2"
                }
            }
        },
        "topologyGCPRouteType": {
            "type": "string",
            "description": "GCP Route Type\n\n - GCP_ROUTE_TYPE_NONE: GCP Route Type None\n\nGCP Route Type None\n - GCP_ROUTE_TYPE_TRANSIT: GCP Route Type Transit\n\nGCP Route Type Transit\n - GCP_ROUTE_TYPE_SUBNET: GCP Route Type Subnet\n\nGCP Route Type Subnet\n - GCP_ROUTE_TYPE_STATIC: GCP Route Type Static\n\nGCP Route Type Static\n - GCP_ROUTE_TYPE_BGP: GCP Route Type BGP\n\nGCP Route Type BGP",
            "title": "GCPRouteType",
            "enum": [
                "GCP_ROUTE_TYPE_NONE",
                "GCP_ROUTE_TYPE_TRANSIT",
                "GCP_ROUTE_TYPE_SUBNET",
                "GCP_ROUTE_TYPE_STATIC",
                "GCP_ROUTE_TYPE_BGP"
            ],
            "default": "GCP_ROUTE_TYPE_NONE",
            "x-displayname": "GCP Route type",
            "x-ves-proto-enum": "ves.io.schema.topology.GCPRouteType"
        },
        "topologyGatewayTypeEnum": {
            "type": "string",
            "description": "Gateway Type\n\n - INGRESS_GATEWAY: Ingress gateway\n\nIngress gateway (single nic)\n - INGRESS_EGRESS_GATEWAY: Ingress and Egress gateway\n\nIngress and Egress gateway (dual nic)",
            "title": "GatewayType",
            "enum": [
                "INGRESS_GATEWAY",
                "INGRESS_EGRESS_GATEWAY"
            ],
            "default": "INGRESS_GATEWAY",
            "x-displayname": "Gateway type",
            "x-ves-proto-enum": "ves.io.schema.topology.GatewayTypeEnum"
        },
        "topologyInstanceType": {
            "type": "object",
            "description": "A canonical form of the instance.",
            "title": "Instance",
            "x-displayname": "instance",
            "x-ves-proto-message": "ves.io.schema.topology.InstanceType",
            "properties": {
                "architecture": {
                    "type": "string",
                    "description": " Architecture",
                    "title": "Architecture",
                    "x-displayname": "Architecture"
                },
                "availability_zone": {
                    "type": "string",
                    "description": " Availability Zone",
                    "title": "Availability Zone",
                    "x-displayname": "Availability Zone"
                },
                "cpu": {
                    "type": "integer",
                    "description": " CPU Count",
                    "title": "CPU",
                    "format": "int64",
                    "x-displayname": "CPU Count"
                },
                "f5xc_node_name": {
                    "type": "string",
                    "description": " F5XC node name",
                    "title": "F5XC Node name",
                    "x-displayname": "F5XC Node Name"
                },
                "instance_type": {
                    "type": "string",
                    "description": " Instance type",
                    "title": "Instance type",
                    "x-displayname": "Instance type"
                },
                "interfaces": {
                    "type": "array",
                    "description": " A list of network interfaces",
                    "title": "Interfaces",
                    "items": {
                        "$ref": "#/definitions/topologyNetworkInterfaceType"
                    },
                    "x-displayname": "Network Interfaces"
                },
                "platform": {
                    "type": "string",
                    "description": " Platform",
                    "title": "Platform",
                    "x-displayname": "Platform"
                },
                "private_address": {
                    "type": "string",
                    "description": " Private Address",
                    "title": "Private addresse",
                    "x-displayname": "Private Address"
                },
                "private_dns_name": {
                    "type": "string",
                    "description": " Private DNS Name",
                    "title": "Private DNS Name",
                    "x-displayname": "Private DNS Name"
                },
                "public_address": {
                    "type": "string",
                    "description": " Public address",
                    "title": "Public address",
                    "x-displayname": "Public Address"
                },
                "public_dns_name": {
                    "type": "string",
                    "description": " Public DNS Name",
                    "title": "Public DNS Name",
                    "x-displayname": "Public DNS Name"
                },
                "security_group": {
                    "type": "array",
                    "description": " Security groups",
                    "title": "Security Groups",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Security Groups"
                }
            }
        },
        "topologyInterfaceTypeEnum": {
            "type": "string",
            "description": " - INSIDE: INSIDE Interface\n\n - WORKLOAD: Workload Interface\n\n - NOT_APPLICABLE: NOT_APPLICABLE\n\nEx - When the subnet belongs to a azure spoke vnet",
            "title": "- OUTSIDE: OUTSIDE Interface",
            "enum": [
                "OUTSIDE",
                "INSIDE",
                "WORKLOAD",
                "NOT_APPLICABLE"
            ],
            "default": "OUTSIDE",
            "x-displayname": "",
            "x-ves-proto-enum": "ves.io.schema.topology.InterfaceTypeEnum"
        },
        "topologyLinkInfo": {
            "type": "object",
            "description": "Information about the link that connects 2 nodes in the topology graph.",
            "title": "LinkInfo",
            "x-displayname": "Link Info",
            "x-ves-proto-message": "ves.io.schema.topology.LinkInfo",
            "properties": {
                "dst_id": {
                    "type": "string",
                    "description": " Endpoint identifier. dst_id is the destination endpoint for the link is between src_id and dst_id.\n\nExample: - \"master-0\"-",
                    "title": "Destination ID",
                    "x-displayname": "Destination ID",
                    "x-ves-example": "master-0"
                },
                "name": {
                    "type": "string",
                    "description": " Name of the link.\n Link name may or may not be present depending on the type of link.\n\nExample: - \"tunnel-1\"-",
                    "title": "Name",
                    "x-displayname": "Name",
                    "x-ves-example": "tunnel-1"
                },
                "src_id": {
                    "type": "string",
                    "description": " Endpoint identifier. src_id is the source endpoint for the link is between src_id and dst_id.\n\nExample: - \"master-0\"-",
                    "title": "Source ID",
                    "x-displayname": "Source ID",
                    "x-ves-example": "master-0"
                },
                "status": {
                    "description": " Link status.",
                    "title": "Status",
                    "$ref": "#/definitions/topologyLinkStatus",
                    "x-displayname": "Status"
                },
                "type": {
                    "description": " Link type.",
                    "title": "Type",
                    "$ref": "#/definitions/schematopologyLinkType",
                    "x-displayname": "Type"
                }
            }
        },
        "topologyLinkInfoSummary": {
            "type": "object",
            "description": "Summary information for a link type",
            "title": "LinkInfoSummary",
            "x-displayname": "Link Info Summary",
            "x-ves-proto-message": "ves.io.schema.topology.LinkInfoSummary",
            "properties": {
                "count": {
                    "type": "integer",
                    "description": " Links count.",
                    "title": "Count",
                    "format": "int64",
                    "x-displayname": "Count"
                },
                "status": {
                    "description": " Link status.",
                    "title": "Status",
                    "$ref": "#/definitions/topologyLinkStatus",
                    "x-displayname": "Status"
                },
                "type": {
                    "description": " Link type.",
                    "title": "Type",
                    "$ref": "#/definitions/schematopologyLinkType",
                    "x-displayname": "Type"
                }
            }
        },
        "topologyLinkStatus": {
            "type": "string",
            "description": "Enumerates link status.\n\nStatus not applicable for this link\nStatus unknown for this link\nIndicates status up/active\nIndicates status down/inactive\nIndicates status degraded",
            "title": "LinkStatus",
            "enum": [
                "LINK_STATUS_NOT_APPLICABLE",
                "LINK_STATUS_UNKNOWN",
                "LINK_STATUS_UP",
                "LINK_STATUS_DOWN",
                "LINK_STATUS_DEGRADED"
            ],
            "default": "LINK_STATUS_NOT_APPLICABLE",
            "x-displayname": "Link Status",
            "x-ves-proto-enum": "ves.io.schema.topology.LinkStatus"
        },
        "topologyLinkTypeData": {
            "type": "object",
            "description": "LinkTypeData contains details about the link and the metrics (if requested/available).",
            "title": "LinkTypeData",
            "x-displayname": "Link Type Data",
            "x-ves-proto-message": "ves.io.schema.topology.LinkTypeData",
            "properties": {
                "info": {
                    "description": " Information about the link.",
                    "title": "Info",
                    "$ref": "#/definitions/topologyLinkInfo",
                    "x-displayname": "Info"
                },
                "metric": {
                    "type": "array",
                    "description": " Metric data for the link.",
                    "title": "Metric",
                    "items": {
                        "$ref": "#/definitions/topologyMetricData"
                    },
                    "x-displayname": "Metric"
                }
            }
        },
        "topologyLoadBalancer": {
            "type": "object",
            "description": "Load Balancer",
            "title": "LB",
            "x-displayname": "Load Balancer",
            "x-ves-proto-message": "ves.io.schema.topology.LoadBalancer",
            "properties": {
                "id": {
                    "type": "string",
                    "description": " Id of the LB",
                    "title": "Id",
                    "x-displayname": "Id"
                },
                "name": {
                    "type": "string",
                    "description": " Name of the LB",
                    "title": "Name",
                    "x-displayname": "Name"
                }
            }
        },
        "topologyMetaType": {
            "type": "object",
            "description": "A metadata for topology objects.",
            "title": "Metadata",
            "x-displayname": "MetaType",
            "x-ves-proto-message": "ves.io.schema.topology.MetaType",
            "properties": {
                "creds": {
                    "type": "array",
                    "description": " Reference to cloud credentials to fetch cloud resources.",
                    "title": "Cloud Credentials",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Cloud Credentials"
                },
                "id": {
                    "type": "string",
                    "description": " ID in the external system (such as cloud specific ID).",
                    "title": "ID",
                    "x-displayname": "ID"
                },
                "name": {
                    "type": "string",
                    "description": " Name in the external system.",
                    "title": "Name",
                    "x-displayname": "Name"
                },
                "owner_id": {
                    "type": "string",
                    "description": " owner id in the cloud side.",
                    "title": "OwnerID",
                    "x-displayname": "Owner ID"
                },
                "provider_type": {
                    "description": " provider type",
                    "title": "Provider Type",
                    "$ref": "#/definitions/topologyProviderType",
                    "x-displayname": "Provider Type"
                },
                "raw_json": {
                    "type": "string",
                    "description": " raw json string",
                    "title": "Raw JSON",
                    "x-displayname": "Raw JSON"
                },
                "status": {
                    "type": "string",
                    "description": " status of topology node",
                    "title": "Status",
                    "x-displayname": "Status"
                },
                "tags": {
                    "type": "object",
                    "description": " Map of string keys and values that annotated in the topology node.\n\nExample: - \"value\"-",
                    "title": "tags",
                    "x-displayname": "Tags",
                    "x-ves-example": "value"
                }
            }
        },
        "topologyMetricData": {
            "type": "object",
            "description": "Metric Data contains the metric type and the metric data.",
            "title": "Metric Data",
            "x-displayname": "Metric Data",
            "x-ves-proto-message": "ves.io.schema.topology.MetricData",
            "properties": {
                "data": {
                    "type": "array",
                    "description": " Metric Data",
                    "title": "Data",
                    "items": {
                        "$ref": "#/definitions/schematopologyMetricTypeData"
                    },
                    "x-displayname": "Data"
                },
                "type": {
                    "description": " Metric Type",
                    "title": "Type",
                    "$ref": "#/definitions/schematopologyMetricType",
                    "x-displayname": "Type"
                },
                "unit": {
                    "description": " Unit for the metric value",
                    "title": "Unit",
                    "$ref": "#/definitions/schemaUnitType",
                    "x-displayname": "Unit"
                }
            }
        },
        "topologyMetricSelector": {
            "type": "object",
            "description": "MetricSelector is used to specify the list of metrics to be returned in the response.",
            "title": "Metric Selector",
            "x-displayname": "Metric Selector",
            "x-ves-proto-message": "ves.io.schema.topology.MetricSelector",
            "properties": {
                "edge": {
                    "type": "array",
                    "description": " List of metrics to be returned for the edges\n\nValidation Rules:\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Edge Metric Types",
                    "items": {
                        "$ref": "#/definitions/schematopologyMetricType"
                    },
                    "x-displayname": "Edge Metric Types",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "end_time": {
                    "type": "string",
                    "description": " End time of metric data. This field is applicable only if \"include_metrics\" is set to true.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"1570197600\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "End time",
                    "x-displayname": "End Time",
                    "x-ves-example": "1570197600",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "node": {
                    "type": "array",
                    "description": " List of metrics to be returned for the nodes\n\nValidation Rules:\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Node Metric Types",
                    "items": {
                        "$ref": "#/definitions/schematopologyMetricType"
                    },
                    "x-displayname": "Node Metric Types",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "start_time": {
                    "type": "string",
                    "description": " Start time of metric data. This field is applicable only if \"include_metrics\" is set to true.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"1570194000\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "Start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "1570194000",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "step": {
                    "type": "string",
                    "description": " step is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\n The timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\n Optional: If not specified, then step size is evaluated to \u003cend_time - start_time\u003e\n\nExample: - \"5m\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_step: true\n",
                    "title": "Step",
                    "x-displayname": "Step",
                    "x-ves-example": "5m",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_step": "true"
                    }
                }
            }
        },
        "topologyNetworkInterfaceType": {
            "type": "object",
            "description": "A canonical form of the network interface.",
            "title": "Network Interface",
            "x-displayname": "Network Interface",
            "x-ves-proto-message": "ves.io.schema.topology.NetworkInterfaceType",
            "properties": {
                "f5xc_status": {
                    "description": " F5XC side interface status",
                    "title": "F5XC status",
                    "$ref": "#/definitions/siteInterfaceStatus",
                    "x-displayname": "f5xc status"
                },
                "name": {
                    "type": "string",
                    "description": " Name of this interface",
                    "title": "Name",
                    "x-displayname": "Name"
                },
                "private_addresses": {
                    "type": "array",
                    "description": " Private Address",
                    "title": "Private addresses",
                    "items": {
                        "$ref": "#/definitions/topologyAddressInfoType"
                    },
                    "x-displayname": "Private Addresses"
                },
                "public_address": {
                    "type": "array",
                    "description": " Public address",
                    "title": "Public address",
                    "items": {
                        "$ref": "#/definitions/topologyAddressInfoType"
                    },
                    "x-displayname": "Public Address"
                },
                "security_group": {
                    "type": "array",
                    "description": " Security groups",
                    "title": "Security Groups",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Security Groups"
                },
                "status": {
                    "type": "string",
                    "description": " Status",
                    "title": "Status",
                    "x-displayname": "Status"
                },
                "subnet": {
                    "type": "array",
                    "description": " Reference to the subnets connected",
                    "title": "Subnets",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Subnets"
                }
            }
        },
        "topologyNetworkRouteTableData": {
            "type": "object",
            "description": "Data associated with the  network route tables",
            "title": "NetworkRouteTableData",
            "x-displayname": "Network Route Data",
            "x-ves-proto-message": "ves.io.schema.topology.NetworkRouteTableData",
            "properties": {
                "route_table_data": {
                    "description": " Route Table Data",
                    "title": "Route Table Data",
                    "$ref": "#/definitions/topologyRouteTableData",
                    "x-displayname": "Route Table Data"
                },
                "subnet_data": {
                    "type": "array",
                    "description": " Subnet Data",
                    "title": "Subnet Data",
                    "items": {
                        "$ref": "#/definitions/topologySubnetData"
                    },
                    "x-displayname": "Subnet Data"
                }
            }
        },
        "topologyNetworkRouteTableMetaData": {
            "type": "object",
            "description": "Metadata associated with the network route tables",
            "title": "NetworkRouteTableMetaData",
            "x-displayname": "Network RouteTable Metadata",
            "x-ves-proto-message": "ves.io.schema.topology.NetworkRouteTableMetaData",
            "properties": {
                "route_table_metadata": {
                    "description": " Route Table Metadata",
                    "title": "Route Table Metadata",
                    "$ref": "#/definitions/topologyRouteTableMetaData",
                    "x-displayname": "Route Table Metadata"
                },
                "subnet_metadata": {
                    "type": "array",
                    "description": " Subnet Metadata",
                    "title": "Subnet Metadata",
                    "items": {
                        "$ref": "#/definitions/topologySubnetMetaData"
                    },
                    "x-displayname": "Subnet Metadata"
                }
            }
        },
        "topologyNetworkRouteTablesResponse": {
            "type": "object",
            "description": "List of RouteTables Associated in the Network",
            "title": "Network Route Tables Response",
            "x-displayname": "Network Route Tables Response",
            "x-ves-proto-message": "ves.io.schema.topology.NetworkRouteTablesResponse",
            "properties": {
                "routes_data": {
                    "type": "array",
                    "description": " Network Routes Data",
                    "title": "Network Routes Data",
                    "items": {
                        "$ref": "#/definitions/topologyNetworkRoutesData"
                    },
                    "x-displayname": "Network Routes Data"
                }
            }
        },
        "topologyNetworkRoutesData": {
            "type": "object",
            "description": "Data associated with the network routes",
            "title": "NetworkRoutesData",
            "x-displayname": "Network Routes Data",
            "x-ves-proto-message": "ves.io.schema.topology.NetworkRoutesData",
            "properties": {
                "network_id": {
                    "type": "string",
                    "description": " Network Id",
                    "title": "Network Id",
                    "x-displayname": "Network Id"
                },
                "route_tables_data": {
                    "type": "array",
                    "description": " Network Route Tables Data",
                    "title": "Network Routes Data",
                    "items": {
                        "$ref": "#/definitions/topologyNetworkRouteTableData"
                    },
                    "x-displayname": "Network Route Tables Data"
                }
            }
        },
        "topologyNetworkRoutesMetaData": {
            "type": "object",
            "description": "Metadata associated with the network routes",
            "title": "NetworkRoutesMetaData",
            "x-displayname": "Network RouteTable Metadata",
            "x-ves-proto-message": "ves.io.schema.topology.NetworkRoutesMetaData",
            "properties": {
                "cloud_resource_id": {
                    "type": "string",
                    "description": " Cloud Resource Id",
                    "title": "Cloud Resource Id",
                    "x-displayname": "Cloud Resource Id"
                },
                "id": {
                    "type": "string",
                    "description": " Network Id",
                    "title": "Network Id",
                    "x-displayname": "Id"
                },
                "name": {
                    "type": "string",
                    "description": " Network Name",
                    "title": "Network Name",
                    "x-displayname": "Name"
                },
                "network_type": {
                    "description": " Network Type",
                    "title": "Network Type",
                    "$ref": "#/definitions/topologyCloudNetworkType",
                    "x-displayname": "Network Type"
                },
                "regions": {
                    "type": "array",
                    "description": " Regions in Network",
                    "title": "Regions",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Regions"
                },
                "route_tables_metadata": {
                    "type": "array",
                    "description": " Network Route Tables Metadata",
                    "title": "Network Route Tables Metadata",
                    "items": {
                        "$ref": "#/definitions/topologyNetworkRouteTableMetaData"
                    },
                    "x-displayname": "Network Route Tables Metadata"
                }
            }
        },
        "topologyNetworkSummaryInfo": {
            "type": "object",
            "description": "Summary information related to the network",
            "title": "NetworkSummaryInfo",
            "x-displayname": "Network Summary",
            "x-ves-proto-message": "ves.io.schema.topology.NetworkSummaryInfo",
            "properties": {
                "route_tables": {
                    "type": "array",
                    "description": " List of route tables associated with the network",
                    "title": "Route Tables",
                    "items": {
                        "$ref": "#/definitions/topologyRouteTableMetaData"
                    },
                    "x-displayname": "Route Tables"
                }
            }
        },
        "topologyNetworkType": {
            "type": "object",
            "description": "A canonical form of the network.",
            "title": "Network",
            "x-displayname": "network",
            "x-ves-proto-message": "ves.io.schema.topology.NetworkType",
            "properties": {
                "cidr_v4": {
                    "type": "array",
                    "description": " IPv4 Cidr",
                    "title": "IPv4 Cidr",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv4 Cidr"
                },
                "cidr_v6": {
                    "type": "array",
                    "description": " IPv6 Cidr",
                    "title": "IPv6 Cidr",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv6 Cidr"
                },
                "load_balancer": {
                    "type": "array",
                    "description": " Load Balancer Present in this Network",
                    "title": "Load Balancer",
                    "items": {
                        "$ref": "#/definitions/topologyLoadBalancer"
                    },
                    "x-displayname": "Load Balancer"
                },
                "network_peers": {
                    "type": "array",
                    "description": " Reference to the network peers",
                    "title": "Network peers",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Network Peers"
                },
                "region": {
                    "type": "array",
                    "description": " Reference to the regions",
                    "title": "Region",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Region"
                }
            }
        },
        "topologyNodeMetaData": {
            "type": "object",
            "description": "Metadata for node",
            "title": "Node Metadata",
            "x-displayname": "Node Metadata",
            "x-ves-proto-message": "ves.io.schema.topology.NodeMetaData",
            "properties": {
                "cloud_resource_id": {
                    "type": "string",
                    "description": " Cloud Resource Identifier for the node. This is only used for node which represent the cloud resource",
                    "title": "Cloud Resource Id",
                    "x-displayname": "Cloud Resource Id"
                },
                "description": {
                    "type": "string",
                    "description": " Description of the node.\n This field may or may not be populated depending on the node type and if the user provided description\n while creating the resource.",
                    "title": "Description",
                    "x-displayname": "Description"
                },
                "level": {
                    "type": "integer",
                    "description": " Level indicates the distance of the node from the root node. A value of 0 indicates the root node.\n\nExample: - \"1\"-",
                    "title": "Level",
                    "format": "int64",
                    "x-displayname": "Level",
                    "x-ves-example": "1"
                },
                "name": {
                    "type": "string",
                    "description": " Name of the node.\n\nExample: - \"site-1\"-",
                    "title": "Name",
                    "x-displayname": "Name",
                    "x-ves-example": "site-1"
                },
                "owner_id": {
                    "type": "string",
                    "description": " Owner id\n\nExample: - \"owner-1\"-",
                    "title": "Owner Id",
                    "x-displayname": "Owner Id",
                    "x-ves-example": "owner-1"
                },
                "provider_type": {
                    "description": " Provider type",
                    "title": "Provider Type",
                    "$ref": "#/definitions/topologyProviderType",
                    "x-displayname": "Provider Type"
                },
                "status": {
                    "type": "string",
                    "description": " status in the node",
                    "title": "Status",
                    "x-displayname": "Status"
                },
                "tags": {
                    "type": "object",
                    "description": " List of key/value pairs associated with the node",
                    "title": "Tags",
                    "x-displayname": "Tags"
                }
            }
        },
        "topologyNodeTypeDCClusterGroup": {
            "type": "object",
            "description": "DC Cluster group is represented as a node in the site topology graph.\nIn the DCClusterTopology API, dc_cluster_group is represented as a node and all the sites\nthat are part of the DC Cluster group are represented as edges (site -\u003e dc_cluster_group) in\naddition to the edges between the sites (site \u003c-\u003e site).",
            "title": "NodeTypeDCClusterGroup",
            "x-displayname": "DC Cluster Group",
            "x-ves-proto-message": "ves.io.schema.topology.NodeTypeDCClusterGroup",
            "properties": {
                "info": {
                    "description": " Information about the DC Cluster group.",
                    "title": "Info",
                    "$ref": "#/definitions/topologyDCClusterGroupType",
                    "x-displayname": "Info"
                },
                "summary": {
                    "description": " Summary information related to the DC Cluster group",
                    "title": "Summary",
                    "$ref": "#/definitions/topologyDCClusterGroupSummaryInfo",
                    "x-displayname": "Summary"
                }
            }
        },
        "topologyNodeTypeInstance": {
            "type": "object",
            "description": "NodeTypeInstance contains details about the instance and the metrics (if requested/available).",
            "title": "NodeTypeInstance",
            "x-displayname": "Instance",
            "x-ves-proto-message": "ves.io.schema.topology.NodeTypeInstance",
            "properties": {
                "info": {
                    "description": " Information about the Instance.",
                    "title": "Info",
                    "$ref": "#/definitions/topologyInstanceType",
                    "x-displayname": "Info"
                },
                "metric": {
                    "type": "array",
                    "description": " Metric data for the Instance.",
                    "title": "Metric",
                    "items": {
                        "$ref": "#/definitions/topologyMetricData"
                    },
                    "x-displayname": "Metric"
                }
            }
        },
        "topologyNodeTypeNetwork": {
            "type": "object",
            "description": "NodeTypeNetwork contains details about the network and the metrics (if requested/available).",
            "title": "NodeTypeNetwork",
            "x-displayname": "Network",
            "x-ves-proto-message": "ves.io.schema.topology.NodeTypeNetwork",
            "properties": {
                "info": {
                    "description": " Information about the Network.",
                    "title": "Info",
                    "$ref": "#/definitions/topologyNetworkType",
                    "x-displayname": "Info"
                },
                "metric": {
                    "type": "array",
                    "description": " Metric data for the Network.",
                    "title": "Metric",
                    "items": {
                        "$ref": "#/definitions/topologyMetricData"
                    },
                    "x-displayname": "Metric"
                },
                "summary": {
                    "description": " Network summary contains additional fields that are not part of the \"info\" field",
                    "title": "Summary",
                    "$ref": "#/definitions/topologyNetworkSummaryInfo",
                    "x-displayname": "Summary"
                }
            }
        },
        "topologyNodeTypeSite": {
            "type": "object",
            "description": "NodeTypeSite contains details about the site and the metrics (if requested/available).",
            "title": "NodeTypeSite",
            "x-displayname": "Site",
            "x-ves-proto-message": "ves.io.schema.topology.NodeTypeSite",
            "properties": {
                "info": {
                    "description": " Information about the site.",
                    "title": "Info",
                    "$ref": "#/definitions/schematopologySiteType",
                    "x-displayname": "Info"
                },
                "metric": {
                    "type": "array",
                    "description": " Metric data for the Site.",
                    "title": "Metric",
                    "items": {
                        "$ref": "#/definitions/topologyMetricData"
                    },
                    "x-displayname": "Metric"
                },
                "summary": {
                    "description": " Site summary contains additional fields that are not part of the \"info\" field",
                    "title": "Summary",
                    "$ref": "#/definitions/topologySiteSummaryInfo",
                    "x-displayname": "Summary"
                }
            }
        },
        "topologyNodeTypeSiteMeshGroup": {
            "type": "object",
            "description": "Site mesh group is represented as a node in the site topology graph.\nIn the SiteMeshTopology API, site_mesh_group is represented as a node and all the sites\nthat are part of the site mesh group are represented as edges (site -\u003e site_mesh_group) in\naddition to the edges between the sites (site \u003c-\u003e site). If the site_mesh_group is of type \"Spoke\",\nthen the node representing the site_mesh_group will have an edge with another site_mesh_group node\nthat represents the \"Hub\" and vice-versa.",
            "title": "NodeTypeSiteMeshGroup",
            "x-displayname": "Site Mesh Group",
            "x-ves-proto-message": "ves.io.schema.topology.NodeTypeSiteMeshGroup",
            "properties": {
                "info": {
                    "description": " Information about the site mesh group.",
                    "title": "Info",
                    "$ref": "#/definitions/schematopologySiteMeshGroupType",
                    "x-displayname": "Info"
                },
                "summary": {
                    "description": " Summary information related to the site mesh group",
                    "title": "Summary",
                    "$ref": "#/definitions/topologySiteMeshGroupSummaryInfo",
                    "x-displayname": "Summary"
                }
            }
        },
        "topologyNodeTypeSubnet": {
            "type": "object",
            "description": "NodeTypeSubnet contains details about the subnet and the metrics (if requested/available).",
            "title": "NodeTypeSubnet",
            "x-displayname": "Subnet",
            "x-ves-proto-message": "ves.io.schema.topology.NodeTypeSubnet",
            "properties": {
                "info": {
                    "description": " Information about the Subnet.",
                    "title": "Info",
                    "$ref": "#/definitions/topologySubnetType",
                    "x-displayname": "Info"
                },
                "metric": {
                    "type": "array",
                    "description": " Metric data for the Subnet.",
                    "title": "Metric",
                    "items": {
                        "$ref": "#/definitions/topologyMetricData"
                    },
                    "x-displayname": "Metric"
                },
                "summary": {
                    "description": " Subnet summary contains additional fields that are not part of the \"info\" field",
                    "title": "Summary",
                    "$ref": "#/definitions/topologySubnetSummaryInfo",
                    "x-displayname": "Summary"
                }
            }
        },
        "topologyNodeTypeTransitGateway": {
            "type": "object",
            "description": "NodeTypeTransitGateway contains details about the transit gateway and the metrics (if requested/available).",
            "title": "NodeTypeTransitGateway",
            "x-displayname": "Transit Gateway",
            "x-ves-proto-message": "ves.io.schema.topology.NodeTypeTransitGateway",
            "properties": {
                "info": {
                    "description": " Information about the Transit Gateway.",
                    "title": "Info",
                    "$ref": "#/definitions/topologyTransitGatewayType",
                    "x-displayname": "Info"
                },
                "metric": {
                    "type": "array",
                    "description": " Metric data for the Transit Gateway.",
                    "title": "Metric",
                    "items": {
                        "$ref": "#/definitions/topologyMetricData"
                    },
                    "x-displayname": "Metric"
                }
            }
        },
        "topologyOrchestrationMode": {
            "type": "string",
            "description": "Orchestration mode of a given site\n\n - NOT_MANAGED: Unmanaged mode\n\nUnmanaged mode\n - MANAGED: Managed mode\n\nManaged mode",
            "title": "Orchestration Mode",
            "enum": [
                "NOT_MANAGED",
                "MANAGED"
            ],
            "default": "NOT_MANAGED",
            "x-displayname": "Orchestration Mode",
            "x-ves-proto-enum": "ves.io.schema.topology.OrchestrationMode"
        },
        "topologyProviderInfo": {
            "type": "object",
            "description": "x-displayName: \"Provider Info\"\nCloud provider information",
            "title": "ProviderInfo",
            "properties": {
                "azure_rg_info": {
                    "description": "x-displayName: \"Azure Resource Group Info\"\nResource group information for Azure Site and Virtual Network",
                    "title": "Azure Resource Group Info",
                    "$ref": "#/definitions/topologyAzureResourceGroupInfo"
                },
                "cloud_link": {
                    "type": "array",
                    "description": "x-displayName: \"Cloud Link\"\nReference to cloud link",
                    "title": "Cloud Link",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    }
                },
                "gcp_zones": {
                    "type": "array",
                    "description": "x-displayName: \"GCP Zones\"\nGCP Zones for the resource",
                    "title": "GCP Zones",
                    "items": {
                        "type": "string"
                    }
                },
                "region": {
                    "type": "string",
                    "description": "x-displayName: \"Region\"\nRegion in which the resource exists",
                    "title": "Region"
                }
            }
        },
        "topologyProviderType": {
            "type": "string",
            "description": "provider type\n\nProviderType unspecified\nAWS backend\nGCP backend\nAzure backend\nF5XC backend\nVMware backend\nKVM backend\nOCI backend\nBaremetal backend\nF5 rSeries backend\nCE on k8s backend",
            "title": "ProviderType",
            "enum": [
                "PROVIDER_TYPE_UNSPECIFIED",
                "PROVIDER_TYPE_AWS",
                "PROVIDER_TYPE_GCP",
                "PROVIDER_TYPE_AZURE",
                "PROVIDER_TYPE_VOLTERRA",
                "PROVIDER_TYPE_VMWARE",
                "PROVIDER_TYPE_KVM",
                "PROVIDER_TYPE_OCI",
                "PROVIDER_TYPE_BAREMETAL",
                "PROVIDER_TYPE_F5RSERIES",
                "PROVIDER_TYPE_K8S"
            ],
            "default": "PROVIDER_TYPE_UNSPECIFIED",
            "x-displayname": "Provider Type",
            "x-ves-proto-enum": "ves.io.schema.topology.ProviderType"
        },
        "topologyRouteNextHopTypeEnum": {
            "type": "string",
            "description": "RouteNextHopTypeEnum\n\n - VIRTUAL_NETWORK_GATEWAY: VIRTUAL NETWORK GATEWAY\n\nVIRTUAL NETWORK GATEWAY\n - VNET_LOCAL: VNET LOCAL\n\nVNET LOCAL\n - INTERNET: INTERNET\n\nINTERNET\n - VIRTUAL_APPLIANCE: VIRTUAL APPLIANCE\n\nVIRTUAL APPLIANCE\n - NONE: NONE\n\nNONE\n - VNET_PEERING: VNET PEERING\n\nVNET PEERING\n - VIRTUAL_NETWORK_SERVICE_ENDPOINT: VIRTUAL NETWORK SERVICE ENDPOINT\n\nVIRTUAL NETWORK SERVICE ENDPOINT\n - NEXT_HOP_TYPE_NOT_APPLICABLE: NEXT_HOP_TYPE_NOT_APPLICABLE\n\nNEXT_HOP_TYPE_NOT_APPLICABLE should be used when the cloud provider doesn't support this.\n - LOADBALANCER: LOAD BALANCER\n\nLOAD BALANCER\n - VPC_NETWORK: VPC NETWORK\n\nVPC NETWORK\n - VPC_PEERING: VPC PEERING\n\nVPC PEERING\n - INTERNAL_LOAD_BALANCER: INTERNAL LOAD BALANCER\n\nINTERNAL LOAD BALANCER\n - INSTANCE: INSTANCE\n\nINSTANCE\n - INTERCONNECT: INTERCONNECT\n\nINTERCONNECT\n - INTERNET_GATEWAY: INTERNET GATEWAY\n\nINTERNET GATEWAY\n - IP: IP\n\nIP\n - VPN_TUNNEL: VPN TUNNEL\n\nVPN TUNNEL\n - TGW_ATTACHMENT: TGW ATTACHMENT\n\nTGW ATTACHMENT",
            "title": "RouteNextHopTypeEnum",
            "enum": [
                "VIRTUAL_NETWORK_GATEWAY",
                "VNET_LOCAL",
                "INTERNET",
                "VIRTUAL_APPLIANCE",
                "NONE",
                "VNET_PEERING",
                "VIRTUAL_NETWORK_SERVICE_ENDPOINT",
                "NEXT_HOP_TYPE_NOT_APPLICABLE",
                "LOADBALANCER",
                "VPC_NETWORK",
                "VPC_PEERING",
                "INTERNAL_LOAD_BALANCER",
                "INSTANCE",
                "INTERCONNECT",
                "INTERNET_GATEWAY",
                "IP",
                "VPN_TUNNEL",
                "TGW_ATTACHMENT"
            ],
            "default": "VIRTUAL_NETWORK_GATEWAY",
            "x-displayname": "RouteNextHopTypeEnum",
            "x-ves-proto-enum": "ves.io.schema.topology.RouteNextHopTypeEnum"
        },
        "topologyRouteSourceTypeEnum": {
            "type": "string",
            "description": "RouteSourceTypeEnum\n\n - INVALID_SOURCE: INVALID_SOURCE\n\nINVALID_SOURCE\n - DEFAULT: DEFAULT\n\nDEFAULT\n - USER: USER\n\nUSER\n - UNKNOWN: UNKNOWN\n\nUNKNOWN\n - VIRTUAL_NETWORK_GATEWAY_SOURCE: VIRTUAL_NETWORK_GATEWAY_SOURCE\n\nVIRTUAL_NETWORK_GATEWAY_SOURCE\n - SOURCE_NOT_APPLICABLE: SOURCE_NOT_APPLICABLE\n\nSOURCE_NOT_APPLICABLE should be used when the cloud provider does not supports this.",
            "title": "RouteSourceTypeEnum",
            "enum": [
                "INVALID_SOURCE",
                "DEFAULT",
                "USER",
                "UNKNOWN",
                "VIRTUAL_NETWORK_GATEWAY_SOURCE",
                "SOURCE_NOT_APPLICABLE"
            ],
            "default": "INVALID_SOURCE",
            "x-displayname": "RouteSourceTypeEnum",
            "x-ves-proto-enum": "ves.io.schema.topology.RouteSourceTypeEnum"
        },
        "topologyRouteStateTypeEnum": {
            "type": "string",
            "description": "RouteStateTypeEnum\n\n - ACTIVE_STATE: ACTIVE_STATE\n\nACTIVE_STATE\n - INVALID_STATE: INVALID_STATE\n\nINVALID_STATE\n - STATE_NOT_APPLICABLE: STATE_NOT_APPLICABLE\n\nSTATE_NOT_APPLICABLE should be used when the cloud provider doesn't supports this\n - STATE_BLACKHOLE: STATE_BLACKHOLE\n\nSTATE_BLACKHOLE\n - STATE_UNAVAILABLE: STATE_UNAVAILABLE\n\nSTATE_UNAVAILABLE\n - STATE_PENDING: STATE_PENDING\n\nSTATE_PENDING\n - STATE_DELETING: STATE_DELETING\n\nSTATE_DELETING\n - STATE_DELETED: STATE_DELETING\n\nSTATE_DELETED",
            "title": "RouteStateTypeEnum",
            "enum": [
                "ACTIVE_STATE",
                "INVALID_STATE",
                "STATE_NOT_APPLICABLE",
                "STATE_BLACKHOLE",
                "STATE_UNAVAILABLE",
                "STATE_PENDING",
                "STATE_DELETING",
                "STATE_DELETED"
            ],
            "default": "ACTIVE_STATE",
            "x-displayname": "RouteStateTypeEnum",
            "x-ves-proto-enum": "ves.io.schema.topology.RouteStateTypeEnum"
        },
        "topologyRouteTableData": {
            "type": "object",
            "description": "Data associated with the route table",
            "title": "RouteTableData",
            "x-displayname": "Route Table Data",
            "x-ves-proto-message": "ves.io.schema.topology.RouteTableData",
            "properties": {
                "metadata": {
                    "description": " Route Table MetaData",
                    "title": "Route Table Data",
                    "$ref": "#/definitions/topologyRouteTableMetaData",
                    "x-displayname": "Route Table Metadata"
                },
                "route_table": {
                    "description": " Route Table",
                    "title": "Route Table",
                    "$ref": "#/definitions/topologyRouteTableType",
                    "x-displayname": "Route Table"
                }
            }
        },
        "topologyRouteTableMetaData": {
            "type": "object",
            "description": "Metadata associated with the route table",
            "title": "RouteTableMetaData",
            "x-displayname": "Route Table Metadata",
            "x-ves-proto-message": "ves.io.schema.topology.RouteTableMetaData",
            "properties": {
                "cloud_resource_id": {
                    "type": "string",
                    "description": " Cloud Resource Identifier this route table",
                    "title": "Cloud Resource Id",
                    "x-displayname": "Cloud Resource Id"
                },
                "name": {
                    "type": "string",
                    "description": " Name of the route table\n\nExample: - \"rt-1\"-",
                    "title": "Name",
                    "x-displayname": "Name",
                    "x-ves-example": "rt-1"
                },
                "tags": {
                    "type": "object",
                    "description": " Map of string keys and values that annotated in the topology node.\n\nExample: - \"value\"-",
                    "title": "tags",
                    "x-displayname": "Tags",
                    "x-ves-example": "value"
                }
            }
        },
        "topologyRouteTableResponse": {
            "type": "object",
            "description": "Route table",
            "title": "Route Table Response",
            "x-displayname": "Route Table Response",
            "x-ves-proto-message": "ves.io.schema.topology.RouteTableResponse",
            "properties": {
                "metadata": {
                    "description": " Route table metadata",
                    "title": "Metadata",
                    "$ref": "#/definitions/topologyRouteTableMetaData",
                    "x-displayname": "Metadata"
                },
                "route_table": {
                    "description": " Route table",
                    "title": "Route Table",
                    "$ref": "#/definitions/topologyRouteTableType",
                    "x-displayname": "Route Table"
                }
            }
        },
        "topologyRouteTableStateEnum": {
            "type": "string",
            "description": "Route table state\n\nRoute table state None\nRoute table state Pending\nRoute table state Availble\nRoute table state Deleting\nRoute table state Deleted",
            "title": "RouteTableStateEnum",
            "enum": [
                "ROUTE_TABLE_STATE_NONE",
                "ROUTE_TABLE_STATE_PENDING",
                "ROUTE_TABLE_STATE_AVAILABLE",
                "ROUTE_TABLE_STATE_DELETING",
                "ROUTE_TABLE_STATE_DELETED"
            ],
            "default": "ROUTE_TABLE_STATE_NONE",
            "x-displayname": "Route Table State",
            "x-ves-proto-enum": "ves.io.schema.topology.RouteTableStateEnum"
        },
        "topologyRouteTableType": {
            "type": "object",
            "description": "A canonical form of the route table.",
            "title": "RouteTableType",
            "x-displayname": "Route Table",
            "x-ves-proto-message": "ves.io.schema.topology.RouteTableType",
            "properties": {
                "associations": {
                    "type": "array",
                    "description": " list of associations",
                    "title": "Associations",
                    "items": {
                        "$ref": "#/definitions/topologyAWSTGWAttachmentMetaData"
                    },
                    "x-displayname": "Associations"
                },
                "explicit_subnet": {
                    "type": "array",
                    "description": " Reference to the subnet explicitly accociated.",
                    "title": "Explicit Subnet Association",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Explicit Subnet Association"
                },
                "implicit_subnet": {
                    "type": "array",
                    "description": " Reference to the subnet implicitly accociated.",
                    "title": "Implicit Subnet Association",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Implicit Subnet Association"
                },
                "network": {
                    "type": "array",
                    "description": " Reference to the network.",
                    "title": "Network",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Network"
                },
                "propagations": {
                    "type": "array",
                    "description": " list of propagations",
                    "title": "Propagations",
                    "items": {
                        "$ref": "#/definitions/topologyAWSTGWAttachmentMetaData"
                    },
                    "x-displayname": "Propagations"
                },
                "route_table_state": {
                    "description": " state of the route table.",
                    "title": "Route Table State",
                    "$ref": "#/definitions/topologyRouteTableStateEnum",
                    "x-displayname": "Route Table State"
                },
                "route_table_type": {
                    "description": " type of this route table.",
                    "title": "Rotue Table type",
                    "$ref": "#/definitions/topologyRouteTableTypeEnum",
                    "x-displayname": "Route table type"
                },
                "routes": {
                    "type": "array",
                    "description": " list of routes",
                    "title": "Routes",
                    "items": {
                        "$ref": "#/definitions/topologyRouteType"
                    },
                    "x-displayname": "Routes"
                },
                "subnet": {
                    "type": "array",
                    "description": " Reference to the subnet.",
                    "title": "Subnet",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Subnet"
                },
                "transit_gateway": {
                    "type": "array",
                    "description": " Reference to the transit gateway if a transit gateway owns this resource.",
                    "title": "Transit Gateway",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Transit Gateway"
                }
            }
        },
        "topologyRouteTableTypeEnum": {
            "type": "string",
            "description": "Route table backend.\n\nRoute table for network\nRoute Table for transit gateway",
            "title": "RouteTableTypeEnum",
            "enum": [
                "ROUTE_TABLE_NETWORK",
                "ROUTE_TABLE_TGW"
            ],
            "default": "ROUTE_TABLE_NETWORK",
            "x-displayname": "Route Table Type",
            "x-ves-proto-enum": "ves.io.schema.topology.RouteTableTypeEnum"
        },
        "topologyRouteType": {
            "type": "object",
            "description": "A canonical form of the route.",
            "title": "RouteType",
            "x-displayname": "Route Type",
            "x-ves-oneof-field-cloud_route_attributes": "[\"aws\",\"gcp\"]",
            "x-ves-proto-message": "ves.io.schema.topology.RouteType",
            "properties": {
                "aws": {
                    "description": "Exclusive with [gcp]\n Cloud Type AWS",
                    "title": "AWS",
                    "$ref": "#/definitions/topologyAWSRouteAttributes",
                    "x-displayname": "AWS"
                },
                "destination": {
                    "type": "string",
                    "description": " Destination",
                    "title": "Destination",
                    "x-displayname": "Destination"
                },
                "gcp": {
                    "description": "Exclusive with [aws]\n Cloud Type GCP",
                    "title": "GCP",
                    "$ref": "#/definitions/topologyGCPRouteAttributes",
                    "x-displayname": "GCP"
                },
                "next_hop_type": {
                    "description": " Next Hop Type of the route",
                    "title": "Next Hop Type",
                    "$ref": "#/definitions/topologyRouteNextHopTypeEnum",
                    "x-displayname": "Next Hop Type"
                },
                "nexthop": {
                    "type": "string",
                    "description": " Nexthop (IP subnet or gateway ID)",
                    "title": "Nexthop",
                    "x-displayname": "Nexthop"
                },
                "source": {
                    "description": " Source of route entry",
                    "title": "Source",
                    "$ref": "#/definitions/topologyRouteSourceTypeEnum",
                    "x-displayname": "Source"
                },
                "state": {
                    "description": " State of the route entry",
                    "title": "State",
                    "$ref": "#/definitions/topologyRouteStateTypeEnum",
                    "x-displayname": "State"
                },
                "user_defined_route_name": {
                    "type": "string",
                    "description": " User Defined Route Name",
                    "title": "User Defined Route Name",
                    "x-displayname": "User Defined Route Name"
                }
            }
        },
        "topologySiteAppTypeEnum": {
            "type": "string",
            "description": "Site App Type\n\n - SITE_APPTYPE_NONE: Not applicable \n\nNot applicable\n - SITE_APPTYPE_APPSTACK: AppStack Site\n\nAppStack Site\n - SITE_APPTYPE_MESH: Mesh site \n\nMesh site",
            "title": "Site App Type",
            "enum": [
                "SITE_APPTYPE_NONE",
                "SITE_APPTYPE_APPSTACK",
                "SITE_APPTYPE_MESH"
            ],
            "default": "SITE_APPTYPE_NONE",
            "x-displayname": "Site App type",
            "x-ves-proto-enum": "ves.io.schema.topology.SiteAppTypeEnum"
        },
        "topologySiteMeshGroupSummaryInfo": {
            "type": "object",
            "description": "Summary information related to the site mesh group",
            "title": "SiteMeshGroupSummaryInfo",
            "x-displayname": "Site Mesh Group Summary",
            "x-ves-proto-message": "ves.io.schema.topology.SiteMeshGroupSummaryInfo",
            "properties": {
                "edge_status_summary": {
                    "type": "array",
                    "description": " Summary of the edges status between the sites in the site mesh group.",
                    "title": "Edge Summary",
                    "items": {
                        "$ref": "#/definitions/topologyEdgeInfoSummary"
                    },
                    "x-displayname": "Edge Summary"
                },
                "link_status_summary": {
                    "type": "array",
                    "description": " Summary of the link status between the sites in the site mesh group.",
                    "title": "Link Status Summary",
                    "items": {
                        "$ref": "#/definitions/topologyLinkInfoSummary"
                    },
                    "x-displayname": "Link Status Summary"
                },
                "other_connected_site_mesh_group_sites": {
                    "type": "integer",
                    "description": " If the site mesh group is of type \"Hub\", this field indicates the number of sites in all the spoke mesh groups\n that are connected to this site mesh group.\n If the site mesh group is of type \"Spoke\", this field indicates the number of sites in the hub as well as the sites\n in other spoke groups that are attached to this hub.",
                    "title": "Other Connected Site Mesh Group Sites",
                    "format": "int64",
                    "x-displayname": "Other Connected Site Mesh Group Sites"
                },
                "sites": {
                    "type": "integer",
                    "description": " This field indicates the number of sites that are part of this site mesh group.",
                    "title": "Sites",
                    "format": "int64",
                    "x-displayname": "Sites"
                }
            }
        },
        "topologySiteMeshTopologyRequest": {
            "type": "object",
            "description": "Request to get site mesh group topology and the associated metrics.",
            "title": "Site Mesh Group Topology Request",
            "x-displayname": "Site Mesh Group Topology Request",
            "x-ves-proto-message": "ves.io.schema.topology.SiteMeshTopologyRequest",
            "properties": {
                "metric_selector": {
                    "description": " Metric fields to be returned in the response. If no metric fields are specified in the request,\n then the response will not contain any metric data.",
                    "title": "Metric Selector",
                    "$ref": "#/definitions/topologyMetricSelector",
                    "x-displayname": "Metric Selector"
                },
                "site_mesh_group": {
                    "type": "string",
                    "description": "\n Name of the site mesh group\n\nExample: - \"smg-1\"-",
                    "title": "Site Mesh Group",
                    "x-displayname": "Site Mesh Group",
                    "x-ves-example": "smg-1"
                }
            }
        },
        "topologySiteNetworksResponse": {
            "type": "object",
            "description": "List of Networks Associated to Site",
            "title": "Site Networks Response",
            "x-displayname": "Site Networks Response",
            "x-ves-oneof-field-cloud_network_meta_data": "[\"aws\"]",
            "x-ves-proto-message": "ves.io.schema.topology.SiteNetworksResponse",
            "properties": {
                "aws": {
                    "description": "Exclusive with []\nAWS network meta data",
                    "title": "AWS",
                    "$ref": "#/definitions/topologyAWSNetworkMetaData",
                    "x-displayname": "AWS"
                },
                "routes_metadata": {
                    "type": "array",
                    "description": " Network Routes Meta Data",
                    "title": "Network Routes Meta Data",
                    "items": {
                        "$ref": "#/definitions/topologyNetworkRoutesMetaData"
                    },
                    "x-displayname": "Network Routes Meta Data"
                }
            }
        },
        "topologySiteSummaryInfo": {
            "type": "object",
            "description": "Summary information related to the site",
            "title": "SiteSummaryInfo",
            "x-displayname": "Site Summary",
            "x-ves-proto-message": "ves.io.schema.topology.SiteSummaryInfo",
            "properties": {
                "availability_zone": {
                    "type": "array",
                    "description": " Availability zone",
                    "title": "Availability Zone",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Availability Zone"
                },
                "node_count": {
                    "type": "integer",
                    "description": " Site Node Count.",
                    "title": "Node Count",
                    "format": "int64",
                    "x-displayname": "Node Count"
                },
                "node_info": {
                    "type": "array",
                    "description": " Provides mapping for node, private ip and public ip",
                    "title": "node_info",
                    "items": {
                        "$ref": "#/definitions/schemasiteNode"
                    },
                    "x-displayname": "Node info"
                }
            }
        },
        "topologySiteTopologyRequest": {
            "type": "object",
            "description": "Request to get site topology and the associated metrics.",
            "title": "Site Topology Request",
            "x-displayname": "Site Topology Request",
            "x-ves-proto-message": "ves.io.schema.topology.SiteTopologyRequest",
            "properties": {
                "group_dc_cluster_nodes": {
                    "type": "boolean",
                    "description": " Option to enable or disable grouping of sites in a DC Cluster group.\n If enabled, then all the sites in a DC Cluster group are returned as a single node in the response.",
                    "title": "Group DC Cluster nodes",
                    "format": "boolean",
                    "x-displayname": "Group DC Cluster nodes"
                },
                "group_site_mesh_nodes": {
                    "type": "boolean",
                    "description": " Option to enable or disable grouping of sites in a site mesh group.\n If enabled, then all the sites in a site mesh group are returned as a single node in the response.",
                    "title": "Group Site Mesh nodes",
                    "format": "boolean",
                    "x-displayname": "Group Site Mesh nodes"
                },
                "level": {
                    "type": "integer",
                    "description": " Level determines the nodes and the corresponding edges to be returned in the response based on its distance from the root node.\n If the level specified in the request is 1, then the response contains the root node (level:0) and all its immediate neighbors (level:1).\n If the level is set to -1, then all the nodes and edges in the topology graph will be returned in the response.\n\nExample: - \"2\"-",
                    "title": "Level",
                    "format": "int32",
                    "x-displayname": "Level",
                    "x-ves-example": "2"
                },
                "metric_selector": {
                    "description": " Metric fields to be returned in the response. If no metric fields are specified in the request,\n then the response will not contain any metric data.",
                    "title": "Metric Selector",
                    "$ref": "#/definitions/topologyMetricSelector",
                    "x-displayname": "Metric Selector"
                },
                "node_id": {
                    "type": "string",
                    "description": " Specifies the node in the topology graph to start the graph traversal.\n\nExample: - \"site:site-1\"-",
                    "title": "Node Id",
                    "x-displayname": "Node Id",
                    "x-ves-example": "site:site-1"
                },
                "site": {
                    "type": "string",
                    "description": "\n Name of the site\n\nExample: - \"ce01\"-",
                    "title": "Site",
                    "x-displayname": "Site",
                    "x-ves-example": "ce01"
                }
            }
        },
        "topologySubnetData": {
            "type": "object",
            "description": "Data associated with the subnets",
            "title": "SubnetData",
            "x-displayname": "Subnet Data",
            "x-ves-proto-message": "ves.io.schema.topology.SubnetData",
            "properties": {
                "metadata": {
                    "description": " Subnet Metadata",
                    "title": "Subnet MetaData",
                    "$ref": "#/definitions/topologySubnetMetaData",
                    "x-displayname": "Subnet MetaData"
                },
                "subnet": {
                    "description": " Subnet",
                    "title": "Subnet",
                    "$ref": "#/definitions/topologySubnetType",
                    "x-displayname": "Subnet"
                }
            }
        },
        "topologySubnetMetaData": {
            "type": "object",
            "description": "Metadata associated with the subnets",
            "title": "SubnetMetaData",
            "x-displayname": "Subnet MetaData",
            "x-ves-proto-message": "ves.io.schema.topology.SubnetMetaData",
            "properties": {
                "cidr_v4": {
                    "type": "array",
                    "description": " IPv4 Cidr",
                    "title": "IPv4 Cidr",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv4 Cidr"
                },
                "cidr_v6": {
                    "type": "array",
                    "description": " IPv6 Cidr",
                    "title": "IPv6 Cidr",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv6 Cidr"
                },
                "cloud_resource_id": {
                    "type": "string",
                    "description": " Cloud Resource Identifier the subnet",
                    "title": "Cloud Resource Id",
                    "x-displayname": "Cloud Resource Id"
                },
                "name": {
                    "type": "string",
                    "description": " Name of the subnet",
                    "title": "Name",
                    "x-displayname": "Name"
                }
            }
        },
        "topologySubnetSummaryInfo": {
            "type": "object",
            "description": "Summary information related to the subnet",
            "title": "SubnetSummaryInfo",
            "x-displayname": "Subnet Summary",
            "x-ves-proto-message": "ves.io.schema.topology.SubnetSummaryInfo",
            "properties": {
                "route_tables": {
                    "type": "array",
                    "description": " List of route tables associated with the subnet",
                    "title": "Route Tables",
                    "items": {
                        "$ref": "#/definitions/topologyRouteTableMetaData"
                    },
                    "x-displayname": "Route Tables"
                }
            }
        },
        "topologySubnetType": {
            "type": "object",
            "description": "A canonical form of the subnet.",
            "title": "Subnet",
            "x-displayname": "subnet",
            "x-ves-proto-message": "ves.io.schema.topology.SubnetType",
            "properties": {
                "availability_zone": {
                    "type": "string",
                    "description": " Availability zone",
                    "title": "Availability Zone",
                    "x-displayname": "Availability Zone"
                },
                "cidr_v4": {
                    "type": "array",
                    "description": " IPv4 Cidr",
                    "title": "IPv4 Cidr",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv4 Cidr"
                },
                "cidr_v6": {
                    "type": "array",
                    "description": " IPv6 Cidr",
                    "title": "IPv6 Cidr",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv6 Cidr"
                },
                "interface_type": {
                    "description": " Subnet Type",
                    "title": "Subnet Type",
                    "$ref": "#/definitions/topologyInterfaceTypeEnum",
                    "x-displayname": "Subnet Type"
                },
                "network": {
                    "type": "array",
                    "description": " Reference to the network",
                    "title": "Network",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Network"
                },
                "region": {
                    "type": "array",
                    "description": " Reference to the regions. (Used for GCP)",
                    "title": "Region",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Region"
                }
            }
        },
        "topologyTGWRouteTablesResponse": {
            "type": "object",
            "description": "List of RouteTables Associated with TGW",
            "title": "TGW Route Tables Response",
            "x-displayname": "TGW Route Tables Response",
            "x-ves-proto-message": "ves.io.schema.topology.TGWRouteTablesResponse",
            "properties": {
                "routes_data": {
                    "type": "array",
                    "description": " TGW Routes Data",
                    "title": "TGW Routes Data",
                    "items": {
                        "$ref": "#/definitions/topologyRouteTableData"
                    },
                    "x-displayname": "TGW Routes Data"
                }
            }
        },
        "topologyTopologyResponse": {
            "type": "object",
            "description": "Relationship between the resources associated with a site is represented as a graph, where each resource/entity is\nrepresented as a node (example: Site (CE, RE), Network (VPC, Virtual Network), Subnet, etc.,) and their association is\nrepresented as edges (example: Site (CE) - Site (CE, RE), Network (VPC) - Subnets, etc.,). All edges are directed.\nHowever if 2 nodes have bidirectional connection, (example: Site - Site), there may be 2 edges in the response for the same\npair of nodes.",
            "title": "Topology Response",
            "x-displayname": "Topology Response",
            "x-ves-proto-message": "ves.io.schema.topology.TopologyResponse",
            "properties": {
                "edges": {
                    "type": "array",
                    "description": " List of edges in the topology graph",
                    "title": "Edges",
                    "items": {
                        "$ref": "#/definitions/topologyEdge"
                    },
                    "x-displayname": "Edges"
                },
                "nodes": {
                    "type": "array",
                    "description": " List of nodes in the topology graph",
                    "title": "Nodes",
                    "items": {
                        "$ref": "#/definitions/schematopologyNode"
                    },
                    "x-displayname": "Nodes"
                },
                "step": {
                    "type": "string",
                    "description": " Actual step size used in the response. It could be higher than the requested step due to metric rollups and the query duration.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\nExample: - \"30m\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.time_interval: true\n",
                    "title": "step",
                    "x-displayname": "Step",
                    "x-ves-example": "30m",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.time_interval": "true"
                    }
                }
            }
        },
        "topologyTransitGatewayType": {
            "type": "object",
            "description": "A canonical form of the transit gateway.",
            "title": "TransitGateway",
            "x-displayname": "transit gateway",
            "x-ves-proto-message": "ves.io.schema.topology.TransitGatewayType",
            "properties": {
                "attachments": {
                    "type": "array",
                    "description": "TGW Attachements",
                    "title": "Attachments",
                    "items": {
                        "$ref": "#/definitions/topologyAWSTGWAttachment"
                    },
                    "x-displayname": "Attachments"
                },
                "auto_accept_shared_attachments": {
                    "type": "boolean",
                    "description": " Auto accept shared attachment",
                    "title": "Auto accept shared attachment",
                    "format": "boolean",
                    "x-displayname": "Auto accept shared attachment"
                },
                "dns_support": {
                    "type": "boolean",
                    "description": " DNS support",
                    "title": "DNS support",
                    "format": "boolean",
                    "x-displayname": "DNS Support"
                },
                "network": {
                    "type": "array",
                    "description": " Reference to the network",
                    "title": "Network",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Network"
                },
                "vpn_ecmp_support": {
                    "type": "boolean",
                    "description": " vpn ecmp support",
                    "title": "vpn ecmp support",
                    "format": "boolean",
                    "x-displayname": "VpnEcmpSupport Support"
                }
            }
        }
    },
    "x-displayname": "Topology",
    "x-ves-proto-file": "ves.io/schema/topology/public_custom_data_api.proto"
}`
