// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/topology/public_custom_data_api.proto

// Topology
//
// x-displayName: "Topology"
// APIs to get topology of all the resources associated/connected to a site such as other CEs (Customer Edge),
// REs (Regional Edge), VPCs (Virtual Private Cloud) networks, etc., and the associated metrics. Relationship between
// the resources associated with a site is represented as a graph, where each resource/entity is represented as a node
// (example: CE, RE, VPC, Subnet, etc.,) and their association is represented as edge (example: CE - RE connection,
// Network - Subnets association, etc.,)

package topology

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/vesenv"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Metric Type
//
// x-displayName: "Metric Type"
// List of metric types applicable for the nodes and edges in the topology graph.
// Not all metric types are applicable for all nodes or edges. For example, LATENCY metric
// is applicable only for the edges where both the vertices are sites and CPU_USAGE metric is
// applicable only for node of type instance. This list is a union of all metric types.
type MetricType int32

const (
	// x-displayName: "In bytes"
	// Total incoming traffic in bytes
	METRIC_TYPE_IN_BYTES MetricType = 0
	// x-displayName: "Out bytes"
	// Total outgoing traffic in bytes
	METRIC_TYPE_OUT_BYTES MetricType = 1
	// x-displayName: "In drops"
	// Total incoming packets dropped
	METRIC_TYPE_IN_DROP_PACKETS MetricType = 2
	// x-displayName: "Out drops"
	// Total outgoing packets dropped
	METRIC_TYPE_OUT_DROP_PACKETS MetricType = 3
	// x-displayName: "Reachability"
	// Reachability based on probes sent periodically
	METRIC_TYPE_REACHABILITY_PERCENT MetricType = 4
	// x-displayName: "Latency"
	// Average latency in seconds
	METRIC_TYPE_LATENCY_SECONDS MetricType = 5
	// x-displayName: "CPU usage"
	// Average CPU utilization in percentage
	METRIC_TYPE_CPU_USAGE_PERCENT MetricType = 6
	// x-displayName: "Memory usage"
	// Average Memory utilization in percentage
	METRIC_TYPE_MEMORY_USAGE_PERCENT MetricType = 7
	// x-displayName: "Disk usage"
	// Average Disk utilization in percentage
	METRIC_TYPE_DISK_USAGE_PERCENT MetricType = 8
	// x-displayName: "Connection Status"
	// Connection status of the tunnel
	METRIC_TYPE_DATA_PLANE_CONNECTION_STATUS MetricType = 9
	// x-displayName: "Control Plane Status"
	// Control plane connection status of the tunnel
	METRIC_TYPE_CONTROL_PLANE_CONNECTION_STATUS MetricType = 10
)

var MetricType_name = map[int32]string{
	0:  "METRIC_TYPE_IN_BYTES",
	1:  "METRIC_TYPE_OUT_BYTES",
	2:  "METRIC_TYPE_IN_DROP_PACKETS",
	3:  "METRIC_TYPE_OUT_DROP_PACKETS",
	4:  "METRIC_TYPE_REACHABILITY_PERCENT",
	5:  "METRIC_TYPE_LATENCY_SECONDS",
	6:  "METRIC_TYPE_CPU_USAGE_PERCENT",
	7:  "METRIC_TYPE_MEMORY_USAGE_PERCENT",
	8:  "METRIC_TYPE_DISK_USAGE_PERCENT",
	9:  "METRIC_TYPE_DATA_PLANE_CONNECTION_STATUS",
	10: "METRIC_TYPE_CONTROL_PLANE_CONNECTION_STATUS",
}

var MetricType_value = map[string]int32{
	"METRIC_TYPE_IN_BYTES":                        0,
	"METRIC_TYPE_OUT_BYTES":                       1,
	"METRIC_TYPE_IN_DROP_PACKETS":                 2,
	"METRIC_TYPE_OUT_DROP_PACKETS":                3,
	"METRIC_TYPE_REACHABILITY_PERCENT":            4,
	"METRIC_TYPE_LATENCY_SECONDS":                 5,
	"METRIC_TYPE_CPU_USAGE_PERCENT":               6,
	"METRIC_TYPE_MEMORY_USAGE_PERCENT":            7,
	"METRIC_TYPE_DISK_USAGE_PERCENT":              8,
	"METRIC_TYPE_DATA_PLANE_CONNECTION_STATUS":    9,
	"METRIC_TYPE_CONTROL_PLANE_CONNECTION_STATUS": 10,
}

func (MetricType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{0}
}

// LinkType
//
// x-displayName: "Link Type"
// Enumerates the association/relationship between 2 nodes.
type LinkType int32

const (
	// x-displayName: "Tunnel"
	// Indicates that 2 nodes are connected using a tunnel
	LINK_TYPE_TUNNEL LinkType = 0
	// x-displayName: "Network"
	// Indicates network connection
	LINK_TYPE_NETWORK LinkType = 1
	// x-displayName: "Subnet"
	// Indicates connection to subnet
	LINK_TYPE_SUBNET LinkType = 2
	// x-displayName: "Instance"
	// Indicates connection to instance
	LINK_TYPE_INSTANCE LinkType = 3
	// x-displayName: "Site Mesh Group"
	// Indicates association with site mesh group
	LINK_TYPE_SITE_MESH_GROUP LinkType = 4
	// x-displayName: "DC Cluster Group"
	// Indicates association with DC Cluster group
	LINK_TYPE_DC_CLUSTER_GROUP LinkType = 5
	// x-displayName: "L3"
	// Indicates L3 connection between the nodes
	LINK_TYPE_L3 LinkType = 6
	// x-displayName: "Control Plane Connection"
	// Indicates the Control plane connection between the nodes
	LINK_TYPE_CONTROL_PLANE LinkType = 7
	// x-displayName: "BGP Connection"
	// Indicates the BGP connection between the tgw and site
	LINK_TYPE_BGP_CONNECTION LinkType = 8
)

var LinkType_name = map[int32]string{
	0: "LINK_TYPE_TUNNEL",
	1: "LINK_TYPE_NETWORK",
	2: "LINK_TYPE_SUBNET",
	3: "LINK_TYPE_INSTANCE",
	4: "LINK_TYPE_SITE_MESH_GROUP",
	5: "LINK_TYPE_DC_CLUSTER_GROUP",
	6: "LINK_TYPE_L3",
	7: "LINK_TYPE_CONTROL_PLANE",
	8: "LINK_TYPE_BGP_CONNECTION",
}

var LinkType_value = map[string]int32{
	"LINK_TYPE_TUNNEL":           0,
	"LINK_TYPE_NETWORK":          1,
	"LINK_TYPE_SUBNET":           2,
	"LINK_TYPE_INSTANCE":         3,
	"LINK_TYPE_SITE_MESH_GROUP":  4,
	"LINK_TYPE_DC_CLUSTER_GROUP": 5,
	"LINK_TYPE_L3":               6,
	"LINK_TYPE_CONTROL_PLANE":    7,
	"LINK_TYPE_BGP_CONNECTION":   8,
}

func (LinkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{1}
}

// LinkStatus
//
// x-displayName: "Link Status"
// Enumerates link status.
type LinkStatus int32

const (
	// x-displayName: "Not Applicable"
	// Status not applicable for this link
	LINK_STATUS_NOT_APPLICABLE LinkStatus = 0
	// x-displayName: "Unknown"
	// Status unknown for this link
	LINK_STATUS_UNKNOWN LinkStatus = 1
	// x-displayName: "Up"
	// Indicates status up/active
	LINK_STATUS_UP LinkStatus = 2
	// x-displayName: "Down"
	// Indicates status down/inactive
	LINK_STATUS_DOWN LinkStatus = 3
)

var LinkStatus_name = map[int32]string{
	0: "LINK_STATUS_NOT_APPLICABLE",
	1: "LINK_STATUS_UNKNOWN",
	2: "LINK_STATUS_UP",
	3: "LINK_STATUS_DOWN",
}

var LinkStatus_value = map[string]int32{
	"LINK_STATUS_NOT_APPLICABLE": 0,
	"LINK_STATUS_UNKNOWN":        1,
	"LINK_STATUS_UP":             2,
	"LINK_STATUS_DOWN":           3,
}

func (LinkStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{2}
}

// Site Topology Request
//
// x-displayName: "Site Topology Request"
// Request to get site topology and the associated metrics.
type SiteTopologyRequest struct {
	// Site
	//
	// x-displayName: "Site"
	//
	// x-example: "ce01"
	// Name of the site
	Site string `protobuf:"bytes,2,opt,name=site,proto3" json:"site,omitempty"`
	// Node Id
	//
	// x-displayName: "Node Id"
	// x-example: "site:site-1"
	// Specifies the node in the topology graph to start the graph traversal.
	NodeId string `protobuf:"bytes,3,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Level
	//
	// x-displayName: "Level"
	// x-example: "2"
	// Level determines the nodes and the corresponding edges to be returned in the response based on its distance from the root node.
	// If the level specified in the request is 1, then the response contains the root node (level:0) and all its immediate neighbors (level:1).
	// If the level is set to -1, then all the nodes and edges in the topology graph will be returned in the response.
	Level int32 `protobuf:"varint,4,opt,name=level,proto3" json:"level,omitempty"`
	// Group Site Mesh nodes
	//
	// x-displayName: "Group Site Mesh nodes"
	// Option to enable or disable grouping of sites in a site mesh group.
	// If enabled, then all the sites in a site mesh group are returned as a single node in the response.
	GroupSiteMeshNodes bool `protobuf:"varint,5,opt,name=group_site_mesh_nodes,json=groupSiteMeshNodes,proto3" json:"group_site_mesh_nodes,omitempty"` // Deprecated: Do not use.
	// Group DC Cluster nodes
	//
	// x-displayName: "Group DC Cluster nodes"
	// Option to enable or disable grouping of sites in a DC Cluster group.
	// If enabled, then all the sites in a DC Cluster group are returned as a single node in the response.
	GroupDcClusterNodes bool `protobuf:"varint,6,opt,name=group_dc_cluster_nodes,json=groupDcClusterNodes,proto3" json:"group_dc_cluster_nodes,omitempty"` // Deprecated: Do not use.
	// Metric Selector
	//
	// x-displayName: "Metric Selector"
	// Metric fields to be returned in the response. If no metric fields are specified in the request,
	// then the response will not contain any metric data.
	MetricSelector *MetricSelector `protobuf:"bytes,7,opt,name=metric_selector,json=metricSelector,proto3" json:"metric_selector,omitempty"`
}

func (m *SiteTopologyRequest) Reset()      { *m = SiteTopologyRequest{} }
func (*SiteTopologyRequest) ProtoMessage() {}
func (*SiteTopologyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{0}
}
func (m *SiteTopologyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteTopologyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SiteTopologyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SiteTopologyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteTopologyRequest.Merge(m, src)
}
func (m *SiteTopologyRequest) XXX_Size() int {
	return m.Size()
}
func (m *SiteTopologyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteTopologyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SiteTopologyRequest proto.InternalMessageInfo

func (m *SiteTopologyRequest) GetSite() string {
	if m != nil {
		return m.Site
	}
	return ""
}

func (m *SiteTopologyRequest) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *SiteTopologyRequest) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

// Deprecated: Do not use.
func (m *SiteTopologyRequest) GetGroupSiteMeshNodes() bool {
	if m != nil {
		return m.GroupSiteMeshNodes
	}
	return false
}

// Deprecated: Do not use.
func (m *SiteTopologyRequest) GetGroupDcClusterNodes() bool {
	if m != nil {
		return m.GroupDcClusterNodes
	}
	return false
}

func (m *SiteTopologyRequest) GetMetricSelector() *MetricSelector {
	if m != nil {
		return m.MetricSelector
	}
	return nil
}

// Site Mesh Groups Summary Request
//
// x-displayName: "Site Mesh Groups Summary Request"
// Request to get summary of all site mesh groups.
type SiteMeshGroupsSummaryRequest struct {
}

func (m *SiteMeshGroupsSummaryRequest) Reset()      { *m = SiteMeshGroupsSummaryRequest{} }
func (*SiteMeshGroupsSummaryRequest) ProtoMessage() {}
func (*SiteMeshGroupsSummaryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{1}
}
func (m *SiteMeshGroupsSummaryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteMeshGroupsSummaryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SiteMeshGroupsSummaryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SiteMeshGroupsSummaryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteMeshGroupsSummaryRequest.Merge(m, src)
}
func (m *SiteMeshGroupsSummaryRequest) XXX_Size() int {
	return m.Size()
}
func (m *SiteMeshGroupsSummaryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteMeshGroupsSummaryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SiteMeshGroupsSummaryRequest proto.InternalMessageInfo

// Site Mesh Group Topology Request
//
// x-displayName: "Site Mesh Group Topology Request"
// Request to get site mesh group topology and the associated metrics.
type SiteMeshTopologyRequest struct {
	// Site Mesh Group
	//
	// x-displayName: "Site Mesh Group"
	//
	// x-example: "smg-1"
	// Name of the site mesh group
	SiteMeshGroup string `protobuf:"bytes,2,opt,name=site_mesh_group,json=siteMeshGroup,proto3" json:"site_mesh_group,omitempty"`
	// Metric Selector
	//
	// x-displayName: "Metric Selector"
	// Metric fields to be returned in the response. If no metric fields are specified in the request,
	// then the response will not contain any metric data.
	MetricSelector *MetricSelector `protobuf:"bytes,3,opt,name=metric_selector,json=metricSelector,proto3" json:"metric_selector,omitempty"`
}

func (m *SiteMeshTopologyRequest) Reset()      { *m = SiteMeshTopologyRequest{} }
func (*SiteMeshTopologyRequest) ProtoMessage() {}
func (*SiteMeshTopologyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{2}
}
func (m *SiteMeshTopologyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteMeshTopologyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SiteMeshTopologyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SiteMeshTopologyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteMeshTopologyRequest.Merge(m, src)
}
func (m *SiteMeshTopologyRequest) XXX_Size() int {
	return m.Size()
}
func (m *SiteMeshTopologyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteMeshTopologyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SiteMeshTopologyRequest proto.InternalMessageInfo

func (m *SiteMeshTopologyRequest) GetSiteMeshGroup() string {
	if m != nil {
		return m.SiteMeshGroup
	}
	return ""
}

func (m *SiteMeshTopologyRequest) GetMetricSelector() *MetricSelector {
	if m != nil {
		return m.MetricSelector
	}
	return nil
}

// DC Cluster Groups Summary Request
//
// x-displayName: "DC Cluster Groups Summary Request"
// Request to get summary of all DC Cluster groups.
type DCClusterGroupsSummaryRequest struct {
}

func (m *DCClusterGroupsSummaryRequest) Reset()      { *m = DCClusterGroupsSummaryRequest{} }
func (*DCClusterGroupsSummaryRequest) ProtoMessage() {}
func (*DCClusterGroupsSummaryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{3}
}
func (m *DCClusterGroupsSummaryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DCClusterGroupsSummaryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DCClusterGroupsSummaryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DCClusterGroupsSummaryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DCClusterGroupsSummaryRequest.Merge(m, src)
}
func (m *DCClusterGroupsSummaryRequest) XXX_Size() int {
	return m.Size()
}
func (m *DCClusterGroupsSummaryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DCClusterGroupsSummaryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DCClusterGroupsSummaryRequest proto.InternalMessageInfo

// DC Cluster Group Topology Request
//
// x-displayName: "DC Cluster Group Topology Request"
// Request to get DC Cluster group topology and the associated metrics.
type DCClusterTopologyRequest struct {
	// DC Cluster group
	//
	// x-displayName: "DC Cluster group"
	// x-example: "dcg-1"
	// Name of the DC Cluster group
	DcClusterGroup string `protobuf:"bytes,2,opt,name=dc_cluster_group,json=dcClusterGroup,proto3" json:"dc_cluster_group,omitempty"`
	// Metric Selector
	//
	// x-displayName: "Metric Selector"
	// Metric fields to be returned in the response. If no metric fields are specified in the request,
	// then the response will not contain any metric data.
	MetricSelector *MetricSelector `protobuf:"bytes,3,opt,name=metric_selector,json=metricSelector,proto3" json:"metric_selector,omitempty"`
}

func (m *DCClusterTopologyRequest) Reset()      { *m = DCClusterTopologyRequest{} }
func (*DCClusterTopologyRequest) ProtoMessage() {}
func (*DCClusterTopologyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{4}
}
func (m *DCClusterTopologyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DCClusterTopologyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DCClusterTopologyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DCClusterTopologyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DCClusterTopologyRequest.Merge(m, src)
}
func (m *DCClusterTopologyRequest) XXX_Size() int {
	return m.Size()
}
func (m *DCClusterTopologyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DCClusterTopologyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DCClusterTopologyRequest proto.InternalMessageInfo

func (m *DCClusterTopologyRequest) GetDcClusterGroup() string {
	if m != nil {
		return m.DcClusterGroup
	}
	return ""
}

func (m *DCClusterTopologyRequest) GetMetricSelector() *MetricSelector {
	if m != nil {
		return m.MetricSelector
	}
	return nil
}

// Topology Response
//
// x-displayName: "Topology Response"
// Relationship between the resources associated with a site is represented as a graph, where each resource/entity is
// represented as a node (example: Site (CE, RE), Network (VPC, Virtual Network), Subnet, etc.,) and their association is
// represented as edges (example: Site (CE) - Site (CE, RE), Network (VPC) - Subnets, etc.,). All edges are directed.
// However if 2 nodes have bidirectional connection, (example: Site - Site), there may be 2 edges in the response for the same
// pair of nodes.
type TopologyResponse struct {
	// Nodes
	//
	// x-displayName: "Nodes"
	// List of nodes in the topology graph
	Nodes []*Node `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// Edges
	//
	// x-displayName: "Edges"
	// List of edges in the topology graph
	Edges []*Edge `protobuf:"bytes,2,rep,name=edges,proto3" json:"edges,omitempty"`
	// step
	//
	// x-displayName: "Step"
	// x-example: "30m"
	// Actual step size used in the response. It could be higher than the requested step due to metric rollups and the query duration.
	// Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days
	Step string `protobuf:"bytes,3,opt,name=step,proto3" json:"step,omitempty"`
}

func (m *TopologyResponse) Reset()      { *m = TopologyResponse{} }
func (*TopologyResponse) ProtoMessage() {}
func (*TopologyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{5}
}
func (m *TopologyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopologyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopologyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopologyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopologyResponse.Merge(m, src)
}
func (m *TopologyResponse) XXX_Size() int {
	return m.Size()
}
func (m *TopologyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TopologyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TopologyResponse proto.InternalMessageInfo

func (m *TopologyResponse) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *TopologyResponse) GetEdges() []*Edge {
	if m != nil {
		return m.Edges
	}
	return nil
}

func (m *TopologyResponse) GetStep() string {
	if m != nil {
		return m.Step
	}
	return ""
}

// Route Table Request
//
// x-displayName: "Route Table Request"
// Request to get the route table
type RouteTableRequest struct {
	// Name
	//
	// x-displayName: "Name"
	// x-required
	// x-example: "rt-1"
	// Route table name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *RouteTableRequest) Reset()      { *m = RouteTableRequest{} }
func (*RouteTableRequest) ProtoMessage() {}
func (*RouteTableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{6}
}
func (m *RouteTableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteTableRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteTableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTableRequest.Merge(m, src)
}
func (m *RouteTableRequest) XXX_Size() int {
	return m.Size()
}
func (m *RouteTableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTableRequest proto.InternalMessageInfo

func (m *RouteTableRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Route Table Response
//
// x-displayName: "Route Table Response"
// Route table
type RouteTableResponse struct {
	// Metadata
	//
	// x-displayName: "Metadata"
	// Route table metadata
	Metadata *RouteTableMetaData `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Route Table
	//
	// x-displayName: "Route Table"
	// Route table
	RouteTable *RouteTableType `protobuf:"bytes,2,opt,name=route_table,json=routeTable,proto3" json:"route_table,omitempty"`
}

func (m *RouteTableResponse) Reset()      { *m = RouteTableResponse{} }
func (*RouteTableResponse) ProtoMessage() {}
func (*RouteTableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{7}
}
func (m *RouteTableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteTableResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteTableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTableResponse.Merge(m, src)
}
func (m *RouteTableResponse) XXX_Size() int {
	return m.Size()
}
func (m *RouteTableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTableResponse proto.InternalMessageInfo

func (m *RouteTableResponse) GetMetadata() *RouteTableMetaData {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *RouteTableResponse) GetRouteTable() *RouteTableType {
	if m != nil {
		return m.RouteTable
	}
	return nil
}

// Metric Selector
//
// x-displayName: "Metric Selector"
// MetricSelector is used to specify the list of metrics to be returned in the response.
type MetricSelector struct {
	// Start time
	//
	// x-displayName: "Start Time"
	// x-example: "1570194000"
	// Start time of metric data. This field is applicable only if "include_metrics" is set to true.
	// Format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// End time
	//
	// x-displayName: "End Time"
	// x-example: "1570197600"
	// End time of metric data. This field is applicable only if "include_metrics" is set to true.
	// Format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// Node Metric Types
	//
	// x-displayName: "Node Metric Types"
	// List of metrics to be returned for the nodes
	Node []MetricType `protobuf:"varint,3,rep,packed,name=node,proto3,enum=ves.io.schema.topology.MetricType" json:"node,omitempty"`
	// Edge Metric Types
	//
	// x-displayName: "Edge Metric Types"
	// List of metrics to be returned for the edges
	Edge []MetricType `protobuf:"varint,4,rep,packed,name=edge,proto3,enum=ves.io.schema.topology.MetricType" json:"edge,omitempty"`
	// Step
	//
	// x-displayName: "Step"
	// x-example: "5m"
	// step is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.
	// The timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn <= end_time.
	// Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days
	//
	// Optional: If not specified, then step size is evaluated to <end_time - start_time>
	Step string `protobuf:"bytes,5,opt,name=step,proto3" json:"step,omitempty"`
}

func (m *MetricSelector) Reset()      { *m = MetricSelector{} }
func (*MetricSelector) ProtoMessage() {}
func (*MetricSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{8}
}
func (m *MetricSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricSelector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricSelector.Merge(m, src)
}
func (m *MetricSelector) XXX_Size() int {
	return m.Size()
}
func (m *MetricSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricSelector.DiscardUnknown(m)
}

var xxx_messageInfo_MetricSelector proto.InternalMessageInfo

func (m *MetricSelector) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *MetricSelector) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *MetricSelector) GetNode() []MetricType {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *MetricSelector) GetEdge() []MetricType {
	if m != nil {
		return m.Edge
	}
	return nil
}

func (m *MetricSelector) GetStep() string {
	if m != nil {
		return m.Step
	}
	return ""
}

// Metric Type Data
//
// x-displayName: "Metric Type Data"
// Metric Type Data contains key that uniquely identifies individual entity and its corresponding metric values.
// For example, if an instance contains multiple interfaces, then the key contains the name/value pair that identifies
// the interface name of the instance.
type MetricTypeData struct {
	// Labels
	//
	// x-displayName: "Labels"
	// Labels contains the name/value pair that uniquely identifies an entity whose metric is being reported.
	// If the Labels is empty, then the metric value is for the corresponding node or edge.
	// For example, if an instance contains multiple interfaces, then the labels contains the name/value pairs that identifies
	// the interface name of the instance.
	Labels map[string]string `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Value
	//
	// x-displayName: "Value"
	// List of metric values. May contain more than one value if timeseries data is requested.
	Values []*schema.MetricValue `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty"`
}

func (m *MetricTypeData) Reset()      { *m = MetricTypeData{} }
func (*MetricTypeData) ProtoMessage() {}
func (*MetricTypeData) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{9}
}
func (m *MetricTypeData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricTypeData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricTypeData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricTypeData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricTypeData.Merge(m, src)
}
func (m *MetricTypeData) XXX_Size() int {
	return m.Size()
}
func (m *MetricTypeData) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricTypeData.DiscardUnknown(m)
}

var xxx_messageInfo_MetricTypeData proto.InternalMessageInfo

func (m *MetricTypeData) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *MetricTypeData) GetValues() []*schema.MetricValue {
	if m != nil {
		return m.Values
	}
	return nil
}

// Metric Data
//
// x-displayName: "Metric Data"
// Metric Data contains the metric type and the metric data.
type MetricData struct {
	// Type
	//
	// x-displayName: "Type"
	// Metric Type
	Type MetricType `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.topology.MetricType" json:"type,omitempty"`
	// Unit
	//
	// x-displayName: "Unit"
	// Unit for the metric value
	Unit schema.UnitType `protobuf:"varint,3,opt,name=unit,proto3,enum=ves.io.schema.UnitType" json:"unit,omitempty"`
	// Data
	//
	// x-displayName: "Data"
	// Metric Data
	Data []*MetricTypeData `protobuf:"bytes,2,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *MetricData) Reset()      { *m = MetricData{} }
func (*MetricData) ProtoMessage() {}
func (*MetricData) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{10}
}
func (m *MetricData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricData.Merge(m, src)
}
func (m *MetricData) XXX_Size() int {
	return m.Size()
}
func (m *MetricData) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricData.DiscardUnknown(m)
}

var xxx_messageInfo_MetricData proto.InternalMessageInfo

func (m *MetricData) GetType() MetricType {
	if m != nil {
		return m.Type
	}
	return METRIC_TYPE_IN_BYTES
}

func (m *MetricData) GetUnit() schema.UnitType {
	if m != nil {
		return m.Unit
	}
	return schema.UNIT_MILLISECONDS
}

func (m *MetricData) GetData() []*MetricTypeData {
	if m != nil {
		return m.Data
	}
	return nil
}

// RouteTableMetaData
//
// x-displayName: "Route Table Metadata"
// Metadata associated with the route table
type RouteTableMetaData struct {
	// Name
	//
	// x-displayName: "Name"
	// x-example: "rt-1"
	// Name of the route table
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// tags
	//
	// x-displayName: "Tags"
	// x-example: "value"
	// Map of string keys and values that annotated in the topology node.
	Tags map[string]string `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Cloud Resource Id
	//
	// x-displayName: "Cloud Resource Id"
	// Cloud Resource Identifier this route table
	CloudResourceId string `protobuf:"bytes,3,opt,name=cloud_resource_id,json=cloudResourceId,proto3" json:"cloud_resource_id,omitempty"`
}

func (m *RouteTableMetaData) Reset()      { *m = RouteTableMetaData{} }
func (*RouteTableMetaData) ProtoMessage() {}
func (*RouteTableMetaData) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{11}
}
func (m *RouteTableMetaData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTableMetaData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteTableMetaData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteTableMetaData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTableMetaData.Merge(m, src)
}
func (m *RouteTableMetaData) XXX_Size() int {
	return m.Size()
}
func (m *RouteTableMetaData) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTableMetaData.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTableMetaData proto.InternalMessageInfo

func (m *RouteTableMetaData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RouteTableMetaData) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *RouteTableMetaData) GetCloudResourceId() string {
	if m != nil {
		return m.CloudResourceId
	}
	return ""
}

// SiteSummaryInfo
//
// x-displayName: "Site Summary"
// Summary information related to the site
type SiteSummaryInfo struct {
	// Node Count
	//
	// x-displayName: "Node Count"
	// Site Node Count.
	NodeCount uint32 `protobuf:"varint,1,opt,name=node_count,json=nodeCount,proto3" json:"node_count,omitempty"`
	// Availability Zone
	//
	// x-displayName: "Availability Zone"
	// Availability zone
	AvailabilityZone []string `protobuf:"bytes,2,rep,name=availability_zone,json=availabilityZone,proto3" json:"availability_zone,omitempty"`
}

func (m *SiteSummaryInfo) Reset()      { *m = SiteSummaryInfo{} }
func (*SiteSummaryInfo) ProtoMessage() {}
func (*SiteSummaryInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{12}
}
func (m *SiteSummaryInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteSummaryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SiteSummaryInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SiteSummaryInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteSummaryInfo.Merge(m, src)
}
func (m *SiteSummaryInfo) XXX_Size() int {
	return m.Size()
}
func (m *SiteSummaryInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteSummaryInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SiteSummaryInfo proto.InternalMessageInfo

func (m *SiteSummaryInfo) GetNodeCount() uint32 {
	if m != nil {
		return m.NodeCount
	}
	return 0
}

func (m *SiteSummaryInfo) GetAvailabilityZone() []string {
	if m != nil {
		return m.AvailabilityZone
	}
	return nil
}

// NetworkSummaryInfo
//
// x-displayName: "Network Summary"
// Summary information related to the network
type NetworkSummaryInfo struct {
	// Route Tables
	//
	// x-displayName: "Route Tables"
	// List of route tables associated with the network
	RouteTables []*RouteTableMetaData `protobuf:"bytes,1,rep,name=route_tables,json=routeTables,proto3" json:"route_tables,omitempty"`
}

func (m *NetworkSummaryInfo) Reset()      { *m = NetworkSummaryInfo{} }
func (*NetworkSummaryInfo) ProtoMessage() {}
func (*NetworkSummaryInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{13}
}
func (m *NetworkSummaryInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkSummaryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkSummaryInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkSummaryInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkSummaryInfo.Merge(m, src)
}
func (m *NetworkSummaryInfo) XXX_Size() int {
	return m.Size()
}
func (m *NetworkSummaryInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkSummaryInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkSummaryInfo proto.InternalMessageInfo

func (m *NetworkSummaryInfo) GetRouteTables() []*RouteTableMetaData {
	if m != nil {
		return m.RouteTables
	}
	return nil
}

// SubnetSummaryInfo
//
// x-displayName: "Subnet Summary"
// Summary information related to the subnet
type SubnetSummaryInfo struct {
	// Route Tables
	//
	// x-displayName: "Route Tables"
	// List of route tables associated with the subnet
	RouteTables []*RouteTableMetaData `protobuf:"bytes,1,rep,name=route_tables,json=routeTables,proto3" json:"route_tables,omitempty"`
}

func (m *SubnetSummaryInfo) Reset()      { *m = SubnetSummaryInfo{} }
func (*SubnetSummaryInfo) ProtoMessage() {}
func (*SubnetSummaryInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{14}
}
func (m *SubnetSummaryInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetSummaryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubnetSummaryInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubnetSummaryInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetSummaryInfo.Merge(m, src)
}
func (m *SubnetSummaryInfo) XXX_Size() int {
	return m.Size()
}
func (m *SubnetSummaryInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetSummaryInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetSummaryInfo proto.InternalMessageInfo

func (m *SubnetSummaryInfo) GetRouteTables() []*RouteTableMetaData {
	if m != nil {
		return m.RouteTables
	}
	return nil
}

// NodeTypeSite
//
// x-displayName: "Site"
// NodeTypeSite contains details about the site and the metrics (if requested/available).
type NodeTypeSite struct {
	// Info
	//
	// x-displayName: "Info"
	// Information about the site.
	Info *SiteType `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	// Metric
	//
	// x-displayName: "Metric"
	// Metric data for the Site.
	Metric []*MetricData `protobuf:"bytes,2,rep,name=metric,proto3" json:"metric,omitempty"`
	// Summary
	//
	// x-displayName: "Summary"
	// Site summary contains additional fields that are not part of the "info" field
	Summary *SiteSummaryInfo `protobuf:"bytes,3,opt,name=summary,proto3" json:"summary,omitempty"`
}

func (m *NodeTypeSite) Reset()      { *m = NodeTypeSite{} }
func (*NodeTypeSite) ProtoMessage() {}
func (*NodeTypeSite) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{15}
}
func (m *NodeTypeSite) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeTypeSite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeTypeSite.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeTypeSite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeTypeSite.Merge(m, src)
}
func (m *NodeTypeSite) XXX_Size() int {
	return m.Size()
}
func (m *NodeTypeSite) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeTypeSite.DiscardUnknown(m)
}

var xxx_messageInfo_NodeTypeSite proto.InternalMessageInfo

func (m *NodeTypeSite) GetInfo() *SiteType {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *NodeTypeSite) GetMetric() []*MetricData {
	if m != nil {
		return m.Metric
	}
	return nil
}

func (m *NodeTypeSite) GetSummary() *SiteSummaryInfo {
	if m != nil {
		return m.Summary
	}
	return nil
}

// SiteMeshGroupSummaryInfo
//
// x-displayName: "Site Mesh Group Summary"
// Summary information related to the site mesh group
type SiteMeshGroupSummaryInfo struct {
	// Sites
	//
	// x-displayName: "Sites"
	// This field indicates the number of sites that are part of this site mesh group.
	Sites uint32 `protobuf:"varint,1,opt,name=sites,proto3" json:"sites,omitempty"`
	// Other Connected Site Mesh Group Sites
	//
	// x-displayName: "Other Connected Site Mesh Group Sites"
	// If the site mesh group is of type "Hub", this field indicates the number of sites in all the spoke mesh groups
	// that are connected to this site mesh group.
	// If the site mesh group is of type "Spoke", this field indicates the number of sites in the hub as well as the sites
	// in other spoke groups that are attached to this hub.
	OtherConnectedSiteMeshGroupSites uint32 `protobuf:"varint,2,opt,name=other_connected_site_mesh_group_sites,json=otherConnectedSiteMeshGroupSites,proto3" json:"other_connected_site_mesh_group_sites,omitempty"`
	// Link Status Summary
	//
	// x-displayName: "Link Status Summary"
	// Summary of the link status between the sites in the site mesh group.
	LinkStatusSummary []*LinkInfoSummary `protobuf:"bytes,3,rep,name=link_status_summary,json=linkStatusSummary,proto3" json:"link_status_summary,omitempty"`
	// Edge Summary
	//
	// x-displayName: "Edge Summary"
	// Summary of the edges status between the sites in the site mesh group.
	EdgeStatusSummary []*EdgeInfoSummary `protobuf:"bytes,4,rep,name=edge_status_summary,json=edgeStatusSummary,proto3" json:"edge_status_summary,omitempty"`
}

func (m *SiteMeshGroupSummaryInfo) Reset()      { *m = SiteMeshGroupSummaryInfo{} }
func (*SiteMeshGroupSummaryInfo) ProtoMessage() {}
func (*SiteMeshGroupSummaryInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{16}
}
func (m *SiteMeshGroupSummaryInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteMeshGroupSummaryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SiteMeshGroupSummaryInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SiteMeshGroupSummaryInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteMeshGroupSummaryInfo.Merge(m, src)
}
func (m *SiteMeshGroupSummaryInfo) XXX_Size() int {
	return m.Size()
}
func (m *SiteMeshGroupSummaryInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteMeshGroupSummaryInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SiteMeshGroupSummaryInfo proto.InternalMessageInfo

func (m *SiteMeshGroupSummaryInfo) GetSites() uint32 {
	if m != nil {
		return m.Sites
	}
	return 0
}

func (m *SiteMeshGroupSummaryInfo) GetOtherConnectedSiteMeshGroupSites() uint32 {
	if m != nil {
		return m.OtherConnectedSiteMeshGroupSites
	}
	return 0
}

func (m *SiteMeshGroupSummaryInfo) GetLinkStatusSummary() []*LinkInfoSummary {
	if m != nil {
		return m.LinkStatusSummary
	}
	return nil
}

func (m *SiteMeshGroupSummaryInfo) GetEdgeStatusSummary() []*EdgeInfoSummary {
	if m != nil {
		return m.EdgeStatusSummary
	}
	return nil
}

// NodeTypeSiteMeshGroup
//
// x-displayName: "Site Mesh Group"
// Site mesh group is represented as a node in the site topology graph.
// In the SiteMeshTopology API, site_mesh_group is represented as a node and all the sites
// that are part of the site mesh group are represented as edges (site -> site_mesh_group) in
// addition to the edges between the sites (site <-> site). If the site_mesh_group is of type "Spoke",
// then the node representing the site_mesh_group will have an edge with another site_mesh_group node
// that represents the "Hub" and vice-versa.
type NodeTypeSiteMeshGroup struct {
	// Info
	//
	// x-displayName: "Info"
	// Information about the site mesh group.
	Info *SiteMeshGroupType `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	// Summary
	//
	// x-displayName: "Summary"
	// Summary information related to the site mesh group
	Summary *SiteMeshGroupSummaryInfo `protobuf:"bytes,2,opt,name=summary,proto3" json:"summary,omitempty"`
}

func (m *NodeTypeSiteMeshGroup) Reset()      { *m = NodeTypeSiteMeshGroup{} }
func (*NodeTypeSiteMeshGroup) ProtoMessage() {}
func (*NodeTypeSiteMeshGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{17}
}
func (m *NodeTypeSiteMeshGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeTypeSiteMeshGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeTypeSiteMeshGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeTypeSiteMeshGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeTypeSiteMeshGroup.Merge(m, src)
}
func (m *NodeTypeSiteMeshGroup) XXX_Size() int {
	return m.Size()
}
func (m *NodeTypeSiteMeshGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeTypeSiteMeshGroup.DiscardUnknown(m)
}

var xxx_messageInfo_NodeTypeSiteMeshGroup proto.InternalMessageInfo

func (m *NodeTypeSiteMeshGroup) GetInfo() *SiteMeshGroupType {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *NodeTypeSiteMeshGroup) GetSummary() *SiteMeshGroupSummaryInfo {
	if m != nil {
		return m.Summary
	}
	return nil
}

// DCClusterGroupSummaryInfo
//
// x-displayName: "DC Cluster Group Summary"
// Summary information related to the DC Cluster Group
type DCClusterGroupSummaryInfo struct {
	// Sites
	//
	// x-displayName: "Sites"
	// This field indicates the number of sites that are part of this DC Cluster group.
	Sites uint32 `protobuf:"varint,1,opt,name=sites,proto3" json:"sites,omitempty"`
}

func (m *DCClusterGroupSummaryInfo) Reset()      { *m = DCClusterGroupSummaryInfo{} }
func (*DCClusterGroupSummaryInfo) ProtoMessage() {}
func (*DCClusterGroupSummaryInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{18}
}
func (m *DCClusterGroupSummaryInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DCClusterGroupSummaryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DCClusterGroupSummaryInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DCClusterGroupSummaryInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DCClusterGroupSummaryInfo.Merge(m, src)
}
func (m *DCClusterGroupSummaryInfo) XXX_Size() int {
	return m.Size()
}
func (m *DCClusterGroupSummaryInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DCClusterGroupSummaryInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DCClusterGroupSummaryInfo proto.InternalMessageInfo

func (m *DCClusterGroupSummaryInfo) GetSites() uint32 {
	if m != nil {
		return m.Sites
	}
	return 0
}

// NodeTypeDCClusterGroup
//
// x-displayName: "DC Cluster Group"
// DC Cluster group is represented as a node in the site topology graph.
// In the DCClusterTopology API, dc_cluster_group is represented as a node and all the sites
// that are part of the DC Cluster group are represented as edges (site -> dc_cluster_group) in
// addition to the edges between the sites (site <-> site).
type NodeTypeDCClusterGroup struct {
	// Info
	//
	// x-displayName: "Info"
	// Information about the DC Cluster group.
	Info *DCClusterGroupType `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	// Summary
	//
	// x-displayName: "Summary"
	// Summary information related to the DC Cluster group
	Summary *DCClusterGroupSummaryInfo `protobuf:"bytes,2,opt,name=summary,proto3" json:"summary,omitempty"`
}

func (m *NodeTypeDCClusterGroup) Reset()      { *m = NodeTypeDCClusterGroup{} }
func (*NodeTypeDCClusterGroup) ProtoMessage() {}
func (*NodeTypeDCClusterGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{19}
}
func (m *NodeTypeDCClusterGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeTypeDCClusterGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeTypeDCClusterGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeTypeDCClusterGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeTypeDCClusterGroup.Merge(m, src)
}
func (m *NodeTypeDCClusterGroup) XXX_Size() int {
	return m.Size()
}
func (m *NodeTypeDCClusterGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeTypeDCClusterGroup.DiscardUnknown(m)
}

var xxx_messageInfo_NodeTypeDCClusterGroup proto.InternalMessageInfo

func (m *NodeTypeDCClusterGroup) GetInfo() *DCClusterGroupType {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *NodeTypeDCClusterGroup) GetSummary() *DCClusterGroupSummaryInfo {
	if m != nil {
		return m.Summary
	}
	return nil
}

// NodeTypeTransitGateway
//
// x-displayName: "Transit Gateway"
// NodeTypeTransitGateway contains details about the transit gateway and the metrics (if requested/available).
type NodeTypeTransitGateway struct {
	// Info
	//
	// x-displayName: "Info"
	// Information about the Transit Gateway.
	Info *TransitGatewayType `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	// Metric
	//
	// x-displayName: "Metric"
	// Metric data for the Transit Gateway.
	Metric []*MetricData `protobuf:"bytes,2,rep,name=metric,proto3" json:"metric,omitempty"`
}

func (m *NodeTypeTransitGateway) Reset()      { *m = NodeTypeTransitGateway{} }
func (*NodeTypeTransitGateway) ProtoMessage() {}
func (*NodeTypeTransitGateway) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{20}
}
func (m *NodeTypeTransitGateway) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeTypeTransitGateway) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeTypeTransitGateway.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeTypeTransitGateway) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeTypeTransitGateway.Merge(m, src)
}
func (m *NodeTypeTransitGateway) XXX_Size() int {
	return m.Size()
}
func (m *NodeTypeTransitGateway) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeTypeTransitGateway.DiscardUnknown(m)
}

var xxx_messageInfo_NodeTypeTransitGateway proto.InternalMessageInfo

func (m *NodeTypeTransitGateway) GetInfo() *TransitGatewayType {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *NodeTypeTransitGateway) GetMetric() []*MetricData {
	if m != nil {
		return m.Metric
	}
	return nil
}

// NodeTypeNetwork
//
// x-displayName: "Network"
// NodeTypeNetwork contains details about the network and the metrics (if requested/available).
type NodeTypeNetwork struct {
	// Info
	//
	// x-displayName: "Info"
	// Information about the Network.
	Info *NetworkType `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	// Metric
	//
	// x-displayName: "Metric"
	// Metric data for the Network.
	Metric []*MetricData `protobuf:"bytes,2,rep,name=metric,proto3" json:"metric,omitempty"`
	// Summary
	//
	// x-displayName: "Summary"
	// Network summary contains additional fields that are not part of the "info" field
	Summary *NetworkSummaryInfo `protobuf:"bytes,3,opt,name=summary,proto3" json:"summary,omitempty"`
}

func (m *NodeTypeNetwork) Reset()      { *m = NodeTypeNetwork{} }
func (*NodeTypeNetwork) ProtoMessage() {}
func (*NodeTypeNetwork) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{21}
}
func (m *NodeTypeNetwork) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeTypeNetwork) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeTypeNetwork.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeTypeNetwork) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeTypeNetwork.Merge(m, src)
}
func (m *NodeTypeNetwork) XXX_Size() int {
	return m.Size()
}
func (m *NodeTypeNetwork) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeTypeNetwork.DiscardUnknown(m)
}

var xxx_messageInfo_NodeTypeNetwork proto.InternalMessageInfo

func (m *NodeTypeNetwork) GetInfo() *NetworkType {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *NodeTypeNetwork) GetMetric() []*MetricData {
	if m != nil {
		return m.Metric
	}
	return nil
}

func (m *NodeTypeNetwork) GetSummary() *NetworkSummaryInfo {
	if m != nil {
		return m.Summary
	}
	return nil
}

// NodeTypeSubnet
//
// x-displayName: "Subnet"
// NodeTypeSubnet contains details about the subnet and the metrics (if requested/available).
type NodeTypeSubnet struct {
	// Info
	//
	// x-displayName: "Info"
	// Information about the Subnet.
	Info *SubnetType `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	// Metric
	//
	// x-displayName: "Metric"
	// Metric data for the Subnet.
	Metric []*MetricData `protobuf:"bytes,2,rep,name=metric,proto3" json:"metric,omitempty"`
	// Summary
	//
	// x-displayName: "Summary"
	// Subnet summary contains additional fields that are not part of the "info" field
	Summary *SubnetSummaryInfo `protobuf:"bytes,3,opt,name=summary,proto3" json:"summary,omitempty"`
}

func (m *NodeTypeSubnet) Reset()      { *m = NodeTypeSubnet{} }
func (*NodeTypeSubnet) ProtoMessage() {}
func (*NodeTypeSubnet) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{22}
}
func (m *NodeTypeSubnet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeTypeSubnet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeTypeSubnet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeTypeSubnet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeTypeSubnet.Merge(m, src)
}
func (m *NodeTypeSubnet) XXX_Size() int {
	return m.Size()
}
func (m *NodeTypeSubnet) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeTypeSubnet.DiscardUnknown(m)
}

var xxx_messageInfo_NodeTypeSubnet proto.InternalMessageInfo

func (m *NodeTypeSubnet) GetInfo() *SubnetType {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *NodeTypeSubnet) GetMetric() []*MetricData {
	if m != nil {
		return m.Metric
	}
	return nil
}

func (m *NodeTypeSubnet) GetSummary() *SubnetSummaryInfo {
	if m != nil {
		return m.Summary
	}
	return nil
}

// NodeTypeInstance
//
// x-displayName: "Instance"
// NodeTypeInstance contains details about the instance and the metrics (if requested/available).
type NodeTypeInstance struct {
	// Info
	//
	// x-displayName: "Info"
	// Information about the Instance.
	Info *InstanceType `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	// Metric
	//
	// x-displayName: "Metric"
	// Metric data for the Instance.
	Metric []*MetricData `protobuf:"bytes,2,rep,name=metric,proto3" json:"metric,omitempty"`
}

func (m *NodeTypeInstance) Reset()      { *m = NodeTypeInstance{} }
func (*NodeTypeInstance) ProtoMessage() {}
func (*NodeTypeInstance) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{23}
}
func (m *NodeTypeInstance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeTypeInstance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeTypeInstance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeTypeInstance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeTypeInstance.Merge(m, src)
}
func (m *NodeTypeInstance) XXX_Size() int {
	return m.Size()
}
func (m *NodeTypeInstance) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeTypeInstance.DiscardUnknown(m)
}

var xxx_messageInfo_NodeTypeInstance proto.InternalMessageInfo

func (m *NodeTypeInstance) GetInfo() *InstanceType {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *NodeTypeInstance) GetMetric() []*MetricData {
	if m != nil {
		return m.Metric
	}
	return nil
}

// Node Metadata
//
// x-displayName: "Node Metadata"
// Metadata for node
type NodeMetaData struct {
	// Name
	//
	// x-displayName: "Name"
	// x-example: "site-1"
	// Name of the node.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Cloud Resource Id
	//
	// x-displayName: "Cloud Resource Id"
	// Cloud Resource Identifier for the node. This is only used for node which represent the cloud resource
	CloudResourceId string `protobuf:"bytes,8,opt,name=cloud_resource_id,json=cloudResourceId,proto3" json:"cloud_resource_id,omitempty"`
	// Description
	//
	// x-displayName: "Description"
	// Description of the node.
	// This field may or may not be populated depending on the node type and if the user provided description
	// while creating the resource.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Level
	//
	// x-displayName: "Level"
	// x-example: "1"
	// Level indicates the distance of the node from the root node. A value of 0 indicates the root node.
	Level uint32 `protobuf:"varint,3,opt,name=level,proto3" json:"level,omitempty"`
	// Provider Type
	//
	// x-displayName: "Provider Type"
	// Provider type
	ProviderType ProviderType `protobuf:"varint,4,opt,name=provider_type,json=providerType,proto3,enum=ves.io.schema.topology.ProviderType" json:"provider_type,omitempty"`
	// Owner Id
	//
	// x-displayName: "Owner Id"
	// x-example: "owner-1"
	// Owner id
	OwnerId string `protobuf:"bytes,5,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	// Tags
	//
	// x-displayName: "Tags"
	// List of key/value pairs associated with the node
	Tags map[string]string `protobuf:"bytes,6,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Status
	//
	// x-displayName: "Status"
	// status in the node
	Status string `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *NodeMetaData) Reset()      { *m = NodeMetaData{} }
func (*NodeMetaData) ProtoMessage() {}
func (*NodeMetaData) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{24}
}
func (m *NodeMetaData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeMetaData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeMetaData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeMetaData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeMetaData.Merge(m, src)
}
func (m *NodeMetaData) XXX_Size() int {
	return m.Size()
}
func (m *NodeMetaData) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeMetaData.DiscardUnknown(m)
}

var xxx_messageInfo_NodeMetaData proto.InternalMessageInfo

func (m *NodeMetaData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NodeMetaData) GetCloudResourceId() string {
	if m != nil {
		return m.CloudResourceId
	}
	return ""
}

func (m *NodeMetaData) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *NodeMetaData) GetLevel() uint32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *NodeMetaData) GetProviderType() ProviderType {
	if m != nil {
		return m.ProviderType
	}
	return PROVIDER_TYPE_UNSPECIFIED
}

func (m *NodeMetaData) GetOwnerId() string {
	if m != nil {
		return m.OwnerId
	}
	return ""
}

func (m *NodeMetaData) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *NodeMetaData) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// Node
//
// x-displayName: "Node"
// Canonical representation of Node in the topology graph.
type Node struct {
	// Id
	//
	// x-displayName: "Id"
	// Identifier for the node.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Metadata
	//
	// x-displayName: "Metadata"
	// Metadata for the node.
	Metadata *NodeMetaData `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Node Type
	//
	// x-displayName: "Node Type"
	// Identifies the Node Type.
	//
	// Types that are valid to be assigned to NodeType:
	//	*Node_Site
	//	*Node_TransitGateway
	//	*Node_Network
	//	*Node_Subnet
	//	*Node_Instance
	//	*Node_SiteMeshGroup
	//	*Node_DcClusterGroup
	NodeType isNode_NodeType `protobuf_oneof:"node_type"`
}

func (m *Node) Reset()      { *m = Node{} }
func (*Node) ProtoMessage() {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{25}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

type isNode_NodeType interface {
	isNode_NodeType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Node_Site struct {
	Site *NodeTypeSite `protobuf:"bytes,4,opt,name=site,proto3,oneof" json:"site,omitempty"`
}
type Node_TransitGateway struct {
	TransitGateway *NodeTypeTransitGateway `protobuf:"bytes,5,opt,name=transit_gateway,json=transitGateway,proto3,oneof" json:"transit_gateway,omitempty"`
}
type Node_Network struct {
	Network *NodeTypeNetwork `protobuf:"bytes,6,opt,name=network,proto3,oneof" json:"network,omitempty"`
}
type Node_Subnet struct {
	Subnet *NodeTypeSubnet `protobuf:"bytes,7,opt,name=subnet,proto3,oneof" json:"subnet,omitempty"`
}
type Node_Instance struct {
	Instance *NodeTypeInstance `protobuf:"bytes,8,opt,name=instance,proto3,oneof" json:"instance,omitempty"`
}
type Node_SiteMeshGroup struct {
	SiteMeshGroup *NodeTypeSiteMeshGroup `protobuf:"bytes,9,opt,name=site_mesh_group,json=siteMeshGroup,proto3,oneof" json:"site_mesh_group,omitempty"`
}
type Node_DcClusterGroup struct {
	DcClusterGroup *NodeTypeDCClusterGroup `protobuf:"bytes,10,opt,name=dc_cluster_group,json=dcClusterGroup,proto3,oneof" json:"dc_cluster_group,omitempty"`
}

func (*Node_Site) isNode_NodeType()           {}
func (*Node_TransitGateway) isNode_NodeType() {}
func (*Node_Network) isNode_NodeType()        {}
func (*Node_Subnet) isNode_NodeType()         {}
func (*Node_Instance) isNode_NodeType()       {}
func (*Node_SiteMeshGroup) isNode_NodeType()  {}
func (*Node_DcClusterGroup) isNode_NodeType() {}

func (m *Node) GetNodeType() isNode_NodeType {
	if m != nil {
		return m.NodeType
	}
	return nil
}

func (m *Node) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Node) GetMetadata() *NodeMetaData {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Node) GetSite() *NodeTypeSite {
	if x, ok := m.GetNodeType().(*Node_Site); ok {
		return x.Site
	}
	return nil
}

func (m *Node) GetTransitGateway() *NodeTypeTransitGateway {
	if x, ok := m.GetNodeType().(*Node_TransitGateway); ok {
		return x.TransitGateway
	}
	return nil
}

func (m *Node) GetNetwork() *NodeTypeNetwork {
	if x, ok := m.GetNodeType().(*Node_Network); ok {
		return x.Network
	}
	return nil
}

func (m *Node) GetSubnet() *NodeTypeSubnet {
	if x, ok := m.GetNodeType().(*Node_Subnet); ok {
		return x.Subnet
	}
	return nil
}

func (m *Node) GetInstance() *NodeTypeInstance {
	if x, ok := m.GetNodeType().(*Node_Instance); ok {
		return x.Instance
	}
	return nil
}

func (m *Node) GetSiteMeshGroup() *NodeTypeSiteMeshGroup {
	if x, ok := m.GetNodeType().(*Node_SiteMeshGroup); ok {
		return x.SiteMeshGroup
	}
	return nil
}

func (m *Node) GetDcClusterGroup() *NodeTypeDCClusterGroup {
	if x, ok := m.GetNodeType().(*Node_DcClusterGroup); ok {
		return x.DcClusterGroup
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Node) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Node_Site)(nil),
		(*Node_TransitGateway)(nil),
		(*Node_Network)(nil),
		(*Node_Subnet)(nil),
		(*Node_Instance)(nil),
		(*Node_SiteMeshGroup)(nil),
		(*Node_DcClusterGroup)(nil),
	}
}

// LinkInfo
//
// x-displayName: "Link Info"
// Information about the link that connects 2 nodes in the topology graph.
type LinkInfo struct {
	// Name
	//
	// x-displayName: "Name"
	// x-example: "tunnel-1"
	// Name of the link.
	// Link name may or may not be present depending on the type of link.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Type
	//
	// x-displayName: "Type"
	// Link type.
	Type LinkType `protobuf:"varint,2,opt,name=type,proto3,enum=ves.io.schema.topology.LinkType" json:"type,omitempty"`
	// Status
	//
	// x-displayName: "Status"
	// Link status.
	Status LinkStatus `protobuf:"varint,3,opt,name=status,proto3,enum=ves.io.schema.topology.LinkStatus" json:"status,omitempty"`
	// Source ID
	//
	// x-displayName: "Source ID"
	// Endpoint identifier. src_id is the source endpoint for the link is between src_id and dst_id.
	// x-example: "master-0"
	SrcId string `protobuf:"bytes,4,opt,name=src_id,json=srcId,proto3" json:"src_id,omitempty"`
	// Destination ID
	//
	// x-displayName: "Destination ID"
	// Endpoint identifier. dst_id is the destination endpoint for the link is between src_id and dst_id.
	// x-example: "master-0"
	DstId string `protobuf:"bytes,5,opt,name=dst_id,json=dstId,proto3" json:"dst_id,omitempty"`
}

func (m *LinkInfo) Reset()      { *m = LinkInfo{} }
func (*LinkInfo) ProtoMessage() {}
func (*LinkInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{26}
}
func (m *LinkInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LinkInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkInfo.Merge(m, src)
}
func (m *LinkInfo) XXX_Size() int {
	return m.Size()
}
func (m *LinkInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LinkInfo proto.InternalMessageInfo

func (m *LinkInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LinkInfo) GetType() LinkType {
	if m != nil {
		return m.Type
	}
	return LINK_TYPE_TUNNEL
}

func (m *LinkInfo) GetStatus() LinkStatus {
	if m != nil {
		return m.Status
	}
	return LINK_STATUS_NOT_APPLICABLE
}

func (m *LinkInfo) GetSrcId() string {
	if m != nil {
		return m.SrcId
	}
	return ""
}

func (m *LinkInfo) GetDstId() string {
	if m != nil {
		return m.DstId
	}
	return ""
}

// LinkInfoSummary
//
// x-displayName: "Link Info Summary"
// Summary information for a link type
type LinkInfoSummary struct {
	// Type
	//
	// x-displayName: "Type"
	// Link type.
	Type LinkType `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.topology.LinkType" json:"type,omitempty"`
	// Status
	//
	// x-displayName: "Status"
	// Link status.
	Status LinkStatus `protobuf:"varint,2,opt,name=status,proto3,enum=ves.io.schema.topology.LinkStatus" json:"status,omitempty"`
	// Count
	//
	// x-displayName: "Count"
	// Links count.
	Count uint32 `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *LinkInfoSummary) Reset()      { *m = LinkInfoSummary{} }
func (*LinkInfoSummary) ProtoMessage() {}
func (*LinkInfoSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{27}
}
func (m *LinkInfoSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkInfoSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkInfoSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LinkInfoSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkInfoSummary.Merge(m, src)
}
func (m *LinkInfoSummary) XXX_Size() int {
	return m.Size()
}
func (m *LinkInfoSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkInfoSummary.DiscardUnknown(m)
}

var xxx_messageInfo_LinkInfoSummary proto.InternalMessageInfo

func (m *LinkInfoSummary) GetType() LinkType {
	if m != nil {
		return m.Type
	}
	return LINK_TYPE_TUNNEL
}

func (m *LinkInfoSummary) GetStatus() LinkStatus {
	if m != nil {
		return m.Status
	}
	return LINK_STATUS_NOT_APPLICABLE
}

func (m *LinkInfoSummary) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// LinkTypeData
//
// x-displayName: "Link Type Data"
// LinkTypeData contains details about the link and the metrics (if requested/available).
type LinkTypeData struct {
	// Info
	//
	// x-displayName: "Info"
	// Information about the link.
	Info *LinkInfo `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	// Metric
	//
	// x-displayName: "Metric"
	// Metric data for the link.
	Metric []*MetricData `protobuf:"bytes,2,rep,name=metric,proto3" json:"metric,omitempty"`
}

func (m *LinkTypeData) Reset()      { *m = LinkTypeData{} }
func (*LinkTypeData) ProtoMessage() {}
func (*LinkTypeData) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{28}
}
func (m *LinkTypeData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkTypeData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkTypeData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LinkTypeData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkTypeData.Merge(m, src)
}
func (m *LinkTypeData) XXX_Size() int {
	return m.Size()
}
func (m *LinkTypeData) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkTypeData.DiscardUnknown(m)
}

var xxx_messageInfo_LinkTypeData proto.InternalMessageInfo

func (m *LinkTypeData) GetInfo() *LinkInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *LinkTypeData) GetMetric() []*MetricData {
	if m != nil {
		return m.Metric
	}
	return nil
}

// EdgeInfoSummary
//
// x-displayName: "Edge Info Summary"
// Summary information for an edge
type EdgeInfoSummary struct {
	// Status
	//
	// x-displayName: "Status"
	// Edge status.
	Status LinkStatus `protobuf:"varint,1,opt,name=status,proto3,enum=ves.io.schema.topology.LinkStatus" json:"status,omitempty"`
	// Count
	//
	// x-displayName: "Count"
	// Links count.
	Count uint32 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *EdgeInfoSummary) Reset()      { *m = EdgeInfoSummary{} }
func (*EdgeInfoSummary) ProtoMessage() {}
func (*EdgeInfoSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{29}
}
func (m *EdgeInfoSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EdgeInfoSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EdgeInfoSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EdgeInfoSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EdgeInfoSummary.Merge(m, src)
}
func (m *EdgeInfoSummary) XXX_Size() int {
	return m.Size()
}
func (m *EdgeInfoSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_EdgeInfoSummary.DiscardUnknown(m)
}

var xxx_messageInfo_EdgeInfoSummary proto.InternalMessageInfo

func (m *EdgeInfoSummary) GetStatus() LinkStatus {
	if m != nil {
		return m.Status
	}
	return LINK_STATUS_NOT_APPLICABLE
}

func (m *EdgeInfoSummary) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// Edge
//
// x-displayName: "Edge"
// Canonical representation of Edge in the topology graph.
type Edge struct {
	// Node Id1
	//
	// x-displayName: "Node Id1"
	// Node identifier.
	NodeId1 string `protobuf:"bytes,1,opt,name=node_id1,json=nodeId1,proto3" json:"node_id1,omitempty"`
	// Node Id2
	//
	// x-displayName: "Node Id2"
	// Node identifier.
	NodeId2 string `protobuf:"bytes,2,opt,name=node_id2,json=nodeId2,proto3" json:"node_id2,omitempty"`
	// Links
	//
	// x-displayName: "Links"
	// An edge may be composed of multiple links.
	// For example, there may be multiple tunnels between a transit gateway and a site and each tunnel
	// is represented as individual links. In some cases, we may want to show only one link between 2 nodes,
	// eventhough there may be multiple connections/tunnels between these nodes.
	Links []*LinkTypeData `protobuf:"bytes,3,rep,name=links,proto3" json:"links,omitempty"`
	// Status
	//
	// x-displayName: "Status"
	// Indicates the overall status of the edge.
	// An edge may be have multiple links (dataplane tunnels, control plane connections).
	// The status of an edge indicates the overall health of the edge.
	Status LinkStatus `protobuf:"varint,4,opt,name=status,proto3,enum=ves.io.schema.topology.LinkStatus" json:"status,omitempty"`
}

func (m *Edge) Reset()      { *m = Edge{} }
func (*Edge) ProtoMessage() {}
func (*Edge) Descriptor() ([]byte, []int) {
	return fileDescriptor_a69fe73d473fc687, []int{30}
}
func (m *Edge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Edge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Edge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Edge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Edge.Merge(m, src)
}
func (m *Edge) XXX_Size() int {
	return m.Size()
}
func (m *Edge) XXX_DiscardUnknown() {
	xxx_messageInfo_Edge.DiscardUnknown(m)
}

var xxx_messageInfo_Edge proto.InternalMessageInfo

func (m *Edge) GetNodeId1() string {
	if m != nil {
		return m.NodeId1
	}
	return ""
}

func (m *Edge) GetNodeId2() string {
	if m != nil {
		return m.NodeId2
	}
	return ""
}

func (m *Edge) GetLinks() []*LinkTypeData {
	if m != nil {
		return m.Links
	}
	return nil
}

func (m *Edge) GetStatus() LinkStatus {
	if m != nil {
		return m.Status
	}
	return LINK_STATUS_NOT_APPLICABLE
}

func init() {
	proto.RegisterEnum("ves.io.schema.topology.MetricType", MetricType_name, MetricType_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.MetricType", MetricType_name, MetricType_value)
	proto.RegisterEnum("ves.io.schema.topology.LinkType", LinkType_name, LinkType_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.LinkType", LinkType_name, LinkType_value)
	proto.RegisterEnum("ves.io.schema.topology.LinkStatus", LinkStatus_name, LinkStatus_value)
	golang_proto.RegisterEnum("ves.io.schema.topology.LinkStatus", LinkStatus_name, LinkStatus_value)
	proto.RegisterType((*SiteTopologyRequest)(nil), "ves.io.schema.topology.SiteTopologyRequest")
	golang_proto.RegisterType((*SiteTopologyRequest)(nil), "ves.io.schema.topology.SiteTopologyRequest")
	proto.RegisterType((*SiteMeshGroupsSummaryRequest)(nil), "ves.io.schema.topology.SiteMeshGroupsSummaryRequest")
	golang_proto.RegisterType((*SiteMeshGroupsSummaryRequest)(nil), "ves.io.schema.topology.SiteMeshGroupsSummaryRequest")
	proto.RegisterType((*SiteMeshTopologyRequest)(nil), "ves.io.schema.topology.SiteMeshTopologyRequest")
	golang_proto.RegisterType((*SiteMeshTopologyRequest)(nil), "ves.io.schema.topology.SiteMeshTopologyRequest")
	proto.RegisterType((*DCClusterGroupsSummaryRequest)(nil), "ves.io.schema.topology.DCClusterGroupsSummaryRequest")
	golang_proto.RegisterType((*DCClusterGroupsSummaryRequest)(nil), "ves.io.schema.topology.DCClusterGroupsSummaryRequest")
	proto.RegisterType((*DCClusterTopologyRequest)(nil), "ves.io.schema.topology.DCClusterTopologyRequest")
	golang_proto.RegisterType((*DCClusterTopologyRequest)(nil), "ves.io.schema.topology.DCClusterTopologyRequest")
	proto.RegisterType((*TopologyResponse)(nil), "ves.io.schema.topology.TopologyResponse")
	golang_proto.RegisterType((*TopologyResponse)(nil), "ves.io.schema.topology.TopologyResponse")
	proto.RegisterType((*RouteTableRequest)(nil), "ves.io.schema.topology.RouteTableRequest")
	golang_proto.RegisterType((*RouteTableRequest)(nil), "ves.io.schema.topology.RouteTableRequest")
	proto.RegisterType((*RouteTableResponse)(nil), "ves.io.schema.topology.RouteTableResponse")
	golang_proto.RegisterType((*RouteTableResponse)(nil), "ves.io.schema.topology.RouteTableResponse")
	proto.RegisterType((*MetricSelector)(nil), "ves.io.schema.topology.MetricSelector")
	golang_proto.RegisterType((*MetricSelector)(nil), "ves.io.schema.topology.MetricSelector")
	proto.RegisterType((*MetricTypeData)(nil), "ves.io.schema.topology.MetricTypeData")
	golang_proto.RegisterType((*MetricTypeData)(nil), "ves.io.schema.topology.MetricTypeData")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.topology.MetricTypeData.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.topology.MetricTypeData.LabelsEntry")
	proto.RegisterType((*MetricData)(nil), "ves.io.schema.topology.MetricData")
	golang_proto.RegisterType((*MetricData)(nil), "ves.io.schema.topology.MetricData")
	proto.RegisterType((*RouteTableMetaData)(nil), "ves.io.schema.topology.RouteTableMetaData")
	golang_proto.RegisterType((*RouteTableMetaData)(nil), "ves.io.schema.topology.RouteTableMetaData")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.topology.RouteTableMetaData.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.topology.RouteTableMetaData.TagsEntry")
	proto.RegisterType((*SiteSummaryInfo)(nil), "ves.io.schema.topology.SiteSummaryInfo")
	golang_proto.RegisterType((*SiteSummaryInfo)(nil), "ves.io.schema.topology.SiteSummaryInfo")
	proto.RegisterType((*NetworkSummaryInfo)(nil), "ves.io.schema.topology.NetworkSummaryInfo")
	golang_proto.RegisterType((*NetworkSummaryInfo)(nil), "ves.io.schema.topology.NetworkSummaryInfo")
	proto.RegisterType((*SubnetSummaryInfo)(nil), "ves.io.schema.topology.SubnetSummaryInfo")
	golang_proto.RegisterType((*SubnetSummaryInfo)(nil), "ves.io.schema.topology.SubnetSummaryInfo")
	proto.RegisterType((*NodeTypeSite)(nil), "ves.io.schema.topology.NodeTypeSite")
	golang_proto.RegisterType((*NodeTypeSite)(nil), "ves.io.schema.topology.NodeTypeSite")
	proto.RegisterType((*SiteMeshGroupSummaryInfo)(nil), "ves.io.schema.topology.SiteMeshGroupSummaryInfo")
	golang_proto.RegisterType((*SiteMeshGroupSummaryInfo)(nil), "ves.io.schema.topology.SiteMeshGroupSummaryInfo")
	proto.RegisterType((*NodeTypeSiteMeshGroup)(nil), "ves.io.schema.topology.NodeTypeSiteMeshGroup")
	golang_proto.RegisterType((*NodeTypeSiteMeshGroup)(nil), "ves.io.schema.topology.NodeTypeSiteMeshGroup")
	proto.RegisterType((*DCClusterGroupSummaryInfo)(nil), "ves.io.schema.topology.DCClusterGroupSummaryInfo")
	golang_proto.RegisterType((*DCClusterGroupSummaryInfo)(nil), "ves.io.schema.topology.DCClusterGroupSummaryInfo")
	proto.RegisterType((*NodeTypeDCClusterGroup)(nil), "ves.io.schema.topology.NodeTypeDCClusterGroup")
	golang_proto.RegisterType((*NodeTypeDCClusterGroup)(nil), "ves.io.schema.topology.NodeTypeDCClusterGroup")
	proto.RegisterType((*NodeTypeTransitGateway)(nil), "ves.io.schema.topology.NodeTypeTransitGateway")
	golang_proto.RegisterType((*NodeTypeTransitGateway)(nil), "ves.io.schema.topology.NodeTypeTransitGateway")
	proto.RegisterType((*NodeTypeNetwork)(nil), "ves.io.schema.topology.NodeTypeNetwork")
	golang_proto.RegisterType((*NodeTypeNetwork)(nil), "ves.io.schema.topology.NodeTypeNetwork")
	proto.RegisterType((*NodeTypeSubnet)(nil), "ves.io.schema.topology.NodeTypeSubnet")
	golang_proto.RegisterType((*NodeTypeSubnet)(nil), "ves.io.schema.topology.NodeTypeSubnet")
	proto.RegisterType((*NodeTypeInstance)(nil), "ves.io.schema.topology.NodeTypeInstance")
	golang_proto.RegisterType((*NodeTypeInstance)(nil), "ves.io.schema.topology.NodeTypeInstance")
	proto.RegisterType((*NodeMetaData)(nil), "ves.io.schema.topology.NodeMetaData")
	golang_proto.RegisterType((*NodeMetaData)(nil), "ves.io.schema.topology.NodeMetaData")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.topology.NodeMetaData.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.topology.NodeMetaData.TagsEntry")
	proto.RegisterType((*Node)(nil), "ves.io.schema.topology.Node")
	golang_proto.RegisterType((*Node)(nil), "ves.io.schema.topology.Node")
	proto.RegisterType((*LinkInfo)(nil), "ves.io.schema.topology.LinkInfo")
	golang_proto.RegisterType((*LinkInfo)(nil), "ves.io.schema.topology.LinkInfo")
	proto.RegisterType((*LinkInfoSummary)(nil), "ves.io.schema.topology.LinkInfoSummary")
	golang_proto.RegisterType((*LinkInfoSummary)(nil), "ves.io.schema.topology.LinkInfoSummary")
	proto.RegisterType((*LinkTypeData)(nil), "ves.io.schema.topology.LinkTypeData")
	golang_proto.RegisterType((*LinkTypeData)(nil), "ves.io.schema.topology.LinkTypeData")
	proto.RegisterType((*EdgeInfoSummary)(nil), "ves.io.schema.topology.EdgeInfoSummary")
	golang_proto.RegisterType((*EdgeInfoSummary)(nil), "ves.io.schema.topology.EdgeInfoSummary")
	proto.RegisterType((*Edge)(nil), "ves.io.schema.topology.Edge")
	golang_proto.RegisterType((*Edge)(nil), "ves.io.schema.topology.Edge")
}

func init() {
	proto.RegisterFile("ves.io/schema/topology/public_custom_data_api.proto", fileDescriptor_a69fe73d473fc687)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/topology/public_custom_data_api.proto", fileDescriptor_a69fe73d473fc687)
}

var fileDescriptor_a69fe73d473fc687 = []byte{
	// 2584 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x5a, 0x5d, 0x6c, 0x23, 0x57,
	0xf5, 0xf7, 0xf5, 0x57, 0x92, 0x93, 0x6c, 0x32, 0xb9, 0xfb, 0xe5, 0x4d, 0x77, 0x5d, 0xff, 0xfd,
	0xef, 0x47, 0x36, 0xdb, 0xd8, 0xdd, 0xec, 0x6e, 0xb7, 0x44, 0x2a, 0xaa, 0xe3, 0xb8, 0x89, 0x1b,
	0xc7, 0xb6, 0xc6, 0x13, 0x56, 0x5b, 0x09, 0x8d, 0x26, 0x33, 0x77, 0xbd, 0xc3, 0xda, 0x33, 0x66,
	0xe6, 0x3a, 0xdb, 0xb4, 0x14, 0x55, 0x15, 0xaa, 0x50, 0x85, 0x50, 0x55, 0x40, 0x50, 0x9e, 0x10,
	0x12, 0x12, 0x2f, 0x3c, 0xc1, 0x13, 0x45, 0xa8, 0x12, 0x42, 0x80, 0x40, 0x68, 0x05, 0x2f, 0x7d,
	0xec, 0x66, 0x2b, 0x04, 0x6f, 0xe5, 0x01, 0x89, 0x47, 0x74, 0xef, 0xcc, 0xd8, 0x33, 0xb3, 0x8e,
	0xed, 0x84, 0xf0, 0x12, 0xf9, 0xde, 0xfb, 0x3b, 0xe7, 0x9e, 0xef, 0x7b, 0xee, 0x9d, 0xc0, 0xb5,
	0x3d, 0x62, 0xe7, 0x74, 0x33, 0x6f, 0xab, 0x77, 0x49, 0x5b, 0xc9, 0x53, 0xb3, 0x63, 0xb6, 0xcc,
	0xe6, 0x7e, 0xbe, 0xd3, 0xdd, 0x6d, 0xe9, 0xaa, 0xac, 0x76, 0x6d, 0x6a, 0xb6, 0x65, 0x4d, 0xa1,
	0x8a, 0xac, 0x74, 0xf4, 0x5c, 0xc7, 0x32, 0xa9, 0x89, 0xcf, 0x39, 0x44, 0x39, 0x87, 0x28, 0xe7,
	0x11, 0x2d, 0x2c, 0x37, 0x75, 0x7a, 0xb7, 0xbb, 0x9b, 0x53, 0xcd, 0x76, 0xbe, 0x69, 0x36, 0xcd,
	0x3c, 0x87, 0xef, 0x76, 0xef, 0xf0, 0x11, 0x1f, 0xf0, 0x5f, 0x0e, 0x9b, 0x85, 0x8b, 0x4d, 0xd3,
	0x6c, 0xb6, 0x48, 0x5e, 0xe9, 0xe8, 0x79, 0xc5, 0x30, 0x4c, 0xaa, 0x50, 0xdd, 0x34, 0x6c, 0x77,
	0xf5, 0x89, 0xa0, 0x64, 0x66, 0xc7, 0xbf, 0x98, 0x3d, 0x44, 0x6c, 0xba, 0xdf, 0x21, 0x1e, 0xe6,
	0x42, 0x08, 0xe3, 0x5b, 0xba, 0x18, 0x5c, 0xda, 0x53, 0x5a, 0xba, 0xa6, 0x50, 0x32, 0x98, 0xf9,
	0x1e, 0xb1, 0x89, 0xb1, 0x17, 0x12, 0x20, 0x13, 0xc2, 0xe8, 0xe4, 0xbe, 0x1c, 0x40, 0x64, 0x3f,
	0x8c, 0xc2, 0xe9, 0x86, 0x4e, 0x89, 0xe4, 0xca, 0x26, 0x92, 0xaf, 0x76, 0x89, 0x4d, 0x31, 0x86,
	0xb8, 0xad, 0x53, 0x92, 0x8a, 0x66, 0xd0, 0xe2, 0x94, 0xc8, 0x7f, 0xe3, 0xf3, 0x30, 0x61, 0x98,
	0x1a, 0x91, 0x75, 0x2d, 0x15, 0xe3, 0xd3, 0x49, 0x36, 0x2c, 0x6b, 0xf8, 0x0c, 0x24, 0x5a, 0x64,
	0x8f, 0xb4, 0x52, 0xf1, 0x0c, 0x5a, 0x4c, 0x88, 0xce, 0x00, 0xdf, 0x80, 0xb3, 0x4d, 0xcb, 0xec,
	0x76, 0x64, 0x46, 0x2c, 0xb7, 0x89, 0x7d, 0x57, 0x66, 0x78, 0x3b, 0x95, 0xc8, 0xa0, 0xc5, 0xc9,
	0xb5, 0x68, 0x0a, 0x89, 0x98, 0x03, 0xd8, 0xfe, 0xdb, 0xc4, 0xbe, 0x5b, 0x65, 0xab, 0xf8, 0x26,
	0x9c, 0x73, 0xc8, 0x34, 0x55, 0x56, 0x5b, 0x5d, 0x9b, 0x12, 0xcb, 0xa5, 0x4b, 0xf6, 0xe8, 0x4e,
	0x73, 0xc4, 0xba, 0x5a, 0x74, 0xd6, 0x1d, 0xc2, 0x1a, 0xcc, 0xb5, 0x09, 0xb5, 0x74, 0x55, 0xb6,
	0x49, 0x8b, 0xa8, 0xd4, 0xb4, 0x52, 0x13, 0x19, 0xb4, 0x38, 0xbd, 0xf2, 0x4c, 0x6e, 0x70, 0x24,
	0xe4, 0xb6, 0x39, 0xbc, 0xe1, 0xa2, 0xc5, 0xd9, 0x76, 0x60, 0x9c, 0x4d, 0xc3, 0x45, 0x4f, 0xb4,
	0x0d, 0xb6, 0x9f, 0xdd, 0xe8, 0xb6, 0xdb, 0x8a, 0xe5, 0xd9, 0x28, 0xfb, 0x01, 0x82, 0xf3, 0x1e,
	0x20, 0x6c, 0xbf, 0x67, 0x60, 0xae, 0xaf, 0x36, 0x97, 0xd6, 0x35, 0xe5, 0x29, 0xdb, 0xcf, 0x72,
	0x90, 0xd0, 0xb1, 0xff, 0x4a, 0xe8, 0x27, 0xe1, 0xd2, 0x7a, 0xd1, 0xb5, 0xcb, 0x40, 0xa9, 0xbf,
	0x87, 0x20, 0xd5, 0x43, 0x84, 0xc5, 0x5e, 0x04, 0xc1, 0x67, 0x76, 0xbf, 0xdc, 0xb3, 0x9a, 0xea,
	0xe7, 0x7a, 0xf2, 0x82, 0xff, 0x10, 0x81, 0xd0, 0x17, 0xc7, 0xee, 0x98, 0x86, 0x4d, 0xf0, 0x0a,
	0x24, 0x1c, 0xdf, 0xa3, 0x4c, 0x6c, 0x71, 0x7a, 0xe5, 0xe2, 0x61, 0xbc, 0x59, 0x04, 0x88, 0x0e,
	0x94, 0xd1, 0x10, 0xad, 0x49, 0xec, 0x54, 0x74, 0x38, 0x4d, 0x49, 0x6b, 0x12, 0xd1, 0x81, 0xe2,
	0x34, 0xc4, 0x6d, 0x4a, 0x3a, 0x4e, 0x5c, 0xaf, 0xc1, 0x2f, 0xff, 0xf1, 0x71, 0x2c, 0x61, 0xc5,
	0x3e, 0x8f, 0x22, 0x91, 0xcf, 0x67, 0x9f, 0x85, 0x79, 0xd1, 0xec, 0x52, 0x22, 0x29, 0xbb, 0x2d,
	0xe2, 0xcb, 0x11, 0x43, 0x69, 0x93, 0x14, 0x72, 0x72, 0x84, 0xfd, 0xce, 0xfe, 0x04, 0x01, 0xf6,
	0x23, 0x5d, 0x3d, 0x5e, 0x81, 0xc9, 0x36, 0xa1, 0x0a, 0xab, 0x50, 0x1c, 0x3e, 0xbd, 0xb2, 0x74,
	0x98, 0x58, 0x7d, 0xea, 0x6d, 0x42, 0x95, 0x75, 0x85, 0x2a, 0x62, 0x8f, 0x16, 0x6f, 0xc0, 0xb4,
	0xc5, 0xd6, 0x65, 0xca, 0x00, 0xdc, 0x35, 0x43, 0x2c, 0xde, 0x67, 0x25, 0xed, 0x77, 0x88, 0x08,
	0x56, 0x6f, 0x9c, 0x7d, 0x2f, 0x0a, 0xb3, 0x41, 0x87, 0xe0, 0xcb, 0x00, 0x36, 0x55, 0x2c, 0x2a,
	0x53, 0xdd, 0x53, 0xaa, 0x67, 0x89, 0x1f, 0xc4, 0x91, 0x38, 0xc5, 0x57, 0x25, 0xbd, 0x4d, 0xf0,
	0xd3, 0x30, 0x49, 0x0c, 0xcd, 0x01, 0x46, 0x1f, 0x03, 0x4e, 0x10, 0x43, 0xe3, 0xb0, 0x35, 0x88,
	0x33, 0x97, 0xa4, 0x62, 0x99, 0xd8, 0xe2, 0xec, 0x4a, 0x76, 0x78, 0x60, 0x30, 0x11, 0x5d, 0x36,
	0x1f, 0x20, 0x96, 0xe4, 0x9c, 0x96, 0xf1, 0x60, 0x2e, 0x4a, 0xc5, 0x8f, 0xc7, 0x83, 0xd1, 0xf6,
	0xbc, 0x9b, 0x08, 0x88, 0xfa, 0xa3, 0xb8, 0xe7, 0xdd, 0x3f, 0x22, 0xcf, 0x18, 0x8c, 0x01, 0x33,
	0x39, 0x7e, 0x15, 0x92, 0x2d, 0x65, 0x97, 0xb4, 0xbc, 0xc8, 0x5b, 0x19, 0xbd, 0x31, 0xa3, 0xcb,
	0x55, 0x38, 0x51, 0xc9, 0xa0, 0xd6, 0xbe, 0xe8, 0x72, 0xc0, 0x2b, 0x90, 0xdc, 0x53, 0x5a, 0xdd,
	0x5e, 0x44, 0x2e, 0x84, 0x78, 0x39, 0x2c, 0xbe, 0xc4, 0x20, 0xa2, 0x8b, 0x5c, 0xf8, 0x02, 0x4c,
	0xfb, 0x58, 0x61, 0x01, 0x62, 0xf7, 0xc8, 0xbe, 0x1b, 0x69, 0xec, 0x27, 0xab, 0xb9, 0x1c, 0xea,
	0xa6, 0xa7, 0x33, 0x58, 0x8d, 0xbe, 0x88, 0xb2, 0x3f, 0x43, 0x00, 0x0e, 0x4b, 0xae, 0xc9, 0x0b,
	0x10, 0x67, 0x87, 0x0a, 0xa7, 0x1d, 0xcb, 0x80, 0x22, 0xc7, 0xe3, 0x2b, 0x10, 0xef, 0x1a, 0x3a,
	0xe5, 0x29, 0x31, 0xbb, 0x72, 0x3e, 0x44, 0xb7, 0x63, 0xe8, 0xd4, 0x01, 0x33, 0x10, 0x5e, 0x85,
	0x38, 0x8f, 0x6d, 0x47, 0xc1, 0x67, 0xc6, 0x33, 0x96, 0xc8, 0x69, 0xb2, 0x9f, 0x05, 0x52, 0xc6,
	0x0b, 0xfa, 0x41, 0xd9, 0x85, 0x77, 0x20, 0x4e, 0x95, 0xa6, 0x67, 0xc7, 0xeb, 0xe3, 0xa7, 0x50,
	0x4e, 0x52, 0x9a, 0x8e, 0x29, 0xd7, 0xa6, 0x0f, 0x3e, 0xfd, 0x6d, 0x2c, 0xf9, 0xde, 0xaf, 0x50,
	0x74, 0x32, 0x22, 0x72, 0x76, 0x78, 0x09, 0xe6, 0xd5, 0x96, 0xd9, 0xd5, 0x64, 0x8b, 0xd8, 0x66,
	0xd7, 0x52, 0x7d, 0x47, 0xdc, 0x1c, 0x5f, 0x10, 0xdd, 0xf9, 0xb2, 0xb6, 0x70, 0x13, 0xa6, 0x7a,
	0xbc, 0x8e, 0xe4, 0x96, 0x2f, 0xc3, 0x1c, 0x3b, 0x2c, 0xdc, 0x6a, 0x5c, 0x36, 0xee, 0x98, 0xf8,
	0x12, 0x00, 0x3f, 0x50, 0x55, 0xb3, 0x6b, 0x50, 0xce, 0xe5, 0x94, 0x38, 0xc5, 0x66, 0x8a, 0x6c,
	0x02, 0x5f, 0x81, 0x79, 0x65, 0x4f, 0xd1, 0x5b, 0xca, 0xae, 0xde, 0xd2, 0xe9, 0xbe, 0xfc, 0x86,
	0x69, 0x10, 0xae, 0xfa, 0x94, 0x28, 0xf8, 0x17, 0x5e, 0x33, 0x0d, 0x92, 0x55, 0x01, 0x57, 0x09,
	0xbd, 0x6f, 0x5a, 0xf7, 0xfc, 0x3b, 0x6c, 0xc3, 0x8c, 0xaf, 0x5e, 0x78, 0xc1, 0x7c, 0x94, 0xda,
	0x33, 0xdd, 0x2f, 0x1a, 0x76, 0x76, 0x17, 0xe6, 0x1b, 0xdd, 0x5d, 0x83, 0xd0, 0xff, 0xe1, 0x1e,
	0xbf, 0x41, 0x30, 0xc3, 0xca, 0x39, 0x8b, 0x12, 0x66, 0x30, 0x7c, 0x1d, 0xe2, 0xba, 0x71, 0xc7,
	0x74, 0xeb, 0x66, 0xe6, 0x30, 0xbe, 0xbc, 0x8b, 0xe1, 0x11, 0xc9, 0xd0, 0x78, 0x15, 0x92, 0xce,
	0x01, 0xe3, 0x06, 0xcb, 0x88, 0xc0, 0xe7, 0x72, 0xb8, 0x14, 0xb8, 0x00, 0x13, 0xb6, 0xa3, 0xa0,
	0x7b, 0xa6, 0x3d, 0x3b, 0x6c, 0x53, 0x9f, 0x2d, 0x44, 0x8f, 0x2e, 0xfb, 0xf3, 0x28, 0xa4, 0x02,
	0xcd, 0x83, 0xdf, 0x62, 0x67, 0x20, 0xc1, 0xba, 0x00, 0xdb, 0x75, 0xb9, 0x33, 0xc0, 0x35, 0x78,
	0xda, 0xa4, 0x77, 0x89, 0x25, 0xab, 0xa6, 0x61, 0x10, 0x95, 0x12, 0x4d, 0x0e, 0xb5, 0x10, 0xb2,
	0x43, 0x15, 0xe5, 0x54, 0x19, 0x0e, 0x2e, 0x7a, 0xd8, 0xe0, 0x66, 0x9c, 0xe1, 0x2d, 0x38, 0xdd,
	0xd2, 0x8d, 0x7b, 0xb2, 0x4d, 0x15, 0xda, 0xb5, 0xe5, 0xbe, 0x4a, 0xb1, 0x61, 0x2a, 0x55, 0x74,
	0xe3, 0x1e, 0x93, 0xd2, 0x6b, 0x1b, 0xe6, 0x19, 0x8f, 0x06, 0x67, 0xe1, 0x4e, 0x31, 0xc6, 0xac,
	0xae, 0x86, 0x19, 0xc7, 0x87, 0x33, 0x66, 0xe7, 0x6d, 0x80, 0x31, 0xe3, 0x11, 0x60, 0x9c, 0xfd,
	0x31, 0x82, 0xb3, 0x7e, 0xdf, 0xf7, 0xfb, 0xa4, 0x97, 0x02, 0x41, 0x70, 0x79, 0x98, 0x3f, 0x7a,
	0x44, 0xbe, 0x68, 0x78, 0xb5, 0xef, 0x51, 0xe7, 0xcc, 0x7c, 0x7e, 0x2c, 0x0e, 0x03, 0x5d, 0x7b,
	0x15, 0x2e, 0x04, 0x3b, 0xac, 0x91, 0xae, 0x65, 0x5d, 0xc1, 0x39, 0x4f, 0xaf, 0x20, 0x2d, 0xfe,
	0x62, 0x40, 0xb1, 0x43, 0xb3, 0x26, 0x48, 0xe5, 0xd3, 0x6c, 0x2b, 0xac, 0xd9, 0xd5, 0xf1, 0x58,
	0x0c, 0x54, 0xed, 0xbb, 0x3e, 0x39, 0x25, 0x4b, 0x31, 0x6c, 0x9d, 0x6e, 0x28, 0x94, 0xdc, 0x57,
	0xf6, 0xc7, 0x95, 0x33, 0x48, 0x75, 0x32, 0xf9, 0x98, 0xfd, 0x13, 0x82, 0x39, 0x4f, 0x2c, 0xb7,
	0xc8, 0xe1, 0x9b, 0x01, 0x79, 0xfe, 0xff, 0xd0, 0xc6, 0xd0, 0x81, 0x9f, 0x50, 0x61, 0x58, 0x0f,
	0x17, 0x86, 0xa5, 0x11, 0xfb, 0x0e, 0xb4, 0xf2, 0x1f, 0x10, 0xcc, 0xf6, 0xa2, 0x9c, 0x97, 0x53,
	0x76, 0x48, 0xfb, 0xb4, 0x39, 0x54, 0x24, 0x07, 0x7d, 0x42, 0xca, 0x14, 0xc3, 0xca, 0x5c, 0x1e,
	0xbe, 0xed, 0x40, 0x5d, 0xbe, 0x89, 0x40, 0xf0, 0x74, 0x29, 0x1b, 0x36, 0x55, 0x0c, 0x95, 0xe0,
	0x17, 0x03, 0xda, 0x3c, 0x75, 0x18, 0x5b, 0x0f, 0x7f, 0x42, 0x51, 0xf2, 0xed, 0x98, 0x73, 0x70,
	0x0c, 0xed, 0x20, 0x06, 0x1e, 0xf5, 0x93, 0x03, 0x8f, 0x7a, 0x9c, 0x81, 0x69, 0x8d, 0xd8, 0xaa,
	0xa5, 0xf3, 0x1b, 0xb3, 0x7b, 0xa2, 0xfb, 0xa7, 0xfa, 0x17, 0xdf, 0x98, 0x93, 0xed, 0xce, 0xc5,
	0xb7, 0x0c, 0xa7, 0x3a, 0x96, 0xb9, 0xa7, 0x6b, 0xc4, 0x92, 0x79, 0xeb, 0x15, 0xe7, 0x2d, 0xd4,
	0xa1, 0x76, 0xa8, 0xbb, 0x60, 0x6e, 0x87, 0x99, 0x8e, 0x6f, 0x84, 0x2f, 0xc0, 0xa4, 0x79, 0xdf,
	0x20, 0x16, 0x93, 0x92, 0x77, 0xaf, 0xe2, 0x04, 0x1f, 0x97, 0x35, 0x5c, 0x73, 0x7b, 0xa1, 0x24,
	0x37, 0x54, 0x6e, 0xd8, 0xcd, 0x68, 0xbc, 0x2e, 0xe8, 0x1c, 0x24, 0x9d, 0x82, 0xce, 0xaf, 0xcd,
	0x53, 0xa2, 0x3b, 0x3a, 0x7e, 0xc7, 0xf3, 0xad, 0x04, 0xc4, 0xd9, 0xf6, 0x78, 0x16, 0xa2, 0xba,
	0xe6, 0xd2, 0x44, 0x75, 0x0d, 0xbf, 0xec, 0xbb, 0x0d, 0x45, 0x87, 0xc7, 0x88, 0x5f, 0x7c, 0xdf,
	0x3d, 0x68, 0xd5, 0x7d, 0x9e, 0x88, 0x8f, 0xa6, 0xf6, 0xce, 0x92, 0xcd, 0x88, 0xfb, 0x8c, 0x71,
	0x1b, 0xe6, 0xa8, 0x53, 0xa5, 0xe4, 0xa6, 0x53, 0xa6, 0xb8, 0x69, 0x47, 0xd8, 0xf0, 0xf1, 0x92,
	0xb8, 0x19, 0x11, 0x67, 0x69, 0xb0, 0x48, 0x16, 0x61, 0xc2, 0x70, 0x12, 0x9f, 0x3f, 0x56, 0x0c,
	0x39, 0x0c, 0x43, 0xe5, 0x6c, 0x33, 0x22, 0x7a, 0x94, 0xf8, 0x65, 0x48, 0xda, 0x3c, 0xe1, 0x46,
	0x3d, 0x5f, 0x04, 0x6b, 0xc8, 0x66, 0x44, 0x74, 0xe9, 0xd8, 0x6d, 0x53, 0x77, 0x73, 0x8b, 0xc7,
	0xf6, 0xf4, 0xca, 0xe2, 0x28, 0x1e, 0x5e, 0x2e, 0x6e, 0x46, 0xc4, 0x1e, 0x2d, 0xbe, 0xf5, 0xf8,
	0x23, 0xc6, 0x14, 0x67, 0xb7, 0x3c, 0x8e, 0xc1, 0x7b, 0xa7, 0xe8, 0x66, 0x24, 0xfc, 0xea, 0xf1,
	0xda, 0x80, 0x67, 0x06, 0x18, 0xcf, 0x07, 0xc1, 0x53, 0x8c, 0xf9, 0x20, 0xf8, 0x30, 0xb1, 0x36,
	0x0f, 0xbc, 0x85, 0xe6, 0x99, 0x87, 0xe3, 0x0f, 0x3e, 0x42, 0xb1, 0x57, 0xe3, 0x93, 0x31, 0x21,
	0x9e, 0xfd, 0x35, 0x82, 0x49, 0xaf, 0xb9, 0x19, 0x58, 0x1b, 0xae, 0xbb, 0x37, 0xa5, 0x28, 0x4f,
	0xd7, 0xcc, 0xb0, 0x06, 0xc9, 0x77, 0x4f, 0x5a, 0xed, 0xa5, 0x4d, 0x6c, 0xf8, 0x0d, 0xab, 0xd2,
	0xeb, 0xa3, 0xbc, 0xd4, 0xc2, 0x67, 0x21, 0x69, 0x5b, 0x2a, 0x4b, 0xee, 0xb8, 0x93, 0x3c, 0xb6,
	0xa5, 0x96, 0x35, 0x36, 0xad, 0xd9, 0xb4, 0x9f, 0xf3, 0x09, 0xcd, 0xa6, 0x65, 0x2d, 0xfb, 0x21,
	0x82, 0xb9, 0x50, 0x77, 0xd6, 0x93, 0x19, 0x1d, 0x53, 0xe6, 0xe8, 0x91, 0x65, 0x3e, 0x03, 0x09,
	0xe7, 0xbe, 0xe2, 0xd6, 0x3c, 0x3e, 0xc8, 0xbe, 0x8d, 0x60, 0xc6, 0xdb, 0x84, 0x17, 0xdf, 0x31,
	0xbb, 0x76, 0x4f, 0x9f, 0x13, 0xa8, 0xff, 0x2a, 0xcc, 0x85, 0x5a, 0x4c, 0x9f, 0x9e, 0xe8, 0xf8,
	0x7a, 0x46, 0xfd, 0x7a, 0xfe, 0x02, 0x41, 0x9c, 0xed, 0xc2, 0x2a, 0xb3, 0xfb, 0x18, 0x7a, 0xd5,
	0x0d, 0xa2, 0x09, 0xe7, 0x35, 0xf4, 0xaa, 0x6f, 0x69, 0xc5, 0x2d, 0x8a, 0xee, 0xd2, 0x0a, 0x5e,
	0x85, 0x04, 0x6b, 0xa7, 0x6d, 0xb7, 0x09, 0x7f, 0x6a, 0x94, 0xbf, 0xb8, 0x82, 0x0e, 0x89, 0x4f,
	0x99, 0xf8, 0x51, 0x95, 0x59, 0xfa, 0x7e, 0xcc, 0x7b, 0x13, 0xe0, 0xc7, 0x4a, 0x0a, 0xce, 0x6c,
	0x97, 0x24, 0xb1, 0x5c, 0x94, 0xa5, 0xdb, 0xf5, 0x92, 0x5c, 0xae, 0xca, 0x6b, 0xb7, 0xa5, 0x52,
	0x43, 0x88, 0xe0, 0x0b, 0x70, 0xd6, 0xbf, 0x52, 0xdb, 0x91, 0xdc, 0x25, 0x84, 0x9f, 0x84, 0x27,
	0x42, 0x44, 0xeb, 0x62, 0xad, 0x2e, 0xd7, 0x0b, 0xc5, 0xad, 0x92, 0xd4, 0x10, 0xa2, 0x38, 0x03,
	0x17, 0xc3, 0xb4, 0x01, 0x44, 0x0c, 0x3f, 0x05, 0x19, 0x3f, 0x42, 0x2c, 0x15, 0x8a, 0x9b, 0x85,
	0xb5, 0x72, 0xa5, 0x2c, 0xdd, 0x96, 0xeb, 0x25, 0xb1, 0x58, 0xaa, 0x4a, 0x42, 0x3c, 0xbc, 0x51,
	0xa5, 0x20, 0x95, 0xaa, 0xc5, 0xdb, 0x72, 0xa3, 0x54, 0xac, 0x55, 0xd7, 0x1b, 0x42, 0x02, 0xff,
	0x1f, 0x5c, 0xf2, 0x03, 0x8a, 0xf5, 0x1d, 0x79, 0xa7, 0x51, 0xd8, 0x28, 0xf5, 0x78, 0x24, 0xc3,
	0x3b, 0x6d, 0x97, 0xb6, 0x6b, 0xe2, 0xed, 0x10, 0x6a, 0x02, 0x67, 0x21, 0xed, 0x47, 0xad, 0x97,
	0x1b, 0x5b, 0x21, 0xcc, 0x24, 0x7e, 0x0e, 0x16, 0x03, 0x98, 0x82, 0x54, 0x90, 0xeb, 0x95, 0x42,
	0xb5, 0x24, 0x17, 0x6b, 0xd5, 0x6a, 0xa9, 0x28, 0x95, 0x6b, 0x55, 0xb9, 0x21, 0x15, 0xa4, 0x9d,
	0x86, 0x30, 0x85, 0xf3, 0x70, 0x25, 0x20, 0x5a, 0xad, 0x2a, 0x89, 0xb5, 0xca, 0xa1, 0x04, 0xb0,
	0xf4, 0x4f, 0xb7, 0x2a, 0x71, 0xbf, 0x9c, 0x01, 0xa1, 0x52, 0xae, 0x6e, 0x39, 0xb4, 0xd2, 0x4e,
	0xb5, 0x5a, 0xaa, 0x08, 0x11, 0x7c, 0x16, 0xe6, 0xfb, 0xb3, 0xd5, 0x92, 0x74, 0xab, 0x26, 0x6e,
	0x09, 0x28, 0x08, 0x6e, 0xec, 0xac, 0x55, 0x4b, 0x92, 0x10, 0xc5, 0xe7, 0x00, 0xf7, 0x67, 0xcb,
	0xd5, 0x86, 0x54, 0xa8, 0x16, 0x4b, 0x42, 0x0c, 0x5f, 0x82, 0x0b, 0x3e, 0x74, 0x59, 0x62, 0x36,
	0x69, 0x6c, 0xca, 0x1b, 0x62, 0x6d, 0xa7, 0x2e, 0xc4, 0x71, 0x1a, 0x16, 0xfa, 0xcb, 0xeb, 0x45,
	0xb9, 0x58, 0xd9, 0x69, 0x48, 0x25, 0xd1, 0x5d, 0x4f, 0x60, 0x01, 0x66, 0xfa, 0xeb, 0x95, 0x6b,
	0x42, 0x12, 0x3f, 0x01, 0xe7, 0xfb, 0x33, 0x01, 0x3d, 0x85, 0x09, 0x7c, 0x11, 0x52, 0xfd, 0xc5,
	0xb5, 0x8d, 0xba, 0x4f, 0x75, 0x61, 0x72, 0xc9, 0x04, 0xe8, 0xc7, 0x68, 0x6f, 0x6b, 0xc7, 0x24,
	0x72, 0xb5, 0x26, 0xc9, 0x85, 0x7a, 0xbd, 0x52, 0x2e, 0x16, 0xd6, 0x2a, 0x25, 0x21, 0x82, 0xcf,
	0xc3, 0x69, 0xff, 0xfa, 0x4e, 0x75, 0xab, 0x5a, 0xbb, 0x55, 0x15, 0x10, 0xc6, 0x30, 0x1b, 0x58,
	0xa8, 0x0b, 0xd1, 0x9e, 0x51, 0xdc, 0xb9, 0x75, 0x86, 0x8c, 0xad, 0xbc, 0x3b, 0x03, 0xa7, 0x8a,
	0xfc, 0x23, 0x11, 0x4b, 0xa8, 0x42, 0xbd, 0x8c, 0x1f, 0x22, 0x98, 0xf1, 0x7f, 0xf7, 0xc0, 0x57,
	0x86, 0xbe, 0x2b, 0x04, 0x9f, 0xc9, 0x17, 0x0e, 0x3d, 0x4e, 0xc3, 0x0f, 0xd8, 0xd9, 0x37, 0x0e,
	0x7e, 0x97, 0x7a, 0xe9, 0xce, 0x8d, 0xd7, 0xd5, 0x65, 0x76, 0x02, 0x2e, 0xb7, 0x15, 0x43, 0x69,
	0x92, 0x36, 0x31, 0xe8, 0xf2, 0xae, 0x62, 0xeb, 0xea, 0x72, 0xdb, 0x34, 0x74, 0x6a, 0x5a, 0xcf,
	0xed, 0x11, 0x7b, 0x59, 0x37, 0x97, 0x75, 0xe3, 0x8e, 0xa5, 0xd8, 0xd4, 0xea, 0xaa, 0xb4, 0x6b,
	0x91, 0x65, 0x8b, 0x28, 0xda, 0x3b, 0x7f, 0xfd, 0xec, 0x3b, 0xd1, 0x6b, 0xd9, 0x9c, 0xfb, 0xb1,
	0x2b, 0xcf, 0x8e, 0x2a, 0xbb, 0xa3, 0xa8, 0xc4, 0xce, 0xdb, 0xfb, 0x36, 0x25, 0xed, 0xfe, 0x77,
	0x25, 0xb6, 0x45, 0xfe, 0x4d, 0xf6, 0xf7, 0xad, 0x55, 0xb4, 0x84, 0xff, 0x85, 0xe0, 0xec, 0xc0,
	0x0f, 0x18, 0xf8, 0xfa, 0x58, 0xb7, 0xdf, 0xd0, 0x97, 0x83, 0x23, 0x68, 0xfd, 0xb5, 0x93, 0xd1,
	0xfa, 0x06, 0xbe, 0x36, 0xa6, 0xd6, 0xbe, 0x16, 0xc5, 0xc6, 0x6f, 0x47, 0x41, 0x08, 0x7f, 0x97,
	0xc1, 0xf9, 0x51, 0x2a, 0x1f, 0xdf, 0xc7, 0xef, 0xa3, 0x93, 0x51, 0xb7, 0x9c, 0x5d, 0x3f, 0xba,
	0xba, 0x8e, 0xbf, 0x7d, 0x13, 0xdc, 0xf5, 0xff, 0x46, 0x70, 0x6e, 0xf0, 0x67, 0x20, 0x7c, 0x63,
	0xbc, 0xf7, 0x81, 0xe3, 0x3b, 0xff, 0xad, 0x93, 0xb1, 0xc6, 0x0b, 0xf8, 0xfa, 0x18, 0xd6, 0x08,
	0xb7, 0x91, 0x36, 0xfe, 0x46, 0x14, 0xe6, 0x1f, 0xfb, 0xbe, 0x85, 0x9f, 0x1f, 0xa9, 0xf5, 0xf1,
	0xfd, 0xff, 0xc1, 0x09, 0xf9, 0x7f, 0x2b, 0xfb, 0xca, 0x31, 0x34, 0xce, 0xbf, 0x19, 0x9e, 0xe1,
	0x11, 0xf0, 0x37, 0x04, 0xa7, 0x36, 0x08, 0xed, 0xbf, 0xb6, 0xe2, 0xcb, 0xa3, 0x5f, 0x64, 0x3d,
	0xdd, 0x97, 0xc6, 0x81, 0xba, 0xda, 0x7f, 0xfd, 0x64, 0x94, 0xbf, 0x89, 0x6f, 0x8c, 0xa1, 0xbc,
	0xef, 0xa1, 0x39, 0xff, 0x26, 0xc3, 0xbd, 0xb5, 0x70, 0xe5, 0xe3, 0x8f, 0x50, 0xec, 0x2f, 0x1f,
	0xa1, 0x4b, 0x87, 0x88, 0x5c, 0xdb, 0xfd, 0x0a, 0x51, 0xe9, 0x3b, 0x7f, 0x4e, 0x45, 0x53, 0x68,
	0xed, 0x5d, 0xf4, 0xe0, 0x61, 0x3a, 0xf2, 0xc9, 0xc3, 0x74, 0xe4, 0xf3, 0x87, 0x69, 0xf4, 0xf6,
	0x41, 0x1a, 0xfd, 0xf4, 0x20, 0x8d, 0x7e, 0x7f, 0x90, 0x46, 0x0f, 0x0e, 0xd2, 0xe8, 0xd3, 0x83,
	0x34, 0xfa, 0xfb, 0x41, 0x3a, 0xf2, 0xf9, 0x41, 0x1a, 0xbd, 0xff, 0x28, 0x1d, 0xf9, 0xf8, 0x51,
	0x1a, 0x3d, 0x78, 0x94, 0x8e, 0x7c, 0xf2, 0x28, 0x1d, 0x79, 0xad, 0xd2, 0x34, 0x3b, 0xf7, 0x9a,
	0xb9, 0x3d, 0xb3, 0x45, 0x89, 0x65, 0x29, 0xb9, 0xae, 0x9d, 0xe7, 0x3f, 0xee, 0x98, 0x56, 0x7b,
	0xd9, 0xbb, 0xb4, 0x2f, 0x7b, 0xcb, 0xf9, 0xce, 0x6e, 0xd3, 0xcc, 0x93, 0xd7, 0xa9, 0xfb, 0xe9,
	0x3d, 0xf4, 0x2f, 0x00, 0xbb, 0x49, 0xfe, 0xf9, 0xfd, 0xda, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff,
	0x4b, 0x32, 0xe6, 0x05, 0xda, 0x20, 0x00, 0x00,
}

func (x MetricType) String() string {
	s, ok := MetricType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LinkType) String() string {
	s, ok := LinkType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LinkStatus) String() string {
	s, ok := LinkStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *SiteTopologyRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteTopologyRequest)
	if !ok {
		that2, ok := that.(SiteTopologyRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Site != that1.Site {
		return false
	}
	if this.NodeId != that1.NodeId {
		return false
	}
	if this.Level != that1.Level {
		return false
	}
	if this.GroupSiteMeshNodes != that1.GroupSiteMeshNodes {
		return false
	}
	if this.GroupDcClusterNodes != that1.GroupDcClusterNodes {
		return false
	}
	if !this.MetricSelector.Equal(that1.MetricSelector) {
		return false
	}
	return true
}
func (this *SiteMeshGroupsSummaryRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteMeshGroupsSummaryRequest)
	if !ok {
		that2, ok := that.(SiteMeshGroupsSummaryRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *SiteMeshTopologyRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteMeshTopologyRequest)
	if !ok {
		that2, ok := that.(SiteMeshTopologyRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SiteMeshGroup != that1.SiteMeshGroup {
		return false
	}
	if !this.MetricSelector.Equal(that1.MetricSelector) {
		return false
	}
	return true
}
func (this *DCClusterGroupsSummaryRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DCClusterGroupsSummaryRequest)
	if !ok {
		that2, ok := that.(DCClusterGroupsSummaryRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *DCClusterTopologyRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DCClusterTopologyRequest)
	if !ok {
		that2, ok := that.(DCClusterTopologyRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DcClusterGroup != that1.DcClusterGroup {
		return false
	}
	if !this.MetricSelector.Equal(that1.MetricSelector) {
		return false
	}
	return true
}
func (this *TopologyResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TopologyResponse)
	if !ok {
		that2, ok := that.(TopologyResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Nodes) != len(that1.Nodes) {
		return false
	}
	for i := range this.Nodes {
		if !this.Nodes[i].Equal(that1.Nodes[i]) {
			return false
		}
	}
	if len(this.Edges) != len(that1.Edges) {
		return false
	}
	for i := range this.Edges {
		if !this.Edges[i].Equal(that1.Edges[i]) {
			return false
		}
	}
	if this.Step != that1.Step {
		return false
	}
	return true
}
func (this *RouteTableRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteTableRequest)
	if !ok {
		that2, ok := that.(RouteTableRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *RouteTableResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteTableResponse)
	if !ok {
		that2, ok := that.(RouteTableResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if !this.RouteTable.Equal(that1.RouteTable) {
		return false
	}
	return true
}
func (this *MetricSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetricSelector)
	if !ok {
		that2, ok := that.(MetricSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if len(this.Node) != len(that1.Node) {
		return false
	}
	for i := range this.Node {
		if this.Node[i] != that1.Node[i] {
			return false
		}
	}
	if len(this.Edge) != len(that1.Edge) {
		return false
	}
	for i := range this.Edge {
		if this.Edge[i] != that1.Edge[i] {
			return false
		}
	}
	if this.Step != that1.Step {
		return false
	}
	return true
}
func (this *MetricTypeData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetricTypeData)
	if !ok {
		that2, ok := that.(MetricTypeData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if !this.Values[i].Equal(that1.Values[i]) {
			return false
		}
	}
	return true
}
func (this *MetricData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetricData)
	if !ok {
		that2, ok := that.(MetricData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Unit != that1.Unit {
		return false
	}
	if len(this.Data) != len(that1.Data) {
		return false
	}
	for i := range this.Data {
		if !this.Data[i].Equal(that1.Data[i]) {
			return false
		}
	}
	return true
}
func (this *RouteTableMetaData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteTableMetaData)
	if !ok {
		that2, ok := that.(RouteTableMetaData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if this.CloudResourceId != that1.CloudResourceId {
		return false
	}
	return true
}
func (this *SiteSummaryInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteSummaryInfo)
	if !ok {
		that2, ok := that.(SiteSummaryInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NodeCount != that1.NodeCount {
		return false
	}
	if len(this.AvailabilityZone) != len(that1.AvailabilityZone) {
		return false
	}
	for i := range this.AvailabilityZone {
		if this.AvailabilityZone[i] != that1.AvailabilityZone[i] {
			return false
		}
	}
	return true
}
func (this *NetworkSummaryInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkSummaryInfo)
	if !ok {
		that2, ok := that.(NetworkSummaryInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RouteTables) != len(that1.RouteTables) {
		return false
	}
	for i := range this.RouteTables {
		if !this.RouteTables[i].Equal(that1.RouteTables[i]) {
			return false
		}
	}
	return true
}
func (this *SubnetSummaryInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubnetSummaryInfo)
	if !ok {
		that2, ok := that.(SubnetSummaryInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RouteTables) != len(that1.RouteTables) {
		return false
	}
	for i := range this.RouteTables {
		if !this.RouteTables[i].Equal(that1.RouteTables[i]) {
			return false
		}
	}
	return true
}
func (this *NodeTypeSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeTypeSite)
	if !ok {
		that2, ok := that.(NodeTypeSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	if len(this.Metric) != len(that1.Metric) {
		return false
	}
	for i := range this.Metric {
		if !this.Metric[i].Equal(that1.Metric[i]) {
			return false
		}
	}
	if !this.Summary.Equal(that1.Summary) {
		return false
	}
	return true
}
func (this *SiteMeshGroupSummaryInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteMeshGroupSummaryInfo)
	if !ok {
		that2, ok := that.(SiteMeshGroupSummaryInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Sites != that1.Sites {
		return false
	}
	if this.OtherConnectedSiteMeshGroupSites != that1.OtherConnectedSiteMeshGroupSites {
		return false
	}
	if len(this.LinkStatusSummary) != len(that1.LinkStatusSummary) {
		return false
	}
	for i := range this.LinkStatusSummary {
		if !this.LinkStatusSummary[i].Equal(that1.LinkStatusSummary[i]) {
			return false
		}
	}
	if len(this.EdgeStatusSummary) != len(that1.EdgeStatusSummary) {
		return false
	}
	for i := range this.EdgeStatusSummary {
		if !this.EdgeStatusSummary[i].Equal(that1.EdgeStatusSummary[i]) {
			return false
		}
	}
	return true
}
func (this *NodeTypeSiteMeshGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeTypeSiteMeshGroup)
	if !ok {
		that2, ok := that.(NodeTypeSiteMeshGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	if !this.Summary.Equal(that1.Summary) {
		return false
	}
	return true
}
func (this *DCClusterGroupSummaryInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DCClusterGroupSummaryInfo)
	if !ok {
		that2, ok := that.(DCClusterGroupSummaryInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Sites != that1.Sites {
		return false
	}
	return true
}
func (this *NodeTypeDCClusterGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeTypeDCClusterGroup)
	if !ok {
		that2, ok := that.(NodeTypeDCClusterGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	if !this.Summary.Equal(that1.Summary) {
		return false
	}
	return true
}
func (this *NodeTypeTransitGateway) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeTypeTransitGateway)
	if !ok {
		that2, ok := that.(NodeTypeTransitGateway)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	if len(this.Metric) != len(that1.Metric) {
		return false
	}
	for i := range this.Metric {
		if !this.Metric[i].Equal(that1.Metric[i]) {
			return false
		}
	}
	return true
}
func (this *NodeTypeNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeTypeNetwork)
	if !ok {
		that2, ok := that.(NodeTypeNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	if len(this.Metric) != len(that1.Metric) {
		return false
	}
	for i := range this.Metric {
		if !this.Metric[i].Equal(that1.Metric[i]) {
			return false
		}
	}
	if !this.Summary.Equal(that1.Summary) {
		return false
	}
	return true
}
func (this *NodeTypeSubnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeTypeSubnet)
	if !ok {
		that2, ok := that.(NodeTypeSubnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	if len(this.Metric) != len(that1.Metric) {
		return false
	}
	for i := range this.Metric {
		if !this.Metric[i].Equal(that1.Metric[i]) {
			return false
		}
	}
	if !this.Summary.Equal(that1.Summary) {
		return false
	}
	return true
}
func (this *NodeTypeInstance) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeTypeInstance)
	if !ok {
		that2, ok := that.(NodeTypeInstance)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	if len(this.Metric) != len(that1.Metric) {
		return false
	}
	for i := range this.Metric {
		if !this.Metric[i].Equal(that1.Metric[i]) {
			return false
		}
	}
	return true
}
func (this *NodeMetaData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeMetaData)
	if !ok {
		that2, ok := that.(NodeMetaData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.CloudResourceId != that1.CloudResourceId {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Level != that1.Level {
		return false
	}
	if this.ProviderType != that1.ProviderType {
		return false
	}
	if this.OwnerId != that1.OwnerId {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *Node) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node)
	if !ok {
		that2, ok := that.(Node)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if that1.NodeType == nil {
		if this.NodeType != nil {
			return false
		}
	} else if this.NodeType == nil {
		return false
	} else if !this.NodeType.Equal(that1.NodeType) {
		return false
	}
	return true
}
func (this *Node_Site) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node_Site)
	if !ok {
		that2, ok := that.(Node_Site)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Site.Equal(that1.Site) {
		return false
	}
	return true
}
func (this *Node_TransitGateway) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node_TransitGateway)
	if !ok {
		that2, ok := that.(Node_TransitGateway)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TransitGateway.Equal(that1.TransitGateway) {
		return false
	}
	return true
}
func (this *Node_Network) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node_Network)
	if !ok {
		that2, ok := that.(Node_Network)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Network.Equal(that1.Network) {
		return false
	}
	return true
}
func (this *Node_Subnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node_Subnet)
	if !ok {
		that2, ok := that.(Node_Subnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Subnet.Equal(that1.Subnet) {
		return false
	}
	return true
}
func (this *Node_Instance) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node_Instance)
	if !ok {
		that2, ok := that.(Node_Instance)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Instance.Equal(that1.Instance) {
		return false
	}
	return true
}
func (this *Node_SiteMeshGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node_SiteMeshGroup)
	if !ok {
		that2, ok := that.(Node_SiteMeshGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteMeshGroup.Equal(that1.SiteMeshGroup) {
		return false
	}
	return true
}
func (this *Node_DcClusterGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node_DcClusterGroup)
	if !ok {
		that2, ok := that.(Node_DcClusterGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DcClusterGroup.Equal(that1.DcClusterGroup) {
		return false
	}
	return true
}
func (this *LinkInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinkInfo)
	if !ok {
		that2, ok := that.(LinkInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.SrcId != that1.SrcId {
		return false
	}
	if this.DstId != that1.DstId {
		return false
	}
	return true
}
func (this *LinkInfoSummary) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinkInfoSummary)
	if !ok {
		that2, ok := that.(LinkInfoSummary)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	return true
}
func (this *LinkTypeData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinkTypeData)
	if !ok {
		that2, ok := that.(LinkTypeData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	if len(this.Metric) != len(that1.Metric) {
		return false
	}
	for i := range this.Metric {
		if !this.Metric[i].Equal(that1.Metric[i]) {
			return false
		}
	}
	return true
}
func (this *EdgeInfoSummary) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EdgeInfoSummary)
	if !ok {
		that2, ok := that.(EdgeInfoSummary)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	return true
}
func (this *Edge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Edge)
	if !ok {
		that2, ok := that.(Edge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NodeId1 != that1.NodeId1 {
		return false
	}
	if this.NodeId2 != that1.NodeId2 {
		return false
	}
	if len(this.Links) != len(that1.Links) {
		return false
	}
	for i := range this.Links {
		if !this.Links[i].Equal(that1.Links[i]) {
			return false
		}
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *SiteTopologyRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&topology.SiteTopologyRequest{")
	s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	s = append(s, "NodeId: "+fmt.Sprintf("%#v", this.NodeId)+",\n")
	s = append(s, "Level: "+fmt.Sprintf("%#v", this.Level)+",\n")
	s = append(s, "GroupSiteMeshNodes: "+fmt.Sprintf("%#v", this.GroupSiteMeshNodes)+",\n")
	s = append(s, "GroupDcClusterNodes: "+fmt.Sprintf("%#v", this.GroupDcClusterNodes)+",\n")
	if this.MetricSelector != nil {
		s = append(s, "MetricSelector: "+fmt.Sprintf("%#v", this.MetricSelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteMeshGroupsSummaryRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&topology.SiteMeshGroupsSummaryRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteMeshTopologyRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.SiteMeshTopologyRequest{")
	s = append(s, "SiteMeshGroup: "+fmt.Sprintf("%#v", this.SiteMeshGroup)+",\n")
	if this.MetricSelector != nil {
		s = append(s, "MetricSelector: "+fmt.Sprintf("%#v", this.MetricSelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DCClusterGroupsSummaryRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&topology.DCClusterGroupsSummaryRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DCClusterTopologyRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.DCClusterTopologyRequest{")
	s = append(s, "DcClusterGroup: "+fmt.Sprintf("%#v", this.DcClusterGroup)+",\n")
	if this.MetricSelector != nil {
		s = append(s, "MetricSelector: "+fmt.Sprintf("%#v", this.MetricSelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TopologyResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&topology.TopologyResponse{")
	if this.Nodes != nil {
		s = append(s, "Nodes: "+fmt.Sprintf("%#v", this.Nodes)+",\n")
	}
	if this.Edges != nil {
		s = append(s, "Edges: "+fmt.Sprintf("%#v", this.Edges)+",\n")
	}
	s = append(s, "Step: "+fmt.Sprintf("%#v", this.Step)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteTableRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&topology.RouteTableRequest{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteTableResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.RouteTableResponse{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.RouteTable != nil {
		s = append(s, "RouteTable: "+fmt.Sprintf("%#v", this.RouteTable)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&topology.MetricSelector{")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	s = append(s, "Node: "+fmt.Sprintf("%#v", this.Node)+",\n")
	s = append(s, "Edge: "+fmt.Sprintf("%#v", this.Edge)+",\n")
	s = append(s, "Step: "+fmt.Sprintf("%#v", this.Step)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricTypeData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.MetricTypeData{")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	if this.Values != nil {
		s = append(s, "Values: "+fmt.Sprintf("%#v", this.Values)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&topology.MetricData{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Unit: "+fmt.Sprintf("%#v", this.Unit)+",\n")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteTableMetaData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&topology.RouteTableMetaData{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	s = append(s, "CloudResourceId: "+fmt.Sprintf("%#v", this.CloudResourceId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteSummaryInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.SiteSummaryInfo{")
	s = append(s, "NodeCount: "+fmt.Sprintf("%#v", this.NodeCount)+",\n")
	s = append(s, "AvailabilityZone: "+fmt.Sprintf("%#v", this.AvailabilityZone)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkSummaryInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&topology.NetworkSummaryInfo{")
	if this.RouteTables != nil {
		s = append(s, "RouteTables: "+fmt.Sprintf("%#v", this.RouteTables)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SubnetSummaryInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&topology.SubnetSummaryInfo{")
	if this.RouteTables != nil {
		s = append(s, "RouteTables: "+fmt.Sprintf("%#v", this.RouteTables)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeTypeSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&topology.NodeTypeSite{")
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	if this.Metric != nil {
		s = append(s, "Metric: "+fmt.Sprintf("%#v", this.Metric)+",\n")
	}
	if this.Summary != nil {
		s = append(s, "Summary: "+fmt.Sprintf("%#v", this.Summary)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteMeshGroupSummaryInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&topology.SiteMeshGroupSummaryInfo{")
	s = append(s, "Sites: "+fmt.Sprintf("%#v", this.Sites)+",\n")
	s = append(s, "OtherConnectedSiteMeshGroupSites: "+fmt.Sprintf("%#v", this.OtherConnectedSiteMeshGroupSites)+",\n")
	if this.LinkStatusSummary != nil {
		s = append(s, "LinkStatusSummary: "+fmt.Sprintf("%#v", this.LinkStatusSummary)+",\n")
	}
	if this.EdgeStatusSummary != nil {
		s = append(s, "EdgeStatusSummary: "+fmt.Sprintf("%#v", this.EdgeStatusSummary)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeTypeSiteMeshGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.NodeTypeSiteMeshGroup{")
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	if this.Summary != nil {
		s = append(s, "Summary: "+fmt.Sprintf("%#v", this.Summary)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DCClusterGroupSummaryInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&topology.DCClusterGroupSummaryInfo{")
	s = append(s, "Sites: "+fmt.Sprintf("%#v", this.Sites)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeTypeDCClusterGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.NodeTypeDCClusterGroup{")
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	if this.Summary != nil {
		s = append(s, "Summary: "+fmt.Sprintf("%#v", this.Summary)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeTypeTransitGateway) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.NodeTypeTransitGateway{")
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	if this.Metric != nil {
		s = append(s, "Metric: "+fmt.Sprintf("%#v", this.Metric)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeTypeNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&topology.NodeTypeNetwork{")
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	if this.Metric != nil {
		s = append(s, "Metric: "+fmt.Sprintf("%#v", this.Metric)+",\n")
	}
	if this.Summary != nil {
		s = append(s, "Summary: "+fmt.Sprintf("%#v", this.Summary)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeTypeSubnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&topology.NodeTypeSubnet{")
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	if this.Metric != nil {
		s = append(s, "Metric: "+fmt.Sprintf("%#v", this.Metric)+",\n")
	}
	if this.Summary != nil {
		s = append(s, "Summary: "+fmt.Sprintf("%#v", this.Summary)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeTypeInstance) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.NodeTypeInstance{")
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	if this.Metric != nil {
		s = append(s, "Metric: "+fmt.Sprintf("%#v", this.Metric)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeMetaData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&topology.NodeMetaData{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "CloudResourceId: "+fmt.Sprintf("%#v", this.CloudResourceId)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Level: "+fmt.Sprintf("%#v", this.Level)+",\n")
	s = append(s, "ProviderType: "+fmt.Sprintf("%#v", this.ProviderType)+",\n")
	s = append(s, "OwnerId: "+fmt.Sprintf("%#v", this.OwnerId)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Node) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&topology.Node{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.NodeType != nil {
		s = append(s, "NodeType: "+fmt.Sprintf("%#v", this.NodeType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Node_Site) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&topology.Node_Site{` +
		`Site:` + fmt.Sprintf("%#v", this.Site) + `}`}, ", ")
	return s
}
func (this *Node_TransitGateway) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&topology.Node_TransitGateway{` +
		`TransitGateway:` + fmt.Sprintf("%#v", this.TransitGateway) + `}`}, ", ")
	return s
}
func (this *Node_Network) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&topology.Node_Network{` +
		`Network:` + fmt.Sprintf("%#v", this.Network) + `}`}, ", ")
	return s
}
func (this *Node_Subnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&topology.Node_Subnet{` +
		`Subnet:` + fmt.Sprintf("%#v", this.Subnet) + `}`}, ", ")
	return s
}
func (this *Node_Instance) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&topology.Node_Instance{` +
		`Instance:` + fmt.Sprintf("%#v", this.Instance) + `}`}, ", ")
	return s
}
func (this *Node_SiteMeshGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&topology.Node_SiteMeshGroup{` +
		`SiteMeshGroup:` + fmt.Sprintf("%#v", this.SiteMeshGroup) + `}`}, ", ")
	return s
}
func (this *Node_DcClusterGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&topology.Node_DcClusterGroup{` +
		`DcClusterGroup:` + fmt.Sprintf("%#v", this.DcClusterGroup) + `}`}, ", ")
	return s
}
func (this *LinkInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&topology.LinkInfo{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "SrcId: "+fmt.Sprintf("%#v", this.SrcId)+",\n")
	s = append(s, "DstId: "+fmt.Sprintf("%#v", this.DstId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LinkInfoSummary) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&topology.LinkInfoSummary{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LinkTypeData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.LinkTypeData{")
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	if this.Metric != nil {
		s = append(s, "Metric: "+fmt.Sprintf("%#v", this.Metric)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EdgeInfoSummary) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&topology.EdgeInfoSummary{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Edge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&topology.Edge{")
	s = append(s, "NodeId1: "+fmt.Sprintf("%#v", this.NodeId1)+",\n")
	s = append(s, "NodeId2: "+fmt.Sprintf("%#v", this.NodeId2)+",\n")
	if this.Links != nil {
		s = append(s, "Links: "+fmt.Sprintf("%#v", this.Links)+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPublicCustomDataApi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CustomDataAPIClient is the client API for CustomDataAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CustomDataAPIClient interface {
	// Site Topology
	//
	// x-displayName: "Site Topology"
	// Get topology of a site and the resources associated/connected to the site such as other Customer sites,
	// Regional Sites, VPCs (Virtual Private Cloud) networks, etc., and the associated metrics.
	SiteTopology(ctx context.Context, in *SiteTopologyRequest, opts ...grpc.CallOption) (*TopologyResponse, error)
	// Site Mesh Groups Summary
	//
	// x-displayName: "Site Mesh Groups Summary"
	// Get summary of all site mesh groups.
	SiteMeshGroupsSummary(ctx context.Context, in *SiteMeshGroupsSummaryRequest, opts ...grpc.CallOption) (*TopologyResponse, error)
	// Site Mesh Topology
	//
	// x-displayName: "Site Mesh Topology"
	// Get topology of a site mesh.
	SiteMeshTopology(ctx context.Context, in *SiteMeshTopologyRequest, opts ...grpc.CallOption) (*TopologyResponse, error)
	// DC Cluster Groups Summary
	//
	// x-displayName: "DC Cluster Groups Summary"
	// Get summary of all DC Cluster groups.
	DCClusterGroupsSummary(ctx context.Context, in *DCClusterGroupsSummaryRequest, opts ...grpc.CallOption) (*TopologyResponse, error)
	// DC Cluster Topology
	//
	// x-displayName: "DC Cluster Topology"
	// Get topology of a DC Cluster.
	DCClusterTopology(ctx context.Context, in *DCClusterTopologyRequest, opts ...grpc.CallOption) (*TopologyResponse, error)
	// Get Route Table
	//
	// x-displayName: "Get Route Table"
	// Get Route Table
	GetRouteTable(ctx context.Context, in *RouteTableRequest, opts ...grpc.CallOption) (*RouteTableResponse, error)
}

type customDataAPIClient struct {
	cc *grpc.ClientConn
}

func NewCustomDataAPIClient(cc *grpc.ClientConn) CustomDataAPIClient {
	return &customDataAPIClient{cc}
}

func (c *customDataAPIClient) SiteTopology(ctx context.Context, in *SiteTopologyRequest, opts ...grpc.CallOption) (*TopologyResponse, error) {
	out := new(TopologyResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.topology.CustomDataAPI/SiteTopology", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customDataAPIClient) SiteMeshGroupsSummary(ctx context.Context, in *SiteMeshGroupsSummaryRequest, opts ...grpc.CallOption) (*TopologyResponse, error) {
	out := new(TopologyResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.topology.CustomDataAPI/SiteMeshGroupsSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customDataAPIClient) SiteMeshTopology(ctx context.Context, in *SiteMeshTopologyRequest, opts ...grpc.CallOption) (*TopologyResponse, error) {
	out := new(TopologyResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.topology.CustomDataAPI/SiteMeshTopology", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customDataAPIClient) DCClusterGroupsSummary(ctx context.Context, in *DCClusterGroupsSummaryRequest, opts ...grpc.CallOption) (*TopologyResponse, error) {
	out := new(TopologyResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.topology.CustomDataAPI/DCClusterGroupsSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customDataAPIClient) DCClusterTopology(ctx context.Context, in *DCClusterTopologyRequest, opts ...grpc.CallOption) (*TopologyResponse, error) {
	out := new(TopologyResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.topology.CustomDataAPI/DCClusterTopology", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customDataAPIClient) GetRouteTable(ctx context.Context, in *RouteTableRequest, opts ...grpc.CallOption) (*RouteTableResponse, error) {
	out := new(RouteTableResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.topology.CustomDataAPI/GetRouteTable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CustomDataAPIServer is the server API for CustomDataAPI service.
type CustomDataAPIServer interface {
	// Site Topology
	//
	// x-displayName: "Site Topology"
	// Get topology of a site and the resources associated/connected to the site such as other Customer sites,
	// Regional Sites, VPCs (Virtual Private Cloud) networks, etc., and the associated metrics.
	SiteTopology(context.Context, *SiteTopologyRequest) (*TopologyResponse, error)
	// Site Mesh Groups Summary
	//
	// x-displayName: "Site Mesh Groups Summary"
	// Get summary of all site mesh groups.
	SiteMeshGroupsSummary(context.Context, *SiteMeshGroupsSummaryRequest) (*TopologyResponse, error)
	// Site Mesh Topology
	//
	// x-displayName: "Site Mesh Topology"
	// Get topology of a site mesh.
	SiteMeshTopology(context.Context, *SiteMeshTopologyRequest) (*TopologyResponse, error)
	// DC Cluster Groups Summary
	//
	// x-displayName: "DC Cluster Groups Summary"
	// Get summary of all DC Cluster groups.
	DCClusterGroupsSummary(context.Context, *DCClusterGroupsSummaryRequest) (*TopologyResponse, error)
	// DC Cluster Topology
	//
	// x-displayName: "DC Cluster Topology"
	// Get topology of a DC Cluster.
	DCClusterTopology(context.Context, *DCClusterTopologyRequest) (*TopologyResponse, error)
	// Get Route Table
	//
	// x-displayName: "Get Route Table"
	// Get Route Table
	GetRouteTable(context.Context, *RouteTableRequest) (*RouteTableResponse, error)
}

// UnimplementedCustomDataAPIServer can be embedded to have forward compatible implementations.
type UnimplementedCustomDataAPIServer struct {
}

func (*UnimplementedCustomDataAPIServer) SiteTopology(ctx context.Context, req *SiteTopologyRequest) (*TopologyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SiteTopology not implemented")
}
func (*UnimplementedCustomDataAPIServer) SiteMeshGroupsSummary(ctx context.Context, req *SiteMeshGroupsSummaryRequest) (*TopologyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SiteMeshGroupsSummary not implemented")
}
func (*UnimplementedCustomDataAPIServer) SiteMeshTopology(ctx context.Context, req *SiteMeshTopologyRequest) (*TopologyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SiteMeshTopology not implemented")
}
func (*UnimplementedCustomDataAPIServer) DCClusterGroupsSummary(ctx context.Context, req *DCClusterGroupsSummaryRequest) (*TopologyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DCClusterGroupsSummary not implemented")
}
func (*UnimplementedCustomDataAPIServer) DCClusterTopology(ctx context.Context, req *DCClusterTopologyRequest) (*TopologyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DCClusterTopology not implemented")
}
func (*UnimplementedCustomDataAPIServer) GetRouteTable(ctx context.Context, req *RouteTableRequest) (*RouteTableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRouteTable not implemented")
}

func RegisterCustomDataAPIServer(s *grpc.Server, srv CustomDataAPIServer) {
	s.RegisterService(&_CustomDataAPI_serviceDesc, srv)
}

func _CustomDataAPI_SiteTopology_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SiteTopologyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomDataAPIServer).SiteTopology(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.topology.CustomDataAPI/SiteTopology",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomDataAPIServer).SiteTopology(ctx, req.(*SiteTopologyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomDataAPI_SiteMeshGroupsSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SiteMeshGroupsSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomDataAPIServer).SiteMeshGroupsSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.topology.CustomDataAPI/SiteMeshGroupsSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomDataAPIServer).SiteMeshGroupsSummary(ctx, req.(*SiteMeshGroupsSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomDataAPI_SiteMeshTopology_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SiteMeshTopologyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomDataAPIServer).SiteMeshTopology(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.topology.CustomDataAPI/SiteMeshTopology",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomDataAPIServer).SiteMeshTopology(ctx, req.(*SiteMeshTopologyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomDataAPI_DCClusterGroupsSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DCClusterGroupsSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomDataAPIServer).DCClusterGroupsSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.topology.CustomDataAPI/DCClusterGroupsSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomDataAPIServer).DCClusterGroupsSummary(ctx, req.(*DCClusterGroupsSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomDataAPI_DCClusterTopology_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DCClusterTopologyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomDataAPIServer).DCClusterTopology(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.topology.CustomDataAPI/DCClusterTopology",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomDataAPIServer).DCClusterTopology(ctx, req.(*DCClusterTopologyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomDataAPI_GetRouteTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomDataAPIServer).GetRouteTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.topology.CustomDataAPI/GetRouteTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomDataAPIServer).GetRouteTable(ctx, req.(*RouteTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CustomDataAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ves.io.schema.topology.CustomDataAPI",
	HandlerType: (*CustomDataAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SiteTopology",
			Handler:    _CustomDataAPI_SiteTopology_Handler,
		},
		{
			MethodName: "SiteMeshGroupsSummary",
			Handler:    _CustomDataAPI_SiteMeshGroupsSummary_Handler,
		},
		{
			MethodName: "SiteMeshTopology",
			Handler:    _CustomDataAPI_SiteMeshTopology_Handler,
		},
		{
			MethodName: "DCClusterGroupsSummary",
			Handler:    _CustomDataAPI_DCClusterGroupsSummary_Handler,
		},
		{
			MethodName: "DCClusterTopology",
			Handler:    _CustomDataAPI_DCClusterTopology_Handler,
		},
		{
			MethodName: "GetRouteTable",
			Handler:    _CustomDataAPI_GetRouteTable_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ves.io/schema/topology/public_custom_data_api.proto",
}

func (m *SiteTopologyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteTopologyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteTopologyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MetricSelector != nil {
		{
			size, err := m.MetricSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.GroupDcClusterNodes {
		i--
		if m.GroupDcClusterNodes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.GroupSiteMeshNodes {
		i--
		if m.GroupSiteMeshNodes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Level != 0 {
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x20
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Site) > 0 {
		i -= len(m.Site)
		copy(dAtA[i:], m.Site)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.Site)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *SiteMeshGroupsSummaryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteMeshGroupsSummaryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteMeshGroupsSummaryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SiteMeshTopologyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteMeshTopologyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteMeshTopologyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MetricSelector != nil {
		{
			size, err := m.MetricSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SiteMeshGroup) > 0 {
		i -= len(m.SiteMeshGroup)
		copy(dAtA[i:], m.SiteMeshGroup)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.SiteMeshGroup)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *DCClusterGroupsSummaryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DCClusterGroupsSummaryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DCClusterGroupsSummaryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DCClusterTopologyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DCClusterTopologyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DCClusterTopologyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MetricSelector != nil {
		{
			size, err := m.MetricSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DcClusterGroup) > 0 {
		i -= len(m.DcClusterGroup)
		copy(dAtA[i:], m.DcClusterGroup)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.DcClusterGroup)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TopologyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopologyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopologyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Step) > 0 {
		i -= len(m.Step)
		copy(dAtA[i:], m.Step)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.Step)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Edges) > 0 {
		for iNdEx := len(m.Edges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Edges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RouteTableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteTableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RouteTable != nil {
		{
			size, err := m.RouteTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetricSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Step) > 0 {
		i -= len(m.Step)
		copy(dAtA[i:], m.Step)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.Step)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Edge) > 0 {
		dAtA7 := make([]byte, len(m.Edge)*10)
		var j6 int
		for _, num := range m.Edge {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Node) > 0 {
		dAtA9 := make([]byte, len(m.Node)*10)
		var j8 int
		for _, num := range m.Node {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetricTypeData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricTypeData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricTypeData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MetricData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Unit != 0 {
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(m.Unit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Type != 0 {
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RouteTableMetaData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableMetaData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTableMetaData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CloudResourceId) > 0 {
		i -= len(m.CloudResourceId)
		copy(dAtA[i:], m.CloudResourceId)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.CloudResourceId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SiteSummaryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteSummaryInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteSummaryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AvailabilityZone) > 0 {
		for iNdEx := len(m.AvailabilityZone) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AvailabilityZone[iNdEx])
			copy(dAtA[i:], m.AvailabilityZone[iNdEx])
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.AvailabilityZone[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.NodeCount != 0 {
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(m.NodeCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NetworkSummaryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkSummaryInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkSummaryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RouteTables) > 0 {
		for iNdEx := len(m.RouteTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RouteTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SubnetSummaryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetSummaryInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetSummaryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RouteTables) > 0 {
		for iNdEx := len(m.RouteTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RouteTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NodeTypeSite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeTypeSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeTypeSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Summary != nil {
		{
			size, err := m.Summary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Metric) > 0 {
		for iNdEx := len(m.Metric) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metric[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SiteMeshGroupSummaryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteMeshGroupSummaryInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteMeshGroupSummaryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EdgeStatusSummary) > 0 {
		for iNdEx := len(m.EdgeStatusSummary) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EdgeStatusSummary[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.LinkStatusSummary) > 0 {
		for iNdEx := len(m.LinkStatusSummary) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LinkStatusSummary[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.OtherConnectedSiteMeshGroupSites != 0 {
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(m.OtherConnectedSiteMeshGroupSites))
		i--
		dAtA[i] = 0x10
	}
	if m.Sites != 0 {
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(m.Sites))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeTypeSiteMeshGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeTypeSiteMeshGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeTypeSiteMeshGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Summary != nil {
		{
			size, err := m.Summary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DCClusterGroupSummaryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DCClusterGroupSummaryInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DCClusterGroupSummaryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sites != 0 {
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(m.Sites))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeTypeDCClusterGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeTypeDCClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeTypeDCClusterGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Summary != nil {
		{
			size, err := m.Summary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeTypeTransitGateway) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeTypeTransitGateway) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeTypeTransitGateway) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metric) > 0 {
		for iNdEx := len(m.Metric) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metric[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeTypeNetwork) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeTypeNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeTypeNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Summary != nil {
		{
			size, err := m.Summary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Metric) > 0 {
		for iNdEx := len(m.Metric) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metric[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeTypeSubnet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeTypeSubnet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeTypeSubnet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Summary != nil {
		{
			size, err := m.Summary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Metric) > 0 {
		for iNdEx := len(m.Metric) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metric[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeTypeInstance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeTypeInstance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeTypeInstance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metric) > 0 {
		for iNdEx := len(m.Metric) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metric[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeMetaData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeMetaData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeMetaData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CloudResourceId) > 0 {
		i -= len(m.CloudResourceId)
		copy(dAtA[i:], m.CloudResourceId)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.CloudResourceId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.OwnerId) > 0 {
		i -= len(m.OwnerId)
		copy(dAtA[i:], m.OwnerId)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.OwnerId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ProviderType != 0 {
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(m.ProviderType))
		i--
		dAtA[i] = 0x20
	}
	if m.Level != 0 {
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeType != nil {
		{
			size := m.NodeType.Size()
			i -= size
			if _, err := m.NodeType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_Site) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Site) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Site != nil {
		{
			size, err := m.Site.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Node_TransitGateway) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_TransitGateway) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TransitGateway != nil {
		{
			size, err := m.TransitGateway.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Node_Network) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Network) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Network != nil {
		{
			size, err := m.Network.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Node_Subnet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Subnet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Subnet != nil {
		{
			size, err := m.Subnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Node_Instance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Instance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Instance != nil {
		{
			size, err := m.Instance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Node_SiteMeshGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_SiteMeshGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteMeshGroup != nil {
		{
			size, err := m.SiteMeshGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Node_DcClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_DcClusterGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DcClusterGroup != nil {
		{
			size, err := m.DcClusterGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *LinkInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstId) > 0 {
		i -= len(m.DstId)
		copy(dAtA[i:], m.DstId)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.DstId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SrcId) > 0 {
		i -= len(m.SrcId)
		copy(dAtA[i:], m.SrcId)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.SrcId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LinkInfoSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkInfoSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkInfoSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LinkTypeData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkTypeData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkTypeData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metric) > 0 {
		for iNdEx := len(m.Metric) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metric[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EdgeInfoSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeInfoSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeInfoSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Status != 0 {
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Edge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Edge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Edge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Links) > 0 {
		for iNdEx := len(m.Links) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Links[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.NodeId2) > 0 {
		i -= len(m.NodeId2)
		copy(dAtA[i:], m.NodeId2)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.NodeId2)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeId1) > 0 {
		i -= len(m.NodeId1)
		copy(dAtA[i:], m.NodeId1)
		i = encodeVarintPublicCustomDataApi(dAtA, i, uint64(len(m.NodeId1)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPublicCustomDataApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovPublicCustomDataApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SiteTopologyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Site)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovPublicCustomDataApi(uint64(m.Level))
	}
	if m.GroupSiteMeshNodes {
		n += 2
	}
	if m.GroupDcClusterNodes {
		n += 2
	}
	if m.MetricSelector != nil {
		l = m.MetricSelector.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}

func (m *SiteMeshGroupsSummaryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SiteMeshTopologyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SiteMeshGroup)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if m.MetricSelector != nil {
		l = m.MetricSelector.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}

func (m *DCClusterGroupsSummaryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DCClusterTopologyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DcClusterGroup)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if m.MetricSelector != nil {
		l = m.MetricSelector.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}

func (m *TopologyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovPublicCustomDataApi(uint64(l))
		}
	}
	if len(m.Edges) > 0 {
		for _, e := range m.Edges {
			l = e.Size()
			n += 1 + l + sovPublicCustomDataApi(uint64(l))
		}
	}
	l = len(m.Step)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}

func (m *RouteTableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}

func (m *RouteTableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if m.RouteTable != nil {
		l = m.RouteTable.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}

func (m *MetricSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if len(m.Node) > 0 {
		l = 0
		for _, e := range m.Node {
			l += sovPublicCustomDataApi(uint64(e))
		}
		n += 1 + sovPublicCustomDataApi(uint64(l)) + l
	}
	if len(m.Edge) > 0 {
		l = 0
		for _, e := range m.Edge {
			l += sovPublicCustomDataApi(uint64(e))
		}
		n += 1 + sovPublicCustomDataApi(uint64(l)) + l
	}
	l = len(m.Step)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}

func (m *MetricTypeData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPublicCustomDataApi(uint64(len(k))) + 1 + len(v) + sovPublicCustomDataApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovPublicCustomDataApi(uint64(mapEntrySize))
		}
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovPublicCustomDataApi(uint64(l))
		}
	}
	return n
}

func (m *MetricData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPublicCustomDataApi(uint64(m.Type))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovPublicCustomDataApi(uint64(l))
		}
	}
	if m.Unit != 0 {
		n += 1 + sovPublicCustomDataApi(uint64(m.Unit))
	}
	return n
}

func (m *RouteTableMetaData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPublicCustomDataApi(uint64(len(k))) + 1 + len(v) + sovPublicCustomDataApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovPublicCustomDataApi(uint64(mapEntrySize))
		}
	}
	l = len(m.CloudResourceId)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}

func (m *SiteSummaryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeCount != 0 {
		n += 1 + sovPublicCustomDataApi(uint64(m.NodeCount))
	}
	if len(m.AvailabilityZone) > 0 {
		for _, s := range m.AvailabilityZone {
			l = len(s)
			n += 1 + l + sovPublicCustomDataApi(uint64(l))
		}
	}
	return n
}

func (m *NetworkSummaryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RouteTables) > 0 {
		for _, e := range m.RouteTables {
			l = e.Size()
			n += 1 + l + sovPublicCustomDataApi(uint64(l))
		}
	}
	return n
}

func (m *SubnetSummaryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RouteTables) > 0 {
		for _, e := range m.RouteTables {
			l = e.Size()
			n += 1 + l + sovPublicCustomDataApi(uint64(l))
		}
	}
	return n
}

func (m *NodeTypeSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if len(m.Metric) > 0 {
		for _, e := range m.Metric {
			l = e.Size()
			n += 1 + l + sovPublicCustomDataApi(uint64(l))
		}
	}
	if m.Summary != nil {
		l = m.Summary.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}

func (m *SiteMeshGroupSummaryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sites != 0 {
		n += 1 + sovPublicCustomDataApi(uint64(m.Sites))
	}
	if m.OtherConnectedSiteMeshGroupSites != 0 {
		n += 1 + sovPublicCustomDataApi(uint64(m.OtherConnectedSiteMeshGroupSites))
	}
	if len(m.LinkStatusSummary) > 0 {
		for _, e := range m.LinkStatusSummary {
			l = e.Size()
			n += 1 + l + sovPublicCustomDataApi(uint64(l))
		}
	}
	if len(m.EdgeStatusSummary) > 0 {
		for _, e := range m.EdgeStatusSummary {
			l = e.Size()
			n += 1 + l + sovPublicCustomDataApi(uint64(l))
		}
	}
	return n
}

func (m *NodeTypeSiteMeshGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if m.Summary != nil {
		l = m.Summary.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}

func (m *DCClusterGroupSummaryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sites != 0 {
		n += 1 + sovPublicCustomDataApi(uint64(m.Sites))
	}
	return n
}

func (m *NodeTypeDCClusterGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if m.Summary != nil {
		l = m.Summary.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}

func (m *NodeTypeTransitGateway) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if len(m.Metric) > 0 {
		for _, e := range m.Metric {
			l = e.Size()
			n += 1 + l + sovPublicCustomDataApi(uint64(l))
		}
	}
	return n
}

func (m *NodeTypeNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if len(m.Metric) > 0 {
		for _, e := range m.Metric {
			l = e.Size()
			n += 1 + l + sovPublicCustomDataApi(uint64(l))
		}
	}
	if m.Summary != nil {
		l = m.Summary.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}

func (m *NodeTypeSubnet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if len(m.Metric) > 0 {
		for _, e := range m.Metric {
			l = e.Size()
			n += 1 + l + sovPublicCustomDataApi(uint64(l))
		}
	}
	if m.Summary != nil {
		l = m.Summary.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}

func (m *NodeTypeInstance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if len(m.Metric) > 0 {
		for _, e := range m.Metric {
			l = e.Size()
			n += 1 + l + sovPublicCustomDataApi(uint64(l))
		}
	}
	return n
}

func (m *NodeMetaData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovPublicCustomDataApi(uint64(m.Level))
	}
	if m.ProviderType != 0 {
		n += 1 + sovPublicCustomDataApi(uint64(m.ProviderType))
	}
	l = len(m.OwnerId)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPublicCustomDataApi(uint64(len(k))) + 1 + len(v) + sovPublicCustomDataApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovPublicCustomDataApi(uint64(mapEntrySize))
		}
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	l = len(m.CloudResourceId)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if m.NodeType != nil {
		n += m.NodeType.Size()
	}
	return n
}

func (m *Node_Site) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Site != nil {
		l = m.Site.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}
func (m *Node_TransitGateway) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TransitGateway != nil {
		l = m.TransitGateway.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}
func (m *Node_Network) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Network != nil {
		l = m.Network.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}
func (m *Node_Subnet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subnet != nil {
		l = m.Subnet.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}
func (m *Node_Instance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Instance != nil {
		l = m.Instance.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}
func (m *Node_SiteMeshGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteMeshGroup != nil {
		l = m.SiteMeshGroup.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}
func (m *Node_DcClusterGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DcClusterGroup != nil {
		l = m.DcClusterGroup.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}
func (m *LinkInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovPublicCustomDataApi(uint64(m.Type))
	}
	if m.Status != 0 {
		n += 1 + sovPublicCustomDataApi(uint64(m.Status))
	}
	l = len(m.SrcId)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	l = len(m.DstId)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	return n
}

func (m *LinkInfoSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPublicCustomDataApi(uint64(m.Type))
	}
	if m.Status != 0 {
		n += 1 + sovPublicCustomDataApi(uint64(m.Status))
	}
	if m.Count != 0 {
		n += 1 + sovPublicCustomDataApi(uint64(m.Count))
	}
	return n
}

func (m *LinkTypeData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if len(m.Metric) > 0 {
		for _, e := range m.Metric {
			l = e.Size()
			n += 1 + l + sovPublicCustomDataApi(uint64(l))
		}
	}
	return n
}

func (m *EdgeInfoSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovPublicCustomDataApi(uint64(m.Status))
	}
	if m.Count != 0 {
		n += 1 + sovPublicCustomDataApi(uint64(m.Count))
	}
	return n
}

func (m *Edge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId1)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	l = len(m.NodeId2)
	if l > 0 {
		n += 1 + l + sovPublicCustomDataApi(uint64(l))
	}
	if len(m.Links) > 0 {
		for _, e := range m.Links {
			l = e.Size()
			n += 1 + l + sovPublicCustomDataApi(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovPublicCustomDataApi(uint64(m.Status))
	}
	return n
}

func sovPublicCustomDataApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPublicCustomDataApi(x uint64) (n int) {
	return sovPublicCustomDataApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *SiteTopologyRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteTopologyRequest{`,
		`Site:` + fmt.Sprintf("%v", this.Site) + `,`,
		`NodeId:` + fmt.Sprintf("%v", this.NodeId) + `,`,
		`Level:` + fmt.Sprintf("%v", this.Level) + `,`,
		`GroupSiteMeshNodes:` + fmt.Sprintf("%v", this.GroupSiteMeshNodes) + `,`,
		`GroupDcClusterNodes:` + fmt.Sprintf("%v", this.GroupDcClusterNodes) + `,`,
		`MetricSelector:` + strings.Replace(this.MetricSelector.String(), "MetricSelector", "MetricSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteMeshGroupsSummaryRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteMeshGroupsSummaryRequest{`,
		`}`,
	}, "")
	return s
}
func (this *SiteMeshTopologyRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteMeshTopologyRequest{`,
		`SiteMeshGroup:` + fmt.Sprintf("%v", this.SiteMeshGroup) + `,`,
		`MetricSelector:` + strings.Replace(this.MetricSelector.String(), "MetricSelector", "MetricSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DCClusterGroupsSummaryRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DCClusterGroupsSummaryRequest{`,
		`}`,
	}, "")
	return s
}
func (this *DCClusterTopologyRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DCClusterTopologyRequest{`,
		`DcClusterGroup:` + fmt.Sprintf("%v", this.DcClusterGroup) + `,`,
		`MetricSelector:` + strings.Replace(this.MetricSelector.String(), "MetricSelector", "MetricSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TopologyResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNodes := "[]*Node{"
	for _, f := range this.Nodes {
		repeatedStringForNodes += strings.Replace(f.String(), "Node", "Node", 1) + ","
	}
	repeatedStringForNodes += "}"
	repeatedStringForEdges := "[]*Edge{"
	for _, f := range this.Edges {
		repeatedStringForEdges += strings.Replace(f.String(), "Edge", "Edge", 1) + ","
	}
	repeatedStringForEdges += "}"
	s := strings.Join([]string{`&TopologyResponse{`,
		`Nodes:` + repeatedStringForNodes + `,`,
		`Edges:` + repeatedStringForEdges + `,`,
		`Step:` + fmt.Sprintf("%v", this.Step) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteTableRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteTableRequest{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteTableResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteTableResponse{`,
		`Metadata:` + strings.Replace(this.Metadata.String(), "RouteTableMetaData", "RouteTableMetaData", 1) + `,`,
		`RouteTable:` + strings.Replace(fmt.Sprintf("%v", this.RouteTable), "RouteTableType", "RouteTableType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricSelector{`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Node:` + fmt.Sprintf("%v", this.Node) + `,`,
		`Edge:` + fmt.Sprintf("%v", this.Edge) + `,`,
		`Step:` + fmt.Sprintf("%v", this.Step) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricTypeData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForValues := "[]*MetricValue{"
	for _, f := range this.Values {
		repeatedStringForValues += strings.Replace(fmt.Sprintf("%v", f), "MetricValue", "schema.MetricValue", 1) + ","
	}
	repeatedStringForValues += "}"
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&MetricTypeData{`,
		`Labels:` + mapStringForLabels + `,`,
		`Values:` + repeatedStringForValues + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForData := "[]*MetricTypeData{"
	for _, f := range this.Data {
		repeatedStringForData += strings.Replace(f.String(), "MetricTypeData", "MetricTypeData", 1) + ","
	}
	repeatedStringForData += "}"
	s := strings.Join([]string{`&MetricData{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Data:` + repeatedStringForData + `,`,
		`Unit:` + fmt.Sprintf("%v", this.Unit) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteTableMetaData) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&RouteTableMetaData{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`CloudResourceId:` + fmt.Sprintf("%v", this.CloudResourceId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteSummaryInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteSummaryInfo{`,
		`NodeCount:` + fmt.Sprintf("%v", this.NodeCount) + `,`,
		`AvailabilityZone:` + fmt.Sprintf("%v", this.AvailabilityZone) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkSummaryInfo) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRouteTables := "[]*RouteTableMetaData{"
	for _, f := range this.RouteTables {
		repeatedStringForRouteTables += strings.Replace(f.String(), "RouteTableMetaData", "RouteTableMetaData", 1) + ","
	}
	repeatedStringForRouteTables += "}"
	s := strings.Join([]string{`&NetworkSummaryInfo{`,
		`RouteTables:` + repeatedStringForRouteTables + `,`,
		`}`,
	}, "")
	return s
}
func (this *SubnetSummaryInfo) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRouteTables := "[]*RouteTableMetaData{"
	for _, f := range this.RouteTables {
		repeatedStringForRouteTables += strings.Replace(f.String(), "RouteTableMetaData", "RouteTableMetaData", 1) + ","
	}
	repeatedStringForRouteTables += "}"
	s := strings.Join([]string{`&SubnetSummaryInfo{`,
		`RouteTables:` + repeatedStringForRouteTables + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeTypeSite) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMetric := "[]*MetricData{"
	for _, f := range this.Metric {
		repeatedStringForMetric += strings.Replace(f.String(), "MetricData", "MetricData", 1) + ","
	}
	repeatedStringForMetric += "}"
	s := strings.Join([]string{`&NodeTypeSite{`,
		`Info:` + strings.Replace(fmt.Sprintf("%v", this.Info), "SiteType", "SiteType", 1) + `,`,
		`Metric:` + repeatedStringForMetric + `,`,
		`Summary:` + strings.Replace(this.Summary.String(), "SiteSummaryInfo", "SiteSummaryInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteMeshGroupSummaryInfo) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLinkStatusSummary := "[]*LinkInfoSummary{"
	for _, f := range this.LinkStatusSummary {
		repeatedStringForLinkStatusSummary += strings.Replace(f.String(), "LinkInfoSummary", "LinkInfoSummary", 1) + ","
	}
	repeatedStringForLinkStatusSummary += "}"
	repeatedStringForEdgeStatusSummary := "[]*EdgeInfoSummary{"
	for _, f := range this.EdgeStatusSummary {
		repeatedStringForEdgeStatusSummary += strings.Replace(f.String(), "EdgeInfoSummary", "EdgeInfoSummary", 1) + ","
	}
	repeatedStringForEdgeStatusSummary += "}"
	s := strings.Join([]string{`&SiteMeshGroupSummaryInfo{`,
		`Sites:` + fmt.Sprintf("%v", this.Sites) + `,`,
		`OtherConnectedSiteMeshGroupSites:` + fmt.Sprintf("%v", this.OtherConnectedSiteMeshGroupSites) + `,`,
		`LinkStatusSummary:` + repeatedStringForLinkStatusSummary + `,`,
		`EdgeStatusSummary:` + repeatedStringForEdgeStatusSummary + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeTypeSiteMeshGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeTypeSiteMeshGroup{`,
		`Info:` + strings.Replace(fmt.Sprintf("%v", this.Info), "SiteMeshGroupType", "SiteMeshGroupType", 1) + `,`,
		`Summary:` + strings.Replace(this.Summary.String(), "SiteMeshGroupSummaryInfo", "SiteMeshGroupSummaryInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DCClusterGroupSummaryInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DCClusterGroupSummaryInfo{`,
		`Sites:` + fmt.Sprintf("%v", this.Sites) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeTypeDCClusterGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeTypeDCClusterGroup{`,
		`Info:` + strings.Replace(fmt.Sprintf("%v", this.Info), "DCClusterGroupType", "DCClusterGroupType", 1) + `,`,
		`Summary:` + strings.Replace(this.Summary.String(), "DCClusterGroupSummaryInfo", "DCClusterGroupSummaryInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeTypeTransitGateway) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMetric := "[]*MetricData{"
	for _, f := range this.Metric {
		repeatedStringForMetric += strings.Replace(f.String(), "MetricData", "MetricData", 1) + ","
	}
	repeatedStringForMetric += "}"
	s := strings.Join([]string{`&NodeTypeTransitGateway{`,
		`Info:` + strings.Replace(fmt.Sprintf("%v", this.Info), "TransitGatewayType", "TransitGatewayType", 1) + `,`,
		`Metric:` + repeatedStringForMetric + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeTypeNetwork) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMetric := "[]*MetricData{"
	for _, f := range this.Metric {
		repeatedStringForMetric += strings.Replace(f.String(), "MetricData", "MetricData", 1) + ","
	}
	repeatedStringForMetric += "}"
	s := strings.Join([]string{`&NodeTypeNetwork{`,
		`Info:` + strings.Replace(fmt.Sprintf("%v", this.Info), "NetworkType", "NetworkType", 1) + `,`,
		`Metric:` + repeatedStringForMetric + `,`,
		`Summary:` + strings.Replace(this.Summary.String(), "NetworkSummaryInfo", "NetworkSummaryInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeTypeSubnet) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMetric := "[]*MetricData{"
	for _, f := range this.Metric {
		repeatedStringForMetric += strings.Replace(f.String(), "MetricData", "MetricData", 1) + ","
	}
	repeatedStringForMetric += "}"
	s := strings.Join([]string{`&NodeTypeSubnet{`,
		`Info:` + strings.Replace(fmt.Sprintf("%v", this.Info), "SubnetType", "SubnetType", 1) + `,`,
		`Metric:` + repeatedStringForMetric + `,`,
		`Summary:` + strings.Replace(this.Summary.String(), "SubnetSummaryInfo", "SubnetSummaryInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeTypeInstance) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMetric := "[]*MetricData{"
	for _, f := range this.Metric {
		repeatedStringForMetric += strings.Replace(f.String(), "MetricData", "MetricData", 1) + ","
	}
	repeatedStringForMetric += "}"
	s := strings.Join([]string{`&NodeTypeInstance{`,
		`Info:` + strings.Replace(fmt.Sprintf("%v", this.Info), "InstanceType", "InstanceType", 1) + `,`,
		`Metric:` + repeatedStringForMetric + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeMetaData) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&NodeMetaData{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Level:` + fmt.Sprintf("%v", this.Level) + `,`,
		`ProviderType:` + fmt.Sprintf("%v", this.ProviderType) + `,`,
		`OwnerId:` + fmt.Sprintf("%v", this.OwnerId) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`CloudResourceId:` + fmt.Sprintf("%v", this.CloudResourceId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Metadata:` + strings.Replace(this.Metadata.String(), "NodeMetaData", "NodeMetaData", 1) + `,`,
		`NodeType:` + fmt.Sprintf("%v", this.NodeType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node_Site) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node_Site{`,
		`Site:` + strings.Replace(fmt.Sprintf("%v", this.Site), "NodeTypeSite", "NodeTypeSite", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node_TransitGateway) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node_TransitGateway{`,
		`TransitGateway:` + strings.Replace(fmt.Sprintf("%v", this.TransitGateway), "NodeTypeTransitGateway", "NodeTypeTransitGateway", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node_Network) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node_Network{`,
		`Network:` + strings.Replace(fmt.Sprintf("%v", this.Network), "NodeTypeNetwork", "NodeTypeNetwork", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node_Subnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node_Subnet{`,
		`Subnet:` + strings.Replace(fmt.Sprintf("%v", this.Subnet), "NodeTypeSubnet", "NodeTypeSubnet", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node_Instance) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node_Instance{`,
		`Instance:` + strings.Replace(fmt.Sprintf("%v", this.Instance), "NodeTypeInstance", "NodeTypeInstance", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node_SiteMeshGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node_SiteMeshGroup{`,
		`SiteMeshGroup:` + strings.Replace(fmt.Sprintf("%v", this.SiteMeshGroup), "NodeTypeSiteMeshGroup", "NodeTypeSiteMeshGroup", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node_DcClusterGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node_DcClusterGroup{`,
		`DcClusterGroup:` + strings.Replace(fmt.Sprintf("%v", this.DcClusterGroup), "NodeTypeDCClusterGroup", "NodeTypeDCClusterGroup", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LinkInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LinkInfo{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`SrcId:` + fmt.Sprintf("%v", this.SrcId) + `,`,
		`DstId:` + fmt.Sprintf("%v", this.DstId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LinkInfoSummary) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LinkInfoSummary{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LinkTypeData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMetric := "[]*MetricData{"
	for _, f := range this.Metric {
		repeatedStringForMetric += strings.Replace(f.String(), "MetricData", "MetricData", 1) + ","
	}
	repeatedStringForMetric += "}"
	s := strings.Join([]string{`&LinkTypeData{`,
		`Info:` + strings.Replace(this.Info.String(), "LinkInfo", "LinkInfo", 1) + `,`,
		`Metric:` + repeatedStringForMetric + `,`,
		`}`,
	}, "")
	return s
}
func (this *EdgeInfoSummary) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EdgeInfoSummary{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Edge) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLinks := "[]*LinkTypeData{"
	for _, f := range this.Links {
		repeatedStringForLinks += strings.Replace(f.String(), "LinkTypeData", "LinkTypeData", 1) + ","
	}
	repeatedStringForLinks += "}"
	s := strings.Join([]string{`&Edge{`,
		`NodeId1:` + fmt.Sprintf("%v", this.NodeId1) + `,`,
		`NodeId2:` + fmt.Sprintf("%v", this.NodeId2) + `,`,
		`Links:` + repeatedStringForLinks + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringPublicCustomDataApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *SiteTopologyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteTopologyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteTopologyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSiteMeshNodes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GroupSiteMeshNodes = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupDcClusterNodes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GroupDcClusterNodes = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetricSelector == nil {
				m.MetricSelector = &MetricSelector{}
			}
			if err := m.MetricSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteMeshGroupsSummaryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteMeshGroupsSummaryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteMeshGroupsSummaryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteMeshTopologyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteMeshTopologyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteMeshTopologyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteMeshGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteMeshGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetricSelector == nil {
				m.MetricSelector = &MetricSelector{}
			}
			if err := m.MetricSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DCClusterGroupsSummaryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DCClusterGroupsSummaryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DCClusterGroupsSummaryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DCClusterTopologyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DCClusterTopologyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DCClusterTopologyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DcClusterGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetricSelector == nil {
				m.MetricSelector = &MetricSelector{}
			}
			if err := m.MetricSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopologyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopologyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopologyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Edges = append(m.Edges, &Edge{})
			if err := m.Edges[len(m.Edges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Step = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &RouteTableMetaData{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RouteTable == nil {
				m.RouteTable = &RouteTableType{}
			}
			if err := m.RouteTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v MetricType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomDataApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= MetricType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Node = append(m.Node, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomDataApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPublicCustomDataApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPublicCustomDataApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Node) == 0 {
					m.Node = make([]MetricType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v MetricType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomDataApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= MetricType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Node = append(m.Node, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
		case 4:
			if wireType == 0 {
				var v MetricType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomDataApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= MetricType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Edge = append(m.Edge, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomDataApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPublicCustomDataApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPublicCustomDataApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Edge) == 0 {
					m.Edge = make([]MetricType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v MetricType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomDataApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= MetricType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Edge = append(m.Edge, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Edge", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Step = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricTypeData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricTypeData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricTypeData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomDataApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomDataApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomDataApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomDataApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomDataApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPublicCustomDataApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPublicCustomDataApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomDataApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &schema.MetricValue{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MetricType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &MetricTypeData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			m.Unit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unit |= schema.UnitType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableMetaData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableMetaData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableMetaData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomDataApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomDataApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomDataApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomDataApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomDataApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPublicCustomDataApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPublicCustomDataApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomDataApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudResourceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudResourceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteSummaryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteSummaryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteSummaryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeCount", wireType)
			}
			m.NodeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZone = append(m.AvailabilityZone, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkSummaryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkSummaryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkSummaryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTables = append(m.RouteTables, &RouteTableMetaData{})
			if err := m.RouteTables[len(m.RouteTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetSummaryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetSummaryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetSummaryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTables = append(m.RouteTables, &RouteTableMetaData{})
			if err := m.RouteTables[len(m.RouteTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeTypeSite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeTypeSite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeTypeSite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &SiteType{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metric = append(m.Metric, &MetricData{})
			if err := m.Metric[len(m.Metric)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Summary == nil {
				m.Summary = &SiteSummaryInfo{}
			}
			if err := m.Summary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteMeshGroupSummaryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteMeshGroupSummaryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteMeshGroupSummaryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sites", wireType)
			}
			m.Sites = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sites |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherConnectedSiteMeshGroupSites", wireType)
			}
			m.OtherConnectedSiteMeshGroupSites = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OtherConnectedSiteMeshGroupSites |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkStatusSummary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkStatusSummary = append(m.LinkStatusSummary, &LinkInfoSummary{})
			if err := m.LinkStatusSummary[len(m.LinkStatusSummary)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeStatusSummary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeStatusSummary = append(m.EdgeStatusSummary, &EdgeInfoSummary{})
			if err := m.EdgeStatusSummary[len(m.EdgeStatusSummary)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeTypeSiteMeshGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeTypeSiteMeshGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeTypeSiteMeshGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &SiteMeshGroupType{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Summary == nil {
				m.Summary = &SiteMeshGroupSummaryInfo{}
			}
			if err := m.Summary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DCClusterGroupSummaryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DCClusterGroupSummaryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DCClusterGroupSummaryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sites", wireType)
			}
			m.Sites = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sites |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeTypeDCClusterGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeTypeDCClusterGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeTypeDCClusterGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &DCClusterGroupType{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Summary == nil {
				m.Summary = &DCClusterGroupSummaryInfo{}
			}
			if err := m.Summary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeTypeTransitGateway) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeTypeTransitGateway: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeTypeTransitGateway: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &TransitGatewayType{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metric = append(m.Metric, &MetricData{})
			if err := m.Metric[len(m.Metric)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeTypeNetwork) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeTypeNetwork: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeTypeNetwork: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &NetworkType{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metric = append(m.Metric, &MetricData{})
			if err := m.Metric[len(m.Metric)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Summary == nil {
				m.Summary = &NetworkSummaryInfo{}
			}
			if err := m.Summary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeTypeSubnet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeTypeSubnet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeTypeSubnet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &SubnetType{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metric = append(m.Metric, &MetricData{})
			if err := m.Metric[len(m.Metric)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Summary == nil {
				m.Summary = &SubnetSummaryInfo{}
			}
			if err := m.Summary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeTypeInstance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeTypeInstance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeTypeInstance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &InstanceType{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metric = append(m.Metric, &MetricData{})
			if err := m.Metric[len(m.Metric)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeMetaData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeMetaData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeMetaData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderType", wireType)
			}
			m.ProviderType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProviderType |= ProviderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomDataApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomDataApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomDataApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomDataApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomDataApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPublicCustomDataApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPublicCustomDataApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomDataApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudResourceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudResourceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &NodeMetaData{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NodeTypeSite{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeType = &Node_Site{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransitGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NodeTypeTransitGateway{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeType = &Node_TransitGateway{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NodeTypeNetwork{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeType = &Node_Network{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NodeTypeSubnet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeType = &Node_Subnet{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NodeTypeInstance{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeType = &Node_Instance{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteMeshGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NodeTypeSiteMeshGroup{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeType = &Node_SiteMeshGroup{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NodeTypeDCClusterGroup{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeType = &Node_DcClusterGroup{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LinkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= LinkStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkInfoSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkInfoSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkInfoSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LinkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= LinkStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkTypeData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkTypeData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkTypeData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &LinkInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metric = append(m.Metric, &MetricData{})
			if err := m.Metric[len(m.Metric)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeInfoSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeInfoSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeInfoSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= LinkStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Edge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Edge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Edge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, &LinkTypeData{})
			if err := m.Links[len(m.Links)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= LinkStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomDataApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomDataApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPublicCustomDataApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPublicCustomDataApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicCustomDataApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPublicCustomDataApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPublicCustomDataApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPublicCustomDataApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPublicCustomDataApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPublicCustomDataApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPublicCustomDataApi = fmt.Errorf("proto: unexpected end of group")
)
