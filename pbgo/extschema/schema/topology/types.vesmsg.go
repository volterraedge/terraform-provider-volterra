// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package topology

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_site_mesh_group "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/site_mesh_group"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AWSPolicyType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSPolicyType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSPolicyType) DeepCopy() *AWSPolicyType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSPolicyType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSPolicyType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSPolicyType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSPolicyTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSPolicyType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSPolicyType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSPolicyType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSPolicyType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["missing_permissions_aws_tgw_site"]; exists {

		vOpts := append(opts, db.WithValidateField("missing_permissions_aws_tgw_site"))
		for idx, item := range m.GetMissingPermissionsAwsTgwSite() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["missing_permissions_aws_vpc_site"]; exists {

		vOpts := append(opts, db.WithValidateField("missing_permissions_aws_vpc_site"))
		for idx, item := range m.GetMissingPermissionsAwsVpcSite() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["support_aws_tgw_site"]; exists {

		vOpts := append(opts, db.WithValidateField("support_aws_tgw_site"))
		if err := fv(ctx, m.GetSupportAwsTgwSite(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["support_aws_vpc_site"]; exists {

		vOpts := append(opts, db.WithValidateField("support_aws_vpc_site"))
		if err := fv(ctx, m.GetSupportAwsVpcSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSPolicyTypeValidator = func() *ValidateAWSPolicyType {
	v := &ValidateAWSPolicyType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AWSPolicyTypeValidator() db.Validator {
	return DefaultAWSPolicyTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AddressInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AddressInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AddressInfoType) DeepCopy() *AddressInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AddressInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AddressInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AddressInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AddressInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAddressInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAddressInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AddressInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AddressInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_name"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_name"))
		if err := fv(ctx, m.GetDnsName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["primary"]; exists {

		vOpts := append(opts, db.WithValidateField("primary"))
		if err := fv(ctx, m.GetPrimary(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAddressInfoTypeValidator = func() *ValidateAddressInfoType {
	v := &ValidateAddressInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AddressInfoTypeValidator() db.Validator {
	return DefaultAddressInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureVnetPeer) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureVnetPeer) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureVnetPeer) DeepCopy() *AzureVnetPeer {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureVnetPeer{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureVnetPeer) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureVnetPeer) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureVnetPeerValidator().Validate(ctx, m, opts...)
}

func (m *AzureVnetPeer) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetPeerNetworkDRefInfo()

}

func (m *AzureVnetPeer) GetPeerNetworkDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetPeerNetwork()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("AzureVnetPeer.peer_network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "peer_network",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetPeerNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *AzureVnetPeer) GetPeerNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_network")
	}
	for _, ref := range m.GetPeerNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateAzureVnetPeer struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureVnetPeer) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureVnetPeer)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureVnetPeer got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["peer_network"]; exists {

		vOpts := append(opts, db.WithValidateField("peer_network"))
		for idx, item := range m.GetPeerNetwork() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["peering_state"]; exists {

		vOpts := append(opts, db.WithValidateField("peering_state"))
		if err := fv(ctx, m.GetPeeringState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureVnetPeerValidator = func() *ValidateAzureVnetPeer {
	v := &ValidateAzureVnetPeer{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AzureVnetPeerValidator() db.Validator {
	return DefaultAzureVnetPeerValidator
}

// augmented methods on protoc/std generated struct

func (m *CloudPolicyType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CloudPolicyType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CloudPolicyType) DeepCopy() *CloudPolicyType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CloudPolicyType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CloudPolicyType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CloudPolicyType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CloudPolicyTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCloudPolicyType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCloudPolicyType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CloudPolicyType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CloudPolicyType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cloud_provider_error"]; exists {

		vOpts := append(opts, db.WithValidateField("cloud_provider_error"))
		if err := fv(ctx, m.GetCloudProviderError(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetCloudType().(type) {
	case *CloudPolicyType_Aws:
		if fv, exists := v.FldValidators["cloud_type.aws"]; exists {
			val := m.GetCloudType().(*CloudPolicyType_Aws).Aws
			vOpts := append(opts,
				db.WithValidateField("cloud_type"),
				db.WithValidateField("aws"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["permissions_populated"]; exists {

		vOpts := append(opts, db.WithValidateField("permissions_populated"))
		if err := fv(ctx, m.GetPermissionsPopulated(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCloudPolicyTypeValidator = func() *ValidateCloudPolicyType {
	v := &ValidateCloudPolicyType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CloudPolicyTypeValidator() db.Validator {
	return DefaultCloudPolicyTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DCClusterGroupType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DCClusterGroupType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DCClusterGroupType) DeepCopy() *DCClusterGroupType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DCClusterGroupType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DCClusterGroupType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DCClusterGroupType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DCClusterGroupTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDCClusterGroupType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDCClusterGroupType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DCClusterGroupType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DCClusterGroupType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDCClusterGroupTypeValidator = func() *ValidateDCClusterGroupType {
	v := &ValidateDCClusterGroupType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DCClusterGroupTypeValidator() db.Validator {
	return DefaultDCClusterGroupTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *InstanceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InstanceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InstanceType) DeepCopy() *InstanceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InstanceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InstanceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InstanceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InstanceTypeValidator().Validate(ctx, m, opts...)
}

func (m *InstanceType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetInterfacesDRefInfo()

}

// GetDRefInfo for the field's type
func (m *InstanceType) GetInterfacesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetInterfaces() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetInterfaces() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetInterfaces() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("interfaces[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateInstanceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInstanceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InstanceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InstanceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["architecture"]; exists {

		vOpts := append(opts, db.WithValidateField("architecture"))
		if err := fv(ctx, m.GetArchitecture(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["availability_zone"]; exists {

		vOpts := append(opts, db.WithValidateField("availability_zone"))
		if err := fv(ctx, m.GetAvailabilityZone(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cpu"]; exists {

		vOpts := append(opts, db.WithValidateField("cpu"))
		if err := fv(ctx, m.GetCpu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["instance_type"]; exists {

		vOpts := append(opts, db.WithValidateField("instance_type"))
		if err := fv(ctx, m.GetInstanceType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["interfaces"]; exists {

		vOpts := append(opts, db.WithValidateField("interfaces"))
		for idx, item := range m.GetInterfaces() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["platform"]; exists {

		vOpts := append(opts, db.WithValidateField("platform"))
		if err := fv(ctx, m.GetPlatform(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["private_address"]; exists {

		vOpts := append(opts, db.WithValidateField("private_address"))
		if err := fv(ctx, m.GetPrivateAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["private_dns_name"]; exists {

		vOpts := append(opts, db.WithValidateField("private_dns_name"))
		if err := fv(ctx, m.GetPrivateDnsName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_address"]; exists {

		vOpts := append(opts, db.WithValidateField("public_address"))
		if err := fv(ctx, m.GetPublicAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_dns_name"]; exists {

		vOpts := append(opts, db.WithValidateField("public_dns_name"))
		if err := fv(ctx, m.GetPublicDnsName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["security_group"]; exists {

		vOpts := append(opts, db.WithValidateField("security_group"))
		for idx, item := range m.GetSecurityGroup() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInstanceTypeValidator = func() *ValidateInstanceType {
	v := &ValidateInstanceType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func InstanceTypeValidator() db.Validator {
	return DefaultInstanceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *LoadBalancer) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LoadBalancer) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LoadBalancer) DeepCopy() *LoadBalancer {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LoadBalancer{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LoadBalancer) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LoadBalancer) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LoadBalancerValidator().Validate(ctx, m, opts...)
}

type ValidateLoadBalancer struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLoadBalancer) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LoadBalancer)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LoadBalancer got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLoadBalancerValidator = func() *ValidateLoadBalancer {
	v := &ValidateLoadBalancer{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LoadBalancerValidator() db.Validator {
	return DefaultLoadBalancerValidator
}

// augmented methods on protoc/std generated struct

func (m *MetaType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MetaType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MetaType) DeepCopy() *MetaType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MetaType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MetaType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MetaType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MetaTypeValidator().Validate(ctx, m, opts...)
}

func (m *MetaType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetCredsDRefInfo()

}

func (m *MetaType) GetCredsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetCreds()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("MetaType.creds[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "cloud_credentials.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "creds",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetCredsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *MetaType) GetCredsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "cloud_credentials.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: cloud_credentials")
	}
	for _, ref := range m.GetCreds() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateMetaType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMetaType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MetaType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MetaType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["creds"]; exists {

		vOpts := append(opts, db.WithValidateField("creds"))
		for idx, item := range m.GetCreds() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["owner_id"]; exists {

		vOpts := append(opts, db.WithValidateField("owner_id"))
		if err := fv(ctx, m.GetOwnerId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provider_type"]; exists {

		vOpts := append(opts, db.WithValidateField("provider_type"))
		if err := fv(ctx, m.GetProviderType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["raw_json"]; exists {

		vOpts := append(opts, db.WithValidateField("raw_json"))
		if err := fv(ctx, m.GetRawJson(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tags"]; exists {

		vOpts := append(opts, db.WithValidateField("tags"))
		for key, value := range m.GetTags() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMetaTypeValidator = func() *ValidateMetaType {
	v := &ValidateMetaType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MetaTypeValidator() db.Validator {
	return DefaultMetaTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkInterfaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkInterfaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkInterfaceType) DeepCopy() *NetworkInterfaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkInterfaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkInterfaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkInterfaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkInterfaceTypeValidator().Validate(ctx, m, opts...)
}

func (m *NetworkInterfaceType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetSubnetDRefInfo()

}

func (m *NetworkInterfaceType) GetSubnetDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetSubnet()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("NetworkInterfaceType.subnet[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_subnet.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "subnet",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetSubnetDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *NetworkInterfaceType) GetSubnetDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_subnet.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_subnet")
	}
	for _, ref := range m.GetSubnet() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateNetworkInterfaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkInterfaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkInterfaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkInterfaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["private_addresses"]; exists {

		vOpts := append(opts, db.WithValidateField("private_addresses"))
		for idx, item := range m.GetPrivateAddresses() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["public_address"]; exists {

		vOpts := append(opts, db.WithValidateField("public_address"))
		for idx, item := range m.GetPublicAddress() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["security_group"]; exists {

		vOpts := append(opts, db.WithValidateField("security_group"))
		for idx, item := range m.GetSecurityGroup() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("subnet"))
		for idx, item := range m.GetSubnet() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkInterfaceTypeValidator = func() *ValidateNetworkInterfaceType {
	v := &ValidateNetworkInterfaceType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NetworkInterfaceTypeValidator() db.Validator {
	return DefaultNetworkInterfaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkPeerType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkPeerType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkPeerType) DeepCopy() *NetworkPeerType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkPeerType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkPeerType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkPeerType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkPeerTypeValidator().Validate(ctx, m, opts...)
}

func (m *NetworkPeerType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetPeerChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *NetworkPeerType) GetPeerChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetPeerChoice() == nil {
		return nil, nil
	}
	switch m.GetPeerChoice().(type) {
	case *NetworkPeerType_VnetPeer:

		drInfos, err := m.GetVnetPeer().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVnetPeer().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "vnet_peer." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateNetworkPeerType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkPeerType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkPeerType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkPeerType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetPeerChoice().(type) {
	case *NetworkPeerType_VnetPeer:
		if fv, exists := v.FldValidators["peer_choice.vnet_peer"]; exists {
			val := m.GetPeerChoice().(*NetworkPeerType_VnetPeer).VnetPeer
			vOpts := append(opts,
				db.WithValidateField("peer_choice"),
				db.WithValidateField("vnet_peer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkPeerTypeValidator = func() *ValidateNetworkPeerType {
	v := &ValidateNetworkPeerType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NetworkPeerTypeValidator() db.Validator {
	return DefaultNetworkPeerTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkType) DeepCopy() *NetworkType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkTypeValidator().Validate(ctx, m, opts...)
}

func (m *NetworkType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetNetworkPeersDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetNetworkPeersDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRegionDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRegionDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *NetworkType) GetNetworkPeersDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetNetworkPeers()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("NetworkType.network_peers[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_network_peer.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "network_peers",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetNetworkPeersDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *NetworkType) GetNetworkPeersDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_network_peer.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_network_peer")
	}
	for _, ref := range m.GetNetworkPeers() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *NetworkType) GetRegionDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRegion()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("NetworkType.region[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_region.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "region",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRegionDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *NetworkType) GetRegionDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_region.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_region")
	}
	for _, ref := range m.GetRegion() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateNetworkType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cidr_v4"]; exists {

		vOpts := append(opts, db.WithValidateField("cidr_v4"))
		for idx, item := range m.GetCidrV4() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["cidr_v6"]; exists {

		vOpts := append(opts, db.WithValidateField("cidr_v6"))
		for idx, item := range m.GetCidrV6() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["load_balancer"]; exists {

		vOpts := append(opts, db.WithValidateField("load_balancer"))
		for idx, item := range m.GetLoadBalancer() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["network_peers"]; exists {

		vOpts := append(opts, db.WithValidateField("network_peers"))
		for idx, item := range m.GetNetworkPeers() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["region"]; exists {

		vOpts := append(opts, db.WithValidateField("region"))
		for idx, item := range m.GetRegion() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkTypeValidator = func() *ValidateNetworkType {
	v := &ValidateNetworkType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NetworkTypeValidator() db.Validator {
	return DefaultNetworkTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteTableType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteTableType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteTableType) DeepCopy() *RouteTableType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteTableType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteTableType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteTableType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteTableTypeValidator().Validate(ctx, m, opts...)
}

func (m *RouteTableType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetExplicitSubnetDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetExplicitSubnetDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetImplicitSubnetDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetImplicitSubnetDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNetworkDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetNetworkDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetSubnetDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSubnetDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTransitGatewayDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTransitGatewayDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *RouteTableType) GetExplicitSubnetDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetExplicitSubnet()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("RouteTableType.explicit_subnet[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_subnet.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "explicit_subnet",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetExplicitSubnetDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *RouteTableType) GetExplicitSubnetDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_subnet.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_subnet")
	}
	for _, ref := range m.GetExplicitSubnet() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *RouteTableType) GetImplicitSubnetDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetImplicitSubnet()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("RouteTableType.implicit_subnet[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_subnet.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "implicit_subnet",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetImplicitSubnetDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *RouteTableType) GetImplicitSubnetDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_subnet.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_subnet")
	}
	for _, ref := range m.GetImplicitSubnet() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *RouteTableType) GetNetworkDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetNetwork()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("RouteTableType.network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "network",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *RouteTableType) GetNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_network")
	}
	for _, ref := range m.GetNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *RouteTableType) GetSubnetDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetSubnet()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("RouteTableType.subnet[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_subnet.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "subnet",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetSubnetDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *RouteTableType) GetSubnetDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_subnet.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_subnet")
	}
	for _, ref := range m.GetSubnet() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *RouteTableType) GetTransitGatewayDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetTransitGateway()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("RouteTableType.transit_gateway[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_transit_gateway.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "transit_gateway",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetTransitGatewayDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *RouteTableType) GetTransitGatewayDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_transit_gateway.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_transit_gateway")
	}
	for _, ref := range m.GetTransitGateway() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateRouteTableType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteTableType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteTableType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteTableType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["explicit_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("explicit_subnet"))
		for idx, item := range m.GetExplicitSubnet() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["implicit_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("implicit_subnet"))
		for idx, item := range m.GetImplicitSubnet() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["network"]; exists {

		vOpts := append(opts, db.WithValidateField("network"))
		for idx, item := range m.GetNetwork() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["route_table_type"]; exists {

		vOpts := append(opts, db.WithValidateField("route_table_type"))
		if err := fv(ctx, m.GetRouteTableType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["routes"]; exists {

		vOpts := append(opts, db.WithValidateField("routes"))
		for idx, item := range m.GetRoutes() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("subnet"))
		for idx, item := range m.GetSubnet() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["transit_gateway"]; exists {

		vOpts := append(opts, db.WithValidateField("transit_gateway"))
		for idx, item := range m.GetTransitGateway() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteTableTypeValidator = func() *ValidateRouteTableType {
	v := &ValidateRouteTableType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func RouteTableTypeValidator() db.Validator {
	return DefaultRouteTableTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteType) DeepCopy() *RouteType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteTypeValidator().Validate(ctx, m, opts...)
}

type ValidateRouteType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["destination"]; exists {

		vOpts := append(opts, db.WithValidateField("destination"))
		if err := fv(ctx, m.GetDestination(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["next_hop_type"]; exists {

		vOpts := append(opts, db.WithValidateField("next_hop_type"))
		if err := fv(ctx, m.GetNextHopType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["nexthop"]; exists {

		vOpts := append(opts, db.WithValidateField("nexthop"))
		if err := fv(ctx, m.GetNexthop(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["source"]; exists {

		vOpts := append(opts, db.WithValidateField("source"))
		if err := fv(ctx, m.GetSource(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_defined_route_name"]; exists {

		vOpts := append(opts, db.WithValidateField("user_defined_route_name"))
		if err := fv(ctx, m.GetUserDefinedRouteName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteTypeValidator = func() *ValidateRouteType {
	v := &ValidateRouteType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func RouteTypeValidator() db.Validator {
	return DefaultRouteTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteMeshGroupType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteMeshGroupType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteMeshGroupType) DeepCopy() *SiteMeshGroupType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteMeshGroupType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteMeshGroupType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteMeshGroupType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteMeshGroupTypeValidator().Validate(ctx, m, opts...)
}

func (m *SiteMeshGroupType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetHubDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetHubDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetMeshChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetMeshChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTopologySiteDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTopologySiteDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetVirtualSiteDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetVirtualSiteDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *SiteMeshGroupType) GetHubDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetHub()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("SiteMeshGroupType.hub[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_site_mesh_group.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "hub",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetHubDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SiteMeshGroupType) GetHubDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_site_mesh_group.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_site_mesh_group")
	}
	for _, ref := range m.GetHub() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *SiteMeshGroupType) GetMeshChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetMeshChoice() == nil {
		return nil, nil
	}
	switch m.GetMeshChoice().(type) {
	case *SiteMeshGroupType_HubMesh:

		return nil, nil

	case *SiteMeshGroupType_SpokeMesh:

		drInfos, err := m.GetSpokeMesh().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSpokeMesh().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "spoke_mesh." + dri.DRField
		}
		return drInfos, err

	case *SiteMeshGroupType_FullMesh:

		return nil, nil

	default:
		return nil, nil
	}

}

func (m *SiteMeshGroupType) GetTopologySiteDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetTopologySite()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("SiteMeshGroupType.topology_site[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "topology_site",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetTopologySiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SiteMeshGroupType) GetTopologySiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_site")
	}
	for _, ref := range m.GetTopologySite() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *SiteMeshGroupType) GetVirtualSiteDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetVirtualSite()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("SiteMeshGroupType.virtual_site[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "virtual_site",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetVirtualSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SiteMeshGroupType) GetVirtualSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_site")
	}
	for _, ref := range m.GetVirtualSite() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateSiteMeshGroupType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteMeshGroupType) VirtualSiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for virtual_site")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for virtual_site")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated virtual_site")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items virtual_site")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSiteMeshGroupType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteMeshGroupType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteMeshGroupType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["hub"]; exists {

		vOpts := append(opts, db.WithValidateField("hub"))
		for idx, item := range m.GetHub() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetMeshChoice().(type) {
	case *SiteMeshGroupType_HubMesh:
		if fv, exists := v.FldValidators["mesh_choice.hub_mesh"]; exists {
			val := m.GetMeshChoice().(*SiteMeshGroupType_HubMesh).HubMesh
			vOpts := append(opts,
				db.WithValidateField("mesh_choice"),
				db.WithValidateField("hub_mesh"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SiteMeshGroupType_SpokeMesh:
		if fv, exists := v.FldValidators["mesh_choice.spoke_mesh"]; exists {
			val := m.GetMeshChoice().(*SiteMeshGroupType_SpokeMesh).SpokeMesh
			vOpts := append(opts,
				db.WithValidateField("mesh_choice"),
				db.WithValidateField("spoke_mesh"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SiteMeshGroupType_FullMesh:
		if fv, exists := v.FldValidators["mesh_choice.full_mesh"]; exists {
			val := m.GetMeshChoice().(*SiteMeshGroupType_FullMesh).FullMesh
			vOpts := append(opts,
				db.WithValidateField("mesh_choice"),
				db.WithValidateField("full_mesh"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["site_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_type"))
		if err := fv(ctx, m.GetSiteType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["topology_site"]; exists {

		vOpts := append(opts, db.WithValidateField("topology_site"))
		for idx, item := range m.GetTopologySite() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["virtual_site"]; exists {
		vOpts := append(opts, db.WithValidateField("virtual_site"))
		if err := fv(ctx, m.GetVirtualSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteMeshGroupTypeValidator = func() *ValidateSiteMeshGroupType {
	v := &ValidateSiteMeshGroupType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVirtualSite := v.VirtualSiteValidationRuleHandler
	rulesVirtualSite := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhVirtualSite(rulesVirtualSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SiteMeshGroupType.virtual_site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["virtual_site"] = vFn

	v.FldValidators["mesh_choice.spoke_mesh"] = ves_io_schema_site_mesh_group.SpokeMeshGroupTypeValidator().Validate

	return v
}()

func SiteMeshGroupTypeValidator() db.Validator {
	return DefaultSiteMeshGroupTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteType) DeepCopy() *SiteType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteTypeValidator().Validate(ctx, m, opts...)
}

func (m *SiteType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetDcClusterGroupDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDcClusterGroupDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNetworkDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetNetworkDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTgwDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTgwDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *SiteType) GetDcClusterGroupDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetDcClusterGroup()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("SiteType.dc_cluster_group[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_dc_cluster_group.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "dc_cluster_group",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetDcClusterGroupDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SiteType) GetDcClusterGroupDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_dc_cluster_group.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_dc_cluster_group")
	}
	for _, ref := range m.GetDcClusterGroup() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *SiteType) GetNetworkDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetNetwork()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("SiteType.network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "network",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SiteType) GetNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_network")
	}
	for _, ref := range m.GetNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *SiteType) GetTgwDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetTgw()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("SiteType.tgw[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_transit_gateway.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "tgw",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetTgwDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SiteType) GetTgwDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_transit_gateway.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_transit_gateway")
	}
	for _, ref := range m.GetTgw() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateSiteType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dc_cluster_group"]; exists {

		vOpts := append(opts, db.WithValidateField("dc_cluster_group"))
		for idx, item := range m.GetDcClusterGroup() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["network"]; exists {

		vOpts := append(opts, db.WithValidateField("network"))
		for idx, item := range m.GetNetwork() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["site_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_type"))
		if err := fv(ctx, m.GetSiteType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tgw"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw"))
		for idx, item := range m.GetTgw() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteTypeValidator = func() *ValidateSiteType {
	v := &ValidateSiteType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SiteTypeValidator() db.Validator {
	return DefaultSiteTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SubnetType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SubnetType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SubnetType) DeepCopy() *SubnetType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SubnetType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SubnetType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SubnetType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SubnetTypeValidator().Validate(ctx, m, opts...)
}

func (m *SubnetType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetNetworkDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetNetworkDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRegionDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRegionDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *SubnetType) GetNetworkDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetNetwork()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("SubnetType.network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "network",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SubnetType) GetNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_network")
	}
	for _, ref := range m.GetNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *SubnetType) GetRegionDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRegion()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("SubnetType.region[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_region.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "region",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRegionDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SubnetType) GetRegionDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_region.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_region")
	}
	for _, ref := range m.GetRegion() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateSubnetType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSubnetType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SubnetType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SubnetType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["availability_zone"]; exists {

		vOpts := append(opts, db.WithValidateField("availability_zone"))
		if err := fv(ctx, m.GetAvailabilityZone(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cidr_v4"]; exists {

		vOpts := append(opts, db.WithValidateField("cidr_v4"))
		for idx, item := range m.GetCidrV4() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["cidr_v6"]; exists {

		vOpts := append(opts, db.WithValidateField("cidr_v6"))
		for idx, item := range m.GetCidrV6() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["interface_type"]; exists {

		vOpts := append(opts, db.WithValidateField("interface_type"))
		if err := fv(ctx, m.GetInterfaceType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network"]; exists {

		vOpts := append(opts, db.WithValidateField("network"))
		for idx, item := range m.GetNetwork() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["region"]; exists {

		vOpts := append(opts, db.WithValidateField("region"))
		for idx, item := range m.GetRegion() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSubnetTypeValidator = func() *ValidateSubnetType {
	v := &ValidateSubnetType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SubnetTypeValidator() db.Validator {
	return DefaultSubnetTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TransitGatewayType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TransitGatewayType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TransitGatewayType) DeepCopy() *TransitGatewayType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TransitGatewayType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TransitGatewayType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TransitGatewayType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TransitGatewayTypeValidator().Validate(ctx, m, opts...)
}

func (m *TransitGatewayType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetNetworkDRefInfo()

}

func (m *TransitGatewayType) GetNetworkDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetNetwork()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("TransitGatewayType.network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "network",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *TransitGatewayType) GetNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_network")
	}
	for _, ref := range m.GetNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateTransitGatewayType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTransitGatewayType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TransitGatewayType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TransitGatewayType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["auto_accept_shared_attachments"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_accept_shared_attachments"))
		if err := fv(ctx, m.GetAutoAcceptSharedAttachments(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_support"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_support"))
		if err := fv(ctx, m.GetDnsSupport(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network"]; exists {

		vOpts := append(opts, db.WithValidateField("network"))
		for idx, item := range m.GetNetwork() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["vpn_ecmp_support"]; exists {

		vOpts := append(opts, db.WithValidateField("vpn_ecmp_support"))
		if err := fv(ctx, m.GetVpnEcmpSupport(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTransitGatewayTypeValidator = func() *ValidateTransitGatewayType {
	v := &ValidateTransitGatewayType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func TransitGatewayTypeValidator() db.Validator {
	return DefaultTransitGatewayTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TunnelSetType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TunnelSetType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TunnelSetType) DeepCopy() *TunnelSetType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TunnelSetType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TunnelSetType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TunnelSetType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TunnelSetTypeValidator().Validate(ctx, m, opts...)
}

func (m *TunnelSetType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetSiteDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSiteDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTunnelsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTunnelsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *TunnelSetType) GetSiteDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetSite()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("TunnelSetType.site[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "site",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *TunnelSetType) GetSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_site")
	}
	for _, ref := range m.GetSite() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *TunnelSetType) GetTunnelsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTunnels() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetTunnels() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTunnels() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("tunnels[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateTunnelSetType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTunnelSetType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TunnelSetType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TunnelSetType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		for idx, item := range m.GetSite() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tunnels"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnels"))
		for idx, item := range m.GetTunnels() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTunnelSetTypeValidator = func() *ValidateTunnelSetType {
	v := &ValidateTunnelSetType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func TunnelSetTypeValidator() db.Validator {
	return DefaultTunnelSetTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TunnelType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TunnelType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TunnelType) DeepCopy() *TunnelType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TunnelType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TunnelType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TunnelType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TunnelTypeValidator().Validate(ctx, m, opts...)
}

func (m *TunnelType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetSiteDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSiteDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTgwDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTgwDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *TunnelType) GetSiteDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetSite()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("TunnelType.site[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "site",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *TunnelType) GetSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_site")
	}
	for _, ref := range m.GetSite() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *TunnelType) GetTgwDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetTgw()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("TunnelType.tgw[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "topology_transit_gateway.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "tgw",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetTgwDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *TunnelType) GetTgwDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "topology_transit_gateway.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: topology_transit_gateway")
	}
	for _, ref := range m.GetTgw() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateTunnelType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTunnelType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TunnelType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TunnelType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["connection"]; exists {

		vOpts := append(opts, db.WithValidateField("connection"))
		if err := fv(ctx, m.GetConnection(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		for idx, item := range m.GetSite() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tgw"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw"))
		for idx, item := range m.GetTgw() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTunnelTypeValidator = func() *ValidateTunnelType {
	v := &ValidateTunnelType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func TunnelTypeValidator() db.Validator {
	return DefaultTunnelTypeValidator
}
