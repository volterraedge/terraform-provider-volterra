// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/dns_load_balancer/types.proto

package dns_load_balancer

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Resource Record Type
//
// x-displayName: "Resource Record Type"
// Resource Record Type
type ResourceRecordType int32

const (
	// A
	//
	// x-displayName: "A"
	A ResourceRecordType = 0
	// AAAA
	//
	// x-displayName: "AAAA"
	AAAA ResourceRecordType = 1
	// MX
	//
	// x-displayName: "MX"
	MX ResourceRecordType = 2
	// CNAME
	//
	// x-displayName: "CNAME"
	CNAME ResourceRecordType = 3
	// SRV
	//
	// x-displayName: "SRV"
	SRV ResourceRecordType = 4
)

var ResourceRecordType_name = map[int32]string{
	0: "A",
	1: "AAAA",
	2: "MX",
	3: "CNAME",
	4: "SRV",
}

var ResourceRecordType_value = map[string]int32{
	"A":     0,
	"AAAA":  1,
	"MX":    2,
	"CNAME": 3,
	"SRV":   4,
}

func (ResourceRecordType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_01361f944871c627, []int{0}
}

// DNS Load Balancer Record
//
// x-displayName: "DNS Load Balancer Record"
// Desired state of DNS Load Balancer Record
type GlobalSpecType struct {
	// Resource Record Type
	//
	// x-displayName: "Record Type"
	// x-required
	RecordType ResourceRecordType `protobuf:"varint,2,opt,name=record_type,json=recordType,proto3,enum=ves.io.schema.dns_load_balancer.ResourceRecordType" json:"record_type,omitempty"`
	// Rule List
	//
	// x-displayName: "Load Balancing Rule List"
	// x-required
	// Load Balancing Rules
	RuleList *LoadBalancingRuleList `protobuf:"bytes,3,opt,name=rule_list,json=ruleList,proto3" json:"rule_list,omitempty"`
	// Response Cache Parameters
	//
	// x-displayName: "Response Cache"
	// Response Cache Parameters
	ResponseCache *ResponseCache `protobuf:"bytes,4,opt,name=response_cache,json=responseCache,proto3" json:"response_cache,omitempty"`
	// backref_objs
	//
	// x-displayName: "DNS Zones"
	// a list of DNS Zones associated with this load balancer
	DnsZones []*views.ObjectRefType `protobuf:"bytes,5,rep,name=dns_zones,json=dnsZones,proto3" json:"dns_zones,omitempty"`
	// fallback pool
	//
	// x-displayName: "Fallback Pool"
	// Fallback Pool to be used for load balancing if none of the Load Balancing rules match
	FallbackPool *views.ObjectRefType `protobuf:"bytes,6,opt,name=fallback_pool,json=fallbackPool,proto3" json:"fallback_pool,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_01361f944871c627, []int{0}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetRecordType() ResourceRecordType {
	if m != nil {
		return m.RecordType
	}
	return A
}

func (m *GlobalSpecType) GetRuleList() *LoadBalancingRuleList {
	if m != nil {
		return m.RuleList
	}
	return nil
}

func (m *GlobalSpecType) GetResponseCache() *ResponseCache {
	if m != nil {
		return m.ResponseCache
	}
	return nil
}

func (m *GlobalSpecType) GetDnsZones() []*views.ObjectRefType {
	if m != nil {
		return m.DnsZones
	}
	return nil
}

func (m *GlobalSpecType) GetFallbackPool() *views.ObjectRefType {
	if m != nil {
		return m.FallbackPool
	}
	return nil
}

// Response Cache
//
// x-displayName: "Response Cache"
// Response Cache
// x-required
type ResponseCache struct {
	// Response Cache Parameters Choice
	//
	// x-displayName: "Response Cache Parameters Choice"
	// x-required
	// When Response Cache is enabled, clients will receive persistent answers
	//
	// Types that are valid to be assigned to ResponseCacheParametersChoice:
	//	*ResponseCache_Disable
	//	*ResponseCache_DefaultResponseCacheParameters
	//	*ResponseCache_ResponseCacheParameters
	ResponseCacheParametersChoice isResponseCache_ResponseCacheParametersChoice `protobuf_oneof:"response_cache_parameters_choice"`
}

func (m *ResponseCache) Reset()      { *m = ResponseCache{} }
func (*ResponseCache) ProtoMessage() {}
func (*ResponseCache) Descriptor() ([]byte, []int) {
	return fileDescriptor_01361f944871c627, []int{1}
}
func (m *ResponseCache) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseCache) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResponseCache) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseCache.Merge(m, src)
}
func (m *ResponseCache) XXX_Size() int {
	return m.Size()
}
func (m *ResponseCache) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseCache.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseCache proto.InternalMessageInfo

type isResponseCache_ResponseCacheParametersChoice interface {
	isResponseCache_ResponseCacheParametersChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ResponseCache_Disable struct {
	Disable *schema.Empty `protobuf:"bytes,2,opt,name=disable,proto3,oneof" json:"disable,omitempty"`
}
type ResponseCache_DefaultResponseCacheParameters struct {
	DefaultResponseCacheParameters *schema.Empty `protobuf:"bytes,3,opt,name=default_response_cache_parameters,json=defaultResponseCacheParameters,proto3,oneof" json:"default_response_cache_parameters,omitempty"`
}
type ResponseCache_ResponseCacheParameters struct {
	ResponseCacheParameters *ResponseCacheParameters `protobuf:"bytes,4,opt,name=response_cache_parameters,json=responseCacheParameters,proto3,oneof" json:"response_cache_parameters,omitempty"`
}

func (*ResponseCache_Disable) isResponseCache_ResponseCacheParametersChoice() {}
func (*ResponseCache_DefaultResponseCacheParameters) isResponseCache_ResponseCacheParametersChoice() {
}
func (*ResponseCache_ResponseCacheParameters) isResponseCache_ResponseCacheParametersChoice() {}

func (m *ResponseCache) GetResponseCacheParametersChoice() isResponseCache_ResponseCacheParametersChoice {
	if m != nil {
		return m.ResponseCacheParametersChoice
	}
	return nil
}

func (m *ResponseCache) GetDisable() *schema.Empty {
	if x, ok := m.GetResponseCacheParametersChoice().(*ResponseCache_Disable); ok {
		return x.Disable
	}
	return nil
}

func (m *ResponseCache) GetDefaultResponseCacheParameters() *schema.Empty {
	if x, ok := m.GetResponseCacheParametersChoice().(*ResponseCache_DefaultResponseCacheParameters); ok {
		return x.DefaultResponseCacheParameters
	}
	return nil
}

func (m *ResponseCache) GetResponseCacheParameters() *ResponseCacheParameters {
	if x, ok := m.GetResponseCacheParametersChoice().(*ResponseCache_ResponseCacheParameters); ok {
		return x.ResponseCacheParameters
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ResponseCache) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ResponseCache_Disable)(nil),
		(*ResponseCache_DefaultResponseCacheParameters)(nil),
		(*ResponseCache_ResponseCacheParameters)(nil),
	}
}

// Load Balancing Rule List
//
// x-displayName: "Load Balancing Rule List"
// List of the Load Balancing Rules
type LoadBalancingRuleList struct {
	// Load Balancing Rules
	//
	// x-displayName: "Load Balancing Rules"
	// x-required
	// Rules to perform load balancing
	Rules []*LoadBalancingRule `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
}

func (m *LoadBalancingRuleList) Reset()      { *m = LoadBalancingRuleList{} }
func (*LoadBalancingRuleList) ProtoMessage() {}
func (*LoadBalancingRuleList) Descriptor() ([]byte, []int) {
	return fileDescriptor_01361f944871c627, []int{2}
}
func (m *LoadBalancingRuleList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadBalancingRuleList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LoadBalancingRuleList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadBalancingRuleList.Merge(m, src)
}
func (m *LoadBalancingRuleList) XXX_Size() int {
	return m.Size()
}
func (m *LoadBalancingRuleList) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadBalancingRuleList.DiscardUnknown(m)
}

var xxx_messageInfo_LoadBalancingRuleList proto.InternalMessageInfo

func (m *LoadBalancingRuleList) GetRules() []*LoadBalancingRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// DNS Load Balancing Rule
//
// x-displayName: "Load Balancing Rule"
type LoadBalancingRule struct {
	// geo_location_choice
	//
	// x-displayName: "Geo Location Selection"
	// x-required
	// Selects the geo locations for which the DNS Load Balancing Rule will be applied. The conditions are limited to the geo location from
	// where the client DNS request originates. This geo location is derived from the EDNS-S0 client subnet.
	//
	// Types that are valid to be assigned to GeoLocationChoice:
	//	*LoadBalancingRule_GeoLocationLabelSelector
	//	*LoadBalancingRule_GeoLocationSet
	GeoLocationChoice isLoadBalancingRule_GeoLocationChoice `protobuf_oneof:"geo_location_choice"`
	// action choice
	//
	// x-required
	// x-displayName: "Action"
	// Action for the DNS Load Balancing Rule
	//
	// Types that are valid to be assigned to ActionChoice:
	//	*LoadBalancingRule_Pool
	//	*LoadBalancingRule_Nxdomain
	ActionChoice isLoadBalancingRule_ActionChoice `protobuf_oneof:"action_choice"`
	// Score
	//
	// x-displayName: "Score"
	// x-example: "50"
	// When multiple load balancing rules match a query, the one with the highest score is chosen
	Score uint32 `protobuf:"varint,7,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *LoadBalancingRule) Reset()      { *m = LoadBalancingRule{} }
func (*LoadBalancingRule) ProtoMessage() {}
func (*LoadBalancingRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_01361f944871c627, []int{3}
}
func (m *LoadBalancingRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadBalancingRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LoadBalancingRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadBalancingRule.Merge(m, src)
}
func (m *LoadBalancingRule) XXX_Size() int {
	return m.Size()
}
func (m *LoadBalancingRule) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadBalancingRule.DiscardUnknown(m)
}

var xxx_messageInfo_LoadBalancingRule proto.InternalMessageInfo

type isLoadBalancingRule_GeoLocationChoice interface {
	isLoadBalancingRule_GeoLocationChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isLoadBalancingRule_ActionChoice interface {
	isLoadBalancingRule_ActionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LoadBalancingRule_GeoLocationLabelSelector struct {
	GeoLocationLabelSelector *schema.LabelSelectorType `protobuf:"bytes,2,opt,name=geo_location_label_selector,json=geoLocationLabelSelector,proto3,oneof" json:"geo_location_label_selector,omitempty"`
}
type LoadBalancingRule_GeoLocationSet struct {
	GeoLocationSet *views.ObjectRefType `protobuf:"bytes,3,opt,name=geo_location_set,json=geoLocationSet,proto3,oneof" json:"geo_location_set,omitempty"`
}
type LoadBalancingRule_Pool struct {
	Pool *views.ObjectRefType `protobuf:"bytes,5,opt,name=pool,proto3,oneof" json:"pool,omitempty"`
}
type LoadBalancingRule_Nxdomain struct {
	Nxdomain *schema.Empty `protobuf:"bytes,6,opt,name=nxdomain,proto3,oneof" json:"nxdomain,omitempty"`
}

func (*LoadBalancingRule_GeoLocationLabelSelector) isLoadBalancingRule_GeoLocationChoice() {}
func (*LoadBalancingRule_GeoLocationSet) isLoadBalancingRule_GeoLocationChoice()           {}
func (*LoadBalancingRule_Pool) isLoadBalancingRule_ActionChoice()                          {}
func (*LoadBalancingRule_Nxdomain) isLoadBalancingRule_ActionChoice()                      {}

func (m *LoadBalancingRule) GetGeoLocationChoice() isLoadBalancingRule_GeoLocationChoice {
	if m != nil {
		return m.GeoLocationChoice
	}
	return nil
}
func (m *LoadBalancingRule) GetActionChoice() isLoadBalancingRule_ActionChoice {
	if m != nil {
		return m.ActionChoice
	}
	return nil
}

func (m *LoadBalancingRule) GetGeoLocationLabelSelector() *schema.LabelSelectorType {
	if x, ok := m.GetGeoLocationChoice().(*LoadBalancingRule_GeoLocationLabelSelector); ok {
		return x.GeoLocationLabelSelector
	}
	return nil
}

func (m *LoadBalancingRule) GetGeoLocationSet() *views.ObjectRefType {
	if x, ok := m.GetGeoLocationChoice().(*LoadBalancingRule_GeoLocationSet); ok {
		return x.GeoLocationSet
	}
	return nil
}

func (m *LoadBalancingRule) GetPool() *views.ObjectRefType {
	if x, ok := m.GetActionChoice().(*LoadBalancingRule_Pool); ok {
		return x.Pool
	}
	return nil
}

func (m *LoadBalancingRule) GetNxdomain() *schema.Empty {
	if x, ok := m.GetActionChoice().(*LoadBalancingRule_Nxdomain); ok {
		return x.Nxdomain
	}
	return nil
}

func (m *LoadBalancingRule) GetScore() uint32 {
	if m != nil {
		return m.Score
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LoadBalancingRule) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LoadBalancingRule_GeoLocationLabelSelector)(nil),
		(*LoadBalancingRule_GeoLocationSet)(nil),
		(*LoadBalancingRule_Pool)(nil),
		(*LoadBalancingRule_Nxdomain)(nil),
	}
}

// Response Cache Parameters
//
// x-displayName: "Response Cache Parameters"
type ResponseCacheParameters struct {
	// Length of IPv4 CIDR masks
	//
	// x-displayName: "Length of IPv4 CIDR masks"
	// x-example: "24"
	// Length of CIDR masks used to group IPv4 clients
	CacheCidrIpv4 uint32 `protobuf:"varint,1,opt,name=cache_cidr_ipv4,json=cacheCidrIpv4,proto3" json:"cache_cidr_ipv4,omitempty"`
	// Length of IPv6 CIDR masks
	//
	// x-displayName: "Length of IPv6 CIDR masks"
	// x-example: "56"
	// Length of CIDR masks used to group IPv6 clients
	CacheCidrIpv6 uint32 `protobuf:"varint,2,opt,name=cache_cidr_ipv6,json=cacheCidrIpv6,proto3" json:"cache_cidr_ipv6,omitempty"`
	// TTL
	//
	// x-displayName: "TTL"
	// x-example: "3600"
	// TTL for response cache
	CacheTtl uint32 `protobuf:"varint,3,opt,name=cache_ttl,json=cacheTtl,proto3" json:"cache_ttl,omitempty"`
}

func (m *ResponseCacheParameters) Reset()      { *m = ResponseCacheParameters{} }
func (*ResponseCacheParameters) ProtoMessage() {}
func (*ResponseCacheParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_01361f944871c627, []int{4}
}
func (m *ResponseCacheParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseCacheParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResponseCacheParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseCacheParameters.Merge(m, src)
}
func (m *ResponseCacheParameters) XXX_Size() int {
	return m.Size()
}
func (m *ResponseCacheParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseCacheParameters.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseCacheParameters proto.InternalMessageInfo

func (m *ResponseCacheParameters) GetCacheCidrIpv4() uint32 {
	if m != nil {
		return m.CacheCidrIpv4
	}
	return 0
}

func (m *ResponseCacheParameters) GetCacheCidrIpv6() uint32 {
	if m != nil {
		return m.CacheCidrIpv6
	}
	return 0
}

func (m *ResponseCacheParameters) GetCacheTtl() uint32 {
	if m != nil {
		return m.CacheTtl
	}
	return 0
}

// Create DNS Load Balancer
//
// x-displayName: "Create DNS Load Balancer"
// Create DNS Load Balancer in a given namespace. If one already exist it will give a error.
type CreateSpecType struct {
	RecordType    ResourceRecordType     `protobuf:"varint,2,opt,name=record_type,json=recordType,proto3,enum=ves.io.schema.dns_load_balancer.ResourceRecordType" json:"record_type,omitempty"`
	RuleList      *LoadBalancingRuleList `protobuf:"bytes,3,opt,name=rule_list,json=ruleList,proto3" json:"rule_list,omitempty"`
	ResponseCache *ResponseCache         `protobuf:"bytes,4,opt,name=response_cache,json=responseCache,proto3" json:"response_cache,omitempty"`
	FallbackPool  *views.ObjectRefType   `protobuf:"bytes,6,opt,name=fallback_pool,json=fallbackPool,proto3" json:"fallback_pool,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_01361f944871c627, []int{5}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetRecordType() ResourceRecordType {
	if m != nil {
		return m.RecordType
	}
	return A
}

func (m *CreateSpecType) GetRuleList() *LoadBalancingRuleList {
	if m != nil {
		return m.RuleList
	}
	return nil
}

func (m *CreateSpecType) GetResponseCache() *ResponseCache {
	if m != nil {
		return m.ResponseCache
	}
	return nil
}

func (m *CreateSpecType) GetFallbackPool() *views.ObjectRefType {
	if m != nil {
		return m.FallbackPool
	}
	return nil
}

// Replace DNS Load Balancer
//
// x-displayName: "Replace DNS Load Balancer"
// Replace DNS Load Balancer in a given namespace.
type ReplaceSpecType struct {
	RecordType    ResourceRecordType     `protobuf:"varint,2,opt,name=record_type,json=recordType,proto3,enum=ves.io.schema.dns_load_balancer.ResourceRecordType" json:"record_type,omitempty"`
	RuleList      *LoadBalancingRuleList `protobuf:"bytes,3,opt,name=rule_list,json=ruleList,proto3" json:"rule_list,omitempty"`
	ResponseCache *ResponseCache         `protobuf:"bytes,4,opt,name=response_cache,json=responseCache,proto3" json:"response_cache,omitempty"`
	FallbackPool  *views.ObjectRefType   `protobuf:"bytes,6,opt,name=fallback_pool,json=fallbackPool,proto3" json:"fallback_pool,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_01361f944871c627, []int{6}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

func (m *ReplaceSpecType) GetRecordType() ResourceRecordType {
	if m != nil {
		return m.RecordType
	}
	return A
}

func (m *ReplaceSpecType) GetRuleList() *LoadBalancingRuleList {
	if m != nil {
		return m.RuleList
	}
	return nil
}

func (m *ReplaceSpecType) GetResponseCache() *ResponseCache {
	if m != nil {
		return m.ResponseCache
	}
	return nil
}

func (m *ReplaceSpecType) GetFallbackPool() *views.ObjectRefType {
	if m != nil {
		return m.FallbackPool
	}
	return nil
}

// Get DNS Load Balancer
//
// x-displayName: "Get DNS Load Balancer"
// Get DNS Load Balancer details.
type GetSpecType struct {
	RecordType    ResourceRecordType     `protobuf:"varint,2,opt,name=record_type,json=recordType,proto3,enum=ves.io.schema.dns_load_balancer.ResourceRecordType" json:"record_type,omitempty"`
	RuleList      *LoadBalancingRuleList `protobuf:"bytes,3,opt,name=rule_list,json=ruleList,proto3" json:"rule_list,omitempty"`
	ResponseCache *ResponseCache         `protobuf:"bytes,4,opt,name=response_cache,json=responseCache,proto3" json:"response_cache,omitempty"`
	DnsZones      []*views.ObjectRefType `protobuf:"bytes,5,rep,name=dns_zones,json=dnsZones,proto3" json:"dns_zones,omitempty"`
	FallbackPool  *views.ObjectRefType   `protobuf:"bytes,6,opt,name=fallback_pool,json=fallbackPool,proto3" json:"fallback_pool,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_01361f944871c627, []int{7}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetRecordType() ResourceRecordType {
	if m != nil {
		return m.RecordType
	}
	return A
}

func (m *GetSpecType) GetRuleList() *LoadBalancingRuleList {
	if m != nil {
		return m.RuleList
	}
	return nil
}

func (m *GetSpecType) GetResponseCache() *ResponseCache {
	if m != nil {
		return m.ResponseCache
	}
	return nil
}

func (m *GetSpecType) GetDnsZones() []*views.ObjectRefType {
	if m != nil {
		return m.DnsZones
	}
	return nil
}

func (m *GetSpecType) GetFallbackPool() *views.ObjectRefType {
	if m != nil {
		return m.FallbackPool
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.dns_load_balancer.ResourceRecordType", ResourceRecordType_name, ResourceRecordType_value)
	golang_proto.RegisterEnum("ves.io.schema.dns_load_balancer.ResourceRecordType", ResourceRecordType_name, ResourceRecordType_value)
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.dns_load_balancer.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.dns_load_balancer.GlobalSpecType")
	proto.RegisterType((*ResponseCache)(nil), "ves.io.schema.dns_load_balancer.ResponseCache")
	golang_proto.RegisterType((*ResponseCache)(nil), "ves.io.schema.dns_load_balancer.ResponseCache")
	proto.RegisterType((*LoadBalancingRuleList)(nil), "ves.io.schema.dns_load_balancer.LoadBalancingRuleList")
	golang_proto.RegisterType((*LoadBalancingRuleList)(nil), "ves.io.schema.dns_load_balancer.LoadBalancingRuleList")
	proto.RegisterType((*LoadBalancingRule)(nil), "ves.io.schema.dns_load_balancer.LoadBalancingRule")
	golang_proto.RegisterType((*LoadBalancingRule)(nil), "ves.io.schema.dns_load_balancer.LoadBalancingRule")
	proto.RegisterType((*ResponseCacheParameters)(nil), "ves.io.schema.dns_load_balancer.ResponseCacheParameters")
	golang_proto.RegisterType((*ResponseCacheParameters)(nil), "ves.io.schema.dns_load_balancer.ResponseCacheParameters")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.dns_load_balancer.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.dns_load_balancer.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.dns_load_balancer.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.dns_load_balancer.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.dns_load_balancer.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.dns_load_balancer.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/dns_load_balancer/types.proto", fileDescriptor_01361f944871c627)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/dns_load_balancer/types.proto", fileDescriptor_01361f944871c627)
}

var fileDescriptor_01361f944871c627 = []byte{
	// 1253 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0xcd, 0x6f, 0x13, 0xc7,
	0x1b, 0xde, 0x59, 0xef, 0xda, 0xce, 0x6b, 0xec, 0x38, 0x03, 0x3f, 0x65, 0x31, 0x3f, 0x2d, 0xdb,
	0x1c, 0xaa, 0xc8, 0x4d, 0xec, 0xd4, 0x09, 0x69, 0x45, 0x25, 0x5a, 0x3b, 0x45, 0x31, 0x28, 0x7c,
	0x68, 0x0d, 0x85, 0xd2, 0xc3, 0x6a, 0xbd, 0x9e, 0x38, 0x5b, 0xd6, 0x9e, 0xd5, 0xee, 0xd8, 0x40,
	0xa5, 0x48, 0x1c, 0x7b, 0x44, 0xf4, 0xd6, 0x7f, 0xa0, 0x08, 0xa9, 0x97, 0x1e, 0xeb, 0x1c, 0x72,
	0x68, 0xa5, 0x8a, 0x53, 0x6e, 0x4d, 0x39, 0x81, 0x73, 0xa1, 0x37, 0x54, 0xb5, 0x52, 0x6f, 0x54,
	0x3b, 0x5e, 0x07, 0xdb, 0x21, 0xe5, 0x43, 0xd0, 0x13, 0xb7, 0xd9, 0x9d, 0xe7, 0x79, 0xde, 0x99,
	0xe7, 0x7d, 0xdf, 0x99, 0x5d, 0x78, 0xaf, 0x4d, 0xfc, 0x9c, 0x4d, 0xf3, 0xbe, 0xb5, 0x46, 0x1a,
	0x66, 0xbe, 0xd6, 0xf4, 0x0d, 0x87, 0x9a, 0x35, 0xa3, 0x6a, 0x3a, 0x66, 0xd3, 0x22, 0x5e, 0x9e,
	0xdd, 0x70, 0x89, 0x9f, 0x73, 0x3d, 0xca, 0x28, 0x3e, 0xda, 0x03, 0xe7, 0x7a, 0xe0, 0xdc, 0x1e,
	0x70, 0x66, 0xb6, 0x6e, 0xb3, 0xb5, 0x56, 0x35, 0x67, 0xd1, 0x46, 0xbe, 0x4e, 0xeb, 0x34, 0xcf,
	0x79, 0xd5, 0xd6, 0x2a, 0x7f, 0xe2, 0x0f, 0x7c, 0xd4, 0xd3, 0xcb, 0x1c, 0xad, 0x53, 0x5a, 0x77,
	0xc8, 0x53, 0x14, 0xb3, 0x1b, 0xc4, 0x67, 0x66, 0xc3, 0x0d, 0x01, 0x93, 0xc3, 0xab, 0x6b, 0x12,
	0x16, 0x4e, 0x1c, 0x19, 0x9e, 0xa0, 0x2e, 0xb3, 0x69, 0x33, 0x5c, 0x66, 0xe6, 0xf0, 0xf0, 0xe4,
	0xc0, 0x0e, 0x32, 0xff, 0x1f, 0x9e, 0x6a, 0x9b, 0x8e, 0x5d, 0x33, 0x19, 0x09, 0x67, 0xb5, 0x91,
	0x59, 0x9b, 0x5c, 0x33, 0x86, 0xa5, 0x8f, 0xee, 0x45, 0xf8, 0x83, 0x01, 0xa6, 0x7e, 0x8d, 0x40,
	0x6a, 0xd9, 0xa1, 0x55, 0xd3, 0xa9, 0xb8, 0xc4, 0xba, 0x70, 0xc3, 0x25, 0xf8, 0x02, 0x24, 0x3c,
	0x62, 0x51, 0xaf, 0x66, 0x04, 0x40, 0x45, 0xd4, 0xd0, 0x74, 0xaa, 0x30, 0x9f, 0x7b, 0x8e, 0x97,
	0x39, 0x9d, 0xf8, 0xb4, 0xe5, 0x59, 0x44, 0xe7, 0xdc, 0x40, 0x49, 0x07, 0x6f, 0x77, 0x8c, 0x3f,
	0x87, 0x31, 0xaf, 0xe5, 0x10, 0xc3, 0xb1, 0x7d, 0xa6, 0x44, 0x34, 0x34, 0x9d, 0x28, 0x2c, 0x3e,
	0x57, 0x73, 0x85, 0x9a, 0xb5, 0x12, 0x7f, 0xb0, 0x9b, 0x75, 0xbd, 0xe5, 0x90, 0x15, 0xdb, 0x67,
	0x25, 0xe9, 0x71, 0x07, 0x21, 0x3d, 0xee, 0x85, 0xcf, 0xf8, 0x0b, 0x48, 0x79, 0xc4, 0x77, 0x69,
	0xd3, 0x27, 0x86, 0x65, 0x5a, 0x6b, 0x44, 0x91, 0xb8, 0x7e, 0xee, 0x45, 0xd6, 0xcc, 0x69, 0x4b,
	0x01, 0x2b, 0xd4, 0x4d, 0x7a, 0x83, 0x2f, 0xf1, 0x0a, 0x8c, 0x05, 0xbc, 0xaf, 0x68, 0x93, 0xf8,
	0x8a, 0xac, 0x45, 0xa6, 0x13, 0x85, 0xa9, 0x11, 0x5d, 0xee, 0x6a, 0xee, 0x5c, 0xf5, 0x4b, 0x62,
	0x31, 0x9d, 0xac, 0x06, 0xdb, 0x2d, 0x25, 0xee, 0xae, 0xc7, 0xfb, 0x3c, 0x3d, 0x18, 0x5d, 0x09,
	0x04, 0xf0, 0x25, 0x48, 0xae, 0x9a, 0x8e, 0x53, 0x35, 0xad, 0xab, 0x86, 0x4b, 0xa9, 0xa3, 0x44,
	0xf9, 0x4a, 0x5f, 0x44, 0x31, 0x75, 0x77, 0x3d, 0xc1, 0x77, 0x50, 0xe5, 0x4c, 0xfd, 0x40, 0x5f,
	0xe8, 0x3c, 0xa5, 0xce, 0x71, 0xf8, 0xe3, 0x44, 0xac, 0x30, 0x33, 0x3f, 0xb3, 0x30, 0xb3, 0x78,
	0x5a, 0x8a, 0xa3, 0xb4, 0x38, 0xf5, 0x9b, 0x08, 0xc9, 0xa1, 0xfd, 0xe1, 0x39, 0x88, 0xd5, 0x6c,
	0xdf, 0xac, 0x3a, 0xbd, 0xa4, 0x26, 0x0a, 0x87, 0x46, 0xc2, 0x9e, 0x6c, 0xb8, 0xec, 0x46, 0x59,
	0xd0, 0xfb, 0x30, 0x6c, 0xc2, 0x3b, 0x35, 0xb2, 0x6a, 0xb6, 0x1c, 0x66, 0x0c, 0x3b, 0x6c, 0xb8,
	0xa6, 0x67, 0x36, 0x08, 0x23, 0x9e, 0x1f, 0x26, 0x73, 0x3f, 0x2d, 0x35, 0x14, 0x18, 0x5a, 0xca,
	0xf9, 0x5d, 0x36, 0x6e, 0xc3, 0xe1, 0xfd, 0xa5, 0x7b, 0x79, 0xfc, 0xf0, 0xe5, 0xf2, 0xf8, 0x54,
	0xbc, 0x2c, 0xe8, 0x93, 0xde, 0xb3, 0xa7, 0x4a, 0xc7, 0x40, 0xdb, 0x37, 0xae, 0x61, 0xad, 0x51,
	0xdb, 0x22, 0x78, 0x62, 0xb3, 0x83, 0xc4, 0xad, 0x0e, 0x42, 0xdd, 0x0e, 0x92, 0xb9, 0xbb, 0xa1,
	0xb7, 0xb7, 0x10, 0xfc, 0xef, 0x99, 0xb5, 0x89, 0xaf, 0x81, 0x1c, 0xd4, 0xa5, 0xaf, 0x20, 0x5e,
	0x2a, 0x85, 0x97, 0x2f, 0xf1, 0xd2, 0x6c, 0x10, 0xf1, 0xc7, 0xdf, 0x37, 0x23, 0xf2, 0x6d, 0x24,
	0xa6, 0x3f, 0xe9, 0x8f, 0xe2, 0xbb, 0xef, 0x14, 0xd4, 0x7d, 0xf0, 0x73, 0x24, 0x7a, 0x7b, 0x03,
	0x89, 0x69, 0xa4, 0xf7, 0xe2, 0x4d, 0x7d, 0x27, 0xc3, 0xc4, 0x1e, 0x2d, 0xcc, 0xe0, 0x48, 0x9d,
	0x50, 0xc3, 0xa1, 0x96, 0x19, 0x1c, 0x0b, 0x86, 0x63, 0x56, 0x89, 0x63, 0xf8, 0xc4, 0x21, 0x16,
	0xa3, 0x5e, 0x58, 0x06, 0xda, 0xc8, 0x22, 0x57, 0x02, 0x50, 0x25, 0xc4, 0xf0, 0xda, 0x9b, 0xf8,
	0x76, 0x03, 0x45, 0x00, 0xc5, 0xba, 0x1b, 0x28, 0x0a, 0x92, 0x1c, 0x45, 0xb1, 0xb2, 0xa0, 0x2b,
	0x75, 0x42, 0x57, 0x42, 0xe1, 0x21, 0x0a, 0xb6, 0x20, 0x3d, 0x14, 0xd5, 0x27, 0xfd, 0x96, 0x7f,
	0x91, 0x42, 0x3f, 0x78, 0x77, 0x7d, 0x0f, 0xbd, 0x2c, 0xe8, 0xa9, 0x81, 0x70, 0x15, 0xc2, 0x70,
	0x19, 0x24, 0xde, 0x41, 0xf2, 0xab, 0x76, 0x50, 0x19, 0xe9, 0x5c, 0x01, 0x7f, 0x04, 0xf1, 0xe6,
	0xf5, 0x1a, 0x6d, 0x98, 0x76, 0x33, 0xec, 0xc7, 0x67, 0x16, 0x73, 0x29, 0xb6, 0xbd, 0x8e, 0x1e,
	0x75, 0x10, 0x2a, 0x23, 0x7d, 0x97, 0x80, 0xb3, 0x20, 0xfb, 0x16, 0xf5, 0x88, 0x12, 0xd3, 0xd0,
	0x74, 0xb2, 0x74, 0xe8, 0x7e, 0x07, 0x45, 0xde, 0x9f, 0x9b, 0x0b, 0x72, 0x15, 0xcf, 0x46, 0x95,
	0x27, 0x4f, 0xd0, 0x34, 0xd2, 0x7b, 0x90, 0xe3, 0xdf, 0xa3, 0x7b, 0x1d, 0x74, 0x07, 0x81, 0x05,
	0xf1, 0xfe, 0x4e, 0xb2, 0x97, 0xe0, 0x22, 0xe4, 0xff, 0x35, 0x4b, 0x38, 0x9d, 0x49, 0x71, 0x7f,
	0xb5, 0xbe, 0xc1, 0x30, 0xb5, 0xd7, 0x60, 0x9c, 0xca, 0x1c, 0xe8, 0x8b, 0x6a, 0x15, 0xc2, 0x20,
	0x0f, 0x89, 0xa0, 0x04, 0xb4, 0xa2, 0xc5, 0xe3, 0x68, 0xa0, 0x42, 0xb4, 0x67, 0x19, 0x1c, 0x7a,
	0xba, 0xe1, 0x42, 0xfc, 0xec, 0xe5, 0x4f, 0xcf, 0x9d, 0x29, 0x9e, 0x3a, 0x0b, 0x69, 0x90, 0x2b,
	0xc1, 0x32, 0x33, 0xb1, 0x70, 0x4b, 0xa5, 0x77, 0xe1, 0xe0, 0x50, 0x98, 0xb0, 0x2d, 0xc6, 0x07,
	0xda, 0x22, 0x52, 0x98, 0x99, 0x2f, 0x69, 0x90, 0x34, 0xad, 0x51, 0x84, 0xbc, 0xd5, 0x41, 0x52,
	0x80, 0x38, 0xd6, 0x3f, 0x92, 0x4e, 0x4b, 0x71, 0x29, 0x2d, 0x4f, 0xfd, 0x84, 0x60, 0x72, 0xbf,
	0xd3, 0xe0, 0x03, 0x18, 0xef, 0x35, 0xa3, 0x65, 0xd7, 0x3c, 0xc3, 0x76, 0xdb, 0x0b, 0x0a, 0xe2,
	0xbe, 0x8e, 0xdf, 0xef, 0x20, 0xb1, 0xb0, 0x10, 0xd8, 0x2a, 0x65, 0x45, 0x45, 0xd3, 0x93, 0x1c,
	0xb7, 0x64, 0xd7, 0xbc, 0x53, 0x6e, 0x7b, 0x01, 0x1f, 0x1f, 0x25, 0x2e, 0xf2, 0xe2, 0x4e, 0x96,
	0x70, 0x40, 0x3c, 0xb6, 0x18, 0x10, 0x63, 0x59, 0x59, 0xb9, 0x19, 0xa4, 0x63, 0x88, 0xbb, 0x88,
	0x17, 0x60, 0xac, 0xc7, 0x65, 0xcc, 0xe1, 0x75, 0x9a, 0x2c, 0x4d, 0xde, 0xef, 0x20, 0x69, 0x7e,
	0x71, 0x6e, 0xee, 0xef, 0x0e, 0x12, 0xbe, 0xde, 0xe8, 0xf5, 0xa3, 0x98, 0x15, 0xf4, 0x38, 0x47,
	0x5e, 0x60, 0xce, 0xd4, 0x9f, 0x22, 0xa4, 0x96, 0x3c, 0x62, 0x32, 0xf2, 0x86, 0x6f, 0xce, 0xca,
	0x6b, 0xbb, 0x39, 0x07, 0xee, 0xcc, 0x8b, 0xaf, 0xe7, 0xce, 0x1c, 0xbd, 0x2d, 0x97, 0x5f, 0xf9,
	0x7e, 0x1b, 0xb9, 0xcf, 0x26, 0xee, 0x9d, 0x18, 0xf9, 0x2e, 0x09, 0x8f, 0xde, 0xbf, 0x44, 0x18,
	0xd7, 0x89, 0xeb, 0x98, 0xd6, 0x5b, 0xdf, 0xff, 0x4b, 0xdf, 0x7f, 0x88, 0x40, 0x62, 0x99, 0xb0,
	0xb7, 0x9e, 0xef, 0x7a, 0xfe, 0xf1, 0x2b, 0x7d, 0x19, 0x0e, 0x7c, 0x0c, 0xbe, 0xf1, 0xa4, 0x65,
	0x97, 0x01, 0xef, 0x35, 0x1c, 0xcb, 0x80, 0x8a, 0x69, 0x01, 0xc7, 0x41, 0x2a, 0x16, 0x8b, 0xc5,
	0x34, 0xc2, 0x51, 0x10, 0xcf, 0x5c, 0x4e, 0x8b, 0x78, 0x0c, 0xe4, 0xa5, 0xb3, 0xc5, 0x33, 0x27,
	0xd3, 0x11, 0x1c, 0x83, 0x48, 0x45, 0xff, 0x2c, 0x2d, 0x65, 0xa4, 0xcd, 0x0e, 0x12, 0x4a, 0xdf,
	0xa0, 0xad, 0x87, 0xaa, 0xb0, 0xfd, 0x50, 0x15, 0x1e, 0x3f, 0x54, 0xd1, 0xcd, 0xae, 0x8a, 0xee,
	0x74, 0x55, 0xf4, 0x4b, 0x57, 0x45, 0x5b, 0x5d, 0x15, 0x6d, 0x77, 0x55, 0xf4, 0xa0, 0xab, 0xa2,
	0x47, 0x5d, 0x55, 0x78, 0xdc, 0x55, 0xd1, 0xad, 0x1d, 0x55, 0xd8, 0xdc, 0x51, 0xd1, 0xd6, 0x8e,
	0x2a, 0x6c, 0xef, 0xa8, 0xc2, 0x95, 0x8b, 0x75, 0xea, 0x5e, 0xad, 0xe7, 0xda, 0xd4, 0x61, 0xc4,
	0xf3, 0xcc, 0x5c, 0xcb, 0xcf, 0xf3, 0xc1, 0x2a, 0xf5, 0x1a, 0xb3, 0xae, 0x47, 0xdb, 0x76, 0x8d,
	0x78, 0xb3, 0xfd, 0xe9, 0xbc, 0x5b, 0xad, 0xd3, 0x3c, 0xb9, 0xce, 0xc2, 0xbf, 0x96, 0xfd, 0xfe,
	0xf5, 0xaa, 0x51, 0xfe, 0x0f, 0x33, 0xff, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x79, 0x02, 0x4c,
	0x1f, 0x15, 0x0e, 0x00, 0x00,
}

func (x ResourceRecordType) String() string {
	s, ok := ResourceRecordType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RecordType != that1.RecordType {
		return false
	}
	if !this.RuleList.Equal(that1.RuleList) {
		return false
	}
	if !this.ResponseCache.Equal(that1.ResponseCache) {
		return false
	}
	if len(this.DnsZones) != len(that1.DnsZones) {
		return false
	}
	for i := range this.DnsZones {
		if !this.DnsZones[i].Equal(that1.DnsZones[i]) {
			return false
		}
	}
	if !this.FallbackPool.Equal(that1.FallbackPool) {
		return false
	}
	return true
}
func (this *ResponseCache) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseCache)
	if !ok {
		that2, ok := that.(ResponseCache)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ResponseCacheParametersChoice == nil {
		if this.ResponseCacheParametersChoice != nil {
			return false
		}
	} else if this.ResponseCacheParametersChoice == nil {
		return false
	} else if !this.ResponseCacheParametersChoice.Equal(that1.ResponseCacheParametersChoice) {
		return false
	}
	return true
}
func (this *ResponseCache_Disable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseCache_Disable)
	if !ok {
		that2, ok := that.(ResponseCache_Disable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Disable.Equal(that1.Disable) {
		return false
	}
	return true
}
func (this *ResponseCache_DefaultResponseCacheParameters) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseCache_DefaultResponseCacheParameters)
	if !ok {
		that2, ok := that.(ResponseCache_DefaultResponseCacheParameters)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultResponseCacheParameters.Equal(that1.DefaultResponseCacheParameters) {
		return false
	}
	return true
}
func (this *ResponseCache_ResponseCacheParameters) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseCache_ResponseCacheParameters)
	if !ok {
		that2, ok := that.(ResponseCache_ResponseCacheParameters)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ResponseCacheParameters.Equal(that1.ResponseCacheParameters) {
		return false
	}
	return true
}
func (this *LoadBalancingRuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoadBalancingRuleList)
	if !ok {
		that2, ok := that.(LoadBalancingRuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	return true
}
func (this *LoadBalancingRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoadBalancingRule)
	if !ok {
		that2, ok := that.(LoadBalancingRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.GeoLocationChoice == nil {
		if this.GeoLocationChoice != nil {
			return false
		}
	} else if this.GeoLocationChoice == nil {
		return false
	} else if !this.GeoLocationChoice.Equal(that1.GeoLocationChoice) {
		return false
	}
	if that1.ActionChoice == nil {
		if this.ActionChoice != nil {
			return false
		}
	} else if this.ActionChoice == nil {
		return false
	} else if !this.ActionChoice.Equal(that1.ActionChoice) {
		return false
	}
	if this.Score != that1.Score {
		return false
	}
	return true
}
func (this *LoadBalancingRule_GeoLocationLabelSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoadBalancingRule_GeoLocationLabelSelector)
	if !ok {
		that2, ok := that.(LoadBalancingRule_GeoLocationLabelSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GeoLocationLabelSelector.Equal(that1.GeoLocationLabelSelector) {
		return false
	}
	return true
}
func (this *LoadBalancingRule_GeoLocationSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoadBalancingRule_GeoLocationSet)
	if !ok {
		that2, ok := that.(LoadBalancingRule_GeoLocationSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GeoLocationSet.Equal(that1.GeoLocationSet) {
		return false
	}
	return true
}
func (this *LoadBalancingRule_Pool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoadBalancingRule_Pool)
	if !ok {
		that2, ok := that.(LoadBalancingRule_Pool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Pool.Equal(that1.Pool) {
		return false
	}
	return true
}
func (this *LoadBalancingRule_Nxdomain) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoadBalancingRule_Nxdomain)
	if !ok {
		that2, ok := that.(LoadBalancingRule_Nxdomain)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Nxdomain.Equal(that1.Nxdomain) {
		return false
	}
	return true
}
func (this *ResponseCacheParameters) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseCacheParameters)
	if !ok {
		that2, ok := that.(ResponseCacheParameters)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CacheCidrIpv4 != that1.CacheCidrIpv4 {
		return false
	}
	if this.CacheCidrIpv6 != that1.CacheCidrIpv6 {
		return false
	}
	if this.CacheTtl != that1.CacheTtl {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RecordType != that1.RecordType {
		return false
	}
	if !this.RuleList.Equal(that1.RuleList) {
		return false
	}
	if !this.ResponseCache.Equal(that1.ResponseCache) {
		return false
	}
	if !this.FallbackPool.Equal(that1.FallbackPool) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RecordType != that1.RecordType {
		return false
	}
	if !this.RuleList.Equal(that1.RuleList) {
		return false
	}
	if !this.ResponseCache.Equal(that1.ResponseCache) {
		return false
	}
	if !this.FallbackPool.Equal(that1.FallbackPool) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RecordType != that1.RecordType {
		return false
	}
	if !this.RuleList.Equal(that1.RuleList) {
		return false
	}
	if !this.ResponseCache.Equal(that1.ResponseCache) {
		return false
	}
	if len(this.DnsZones) != len(that1.DnsZones) {
		return false
	}
	for i := range this.DnsZones {
		if !this.DnsZones[i].Equal(that1.DnsZones[i]) {
			return false
		}
	}
	if !this.FallbackPool.Equal(that1.FallbackPool) {
		return false
	}
	return true
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&dns_load_balancer.GlobalSpecType{")
	s = append(s, "RecordType: "+fmt.Sprintf("%#v", this.RecordType)+",\n")
	if this.RuleList != nil {
		s = append(s, "RuleList: "+fmt.Sprintf("%#v", this.RuleList)+",\n")
	}
	if this.ResponseCache != nil {
		s = append(s, "ResponseCache: "+fmt.Sprintf("%#v", this.ResponseCache)+",\n")
	}
	if this.DnsZones != nil {
		s = append(s, "DnsZones: "+fmt.Sprintf("%#v", this.DnsZones)+",\n")
	}
	if this.FallbackPool != nil {
		s = append(s, "FallbackPool: "+fmt.Sprintf("%#v", this.FallbackPool)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseCache) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dns_load_balancer.ResponseCache{")
	if this.ResponseCacheParametersChoice != nil {
		s = append(s, "ResponseCacheParametersChoice: "+fmt.Sprintf("%#v", this.ResponseCacheParametersChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseCache_Disable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_load_balancer.ResponseCache_Disable{` +
		`Disable:` + fmt.Sprintf("%#v", this.Disable) + `}`}, ", ")
	return s
}
func (this *ResponseCache_DefaultResponseCacheParameters) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_load_balancer.ResponseCache_DefaultResponseCacheParameters{` +
		`DefaultResponseCacheParameters:` + fmt.Sprintf("%#v", this.DefaultResponseCacheParameters) + `}`}, ", ")
	return s
}
func (this *ResponseCache_ResponseCacheParameters) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_load_balancer.ResponseCache_ResponseCacheParameters{` +
		`ResponseCacheParameters:` + fmt.Sprintf("%#v", this.ResponseCacheParameters) + `}`}, ", ")
	return s
}
func (this *LoadBalancingRuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dns_load_balancer.LoadBalancingRuleList{")
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoadBalancingRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&dns_load_balancer.LoadBalancingRule{")
	if this.GeoLocationChoice != nil {
		s = append(s, "GeoLocationChoice: "+fmt.Sprintf("%#v", this.GeoLocationChoice)+",\n")
	}
	if this.ActionChoice != nil {
		s = append(s, "ActionChoice: "+fmt.Sprintf("%#v", this.ActionChoice)+",\n")
	}
	s = append(s, "Score: "+fmt.Sprintf("%#v", this.Score)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoadBalancingRule_GeoLocationLabelSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_load_balancer.LoadBalancingRule_GeoLocationLabelSelector{` +
		`GeoLocationLabelSelector:` + fmt.Sprintf("%#v", this.GeoLocationLabelSelector) + `}`}, ", ")
	return s
}
func (this *LoadBalancingRule_GeoLocationSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_load_balancer.LoadBalancingRule_GeoLocationSet{` +
		`GeoLocationSet:` + fmt.Sprintf("%#v", this.GeoLocationSet) + `}`}, ", ")
	return s
}
func (this *LoadBalancingRule_Pool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_load_balancer.LoadBalancingRule_Pool{` +
		`Pool:` + fmt.Sprintf("%#v", this.Pool) + `}`}, ", ")
	return s
}
func (this *LoadBalancingRule_Nxdomain) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_load_balancer.LoadBalancingRule_Nxdomain{` +
		`Nxdomain:` + fmt.Sprintf("%#v", this.Nxdomain) + `}`}, ", ")
	return s
}
func (this *ResponseCacheParameters) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dns_load_balancer.ResponseCacheParameters{")
	s = append(s, "CacheCidrIpv4: "+fmt.Sprintf("%#v", this.CacheCidrIpv4)+",\n")
	s = append(s, "CacheCidrIpv6: "+fmt.Sprintf("%#v", this.CacheCidrIpv6)+",\n")
	s = append(s, "CacheTtl: "+fmt.Sprintf("%#v", this.CacheTtl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dns_load_balancer.CreateSpecType{")
	s = append(s, "RecordType: "+fmt.Sprintf("%#v", this.RecordType)+",\n")
	if this.RuleList != nil {
		s = append(s, "RuleList: "+fmt.Sprintf("%#v", this.RuleList)+",\n")
	}
	if this.ResponseCache != nil {
		s = append(s, "ResponseCache: "+fmt.Sprintf("%#v", this.ResponseCache)+",\n")
	}
	if this.FallbackPool != nil {
		s = append(s, "FallbackPool: "+fmt.Sprintf("%#v", this.FallbackPool)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dns_load_balancer.ReplaceSpecType{")
	s = append(s, "RecordType: "+fmt.Sprintf("%#v", this.RecordType)+",\n")
	if this.RuleList != nil {
		s = append(s, "RuleList: "+fmt.Sprintf("%#v", this.RuleList)+",\n")
	}
	if this.ResponseCache != nil {
		s = append(s, "ResponseCache: "+fmt.Sprintf("%#v", this.ResponseCache)+",\n")
	}
	if this.FallbackPool != nil {
		s = append(s, "FallbackPool: "+fmt.Sprintf("%#v", this.FallbackPool)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&dns_load_balancer.GetSpecType{")
	s = append(s, "RecordType: "+fmt.Sprintf("%#v", this.RecordType)+",\n")
	if this.RuleList != nil {
		s = append(s, "RuleList: "+fmt.Sprintf("%#v", this.RuleList)+",\n")
	}
	if this.ResponseCache != nil {
		s = append(s, "ResponseCache: "+fmt.Sprintf("%#v", this.ResponseCache)+",\n")
	}
	if this.DnsZones != nil {
		s = append(s, "DnsZones: "+fmt.Sprintf("%#v", this.DnsZones)+",\n")
	}
	if this.FallbackPool != nil {
		s = append(s, "FallbackPool: "+fmt.Sprintf("%#v", this.FallbackPool)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FallbackPool != nil {
		{
			size, err := m.FallbackPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.DnsZones) > 0 {
		for iNdEx := len(m.DnsZones) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DnsZones[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ResponseCache != nil {
		{
			size, err := m.ResponseCache.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RuleList != nil {
		{
			size, err := m.RuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RecordType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RecordType))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *ResponseCache) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseCache) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseCache) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResponseCacheParametersChoice != nil {
		{
			size := m.ResponseCacheParametersChoice.Size()
			i -= size
			if _, err := m.ResponseCacheParametersChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResponseCache_Disable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseCache_Disable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Disable != nil {
		{
			size, err := m.Disable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ResponseCache_DefaultResponseCacheParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseCache_DefaultResponseCacheParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultResponseCacheParameters != nil {
		{
			size, err := m.DefaultResponseCacheParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseCache_ResponseCacheParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseCache_ResponseCacheParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ResponseCacheParameters != nil {
		{
			size, err := m.ResponseCacheParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *LoadBalancingRuleList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadBalancingRuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadBalancingRuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LoadBalancingRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadBalancingRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadBalancingRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Score != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x38
	}
	if m.ActionChoice != nil {
		{
			size := m.ActionChoice.Size()
			i -= size
			if _, err := m.ActionChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.GeoLocationChoice != nil {
		{
			size := m.GeoLocationChoice.Size()
			i -= size
			if _, err := m.GeoLocationChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *LoadBalancingRule_GeoLocationLabelSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadBalancingRule_GeoLocationLabelSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GeoLocationLabelSelector != nil {
		{
			size, err := m.GeoLocationLabelSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *LoadBalancingRule_GeoLocationSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadBalancingRule_GeoLocationSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GeoLocationSet != nil {
		{
			size, err := m.GeoLocationSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *LoadBalancingRule_Pool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadBalancingRule_Pool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Pool != nil {
		{
			size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *LoadBalancingRule_Nxdomain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadBalancingRule_Nxdomain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Nxdomain != nil {
		{
			size, err := m.Nxdomain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ResponseCacheParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseCacheParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseCacheParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CacheTtl != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CacheTtl))
		i--
		dAtA[i] = 0x18
	}
	if m.CacheCidrIpv6 != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CacheCidrIpv6))
		i--
		dAtA[i] = 0x10
	}
	if m.CacheCidrIpv4 != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CacheCidrIpv4))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FallbackPool != nil {
		{
			size, err := m.FallbackPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ResponseCache != nil {
		{
			size, err := m.ResponseCache.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RuleList != nil {
		{
			size, err := m.RuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RecordType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RecordType))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FallbackPool != nil {
		{
			size, err := m.FallbackPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ResponseCache != nil {
		{
			size, err := m.ResponseCache.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RuleList != nil {
		{
			size, err := m.RuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RecordType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RecordType))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FallbackPool != nil {
		{
			size, err := m.FallbackPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.DnsZones) > 0 {
		for iNdEx := len(m.DnsZones) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DnsZones[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ResponseCache != nil {
		{
			size, err := m.ResponseCache.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RuleList != nil {
		{
			size, err := m.RuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RecordType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RecordType))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RecordType != 0 {
		n += 1 + sovTypes(uint64(m.RecordType))
	}
	if m.RuleList != nil {
		l = m.RuleList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ResponseCache != nil {
		l = m.ResponseCache.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.DnsZones) > 0 {
		for _, e := range m.DnsZones {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.FallbackPool != nil {
		l = m.FallbackPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ResponseCache) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResponseCacheParametersChoice != nil {
		n += m.ResponseCacheParametersChoice.Size()
	}
	return n
}

func (m *ResponseCache_Disable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Disable != nil {
		l = m.Disable.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ResponseCache_DefaultResponseCacheParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultResponseCacheParameters != nil {
		l = m.DefaultResponseCacheParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ResponseCache_ResponseCacheParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResponseCacheParameters != nil {
		l = m.ResponseCacheParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LoadBalancingRuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *LoadBalancingRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GeoLocationChoice != nil {
		n += m.GeoLocationChoice.Size()
	}
	if m.ActionChoice != nil {
		n += m.ActionChoice.Size()
	}
	if m.Score != 0 {
		n += 1 + sovTypes(uint64(m.Score))
	}
	return n
}

func (m *LoadBalancingRule_GeoLocationLabelSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GeoLocationLabelSelector != nil {
		l = m.GeoLocationLabelSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LoadBalancingRule_GeoLocationSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GeoLocationSet != nil {
		l = m.GeoLocationSet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LoadBalancingRule_Pool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pool != nil {
		l = m.Pool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LoadBalancingRule_Nxdomain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nxdomain != nil {
		l = m.Nxdomain.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ResponseCacheParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CacheCidrIpv4 != 0 {
		n += 1 + sovTypes(uint64(m.CacheCidrIpv4))
	}
	if m.CacheCidrIpv6 != 0 {
		n += 1 + sovTypes(uint64(m.CacheCidrIpv6))
	}
	if m.CacheTtl != 0 {
		n += 1 + sovTypes(uint64(m.CacheTtl))
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RecordType != 0 {
		n += 1 + sovTypes(uint64(m.RecordType))
	}
	if m.RuleList != nil {
		l = m.RuleList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ResponseCache != nil {
		l = m.ResponseCache.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.FallbackPool != nil {
		l = m.FallbackPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RecordType != 0 {
		n += 1 + sovTypes(uint64(m.RecordType))
	}
	if m.RuleList != nil {
		l = m.RuleList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ResponseCache != nil {
		l = m.ResponseCache.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.FallbackPool != nil {
		l = m.FallbackPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RecordType != 0 {
		n += 1 + sovTypes(uint64(m.RecordType))
	}
	if m.RuleList != nil {
		l = m.RuleList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ResponseCache != nil {
		l = m.ResponseCache.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.DnsZones) > 0 {
		for _, e := range m.DnsZones {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.FallbackPool != nil {
		l = m.FallbackPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDnsZones := "[]*ObjectRefType{"
	for _, f := range this.DnsZones {
		repeatedStringForDnsZones += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForDnsZones += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`RecordType:` + fmt.Sprintf("%v", this.RecordType) + `,`,
		`RuleList:` + strings.Replace(this.RuleList.String(), "LoadBalancingRuleList", "LoadBalancingRuleList", 1) + `,`,
		`ResponseCache:` + strings.Replace(this.ResponseCache.String(), "ResponseCache", "ResponseCache", 1) + `,`,
		`DnsZones:` + repeatedStringForDnsZones + `,`,
		`FallbackPool:` + strings.Replace(fmt.Sprintf("%v", this.FallbackPool), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseCache) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseCache{`,
		`ResponseCacheParametersChoice:` + fmt.Sprintf("%v", this.ResponseCacheParametersChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseCache_Disable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseCache_Disable{`,
		`Disable:` + strings.Replace(fmt.Sprintf("%v", this.Disable), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseCache_DefaultResponseCacheParameters) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseCache_DefaultResponseCacheParameters{`,
		`DefaultResponseCacheParameters:` + strings.Replace(fmt.Sprintf("%v", this.DefaultResponseCacheParameters), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseCache_ResponseCacheParameters) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseCache_ResponseCacheParameters{`,
		`ResponseCacheParameters:` + strings.Replace(fmt.Sprintf("%v", this.ResponseCacheParameters), "ResponseCacheParameters", "ResponseCacheParameters", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoadBalancingRuleList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRules := "[]*LoadBalancingRule{"
	for _, f := range this.Rules {
		repeatedStringForRules += strings.Replace(f.String(), "LoadBalancingRule", "LoadBalancingRule", 1) + ","
	}
	repeatedStringForRules += "}"
	s := strings.Join([]string{`&LoadBalancingRuleList{`,
		`Rules:` + repeatedStringForRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoadBalancingRule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoadBalancingRule{`,
		`GeoLocationChoice:` + fmt.Sprintf("%v", this.GeoLocationChoice) + `,`,
		`ActionChoice:` + fmt.Sprintf("%v", this.ActionChoice) + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoadBalancingRule_GeoLocationLabelSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoadBalancingRule_GeoLocationLabelSelector{`,
		`GeoLocationLabelSelector:` + strings.Replace(fmt.Sprintf("%v", this.GeoLocationLabelSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoadBalancingRule_GeoLocationSet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoadBalancingRule_GeoLocationSet{`,
		`GeoLocationSet:` + strings.Replace(fmt.Sprintf("%v", this.GeoLocationSet), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoadBalancingRule_Pool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoadBalancingRule_Pool{`,
		`Pool:` + strings.Replace(fmt.Sprintf("%v", this.Pool), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoadBalancingRule_Nxdomain) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoadBalancingRule_Nxdomain{`,
		`Nxdomain:` + strings.Replace(fmt.Sprintf("%v", this.Nxdomain), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseCacheParameters) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseCacheParameters{`,
		`CacheCidrIpv4:` + fmt.Sprintf("%v", this.CacheCidrIpv4) + `,`,
		`CacheCidrIpv6:` + fmt.Sprintf("%v", this.CacheCidrIpv6) + `,`,
		`CacheTtl:` + fmt.Sprintf("%v", this.CacheTtl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`RecordType:` + fmt.Sprintf("%v", this.RecordType) + `,`,
		`RuleList:` + strings.Replace(this.RuleList.String(), "LoadBalancingRuleList", "LoadBalancingRuleList", 1) + `,`,
		`ResponseCache:` + strings.Replace(this.ResponseCache.String(), "ResponseCache", "ResponseCache", 1) + `,`,
		`FallbackPool:` + strings.Replace(fmt.Sprintf("%v", this.FallbackPool), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`RecordType:` + fmt.Sprintf("%v", this.RecordType) + `,`,
		`RuleList:` + strings.Replace(this.RuleList.String(), "LoadBalancingRuleList", "LoadBalancingRuleList", 1) + `,`,
		`ResponseCache:` + strings.Replace(this.ResponseCache.String(), "ResponseCache", "ResponseCache", 1) + `,`,
		`FallbackPool:` + strings.Replace(fmt.Sprintf("%v", this.FallbackPool), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDnsZones := "[]*ObjectRefType{"
	for _, f := range this.DnsZones {
		repeatedStringForDnsZones += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForDnsZones += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`RecordType:` + fmt.Sprintf("%v", this.RecordType) + `,`,
		`RuleList:` + strings.Replace(this.RuleList.String(), "LoadBalancingRuleList", "LoadBalancingRuleList", 1) + `,`,
		`ResponseCache:` + strings.Replace(this.ResponseCache.String(), "ResponseCache", "ResponseCache", 1) + `,`,
		`DnsZones:` + repeatedStringForDnsZones + `,`,
		`FallbackPool:` + strings.Replace(fmt.Sprintf("%v", this.FallbackPool), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordType |= ResourceRecordType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuleList == nil {
				m.RuleList = &LoadBalancingRuleList{}
			}
			if err := m.RuleList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponseCache == nil {
				m.ResponseCache = &ResponseCache{}
			}
			if err := m.ResponseCache.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsZones", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsZones = append(m.DnsZones, &views.ObjectRefType{})
			if err := m.DnsZones[len(m.DnsZones)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FallbackPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FallbackPool == nil {
				m.FallbackPool = &views.ObjectRefType{}
			}
			if err := m.FallbackPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseCache) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseCache: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseCache: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResponseCacheParametersChoice = &ResponseCache_Disable{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultResponseCacheParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResponseCacheParametersChoice = &ResponseCache_DefaultResponseCacheParameters{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCacheParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResponseCacheParameters{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResponseCacheParametersChoice = &ResponseCache_ResponseCacheParameters{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadBalancingRuleList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadBalancingRuleList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadBalancingRuleList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &LoadBalancingRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadBalancingRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadBalancingRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadBalancingRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoLocationLabelSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GeoLocationChoice = &LoadBalancingRule_GeoLocationLabelSelector{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoLocationSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GeoLocationChoice = &LoadBalancingRule_GeoLocationSet{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionChoice = &LoadBalancingRule_Pool{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nxdomain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionChoice = &LoadBalancingRule_Nxdomain{v}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseCacheParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseCacheParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseCacheParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheCidrIpv4", wireType)
			}
			m.CacheCidrIpv4 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheCidrIpv4 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheCidrIpv6", wireType)
			}
			m.CacheCidrIpv6 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheCidrIpv6 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheTtl", wireType)
			}
			m.CacheTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheTtl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordType |= ResourceRecordType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuleList == nil {
				m.RuleList = &LoadBalancingRuleList{}
			}
			if err := m.RuleList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponseCache == nil {
				m.ResponseCache = &ResponseCache{}
			}
			if err := m.ResponseCache.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FallbackPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FallbackPool == nil {
				m.FallbackPool = &views.ObjectRefType{}
			}
			if err := m.FallbackPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordType |= ResourceRecordType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuleList == nil {
				m.RuleList = &LoadBalancingRuleList{}
			}
			if err := m.RuleList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponseCache == nil {
				m.ResponseCache = &ResponseCache{}
			}
			if err := m.ResponseCache.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FallbackPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FallbackPool == nil {
				m.FallbackPool = &views.ObjectRefType{}
			}
			if err := m.FallbackPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordType |= ResourceRecordType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuleList == nil {
				m.RuleList = &LoadBalancingRuleList{}
			}
			if err := m.RuleList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponseCache == nil {
				m.ResponseCache = &ResponseCache{}
			}
			if err := m.ResponseCache.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsZones", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsZones = append(m.DnsZones, &views.ObjectRefType{})
			if err := m.DnsZones[len(m.DnsZones)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FallbackPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FallbackPool == nil {
				m.FallbackPool = &views.ObjectRefType{}
			}
			if err := m.FallbackPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
