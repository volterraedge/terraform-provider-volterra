// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package dns_load_balancer

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetFallbackPoolDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetFallbackPoolDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRuleListDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRuleListDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *CreateSpecType) GetFallbackPoolDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetFallbackPool()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("dns_lb_pool.Object")
	dri := db.DRefInfo{
		RefdType:   "dns_lb_pool.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "fallback_pool",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetFallbackPoolDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetFallbackPoolDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "dns_lb_pool.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: dns_lb_pool")
	}

	vref := m.GetFallbackPool()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "dns_lb_pool.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetRuleListDRefInfo() ([]db.DRefInfo, error) {
	if m.GetRuleList() == nil {
		return nil, nil
	}

	drInfos, err := m.GetRuleList().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetRuleList().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "rule_list." + dri.DRField
	}
	return drInfos, err

}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) RecordTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ResourceRecordType)
		return int32(i)
	}
	// ResourceRecordType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ResourceRecordType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for record_type")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) RuleListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for rule_list")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := LoadBalancingRuleListValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["fallback_pool"]; exists {

		vOpts := append(opts, db.WithValidateField("fallback_pool"))
		if err := fv(ctx, m.GetFallbackPool(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["record_type"]; exists {

		vOpts := append(opts, db.WithValidateField("record_type"))
		if err := fv(ctx, m.GetRecordType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_cache"]; exists {

		vOpts := append(opts, db.WithValidateField("response_cache"))
		if err := fv(ctx, m.GetResponseCache(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rule_list"]; exists {

		vOpts := append(opts, db.WithValidateField("rule_list"))
		if err := fv(ctx, m.GetRuleList(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRecordType := v.RecordTypeValidationRuleHandler
	rulesRecordType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhRecordType(rulesRecordType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.record_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["record_type"] = vFn

	vrhRuleList := v.RuleListValidationRuleHandler
	rulesRuleList := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhRuleList(rulesRuleList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.rule_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rule_list"] = vFn

	v.FldValidators["response_cache"] = ResponseCacheValidator().Validate

	v.FldValidators["fallback_pool"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetDnsZonesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDnsZonesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetFallbackPoolDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetFallbackPoolDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRuleListDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRuleListDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GetSpecType) GetDnsZonesDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetDnsZones()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("GetSpecType.dns_zones[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dns_zone.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "dns_zone.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dns_zones",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetDnsZonesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetDnsZonesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "dns_zone.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: dns_zone")
	}
	for i, vref := range m.GetDnsZones() {
		if vref == nil {
			return nil, fmt.Errorf("GetSpecType.dns_zones[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "dns_zone.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GetSpecType) GetFallbackPoolDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetFallbackPool()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("dns_lb_pool.Object")
	dri := db.DRefInfo{
		RefdType:   "dns_lb_pool.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "fallback_pool",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetFallbackPoolDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetFallbackPoolDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "dns_lb_pool.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: dns_lb_pool")
	}

	vref := m.GetFallbackPool()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "dns_lb_pool.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetRuleListDRefInfo() ([]db.DRefInfo, error) {
	if m.GetRuleList() == nil {
		return nil, nil
	}

	drInfos, err := m.GetRuleList().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetRuleList().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "rule_list." + dri.DRField
	}
	return drInfos, err

}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) RecordTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ResourceRecordType)
		return int32(i)
	}
	// ResourceRecordType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ResourceRecordType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for record_type")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) RuleListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for rule_list")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := LoadBalancingRuleListValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dns_zones"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_zones"))
		for idx, item := range m.GetDnsZones() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["fallback_pool"]; exists {

		vOpts := append(opts, db.WithValidateField("fallback_pool"))
		if err := fv(ctx, m.GetFallbackPool(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["record_type"]; exists {

		vOpts := append(opts, db.WithValidateField("record_type"))
		if err := fv(ctx, m.GetRecordType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_cache"]; exists {

		vOpts := append(opts, db.WithValidateField("response_cache"))
		if err := fv(ctx, m.GetResponseCache(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rule_list"]; exists {

		vOpts := append(opts, db.WithValidateField("rule_list"))
		if err := fv(ctx, m.GetRuleList(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRecordType := v.RecordTypeValidationRuleHandler
	rulesRecordType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhRecordType(rulesRecordType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.record_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["record_type"] = vFn

	vrhRuleList := v.RuleListValidationRuleHandler
	rulesRuleList := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhRuleList(rulesRuleList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.rule_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rule_list"] = vFn

	v.FldValidators["response_cache"] = ResponseCacheValidator().Validate

	v.FldValidators["dns_zones"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["fallback_pool"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetDnsZonesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDnsZonesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetFallbackPoolDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetFallbackPoolDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRuleListDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRuleListDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GlobalSpecType) GetDnsZonesDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetDnsZones()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("GlobalSpecType.dns_zones[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dns_zone.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "dns_zone.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dns_zones",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetDnsZonesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetDnsZonesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "dns_zone.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: dns_zone")
	}
	for i, vref := range m.GetDnsZones() {
		if vref == nil {
			return nil, fmt.Errorf("GlobalSpecType.dns_zones[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "dns_zone.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetFallbackPoolDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetFallbackPool()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("dns_lb_pool.Object")
	dri := db.DRefInfo{
		RefdType:   "dns_lb_pool.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "fallback_pool",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetFallbackPoolDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetFallbackPoolDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "dns_lb_pool.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: dns_lb_pool")
	}

	vref := m.GetFallbackPool()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "dns_lb_pool.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetRuleListDRefInfo() ([]db.DRefInfo, error) {
	if m.GetRuleList() == nil {
		return nil, nil
	}

	drInfos, err := m.GetRuleList().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetRuleList().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "rule_list." + dri.DRField
	}
	return drInfos, err

}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) RecordTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ResourceRecordType)
		return int32(i)
	}
	// ResourceRecordType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ResourceRecordType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for record_type")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) RuleListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for rule_list")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := LoadBalancingRuleListValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dns_zones"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_zones"))
		for idx, item := range m.GetDnsZones() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["fallback_pool"]; exists {

		vOpts := append(opts, db.WithValidateField("fallback_pool"))
		if err := fv(ctx, m.GetFallbackPool(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["record_type"]; exists {

		vOpts := append(opts, db.WithValidateField("record_type"))
		if err := fv(ctx, m.GetRecordType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_cache"]; exists {

		vOpts := append(opts, db.WithValidateField("response_cache"))
		if err := fv(ctx, m.GetResponseCache(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rule_list"]; exists {

		vOpts := append(opts, db.WithValidateField("rule_list"))
		if err := fv(ctx, m.GetRuleList(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRecordType := v.RecordTypeValidationRuleHandler
	rulesRecordType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhRecordType(rulesRecordType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.record_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["record_type"] = vFn

	vrhRuleList := v.RuleListValidationRuleHandler
	rulesRuleList := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhRuleList(rulesRuleList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.rule_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rule_list"] = vFn

	v.FldValidators["response_cache"] = ResponseCacheValidator().Validate

	v.FldValidators["dns_zones"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["fallback_pool"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *LoadBalancingRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LoadBalancingRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LoadBalancingRule) DeepCopy() *LoadBalancingRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LoadBalancingRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LoadBalancingRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LoadBalancingRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LoadBalancingRuleValidator().Validate(ctx, m, opts...)
}

func (m *LoadBalancingRule) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetActionChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetActionChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetClientChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetClientChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *LoadBalancingRule) GetActionChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetActionChoice().(type) {
	case *LoadBalancingRule_Pool:

		vref := m.GetPool()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dns_lb_pool.Object")
		dri := db.DRefInfo{
			RefdType:   "dns_lb_pool.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "pool",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	case *LoadBalancingRule_Nxdomain:

		return nil, nil

	default:
		return nil, nil
	}
}

// GetActionChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *LoadBalancingRule) GetActionChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetActionChoice().(type) {
	case *LoadBalancingRule_Pool:
		refdType, err := d.TypeForEntryKind("", "", "dns_lb_pool.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: dns_lb_pool")
		}

		vref := m.GetPool()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "dns_lb_pool.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *LoadBalancingRule_Nxdomain:

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *LoadBalancingRule) GetClientChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetClientChoice() == nil {
		return nil, nil
	}
	switch m.GetClientChoice().(type) {
	case *LoadBalancingRule_GeoLocationLabelSelector:

		return nil, nil

	case *LoadBalancingRule_GeoLocationSet:

		vref := m.GetGeoLocationSet()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("geo_location_set.Object")
		dri := db.DRefInfo{
			RefdType:   "geo_location_set.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "geo_location_set",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	case *LoadBalancingRule_AsnList:

		return nil, nil

	case *LoadBalancingRule_AsnMatcher:

		drInfos, err := m.GetAsnMatcher().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAsnMatcher().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "asn_matcher." + dri.DRField
		}
		return drInfos, err

	case *LoadBalancingRule_IpPrefixList:

		return nil, nil

	case *LoadBalancingRule_IpPrefixSet:

		drInfos, err := m.GetIpPrefixSet().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetIpPrefixSet().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "ip_prefix_set." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateLoadBalancingRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLoadBalancingRule) ActionChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for action_choice")
	}
	return validatorFn, nil
}

func (v *ValidateLoadBalancingRule) ClientChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for client_choice")
	}
	return validatorFn, nil
}

func (v *ValidateLoadBalancingRule) ScoreValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for score")
	}

	return validatorFn, nil
}

func (v *ValidateLoadBalancingRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LoadBalancingRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LoadBalancingRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action_choice"]; exists {
		val := m.GetActionChoice()
		vOpts := append(opts,
			db.WithValidateField("action_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetActionChoice().(type) {
	case *LoadBalancingRule_Pool:
		if fv, exists := v.FldValidators["action_choice.pool"]; exists {
			val := m.GetActionChoice().(*LoadBalancingRule_Pool).Pool
			vOpts := append(opts,
				db.WithValidateField("action_choice"),
				db.WithValidateField("pool"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LoadBalancingRule_Nxdomain:
		if fv, exists := v.FldValidators["action_choice.nxdomain"]; exists {
			val := m.GetActionChoice().(*LoadBalancingRule_Nxdomain).Nxdomain
			vOpts := append(opts,
				db.WithValidateField("action_choice"),
				db.WithValidateField("nxdomain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["client_choice"]; exists {
		val := m.GetClientChoice()
		vOpts := append(opts,
			db.WithValidateField("client_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetClientChoice().(type) {
	case *LoadBalancingRule_GeoLocationLabelSelector:
		if fv, exists := v.FldValidators["client_choice.geo_location_label_selector"]; exists {
			val := m.GetClientChoice().(*LoadBalancingRule_GeoLocationLabelSelector).GeoLocationLabelSelector
			vOpts := append(opts,
				db.WithValidateField("client_choice"),
				db.WithValidateField("geo_location_label_selector"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LoadBalancingRule_GeoLocationSet:
		if fv, exists := v.FldValidators["client_choice.geo_location_set"]; exists {
			val := m.GetClientChoice().(*LoadBalancingRule_GeoLocationSet).GeoLocationSet
			vOpts := append(opts,
				db.WithValidateField("client_choice"),
				db.WithValidateField("geo_location_set"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LoadBalancingRule_AsnList:
		if fv, exists := v.FldValidators["client_choice.asn_list"]; exists {
			val := m.GetClientChoice().(*LoadBalancingRule_AsnList).AsnList
			vOpts := append(opts,
				db.WithValidateField("client_choice"),
				db.WithValidateField("asn_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LoadBalancingRule_AsnMatcher:
		if fv, exists := v.FldValidators["client_choice.asn_matcher"]; exists {
			val := m.GetClientChoice().(*LoadBalancingRule_AsnMatcher).AsnMatcher
			vOpts := append(opts,
				db.WithValidateField("client_choice"),
				db.WithValidateField("asn_matcher"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LoadBalancingRule_IpPrefixList:
		if fv, exists := v.FldValidators["client_choice.ip_prefix_list"]; exists {
			val := m.GetClientChoice().(*LoadBalancingRule_IpPrefixList).IpPrefixList
			vOpts := append(opts,
				db.WithValidateField("client_choice"),
				db.WithValidateField("ip_prefix_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LoadBalancingRule_IpPrefixSet:
		if fv, exists := v.FldValidators["client_choice.ip_prefix_set"]; exists {
			val := m.GetClientChoice().(*LoadBalancingRule_IpPrefixSet).IpPrefixSet
			vOpts := append(opts,
				db.WithValidateField("client_choice"),
				db.WithValidateField("ip_prefix_set"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["score"]; exists {

		vOpts := append(opts, db.WithValidateField("score"))
		if err := fv(ctx, m.GetScore(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLoadBalancingRuleValidator = func() *ValidateLoadBalancingRule {
	v := &ValidateLoadBalancingRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhActionChoice := v.ActionChoiceValidationRuleHandler
	rulesActionChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhActionChoice(rulesActionChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LoadBalancingRule.action_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action_choice"] = vFn

	vrhClientChoice := v.ClientChoiceValidationRuleHandler
	rulesClientChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhClientChoice(rulesClientChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LoadBalancingRule.client_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["client_choice"] = vFn

	vrhScore := v.ScoreValidationRuleHandler
	rulesScore := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "32767",
	}
	vFn, err = vrhScore(rulesScore)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LoadBalancingRule.score: %s", err)
		panic(errMsg)
	}
	v.FldValidators["score"] = vFn

	v.FldValidators["action_choice.pool"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["client_choice.geo_location_label_selector"] = ves_io_schema.LabelSelectorTypeValidator().Validate
	v.FldValidators["client_choice.geo_location_set"] = ves_io_schema_views.ObjectRefTypeValidator().Validate
	v.FldValidators["client_choice.asn_list"] = ves_io_schema_policy.AsnMatchListValidator().Validate
	v.FldValidators["client_choice.asn_matcher"] = ves_io_schema_policy.AsnMatcherTypeValidator().Validate
	v.FldValidators["client_choice.ip_prefix_list"] = ves_io_schema_policy.PrefixMatchListValidator().Validate
	v.FldValidators["client_choice.ip_prefix_set"] = ves_io_schema_policy.IpMatcherTypeValidator().Validate

	return v
}()

func LoadBalancingRuleValidator() db.Validator {
	return DefaultLoadBalancingRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *LoadBalancingRuleList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LoadBalancingRuleList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LoadBalancingRuleList) DeepCopy() *LoadBalancingRuleList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LoadBalancingRuleList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LoadBalancingRuleList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LoadBalancingRuleList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LoadBalancingRuleListValidator().Validate(ctx, m, opts...)
}

func (m *LoadBalancingRuleList) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRulesDRefInfo()

}

// GetDRefInfo for the field's type
func (m *LoadBalancingRuleList) GetRulesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetRules() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetRules() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetRules() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("rules[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateLoadBalancingRuleList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLoadBalancingRuleList) RulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rules")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*LoadBalancingRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := LoadBalancingRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rules")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*LoadBalancingRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*LoadBalancingRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rules")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rules")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateLoadBalancingRuleList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LoadBalancingRuleList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LoadBalancingRuleList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["rules"]; exists {
		vOpts := append(opts, db.WithValidateField("rules"))
		if err := fv(ctx, m.GetRules(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLoadBalancingRuleListValidator = func() *ValidateLoadBalancingRuleList {
	v := &ValidateLoadBalancingRuleList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRules := v.RulesValidationRuleHandler
	rulesRules := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRules(rulesRules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LoadBalancingRuleList.rules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rules"] = vFn

	return v
}()

func LoadBalancingRuleListValidator() db.Validator {
	return DefaultLoadBalancingRuleListValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetFallbackPoolDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetFallbackPoolDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRuleListDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRuleListDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *ReplaceSpecType) GetFallbackPoolDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetFallbackPool()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("dns_lb_pool.Object")
	dri := db.DRefInfo{
		RefdType:   "dns_lb_pool.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "fallback_pool",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetFallbackPoolDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetFallbackPoolDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "dns_lb_pool.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: dns_lb_pool")
	}

	vref := m.GetFallbackPool()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "dns_lb_pool.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetRuleListDRefInfo() ([]db.DRefInfo, error) {
	if m.GetRuleList() == nil {
		return nil, nil
	}

	drInfos, err := m.GetRuleList().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetRuleList().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "rule_list." + dri.DRField
	}
	return drInfos, err

}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) RecordTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ResourceRecordType)
		return int32(i)
	}
	// ResourceRecordType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ResourceRecordType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for record_type")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) RuleListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for rule_list")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := LoadBalancingRuleListValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["fallback_pool"]; exists {

		vOpts := append(opts, db.WithValidateField("fallback_pool"))
		if err := fv(ctx, m.GetFallbackPool(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["record_type"]; exists {

		vOpts := append(opts, db.WithValidateField("record_type"))
		if err := fv(ctx, m.GetRecordType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_cache"]; exists {

		vOpts := append(opts, db.WithValidateField("response_cache"))
		if err := fv(ctx, m.GetResponseCache(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rule_list"]; exists {

		vOpts := append(opts, db.WithValidateField("rule_list"))
		if err := fv(ctx, m.GetRuleList(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRecordType := v.RecordTypeValidationRuleHandler
	rulesRecordType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhRecordType(rulesRecordType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.record_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["record_type"] = vFn

	vrhRuleList := v.RuleListValidationRuleHandler
	rulesRuleList := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhRuleList(rulesRuleList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.rule_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rule_list"] = vFn

	v.FldValidators["response_cache"] = ResponseCacheValidator().Validate

	v.FldValidators["fallback_pool"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ResponseCache) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ResponseCache) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ResponseCache) DeepCopy() *ResponseCache {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ResponseCache{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ResponseCache) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ResponseCache) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ResponseCacheValidator().Validate(ctx, m, opts...)
}

type ValidateResponseCache struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateResponseCache) ResponseCacheParametersChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for response_cache_parameters_choice")
	}
	return validatorFn, nil
}

func (v *ValidateResponseCache) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ResponseCache)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ResponseCache got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["response_cache_parameters_choice"]; exists {
		val := m.GetResponseCacheParametersChoice()
		vOpts := append(opts,
			db.WithValidateField("response_cache_parameters_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetResponseCacheParametersChoice().(type) {
	case *ResponseCache_Disable:
		if fv, exists := v.FldValidators["response_cache_parameters_choice.disable"]; exists {
			val := m.GetResponseCacheParametersChoice().(*ResponseCache_Disable).Disable
			vOpts := append(opts,
				db.WithValidateField("response_cache_parameters_choice"),
				db.WithValidateField("disable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ResponseCache_DefaultResponseCacheParameters:
		if fv, exists := v.FldValidators["response_cache_parameters_choice.default_response_cache_parameters"]; exists {
			val := m.GetResponseCacheParametersChoice().(*ResponseCache_DefaultResponseCacheParameters).DefaultResponseCacheParameters
			vOpts := append(opts,
				db.WithValidateField("response_cache_parameters_choice"),
				db.WithValidateField("default_response_cache_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ResponseCache_ResponseCacheParameters:
		if fv, exists := v.FldValidators["response_cache_parameters_choice.response_cache_parameters"]; exists {
			val := m.GetResponseCacheParametersChoice().(*ResponseCache_ResponseCacheParameters).ResponseCacheParameters
			vOpts := append(opts,
				db.WithValidateField("response_cache_parameters_choice"),
				db.WithValidateField("response_cache_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultResponseCacheValidator = func() *ValidateResponseCache {
	v := &ValidateResponseCache{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhResponseCacheParametersChoice := v.ResponseCacheParametersChoiceValidationRuleHandler
	rulesResponseCacheParametersChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhResponseCacheParametersChoice(rulesResponseCacheParametersChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ResponseCache.response_cache_parameters_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_cache_parameters_choice"] = vFn

	v.FldValidators["response_cache_parameters_choice.response_cache_parameters"] = ResponseCacheParametersValidator().Validate

	return v
}()

func ResponseCacheValidator() db.Validator {
	return DefaultResponseCacheValidator
}

// augmented methods on protoc/std generated struct

func (m *ResponseCacheParameters) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ResponseCacheParameters) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ResponseCacheParameters) DeepCopy() *ResponseCacheParameters {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ResponseCacheParameters{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ResponseCacheParameters) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ResponseCacheParameters) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ResponseCacheParametersValidator().Validate(ctx, m, opts...)
}

type ValidateResponseCacheParameters struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateResponseCacheParameters) CacheCidrIpv4ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_cidr_ipv4")
	}

	return validatorFn, nil
}

func (v *ValidateResponseCacheParameters) CacheCidrIpv6ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_cidr_ipv6")
	}

	return validatorFn, nil
}

func (v *ValidateResponseCacheParameters) CacheTtlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_ttl")
	}

	return validatorFn, nil
}

func (v *ValidateResponseCacheParameters) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ResponseCacheParameters)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ResponseCacheParameters got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_cidr_ipv4"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_cidr_ipv4"))
		if err := fv(ctx, m.GetCacheCidrIpv4(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cache_cidr_ipv6"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_cidr_ipv6"))
		if err := fv(ctx, m.GetCacheCidrIpv6(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cache_ttl"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_ttl"))
		if err := fv(ctx, m.GetCacheTtl(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultResponseCacheParametersValidator = func() *ValidateResponseCacheParameters {
	v := &ValidateResponseCacheParameters{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCacheCidrIpv4 := v.CacheCidrIpv4ValidationRuleHandler
	rulesCacheCidrIpv4 := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "32",
	}
	vFn, err = vrhCacheCidrIpv4(rulesCacheCidrIpv4)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ResponseCacheParameters.cache_cidr_ipv4: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cache_cidr_ipv4"] = vFn

	vrhCacheCidrIpv6 := v.CacheCidrIpv6ValidationRuleHandler
	rulesCacheCidrIpv6 := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "128",
	}
	vFn, err = vrhCacheCidrIpv6(rulesCacheCidrIpv6)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ResponseCacheParameters.cache_cidr_ipv6: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cache_cidr_ipv6"] = vFn

	vrhCacheTtl := v.CacheTtlValidationRuleHandler
	rulesCacheTtl := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
	}
	vFn, err = vrhCacheTtl(rulesCacheTtl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ResponseCacheParameters.cache_ttl: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cache_ttl"] = vFn

	return v
}()

func ResponseCacheParametersValidator() db.Validator {
	return DefaultResponseCacheParametersValidator
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.FallbackPool = f.GetFallbackPool()
	m.RecordType = f.GetRecordType()
	m.ResponseCache = f.GetResponseCache()
	m.RuleList = f.GetRuleList()
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.FallbackPool = m1.FallbackPool
	f.RecordType = m1.RecordType
	f.ResponseCache = m1.ResponseCache
	f.RuleList = m1.RuleList
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.DnsZones = f.GetDnsZones()
	m.FallbackPool = f.GetFallbackPool()
	m.RecordType = f.GetRecordType()
	m.ResponseCache = f.GetResponseCache()
	m.RuleList = f.GetRuleList()
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.DnsZones = m1.DnsZones
	f.FallbackPool = m1.FallbackPool
	f.RecordType = m1.RecordType
	f.ResponseCache = m1.ResponseCache
	f.RuleList = m1.RuleList
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.FallbackPool = f.GetFallbackPool()
	m.RecordType = f.GetRecordType()
	m.ResponseCache = f.GetResponseCache()
	m.RuleList = f.GetRuleList()
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.FallbackPool = m1.FallbackPool
	f.RecordType = m1.RecordType
	f.ResponseCache = m1.ResponseCache
	f.RuleList = m1.RuleList
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
