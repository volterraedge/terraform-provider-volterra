// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/endpoint/types.proto

package endpoint

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/origin_pool"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// HealthStatus
//
// x-displayName: "Health Status"
// Possible values to specify Health Status of endpoint
type HealthStatus int32

const (
	// HEALTHY
	//
	// x-displayName: "Healthy Status"
	// Status is Healthy
	HEALTHY HealthStatus = 0
	// UNHEALTHY
	//
	// x-displayName: "Unhealthy Status"
	// Status is Unhealthy
	UNHEALTHY HealthStatus = 1
)

var HealthStatus_name = map[int32]string{
	0: "HEALTHY",
	1: "UNHEALTHY",
}

var HealthStatus_value = map[string]int32{
	"HEALTHY":   0,
	"UNHEALTHY": 1,
}

func (HealthStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c4b1d0fcf1d7e4b, []int{0}
}

// ServiceInfoType
//
// x-displayName: "Service Info Type"
// Specifies whether endpoint service is discovered by name or labels
type ServiceInfoType struct {
	// discovery_type
	//
	// x-displayName: "Discovery"
	// x-required
	// Specifies whether the discovery is from Kubernetes or Consul cluster
	DiscoveryType schema.DiscoveryType `protobuf:"varint,1,opt,name=discovery_type,json=discoveryType,proto3,enum=ves.io.schema.DiscoveryType" json:"discovery_type,omitempty"`
	// service_info
	//
	// x-displayName: "Service"
	// Specifies whether service discovery has to be done using service name or labels
	//
	// Types that are valid to be assigned to ServiceInfo:
	//	*ServiceInfoType_ServiceName
	//	*ServiceInfoType_ServiceSelector
	ServiceInfo isServiceInfoType_ServiceInfo `protobuf_oneof:"service_info"`
}

func (m *ServiceInfoType) Reset()      { *m = ServiceInfoType{} }
func (*ServiceInfoType) ProtoMessage() {}
func (*ServiceInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4b1d0fcf1d7e4b, []int{0}
}
func (m *ServiceInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ServiceInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceInfoType.Merge(m, src)
}
func (m *ServiceInfoType) XXX_Size() int {
	return m.Size()
}
func (m *ServiceInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceInfoType proto.InternalMessageInfo

type isServiceInfoType_ServiceInfo interface {
	isServiceInfoType_ServiceInfo()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ServiceInfoType_ServiceName struct {
	ServiceName string `protobuf:"bytes,2,opt,name=service_name,json=serviceName,proto3,oneof" json:"service_name,omitempty"`
}
type ServiceInfoType_ServiceSelector struct {
	ServiceSelector *schema.LabelSelectorType `protobuf:"bytes,3,opt,name=service_selector,json=serviceSelector,proto3,oneof" json:"service_selector,omitempty"`
}

func (*ServiceInfoType_ServiceName) isServiceInfoType_ServiceInfo()     {}
func (*ServiceInfoType_ServiceSelector) isServiceInfoType_ServiceInfo() {}

func (m *ServiceInfoType) GetServiceInfo() isServiceInfoType_ServiceInfo {
	if m != nil {
		return m.ServiceInfo
	}
	return nil
}

func (m *ServiceInfoType) GetDiscoveryType() schema.DiscoveryType {
	if m != nil {
		return m.DiscoveryType
	}
	return schema.INVALID_DISCOVERY
}

func (m *ServiceInfoType) GetServiceName() string {
	if x, ok := m.GetServiceInfo().(*ServiceInfoType_ServiceName); ok {
		return x.ServiceName
	}
	return ""
}

func (m *ServiceInfoType) GetServiceSelector() *schema.LabelSelectorType {
	if x, ok := m.GetServiceInfo().(*ServiceInfoType_ServiceSelector); ok {
		return x.ServiceSelector
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ServiceInfoType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ServiceInfoType_ServiceName)(nil),
		(*ServiceInfoType_ServiceSelector)(nil),
	}
}

// DnsNameAdvancedType
//
// x-displayName: "DNS Name Advanced Type"
// Specifies name and TTL used for DNS resolution.
type DnsNameAdvancedType struct {
	// name
	//
	// x-displayName: "Endpoint DNS Name"
	// x-example: "volterra.io"
	// Endpoint's ip address is discovered using DNS name resolution. The name given here is fully qualified domain name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// ttl_choice
	//
	// x-displayName: "TTL Choice"
	// Time to live parameter
	//
	// Types that are valid to be assigned to TtlChoice:
	//	*DnsNameAdvancedType_StrictTtl
	//	*DnsNameAdvancedType_RefreshInterval
	TtlChoice isDnsNameAdvancedType_TtlChoice `protobuf_oneof:"ttl_choice"`
}

func (m *DnsNameAdvancedType) Reset()      { *m = DnsNameAdvancedType{} }
func (*DnsNameAdvancedType) ProtoMessage() {}
func (*DnsNameAdvancedType) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4b1d0fcf1d7e4b, []int{1}
}
func (m *DnsNameAdvancedType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DnsNameAdvancedType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DnsNameAdvancedType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DnsNameAdvancedType.Merge(m, src)
}
func (m *DnsNameAdvancedType) XXX_Size() int {
	return m.Size()
}
func (m *DnsNameAdvancedType) XXX_DiscardUnknown() {
	xxx_messageInfo_DnsNameAdvancedType.DiscardUnknown(m)
}

var xxx_messageInfo_DnsNameAdvancedType proto.InternalMessageInfo

type isDnsNameAdvancedType_TtlChoice interface {
	isDnsNameAdvancedType_TtlChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DnsNameAdvancedType_StrictTtl struct {
	StrictTtl *schema.Empty `protobuf:"bytes,3,opt,name=strict_ttl,json=strictTtl,proto3,oneof" json:"strict_ttl,omitempty"`
}
type DnsNameAdvancedType_RefreshInterval struct {
	RefreshInterval uint32 `protobuf:"varint,4,opt,name=refresh_interval,json=refreshInterval,proto3,oneof" json:"refresh_interval,omitempty"`
}

func (*DnsNameAdvancedType_StrictTtl) isDnsNameAdvancedType_TtlChoice()       {}
func (*DnsNameAdvancedType_RefreshInterval) isDnsNameAdvancedType_TtlChoice() {}

func (m *DnsNameAdvancedType) GetTtlChoice() isDnsNameAdvancedType_TtlChoice {
	if m != nil {
		return m.TtlChoice
	}
	return nil
}

func (m *DnsNameAdvancedType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DnsNameAdvancedType) GetStrictTtl() *schema.Empty {
	if x, ok := m.GetTtlChoice().(*DnsNameAdvancedType_StrictTtl); ok {
		return x.StrictTtl
	}
	return nil
}

func (m *DnsNameAdvancedType) GetRefreshInterval() uint32 {
	if x, ok := m.GetTtlChoice().(*DnsNameAdvancedType_RefreshInterval); ok {
		return x.RefreshInterval
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DnsNameAdvancedType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DnsNameAdvancedType_StrictTtl)(nil),
		(*DnsNameAdvancedType_RefreshInterval)(nil),
	}
}

// GlobalSpecType
//
// x-displayName: "Global Configuration Specification"
// Configuration specification for Endpoint
type GlobalSpecType struct {
	// where
	//
	// x-displayName: "Where"
	// This endpoint is present in site, virtual_site or virtual_network selected by following field.
	Where *schema.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where,proto3" json:"where,omitempty"`
	// Protocol
	//
	// x-displayName: "Protocol"
	// x-example: "TCP"
	// Endpoint protocol. Default is TCP.
	// Both TCP and UDP protocols are supported
	Protocol string `protobuf:"bytes,9,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Port
	//
	// x-displayName: "Port"
	// x-example: "9080"
	// Endpoint service is available on this port
	Port uint32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	// Health check Port
	//
	// x-displayName: "Port used for health check"
	// x-example: "9080"
	// By default the health check port of an endpoint is the same as the endpointâ€™s port. This option provides an alternative health check port.
	// Setting this with a non-zero value allows an endpoint to have different health check port.
	HealthCheckPort uint32 `protobuf:"varint,12,opt,name=health_check_port,json=healthCheckPort,proto3" json:"health_check_port,omitempty"`
	// Endpoint Address
	//
	// x-displayName: "Endpoint Specifier"
	// Endpoint address can be specified in multiple ways. It can be configured as ip address or DNS name.
	// It can be discovered using a service discovery method.
	// This field represents any one of method by which this endpoint is addressed or discovered.
	//
	// Types that are valid to be assigned to EndpointAddress:
	//	*GlobalSpecType_Ip
	//	*GlobalSpecType_DnsName
	//	*GlobalSpecType_DnsNameAdvanced
	//	*GlobalSpecType_ServerlessServiceName
	//	*GlobalSpecType_ServiceInfo
	//	*GlobalSpecType_K8SClusterApiServer
	EndpointAddress isGlobalSpecType_EndpointAddress `protobuf_oneof:"endpoint_address"`
	// Preference Rules
	//
	// x-displayName: "Preference Rules"
	// Preference rules define how the origins are selected as part of LB
	//
	// Types that are valid to be assigned to ProximityChoice:
	//	*GlobalSpecType_NoPreference
	//	*GlobalSpecType_SitePreferences
	ProximityChoice isGlobalSpecType_ProximityChoice `protobuf_oneof:"proximity_choice"`
	// SNAT Pool
	//
	// x-displayName: "Configured SNAT Pool"
	// Configured SNAT Pool
	SnatPool *views.SnatPoolConfiguration `protobuf:"bytes,17,opt,name=snat_pool,json=snatPool,proto3" json:"snat_pool,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4b1d0fcf1d7e4b, []int{2}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_EndpointAddress interface {
	isGlobalSpecType_EndpointAddress()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_ProximityChoice interface {
	isGlobalSpecType_ProximityChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_Ip struct {
	Ip string `protobuf:"bytes,3,opt,name=ip,proto3,oneof" json:"ip,omitempty"`
}
type GlobalSpecType_DnsName struct {
	DnsName string `protobuf:"bytes,4,opt,name=dns_name,json=dnsName,proto3,oneof" json:"dns_name,omitempty"`
}
type GlobalSpecType_DnsNameAdvanced struct {
	DnsNameAdvanced *DnsNameAdvancedType `protobuf:"bytes,11,opt,name=dns_name_advanced,json=dnsNameAdvanced,proto3,oneof" json:"dns_name_advanced,omitempty"`
}
type GlobalSpecType_ServerlessServiceName struct {
	ServerlessServiceName string `protobuf:"bytes,6,opt,name=serverless_service_name,json=serverlessServiceName,proto3,oneof" json:"serverless_service_name,omitempty"`
}
type GlobalSpecType_ServiceInfo struct {
	ServiceInfo *ServiceInfoType `protobuf:"bytes,8,opt,name=service_info,json=serviceInfo,proto3,oneof" json:"service_info,omitempty"`
}
type GlobalSpecType_K8SClusterApiServer struct {
	K8SClusterApiServer *schema.Empty `protobuf:"bytes,13,opt,name=k8s_cluster_api_server,json=k8sClusterApiServer,proto3,oneof" json:"k8s_cluster_api_server,omitempty"`
}
type GlobalSpecType_NoPreference struct {
	NoPreference *schema.Empty `protobuf:"bytes,15,opt,name=no_preference,json=noPreference,proto3,oneof" json:"no_preference,omitempty"`
}
type GlobalSpecType_SitePreferences struct {
	SitePreferences *schema.SiteReferenceListType `protobuf:"bytes,16,opt,name=site_preferences,json=sitePreferences,proto3,oneof" json:"site_preferences,omitempty"`
}

func (*GlobalSpecType_Ip) isGlobalSpecType_EndpointAddress()                    {}
func (*GlobalSpecType_DnsName) isGlobalSpecType_EndpointAddress()               {}
func (*GlobalSpecType_DnsNameAdvanced) isGlobalSpecType_EndpointAddress()       {}
func (*GlobalSpecType_ServerlessServiceName) isGlobalSpecType_EndpointAddress() {}
func (*GlobalSpecType_ServiceInfo) isGlobalSpecType_EndpointAddress()           {}
func (*GlobalSpecType_K8SClusterApiServer) isGlobalSpecType_EndpointAddress()   {}
func (*GlobalSpecType_NoPreference) isGlobalSpecType_ProximityChoice()          {}
func (*GlobalSpecType_SitePreferences) isGlobalSpecType_ProximityChoice()       {}

func (m *GlobalSpecType) GetEndpointAddress() isGlobalSpecType_EndpointAddress {
	if m != nil {
		return m.EndpointAddress
	}
	return nil
}
func (m *GlobalSpecType) GetProximityChoice() isGlobalSpecType_ProximityChoice {
	if m != nil {
		return m.ProximityChoice
	}
	return nil
}

func (m *GlobalSpecType) GetWhere() *schema.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *GlobalSpecType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *GlobalSpecType) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *GlobalSpecType) GetHealthCheckPort() uint32 {
	if m != nil {
		return m.HealthCheckPort
	}
	return 0
}

func (m *GlobalSpecType) GetIp() string {
	if x, ok := m.GetEndpointAddress().(*GlobalSpecType_Ip); ok {
		return x.Ip
	}
	return ""
}

func (m *GlobalSpecType) GetDnsName() string {
	if x, ok := m.GetEndpointAddress().(*GlobalSpecType_DnsName); ok {
		return x.DnsName
	}
	return ""
}

func (m *GlobalSpecType) GetDnsNameAdvanced() *DnsNameAdvancedType {
	if x, ok := m.GetEndpointAddress().(*GlobalSpecType_DnsNameAdvanced); ok {
		return x.DnsNameAdvanced
	}
	return nil
}

func (m *GlobalSpecType) GetServerlessServiceName() string {
	if x, ok := m.GetEndpointAddress().(*GlobalSpecType_ServerlessServiceName); ok {
		return x.ServerlessServiceName
	}
	return ""
}

func (m *GlobalSpecType) GetServiceInfo() *ServiceInfoType {
	if x, ok := m.GetEndpointAddress().(*GlobalSpecType_ServiceInfo); ok {
		return x.ServiceInfo
	}
	return nil
}

func (m *GlobalSpecType) GetK8SClusterApiServer() *schema.Empty {
	if x, ok := m.GetEndpointAddress().(*GlobalSpecType_K8SClusterApiServer); ok {
		return x.K8SClusterApiServer
	}
	return nil
}

func (m *GlobalSpecType) GetNoPreference() *schema.Empty {
	if x, ok := m.GetProximityChoice().(*GlobalSpecType_NoPreference); ok {
		return x.NoPreference
	}
	return nil
}

func (m *GlobalSpecType) GetSitePreferences() *schema.SiteReferenceListType {
	if x, ok := m.GetProximityChoice().(*GlobalSpecType_SitePreferences); ok {
		return x.SitePreferences
	}
	return nil
}

func (m *GlobalSpecType) GetSnatPool() *views.SnatPoolConfiguration {
	if m != nil {
		return m.SnatPool
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_Ip)(nil),
		(*GlobalSpecType_DnsName)(nil),
		(*GlobalSpecType_DnsNameAdvanced)(nil),
		(*GlobalSpecType_ServerlessServiceName)(nil),
		(*GlobalSpecType_ServiceInfo)(nil),
		(*GlobalSpecType_K8SClusterApiServer)(nil),
		(*GlobalSpecType_NoPreference)(nil),
		(*GlobalSpecType_SitePreferences)(nil),
	}
}

// Create Endpoint
//
// x-displayName: "Create Endpoint"
// Create endpoint will create the object in the storage backend for namespace metadata.namespace
type CreateSpecType struct {
	Where           *schema.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where,proto3" json:"where,omitempty"`
	Protocol        string                         `protobuf:"bytes,9,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Port            uint32                         `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	HealthCheckPort uint32                         `protobuf:"varint,12,opt,name=health_check_port,json=healthCheckPort,proto3" json:"health_check_port,omitempty"`
	// Types that are valid to be assigned to EndpointAddress:
	//	*CreateSpecType_Ip
	//	*CreateSpecType_DnsName
	//	*CreateSpecType_DnsNameAdvanced
	//	*CreateSpecType_ServiceInfo
	EndpointAddress isCreateSpecType_EndpointAddress `protobuf_oneof:"endpoint_address"`
	SnatPool        *views.SnatPoolConfiguration     `protobuf:"bytes,17,opt,name=snat_pool,json=snatPool,proto3" json:"snat_pool,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4b1d0fcf1d7e4b, []int{3}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_EndpointAddress interface {
	isCreateSpecType_EndpointAddress()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_Ip struct {
	Ip string `protobuf:"bytes,3,opt,name=ip,proto3,oneof" json:"ip,omitempty"`
}
type CreateSpecType_DnsName struct {
	DnsName string `protobuf:"bytes,4,opt,name=dns_name,json=dnsName,proto3,oneof" json:"dns_name,omitempty"`
}
type CreateSpecType_DnsNameAdvanced struct {
	DnsNameAdvanced *DnsNameAdvancedType `protobuf:"bytes,11,opt,name=dns_name_advanced,json=dnsNameAdvanced,proto3,oneof" json:"dns_name_advanced,omitempty"`
}
type CreateSpecType_ServiceInfo struct {
	ServiceInfo *ServiceInfoType `protobuf:"bytes,8,opt,name=service_info,json=serviceInfo,proto3,oneof" json:"service_info,omitempty"`
}

func (*CreateSpecType_Ip) isCreateSpecType_EndpointAddress()              {}
func (*CreateSpecType_DnsName) isCreateSpecType_EndpointAddress()         {}
func (*CreateSpecType_DnsNameAdvanced) isCreateSpecType_EndpointAddress() {}
func (*CreateSpecType_ServiceInfo) isCreateSpecType_EndpointAddress()     {}

func (m *CreateSpecType) GetEndpointAddress() isCreateSpecType_EndpointAddress {
	if m != nil {
		return m.EndpointAddress
	}
	return nil
}

func (m *CreateSpecType) GetWhere() *schema.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *CreateSpecType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *CreateSpecType) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *CreateSpecType) GetHealthCheckPort() uint32 {
	if m != nil {
		return m.HealthCheckPort
	}
	return 0
}

func (m *CreateSpecType) GetIp() string {
	if x, ok := m.GetEndpointAddress().(*CreateSpecType_Ip); ok {
		return x.Ip
	}
	return ""
}

func (m *CreateSpecType) GetDnsName() string {
	if x, ok := m.GetEndpointAddress().(*CreateSpecType_DnsName); ok {
		return x.DnsName
	}
	return ""
}

func (m *CreateSpecType) GetDnsNameAdvanced() *DnsNameAdvancedType {
	if x, ok := m.GetEndpointAddress().(*CreateSpecType_DnsNameAdvanced); ok {
		return x.DnsNameAdvanced
	}
	return nil
}

func (m *CreateSpecType) GetServiceInfo() *ServiceInfoType {
	if x, ok := m.GetEndpointAddress().(*CreateSpecType_ServiceInfo); ok {
		return x.ServiceInfo
	}
	return nil
}

func (m *CreateSpecType) GetSnatPool() *views.SnatPoolConfiguration {
	if m != nil {
		return m.SnatPool
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_Ip)(nil),
		(*CreateSpecType_DnsName)(nil),
		(*CreateSpecType_DnsNameAdvanced)(nil),
		(*CreateSpecType_ServiceInfo)(nil),
	}
}

// Replace Endpoint
//
// x-displayName: "Replace Endpoint"
// Replacing an endpoint object will update the object by replacing the existing spec with the provided one.
// For read-then-write operations a resourceVersion mismatch will occur if the object was modified between the read and write.
type ReplaceSpecType struct {
	Where           *schema.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where,proto3" json:"where,omitempty"`
	Protocol        string                         `protobuf:"bytes,9,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Port            uint32                         `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	HealthCheckPort uint32                         `protobuf:"varint,12,opt,name=health_check_port,json=healthCheckPort,proto3" json:"health_check_port,omitempty"`
	// Types that are valid to be assigned to EndpointAddress:
	//	*ReplaceSpecType_Ip
	//	*ReplaceSpecType_DnsName
	//	*ReplaceSpecType_DnsNameAdvanced
	//	*ReplaceSpecType_ServiceInfo
	EndpointAddress isReplaceSpecType_EndpointAddress `protobuf_oneof:"endpoint_address"`
	SnatPool        *views.SnatPoolConfiguration      `protobuf:"bytes,17,opt,name=snat_pool,json=snatPool,proto3" json:"snat_pool,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4b1d0fcf1d7e4b, []int{4}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_EndpointAddress interface {
	isReplaceSpecType_EndpointAddress()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_Ip struct {
	Ip string `protobuf:"bytes,3,opt,name=ip,proto3,oneof" json:"ip,omitempty"`
}
type ReplaceSpecType_DnsName struct {
	DnsName string `protobuf:"bytes,4,opt,name=dns_name,json=dnsName,proto3,oneof" json:"dns_name,omitempty"`
}
type ReplaceSpecType_DnsNameAdvanced struct {
	DnsNameAdvanced *DnsNameAdvancedType `protobuf:"bytes,11,opt,name=dns_name_advanced,json=dnsNameAdvanced,proto3,oneof" json:"dns_name_advanced,omitempty"`
}
type ReplaceSpecType_ServiceInfo struct {
	ServiceInfo *ServiceInfoType `protobuf:"bytes,8,opt,name=service_info,json=serviceInfo,proto3,oneof" json:"service_info,omitempty"`
}

func (*ReplaceSpecType_Ip) isReplaceSpecType_EndpointAddress()              {}
func (*ReplaceSpecType_DnsName) isReplaceSpecType_EndpointAddress()         {}
func (*ReplaceSpecType_DnsNameAdvanced) isReplaceSpecType_EndpointAddress() {}
func (*ReplaceSpecType_ServiceInfo) isReplaceSpecType_EndpointAddress()     {}

func (m *ReplaceSpecType) GetEndpointAddress() isReplaceSpecType_EndpointAddress {
	if m != nil {
		return m.EndpointAddress
	}
	return nil
}

func (m *ReplaceSpecType) GetWhere() *schema.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *ReplaceSpecType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *ReplaceSpecType) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *ReplaceSpecType) GetHealthCheckPort() uint32 {
	if m != nil {
		return m.HealthCheckPort
	}
	return 0
}

func (m *ReplaceSpecType) GetIp() string {
	if x, ok := m.GetEndpointAddress().(*ReplaceSpecType_Ip); ok {
		return x.Ip
	}
	return ""
}

func (m *ReplaceSpecType) GetDnsName() string {
	if x, ok := m.GetEndpointAddress().(*ReplaceSpecType_DnsName); ok {
		return x.DnsName
	}
	return ""
}

func (m *ReplaceSpecType) GetDnsNameAdvanced() *DnsNameAdvancedType {
	if x, ok := m.GetEndpointAddress().(*ReplaceSpecType_DnsNameAdvanced); ok {
		return x.DnsNameAdvanced
	}
	return nil
}

func (m *ReplaceSpecType) GetServiceInfo() *ServiceInfoType {
	if x, ok := m.GetEndpointAddress().(*ReplaceSpecType_ServiceInfo); ok {
		return x.ServiceInfo
	}
	return nil
}

func (m *ReplaceSpecType) GetSnatPool() *views.SnatPoolConfiguration {
	if m != nil {
		return m.SnatPool
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_Ip)(nil),
		(*ReplaceSpecType_DnsName)(nil),
		(*ReplaceSpecType_DnsNameAdvanced)(nil),
		(*ReplaceSpecType_ServiceInfo)(nil),
	}
}

// Get Endpoint
//
// x-displayName: "Get Endpoint"
// Get endpoint will get the object from the storage backend for namespace metadata.namespace
type GetSpecType struct {
	Where           *schema.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where,proto3" json:"where,omitempty"`
	Protocol        string                         `protobuf:"bytes,9,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Port            uint32                         `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	HealthCheckPort uint32                         `protobuf:"varint,12,opt,name=health_check_port,json=healthCheckPort,proto3" json:"health_check_port,omitempty"`
	// Types that are valid to be assigned to EndpointAddress:
	//	*GetSpecType_Ip
	//	*GetSpecType_DnsName
	//	*GetSpecType_DnsNameAdvanced
	//	*GetSpecType_ServiceInfo
	EndpointAddress isGetSpecType_EndpointAddress `protobuf_oneof:"endpoint_address"`
	SnatPool        *views.SnatPoolConfiguration  `protobuf:"bytes,17,opt,name=snat_pool,json=snatPool,proto3" json:"snat_pool,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4b1d0fcf1d7e4b, []int{5}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_EndpointAddress interface {
	isGetSpecType_EndpointAddress()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_Ip struct {
	Ip string `protobuf:"bytes,3,opt,name=ip,proto3,oneof" json:"ip,omitempty"`
}
type GetSpecType_DnsName struct {
	DnsName string `protobuf:"bytes,4,opt,name=dns_name,json=dnsName,proto3,oneof" json:"dns_name,omitempty"`
}
type GetSpecType_DnsNameAdvanced struct {
	DnsNameAdvanced *DnsNameAdvancedType `protobuf:"bytes,11,opt,name=dns_name_advanced,json=dnsNameAdvanced,proto3,oneof" json:"dns_name_advanced,omitempty"`
}
type GetSpecType_ServiceInfo struct {
	ServiceInfo *ServiceInfoType `protobuf:"bytes,8,opt,name=service_info,json=serviceInfo,proto3,oneof" json:"service_info,omitempty"`
}

func (*GetSpecType_Ip) isGetSpecType_EndpointAddress()              {}
func (*GetSpecType_DnsName) isGetSpecType_EndpointAddress()         {}
func (*GetSpecType_DnsNameAdvanced) isGetSpecType_EndpointAddress() {}
func (*GetSpecType_ServiceInfo) isGetSpecType_EndpointAddress()     {}

func (m *GetSpecType) GetEndpointAddress() isGetSpecType_EndpointAddress {
	if m != nil {
		return m.EndpointAddress
	}
	return nil
}

func (m *GetSpecType) GetWhere() *schema.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *GetSpecType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *GetSpecType) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *GetSpecType) GetHealthCheckPort() uint32 {
	if m != nil {
		return m.HealthCheckPort
	}
	return 0
}

func (m *GetSpecType) GetIp() string {
	if x, ok := m.GetEndpointAddress().(*GetSpecType_Ip); ok {
		return x.Ip
	}
	return ""
}

func (m *GetSpecType) GetDnsName() string {
	if x, ok := m.GetEndpointAddress().(*GetSpecType_DnsName); ok {
		return x.DnsName
	}
	return ""
}

func (m *GetSpecType) GetDnsNameAdvanced() *DnsNameAdvancedType {
	if x, ok := m.GetEndpointAddress().(*GetSpecType_DnsNameAdvanced); ok {
		return x.DnsNameAdvanced
	}
	return nil
}

func (m *GetSpecType) GetServiceInfo() *ServiceInfoType {
	if x, ok := m.GetEndpointAddress().(*GetSpecType_ServiceInfo); ok {
		return x.ServiceInfo
	}
	return nil
}

func (m *GetSpecType) GetSnatPool() *views.SnatPoolConfiguration {
	if m != nil {
		return m.SnatPool
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_Ip)(nil),
		(*GetSpecType_DnsName)(nil),
		(*GetSpecType_DnsNameAdvanced)(nil),
		(*GetSpecType_ServiceInfo)(nil),
	}
}

// K8SInfo
//
// x-displayName: "K8s Info"
// Discovered Information for Kubernetes endpoints
type K8SInfo struct {
	// in_cluster_discovery
	//
	// x-displayName: "In Cluster Discovery"
	// x-example: true
	// Specifies whether discovery is from local Kubernetes cluster
	InClusterDiscovery bool `protobuf:"varint,1,opt,name=in_cluster_discovery,json=inClusterDiscovery,proto3" json:"in_cluster_discovery,omitempty"`
	// pod_name
	//
	// x-displayName: "Name of Pod"
	// x-example: "ver-l99cw"
	// Pod Names of the endpoint
	PodName []string `protobuf:"bytes,2,rep,name=pod_name,json=podName,proto3" json:"pod_name,omitempty"`
	// labels
	//
	// x-displayName: "labels"
	// labels of service
	Labels map[string]string `protobuf:"bytes,3,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *K8SInfo) Reset()      { *m = K8SInfo{} }
func (*K8SInfo) ProtoMessage() {}
func (*K8SInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4b1d0fcf1d7e4b, []int{6}
}
func (m *K8SInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *K8SInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SInfo.Merge(m, src)
}
func (m *K8SInfo) XXX_Size() int {
	return m.Size()
}
func (m *K8SInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SInfo.DiscardUnknown(m)
}

var xxx_messageInfo_K8SInfo proto.InternalMessageInfo

func (m *K8SInfo) GetInClusterDiscovery() bool {
	if m != nil {
		return m.InClusterDiscovery
	}
	return false
}

func (m *K8SInfo) GetPodName() []string {
	if m != nil {
		return m.PodName
	}
	return nil
}

func (m *K8SInfo) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// DNSInfo
//
// x-displayName: "DNS Info"
// Addresses resolved from DNS discovery
type DNSInfo struct {
	// x-displayName: "DNS resolved addresses"
	// x-example: "13.84.78.21"
	// IP addresses from DNS resolution
	ResolvedIps []string `protobuf:"bytes,1,rep,name=resolved_ips,json=resolvedIps,proto3" json:"resolved_ips,omitempty"`
}

func (m *DNSInfo) Reset()      { *m = DNSInfo{} }
func (*DNSInfo) ProtoMessage() {}
func (*DNSInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4b1d0fcf1d7e4b, []int{7}
}
func (m *DNSInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNSInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DNSInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNSInfo.Merge(m, src)
}
func (m *DNSInfo) XXX_Size() int {
	return m.Size()
}
func (m *DNSInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DNSInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DNSInfo proto.InternalMessageInfo

func (m *DNSInfo) GetResolvedIps() []string {
	if m != nil {
		return m.ResolvedIps
	}
	return nil
}

// ConsulInfo
//
// x-displayName: "Consul Info"
// Service instance resolved from Consul discovery
type ConsulInfo struct {
	// x-displayName: "Consul resolved service instance"
	// x-example: "web.service.consul"
	// Consul Service instance name
	InstanceName []string `protobuf:"bytes,1,rep,name=instance_name,json=instanceName,proto3" json:"instance_name,omitempty"`
	// labels
	//
	// x-displayName: "labels"
	// Tags on the service instance
	Labels map[string]string `protobuf:"bytes,2,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ConsulInfo) Reset()      { *m = ConsulInfo{} }
func (*ConsulInfo) ProtoMessage() {}
func (*ConsulInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4b1d0fcf1d7e4b, []int{8}
}
func (m *ConsulInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsulInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConsulInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsulInfo.Merge(m, src)
}
func (m *ConsulInfo) XXX_Size() int {
	return m.Size()
}
func (m *ConsulInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsulInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConsulInfo proto.InternalMessageInfo

func (m *ConsulInfo) GetInstanceName() []string {
	if m != nil {
		return m.InstanceName
	}
	return nil
}

func (m *ConsulInfo) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// DiscoveredInfoType
//
// x-displayName: "Discovered Info Type"
// Discovered Information for endpoints
type DiscoveredInfoType struct {
	// discovered_info
	//
	// x-displayName: "Discovered Info"
	// Discovered Information for endpoints
	//
	// Types that are valid to be assigned to DiscoveredInfo:
	//	*DiscoveredInfoType_K8SInfo
	//	*DiscoveredInfoType_ConsulInfo
	//	*DiscoveredInfoType_DnsInfo
	DiscoveredInfo isDiscoveredInfoType_DiscoveredInfo `protobuf_oneof:"discovered_info"`
}

func (m *DiscoveredInfoType) Reset()      { *m = DiscoveredInfoType{} }
func (*DiscoveredInfoType) ProtoMessage() {}
func (*DiscoveredInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4b1d0fcf1d7e4b, []int{9}
}
func (m *DiscoveredInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiscoveredInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DiscoveredInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscoveredInfoType.Merge(m, src)
}
func (m *DiscoveredInfoType) XXX_Size() int {
	return m.Size()
}
func (m *DiscoveredInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscoveredInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_DiscoveredInfoType proto.InternalMessageInfo

type isDiscoveredInfoType_DiscoveredInfo interface {
	isDiscoveredInfoType_DiscoveredInfo()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DiscoveredInfoType_K8SInfo struct {
	K8SInfo *K8SInfo `protobuf:"bytes,1,opt,name=k8s_info,json=k8sInfo,proto3,oneof" json:"k8s_info,omitempty"`
}
type DiscoveredInfoType_ConsulInfo struct {
	ConsulInfo *ConsulInfo `protobuf:"bytes,2,opt,name=consul_info,json=consulInfo,proto3,oneof" json:"consul_info,omitempty"`
}
type DiscoveredInfoType_DnsInfo struct {
	DnsInfo *DNSInfo `protobuf:"bytes,3,opt,name=dns_info,json=dnsInfo,proto3,oneof" json:"dns_info,omitempty"`
}

func (*DiscoveredInfoType_K8SInfo) isDiscoveredInfoType_DiscoveredInfo()    {}
func (*DiscoveredInfoType_ConsulInfo) isDiscoveredInfoType_DiscoveredInfo() {}
func (*DiscoveredInfoType_DnsInfo) isDiscoveredInfoType_DiscoveredInfo()    {}

func (m *DiscoveredInfoType) GetDiscoveredInfo() isDiscoveredInfoType_DiscoveredInfo {
	if m != nil {
		return m.DiscoveredInfo
	}
	return nil
}

func (m *DiscoveredInfoType) GetK8SInfo() *K8SInfo {
	if x, ok := m.GetDiscoveredInfo().(*DiscoveredInfoType_K8SInfo); ok {
		return x.K8SInfo
	}
	return nil
}

func (m *DiscoveredInfoType) GetConsulInfo() *ConsulInfo {
	if x, ok := m.GetDiscoveredInfo().(*DiscoveredInfoType_ConsulInfo); ok {
		return x.ConsulInfo
	}
	return nil
}

func (m *DiscoveredInfoType) GetDnsInfo() *DNSInfo {
	if x, ok := m.GetDiscoveredInfo().(*DiscoveredInfoType_DnsInfo); ok {
		return x.DnsInfo
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DiscoveredInfoType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DiscoveredInfoType_K8SInfo)(nil),
		(*DiscoveredInfoType_ConsulInfo)(nil),
		(*DiscoveredInfoType_DnsInfo)(nil),
	}
}

// HealthCheckInfoType
//
// x-displayName: "Health Check Info"
// Health status information sent for endpoints
type HealthCheckInfoType struct {
	// health_check
	//
	// x-displayName: "Health check"
	// Health check object details
	HealthCheck *views.ObjectRefType `protobuf:"bytes,1,opt,name=health_check,json=healthCheck,proto3" json:"health_check,omitempty"`
	// health_status
	//
	// x-displayName: "Health status"
	// Health status information
	HealthStatus string `protobuf:"bytes,2,opt,name=health_status,json=healthStatus,proto3" json:"health_status,omitempty"`
	// HealthStatusFailureReason
	//
	// x-displayName: "Health Status Failure Reason"
	// Applicable only if health status is unhealthy.
	HealthStatusFailureReason string `protobuf:"bytes,3,opt,name=health_status_failure_reason,json=healthStatusFailureReason,proto3" json:"health_status_failure_reason,omitempty"`
	// HealthStatusFailureDetails
	//
	// x-displayName: "Health Status Failure Details"
	// Applicable only if health status is unhealthy.
	HealthStatusFailureDetails string `protobuf:"bytes,4,opt,name=health_status_failure_details,json=healthStatusFailureDetails,proto3" json:"health_status_failure_details,omitempty"`
	// HealthStatusUpdateTime
	//
	// x-displayName: "Health Status Update Time"
	// Health Status updated time
	HealthStatusUpdateTime *types.Timestamp `protobuf:"bytes,5,opt,name=health_status_update_time,json=healthStatusUpdateTime,proto3" json:"health_status_update_time,omitempty"`
	// LastHealthStatusFailureReason
	//
	// x-displayName: "Last Health Status Failure Reason"
	// Applicable only if health status was unhealthy in last state.
	LastHealthStatusFailureReason string `protobuf:"bytes,6,opt,name=last_health_status_failure_reason,json=lastHealthStatusFailureReason,proto3" json:"last_health_status_failure_reason,omitempty"`
	// LastHealthStatusFailureDetails
	//
	// x-displayName: "Last Health Status Failure Details"
	// Applicable only if health status was unhealthy in last state.
	LastHealthStatusFailureDetails string `protobuf:"bytes,7,opt,name=last_health_status_failure_details,json=lastHealthStatusFailureDetails,proto3" json:"last_health_status_failure_details,omitempty"`
	// LastHealthStatusUpdateTime
	//
	// x-displayName: "Last Health Status Updated Time"
	// Health Status updated last time
	LastHealthStatusUpdateTime *types.Timestamp `protobuf:"bytes,8,opt,name=last_health_status_update_time,json=lastHealthStatusUpdateTime,proto3" json:"last_health_status_update_time,omitempty"`
}

func (m *HealthCheckInfoType) Reset()      { *m = HealthCheckInfoType{} }
func (*HealthCheckInfoType) ProtoMessage() {}
func (*HealthCheckInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4b1d0fcf1d7e4b, []int{10}
}
func (m *HealthCheckInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthCheckInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HealthCheckInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthCheckInfoType.Merge(m, src)
}
func (m *HealthCheckInfoType) XXX_Size() int {
	return m.Size()
}
func (m *HealthCheckInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthCheckInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_HealthCheckInfoType proto.InternalMessageInfo

func (m *HealthCheckInfoType) GetHealthCheck() *views.ObjectRefType {
	if m != nil {
		return m.HealthCheck
	}
	return nil
}

func (m *HealthCheckInfoType) GetHealthStatus() string {
	if m != nil {
		return m.HealthStatus
	}
	return ""
}

func (m *HealthCheckInfoType) GetHealthStatusFailureReason() string {
	if m != nil {
		return m.HealthStatusFailureReason
	}
	return ""
}

func (m *HealthCheckInfoType) GetHealthStatusFailureDetails() string {
	if m != nil {
		return m.HealthStatusFailureDetails
	}
	return ""
}

func (m *HealthCheckInfoType) GetHealthStatusUpdateTime() *types.Timestamp {
	if m != nil {
		return m.HealthStatusUpdateTime
	}
	return nil
}

func (m *HealthCheckInfoType) GetLastHealthStatusFailureReason() string {
	if m != nil {
		return m.LastHealthStatusFailureReason
	}
	return ""
}

func (m *HealthCheckInfoType) GetLastHealthStatusFailureDetails() string {
	if m != nil {
		return m.LastHealthStatusFailureDetails
	}
	return ""
}

func (m *HealthCheckInfoType) GetLastHealthStatusUpdateTime() *types.Timestamp {
	if m != nil {
		return m.LastHealthStatusUpdateTime
	}
	return nil
}

// VerStatusType
//
// x-displayName: "VER Status Type"
// Status information sent for endpoints
type VerStatusType struct {
	// service_name
	//
	// x-displayName: "Service Name"
	// x-example: "productpage"
	// Service Name of the endpoint
	ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	// discovered_ip
	//
	// x-displayName: "Discovered IP"
	// Discovered IP of the endpoint
	DiscoveredIp *schema.IpAddressType `protobuf:"bytes,2,opt,name=discovered_ip,json=discoveredIp,proto3" json:"discovered_ip,omitempty"`
	// discovered_port
	//
	// x-displayName: "Discovered Port"
	// x-example: 9080
	// Discovered port of the endpoint
	DiscoveredPort uint32 `protobuf:"varint,3,opt,name=discovered_port,json=discoveredPort,proto3" json:"discovered_port,omitempty"`
	// allocated_ip
	//
	// x-displayName: "Allocated IP"
	// Allocated AIN IP of the endpoint
	AllocatedIp *schema.Ipv6AddressType `protobuf:"bytes,4,opt,name=allocated_ip,json=allocatedIp,proto3" json:"allocated_ip,omitempty"`
	// site
	//
	// x-displayName: "Site"
	// x-example: "ce01"
	// site name of the endpoint
	Site string `protobuf:"bytes,5,opt,name=site,proto3" json:"site,omitempty"`
	// Health Status
	//
	// x-displayName: "Health Status"
	// Map of HealthCheck UID to health status
	HealthStatus map[string]HealthStatus `protobuf:"bytes,6,rep,name=health_status,json=healthStatus,proto3" json:"health_status,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=ves.io.schema.endpoint.HealthStatus"` // Deprecated: Do not use.
	// DiscoveredInfoType
	//
	// x-displayName: "Discovered Info"
	// Discovered Information for endpoints
	DiscoveredInfo *DiscoveredInfoType `protobuf:"bytes,7,opt,name=discovered_info,json=discoveredInfo,proto3" json:"discovered_info,omitempty"`
	// Health Check Info
	//
	// x-displayName: "Health Check Info"
	// Health check information for endpoints
	HealthCheckDetails []*HealthCheckInfoType `protobuf:"bytes,8,rep,name=health_check_details,json=healthCheckDetails,proto3" json:"health_check_details,omitempty"`
}

func (m *VerStatusType) Reset()      { *m = VerStatusType{} }
func (*VerStatusType) ProtoMessage() {}
func (*VerStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4b1d0fcf1d7e4b, []int{11}
}
func (m *VerStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VerStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerStatusType.Merge(m, src)
}
func (m *VerStatusType) XXX_Size() int {
	return m.Size()
}
func (m *VerStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_VerStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_VerStatusType proto.InternalMessageInfo

func (m *VerStatusType) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *VerStatusType) GetDiscoveredIp() *schema.IpAddressType {
	if m != nil {
		return m.DiscoveredIp
	}
	return nil
}

func (m *VerStatusType) GetDiscoveredPort() uint32 {
	if m != nil {
		return m.DiscoveredPort
	}
	return 0
}

func (m *VerStatusType) GetAllocatedIp() *schema.Ipv6AddressType {
	if m != nil {
		return m.AllocatedIp
	}
	return nil
}

func (m *VerStatusType) GetSite() string {
	if m != nil {
		return m.Site
	}
	return ""
}

// Deprecated: Do not use.
func (m *VerStatusType) GetHealthStatus() map[string]HealthStatus {
	if m != nil {
		return m.HealthStatus
	}
	return nil
}

func (m *VerStatusType) GetDiscoveredInfo() *DiscoveredInfoType {
	if m != nil {
		return m.DiscoveredInfo
	}
	return nil
}

func (m *VerStatusType) GetHealthCheckDetails() []*HealthCheckInfoType {
	if m != nil {
		return m.HealthCheckDetails
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.endpoint.HealthStatus", HealthStatus_name, HealthStatus_value)
	golang_proto.RegisterEnum("ves.io.schema.endpoint.HealthStatus", HealthStatus_name, HealthStatus_value)
	proto.RegisterType((*ServiceInfoType)(nil), "ves.io.schema.endpoint.ServiceInfoType")
	golang_proto.RegisterType((*ServiceInfoType)(nil), "ves.io.schema.endpoint.ServiceInfoType")
	proto.RegisterType((*DnsNameAdvancedType)(nil), "ves.io.schema.endpoint.DnsNameAdvancedType")
	golang_proto.RegisterType((*DnsNameAdvancedType)(nil), "ves.io.schema.endpoint.DnsNameAdvancedType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.endpoint.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.endpoint.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.endpoint.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.endpoint.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.endpoint.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.endpoint.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.endpoint.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.endpoint.GetSpecType")
	proto.RegisterType((*K8SInfo)(nil), "ves.io.schema.endpoint.K8SInfo")
	golang_proto.RegisterType((*K8SInfo)(nil), "ves.io.schema.endpoint.K8SInfo")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.endpoint.K8SInfo.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.endpoint.K8SInfo.LabelsEntry")
	proto.RegisterType((*DNSInfo)(nil), "ves.io.schema.endpoint.DNSInfo")
	golang_proto.RegisterType((*DNSInfo)(nil), "ves.io.schema.endpoint.DNSInfo")
	proto.RegisterType((*ConsulInfo)(nil), "ves.io.schema.endpoint.ConsulInfo")
	golang_proto.RegisterType((*ConsulInfo)(nil), "ves.io.schema.endpoint.ConsulInfo")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.endpoint.ConsulInfo.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.endpoint.ConsulInfo.LabelsEntry")
	proto.RegisterType((*DiscoveredInfoType)(nil), "ves.io.schema.endpoint.DiscoveredInfoType")
	golang_proto.RegisterType((*DiscoveredInfoType)(nil), "ves.io.schema.endpoint.DiscoveredInfoType")
	proto.RegisterType((*HealthCheckInfoType)(nil), "ves.io.schema.endpoint.HealthCheckInfoType")
	golang_proto.RegisterType((*HealthCheckInfoType)(nil), "ves.io.schema.endpoint.HealthCheckInfoType")
	proto.RegisterType((*VerStatusType)(nil), "ves.io.schema.endpoint.VerStatusType")
	golang_proto.RegisterType((*VerStatusType)(nil), "ves.io.schema.endpoint.VerStatusType")
	proto.RegisterMapType((map[string]HealthStatus)(nil), "ves.io.schema.endpoint.VerStatusType.HealthStatusEntry")
	golang_proto.RegisterMapType((map[string]HealthStatus)(nil), "ves.io.schema.endpoint.VerStatusType.HealthStatusEntry")
}

func init() {
	proto.RegisterFile("ves.io/schema/endpoint/types.proto", fileDescriptor_3c4b1d0fcf1d7e4b)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/endpoint/types.proto", fileDescriptor_3c4b1d0fcf1d7e4b)
}

var fileDescriptor_3c4b1d0fcf1d7e4b = []byte{
	// 2187 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0xcf, 0x6f, 0x1b, 0xc7,
	0x15, 0xe6, 0x90, 0x2b, 0x6a, 0xf9, 0x48, 0x8a, 0xd4, 0x4a, 0xb1, 0x68, 0xda, 0xa2, 0x68, 0xda,
	0x6d, 0x14, 0x99, 0xa6, 0xac, 0x1f, 0xb1, 0x65, 0x25, 0x75, 0x2a, 0xca, 0xaa, 0x29, 0x45, 0x70,
	0xd4, 0xa5, 0x1c, 0x20, 0x2d, 0xda, 0xc5, 0x8a, 0x1c, 0x51, 0x5b, 0xad, 0x76, 0x17, 0x3b, 0x23,
	0x3a, 0x3a, 0x14, 0x30, 0x82, 0x02, 0x2d, 0x72, 0xea, 0x39, 0xc7, 0x5e, 0xda, 0xff, 0xa0, 0x40,
	0x99, 0x83, 0x10, 0xa0, 0x40, 0xe1, 0x93, 0x80, 0x02, 0x85, 0x51, 0xa0, 0x40, 0x4c, 0x5f, 0xdc,
	0x4b, 0x61, 0x14, 0x48, 0x61, 0x14, 0x05, 0x52, 0xec, 0xcc, 0x2e, 0xb9, 0x5c, 0x51, 0xb4, 0x51,
	0x18, 0xbd, 0x24, 0xb7, 0xe5, 0xce, 0x7b, 0x6f, 0xde, 0xf7, 0xe6, 0x7b, 0xdf, 0xcc, 0x2c, 0xa1,
	0xd0, 0xc4, 0xa4, 0xa4, 0x99, 0xb3, 0xa4, 0xb6, 0x87, 0x0f, 0xd4, 0x59, 0x6c, 0xd4, 0x2d, 0x53,
	0x33, 0xe8, 0x2c, 0x3d, 0xb2, 0x30, 0x29, 0x59, 0xb6, 0x49, 0x4d, 0xe9, 0x1c, 0xb7, 0x29, 0x71,
	0x9b, 0x92, 0x67, 0x93, 0xbd, 0xd6, 0xd0, 0xe8, 0xde, 0xe1, 0x4e, 0xa9, 0x66, 0x1e, 0xcc, 0x36,
	0xcc, 0x86, 0x39, 0xcb, 0xcc, 0x77, 0x0e, 0x77, 0xd9, 0x2f, 0xf6, 0x83, 0x3d, 0xf1, 0x30, 0xd9,
	0xa9, 0x86, 0x69, 0x36, 0x74, 0xdc, 0xb5, 0xa2, 0xda, 0x01, 0x26, 0x54, 0x3d, 0xb0, 0x5c, 0x83,
	0x89, 0xde, 0x5c, 0x0c, 0x4c, 0xdd, 0x81, 0x0b, 0xbd, 0x03, 0xa6, 0x45, 0x35, 0xd3, 0x70, 0xb3,
	0xcb, 0x9e, 0xef, 0x1d, 0xf4, 0x25, 0x9e, 0xbd, 0xd8, 0x3b, 0xd4, 0x54, 0x75, 0xad, 0xae, 0x52,
	0xec, 0x8e, 0xe6, 0x03, 0xa3, 0x1a, 0x7e, 0xa0, 0xf4, 0x86, 0xbe, 0x7a, 0xda, 0x82, 0xcc, 0x9a,
	0xb6, 0xd6, 0xd0, 0x0c, 0xc5, 0x32, 0x4d, 0xbd, 0x67, 0xb2, 0xa9, 0x7e, 0xc6, 0x3e, 0x83, 0xc2,
	0x6f, 0xc3, 0x90, 0xaa, 0x62, 0xbb, 0xa9, 0xd5, 0xf0, 0xba, 0xb1, 0x6b, 0x6e, 0x1f, 0x59, 0x58,
	0xaa, 0xc2, 0x48, 0x5d, 0x23, 0x35, 0xb3, 0x89, 0xed, 0x23, 0xc5, 0x31, 0xce, 0xa0, 0x3c, 0x9a,
	0x1e, 0x99, 0xbf, 0x58, 0xea, 0xad, 0xf9, 0x1d, 0xcf, 0xc8, 0xf1, 0x2a, 0x8f, 0xbc, 0x68, 0xa1,
	0xd0, 0x1f, 0xfe, 0x7e, 0x1c, 0x19, 0xfa, 0x04, 0x85, 0xf3, 0x21, 0x39, 0x59, 0xf7, 0x0f, 0x4b,
	0x0b, 0x90, 0x20, 0x7c, 0x1e, 0xc5, 0x50, 0x0f, 0x70, 0x26, 0x9c, 0x47, 0xd3, 0x31, 0x9f, 0x93,
	0x1d, 0x99, 0x7e, 0x18, 0xae, 0x84, 0xe4, 0xb8, 0x6b, 0x75, 0x4f, 0x3d, 0xc0, 0xd2, 0x8f, 0x21,
	0xed, 0x39, 0x11, 0xac, 0xe3, 0x1a, 0x35, 0xed, 0x4c, 0x24, 0x8f, 0xa6, 0xe3, 0xf3, 0xf9, 0x40,
	0x2e, 0x9b, 0xea, 0x0e, 0xd6, 0xab, 0xae, 0x0d, 0xcb, 0x27, 0xe1, 0x84, 0xfe, 0xec, 0x73, 0x24,
	0x40, 0x38, 0x84, 0x2a, 0x21, 0x39, 0xe5, 0x46, 0xf2, 0x8c, 0x96, 0xa3, 0xff, 0xbc, 0x1d, 0x99,
	0x2b, 0x2e, 0x96, 0xa7, 0xba, 0x99, 0x69, 0xc6, 0xae, 0x29, 0xa5, 0x8e, 0x5b, 0x28, 0x72, 0xd2,
	0x42, 0x42, 0xbb, 0x85, 0x22, 0xf3, 0xc5, 0x85, 0x0d, 0x41, 0x14, 0xd2, 0x43, 0x85, 0x7f, 0x20,
	0x18, 0xbb, 0x63, 0x10, 0x27, 0xaf, 0x95, 0x7a, 0x53, 0x35, 0x6a, 0xb8, 0xce, 0x80, 0x5d, 0x05,
	0x81, 0x01, 0x42, 0x0c, 0xd0, 0x84, 0x0f, 0x50, 0xe6, 0x61, 0xd8, 0x79, 0x12, 0xec, 0xf0, 0x1e,
	0x92, 0x99, 0x91, 0x74, 0x1b, 0x80, 0x50, 0x5b, 0xab, 0x51, 0x85, 0x52, 0xdd, 0x85, 0x32, 0x1e,
	0x80, 0xb2, 0x76, 0x60, 0xd1, 0xa3, 0xf2, 0xf0, 0xe3, 0x9f, 0xa3, 0x67, 0x2d, 0xe4, 0x64, 0x1e,
	0xe3, 0x2e, 0xdb, 0x54, 0x97, 0xd6, 0x20, 0x6d, 0xe3, 0x5d, 0x1b, 0x93, 0x3d, 0x45, 0x33, 0x28,
	0xb6, 0x9b, 0xaa, 0x9e, 0x11, 0xf2, 0x68, 0x3a, 0x59, 0xce, 0xfc, 0xb5, 0x85, 0x22, 0x0b, 0xd7,
	0xaf, 0x7b, 0xf3, 0x8b, 0x33, 0xd1, 0xcc, 0xc3, 0xaf, 0xae, 0x4c, 0x83, 0x03, 0xdd, 0xf5, 0x59,
	0x77, 0x5d, 0xca, 0x93, 0x00, 0x94, 0xea, 0x4a, 0x6d, 0xcf, 0xd4, 0x6a, 0x98, 0x01, 0x16, 0x4e,
	0x5a, 0x28, 0xec, 0x00, 0x5e, 0x28, 0x2e, 0x6e, 0x08, 0x62, 0x38, 0x1d, 0x29, 0xfc, 0x46, 0x84,
	0x91, 0xbb, 0xba, 0xb9, 0xa3, 0xea, 0x55, 0x0b, 0xd7, 0x18, 0xd6, 0x15, 0x18, 0x7a, 0xb0, 0x87,
	0x6d, 0x0e, 0x36, 0x3e, 0xff, 0x9d, 0x40, 0xe6, 0xf7, 0x30, 0x7d, 0x60, 0xda, 0xfb, 0x55, 0x8d,
	0x62, 0x19, 0xef, 0x7a, 0x85, 0x2e, 0x0b, 0xcf, 0x5b, 0x08, 0xc9, 0xdc, 0x53, 0x5a, 0x02, 0x91,
	0x31, 0xaf, 0x66, 0xea, 0x99, 0x18, 0x2b, 0xd9, 0x45, 0x27, 0xf3, 0xed, 0xd5, 0x2d, 0x2f, 0xf3,
	0x84, 0x0d, 0xb2, 0xf3, 0x5b, 0x8e, 0xdc, 0xbf, 0xb3, 0x25, 0x77, 0xac, 0xa5, 0xcb, 0x20, 0x58,
	0xa6, 0x4d, 0x19, 0x73, 0x92, 0xe5, 0x94, 0x67, 0x1e, 0x9d, 0x11, 0x32, 0x5f, 0x7f, 0x1d, 0x91,
	0xd9, 0xa0, 0xf4, 0x1e, 0x8c, 0xee, 0x61, 0x55, 0xa7, 0x7b, 0x4a, 0x6d, 0x0f, 0xd7, 0xf6, 0x15,
	0xe6, 0x91, 0x60, 0x1e, 0x63, 0xc7, 0x2d, 0x84, 0x82, 0x5e, 0x29, 0x6e, 0xbd, 0xea, 0x18, 0x6f,
	0x39, 0x01, 0xa6, 0x20, 0xac, 0x59, 0x6c, 0x65, 0x62, 0xe5, 0xa4, 0x67, 0x2d, 0xd8, 0x61, 0xcb,
	0x59, 0x89, 0xb0, 0x66, 0x49, 0x8b, 0x20, 0xd6, 0x0d, 0xc2, 0x49, 0x2c, 0x0c, 0x5c, 0xf3, 0x4a,
	0x48, 0x1e, 0xae, 0x73, 0xc6, 0x48, 0x0a, 0x8c, 0x7a, 0x5e, 0x8a, 0xea, 0xd2, 0x27, 0x13, 0x67,
	0x55, 0xbc, 0x5a, 0xea, 0x2f, 0x65, 0xa5, 0x3e, 0x6c, 0x2b, 0x0b, 0xc7, 0x9c, 0x13, 0xa9, 0x7a,
	0xef, 0xa0, 0xb4, 0x09, 0x13, 0x0e, 0x8b, 0xb1, 0xad, 0x63, 0x42, 0x94, 0x9e, 0x56, 0x8b, 0xb2,
	0x2c, 0xa5, 0x67, 0x3e, 0xf8, 0x3c, 0xd3, 0x4a, 0x48, 0x7e, 0xa3, 0xeb, 0x54, 0xf5, 0x35, 0xde,
	0x66, 0x6f, 0x4f, 0x64, 0x44, 0x96, 0xe9, 0x9b, 0x67, 0x65, 0x1a, 0x50, 0x10, 0x5f, 0x1b, 0x3b,
	0xaf, 0xa4, 0x6d, 0x38, 0xb7, 0xbf, 0x44, 0x94, 0x9a, 0x7e, 0x48, 0x28, 0xb6, 0x15, 0xd5, 0xd2,
	0x14, 0x3e, 0x6d, 0x26, 0xf9, 0x6a, 0x1d, 0x30, 0xb6, 0xbf, 0x44, 0x56, 0xb9, 0xf7, 0x8a, 0xa5,
	0x55, 0x99, 0xaf, 0xf4, 0x0e, 0x24, 0x0d, 0x53, 0xb1, 0x6c, 0xbc, 0x8b, 0x6d, 0x6c, 0xd4, 0x70,
	0x26, 0x75, 0x76, 0xb0, 0x0a, 0x92, 0x13, 0x86, 0xb9, 0xd5, 0xb1, 0x95, 0x7e, 0x08, 0x69, 0xa2,
	0x51, 0xec, 0x73, 0x27, 0x99, 0x34, 0xf3, 0xbf, 0x12, 0xf0, 0x77, 0xd9, 0xcc, 0x8d, 0x36, 0x35,
	0x42, 0x19, 0x42, 0x24, 0xa7, 0x1c, 0xff, 0x6e, 0x44, 0x22, 0xdd, 0x85, 0x18, 0x31, 0x54, 0xca,
	0x44, 0x38, 0x33, 0xca, 0x62, 0xcd, 0x04, 0x62, 0x31, 0xfd, 0x2d, 0x55, 0x0d, 0x95, 0x6e, 0x99,
	0xa6, 0xbe, 0x6a, 0x1a, 0xbb, 0x5a, 0xe3, 0xd0, 0x56, 0x1d, 0x79, 0x97, 0x45, 0xe2, 0xbe, 0x5e,
	0xfe, 0xde, 0x17, 0x2d, 0x74, 0x0b, 0xbe, 0x0b, 0x13, 0x1f, 0x30, 0x55, 0xcf, 0x73, 0xbc, 0xd3,
	0x6b, 0x6e, 0xb5, 0xdf, 0x92, 0xe2, 0x73, 0xd7, 0x8b, 0xb7, 0x8a, 0xf3, 0xc5, 0xb9, 0xf9, 0xe2,
	0x1c, 0xa4, 0x20, 0x56, 0xbd, 0xb7, 0xb2, 0x9d, 0x77, 0x5c, 0xa5, 0xf0, 0xdc, 0xcd, 0xf2, 0x34,
	0xa4, 0xbd, 0x85, 0x51, 0xd4, 0x7a, 0xdd, 0xc6, 0x84, 0x48, 0xe3, 0xae, 0xa6, 0x41, 0xbb, 0x85,
	0xc4, 0x85, 0xe2, 0x62, 0x71, 0xa9, 0x38, 0x37, 0x57, 0x7e, 0x0b, 0xd2, 0x96, 0x6d, 0x7e, 0xac,
	0x1d, 0x68, 0xf4, 0xc8, 0x13, 0x83, 0x37, 0x8e, 0x5b, 0x28, 0x75, 0xd2, 0x42, 0x23, 0xed, 0x16,
	0x1a, 0x9a, 0x7b, 0xbb, 0x38, 0x77, 0xe3, 0x45, 0x0b, 0xa1, 0x0d, 0x41, 0x1c, 0x4a, 0x47, 0x37,
	0x04, 0x71, 0x38, 0x2d, 0x6e, 0x08, 0x22, 0xa4, 0xe3, 0x1b, 0x82, 0x38, 0x92, 0x4e, 0x15, 0x7e,
	0x29, 0xc0, 0xc8, 0xaa, 0x8d, 0x55, 0x8a, 0x3b, 0x22, 0xf1, 0xce, 0xff, 0x22, 0x12, 0x9e, 0x3c,
	0x64, 0x83, 0xf2, 0xe0, 0x13, 0x00, 0xc9, 0x2f, 0x00, 0x6e, 0xbf, 0xcf, 0x9c, 0xd9, 0xef, 0xa7,
	0x5b, 0x3b, 0xdd, 0x6d, 0x6d, 0xb7, 0x97, 0x2f, 0x04, 0x7b, 0xd9, 0xdf, 0xb2, 0x1f, 0xbd, 0x9e,
	0x96, 0xed, 0xdf, 0xac, 0xaf, 0xb3, 0xbd, 0x5e, 0x1b, 0xf1, 0x46, 0x1f, 0xdd, 0x0e, 0x28, 0x7e,
	0x7f, 0x32, 0x7d, 0xf2, 0x6f, 0x74, 0xea, 0x6d, 0xe1, 0x57, 0x02, 0xa4, 0x64, 0x6c, 0xe9, 0x6a,
	0xed, 0x5b, 0x2a, 0x7c, 0xc3, 0xa9, 0xf0, 0x0b, 0x01, 0xe2, 0x77, 0x31, 0xfd, 0x96, 0x06, 0xdf,
	0x6c, 0x1a, 0x7c, 0x85, 0x60, 0xf8, 0xfd, 0xa5, 0x2a, 0xcb, 0xe8, 0x3a, 0x8c, 0x6b, 0x46, 0xe7,
	0x04, 0xd0, 0xb9, 0x1a, 0x30, 0x46, 0x88, 0xb2, 0xa4, 0x19, 0xee, 0xf6, 0xde, 0xb9, 0x53, 0x48,
	0xe7, 0x41, 0xb4, 0xcc, 0xba, 0x77, 0x59, 0x88, 0x4c, 0xc7, 0xe4, 0x61, 0xcb, 0xac, 0xb3, 0x75,
	0xd8, 0x81, 0xa8, 0xee, 0x9c, 0xf7, 0x49, 0x26, 0x92, 0x8f, 0x0c, 0x2a, 0xbe, 0x3b, 0x3b, 0xbf,
	0x1d, 0x90, 0x35, 0x83, 0xda, 0x47, 0xe5, 0x49, 0xef, 0x4e, 0xc0, 0xce, 0x41, 0x9f, 0xa1, 0x70,
	0x3a, 0xdf, 0xfe, 0xf2, 0x8f, 0x91, 0xe8, 0xa7, 0x9f, 0xa3, 0xb0, 0x18, 0x92, 0xdd, 0xc8, 0xd9,
	0x5b, 0x10, 0xf7, 0x79, 0x49, 0x69, 0x88, 0xec, 0x63, 0x9e, 0x6e, 0x4c, 0x76, 0x1e, 0xa5, 0x71,
	0x18, 0x6a, 0xaa, 0xfa, 0xa1, 0x7b, 0x93, 0x91, 0xf9, 0x8f, 0xe5, 0xf0, 0x12, 0x2a, 0x14, 0x61,
	0xf8, 0xce, 0x3d, 0x0e, 0xfb, 0x12, 0x24, 0x6c, 0x4c, 0x4c, 0xbd, 0x89, 0xeb, 0x8a, 0x66, 0x91,
	0x0c, 0x62, 0x40, 0xe2, 0xde, 0xbb, 0x75, 0x8b, 0x14, 0xfe, 0x8c, 0x00, 0x56, 0x4d, 0x83, 0x1c,
	0xea, 0xcc, 0xe3, 0x32, 0x24, 0x35, 0x83, 0x50, 0x87, 0x15, 0x8a, 0x7b, 0xaf, 0x70, 0x5c, 0x12,
	0xde, 0x4b, 0x56, 0x00, 0xdc, 0x29, 0x40, 0x98, 0x15, 0xa0, 0x74, 0x56, 0x01, 0xba, 0x81, 0xff,
	0xcf, 0x35, 0xf8, 0x17, 0x02, 0xc9, 0x5b, 0x4b, 0x5c, 0xef, 0x5c, 0x2d, 0xdf, 0x05, 0xd1, 0x39,
	0x09, 0x32, 0x8a, 0x73, 0x31, 0x98, 0x7a, 0xc9, 0xda, 0x39, 0xfd, 0xb7, 0xbf, 0x44, 0x58, 0x6d,
	0xd6, 0x20, 0x5e, 0x63, 0x80, 0x78, 0x80, 0x30, 0x0b, 0x50, 0x78, 0x39, 0xf6, 0x4a, 0x48, 0x86,
	0x5a, 0xb7, 0xc4, 0xef, 0xf2, 0x1e, 0x67, 0x31, 0x22, 0x83, 0x93, 0x70, 0xd7, 0xd1, 0x15, 0x01,
	0xe7, 0xb1, 0x3c, 0x01, 0xa9, 0x7a, 0x07, 0x18, 0xbf, 0x31, 0x3a, 0x97, 0x27, 0xc1, 0xbd, 0x26,
	0xfe, 0x5e, 0x84, 0xb1, 0x4a, 0x57, 0x66, 0x3a, 0xc8, 0xd7, 0x20, 0xe1, 0x97, 0x25, 0x17, 0x7d,
	0xa1, 0x6f, 0x57, 0x7e, 0xb0, 0xf3, 0x33, 0x5c, 0xa3, 0x32, 0xde, 0x75, 0x3c, 0xe5, 0xb8, 0x4f,
	0xb5, 0x1c, 0x7a, 0xb8, 0x61, 0x08, 0x55, 0xe9, 0x21, 0x71, 0x2b, 0xef, 0xc6, 0xae, 0xb2, 0x77,
	0xd2, 0x7b, 0x70, 0xb1, 0xc7, 0x48, 0xd9, 0x55, 0x35, 0xfd, 0xd0, 0xc6, 0x8a, 0x8d, 0x55, 0x62,
	0x1a, 0x5c, 0xf0, 0xe4, 0xf3, 0x7e, 0x9f, 0x1f, 0x70, 0x0b, 0x99, 0x19, 0x48, 0x2b, 0x30, 0xd9,
	0x3f, 0x40, 0x1d, 0x53, 0x55, 0xd3, 0x09, 0x97, 0x46, 0x39, 0xdb, 0x27, 0xc2, 0x1d, 0x6e, 0x21,
	0xdd, 0x87, 0xf3, 0xbd, 0x21, 0x0e, 0xad, 0xba, 0x4a, 0xb1, 0x42, 0xb5, 0x03, 0x9c, 0x19, 0x62,
	0xe0, 0xb3, 0x25, 0xfe, 0xf1, 0xa5, 0xe4, 0x7d, 0x7c, 0x29, 0x6d, 0x7b, 0x1f, 0x5f, 0xe4, 0x73,
	0xfe, 0xd0, 0xf7, 0x99, 0xab, 0x33, 0x28, 0x55, 0xe0, 0x92, 0xae, 0x12, 0xaa, 0x0c, 0xc4, 0xc7,
	0x2e, 0x3c, 0xf2, 0xa4, 0x63, 0x58, 0x39, 0x13, 0xe3, 0x06, 0x14, 0x06, 0x44, 0xf2, 0x80, 0x0e,
	0xb3, 0x50, 0xb9, 0x33, 0x42, 0x79, 0x60, 0x7f, 0x0a, 0xb9, 0x3e, 0xb1, 0xfc, 0x88, 0xc5, 0x97,
	0x22, 0xce, 0x06, 0xe7, 0xe8, 0xa2, 0x5e, 0x6e, 0x47, 0x1e, 0xb5, 0xd0, 0xdf, 0x22, 0x70, 0x19,
	0x12, 0xdc, 0x22, 0xcf, 0xd8, 0x90, 0x1d, 0xeb, 0xdd, 0xeb, 0x4a, 0x8e, 0x60, 0x40, 0x1e, 0x92,
	0xae, 0x11, 0x8f, 0x93, 0x4d, 0x05, 0x38, 0x03, 0xb7, 0xe1, 0x62, 0x8f, 0x45, 0xde, 0x85, 0x93,
	0xe7, 0xa5, 0xc9, 0xe6, 0x06, 0xf3, 0x07, 0xbe, 0x0f, 0x93, 0xfd, 0xfd, 0xdd, 0x7a, 0x64, 0xa7,
	0x5e, 0xc2, 0x1f, 0x58, 0x82, 0xf3, 0xbd, 0x11, 0x38, 0xd8, 0xbc, 0x83, 0x36, 0x7b, 0x61, 0x00,
	0x75, 0xa0, 0x02, 0x97, 0x36, 0x55, 0x42, 0xf3, 0x03, 0x01, 0x5c, 0x7e, 0x05, 0x96, 0xc0, 0x06,
	0x14, 0x06, 0x44, 0xf2, 0xa0, 0x5c, 0x79, 0x15, 0x9a, 0x40, 0x19, 0x72, 0x7d, 0x62, 0xf9, 0x41,
	0xe5, 0x5f, 0x46, 0x91, 0xc2, 0x8b, 0x28, 0x24, 0x3f, 0xc4, 0x36, 0xf7, 0x65, 0x9a, 0x71, 0x29,
	0xf0, 0xcd, 0x8c, 0x2b, 0x6f, 0xcf, 0x17, 0xb2, 0x15, 0x48, 0xfa, 0xd5, 0xc8, 0x72, 0x45, 0x31,
	0xf8, 0xa9, 0x6e, 0xdd, 0x5a, 0xe1, 0x9b, 0x32, 0x53, 0x94, 0x44, 0xd7, 0x65, 0xdd, 0x92, 0xde,
	0xec, 0x11, 0x34, 0x76, 0x5c, 0x8a, 0xb0, 0xe3, 0xd2, 0x48, 0xf7, 0x35, 0x3b, 0x2d, 0xad, 0x40,
	0x42, 0xd5, 0x75, 0xb3, 0xa6, 0x52, 0x3e, 0x95, 0xc0, 0xa6, 0xca, 0x9d, 0x9a, 0xaa, 0x79, 0xc3,
	0x3f, 0x59, 0xbc, 0xe3, 0xb3, 0x6e, 0x39, 0x07, 0x36, 0xe7, 0xda, 0xcc, 0x04, 0x20, 0x26, 0xb3,
	0x67, 0xa9, 0x11, 0x94, 0xb4, 0x28, 0xdb, 0xd3, 0x6e, 0x9e, 0xa5, 0xc9, 0x3d, 0x35, 0x2a, 0xf9,
	0x3b, 0x86, 0x6f, 0x6e, 0x31, 0xf7, 0xbb, 0x41, 0x06, 0x05, 0x64, 0xb1, 0x7a, 0x4a, 0xb9, 0x59,
	0x7b, 0x9f, 0x3e, 0x1b, 0x75, 0xe5, 0xff, 0xd4, 0x0e, 0xe6, 0x2f, 0x0a, 0xdb, 0x4c, 0x7e, 0x02,
	0xe3, 0x3d, 0xc7, 0x4d, 0x4f, 0x38, 0xc4, 0xc1, 0x27, 0x93, 0x3e, 0x5b, 0x84, 0x2c, 0xf9, 0x84,
	0xde, 0xa3, 0x1f, 0x86, 0xd1, 0x53, 0x08, 0xfb, 0x6c, 0xc4, 0xcb, 0xfe, 0x8d, 0x78, 0xe4, 0xd4,
	0x37, 0x8c, 0xc0, 0xb4, 0x3c, 0x96, 0x6f, 0xbb, 0x5e, 0xfe, 0x0f, 0xfa, 0xa2, 0x85, 0x26, 0xe1,
	0x02, 0xc0, 0x87, 0xd8, 0x76, 0xe9, 0x2b, 0x25, 0xdf, 0x2e, 0xce, 0x17, 0x17, 0x8b, 0x0b, 0xc5,
	0xb9, 0xe2, 0xcd, 0xe2, 0xd2, 0xa3, 0x16, 0xfa, 0x0b, 0x82, 0x11, 0x10, 0x9c, 0x73, 0x7a, 0x36,
	0xca, 0x17, 0x12, 0xae, 0x04, 0xc4, 0x66, 0x63, 0x2c, 0xb0, 0x9a, 0x69, 0x61, 0x1a, 0xc1, 0xfb,
	0xf0, 0x46, 0xb7, 0x94, 0xf9, 0xf5, 0xad, 0xbc, 0x4b, 0x90, 0xf9, 0x79, 0x98, 0xe8, 0xa1, 0x6f,
	0x49, 0xb3, 0x9a, 0x8b, 0x25, 0xe7, 0x00, 0xd9, 0x67, 0xe0, 0x06, 0x1f, 0xb8, 0x0a, 0xe3, 0x2b,
	0x1e, 0xa5, 0x7c, 0xb1, 0x1c, 0x31, 0xf4, 0xd3, 0x93, 0x1b, 0x5f, 0x81, 0x94, 0x6f, 0x66, 0x87,
	0xdc, 0xd9, 0xd1, 0x53, 0x7c, 0x9f, 0x99, 0xf1, 0x74, 0xd5, 0x45, 0x1e, 0x87, 0xe1, 0xca, 0xda,
	0xca, 0xe6, 0x76, 0xe5, 0xa3, 0x74, 0x48, 0x4a, 0x42, 0xec, 0xfe, 0x3d, 0xef, 0x27, 0x2a, 0x7f,
	0x8a, 0x4e, 0x9e, 0xe4, 0x42, 0x8f, 0x9f, 0xe4, 0x42, 0xcf, 0x9f, 0xe4, 0xd0, 0xc3, 0x76, 0x0e,
	0xfd, 0xae, 0x9d, 0x43, 0x7f, 0x6a, 0xe7, 0xd0, 0x49, 0x3b, 0x87, 0x1e, 0xb7, 0x73, 0xe8, 0xcb,
	0x76, 0x0e, 0x3d, 0x6b, 0xe7, 0x42, 0xcf, 0xdb, 0x39, 0xf4, 0xeb, 0xa7, 0xb9, 0xd0, 0xf1, 0xd3,
	0x1c, 0x3a, 0x79, 0x9a, 0x0b, 0x3d, 0x7e, 0x9a, 0x0b, 0xfd, 0x68, 0xb3, 0x61, 0x5a, 0xfb, 0x8d,
	0x52, 0xd3, 0xd4, 0x29, 0xb6, 0x6d, 0xb5, 0x74, 0x48, 0x66, 0xd9, 0xc3, 0xae, 0x69, 0x1f, 0x5c,
	0xb3, 0x6c, 0xb3, 0xa9, 0xd5, 0xb1, 0x7d, 0xcd, 0x1b, 0x9e, 0xb5, 0x76, 0x1a, 0xe6, 0x2c, 0xfe,
	0x98, 0xba, 0x1f, 0xf0, 0x03, 0xff, 0x88, 0xec, 0x44, 0xd9, 0x46, 0xb2, 0xf0, 0xdf, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xb1, 0x84, 0x77, 0xdb, 0x32, 0x19, 0x00, 0x00,
}

func (x HealthStatus) String() string {
	s, ok := HealthStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *ServiceInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceInfoType)
	if !ok {
		that2, ok := that.(ServiceInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DiscoveryType != that1.DiscoveryType {
		return false
	}
	if that1.ServiceInfo == nil {
		if this.ServiceInfo != nil {
			return false
		}
	} else if this.ServiceInfo == nil {
		return false
	} else if !this.ServiceInfo.Equal(that1.ServiceInfo) {
		return false
	}
	return true
}
func (this *ServiceInfoType_ServiceName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceInfoType_ServiceName)
	if !ok {
		that2, ok := that.(ServiceInfoType_ServiceName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServiceName != that1.ServiceName {
		return false
	}
	return true
}
func (this *ServiceInfoType_ServiceSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceInfoType_ServiceSelector)
	if !ok {
		that2, ok := that.(ServiceInfoType_ServiceSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServiceSelector.Equal(that1.ServiceSelector) {
		return false
	}
	return true
}
func (this *DnsNameAdvancedType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DnsNameAdvancedType)
	if !ok {
		that2, ok := that.(DnsNameAdvancedType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.TtlChoice == nil {
		if this.TtlChoice != nil {
			return false
		}
	} else if this.TtlChoice == nil {
		return false
	} else if !this.TtlChoice.Equal(that1.TtlChoice) {
		return false
	}
	return true
}
func (this *DnsNameAdvancedType_StrictTtl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DnsNameAdvancedType_StrictTtl)
	if !ok {
		that2, ok := that.(DnsNameAdvancedType_StrictTtl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StrictTtl.Equal(that1.StrictTtl) {
		return false
	}
	return true
}
func (this *DnsNameAdvancedType_RefreshInterval) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DnsNameAdvancedType_RefreshInterval)
	if !ok {
		that2, ok := that.(DnsNameAdvancedType_RefreshInterval)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RefreshInterval != that1.RefreshInterval {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.HealthCheckPort != that1.HealthCheckPort {
		return false
	}
	if that1.EndpointAddress == nil {
		if this.EndpointAddress != nil {
			return false
		}
	} else if this.EndpointAddress == nil {
		return false
	} else if !this.EndpointAddress.Equal(that1.EndpointAddress) {
		return false
	}
	if that1.ProximityChoice == nil {
		if this.ProximityChoice != nil {
			return false
		}
	} else if this.ProximityChoice == nil {
		return false
	} else if !this.ProximityChoice.Equal(that1.ProximityChoice) {
		return false
	}
	if !this.SnatPool.Equal(that1.SnatPool) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Ip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Ip)
	if !ok {
		that2, ok := that.(GlobalSpecType_Ip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	return true
}
func (this *GlobalSpecType_DnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DnsName)
	if !ok {
		that2, ok := that.(GlobalSpecType_DnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DnsName != that1.DnsName {
		return false
	}
	return true
}
func (this *GlobalSpecType_DnsNameAdvanced) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DnsNameAdvanced)
	if !ok {
		that2, ok := that.(GlobalSpecType_DnsNameAdvanced)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DnsNameAdvanced.Equal(that1.DnsNameAdvanced) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ServerlessServiceName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ServerlessServiceName)
	if !ok {
		that2, ok := that.(GlobalSpecType_ServerlessServiceName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerlessServiceName != that1.ServerlessServiceName {
		return false
	}
	return true
}
func (this *GlobalSpecType_ServiceInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ServiceInfo)
	if !ok {
		that2, ok := that.(GlobalSpecType_ServiceInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServiceInfo.Equal(that1.ServiceInfo) {
		return false
	}
	return true
}
func (this *GlobalSpecType_K8SClusterApiServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_K8SClusterApiServer)
	if !ok {
		that2, ok := that.(GlobalSpecType_K8SClusterApiServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.K8SClusterApiServer.Equal(that1.K8SClusterApiServer) {
		return false
	}
	return true
}
func (this *GlobalSpecType_NoPreference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_NoPreference)
	if !ok {
		that2, ok := that.(GlobalSpecType_NoPreference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoPreference.Equal(that1.NoPreference) {
		return false
	}
	return true
}
func (this *GlobalSpecType_SitePreferences) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_SitePreferences)
	if !ok {
		that2, ok := that.(GlobalSpecType_SitePreferences)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SitePreferences.Equal(that1.SitePreferences) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.HealthCheckPort != that1.HealthCheckPort {
		return false
	}
	if that1.EndpointAddress == nil {
		if this.EndpointAddress != nil {
			return false
		}
	} else if this.EndpointAddress == nil {
		return false
	} else if !this.EndpointAddress.Equal(that1.EndpointAddress) {
		return false
	}
	if !this.SnatPool.Equal(that1.SnatPool) {
		return false
	}
	return true
}
func (this *CreateSpecType_Ip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_Ip)
	if !ok {
		that2, ok := that.(CreateSpecType_Ip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	return true
}
func (this *CreateSpecType_DnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DnsName)
	if !ok {
		that2, ok := that.(CreateSpecType_DnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DnsName != that1.DnsName {
		return false
	}
	return true
}
func (this *CreateSpecType_DnsNameAdvanced) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DnsNameAdvanced)
	if !ok {
		that2, ok := that.(CreateSpecType_DnsNameAdvanced)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DnsNameAdvanced.Equal(that1.DnsNameAdvanced) {
		return false
	}
	return true
}
func (this *CreateSpecType_ServiceInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ServiceInfo)
	if !ok {
		that2, ok := that.(CreateSpecType_ServiceInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServiceInfo.Equal(that1.ServiceInfo) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.HealthCheckPort != that1.HealthCheckPort {
		return false
	}
	if that1.EndpointAddress == nil {
		if this.EndpointAddress != nil {
			return false
		}
	} else if this.EndpointAddress == nil {
		return false
	} else if !this.EndpointAddress.Equal(that1.EndpointAddress) {
		return false
	}
	if !this.SnatPool.Equal(that1.SnatPool) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_Ip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_Ip)
	if !ok {
		that2, ok := that.(ReplaceSpecType_Ip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DnsName)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DnsName != that1.DnsName {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DnsNameAdvanced) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DnsNameAdvanced)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DnsNameAdvanced)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DnsNameAdvanced.Equal(that1.DnsNameAdvanced) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ServiceInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ServiceInfo)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ServiceInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServiceInfo.Equal(that1.ServiceInfo) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.HealthCheckPort != that1.HealthCheckPort {
		return false
	}
	if that1.EndpointAddress == nil {
		if this.EndpointAddress != nil {
			return false
		}
	} else if this.EndpointAddress == nil {
		return false
	} else if !this.EndpointAddress.Equal(that1.EndpointAddress) {
		return false
	}
	if !this.SnatPool.Equal(that1.SnatPool) {
		return false
	}
	return true
}
func (this *GetSpecType_Ip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_Ip)
	if !ok {
		that2, ok := that.(GetSpecType_Ip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	return true
}
func (this *GetSpecType_DnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DnsName)
	if !ok {
		that2, ok := that.(GetSpecType_DnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DnsName != that1.DnsName {
		return false
	}
	return true
}
func (this *GetSpecType_DnsNameAdvanced) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DnsNameAdvanced)
	if !ok {
		that2, ok := that.(GetSpecType_DnsNameAdvanced)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DnsNameAdvanced.Equal(that1.DnsNameAdvanced) {
		return false
	}
	return true
}
func (this *GetSpecType_ServiceInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ServiceInfo)
	if !ok {
		that2, ok := that.(GetSpecType_ServiceInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServiceInfo.Equal(that1.ServiceInfo) {
		return false
	}
	return true
}
func (this *K8SInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SInfo)
	if !ok {
		that2, ok := that.(K8SInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.InClusterDiscovery != that1.InClusterDiscovery {
		return false
	}
	if len(this.PodName) != len(that1.PodName) {
		return false
	}
	for i := range this.PodName {
		if this.PodName[i] != that1.PodName[i] {
			return false
		}
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	return true
}
func (this *DNSInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DNSInfo)
	if !ok {
		that2, ok := that.(DNSInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ResolvedIps) != len(that1.ResolvedIps) {
		return false
	}
	for i := range this.ResolvedIps {
		if this.ResolvedIps[i] != that1.ResolvedIps[i] {
			return false
		}
	}
	return true
}
func (this *ConsulInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulInfo)
	if !ok {
		that2, ok := that.(ConsulInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.InstanceName) != len(that1.InstanceName) {
		return false
	}
	for i := range this.InstanceName {
		if this.InstanceName[i] != that1.InstanceName[i] {
			return false
		}
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	return true
}
func (this *DiscoveredInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DiscoveredInfoType)
	if !ok {
		that2, ok := that.(DiscoveredInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DiscoveredInfo == nil {
		if this.DiscoveredInfo != nil {
			return false
		}
	} else if this.DiscoveredInfo == nil {
		return false
	} else if !this.DiscoveredInfo.Equal(that1.DiscoveredInfo) {
		return false
	}
	return true
}
func (this *DiscoveredInfoType_K8SInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DiscoveredInfoType_K8SInfo)
	if !ok {
		that2, ok := that.(DiscoveredInfoType_K8SInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.K8SInfo.Equal(that1.K8SInfo) {
		return false
	}
	return true
}
func (this *DiscoveredInfoType_ConsulInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DiscoveredInfoType_ConsulInfo)
	if !ok {
		that2, ok := that.(DiscoveredInfoType_ConsulInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConsulInfo.Equal(that1.ConsulInfo) {
		return false
	}
	return true
}
func (this *DiscoveredInfoType_DnsInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DiscoveredInfoType_DnsInfo)
	if !ok {
		that2, ok := that.(DiscoveredInfoType_DnsInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DnsInfo.Equal(that1.DnsInfo) {
		return false
	}
	return true
}
func (this *HealthCheckInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HealthCheckInfoType)
	if !ok {
		that2, ok := that.(HealthCheckInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HealthCheck.Equal(that1.HealthCheck) {
		return false
	}
	if this.HealthStatus != that1.HealthStatus {
		return false
	}
	if this.HealthStatusFailureReason != that1.HealthStatusFailureReason {
		return false
	}
	if this.HealthStatusFailureDetails != that1.HealthStatusFailureDetails {
		return false
	}
	if !this.HealthStatusUpdateTime.Equal(that1.HealthStatusUpdateTime) {
		return false
	}
	if this.LastHealthStatusFailureReason != that1.LastHealthStatusFailureReason {
		return false
	}
	if this.LastHealthStatusFailureDetails != that1.LastHealthStatusFailureDetails {
		return false
	}
	if !this.LastHealthStatusUpdateTime.Equal(that1.LastHealthStatusUpdateTime) {
		return false
	}
	return true
}
func (this *VerStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VerStatusType)
	if !ok {
		that2, ok := that.(VerStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServiceName != that1.ServiceName {
		return false
	}
	if !this.DiscoveredIp.Equal(that1.DiscoveredIp) {
		return false
	}
	if this.DiscoveredPort != that1.DiscoveredPort {
		return false
	}
	if !this.AllocatedIp.Equal(that1.AllocatedIp) {
		return false
	}
	if this.Site != that1.Site {
		return false
	}
	if len(this.HealthStatus) != len(that1.HealthStatus) {
		return false
	}
	for i := range this.HealthStatus {
		if this.HealthStatus[i] != that1.HealthStatus[i] {
			return false
		}
	}
	if !this.DiscoveredInfo.Equal(that1.DiscoveredInfo) {
		return false
	}
	if len(this.HealthCheckDetails) != len(that1.HealthCheckDetails) {
		return false
	}
	for i := range this.HealthCheckDetails {
		if !this.HealthCheckDetails[i].Equal(that1.HealthCheckDetails[i]) {
			return false
		}
	}
	return true
}
func (this *ServiceInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&endpoint.ServiceInfoType{")
	s = append(s, "DiscoveryType: "+fmt.Sprintf("%#v", this.DiscoveryType)+",\n")
	if this.ServiceInfo != nil {
		s = append(s, "ServiceInfo: "+fmt.Sprintf("%#v", this.ServiceInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServiceInfoType_ServiceName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.ServiceInfoType_ServiceName{` +
		`ServiceName:` + fmt.Sprintf("%#v", this.ServiceName) + `}`}, ", ")
	return s
}
func (this *ServiceInfoType_ServiceSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.ServiceInfoType_ServiceSelector{` +
		`ServiceSelector:` + fmt.Sprintf("%#v", this.ServiceSelector) + `}`}, ", ")
	return s
}
func (this *DnsNameAdvancedType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&endpoint.DnsNameAdvancedType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.TtlChoice != nil {
		s = append(s, "TtlChoice: "+fmt.Sprintf("%#v", this.TtlChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DnsNameAdvancedType_StrictTtl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.DnsNameAdvancedType_StrictTtl{` +
		`StrictTtl:` + fmt.Sprintf("%#v", this.StrictTtl) + `}`}, ", ")
	return s
}
func (this *DnsNameAdvancedType_RefreshInterval) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.DnsNameAdvancedType_RefreshInterval{` +
		`RefreshInterval:` + fmt.Sprintf("%#v", this.RefreshInterval) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&endpoint.GlobalSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "HealthCheckPort: "+fmt.Sprintf("%#v", this.HealthCheckPort)+",\n")
	if this.EndpointAddress != nil {
		s = append(s, "EndpointAddress: "+fmt.Sprintf("%#v", this.EndpointAddress)+",\n")
	}
	if this.ProximityChoice != nil {
		s = append(s, "ProximityChoice: "+fmt.Sprintf("%#v", this.ProximityChoice)+",\n")
	}
	if this.SnatPool != nil {
		s = append(s, "SnatPool: "+fmt.Sprintf("%#v", this.SnatPool)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_Ip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GlobalSpecType_Ip{` +
		`Ip:` + fmt.Sprintf("%#v", this.Ip) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GlobalSpecType_DnsName{` +
		`DnsName:` + fmt.Sprintf("%#v", this.DnsName) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DnsNameAdvanced) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GlobalSpecType_DnsNameAdvanced{` +
		`DnsNameAdvanced:` + fmt.Sprintf("%#v", this.DnsNameAdvanced) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ServerlessServiceName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GlobalSpecType_ServerlessServiceName{` +
		`ServerlessServiceName:` + fmt.Sprintf("%#v", this.ServerlessServiceName) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ServiceInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GlobalSpecType_ServiceInfo{` +
		`ServiceInfo:` + fmt.Sprintf("%#v", this.ServiceInfo) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_K8SClusterApiServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GlobalSpecType_K8SClusterApiServer{` +
		`K8SClusterApiServer:` + fmt.Sprintf("%#v", this.K8SClusterApiServer) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_NoPreference) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GlobalSpecType_NoPreference{` +
		`NoPreference:` + fmt.Sprintf("%#v", this.NoPreference) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_SitePreferences) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GlobalSpecType_SitePreferences{` +
		`SitePreferences:` + fmt.Sprintf("%#v", this.SitePreferences) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&endpoint.CreateSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "HealthCheckPort: "+fmt.Sprintf("%#v", this.HealthCheckPort)+",\n")
	if this.EndpointAddress != nil {
		s = append(s, "EndpointAddress: "+fmt.Sprintf("%#v", this.EndpointAddress)+",\n")
	}
	if this.SnatPool != nil {
		s = append(s, "SnatPool: "+fmt.Sprintf("%#v", this.SnatPool)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_Ip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.CreateSpecType_Ip{` +
		`Ip:` + fmt.Sprintf("%#v", this.Ip) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.CreateSpecType_DnsName{` +
		`DnsName:` + fmt.Sprintf("%#v", this.DnsName) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DnsNameAdvanced) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.CreateSpecType_DnsNameAdvanced{` +
		`DnsNameAdvanced:` + fmt.Sprintf("%#v", this.DnsNameAdvanced) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ServiceInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.CreateSpecType_ServiceInfo{` +
		`ServiceInfo:` + fmt.Sprintf("%#v", this.ServiceInfo) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&endpoint.ReplaceSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "HealthCheckPort: "+fmt.Sprintf("%#v", this.HealthCheckPort)+",\n")
	if this.EndpointAddress != nil {
		s = append(s, "EndpointAddress: "+fmt.Sprintf("%#v", this.EndpointAddress)+",\n")
	}
	if this.SnatPool != nil {
		s = append(s, "SnatPool: "+fmt.Sprintf("%#v", this.SnatPool)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_Ip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.ReplaceSpecType_Ip{` +
		`Ip:` + fmt.Sprintf("%#v", this.Ip) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.ReplaceSpecType_DnsName{` +
		`DnsName:` + fmt.Sprintf("%#v", this.DnsName) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DnsNameAdvanced) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.ReplaceSpecType_DnsNameAdvanced{` +
		`DnsNameAdvanced:` + fmt.Sprintf("%#v", this.DnsNameAdvanced) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ServiceInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.ReplaceSpecType_ServiceInfo{` +
		`ServiceInfo:` + fmt.Sprintf("%#v", this.ServiceInfo) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&endpoint.GetSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "HealthCheckPort: "+fmt.Sprintf("%#v", this.HealthCheckPort)+",\n")
	if this.EndpointAddress != nil {
		s = append(s, "EndpointAddress: "+fmt.Sprintf("%#v", this.EndpointAddress)+",\n")
	}
	if this.SnatPool != nil {
		s = append(s, "SnatPool: "+fmt.Sprintf("%#v", this.SnatPool)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_Ip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GetSpecType_Ip{` +
		`Ip:` + fmt.Sprintf("%#v", this.Ip) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GetSpecType_DnsName{` +
		`DnsName:` + fmt.Sprintf("%#v", this.DnsName) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DnsNameAdvanced) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GetSpecType_DnsNameAdvanced{` +
		`DnsNameAdvanced:` + fmt.Sprintf("%#v", this.DnsNameAdvanced) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ServiceInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GetSpecType_ServiceInfo{` +
		`ServiceInfo:` + fmt.Sprintf("%#v", this.ServiceInfo) + `}`}, ", ")
	return s
}
func (this *K8SInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&endpoint.K8SInfo{")
	s = append(s, "InClusterDiscovery: "+fmt.Sprintf("%#v", this.InClusterDiscovery)+",\n")
	s = append(s, "PodName: "+fmt.Sprintf("%#v", this.PodName)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DNSInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&endpoint.DNSInfo{")
	s = append(s, "ResolvedIps: "+fmt.Sprintf("%#v", this.ResolvedIps)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConsulInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&endpoint.ConsulInfo{")
	s = append(s, "InstanceName: "+fmt.Sprintf("%#v", this.InstanceName)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DiscoveredInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&endpoint.DiscoveredInfoType{")
	if this.DiscoveredInfo != nil {
		s = append(s, "DiscoveredInfo: "+fmt.Sprintf("%#v", this.DiscoveredInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DiscoveredInfoType_K8SInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.DiscoveredInfoType_K8SInfo{` +
		`K8SInfo:` + fmt.Sprintf("%#v", this.K8SInfo) + `}`}, ", ")
	return s
}
func (this *DiscoveredInfoType_ConsulInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.DiscoveredInfoType_ConsulInfo{` +
		`ConsulInfo:` + fmt.Sprintf("%#v", this.ConsulInfo) + `}`}, ", ")
	return s
}
func (this *DiscoveredInfoType_DnsInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.DiscoveredInfoType_DnsInfo{` +
		`DnsInfo:` + fmt.Sprintf("%#v", this.DnsInfo) + `}`}, ", ")
	return s
}
func (this *HealthCheckInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&endpoint.HealthCheckInfoType{")
	if this.HealthCheck != nil {
		s = append(s, "HealthCheck: "+fmt.Sprintf("%#v", this.HealthCheck)+",\n")
	}
	s = append(s, "HealthStatus: "+fmt.Sprintf("%#v", this.HealthStatus)+",\n")
	s = append(s, "HealthStatusFailureReason: "+fmt.Sprintf("%#v", this.HealthStatusFailureReason)+",\n")
	s = append(s, "HealthStatusFailureDetails: "+fmt.Sprintf("%#v", this.HealthStatusFailureDetails)+",\n")
	if this.HealthStatusUpdateTime != nil {
		s = append(s, "HealthStatusUpdateTime: "+fmt.Sprintf("%#v", this.HealthStatusUpdateTime)+",\n")
	}
	s = append(s, "LastHealthStatusFailureReason: "+fmt.Sprintf("%#v", this.LastHealthStatusFailureReason)+",\n")
	s = append(s, "LastHealthStatusFailureDetails: "+fmt.Sprintf("%#v", this.LastHealthStatusFailureDetails)+",\n")
	if this.LastHealthStatusUpdateTime != nil {
		s = append(s, "LastHealthStatusUpdateTime: "+fmt.Sprintf("%#v", this.LastHealthStatusUpdateTime)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VerStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&endpoint.VerStatusType{")
	s = append(s, "ServiceName: "+fmt.Sprintf("%#v", this.ServiceName)+",\n")
	if this.DiscoveredIp != nil {
		s = append(s, "DiscoveredIp: "+fmt.Sprintf("%#v", this.DiscoveredIp)+",\n")
	}
	s = append(s, "DiscoveredPort: "+fmt.Sprintf("%#v", this.DiscoveredPort)+",\n")
	if this.AllocatedIp != nil {
		s = append(s, "AllocatedIp: "+fmt.Sprintf("%#v", this.AllocatedIp)+",\n")
	}
	s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	keysForHealthStatus := make([]string, 0, len(this.HealthStatus))
	for k, _ := range this.HealthStatus {
		keysForHealthStatus = append(keysForHealthStatus, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHealthStatus)
	mapStringForHealthStatus := "map[string]HealthStatus{"
	for _, k := range keysForHealthStatus {
		mapStringForHealthStatus += fmt.Sprintf("%#v: %#v,", k, this.HealthStatus[k])
	}
	mapStringForHealthStatus += "}"
	if this.HealthStatus != nil {
		s = append(s, "HealthStatus: "+mapStringForHealthStatus+",\n")
	}
	if this.DiscoveredInfo != nil {
		s = append(s, "DiscoveredInfo: "+fmt.Sprintf("%#v", this.DiscoveredInfo)+",\n")
	}
	if this.HealthCheckDetails != nil {
		s = append(s, "HealthCheckDetails: "+fmt.Sprintf("%#v", this.HealthCheckDetails)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *ServiceInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ServiceInfo != nil {
		{
			size := m.ServiceInfo.Size()
			i -= size
			if _, err := m.ServiceInfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DiscoveryType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DiscoveryType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServiceInfoType_ServiceName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceInfoType_ServiceName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServiceName)
	copy(dAtA[i:], m.ServiceName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServiceName)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *ServiceInfoType_ServiceSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceInfoType_ServiceSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServiceSelector != nil {
		{
			size, err := m.ServiceSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DnsNameAdvancedType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DnsNameAdvancedType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DnsNameAdvancedType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TtlChoice != nil {
		{
			size := m.TtlChoice.Size()
			i -= size
			if _, err := m.TtlChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DnsNameAdvancedType_StrictTtl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DnsNameAdvancedType_StrictTtl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StrictTtl != nil {
		{
			size, err := m.StrictTtl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DnsNameAdvancedType_RefreshInterval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DnsNameAdvancedType_RefreshInterval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.RefreshInterval))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SnatPool != nil {
		{
			size, err := m.SnatPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.ProximityChoice != nil {
		{
			size := m.ProximityChoice.Size()
			i -= size
			if _, err := m.ProximityChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.EndpointAddress != nil {
		{
			size := m.EndpointAddress.Size()
			i -= size
			if _, err := m.EndpointAddress.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.HealthCheckPort != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.HealthCheckPort))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Port != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if m.Where != nil {
		{
			size, err := m.Where.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_Ip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Ip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Ip)
	copy(dAtA[i:], m.Ip)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Ip)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DnsName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DnsName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DnsName)
	copy(dAtA[i:], m.DnsName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DnsName)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_ServerlessServiceName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ServerlessServiceName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServerlessServiceName)
	copy(dAtA[i:], m.ServerlessServiceName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerlessServiceName)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_ServiceInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ServiceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServiceInfo != nil {
		{
			size, err := m.ServiceInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DnsNameAdvanced) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DnsNameAdvanced) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DnsNameAdvanced != nil {
		{
			size, err := m.DnsNameAdvanced.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_K8SClusterApiServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_K8SClusterApiServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.K8SClusterApiServer != nil {
		{
			size, err := m.K8SClusterApiServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_NoPreference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_NoPreference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoPreference != nil {
		{
			size, err := m.NoPreference.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_SitePreferences) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_SitePreferences) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SitePreferences != nil {
		{
			size, err := m.SitePreferences.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SnatPool != nil {
		{
			size, err := m.SnatPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.HealthCheckPort != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.HealthCheckPort))
		i--
		dAtA[i] = 0x60
	}
	if m.EndpointAddress != nil {
		{
			size := m.EndpointAddress.Size()
			i -= size
			if _, err := m.EndpointAddress.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Port != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if m.Where != nil {
		{
			size, err := m.Where.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_Ip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_Ip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Ip)
	copy(dAtA[i:], m.Ip)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Ip)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DnsName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DnsName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DnsName)
	copy(dAtA[i:], m.DnsName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DnsName)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_ServiceInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ServiceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServiceInfo != nil {
		{
			size, err := m.ServiceInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DnsNameAdvanced) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DnsNameAdvanced) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DnsNameAdvanced != nil {
		{
			size, err := m.DnsNameAdvanced.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SnatPool != nil {
		{
			size, err := m.SnatPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.HealthCheckPort != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.HealthCheckPort))
		i--
		dAtA[i] = 0x60
	}
	if m.EndpointAddress != nil {
		{
			size := m.EndpointAddress.Size()
			i -= size
			if _, err := m.EndpointAddress.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Port != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if m.Where != nil {
		{
			size, err := m.Where.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_Ip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_Ip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Ip)
	copy(dAtA[i:], m.Ip)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Ip)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DnsName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DnsName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DnsName)
	copy(dAtA[i:], m.DnsName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DnsName)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_ServiceInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ServiceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServiceInfo != nil {
		{
			size, err := m.ServiceInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DnsNameAdvanced) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DnsNameAdvanced) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DnsNameAdvanced != nil {
		{
			size, err := m.DnsNameAdvanced.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SnatPool != nil {
		{
			size, err := m.SnatPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.HealthCheckPort != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.HealthCheckPort))
		i--
		dAtA[i] = 0x60
	}
	if m.EndpointAddress != nil {
		{
			size := m.EndpointAddress.Size()
			i -= size
			if _, err := m.EndpointAddress.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Port != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if m.Where != nil {
		{
			size, err := m.Where.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_Ip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_Ip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Ip)
	copy(dAtA[i:], m.Ip)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Ip)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DnsName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DnsName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DnsName)
	copy(dAtA[i:], m.DnsName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DnsName)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *GetSpecType_ServiceInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ServiceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServiceInfo != nil {
		{
			size, err := m.ServiceInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DnsNameAdvanced) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DnsNameAdvanced) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DnsNameAdvanced != nil {
		{
			size, err := m.DnsNameAdvanced.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *K8SInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PodName) > 0 {
		for iNdEx := len(m.PodName) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PodName[iNdEx])
			copy(dAtA[i:], m.PodName[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.PodName[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.InClusterDiscovery {
		i--
		if m.InClusterDiscovery {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DNSInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNSInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DNSInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResolvedIps) > 0 {
		for iNdEx := len(m.ResolvedIps) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResolvedIps[iNdEx])
			copy(dAtA[i:], m.ResolvedIps[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ResolvedIps[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConsulInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsulInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsulInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.InstanceName) > 0 {
		for iNdEx := len(m.InstanceName) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InstanceName[iNdEx])
			copy(dAtA[i:], m.InstanceName[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.InstanceName[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DiscoveredInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscoveredInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiscoveredInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DiscoveredInfo != nil {
		{
			size := m.DiscoveredInfo.Size()
			i -= size
			if _, err := m.DiscoveredInfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DiscoveredInfoType_K8SInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiscoveredInfoType_K8SInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.K8SInfo != nil {
		{
			size, err := m.K8SInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DiscoveredInfoType_ConsulInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiscoveredInfoType_ConsulInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConsulInfo != nil {
		{
			size, err := m.ConsulInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DiscoveredInfoType_DnsInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiscoveredInfoType_DnsInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DnsInfo != nil {
		{
			size, err := m.DnsInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *HealthCheckInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheckInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthCheckInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastHealthStatusUpdateTime != nil {
		{
			size, err := m.LastHealthStatusUpdateTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.LastHealthStatusFailureDetails) > 0 {
		i -= len(m.LastHealthStatusFailureDetails)
		copy(dAtA[i:], m.LastHealthStatusFailureDetails)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LastHealthStatusFailureDetails)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.LastHealthStatusFailureReason) > 0 {
		i -= len(m.LastHealthStatusFailureReason)
		copy(dAtA[i:], m.LastHealthStatusFailureReason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LastHealthStatusFailureReason)))
		i--
		dAtA[i] = 0x32
	}
	if m.HealthStatusUpdateTime != nil {
		{
			size, err := m.HealthStatusUpdateTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.HealthStatusFailureDetails) > 0 {
		i -= len(m.HealthStatusFailureDetails)
		copy(dAtA[i:], m.HealthStatusFailureDetails)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HealthStatusFailureDetails)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.HealthStatusFailureReason) > 0 {
		i -= len(m.HealthStatusFailureReason)
		copy(dAtA[i:], m.HealthStatusFailureReason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HealthStatusFailureReason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.HealthStatus) > 0 {
		i -= len(m.HealthStatus)
		copy(dAtA[i:], m.HealthStatus)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HealthStatus)))
		i--
		dAtA[i] = 0x12
	}
	if m.HealthCheck != nil {
		{
			size, err := m.HealthCheck.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HealthCheckDetails) > 0 {
		for iNdEx := len(m.HealthCheckDetails) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HealthCheckDetails[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.DiscoveredInfo != nil {
		{
			size, err := m.DiscoveredInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.HealthStatus) > 0 {
		keysForHealthStatus := make([]string, 0, len(m.HealthStatus))
		for k := range m.HealthStatus {
			keysForHealthStatus = append(keysForHealthStatus, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForHealthStatus)
		for iNdEx := len(keysForHealthStatus) - 1; iNdEx >= 0; iNdEx-- {
			v := m.HealthStatus[string(keysForHealthStatus[iNdEx])]
			baseI := i
			i = encodeVarintTypes(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(keysForHealthStatus[iNdEx])
			copy(dAtA[i:], keysForHealthStatus[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForHealthStatus[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Site) > 0 {
		i -= len(m.Site)
		copy(dAtA[i:], m.Site)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Site)))
		i--
		dAtA[i] = 0x2a
	}
	if m.AllocatedIp != nil {
		{
			size, err := m.AllocatedIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DiscoveredPort != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DiscoveredPort))
		i--
		dAtA[i] = 0x18
	}
	if m.DiscoveredIp != nil {
		{
			size, err := m.DiscoveredIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServiceName) > 0 {
		i -= len(m.ServiceName)
		copy(dAtA[i:], m.ServiceName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServiceName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ServiceInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryType != 0 {
		n += 1 + sovTypes(uint64(m.DiscoveryType))
	}
	if m.ServiceInfo != nil {
		n += m.ServiceInfo.Size()
	}
	return n
}

func (m *ServiceInfoType_ServiceName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServiceName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ServiceInfoType_ServiceSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServiceSelector != nil {
		l = m.ServiceSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DnsNameAdvancedType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TtlChoice != nil {
		n += m.TtlChoice.Size()
	}
	return n
}

func (m *DnsNameAdvancedType_StrictTtl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StrictTtl != nil {
		l = m.StrictTtl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DnsNameAdvancedType_RefreshInterval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.RefreshInterval))
	return n
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovTypes(uint64(m.Port))
	}
	if m.EndpointAddress != nil {
		n += m.EndpointAddress.Size()
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HealthCheckPort != 0 {
		n += 1 + sovTypes(uint64(m.HealthCheckPort))
	}
	if m.ProximityChoice != nil {
		n += m.ProximityChoice.Size()
	}
	if m.SnatPool != nil {
		l = m.SnatPool.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType_Ip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ip)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GlobalSpecType_DnsName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GlobalSpecType_ServerlessServiceName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerlessServiceName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GlobalSpecType_ServiceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServiceInfo != nil {
		l = m.ServiceInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DnsNameAdvanced) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DnsNameAdvanced != nil {
		l = m.DnsNameAdvanced.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_K8SClusterApiServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.K8SClusterApiServer != nil {
		l = m.K8SClusterApiServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_NoPreference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoPreference != nil {
		l = m.NoPreference.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_SitePreferences) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SitePreferences != nil {
		l = m.SitePreferences.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovTypes(uint64(m.Port))
	}
	if m.EndpointAddress != nil {
		n += m.EndpointAddress.Size()
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HealthCheckPort != 0 {
		n += 1 + sovTypes(uint64(m.HealthCheckPort))
	}
	if m.SnatPool != nil {
		l = m.SnatPool.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType_Ip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ip)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CreateSpecType_DnsName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CreateSpecType_ServiceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServiceInfo != nil {
		l = m.ServiceInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DnsNameAdvanced) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DnsNameAdvanced != nil {
		l = m.DnsNameAdvanced.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovTypes(uint64(m.Port))
	}
	if m.EndpointAddress != nil {
		n += m.EndpointAddress.Size()
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HealthCheckPort != 0 {
		n += 1 + sovTypes(uint64(m.HealthCheckPort))
	}
	if m.SnatPool != nil {
		l = m.SnatPool.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType_Ip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ip)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ReplaceSpecType_DnsName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ReplaceSpecType_ServiceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServiceInfo != nil {
		l = m.ServiceInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DnsNameAdvanced) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DnsNameAdvanced != nil {
		l = m.DnsNameAdvanced.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovTypes(uint64(m.Port))
	}
	if m.EndpointAddress != nil {
		n += m.EndpointAddress.Size()
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HealthCheckPort != 0 {
		n += 1 + sovTypes(uint64(m.HealthCheckPort))
	}
	if m.SnatPool != nil {
		l = m.SnatPool.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType_Ip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ip)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GetSpecType_DnsName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GetSpecType_ServiceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServiceInfo != nil {
		l = m.ServiceInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DnsNameAdvanced) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DnsNameAdvanced != nil {
		l = m.DnsNameAdvanced.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InClusterDiscovery {
		n += 2
	}
	if len(m.PodName) > 0 {
		for _, s := range m.PodName {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DNSInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResolvedIps) > 0 {
		for _, s := range m.ResolvedIps {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ConsulInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InstanceName) > 0 {
		for _, s := range m.InstanceName {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DiscoveredInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveredInfo != nil {
		n += m.DiscoveredInfo.Size()
	}
	return n
}

func (m *DiscoveredInfoType_K8SInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.K8SInfo != nil {
		l = m.K8SInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DiscoveredInfoType_ConsulInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConsulInfo != nil {
		l = m.ConsulInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DiscoveredInfoType_DnsInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DnsInfo != nil {
		l = m.DnsInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HealthCheckInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HealthCheck != nil {
		l = m.HealthCheck.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.HealthStatus)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.HealthStatusFailureReason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.HealthStatusFailureDetails)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HealthStatusUpdateTime != nil {
		l = m.HealthStatusUpdateTime.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.LastHealthStatusFailureReason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.LastHealthStatusFailureDetails)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LastHealthStatusUpdateTime != nil {
		l = m.LastHealthStatusUpdateTime.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *VerStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DiscoveredIp != nil {
		l = m.DiscoveredIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DiscoveredPort != 0 {
		n += 1 + sovTypes(uint64(m.DiscoveredPort))
	}
	if m.AllocatedIp != nil {
		l = m.AllocatedIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Site)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.HealthStatus) > 0 {
		for k, v := range m.HealthStatus {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + sovTypes(uint64(v))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.DiscoveredInfo != nil {
		l = m.DiscoveredInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.HealthCheckDetails) > 0 {
		for _, e := range m.HealthCheckDetails {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ServiceInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceInfoType{`,
		`DiscoveryType:` + fmt.Sprintf("%v", this.DiscoveryType) + `,`,
		`ServiceInfo:` + fmt.Sprintf("%v", this.ServiceInfo) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceInfoType_ServiceName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceInfoType_ServiceName{`,
		`ServiceName:` + fmt.Sprintf("%v", this.ServiceName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceInfoType_ServiceSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceInfoType_ServiceSelector{`,
		`ServiceSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServiceSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DnsNameAdvancedType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DnsNameAdvancedType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`TtlChoice:` + fmt.Sprintf("%v", this.TtlChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DnsNameAdvancedType_StrictTtl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DnsNameAdvancedType_StrictTtl{`,
		`StrictTtl:` + strings.Replace(fmt.Sprintf("%v", this.StrictTtl), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DnsNameAdvancedType_RefreshInterval) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DnsNameAdvancedType_RefreshInterval{`,
		`RefreshInterval:` + fmt.Sprintf("%v", this.RefreshInterval) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "schema.NetworkSiteRefSelector", 1) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`EndpointAddress:` + fmt.Sprintf("%v", this.EndpointAddress) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`HealthCheckPort:` + fmt.Sprintf("%v", this.HealthCheckPort) + `,`,
		`ProximityChoice:` + fmt.Sprintf("%v", this.ProximityChoice) + `,`,
		`SnatPool:` + strings.Replace(fmt.Sprintf("%v", this.SnatPool), "SnatPoolConfiguration", "views.SnatPoolConfiguration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Ip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Ip{`,
		`Ip:` + fmt.Sprintf("%v", this.Ip) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DnsName{`,
		`DnsName:` + fmt.Sprintf("%v", this.DnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ServerlessServiceName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ServerlessServiceName{`,
		`ServerlessServiceName:` + fmt.Sprintf("%v", this.ServerlessServiceName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ServiceInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ServiceInfo{`,
		`ServiceInfo:` + strings.Replace(fmt.Sprintf("%v", this.ServiceInfo), "ServiceInfoType", "ServiceInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DnsNameAdvanced) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DnsNameAdvanced{`,
		`DnsNameAdvanced:` + strings.Replace(fmt.Sprintf("%v", this.DnsNameAdvanced), "DnsNameAdvancedType", "DnsNameAdvancedType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_K8SClusterApiServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_K8SClusterApiServer{`,
		`K8SClusterApiServer:` + strings.Replace(fmt.Sprintf("%v", this.K8SClusterApiServer), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_NoPreference) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_NoPreference{`,
		`NoPreference:` + strings.Replace(fmt.Sprintf("%v", this.NoPreference), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_SitePreferences) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_SitePreferences{`,
		`SitePreferences:` + strings.Replace(fmt.Sprintf("%v", this.SitePreferences), "SiteReferenceListType", "schema.SiteReferenceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "schema.NetworkSiteRefSelector", 1) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`EndpointAddress:` + fmt.Sprintf("%v", this.EndpointAddress) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`HealthCheckPort:` + fmt.Sprintf("%v", this.HealthCheckPort) + `,`,
		`SnatPool:` + strings.Replace(fmt.Sprintf("%v", this.SnatPool), "SnatPoolConfiguration", "views.SnatPoolConfiguration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_Ip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_Ip{`,
		`Ip:` + fmt.Sprintf("%v", this.Ip) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DnsName{`,
		`DnsName:` + fmt.Sprintf("%v", this.DnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ServiceInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ServiceInfo{`,
		`ServiceInfo:` + strings.Replace(fmt.Sprintf("%v", this.ServiceInfo), "ServiceInfoType", "ServiceInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DnsNameAdvanced) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DnsNameAdvanced{`,
		`DnsNameAdvanced:` + strings.Replace(fmt.Sprintf("%v", this.DnsNameAdvanced), "DnsNameAdvancedType", "DnsNameAdvancedType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "schema.NetworkSiteRefSelector", 1) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`EndpointAddress:` + fmt.Sprintf("%v", this.EndpointAddress) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`HealthCheckPort:` + fmt.Sprintf("%v", this.HealthCheckPort) + `,`,
		`SnatPool:` + strings.Replace(fmt.Sprintf("%v", this.SnatPool), "SnatPoolConfiguration", "views.SnatPoolConfiguration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_Ip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_Ip{`,
		`Ip:` + fmt.Sprintf("%v", this.Ip) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DnsName{`,
		`DnsName:` + fmt.Sprintf("%v", this.DnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ServiceInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ServiceInfo{`,
		`ServiceInfo:` + strings.Replace(fmt.Sprintf("%v", this.ServiceInfo), "ServiceInfoType", "ServiceInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DnsNameAdvanced) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DnsNameAdvanced{`,
		`DnsNameAdvanced:` + strings.Replace(fmt.Sprintf("%v", this.DnsNameAdvanced), "DnsNameAdvancedType", "DnsNameAdvancedType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "schema.NetworkSiteRefSelector", 1) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`EndpointAddress:` + fmt.Sprintf("%v", this.EndpointAddress) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`HealthCheckPort:` + fmt.Sprintf("%v", this.HealthCheckPort) + `,`,
		`SnatPool:` + strings.Replace(fmt.Sprintf("%v", this.SnatPool), "SnatPoolConfiguration", "views.SnatPoolConfiguration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_Ip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_Ip{`,
		`Ip:` + fmt.Sprintf("%v", this.Ip) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DnsName{`,
		`DnsName:` + fmt.Sprintf("%v", this.DnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ServiceInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ServiceInfo{`,
		`ServiceInfo:` + strings.Replace(fmt.Sprintf("%v", this.ServiceInfo), "ServiceInfoType", "ServiceInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DnsNameAdvanced) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DnsNameAdvanced{`,
		`DnsNameAdvanced:` + strings.Replace(fmt.Sprintf("%v", this.DnsNameAdvanced), "DnsNameAdvancedType", "DnsNameAdvancedType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SInfo) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&K8SInfo{`,
		`InClusterDiscovery:` + fmt.Sprintf("%v", this.InClusterDiscovery) + `,`,
		`PodName:` + fmt.Sprintf("%v", this.PodName) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *DNSInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DNSInfo{`,
		`ResolvedIps:` + fmt.Sprintf("%v", this.ResolvedIps) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulInfo) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&ConsulInfo{`,
		`InstanceName:` + fmt.Sprintf("%v", this.InstanceName) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiscoveredInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DiscoveredInfoType{`,
		`DiscoveredInfo:` + fmt.Sprintf("%v", this.DiscoveredInfo) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiscoveredInfoType_K8SInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DiscoveredInfoType_K8SInfo{`,
		`K8SInfo:` + strings.Replace(fmt.Sprintf("%v", this.K8SInfo), "K8SInfo", "K8SInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiscoveredInfoType_ConsulInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DiscoveredInfoType_ConsulInfo{`,
		`ConsulInfo:` + strings.Replace(fmt.Sprintf("%v", this.ConsulInfo), "ConsulInfo", "ConsulInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiscoveredInfoType_DnsInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DiscoveredInfoType_DnsInfo{`,
		`DnsInfo:` + strings.Replace(fmt.Sprintf("%v", this.DnsInfo), "DNSInfo", "DNSInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HealthCheckInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HealthCheckInfoType{`,
		`HealthCheck:` + strings.Replace(fmt.Sprintf("%v", this.HealthCheck), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`HealthStatus:` + fmt.Sprintf("%v", this.HealthStatus) + `,`,
		`HealthStatusFailureReason:` + fmt.Sprintf("%v", this.HealthStatusFailureReason) + `,`,
		`HealthStatusFailureDetails:` + fmt.Sprintf("%v", this.HealthStatusFailureDetails) + `,`,
		`HealthStatusUpdateTime:` + strings.Replace(fmt.Sprintf("%v", this.HealthStatusUpdateTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`LastHealthStatusFailureReason:` + fmt.Sprintf("%v", this.LastHealthStatusFailureReason) + `,`,
		`LastHealthStatusFailureDetails:` + fmt.Sprintf("%v", this.LastHealthStatusFailureDetails) + `,`,
		`LastHealthStatusUpdateTime:` + strings.Replace(fmt.Sprintf("%v", this.LastHealthStatusUpdateTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VerStatusType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHealthCheckDetails := "[]*HealthCheckInfoType{"
	for _, f := range this.HealthCheckDetails {
		repeatedStringForHealthCheckDetails += strings.Replace(f.String(), "HealthCheckInfoType", "HealthCheckInfoType", 1) + ","
	}
	repeatedStringForHealthCheckDetails += "}"
	keysForHealthStatus := make([]string, 0, len(this.HealthStatus))
	for k, _ := range this.HealthStatus {
		keysForHealthStatus = append(keysForHealthStatus, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHealthStatus)
	mapStringForHealthStatus := "map[string]HealthStatus{"
	for _, k := range keysForHealthStatus {
		mapStringForHealthStatus += fmt.Sprintf("%v: %v,", k, this.HealthStatus[k])
	}
	mapStringForHealthStatus += "}"
	s := strings.Join([]string{`&VerStatusType{`,
		`ServiceName:` + fmt.Sprintf("%v", this.ServiceName) + `,`,
		`DiscoveredIp:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveredIp), "IpAddressType", "schema.IpAddressType", 1) + `,`,
		`DiscoveredPort:` + fmt.Sprintf("%v", this.DiscoveredPort) + `,`,
		`AllocatedIp:` + strings.Replace(fmt.Sprintf("%v", this.AllocatedIp), "Ipv6AddressType", "schema.Ipv6AddressType", 1) + `,`,
		`Site:` + fmt.Sprintf("%v", this.Site) + `,`,
		`HealthStatus:` + mapStringForHealthStatus + `,`,
		`DiscoveredInfo:` + strings.Replace(this.DiscoveredInfo.String(), "DiscoveredInfoType", "DiscoveredInfoType", 1) + `,`,
		`HealthCheckDetails:` + repeatedStringForHealthCheckDetails + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ServiceInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryType", wireType)
			}
			m.DiscoveryType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscoveryType |= schema.DiscoveryType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceInfo = &ServiceInfoType_ServiceName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServiceInfo = &ServiceInfoType_ServiceSelector{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DnsNameAdvancedType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DnsNameAdvancedType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DnsNameAdvancedType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrictTtl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TtlChoice = &DnsNameAdvancedType_StrictTtl{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshInterval", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TtlChoice = &DnsNameAdvancedType_RefreshInterval{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &schema.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAddress = &GlobalSpecType_Ip{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAddress = &GlobalSpecType_DnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerlessServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAddress = &GlobalSpecType_ServerlessServiceName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointAddress = &GlobalSpecType_ServiceInfo{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsNameAdvanced", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DnsNameAdvancedType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointAddress = &GlobalSpecType_DnsNameAdvanced{v}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheckPort", wireType)
			}
			m.HealthCheckPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HealthCheckPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SClusterApiServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointAddress = &GlobalSpecType_K8SClusterApiServer{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoPreference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ProximityChoice = &GlobalSpecType_NoPreference{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SitePreferences", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.SiteReferenceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ProximityChoice = &GlobalSpecType_SitePreferences{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnatPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnatPool == nil {
				m.SnatPool = &views.SnatPoolConfiguration{}
			}
			if err := m.SnatPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &schema.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAddress = &CreateSpecType_Ip{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAddress = &CreateSpecType_DnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointAddress = &CreateSpecType_ServiceInfo{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsNameAdvanced", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DnsNameAdvancedType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointAddress = &CreateSpecType_DnsNameAdvanced{v}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheckPort", wireType)
			}
			m.HealthCheckPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HealthCheckPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnatPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnatPool == nil {
				m.SnatPool = &views.SnatPoolConfiguration{}
			}
			if err := m.SnatPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &schema.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAddress = &ReplaceSpecType_Ip{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAddress = &ReplaceSpecType_DnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointAddress = &ReplaceSpecType_ServiceInfo{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsNameAdvanced", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DnsNameAdvancedType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointAddress = &ReplaceSpecType_DnsNameAdvanced{v}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheckPort", wireType)
			}
			m.HealthCheckPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HealthCheckPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnatPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnatPool == nil {
				m.SnatPool = &views.SnatPoolConfiguration{}
			}
			if err := m.SnatPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &schema.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAddress = &GetSpecType_Ip{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAddress = &GetSpecType_DnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointAddress = &GetSpecType_ServiceInfo{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsNameAdvanced", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DnsNameAdvancedType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointAddress = &GetSpecType_DnsNameAdvanced{v}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheckPort", wireType)
			}
			m.HealthCheckPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HealthCheckPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnatPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnatPool == nil {
				m.SnatPool = &views.SnatPoolConfiguration{}
			}
			if err := m.SnatPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InClusterDiscovery", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InClusterDiscovery = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodName = append(m.PodName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedIps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolvedIps = append(m.ResolvedIps, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsulInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsulInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsulInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceName = append(m.InstanceName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscoveredInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscoveredInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscoveredInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveredInfo = &DiscoveredInfoType_K8SInfo{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsulInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsulInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveredInfo = &DiscoveredInfoType_ConsulInfo{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DNSInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveredInfo = &DiscoveredInfoType_DnsInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheckInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheckInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheckInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HealthCheck == nil {
				m.HealthCheck = &views.ObjectRefType{}
			}
			if err := m.HealthCheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HealthStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthStatusFailureReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HealthStatusFailureReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthStatusFailureDetails", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HealthStatusFailureDetails = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthStatusUpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HealthStatusUpdateTime == nil {
				m.HealthStatusUpdateTime = &types.Timestamp{}
			}
			if err := m.HealthStatusUpdateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHealthStatusFailureReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastHealthStatusFailureReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHealthStatusFailureDetails", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastHealthStatusFailureDetails = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHealthStatusUpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastHealthStatusUpdateTime == nil {
				m.LastHealthStatusUpdateTime = &types.Timestamp{}
			}
			if err := m.LastHealthStatusUpdateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveredIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DiscoveredIp == nil {
				m.DiscoveredIp = &schema.IpAddressType{}
			}
			if err := m.DiscoveredIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveredPort", wireType)
			}
			m.DiscoveredPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscoveredPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatedIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllocatedIp == nil {
				m.AllocatedIp = &schema.Ipv6AddressType{}
			}
			if err := m.AllocatedIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HealthStatus == nil {
				m.HealthStatus = make(map[string]HealthStatus)
			}
			var mapkey string
			var mapvalue HealthStatus
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= HealthStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HealthStatus[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveredInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DiscoveredInfo == nil {
				m.DiscoveredInfo = &DiscoveredInfoType{}
			}
			if err := m.DiscoveredInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheckDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HealthCheckDetails = append(m.HealthCheckDetails, &HealthCheckInfoType{})
			if err := m.HealthCheckDetails[len(m.HealthCheckDetails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
