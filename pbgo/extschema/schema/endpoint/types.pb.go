// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/endpoint/types.proto

package endpoint

import proto "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import ves_io_schema3 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"

import strconv "strconv"

import strings "strings"
import reflect "reflect"
import sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// HealthStatus
//
// x-displayName: "Health Status"
// Possible values to specify Health Status of endpoint
type HealthStatus int32

const (
	// HEALTHY
	//
	// x-displayName: "Healthy Status"
	// Status is Healthy
	HEALTHY HealthStatus = 0
	// UNHEALTHY
	//
	// x-displayName: "Unhealthy Status"
	// Status is Unhealthy
	UNHEALTHY HealthStatus = 1
)

var HealthStatus_name = map[int32]string{
	0: "HEALTHY",
	1: "UNHEALTHY",
}
var HealthStatus_value = map[string]int32{
	"HEALTHY":   0,
	"UNHEALTHY": 1,
}

func (HealthStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// ServiceInfoType
//
// x-displayName: "Service Info Type"
// Specifies whether endpoint service is discovered by name or labels
type ServiceInfoType struct {
	// discovery_type
	//
	// x-displayName: "Discovery"
	// x-required
	// Specifies whether the discovery is from Kubernetes or Consul cluster
	DiscoveryType ves_io_schema4.DiscoveryType `protobuf:"varint,1,opt,name=discovery_type,json=discoveryType,proto3,enum=ves.io.schema.DiscoveryType" json:"discovery_type,omitempty"`
	// service_info
	//
	// x-displayName: "Service"
	// Specifies whether service discovery has to be done using service name or labels
	//
	// Types that are valid to be assigned to ServiceInfo:
	//	*ServiceInfoType_ServiceName
	//	*ServiceInfoType_ServiceSelector
	ServiceInfo isServiceInfoType_ServiceInfo `protobuf_oneof:"service_info"`
}

func (m *ServiceInfoType) Reset()                    { *m = ServiceInfoType{} }
func (*ServiceInfoType) ProtoMessage()               {}
func (*ServiceInfoType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

type isServiceInfoType_ServiceInfo interface {
	isServiceInfoType_ServiceInfo()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ServiceInfoType_ServiceName struct {
	ServiceName string `protobuf:"bytes,2,opt,name=service_name,json=serviceName,proto3,oneof"`
}
type ServiceInfoType_ServiceSelector struct {
	ServiceSelector *ves_io_schema4.LabelSelectorType `protobuf:"bytes,3,opt,name=service_selector,json=serviceSelector,oneof"`
}

func (*ServiceInfoType_ServiceName) isServiceInfoType_ServiceInfo()     {}
func (*ServiceInfoType_ServiceSelector) isServiceInfoType_ServiceInfo() {}

func (m *ServiceInfoType) GetServiceInfo() isServiceInfoType_ServiceInfo {
	if m != nil {
		return m.ServiceInfo
	}
	return nil
}

func (m *ServiceInfoType) GetDiscoveryType() ves_io_schema4.DiscoveryType {
	if m != nil {
		return m.DiscoveryType
	}
	return ves_io_schema4.INVALID_DISCOVERY
}

func (m *ServiceInfoType) GetServiceName() string {
	if x, ok := m.GetServiceInfo().(*ServiceInfoType_ServiceName); ok {
		return x.ServiceName
	}
	return ""
}

func (m *ServiceInfoType) GetServiceSelector() *ves_io_schema4.LabelSelectorType {
	if x, ok := m.GetServiceInfo().(*ServiceInfoType_ServiceSelector); ok {
		return x.ServiceSelector
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ServiceInfoType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ServiceInfoType_OneofMarshaler, _ServiceInfoType_OneofUnmarshaler, _ServiceInfoType_OneofSizer, []interface{}{
		(*ServiceInfoType_ServiceName)(nil),
		(*ServiceInfoType_ServiceSelector)(nil),
	}
}

func _ServiceInfoType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ServiceInfoType)
	// service_info
	switch x := m.ServiceInfo.(type) {
	case *ServiceInfoType_ServiceName:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ServiceName)
	case *ServiceInfoType_ServiceSelector:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServiceSelector); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ServiceInfoType.ServiceInfo has unexpected type %T", x)
	}
	return nil
}

func _ServiceInfoType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ServiceInfoType)
	switch tag {
	case 2: // service_info.service_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ServiceInfo = &ServiceInfoType_ServiceName{x}
		return true, err
	case 3: // service_info.service_selector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.LabelSelectorType)
		err := b.DecodeMessage(msg)
		m.ServiceInfo = &ServiceInfoType_ServiceSelector{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ServiceInfoType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ServiceInfoType)
	// service_info
	switch x := m.ServiceInfo.(type) {
	case *ServiceInfoType_ServiceName:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ServiceName)))
		n += len(x.ServiceName)
	case *ServiceInfoType_ServiceSelector:
		s := proto.Size(x.ServiceSelector)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// DnsNameAdvancedType
//
// x-displayName: "DNS Name Advanced Type"
// Specifies name and TTL used for DNS resolution.
type DnsNameAdvancedType struct {
	// name
	//
	// x-displayName: "Endpoint DNS Name"
	// x-example: "volterra.io"
	// Endpoint's ip address is discovered using DNS name resolution. The name given here is fully qualified domain name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// ttl_choice
	//
	// x-displayName: "TTL Choice"
	// Time to live parameter
	//
	// Types that are valid to be assigned to TtlChoice:
	//	*DnsNameAdvancedType_StrictTtl
	//	*DnsNameAdvancedType_RefreshInterval
	TtlChoice isDnsNameAdvancedType_TtlChoice `protobuf_oneof:"ttl_choice"`
}

func (m *DnsNameAdvancedType) Reset()                    { *m = DnsNameAdvancedType{} }
func (*DnsNameAdvancedType) ProtoMessage()               {}
func (*DnsNameAdvancedType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

type isDnsNameAdvancedType_TtlChoice interface {
	isDnsNameAdvancedType_TtlChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DnsNameAdvancedType_StrictTtl struct {
	StrictTtl *ves_io_schema4.Empty `protobuf:"bytes,3,opt,name=strict_ttl,json=strictTtl,oneof"`
}
type DnsNameAdvancedType_RefreshInterval struct {
	RefreshInterval uint32 `protobuf:"varint,4,opt,name=refresh_interval,json=refreshInterval,proto3,oneof"`
}

func (*DnsNameAdvancedType_StrictTtl) isDnsNameAdvancedType_TtlChoice()       {}
func (*DnsNameAdvancedType_RefreshInterval) isDnsNameAdvancedType_TtlChoice() {}

func (m *DnsNameAdvancedType) GetTtlChoice() isDnsNameAdvancedType_TtlChoice {
	if m != nil {
		return m.TtlChoice
	}
	return nil
}

func (m *DnsNameAdvancedType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DnsNameAdvancedType) GetStrictTtl() *ves_io_schema4.Empty {
	if x, ok := m.GetTtlChoice().(*DnsNameAdvancedType_StrictTtl); ok {
		return x.StrictTtl
	}
	return nil
}

func (m *DnsNameAdvancedType) GetRefreshInterval() uint32 {
	if x, ok := m.GetTtlChoice().(*DnsNameAdvancedType_RefreshInterval); ok {
		return x.RefreshInterval
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DnsNameAdvancedType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DnsNameAdvancedType_OneofMarshaler, _DnsNameAdvancedType_OneofUnmarshaler, _DnsNameAdvancedType_OneofSizer, []interface{}{
		(*DnsNameAdvancedType_StrictTtl)(nil),
		(*DnsNameAdvancedType_RefreshInterval)(nil),
	}
}

func _DnsNameAdvancedType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DnsNameAdvancedType)
	// ttl_choice
	switch x := m.TtlChoice.(type) {
	case *DnsNameAdvancedType_StrictTtl:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StrictTtl); err != nil {
			return err
		}
	case *DnsNameAdvancedType_RefreshInterval:
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.RefreshInterval))
	case nil:
	default:
		return fmt.Errorf("DnsNameAdvancedType.TtlChoice has unexpected type %T", x)
	}
	return nil
}

func _DnsNameAdvancedType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DnsNameAdvancedType)
	switch tag {
	case 3: // ttl_choice.strict_ttl
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.TtlChoice = &DnsNameAdvancedType_StrictTtl{msg}
		return true, err
	case 4: // ttl_choice.refresh_interval
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TtlChoice = &DnsNameAdvancedType_RefreshInterval{uint32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _DnsNameAdvancedType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DnsNameAdvancedType)
	// ttl_choice
	switch x := m.TtlChoice.(type) {
	case *DnsNameAdvancedType_StrictTtl:
		s := proto.Size(x.StrictTtl)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DnsNameAdvancedType_RefreshInterval:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.RefreshInterval))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// GlobalSpecType
//
// x-displayName: "Global Configuration Specification"
// Configuration specification for Endpoint
type GlobalSpecType struct {
	// where
	//
	// x-displayName: "Where"
	// This endpoint is present in site, virtual_site or virtual_network selected by following field.
	Where *ves_io_schema4.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where" json:"where,omitempty"`
	// Protocol
	//
	// x-displayName: "Protocol"
	// x-example: "TCP"
	// Endpoint protocol. Default is TCP.
	// Both TCP and UDP protocols are supported
	Protocol string `protobuf:"bytes,9,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Port
	//
	// x-displayName: "Port"
	// x-example: "9080"
	// Endpoint service is available on this port
	Port uint32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	// Health check Port
	//
	// x-displayName: "Port used for health check"
	// x-example: "9080"
	// By default the health check port of an endpoint is the same as the endpointâ€™s port. This option provides an alternative health check port.
	// Setting this with a non-zero value allows an endpoint to have different health check port.
	HealthCheckPort uint32 `protobuf:"varint,12,opt,name=health_check_port,json=healthCheckPort,proto3" json:"health_check_port,omitempty"`
	// Endpoint Address
	//
	// x-displayName: "Endpoint Specifier"
	// Endpoint address can be specified in multiple ways. It can be configured as ip address or DNS name.
	// It can be discovered using a service discovery method.
	// This field represents any one of method by which this endpoint is addressed or discovered.
	//
	// Types that are valid to be assigned to EndpointAddress:
	//	*GlobalSpecType_Ip
	//	*GlobalSpecType_DnsName
	//	*GlobalSpecType_DnsNameAdvanced
	//	*GlobalSpecType_ServerlessServiceName
	//	*GlobalSpecType_ServiceInfo
	//	*GlobalSpecType_K8SClusterApiServer
	EndpointAddress isGlobalSpecType_EndpointAddress `protobuf_oneof:"endpoint_address"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

type isGlobalSpecType_EndpointAddress interface {
	isGlobalSpecType_EndpointAddress()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_Ip struct {
	Ip string `protobuf:"bytes,3,opt,name=ip,proto3,oneof"`
}
type GlobalSpecType_DnsName struct {
	DnsName string `protobuf:"bytes,4,opt,name=dns_name,json=dnsName,proto3,oneof"`
}
type GlobalSpecType_DnsNameAdvanced struct {
	DnsNameAdvanced *DnsNameAdvancedType `protobuf:"bytes,11,opt,name=dns_name_advanced,json=dnsNameAdvanced,oneof"`
}
type GlobalSpecType_ServerlessServiceName struct {
	ServerlessServiceName string `protobuf:"bytes,6,opt,name=serverless_service_name,json=serverlessServiceName,proto3,oneof"`
}
type GlobalSpecType_ServiceInfo struct {
	ServiceInfo *ServiceInfoType `protobuf:"bytes,8,opt,name=service_info,json=serviceInfo,oneof"`
}
type GlobalSpecType_K8SClusterApiServer struct {
	K8SClusterApiServer *ves_io_schema4.Empty `protobuf:"bytes,13,opt,name=k8s_cluster_api_server,json=k8sClusterApiServer,oneof"`
}

func (*GlobalSpecType_Ip) isGlobalSpecType_EndpointAddress()                    {}
func (*GlobalSpecType_DnsName) isGlobalSpecType_EndpointAddress()               {}
func (*GlobalSpecType_DnsNameAdvanced) isGlobalSpecType_EndpointAddress()       {}
func (*GlobalSpecType_ServerlessServiceName) isGlobalSpecType_EndpointAddress() {}
func (*GlobalSpecType_ServiceInfo) isGlobalSpecType_EndpointAddress()           {}
func (*GlobalSpecType_K8SClusterApiServer) isGlobalSpecType_EndpointAddress()   {}

func (m *GlobalSpecType) GetEndpointAddress() isGlobalSpecType_EndpointAddress {
	if m != nil {
		return m.EndpointAddress
	}
	return nil
}

func (m *GlobalSpecType) GetWhere() *ves_io_schema4.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *GlobalSpecType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *GlobalSpecType) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *GlobalSpecType) GetHealthCheckPort() uint32 {
	if m != nil {
		return m.HealthCheckPort
	}
	return 0
}

func (m *GlobalSpecType) GetIp() string {
	if x, ok := m.GetEndpointAddress().(*GlobalSpecType_Ip); ok {
		return x.Ip
	}
	return ""
}

func (m *GlobalSpecType) GetDnsName() string {
	if x, ok := m.GetEndpointAddress().(*GlobalSpecType_DnsName); ok {
		return x.DnsName
	}
	return ""
}

func (m *GlobalSpecType) GetDnsNameAdvanced() *DnsNameAdvancedType {
	if x, ok := m.GetEndpointAddress().(*GlobalSpecType_DnsNameAdvanced); ok {
		return x.DnsNameAdvanced
	}
	return nil
}

func (m *GlobalSpecType) GetServerlessServiceName() string {
	if x, ok := m.GetEndpointAddress().(*GlobalSpecType_ServerlessServiceName); ok {
		return x.ServerlessServiceName
	}
	return ""
}

func (m *GlobalSpecType) GetServiceInfo() *ServiceInfoType {
	if x, ok := m.GetEndpointAddress().(*GlobalSpecType_ServiceInfo); ok {
		return x.ServiceInfo
	}
	return nil
}

func (m *GlobalSpecType) GetK8SClusterApiServer() *ves_io_schema4.Empty {
	if x, ok := m.GetEndpointAddress().(*GlobalSpecType_K8SClusterApiServer); ok {
		return x.K8SClusterApiServer
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GlobalSpecType_OneofMarshaler, _GlobalSpecType_OneofUnmarshaler, _GlobalSpecType_OneofSizer, []interface{}{
		(*GlobalSpecType_Ip)(nil),
		(*GlobalSpecType_DnsName)(nil),
		(*GlobalSpecType_DnsNameAdvanced)(nil),
		(*GlobalSpecType_ServerlessServiceName)(nil),
		(*GlobalSpecType_ServiceInfo)(nil),
		(*GlobalSpecType_K8SClusterApiServer)(nil),
	}
}

func _GlobalSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GlobalSpecType)
	// endpoint_address
	switch x := m.EndpointAddress.(type) {
	case *GlobalSpecType_Ip:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Ip)
	case *GlobalSpecType_DnsName:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.DnsName)
	case *GlobalSpecType_DnsNameAdvanced:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DnsNameAdvanced); err != nil {
			return err
		}
	case *GlobalSpecType_ServerlessServiceName:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ServerlessServiceName)
	case *GlobalSpecType_ServiceInfo:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServiceInfo); err != nil {
			return err
		}
	case *GlobalSpecType_K8SClusterApiServer:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.K8SClusterApiServer); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.EndpointAddress has unexpected type %T", x)
	}
	return nil
}

func _GlobalSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GlobalSpecType)
	switch tag {
	case 3: // endpoint_address.ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.EndpointAddress = &GlobalSpecType_Ip{x}
		return true, err
	case 4: // endpoint_address.dns_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.EndpointAddress = &GlobalSpecType_DnsName{x}
		return true, err
	case 11: // endpoint_address.dns_name_advanced
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DnsNameAdvancedType)
		err := b.DecodeMessage(msg)
		m.EndpointAddress = &GlobalSpecType_DnsNameAdvanced{msg}
		return true, err
	case 6: // endpoint_address.serverless_service_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.EndpointAddress = &GlobalSpecType_ServerlessServiceName{x}
		return true, err
	case 8: // endpoint_address.service_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServiceInfoType)
		err := b.DecodeMessage(msg)
		m.EndpointAddress = &GlobalSpecType_ServiceInfo{msg}
		return true, err
	case 13: // endpoint_address.k8s_cluster_api_server
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.EndpointAddress = &GlobalSpecType_K8SClusterApiServer{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GlobalSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GlobalSpecType)
	// endpoint_address
	switch x := m.EndpointAddress.(type) {
	case *GlobalSpecType_Ip:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Ip)))
		n += len(x.Ip)
	case *GlobalSpecType_DnsName:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.DnsName)))
		n += len(x.DnsName)
	case *GlobalSpecType_DnsNameAdvanced:
		s := proto.Size(x.DnsNameAdvanced)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_ServerlessServiceName:
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ServerlessServiceName)))
		n += len(x.ServerlessServiceName)
	case *GlobalSpecType_ServiceInfo:
		s := proto.Size(x.ServiceInfo)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_K8SClusterApiServer:
		s := proto.Size(x.K8SClusterApiServer)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Create Endpoint
//
// x-displayName: "Create Endpoint"
// Create endpoint will create the object in the storage backend for namespace metadata.namespace
type CreateSpecType struct {
	Where           *ves_io_schema4.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where" json:"where,omitempty"`
	Protocol        string                                 `protobuf:"bytes,9,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Port            uint32                                 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	HealthCheckPort uint32                                 `protobuf:"varint,12,opt,name=health_check_port,json=healthCheckPort,proto3" json:"health_check_port,omitempty"`
	// Types that are valid to be assigned to EndpointAddress:
	//	*CreateSpecType_Ip
	//	*CreateSpecType_DnsName
	//	*CreateSpecType_DnsNameAdvanced
	//	*CreateSpecType_ServiceInfo
	EndpointAddress isCreateSpecType_EndpointAddress `protobuf_oneof:"endpoint_address"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

type isCreateSpecType_EndpointAddress interface {
	isCreateSpecType_EndpointAddress()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_Ip struct {
	Ip string `protobuf:"bytes,3,opt,name=ip,proto3,oneof"`
}
type CreateSpecType_DnsName struct {
	DnsName string `protobuf:"bytes,4,opt,name=dns_name,json=dnsName,proto3,oneof"`
}
type CreateSpecType_DnsNameAdvanced struct {
	DnsNameAdvanced *DnsNameAdvancedType `protobuf:"bytes,11,opt,name=dns_name_advanced,json=dnsNameAdvanced,oneof"`
}
type CreateSpecType_ServiceInfo struct {
	ServiceInfo *ServiceInfoType `protobuf:"bytes,8,opt,name=service_info,json=serviceInfo,oneof"`
}

func (*CreateSpecType_Ip) isCreateSpecType_EndpointAddress()              {}
func (*CreateSpecType_DnsName) isCreateSpecType_EndpointAddress()         {}
func (*CreateSpecType_DnsNameAdvanced) isCreateSpecType_EndpointAddress() {}
func (*CreateSpecType_ServiceInfo) isCreateSpecType_EndpointAddress()     {}

func (m *CreateSpecType) GetEndpointAddress() isCreateSpecType_EndpointAddress {
	if m != nil {
		return m.EndpointAddress
	}
	return nil
}

func (m *CreateSpecType) GetWhere() *ves_io_schema4.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *CreateSpecType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *CreateSpecType) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *CreateSpecType) GetHealthCheckPort() uint32 {
	if m != nil {
		return m.HealthCheckPort
	}
	return 0
}

func (m *CreateSpecType) GetIp() string {
	if x, ok := m.GetEndpointAddress().(*CreateSpecType_Ip); ok {
		return x.Ip
	}
	return ""
}

func (m *CreateSpecType) GetDnsName() string {
	if x, ok := m.GetEndpointAddress().(*CreateSpecType_DnsName); ok {
		return x.DnsName
	}
	return ""
}

func (m *CreateSpecType) GetDnsNameAdvanced() *DnsNameAdvancedType {
	if x, ok := m.GetEndpointAddress().(*CreateSpecType_DnsNameAdvanced); ok {
		return x.DnsNameAdvanced
	}
	return nil
}

func (m *CreateSpecType) GetServiceInfo() *ServiceInfoType {
	if x, ok := m.GetEndpointAddress().(*CreateSpecType_ServiceInfo); ok {
		return x.ServiceInfo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CreateSpecType_OneofMarshaler, _CreateSpecType_OneofUnmarshaler, _CreateSpecType_OneofSizer, []interface{}{
		(*CreateSpecType_Ip)(nil),
		(*CreateSpecType_DnsName)(nil),
		(*CreateSpecType_DnsNameAdvanced)(nil),
		(*CreateSpecType_ServiceInfo)(nil),
	}
}

func _CreateSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CreateSpecType)
	// endpoint_address
	switch x := m.EndpointAddress.(type) {
	case *CreateSpecType_Ip:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Ip)
	case *CreateSpecType_DnsName:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.DnsName)
	case *CreateSpecType_DnsNameAdvanced:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DnsNameAdvanced); err != nil {
			return err
		}
	case *CreateSpecType_ServiceInfo:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServiceInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.EndpointAddress has unexpected type %T", x)
	}
	return nil
}

func _CreateSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CreateSpecType)
	switch tag {
	case 3: // endpoint_address.ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.EndpointAddress = &CreateSpecType_Ip{x}
		return true, err
	case 4: // endpoint_address.dns_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.EndpointAddress = &CreateSpecType_DnsName{x}
		return true, err
	case 11: // endpoint_address.dns_name_advanced
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DnsNameAdvancedType)
		err := b.DecodeMessage(msg)
		m.EndpointAddress = &CreateSpecType_DnsNameAdvanced{msg}
		return true, err
	case 8: // endpoint_address.service_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServiceInfoType)
		err := b.DecodeMessage(msg)
		m.EndpointAddress = &CreateSpecType_ServiceInfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CreateSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CreateSpecType)
	// endpoint_address
	switch x := m.EndpointAddress.(type) {
	case *CreateSpecType_Ip:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Ip)))
		n += len(x.Ip)
	case *CreateSpecType_DnsName:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.DnsName)))
		n += len(x.DnsName)
	case *CreateSpecType_DnsNameAdvanced:
		s := proto.Size(x.DnsNameAdvanced)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_ServiceInfo:
		s := proto.Size(x.ServiceInfo)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Replace Endpoint
//
// x-displayName: "Replace Endpoint"
// Replacing an endpoint object will update the object by replacing the existing spec with the provided one.
// For read-then-write operations a resourceVersion mismatch will occur if the object was modified between the read and write.
type ReplaceSpecType struct {
	Where           *ves_io_schema4.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where" json:"where,omitempty"`
	Protocol        string                                 `protobuf:"bytes,9,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Port            uint32                                 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	HealthCheckPort uint32                                 `protobuf:"varint,12,opt,name=health_check_port,json=healthCheckPort,proto3" json:"health_check_port,omitempty"`
	// Types that are valid to be assigned to EndpointAddress:
	//	*ReplaceSpecType_Ip
	//	*ReplaceSpecType_DnsName
	//	*ReplaceSpecType_DnsNameAdvanced
	//	*ReplaceSpecType_ServiceInfo
	EndpointAddress isReplaceSpecType_EndpointAddress `protobuf_oneof:"endpoint_address"`
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

type isReplaceSpecType_EndpointAddress interface {
	isReplaceSpecType_EndpointAddress()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_Ip struct {
	Ip string `protobuf:"bytes,3,opt,name=ip,proto3,oneof"`
}
type ReplaceSpecType_DnsName struct {
	DnsName string `protobuf:"bytes,4,opt,name=dns_name,json=dnsName,proto3,oneof"`
}
type ReplaceSpecType_DnsNameAdvanced struct {
	DnsNameAdvanced *DnsNameAdvancedType `protobuf:"bytes,11,opt,name=dns_name_advanced,json=dnsNameAdvanced,oneof"`
}
type ReplaceSpecType_ServiceInfo struct {
	ServiceInfo *ServiceInfoType `protobuf:"bytes,8,opt,name=service_info,json=serviceInfo,oneof"`
}

func (*ReplaceSpecType_Ip) isReplaceSpecType_EndpointAddress()              {}
func (*ReplaceSpecType_DnsName) isReplaceSpecType_EndpointAddress()         {}
func (*ReplaceSpecType_DnsNameAdvanced) isReplaceSpecType_EndpointAddress() {}
func (*ReplaceSpecType_ServiceInfo) isReplaceSpecType_EndpointAddress()     {}

func (m *ReplaceSpecType) GetEndpointAddress() isReplaceSpecType_EndpointAddress {
	if m != nil {
		return m.EndpointAddress
	}
	return nil
}

func (m *ReplaceSpecType) GetWhere() *ves_io_schema4.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *ReplaceSpecType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *ReplaceSpecType) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *ReplaceSpecType) GetHealthCheckPort() uint32 {
	if m != nil {
		return m.HealthCheckPort
	}
	return 0
}

func (m *ReplaceSpecType) GetIp() string {
	if x, ok := m.GetEndpointAddress().(*ReplaceSpecType_Ip); ok {
		return x.Ip
	}
	return ""
}

func (m *ReplaceSpecType) GetDnsName() string {
	if x, ok := m.GetEndpointAddress().(*ReplaceSpecType_DnsName); ok {
		return x.DnsName
	}
	return ""
}

func (m *ReplaceSpecType) GetDnsNameAdvanced() *DnsNameAdvancedType {
	if x, ok := m.GetEndpointAddress().(*ReplaceSpecType_DnsNameAdvanced); ok {
		return x.DnsNameAdvanced
	}
	return nil
}

func (m *ReplaceSpecType) GetServiceInfo() *ServiceInfoType {
	if x, ok := m.GetEndpointAddress().(*ReplaceSpecType_ServiceInfo); ok {
		return x.ServiceInfo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReplaceSpecType_OneofMarshaler, _ReplaceSpecType_OneofUnmarshaler, _ReplaceSpecType_OneofSizer, []interface{}{
		(*ReplaceSpecType_Ip)(nil),
		(*ReplaceSpecType_DnsName)(nil),
		(*ReplaceSpecType_DnsNameAdvanced)(nil),
		(*ReplaceSpecType_ServiceInfo)(nil),
	}
}

func _ReplaceSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReplaceSpecType)
	// endpoint_address
	switch x := m.EndpointAddress.(type) {
	case *ReplaceSpecType_Ip:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Ip)
	case *ReplaceSpecType_DnsName:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.DnsName)
	case *ReplaceSpecType_DnsNameAdvanced:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DnsNameAdvanced); err != nil {
			return err
		}
	case *ReplaceSpecType_ServiceInfo:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServiceInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.EndpointAddress has unexpected type %T", x)
	}
	return nil
}

func _ReplaceSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReplaceSpecType)
	switch tag {
	case 3: // endpoint_address.ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.EndpointAddress = &ReplaceSpecType_Ip{x}
		return true, err
	case 4: // endpoint_address.dns_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.EndpointAddress = &ReplaceSpecType_DnsName{x}
		return true, err
	case 11: // endpoint_address.dns_name_advanced
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DnsNameAdvancedType)
		err := b.DecodeMessage(msg)
		m.EndpointAddress = &ReplaceSpecType_DnsNameAdvanced{msg}
		return true, err
	case 8: // endpoint_address.service_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServiceInfoType)
		err := b.DecodeMessage(msg)
		m.EndpointAddress = &ReplaceSpecType_ServiceInfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ReplaceSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReplaceSpecType)
	// endpoint_address
	switch x := m.EndpointAddress.(type) {
	case *ReplaceSpecType_Ip:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Ip)))
		n += len(x.Ip)
	case *ReplaceSpecType_DnsName:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.DnsName)))
		n += len(x.DnsName)
	case *ReplaceSpecType_DnsNameAdvanced:
		s := proto.Size(x.DnsNameAdvanced)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_ServiceInfo:
		s := proto.Size(x.ServiceInfo)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Get Endpoint
//
// x-displayName: "Get Endpoint"
// Get endpoint will get the object from the storage backend for namespace metadata.namespace
type GetSpecType struct {
	Where           *ves_io_schema4.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where" json:"where,omitempty"`
	Protocol        string                                 `protobuf:"bytes,9,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Port            uint32                                 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	HealthCheckPort uint32                                 `protobuf:"varint,12,opt,name=health_check_port,json=healthCheckPort,proto3" json:"health_check_port,omitempty"`
	// Types that are valid to be assigned to EndpointAddress:
	//	*GetSpecType_Ip
	//	*GetSpecType_DnsName
	//	*GetSpecType_DnsNameAdvanced
	//	*GetSpecType_ServiceInfo
	EndpointAddress isGetSpecType_EndpointAddress `protobuf_oneof:"endpoint_address"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

type isGetSpecType_EndpointAddress interface {
	isGetSpecType_EndpointAddress()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_Ip struct {
	Ip string `protobuf:"bytes,3,opt,name=ip,proto3,oneof"`
}
type GetSpecType_DnsName struct {
	DnsName string `protobuf:"bytes,4,opt,name=dns_name,json=dnsName,proto3,oneof"`
}
type GetSpecType_DnsNameAdvanced struct {
	DnsNameAdvanced *DnsNameAdvancedType `protobuf:"bytes,11,opt,name=dns_name_advanced,json=dnsNameAdvanced,oneof"`
}
type GetSpecType_ServiceInfo struct {
	ServiceInfo *ServiceInfoType `protobuf:"bytes,8,opt,name=service_info,json=serviceInfo,oneof"`
}

func (*GetSpecType_Ip) isGetSpecType_EndpointAddress()              {}
func (*GetSpecType_DnsName) isGetSpecType_EndpointAddress()         {}
func (*GetSpecType_DnsNameAdvanced) isGetSpecType_EndpointAddress() {}
func (*GetSpecType_ServiceInfo) isGetSpecType_EndpointAddress()     {}

func (m *GetSpecType) GetEndpointAddress() isGetSpecType_EndpointAddress {
	if m != nil {
		return m.EndpointAddress
	}
	return nil
}

func (m *GetSpecType) GetWhere() *ves_io_schema4.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *GetSpecType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *GetSpecType) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *GetSpecType) GetHealthCheckPort() uint32 {
	if m != nil {
		return m.HealthCheckPort
	}
	return 0
}

func (m *GetSpecType) GetIp() string {
	if x, ok := m.GetEndpointAddress().(*GetSpecType_Ip); ok {
		return x.Ip
	}
	return ""
}

func (m *GetSpecType) GetDnsName() string {
	if x, ok := m.GetEndpointAddress().(*GetSpecType_DnsName); ok {
		return x.DnsName
	}
	return ""
}

func (m *GetSpecType) GetDnsNameAdvanced() *DnsNameAdvancedType {
	if x, ok := m.GetEndpointAddress().(*GetSpecType_DnsNameAdvanced); ok {
		return x.DnsNameAdvanced
	}
	return nil
}

func (m *GetSpecType) GetServiceInfo() *ServiceInfoType {
	if x, ok := m.GetEndpointAddress().(*GetSpecType_ServiceInfo); ok {
		return x.ServiceInfo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetSpecType_OneofMarshaler, _GetSpecType_OneofUnmarshaler, _GetSpecType_OneofSizer, []interface{}{
		(*GetSpecType_Ip)(nil),
		(*GetSpecType_DnsName)(nil),
		(*GetSpecType_DnsNameAdvanced)(nil),
		(*GetSpecType_ServiceInfo)(nil),
	}
}

func _GetSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetSpecType)
	// endpoint_address
	switch x := m.EndpointAddress.(type) {
	case *GetSpecType_Ip:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Ip)
	case *GetSpecType_DnsName:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.DnsName)
	case *GetSpecType_DnsNameAdvanced:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DnsNameAdvanced); err != nil {
			return err
		}
	case *GetSpecType_ServiceInfo:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServiceInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.EndpointAddress has unexpected type %T", x)
	}
	return nil
}

func _GetSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetSpecType)
	switch tag {
	case 3: // endpoint_address.ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.EndpointAddress = &GetSpecType_Ip{x}
		return true, err
	case 4: // endpoint_address.dns_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.EndpointAddress = &GetSpecType_DnsName{x}
		return true, err
	case 11: // endpoint_address.dns_name_advanced
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DnsNameAdvancedType)
		err := b.DecodeMessage(msg)
		m.EndpointAddress = &GetSpecType_DnsNameAdvanced{msg}
		return true, err
	case 8: // endpoint_address.service_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServiceInfoType)
		err := b.DecodeMessage(msg)
		m.EndpointAddress = &GetSpecType_ServiceInfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GetSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetSpecType)
	// endpoint_address
	switch x := m.EndpointAddress.(type) {
	case *GetSpecType_Ip:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Ip)))
		n += len(x.Ip)
	case *GetSpecType_DnsName:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.DnsName)))
		n += len(x.DnsName)
	case *GetSpecType_DnsNameAdvanced:
		s := proto.Size(x.DnsNameAdvanced)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_ServiceInfo:
		s := proto.Size(x.ServiceInfo)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// K8SInfo
//
// x-displayName: "K8s Info"
// Discovered Information for Kubernetes endpoints
type K8SInfo struct {
	// in_cluster_discovery
	//
	// x-displayName: "In Cluster Discovery"
	// x-example: true
	// Specifies whether discovery is from local Kubernetes cluster
	InClusterDiscovery bool `protobuf:"varint,1,opt,name=in_cluster_discovery,json=inClusterDiscovery,proto3" json:"in_cluster_discovery,omitempty"`
	// pod_name
	//
	// x-displayName: "Name of Pod"
	// x-example: "ver-l99cw"
	// Pod Names of the endpoint
	PodName []string `protobuf:"bytes,2,rep,name=pod_name,json=podName" json:"pod_name,omitempty"`
	// labels
	//
	// x-displayName: "labels"
	// labels of service
	Labels map[string]string `protobuf:"bytes,3,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *K8SInfo) Reset()                    { *m = K8SInfo{} }
func (*K8SInfo) ProtoMessage()               {}
func (*K8SInfo) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

func (m *K8SInfo) GetInClusterDiscovery() bool {
	if m != nil {
		return m.InClusterDiscovery
	}
	return false
}

func (m *K8SInfo) GetPodName() []string {
	if m != nil {
		return m.PodName
	}
	return nil
}

func (m *K8SInfo) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// DNSInfo
//
// x-displayName: "DNS Info"
// Addresses resolved from DNS discovery
type DNSInfo struct {
	// x-displayName: "DNS resolved addresses"
	// x-example: "13.84.78.21"
	// IP addresses from DNS resolution
	ResolvedIps []string `protobuf:"bytes,1,rep,name=resolved_ips,json=resolvedIps" json:"resolved_ips,omitempty"`
}

func (m *DNSInfo) Reset()                    { *m = DNSInfo{} }
func (*DNSInfo) ProtoMessage()               {}
func (*DNSInfo) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

func (m *DNSInfo) GetResolvedIps() []string {
	if m != nil {
		return m.ResolvedIps
	}
	return nil
}

// ConsulInfo
//
// x-displayName: "Consul Info"
// Service instance resolved from Consul discovery
type ConsulInfo struct {
	// x-displayName: "Consul resolved service instance"
	// x-example: "web.service.consul"
	// Consul Service instance name
	InstanceName []string `protobuf:"bytes,1,rep,name=instance_name,json=instanceName" json:"instance_name,omitempty"`
	// labels
	//
	// x-displayName: "labels"
	// Tags on the service instance
	Labels map[string]string `protobuf:"bytes,2,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ConsulInfo) Reset()                    { *m = ConsulInfo{} }
func (*ConsulInfo) ProtoMessage()               {}
func (*ConsulInfo) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

func (m *ConsulInfo) GetInstanceName() []string {
	if m != nil {
		return m.InstanceName
	}
	return nil
}

func (m *ConsulInfo) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// DiscoveredInfoType
//
// x-displayName: "Discovered Info Type"
// Discovered Information for endpoints
type DiscoveredInfoType struct {
	// discovered_info
	//
	// x-displayName: "Discovered Info"
	// Discovered Information for endpoints
	//
	// Types that are valid to be assigned to DiscoveredInfo:
	//	*DiscoveredInfoType_K8SInfo
	//	*DiscoveredInfoType_ConsulInfo
	//	*DiscoveredInfoType_DnsInfo
	DiscoveredInfo isDiscoveredInfoType_DiscoveredInfo `protobuf_oneof:"discovered_info"`
}

func (m *DiscoveredInfoType) Reset()                    { *m = DiscoveredInfoType{} }
func (*DiscoveredInfoType) ProtoMessage()               {}
func (*DiscoveredInfoType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

type isDiscoveredInfoType_DiscoveredInfo interface {
	isDiscoveredInfoType_DiscoveredInfo()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DiscoveredInfoType_K8SInfo struct {
	K8SInfo *K8SInfo `protobuf:"bytes,1,opt,name=k8s_info,json=k8sInfo,oneof"`
}
type DiscoveredInfoType_ConsulInfo struct {
	ConsulInfo *ConsulInfo `protobuf:"bytes,2,opt,name=consul_info,json=consulInfo,oneof"`
}
type DiscoveredInfoType_DnsInfo struct {
	DnsInfo *DNSInfo `protobuf:"bytes,3,opt,name=dns_info,json=dnsInfo,oneof"`
}

func (*DiscoveredInfoType_K8SInfo) isDiscoveredInfoType_DiscoveredInfo()    {}
func (*DiscoveredInfoType_ConsulInfo) isDiscoveredInfoType_DiscoveredInfo() {}
func (*DiscoveredInfoType_DnsInfo) isDiscoveredInfoType_DiscoveredInfo()    {}

func (m *DiscoveredInfoType) GetDiscoveredInfo() isDiscoveredInfoType_DiscoveredInfo {
	if m != nil {
		return m.DiscoveredInfo
	}
	return nil
}

func (m *DiscoveredInfoType) GetK8SInfo() *K8SInfo {
	if x, ok := m.GetDiscoveredInfo().(*DiscoveredInfoType_K8SInfo); ok {
		return x.K8SInfo
	}
	return nil
}

func (m *DiscoveredInfoType) GetConsulInfo() *ConsulInfo {
	if x, ok := m.GetDiscoveredInfo().(*DiscoveredInfoType_ConsulInfo); ok {
		return x.ConsulInfo
	}
	return nil
}

func (m *DiscoveredInfoType) GetDnsInfo() *DNSInfo {
	if x, ok := m.GetDiscoveredInfo().(*DiscoveredInfoType_DnsInfo); ok {
		return x.DnsInfo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DiscoveredInfoType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DiscoveredInfoType_OneofMarshaler, _DiscoveredInfoType_OneofUnmarshaler, _DiscoveredInfoType_OneofSizer, []interface{}{
		(*DiscoveredInfoType_K8SInfo)(nil),
		(*DiscoveredInfoType_ConsulInfo)(nil),
		(*DiscoveredInfoType_DnsInfo)(nil),
	}
}

func _DiscoveredInfoType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DiscoveredInfoType)
	// discovered_info
	switch x := m.DiscoveredInfo.(type) {
	case *DiscoveredInfoType_K8SInfo:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.K8SInfo); err != nil {
			return err
		}
	case *DiscoveredInfoType_ConsulInfo:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ConsulInfo); err != nil {
			return err
		}
	case *DiscoveredInfoType_DnsInfo:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DnsInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DiscoveredInfoType.DiscoveredInfo has unexpected type %T", x)
	}
	return nil
}

func _DiscoveredInfoType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DiscoveredInfoType)
	switch tag {
	case 1: // discovered_info.k8s_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(K8SInfo)
		err := b.DecodeMessage(msg)
		m.DiscoveredInfo = &DiscoveredInfoType_K8SInfo{msg}
		return true, err
	case 2: // discovered_info.consul_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConsulInfo)
		err := b.DecodeMessage(msg)
		m.DiscoveredInfo = &DiscoveredInfoType_ConsulInfo{msg}
		return true, err
	case 3: // discovered_info.dns_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DNSInfo)
		err := b.DecodeMessage(msg)
		m.DiscoveredInfo = &DiscoveredInfoType_DnsInfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DiscoveredInfoType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DiscoveredInfoType)
	// discovered_info
	switch x := m.DiscoveredInfo.(type) {
	case *DiscoveredInfoType_K8SInfo:
		s := proto.Size(x.K8SInfo)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DiscoveredInfoType_ConsulInfo:
		s := proto.Size(x.ConsulInfo)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DiscoveredInfoType_DnsInfo:
		s := proto.Size(x.DnsInfo)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// VerStatusType
//
// x-displayName: "VER Status Type"
// Status information sent for endpoints
type VerStatusType struct {
	// service_name
	//
	// x-displayName: "Service Name"
	// x-example: "productpage"
	// Service Name of the endpoint
	ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	// discovered_ip
	//
	// x-displayName: "Discovered IP"
	// Discovered IP of the endpoint
	DiscoveredIp *ves_io_schema3.IpAddressType `protobuf:"bytes,2,opt,name=discovered_ip,json=discoveredIp" json:"discovered_ip,omitempty"`
	// discovered_port
	//
	// x-displayName: "Discovered Port"
	// x-example: 9080
	// Discovered port of the endpoint
	DiscoveredPort uint32 `protobuf:"varint,3,opt,name=discovered_port,json=discoveredPort,proto3" json:"discovered_port,omitempty"`
	// allocated_ip
	//
	// x-displayName: "Allocated IP"
	// Allocated AIN IP of the endpoint
	AllocatedIp *ves_io_schema3.Ipv6AddressType `protobuf:"bytes,4,opt,name=allocated_ip,json=allocatedIp" json:"allocated_ip,omitempty"`
	// site
	//
	// x-displayName: "Site"
	// x-example: "ce01"
	// site name of the endpoint
	Site string `protobuf:"bytes,5,opt,name=site,proto3" json:"site,omitempty"`
	// Health Status
	//
	// x-displayName: "Health Status"
	// Map of HealthCheck UID to health status
	HealthStatus map[string]HealthStatus `protobuf:"bytes,6,rep,name=health_status,json=healthStatus" json:"health_status,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=ves.io.schema.endpoint.HealthStatus"`
	// DiscoveredInfoType
	//
	// x-displayName: "Discovered Info"
	// Discovered Information for endpoints
	DiscoveredInfo *DiscoveredInfoType `protobuf:"bytes,7,opt,name=discovered_info,json=discoveredInfo" json:"discovered_info,omitempty"`
}

func (m *VerStatusType) Reset()                    { *m = VerStatusType{} }
func (*VerStatusType) ProtoMessage()               {}
func (*VerStatusType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

func (m *VerStatusType) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *VerStatusType) GetDiscoveredIp() *ves_io_schema3.IpAddressType {
	if m != nil {
		return m.DiscoveredIp
	}
	return nil
}

func (m *VerStatusType) GetDiscoveredPort() uint32 {
	if m != nil {
		return m.DiscoveredPort
	}
	return 0
}

func (m *VerStatusType) GetAllocatedIp() *ves_io_schema3.Ipv6AddressType {
	if m != nil {
		return m.AllocatedIp
	}
	return nil
}

func (m *VerStatusType) GetSite() string {
	if m != nil {
		return m.Site
	}
	return ""
}

func (m *VerStatusType) GetHealthStatus() map[string]HealthStatus {
	if m != nil {
		return m.HealthStatus
	}
	return nil
}

func (m *VerStatusType) GetDiscoveredInfo() *DiscoveredInfoType {
	if m != nil {
		return m.DiscoveredInfo
	}
	return nil
}

func init() {
	proto.RegisterType((*ServiceInfoType)(nil), "ves.io.schema.endpoint.ServiceInfoType")
	golang_proto.RegisterType((*ServiceInfoType)(nil), "ves.io.schema.endpoint.ServiceInfoType")
	proto.RegisterType((*DnsNameAdvancedType)(nil), "ves.io.schema.endpoint.DnsNameAdvancedType")
	golang_proto.RegisterType((*DnsNameAdvancedType)(nil), "ves.io.schema.endpoint.DnsNameAdvancedType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.endpoint.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.endpoint.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.endpoint.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.endpoint.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.endpoint.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.endpoint.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.endpoint.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.endpoint.GetSpecType")
	proto.RegisterType((*K8SInfo)(nil), "ves.io.schema.endpoint.K8SInfo")
	golang_proto.RegisterType((*K8SInfo)(nil), "ves.io.schema.endpoint.K8SInfo")
	proto.RegisterType((*DNSInfo)(nil), "ves.io.schema.endpoint.DNSInfo")
	golang_proto.RegisterType((*DNSInfo)(nil), "ves.io.schema.endpoint.DNSInfo")
	proto.RegisterType((*ConsulInfo)(nil), "ves.io.schema.endpoint.ConsulInfo")
	golang_proto.RegisterType((*ConsulInfo)(nil), "ves.io.schema.endpoint.ConsulInfo")
	proto.RegisterType((*DiscoveredInfoType)(nil), "ves.io.schema.endpoint.DiscoveredInfoType")
	golang_proto.RegisterType((*DiscoveredInfoType)(nil), "ves.io.schema.endpoint.DiscoveredInfoType")
	proto.RegisterType((*VerStatusType)(nil), "ves.io.schema.endpoint.VerStatusType")
	golang_proto.RegisterType((*VerStatusType)(nil), "ves.io.schema.endpoint.VerStatusType")
	proto.RegisterEnum("ves.io.schema.endpoint.HealthStatus", HealthStatus_name, HealthStatus_value)
	golang_proto.RegisterEnum("ves.io.schema.endpoint.HealthStatus", HealthStatus_name, HealthStatus_value)
}
func (x HealthStatus) String() string {
	s, ok := HealthStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *ServiceInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceInfoType)
	if !ok {
		that2, ok := that.(ServiceInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DiscoveryType != that1.DiscoveryType {
		return false
	}
	if that1.ServiceInfo == nil {
		if this.ServiceInfo != nil {
			return false
		}
	} else if this.ServiceInfo == nil {
		return false
	} else if !this.ServiceInfo.Equal(that1.ServiceInfo) {
		return false
	}
	return true
}
func (this *ServiceInfoType_ServiceName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceInfoType_ServiceName)
	if !ok {
		that2, ok := that.(ServiceInfoType_ServiceName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServiceName != that1.ServiceName {
		return false
	}
	return true
}
func (this *ServiceInfoType_ServiceSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceInfoType_ServiceSelector)
	if !ok {
		that2, ok := that.(ServiceInfoType_ServiceSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServiceSelector.Equal(that1.ServiceSelector) {
		return false
	}
	return true
}
func (this *DnsNameAdvancedType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DnsNameAdvancedType)
	if !ok {
		that2, ok := that.(DnsNameAdvancedType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.TtlChoice == nil {
		if this.TtlChoice != nil {
			return false
		}
	} else if this.TtlChoice == nil {
		return false
	} else if !this.TtlChoice.Equal(that1.TtlChoice) {
		return false
	}
	return true
}
func (this *DnsNameAdvancedType_StrictTtl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DnsNameAdvancedType_StrictTtl)
	if !ok {
		that2, ok := that.(DnsNameAdvancedType_StrictTtl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StrictTtl.Equal(that1.StrictTtl) {
		return false
	}
	return true
}
func (this *DnsNameAdvancedType_RefreshInterval) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DnsNameAdvancedType_RefreshInterval)
	if !ok {
		that2, ok := that.(DnsNameAdvancedType_RefreshInterval)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RefreshInterval != that1.RefreshInterval {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.HealthCheckPort != that1.HealthCheckPort {
		return false
	}
	if that1.EndpointAddress == nil {
		if this.EndpointAddress != nil {
			return false
		}
	} else if this.EndpointAddress == nil {
		return false
	} else if !this.EndpointAddress.Equal(that1.EndpointAddress) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Ip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Ip)
	if !ok {
		that2, ok := that.(GlobalSpecType_Ip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	return true
}
func (this *GlobalSpecType_DnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DnsName)
	if !ok {
		that2, ok := that.(GlobalSpecType_DnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DnsName != that1.DnsName {
		return false
	}
	return true
}
func (this *GlobalSpecType_DnsNameAdvanced) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DnsNameAdvanced)
	if !ok {
		that2, ok := that.(GlobalSpecType_DnsNameAdvanced)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DnsNameAdvanced.Equal(that1.DnsNameAdvanced) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ServerlessServiceName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ServerlessServiceName)
	if !ok {
		that2, ok := that.(GlobalSpecType_ServerlessServiceName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerlessServiceName != that1.ServerlessServiceName {
		return false
	}
	return true
}
func (this *GlobalSpecType_ServiceInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ServiceInfo)
	if !ok {
		that2, ok := that.(GlobalSpecType_ServiceInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServiceInfo.Equal(that1.ServiceInfo) {
		return false
	}
	return true
}
func (this *GlobalSpecType_K8SClusterApiServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_K8SClusterApiServer)
	if !ok {
		that2, ok := that.(GlobalSpecType_K8SClusterApiServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.K8SClusterApiServer.Equal(that1.K8SClusterApiServer) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.HealthCheckPort != that1.HealthCheckPort {
		return false
	}
	if that1.EndpointAddress == nil {
		if this.EndpointAddress != nil {
			return false
		}
	} else if this.EndpointAddress == nil {
		return false
	} else if !this.EndpointAddress.Equal(that1.EndpointAddress) {
		return false
	}
	return true
}
func (this *CreateSpecType_Ip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_Ip)
	if !ok {
		that2, ok := that.(CreateSpecType_Ip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	return true
}
func (this *CreateSpecType_DnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DnsName)
	if !ok {
		that2, ok := that.(CreateSpecType_DnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DnsName != that1.DnsName {
		return false
	}
	return true
}
func (this *CreateSpecType_DnsNameAdvanced) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DnsNameAdvanced)
	if !ok {
		that2, ok := that.(CreateSpecType_DnsNameAdvanced)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DnsNameAdvanced.Equal(that1.DnsNameAdvanced) {
		return false
	}
	return true
}
func (this *CreateSpecType_ServiceInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ServiceInfo)
	if !ok {
		that2, ok := that.(CreateSpecType_ServiceInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServiceInfo.Equal(that1.ServiceInfo) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.HealthCheckPort != that1.HealthCheckPort {
		return false
	}
	if that1.EndpointAddress == nil {
		if this.EndpointAddress != nil {
			return false
		}
	} else if this.EndpointAddress == nil {
		return false
	} else if !this.EndpointAddress.Equal(that1.EndpointAddress) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_Ip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_Ip)
	if !ok {
		that2, ok := that.(ReplaceSpecType_Ip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DnsName)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DnsName != that1.DnsName {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DnsNameAdvanced) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DnsNameAdvanced)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DnsNameAdvanced)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DnsNameAdvanced.Equal(that1.DnsNameAdvanced) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ServiceInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ServiceInfo)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ServiceInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServiceInfo.Equal(that1.ServiceInfo) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.HealthCheckPort != that1.HealthCheckPort {
		return false
	}
	if that1.EndpointAddress == nil {
		if this.EndpointAddress != nil {
			return false
		}
	} else if this.EndpointAddress == nil {
		return false
	} else if !this.EndpointAddress.Equal(that1.EndpointAddress) {
		return false
	}
	return true
}
func (this *GetSpecType_Ip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_Ip)
	if !ok {
		that2, ok := that.(GetSpecType_Ip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	return true
}
func (this *GetSpecType_DnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DnsName)
	if !ok {
		that2, ok := that.(GetSpecType_DnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DnsName != that1.DnsName {
		return false
	}
	return true
}
func (this *GetSpecType_DnsNameAdvanced) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DnsNameAdvanced)
	if !ok {
		that2, ok := that.(GetSpecType_DnsNameAdvanced)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DnsNameAdvanced.Equal(that1.DnsNameAdvanced) {
		return false
	}
	return true
}
func (this *GetSpecType_ServiceInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ServiceInfo)
	if !ok {
		that2, ok := that.(GetSpecType_ServiceInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServiceInfo.Equal(that1.ServiceInfo) {
		return false
	}
	return true
}
func (this *K8SInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SInfo)
	if !ok {
		that2, ok := that.(K8SInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.InClusterDiscovery != that1.InClusterDiscovery {
		return false
	}
	if len(this.PodName) != len(that1.PodName) {
		return false
	}
	for i := range this.PodName {
		if this.PodName[i] != that1.PodName[i] {
			return false
		}
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	return true
}
func (this *DNSInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DNSInfo)
	if !ok {
		that2, ok := that.(DNSInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ResolvedIps) != len(that1.ResolvedIps) {
		return false
	}
	for i := range this.ResolvedIps {
		if this.ResolvedIps[i] != that1.ResolvedIps[i] {
			return false
		}
	}
	return true
}
func (this *ConsulInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulInfo)
	if !ok {
		that2, ok := that.(ConsulInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.InstanceName) != len(that1.InstanceName) {
		return false
	}
	for i := range this.InstanceName {
		if this.InstanceName[i] != that1.InstanceName[i] {
			return false
		}
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	return true
}
func (this *DiscoveredInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DiscoveredInfoType)
	if !ok {
		that2, ok := that.(DiscoveredInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DiscoveredInfo == nil {
		if this.DiscoveredInfo != nil {
			return false
		}
	} else if this.DiscoveredInfo == nil {
		return false
	} else if !this.DiscoveredInfo.Equal(that1.DiscoveredInfo) {
		return false
	}
	return true
}
func (this *DiscoveredInfoType_K8SInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DiscoveredInfoType_K8SInfo)
	if !ok {
		that2, ok := that.(DiscoveredInfoType_K8SInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.K8SInfo.Equal(that1.K8SInfo) {
		return false
	}
	return true
}
func (this *DiscoveredInfoType_ConsulInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DiscoveredInfoType_ConsulInfo)
	if !ok {
		that2, ok := that.(DiscoveredInfoType_ConsulInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConsulInfo.Equal(that1.ConsulInfo) {
		return false
	}
	return true
}
func (this *DiscoveredInfoType_DnsInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DiscoveredInfoType_DnsInfo)
	if !ok {
		that2, ok := that.(DiscoveredInfoType_DnsInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DnsInfo.Equal(that1.DnsInfo) {
		return false
	}
	return true
}
func (this *VerStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VerStatusType)
	if !ok {
		that2, ok := that.(VerStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServiceName != that1.ServiceName {
		return false
	}
	if !this.DiscoveredIp.Equal(that1.DiscoveredIp) {
		return false
	}
	if this.DiscoveredPort != that1.DiscoveredPort {
		return false
	}
	if !this.AllocatedIp.Equal(that1.AllocatedIp) {
		return false
	}
	if this.Site != that1.Site {
		return false
	}
	if len(this.HealthStatus) != len(that1.HealthStatus) {
		return false
	}
	for i := range this.HealthStatus {
		if this.HealthStatus[i] != that1.HealthStatus[i] {
			return false
		}
	}
	if !this.DiscoveredInfo.Equal(that1.DiscoveredInfo) {
		return false
	}
	return true
}
func (this *ServiceInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&endpoint.ServiceInfoType{")
	s = append(s, "DiscoveryType: "+fmt.Sprintf("%#v", this.DiscoveryType)+",\n")
	if this.ServiceInfo != nil {
		s = append(s, "ServiceInfo: "+fmt.Sprintf("%#v", this.ServiceInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServiceInfoType_ServiceName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.ServiceInfoType_ServiceName{` +
		`ServiceName:` + fmt.Sprintf("%#v", this.ServiceName) + `}`}, ", ")
	return s
}
func (this *ServiceInfoType_ServiceSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.ServiceInfoType_ServiceSelector{` +
		`ServiceSelector:` + fmt.Sprintf("%#v", this.ServiceSelector) + `}`}, ", ")
	return s
}
func (this *DnsNameAdvancedType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&endpoint.DnsNameAdvancedType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.TtlChoice != nil {
		s = append(s, "TtlChoice: "+fmt.Sprintf("%#v", this.TtlChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DnsNameAdvancedType_StrictTtl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.DnsNameAdvancedType_StrictTtl{` +
		`StrictTtl:` + fmt.Sprintf("%#v", this.StrictTtl) + `}`}, ", ")
	return s
}
func (this *DnsNameAdvancedType_RefreshInterval) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.DnsNameAdvancedType_RefreshInterval{` +
		`RefreshInterval:` + fmt.Sprintf("%#v", this.RefreshInterval) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&endpoint.GlobalSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "HealthCheckPort: "+fmt.Sprintf("%#v", this.HealthCheckPort)+",\n")
	if this.EndpointAddress != nil {
		s = append(s, "EndpointAddress: "+fmt.Sprintf("%#v", this.EndpointAddress)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_Ip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GlobalSpecType_Ip{` +
		`Ip:` + fmt.Sprintf("%#v", this.Ip) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GlobalSpecType_DnsName{` +
		`DnsName:` + fmt.Sprintf("%#v", this.DnsName) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DnsNameAdvanced) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GlobalSpecType_DnsNameAdvanced{` +
		`DnsNameAdvanced:` + fmt.Sprintf("%#v", this.DnsNameAdvanced) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ServerlessServiceName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GlobalSpecType_ServerlessServiceName{` +
		`ServerlessServiceName:` + fmt.Sprintf("%#v", this.ServerlessServiceName) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ServiceInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GlobalSpecType_ServiceInfo{` +
		`ServiceInfo:` + fmt.Sprintf("%#v", this.ServiceInfo) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_K8SClusterApiServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GlobalSpecType_K8SClusterApiServer{` +
		`K8SClusterApiServer:` + fmt.Sprintf("%#v", this.K8SClusterApiServer) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&endpoint.CreateSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "HealthCheckPort: "+fmt.Sprintf("%#v", this.HealthCheckPort)+",\n")
	if this.EndpointAddress != nil {
		s = append(s, "EndpointAddress: "+fmt.Sprintf("%#v", this.EndpointAddress)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_Ip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.CreateSpecType_Ip{` +
		`Ip:` + fmt.Sprintf("%#v", this.Ip) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.CreateSpecType_DnsName{` +
		`DnsName:` + fmt.Sprintf("%#v", this.DnsName) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DnsNameAdvanced) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.CreateSpecType_DnsNameAdvanced{` +
		`DnsNameAdvanced:` + fmt.Sprintf("%#v", this.DnsNameAdvanced) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ServiceInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.CreateSpecType_ServiceInfo{` +
		`ServiceInfo:` + fmt.Sprintf("%#v", this.ServiceInfo) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&endpoint.ReplaceSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "HealthCheckPort: "+fmt.Sprintf("%#v", this.HealthCheckPort)+",\n")
	if this.EndpointAddress != nil {
		s = append(s, "EndpointAddress: "+fmt.Sprintf("%#v", this.EndpointAddress)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_Ip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.ReplaceSpecType_Ip{` +
		`Ip:` + fmt.Sprintf("%#v", this.Ip) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.ReplaceSpecType_DnsName{` +
		`DnsName:` + fmt.Sprintf("%#v", this.DnsName) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DnsNameAdvanced) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.ReplaceSpecType_DnsNameAdvanced{` +
		`DnsNameAdvanced:` + fmt.Sprintf("%#v", this.DnsNameAdvanced) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ServiceInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.ReplaceSpecType_ServiceInfo{` +
		`ServiceInfo:` + fmt.Sprintf("%#v", this.ServiceInfo) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&endpoint.GetSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "HealthCheckPort: "+fmt.Sprintf("%#v", this.HealthCheckPort)+",\n")
	if this.EndpointAddress != nil {
		s = append(s, "EndpointAddress: "+fmt.Sprintf("%#v", this.EndpointAddress)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_Ip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GetSpecType_Ip{` +
		`Ip:` + fmt.Sprintf("%#v", this.Ip) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GetSpecType_DnsName{` +
		`DnsName:` + fmt.Sprintf("%#v", this.DnsName) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DnsNameAdvanced) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GetSpecType_DnsNameAdvanced{` +
		`DnsNameAdvanced:` + fmt.Sprintf("%#v", this.DnsNameAdvanced) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ServiceInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.GetSpecType_ServiceInfo{` +
		`ServiceInfo:` + fmt.Sprintf("%#v", this.ServiceInfo) + `}`}, ", ")
	return s
}
func (this *K8SInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&endpoint.K8SInfo{")
	s = append(s, "InClusterDiscovery: "+fmt.Sprintf("%#v", this.InClusterDiscovery)+",\n")
	s = append(s, "PodName: "+fmt.Sprintf("%#v", this.PodName)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DNSInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&endpoint.DNSInfo{")
	s = append(s, "ResolvedIps: "+fmt.Sprintf("%#v", this.ResolvedIps)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConsulInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&endpoint.ConsulInfo{")
	s = append(s, "InstanceName: "+fmt.Sprintf("%#v", this.InstanceName)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DiscoveredInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&endpoint.DiscoveredInfoType{")
	if this.DiscoveredInfo != nil {
		s = append(s, "DiscoveredInfo: "+fmt.Sprintf("%#v", this.DiscoveredInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DiscoveredInfoType_K8SInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.DiscoveredInfoType_K8SInfo{` +
		`K8SInfo:` + fmt.Sprintf("%#v", this.K8SInfo) + `}`}, ", ")
	return s
}
func (this *DiscoveredInfoType_ConsulInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.DiscoveredInfoType_ConsulInfo{` +
		`ConsulInfo:` + fmt.Sprintf("%#v", this.ConsulInfo) + `}`}, ", ")
	return s
}
func (this *DiscoveredInfoType_DnsInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&endpoint.DiscoveredInfoType_DnsInfo{` +
		`DnsInfo:` + fmt.Sprintf("%#v", this.DnsInfo) + `}`}, ", ")
	return s
}
func (this *VerStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&endpoint.VerStatusType{")
	s = append(s, "ServiceName: "+fmt.Sprintf("%#v", this.ServiceName)+",\n")
	if this.DiscoveredIp != nil {
		s = append(s, "DiscoveredIp: "+fmt.Sprintf("%#v", this.DiscoveredIp)+",\n")
	}
	s = append(s, "DiscoveredPort: "+fmt.Sprintf("%#v", this.DiscoveredPort)+",\n")
	if this.AllocatedIp != nil {
		s = append(s, "AllocatedIp: "+fmt.Sprintf("%#v", this.AllocatedIp)+",\n")
	}
	s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	keysForHealthStatus := make([]string, 0, len(this.HealthStatus))
	for k, _ := range this.HealthStatus {
		keysForHealthStatus = append(keysForHealthStatus, k)
	}
	sortkeys.Strings(keysForHealthStatus)
	mapStringForHealthStatus := "map[string]HealthStatus{"
	for _, k := range keysForHealthStatus {
		mapStringForHealthStatus += fmt.Sprintf("%#v: %#v,", k, this.HealthStatus[k])
	}
	mapStringForHealthStatus += "}"
	if this.HealthStatus != nil {
		s = append(s, "HealthStatus: "+mapStringForHealthStatus+",\n")
	}
	if this.DiscoveredInfo != nil {
		s = append(s, "DiscoveredInfo: "+fmt.Sprintf("%#v", this.DiscoveredInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *ServiceInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceInfoType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DiscoveryType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DiscoveryType))
	}
	if m.ServiceInfo != nil {
		nn1, err := m.ServiceInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *ServiceInfoType_ServiceName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServiceName)))
	i += copy(dAtA[i:], m.ServiceName)
	return i, nil
}
func (m *ServiceInfoType_ServiceSelector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServiceSelector != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ServiceSelector.Size()))
		n2, err := m.ServiceSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *DnsNameAdvancedType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DnsNameAdvancedType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.TtlChoice != nil {
		nn3, err := m.TtlChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	return i, nil
}

func (m *DnsNameAdvancedType_StrictTtl) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StrictTtl != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StrictTtl.Size()))
		n4, err := m.StrictTtl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *DnsNameAdvancedType_RefreshInterval) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x20
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.RefreshInterval))
	return i, nil
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Where != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Where.Size()))
		n5, err := m.Where.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Port))
	}
	if m.EndpointAddress != nil {
		nn6, err := m.EndpointAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn6
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.HealthCheckPort != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.HealthCheckPort))
	}
	return i, nil
}

func (m *GlobalSpecType_Ip) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Ip)))
	i += copy(dAtA[i:], m.Ip)
	return i, nil
}
func (m *GlobalSpecType_DnsName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x22
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DnsName)))
	i += copy(dAtA[i:], m.DnsName)
	return i, nil
}
func (m *GlobalSpecType_ServerlessServiceName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x32
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerlessServiceName)))
	i += copy(dAtA[i:], m.ServerlessServiceName)
	return i, nil
}
func (m *GlobalSpecType_ServiceInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServiceInfo != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ServiceInfo.Size()))
		n7, err := m.ServiceInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *GlobalSpecType_DnsNameAdvanced) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DnsNameAdvanced != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DnsNameAdvanced.Size()))
		n8, err := m.DnsNameAdvanced.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *GlobalSpecType_K8SClusterApiServer) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.K8SClusterApiServer != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.K8SClusterApiServer.Size()))
		n9, err := m.K8SClusterApiServer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Where != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Where.Size()))
		n10, err := m.Where.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Port))
	}
	if m.EndpointAddress != nil {
		nn11, err := m.EndpointAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn11
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.HealthCheckPort != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.HealthCheckPort))
	}
	return i, nil
}

func (m *CreateSpecType_Ip) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Ip)))
	i += copy(dAtA[i:], m.Ip)
	return i, nil
}
func (m *CreateSpecType_DnsName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x22
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DnsName)))
	i += copy(dAtA[i:], m.DnsName)
	return i, nil
}
func (m *CreateSpecType_ServiceInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServiceInfo != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ServiceInfo.Size()))
		n12, err := m.ServiceInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *CreateSpecType_DnsNameAdvanced) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DnsNameAdvanced != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DnsNameAdvanced.Size()))
		n13, err := m.DnsNameAdvanced.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Where != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Where.Size()))
		n14, err := m.Where.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Port))
	}
	if m.EndpointAddress != nil {
		nn15, err := m.EndpointAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn15
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.HealthCheckPort != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.HealthCheckPort))
	}
	return i, nil
}

func (m *ReplaceSpecType_Ip) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Ip)))
	i += copy(dAtA[i:], m.Ip)
	return i, nil
}
func (m *ReplaceSpecType_DnsName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x22
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DnsName)))
	i += copy(dAtA[i:], m.DnsName)
	return i, nil
}
func (m *ReplaceSpecType_ServiceInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServiceInfo != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ServiceInfo.Size()))
		n16, err := m.ServiceInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *ReplaceSpecType_DnsNameAdvanced) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DnsNameAdvanced != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DnsNameAdvanced.Size()))
		n17, err := m.DnsNameAdvanced.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Where != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Where.Size()))
		n18, err := m.Where.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Port))
	}
	if m.EndpointAddress != nil {
		nn19, err := m.EndpointAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn19
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.HealthCheckPort != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.HealthCheckPort))
	}
	return i, nil
}

func (m *GetSpecType_Ip) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Ip)))
	i += copy(dAtA[i:], m.Ip)
	return i, nil
}
func (m *GetSpecType_DnsName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x22
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DnsName)))
	i += copy(dAtA[i:], m.DnsName)
	return i, nil
}
func (m *GetSpecType_ServiceInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServiceInfo != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ServiceInfo.Size()))
		n20, err := m.ServiceInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}
func (m *GetSpecType_DnsNameAdvanced) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DnsNameAdvanced != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DnsNameAdvanced.Size()))
		n21, err := m.DnsNameAdvanced.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *K8SInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InClusterDiscovery {
		dAtA[i] = 0x8
		i++
		if m.InClusterDiscovery {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PodName) > 0 {
		for _, s := range m.PodName {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k, _ := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		sortkeys.Strings(keysForLabels)
		for _, k := range keysForLabels {
			dAtA[i] = 0x1a
			i++
			v := m.Labels[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *DNSInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNSInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResolvedIps) > 0 {
		for _, s := range m.ResolvedIps {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ConsulInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsulInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InstanceName) > 0 {
		for _, s := range m.InstanceName {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k, _ := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		sortkeys.Strings(keysForLabels)
		for _, k := range keysForLabels {
			dAtA[i] = 0x12
			i++
			v := m.Labels[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *DiscoveredInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscoveredInfoType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DiscoveredInfo != nil {
		nn22, err := m.DiscoveredInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn22
	}
	return i, nil
}

func (m *DiscoveredInfoType_K8SInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.K8SInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.K8SInfo.Size()))
		n23, err := m.K8SInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *DiscoveredInfoType_ConsulInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ConsulInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ConsulInfo.Size()))
		n24, err := m.ConsulInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *DiscoveredInfoType_DnsInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DnsInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DnsInfo.Size()))
		n25, err := m.DnsInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *VerStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerStatusType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServiceName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServiceName)))
		i += copy(dAtA[i:], m.ServiceName)
	}
	if m.DiscoveredIp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DiscoveredIp.Size()))
		n26, err := m.DiscoveredIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.DiscoveredPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DiscoveredPort))
	}
	if m.AllocatedIp != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AllocatedIp.Size()))
		n27, err := m.AllocatedIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if len(m.Site) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Site)))
		i += copy(dAtA[i:], m.Site)
	}
	if len(m.HealthStatus) > 0 {
		keysForHealthStatus := make([]string, 0, len(m.HealthStatus))
		for k, _ := range m.HealthStatus {
			keysForHealthStatus = append(keysForHealthStatus, string(k))
		}
		sortkeys.Strings(keysForHealthStatus)
		for _, k := range keysForHealthStatus {
			dAtA[i] = 0x32
			i++
			v := m.HealthStatus[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + sovTypes(uint64(v))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintTypes(dAtA, i, uint64(v))
		}
	}
	if m.DiscoveredInfo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DiscoveredInfo.Size()))
		n28, err := m.DiscoveredInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ServiceInfoType) Size() (n int) {
	var l int
	_ = l
	if m.DiscoveryType != 0 {
		n += 1 + sovTypes(uint64(m.DiscoveryType))
	}
	if m.ServiceInfo != nil {
		n += m.ServiceInfo.Size()
	}
	return n
}

func (m *ServiceInfoType_ServiceName) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServiceName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ServiceInfoType_ServiceSelector) Size() (n int) {
	var l int
	_ = l
	if m.ServiceSelector != nil {
		l = m.ServiceSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DnsNameAdvancedType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TtlChoice != nil {
		n += m.TtlChoice.Size()
	}
	return n
}

func (m *DnsNameAdvancedType_StrictTtl) Size() (n int) {
	var l int
	_ = l
	if m.StrictTtl != nil {
		l = m.StrictTtl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DnsNameAdvancedType_RefreshInterval) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.RefreshInterval))
	return n
}
func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovTypes(uint64(m.Port))
	}
	if m.EndpointAddress != nil {
		n += m.EndpointAddress.Size()
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HealthCheckPort != 0 {
		n += 1 + sovTypes(uint64(m.HealthCheckPort))
	}
	return n
}

func (m *GlobalSpecType_Ip) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ip)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GlobalSpecType_DnsName) Size() (n int) {
	var l int
	_ = l
	l = len(m.DnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GlobalSpecType_ServerlessServiceName) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServerlessServiceName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GlobalSpecType_ServiceInfo) Size() (n int) {
	var l int
	_ = l
	if m.ServiceInfo != nil {
		l = m.ServiceInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DnsNameAdvanced) Size() (n int) {
	var l int
	_ = l
	if m.DnsNameAdvanced != nil {
		l = m.DnsNameAdvanced.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_K8SClusterApiServer) Size() (n int) {
	var l int
	_ = l
	if m.K8SClusterApiServer != nil {
		l = m.K8SClusterApiServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovTypes(uint64(m.Port))
	}
	if m.EndpointAddress != nil {
		n += m.EndpointAddress.Size()
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HealthCheckPort != 0 {
		n += 1 + sovTypes(uint64(m.HealthCheckPort))
	}
	return n
}

func (m *CreateSpecType_Ip) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ip)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CreateSpecType_DnsName) Size() (n int) {
	var l int
	_ = l
	l = len(m.DnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CreateSpecType_ServiceInfo) Size() (n int) {
	var l int
	_ = l
	if m.ServiceInfo != nil {
		l = m.ServiceInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DnsNameAdvanced) Size() (n int) {
	var l int
	_ = l
	if m.DnsNameAdvanced != nil {
		l = m.DnsNameAdvanced.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovTypes(uint64(m.Port))
	}
	if m.EndpointAddress != nil {
		n += m.EndpointAddress.Size()
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HealthCheckPort != 0 {
		n += 1 + sovTypes(uint64(m.HealthCheckPort))
	}
	return n
}

func (m *ReplaceSpecType_Ip) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ip)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ReplaceSpecType_DnsName) Size() (n int) {
	var l int
	_ = l
	l = len(m.DnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ReplaceSpecType_ServiceInfo) Size() (n int) {
	var l int
	_ = l
	if m.ServiceInfo != nil {
		l = m.ServiceInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DnsNameAdvanced) Size() (n int) {
	var l int
	_ = l
	if m.DnsNameAdvanced != nil {
		l = m.DnsNameAdvanced.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovTypes(uint64(m.Port))
	}
	if m.EndpointAddress != nil {
		n += m.EndpointAddress.Size()
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HealthCheckPort != 0 {
		n += 1 + sovTypes(uint64(m.HealthCheckPort))
	}
	return n
}

func (m *GetSpecType_Ip) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ip)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GetSpecType_DnsName) Size() (n int) {
	var l int
	_ = l
	l = len(m.DnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GetSpecType_ServiceInfo) Size() (n int) {
	var l int
	_ = l
	if m.ServiceInfo != nil {
		l = m.ServiceInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DnsNameAdvanced) Size() (n int) {
	var l int
	_ = l
	if m.DnsNameAdvanced != nil {
		l = m.DnsNameAdvanced.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SInfo) Size() (n int) {
	var l int
	_ = l
	if m.InClusterDiscovery {
		n += 2
	}
	if len(m.PodName) > 0 {
		for _, s := range m.PodName {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DNSInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.ResolvedIps) > 0 {
		for _, s := range m.ResolvedIps {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ConsulInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.InstanceName) > 0 {
		for _, s := range m.InstanceName {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DiscoveredInfoType) Size() (n int) {
	var l int
	_ = l
	if m.DiscoveredInfo != nil {
		n += m.DiscoveredInfo.Size()
	}
	return n
}

func (m *DiscoveredInfoType_K8SInfo) Size() (n int) {
	var l int
	_ = l
	if m.K8SInfo != nil {
		l = m.K8SInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DiscoveredInfoType_ConsulInfo) Size() (n int) {
	var l int
	_ = l
	if m.ConsulInfo != nil {
		l = m.ConsulInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DiscoveredInfoType_DnsInfo) Size() (n int) {
	var l int
	_ = l
	if m.DnsInfo != nil {
		l = m.DnsInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VerStatusType) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DiscoveredIp != nil {
		l = m.DiscoveredIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DiscoveredPort != 0 {
		n += 1 + sovTypes(uint64(m.DiscoveredPort))
	}
	if m.AllocatedIp != nil {
		l = m.AllocatedIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Site)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.HealthStatus) > 0 {
		for k, v := range m.HealthStatus {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + sovTypes(uint64(v))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.DiscoveredInfo != nil {
		l = m.DiscoveredInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ServiceInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceInfoType{`,
		`DiscoveryType:` + fmt.Sprintf("%v", this.DiscoveryType) + `,`,
		`ServiceInfo:` + fmt.Sprintf("%v", this.ServiceInfo) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceInfoType_ServiceName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceInfoType_ServiceName{`,
		`ServiceName:` + fmt.Sprintf("%v", this.ServiceName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceInfoType_ServiceSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceInfoType_ServiceSelector{`,
		`ServiceSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServiceSelector), "LabelSelectorType", "ves_io_schema4.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DnsNameAdvancedType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DnsNameAdvancedType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`TtlChoice:` + fmt.Sprintf("%v", this.TtlChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DnsNameAdvancedType_StrictTtl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DnsNameAdvancedType_StrictTtl{`,
		`StrictTtl:` + strings.Replace(fmt.Sprintf("%v", this.StrictTtl), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DnsNameAdvancedType_RefreshInterval) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DnsNameAdvancedType_RefreshInterval{`,
		`RefreshInterval:` + fmt.Sprintf("%v", this.RefreshInterval) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "ves_io_schema4.NetworkSiteRefSelector", 1) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`EndpointAddress:` + fmt.Sprintf("%v", this.EndpointAddress) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`HealthCheckPort:` + fmt.Sprintf("%v", this.HealthCheckPort) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Ip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Ip{`,
		`Ip:` + fmt.Sprintf("%v", this.Ip) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DnsName{`,
		`DnsName:` + fmt.Sprintf("%v", this.DnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ServerlessServiceName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ServerlessServiceName{`,
		`ServerlessServiceName:` + fmt.Sprintf("%v", this.ServerlessServiceName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ServiceInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ServiceInfo{`,
		`ServiceInfo:` + strings.Replace(fmt.Sprintf("%v", this.ServiceInfo), "ServiceInfoType", "ServiceInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DnsNameAdvanced) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DnsNameAdvanced{`,
		`DnsNameAdvanced:` + strings.Replace(fmt.Sprintf("%v", this.DnsNameAdvanced), "DnsNameAdvancedType", "DnsNameAdvancedType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_K8SClusterApiServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_K8SClusterApiServer{`,
		`K8SClusterApiServer:` + strings.Replace(fmt.Sprintf("%v", this.K8SClusterApiServer), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "ves_io_schema4.NetworkSiteRefSelector", 1) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`EndpointAddress:` + fmt.Sprintf("%v", this.EndpointAddress) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`HealthCheckPort:` + fmt.Sprintf("%v", this.HealthCheckPort) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_Ip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_Ip{`,
		`Ip:` + fmt.Sprintf("%v", this.Ip) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DnsName{`,
		`DnsName:` + fmt.Sprintf("%v", this.DnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ServiceInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ServiceInfo{`,
		`ServiceInfo:` + strings.Replace(fmt.Sprintf("%v", this.ServiceInfo), "ServiceInfoType", "ServiceInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DnsNameAdvanced) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DnsNameAdvanced{`,
		`DnsNameAdvanced:` + strings.Replace(fmt.Sprintf("%v", this.DnsNameAdvanced), "DnsNameAdvancedType", "DnsNameAdvancedType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "ves_io_schema4.NetworkSiteRefSelector", 1) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`EndpointAddress:` + fmt.Sprintf("%v", this.EndpointAddress) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`HealthCheckPort:` + fmt.Sprintf("%v", this.HealthCheckPort) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_Ip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_Ip{`,
		`Ip:` + fmt.Sprintf("%v", this.Ip) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DnsName{`,
		`DnsName:` + fmt.Sprintf("%v", this.DnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ServiceInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ServiceInfo{`,
		`ServiceInfo:` + strings.Replace(fmt.Sprintf("%v", this.ServiceInfo), "ServiceInfoType", "ServiceInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DnsNameAdvanced) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DnsNameAdvanced{`,
		`DnsNameAdvanced:` + strings.Replace(fmt.Sprintf("%v", this.DnsNameAdvanced), "DnsNameAdvancedType", "DnsNameAdvancedType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "ves_io_schema4.NetworkSiteRefSelector", 1) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`EndpointAddress:` + fmt.Sprintf("%v", this.EndpointAddress) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`HealthCheckPort:` + fmt.Sprintf("%v", this.HealthCheckPort) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_Ip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_Ip{`,
		`Ip:` + fmt.Sprintf("%v", this.Ip) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DnsName{`,
		`DnsName:` + fmt.Sprintf("%v", this.DnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ServiceInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ServiceInfo{`,
		`ServiceInfo:` + strings.Replace(fmt.Sprintf("%v", this.ServiceInfo), "ServiceInfoType", "ServiceInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DnsNameAdvanced) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DnsNameAdvanced{`,
		`DnsNameAdvanced:` + strings.Replace(fmt.Sprintf("%v", this.DnsNameAdvanced), "DnsNameAdvancedType", "DnsNameAdvancedType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SInfo) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&K8SInfo{`,
		`InClusterDiscovery:` + fmt.Sprintf("%v", this.InClusterDiscovery) + `,`,
		`PodName:` + fmt.Sprintf("%v", this.PodName) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *DNSInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DNSInfo{`,
		`ResolvedIps:` + fmt.Sprintf("%v", this.ResolvedIps) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulInfo) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&ConsulInfo{`,
		`InstanceName:` + fmt.Sprintf("%v", this.InstanceName) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiscoveredInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DiscoveredInfoType{`,
		`DiscoveredInfo:` + fmt.Sprintf("%v", this.DiscoveredInfo) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiscoveredInfoType_K8SInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DiscoveredInfoType_K8SInfo{`,
		`K8SInfo:` + strings.Replace(fmt.Sprintf("%v", this.K8SInfo), "K8SInfo", "K8SInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiscoveredInfoType_ConsulInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DiscoveredInfoType_ConsulInfo{`,
		`ConsulInfo:` + strings.Replace(fmt.Sprintf("%v", this.ConsulInfo), "ConsulInfo", "ConsulInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiscoveredInfoType_DnsInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DiscoveredInfoType_DnsInfo{`,
		`DnsInfo:` + strings.Replace(fmt.Sprintf("%v", this.DnsInfo), "DNSInfo", "DNSInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VerStatusType) String() string {
	if this == nil {
		return "nil"
	}
	keysForHealthStatus := make([]string, 0, len(this.HealthStatus))
	for k, _ := range this.HealthStatus {
		keysForHealthStatus = append(keysForHealthStatus, k)
	}
	sortkeys.Strings(keysForHealthStatus)
	mapStringForHealthStatus := "map[string]HealthStatus{"
	for _, k := range keysForHealthStatus {
		mapStringForHealthStatus += fmt.Sprintf("%v: %v,", k, this.HealthStatus[k])
	}
	mapStringForHealthStatus += "}"
	s := strings.Join([]string{`&VerStatusType{`,
		`ServiceName:` + fmt.Sprintf("%v", this.ServiceName) + `,`,
		`DiscoveredIp:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveredIp), "IpAddressType", "ves_io_schema3.IpAddressType", 1) + `,`,
		`DiscoveredPort:` + fmt.Sprintf("%v", this.DiscoveredPort) + `,`,
		`AllocatedIp:` + strings.Replace(fmt.Sprintf("%v", this.AllocatedIp), "Ipv6AddressType", "ves_io_schema3.Ipv6AddressType", 1) + `,`,
		`Site:` + fmt.Sprintf("%v", this.Site) + `,`,
		`HealthStatus:` + mapStringForHealthStatus + `,`,
		`DiscoveredInfo:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveredInfo), "DiscoveredInfoType", "DiscoveredInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ServiceInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryType", wireType)
			}
			m.DiscoveryType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscoveryType |= (ves_io_schema4.DiscoveryType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceInfo = &ServiceInfoType_ServiceName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServiceInfo = &ServiceInfoType_ServiceSelector{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DnsNameAdvancedType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DnsNameAdvancedType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DnsNameAdvancedType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrictTtl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TtlChoice = &DnsNameAdvancedType_StrictTtl{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshInterval", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TtlChoice = &DnsNameAdvancedType_RefreshInterval{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &ves_io_schema4.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAddress = &GlobalSpecType_Ip{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAddress = &GlobalSpecType_DnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerlessServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAddress = &GlobalSpecType_ServerlessServiceName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointAddress = &GlobalSpecType_ServiceInfo{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsNameAdvanced", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DnsNameAdvancedType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointAddress = &GlobalSpecType_DnsNameAdvanced{v}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheckPort", wireType)
			}
			m.HealthCheckPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HealthCheckPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SClusterApiServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointAddress = &GlobalSpecType_K8SClusterApiServer{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &ves_io_schema4.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAddress = &CreateSpecType_Ip{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAddress = &CreateSpecType_DnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointAddress = &CreateSpecType_ServiceInfo{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsNameAdvanced", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DnsNameAdvancedType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointAddress = &CreateSpecType_DnsNameAdvanced{v}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheckPort", wireType)
			}
			m.HealthCheckPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HealthCheckPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &ves_io_schema4.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAddress = &ReplaceSpecType_Ip{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAddress = &ReplaceSpecType_DnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointAddress = &ReplaceSpecType_ServiceInfo{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsNameAdvanced", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DnsNameAdvancedType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointAddress = &ReplaceSpecType_DnsNameAdvanced{v}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheckPort", wireType)
			}
			m.HealthCheckPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HealthCheckPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &ves_io_schema4.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAddress = &GetSpecType_Ip{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAddress = &GetSpecType_DnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointAddress = &GetSpecType_ServiceInfo{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsNameAdvanced", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DnsNameAdvancedType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointAddress = &GetSpecType_DnsNameAdvanced{v}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheckPort", wireType)
			}
			m.HealthCheckPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HealthCheckPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InClusterDiscovery", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InClusterDiscovery = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodName = append(m.PodName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedIps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolvedIps = append(m.ResolvedIps, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsulInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsulInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsulInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceName = append(m.InstanceName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscoveredInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscoveredInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscoveredInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveredInfo = &DiscoveredInfoType_K8SInfo{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsulInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsulInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveredInfo = &DiscoveredInfoType_ConsulInfo{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DNSInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveredInfo = &DiscoveredInfoType_DnsInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveredIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DiscoveredIp == nil {
				m.DiscoveredIp = &ves_io_schema3.IpAddressType{}
			}
			if err := m.DiscoveredIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveredPort", wireType)
			}
			m.DiscoveredPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscoveredPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatedIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllocatedIp == nil {
				m.AllocatedIp = &ves_io_schema3.Ipv6AddressType{}
			}
			if err := m.AllocatedIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HealthStatus == nil {
				m.HealthStatus = make(map[string]HealthStatus)
			}
			var mapkey string
			var mapvalue HealthStatus
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (HealthStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HealthStatus[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveredInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DiscoveredInfo == nil {
				m.DiscoveredInfo = &DiscoveredInfoType{}
			}
			if err := m.DiscoveredInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/endpoint/types.proto", fileDescriptorTypes) }
func init() { golang_proto.RegisterFile("ves.io/schema/endpoint/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 1553 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0xdf, 0x6b, 0xdb, 0xd6,
	0x1e, 0xf7, 0x91, 0x14, 0x5b, 0xf9, 0xda, 0x8e, 0x1d, 0x35, 0xb7, 0x51, 0xd3, 0xd6, 0x75, 0xdd,
	0x96, 0xba, 0xa9, 0x6b, 0xe7, 0x17, 0xf7, 0xa6, 0xb9, 0xa5, 0x97, 0x38, 0x09, 0x75, 0x72, 0x43,
	0x6e, 0x91, 0xd3, 0x0b, 0xdd, 0x06, 0x42, 0x91, 0x4e, 0x62, 0x11, 0x45, 0x12, 0xd2, 0x89, 0xbb,
	0x3c, 0x0c, 0x42, 0xd9, 0xd3, 0x5e, 0xb6, 0xe7, 0xfe, 0x03, 0xdb, 0xdf, 0x30, 0x97, 0x2d, 0x0c,
	0x06, 0x63, 0x4f, 0x81, 0xbd, 0x94, 0x3d, 0xb5, 0xee, 0x4b, 0xf7, 0x32, 0xca, 0xa0, 0x63, 0xec,
	0xa5, 0x43, 0x47, 0x92, 0x23, 0x3b, 0x49, 0x3b, 0x46, 0x19, 0x14, 0xfa, 0x26, 0x9d, 0xf3, 0xfd,
	0xf5, 0xf9, 0x7c, 0x3f, 0x5f, 0xf9, 0x1c, 0x43, 0xa1, 0x89, 0xdd, 0xb2, 0x6e, 0x55, 0x5c, 0xb5,
	0x81, 0xb7, 0x94, 0x0a, 0x36, 0x35, 0xdb, 0xd2, 0x4d, 0x52, 0x21, 0x3b, 0x36, 0x76, 0xcb, 0xb6,
	0x63, 0x11, 0x4b, 0x38, 0xe9, 0xdb, 0x94, 0x7d, 0x9b, 0x72, 0x68, 0x33, 0x72, 0x6d, 0x43, 0x27,
	0x8d, 0xed, 0xb5, 0xb2, 0x6a, 0x6d, 0x55, 0x36, 0xac, 0x0d, 0xab, 0x42, 0xcd, 0xd7, 0xb6, 0xd7,
	0xe9, 0x1b, 0x7d, 0xa1, 0x4f, 0x7e, 0x98, 0x91, 0xe1, 0xee, 0x54, 0x26, 0x26, 0xc1, 0xc6, 0xe9,
	0xee, 0x0d, 0xcb, 0x26, 0xba, 0x65, 0x06, 0xc9, 0x47, 0x4e, 0x75, 0x6f, 0x46, 0xea, 0x1a, 0x39,
	0xd3, 0xbd, 0xd5, 0x54, 0x0c, 0x5d, 0x53, 0x08, 0x0e, 0x76, 0xf3, 0x3d, 0xbb, 0x3a, 0xbe, 0x27,
	0x77, 0x85, 0x2e, 0x7c, 0xce, 0x40, 0xa6, 0x8e, 0x9d, 0xa6, 0xae, 0xe2, 0x45, 0x73, 0xdd, 0x5a,
	0xdd, 0xb1, 0xb1, 0x50, 0x87, 0x01, 0x4d, 0x77, 0x55, 0xab, 0x89, 0x9d, 0x1d, 0xd9, 0x4b, 0x26,
	0xa2, 0x3c, 0x2a, 0x0e, 0x4c, 0x9c, 0x29, 0x77, 0x93, 0x30, 0x1f, 0x1a, 0x79, 0x5e, 0xd5, 0x81,
	0xdf, 0x5a, 0x28, 0xf6, 0xe5, 0x4f, 0x7b, 0x6c, 0xdf, 0x7d, 0xc4, 0xe4, 0x63, 0x52, 0x5a, 0x8b,
	0x6e, 0x0b, 0x93, 0x90, 0x72, 0xfd, 0x3c, 0xb2, 0xa9, 0x6c, 0x61, 0x91, 0xc9, 0xa3, 0x62, 0x7f,
	0xc4, 0xc9, 0x61, 0x8b, 0xbb, 0x4c, 0x2d, 0x26, 0x25, 0x03, 0xab, 0x15, 0x65, 0x0b, 0x0b, 0xef,
	0x43, 0x36, 0x74, 0x72, 0xb1, 0x81, 0x55, 0x62, 0x39, 0x22, 0x9b, 0x47, 0xc5, 0xe4, 0x44, 0xbe,
	0xa7, 0x96, 0x65, 0x65, 0x0d, 0x1b, 0xf5, 0xc0, 0x86, 0xd6, 0x93, 0xf2, 0x42, 0x3f, 0x78, 0x88,
	0x38, 0x60, 0x62, 0xa8, 0x16, 0x93, 0x32, 0x41, 0xa4, 0xd0, 0x68, 0x26, 0xfe, 0xcb, 0x4d, 0x76,
	0xbc, 0x34, 0x55, 0x3d, 0x77, 0x50, 0x99, 0x6e, 0xae, 0x5b, 0x42, 0x66, 0xaf, 0x85, 0xd8, 0xfd,
	0x16, 0xe2, 0xda, 0x2d, 0xc4, 0x4e, 0x94, 0x26, 0x97, 0x38, 0x9e, 0xcb, 0xf6, 0x15, 0x7e, 0x46,
	0x70, 0x62, 0xde, 0x74, 0xbd, 0xba, 0x66, 0xb5, 0xa6, 0x62, 0xaa, 0x58, 0xa3, 0xc0, 0xae, 0x02,
	0x47, 0x01, 0x21, 0x0a, 0x68, 0x38, 0x02, 0x48, 0xdc, 0x65, 0xbc, 0x27, 0xce, 0x61, 0x1a, 0x48,
	0xa2, 0x46, 0xc2, 0x4d, 0x00, 0x97, 0x38, 0xba, 0x4a, 0x64, 0x42, 0x8c, 0x00, 0xca, 0x50, 0x0f,
	0x94, 0x85, 0x2d, 0x9b, 0xec, 0x54, 0x13, 0x8f, 0x3e, 0x42, 0xcf, 0x5a, 0xc8, 0xab, 0xbc, 0xdf,
	0x77, 0x59, 0x25, 0x86, 0xb0, 0x00, 0x59, 0x07, 0xaf, 0x3b, 0xd8, 0x6d, 0xc8, 0xba, 0x49, 0xb0,
	0xd3, 0x54, 0x0c, 0x91, 0xcb, 0xa3, 0x62, 0xba, 0x2a, 0xfe, 0xd8, 0x42, 0xec, 0xe4, 0xd8, 0x58,
	0x98, 0x9f, 0x1f, 0x8d, 0x8b, 0xbb, 0x2f, 0x2e, 0x16, 0xc1, 0x83, 0x1e, 0xf8, 0x2c, 0x06, 0x2e,
	0xd5, 0xb3, 0x00, 0x84, 0x18, 0xb2, 0xda, 0xb0, 0x74, 0x15, 0x53, 0xc0, 0xdc, 0x7e, 0x0b, 0x31,
	0x1e, 0xe0, 0xc9, 0xd2, 0xd4, 0x12, 0xc7, 0x33, 0x59, 0xb6, 0xf0, 0x71, 0x1c, 0x06, 0x6e, 0x19,
	0xd6, 0x9a, 0x62, 0xd4, 0x6d, 0xac, 0x52, 0xac, 0xb3, 0xd0, 0x77, 0xaf, 0x81, 0x1d, 0x1f, 0x6c,
	0x72, 0xe2, 0x52, 0x4f, 0xe5, 0x2b, 0x98, 0xdc, 0xb3, 0x9c, 0xcd, 0xba, 0x4e, 0xb0, 0x84, 0xd7,
	0x43, 0xa2, 0xab, 0xdc, 0xf3, 0x16, 0x42, 0x92, 0xef, 0x29, 0x5c, 0x00, 0xce, 0xb6, 0x1c, 0x42,
	0xfb, 0x9f, 0xae, 0x66, 0xc2, 0x72, 0xe3, 0xa3, 0x9c, 0xf8, 0xf2, 0x25, 0x2b, 0xd1, 0x4d, 0xe1,
	0x1c, 0x30, 0xba, 0x4d, 0xe9, 0xe9, 0xaf, 0xa6, 0x43, 0x13, 0xce, 0x61, 0x6c, 0x8f, 0x0e, 0x46,
	0xb7, 0x85, 0x29, 0xe0, 0x35, 0xd3, 0xf5, 0x95, 0xc4, 0xbd, 0x92, 0xf8, 0x5a, 0x4c, 0x4a, 0x68,
	0x7e, 0xdb, 0x84, 0x65, 0x18, 0xf6, 0x3a, 0x8d, 0x1d, 0x03, 0xbb, 0xae, 0xdc, 0x25, 0xc7, 0x38,
	0x0d, 0x22, 0x78, 0x8c, 0x77, 0x07, 0xaa, 0xc5, 0xa4, 0x7f, 0x1c, 0x38, 0xd5, 0x23, 0xe2, 0x5c,
	0xee, 0xd6, 0x8d, 0xc8, 0x53, 0x4e, 0x2e, 0x97, 0x8f, 0xfe, 0x52, 0x94, 0x7b, 0xa6, 0x2c, 0x22,
	0x75, 0x6f, 0x49, 0x98, 0x06, 0x9e, 0x4e, 0xa4, 0x6a, 0x19, 0x62, 0x3f, 0x2d, 0xe6, 0x8c, 0xd7,
	0xd1, 0xd5, 0xb9, 0xdb, 0x61, 0x3d, 0x29, 0x07, 0x24, 0xef, 0x5d, 0x62, 0xef, 0xcc, 0xdf, 0x96,
	0x3a, 0xd6, 0x82, 0x0c, 0x83, 0x21, 0x17, 0xb2, 0x12, 0x28, 0x53, 0x4c, 0xd2, 0x62, 0xae, 0x1e,
	0x57, 0xcc, 0x11, 0x42, 0xae, 0x72, 0x7b, 0xbe, 0xdc, 0x32, 0x5a, 0xf7, 0xa6, 0xf0, 0x1f, 0x18,
	0x6c, 0x60, 0xc5, 0x20, 0x0d, 0x59, 0x6d, 0x60, 0x75, 0x53, 0xa6, 0xfd, 0x4b, 0xd1, 0xfe, 0x9d,
	0xd8, 0x8b, 0x10, 0x16, 0xf6, 0x30, 0xe3, 0x5b, 0xcf, 0x79, 0xc6, 0xb7, 0xbd, 0x76, 0xae, 0xc2,
	0xc9, 0xcd, 0x69, 0x57, 0x56, 0x8d, 0x6d, 0x97, 0x60, 0x47, 0x56, 0x6c, 0x5d, 0xf6, 0x29, 0x15,
	0xd3, 0x7f, 0x6e, 0x02, 0x4e, 0x6c, 0x4e, 0xbb, 0x73, 0xbe, 0xf7, 0xac, 0xad, 0xd7, 0xa9, 0xef,
	0xcc, 0x95, 0x6f, 0x5a, 0xe8, 0x12, 0x5c, 0x80, 0xe1, 0xff, 0x39, 0xfa, 0x86, 0x6e, 0xe6, 0xfd,
	0xe5, 0xe2, 0x42, 0x80, 0xf1, 0x8a, 0xc0, 0x8f, 0x8f, 0x95, 0xae, 0x97, 0x26, 0x4a, 0xe3, 0xd5,
	0x22, 0x64, 0x43, 0xe8, 0xb2, 0xa2, 0x69, 0x0e, 0x76, 0x5d, 0x61, 0x28, 0x18, 0x73, 0x68, 0xb7,
	0x10, 0x3f, 0x59, 0x9a, 0x2a, 0x4d, 0x97, 0xc6, 0xc7, 0x97, 0x38, 0xbe, 0x2f, 0x1b, 0x5f, 0xe2,
	0xf8, 0x44, 0x96, 0x5f, 0xe2, 0x78, 0xc8, 0x26, 0x0b, 0x5f, 0xb1, 0x30, 0x30, 0xe7, 0x60, 0x85,
	0xe0, 0xce, 0x18, 0xfc, 0xfb, 0xaf, 0x8c, 0x41, 0x38, 0x00, 0x42, 0x74, 0x00, 0x02, 0xbd, 0x67,
	0x0f, 0xf4, 0x1e, 0x08, 0xfc, 0x74, 0xaf, 0xc0, 0xbb, 0x75, 0xfc, 0x26, 0x95, 0x37, 0xd2, 0xab,
	0xbc, 0x88, 0xb6, 0xee, 0xbe, 0x19, 0x6d, 0x1d, 0xa5, 0xaa, 0xd1, 0x63, 0x55, 0x75, 0x48, 0x40,
	0x33, 0x83, 0xdf, 0xdf, 0xec, 0xf9, 0x14, 0x1d, 0xdd, 0xd2, 0xfb, 0xbf, 0xa3, 0x43, 0xab, 0x85,
	0xaf, 0x59, 0xc8, 0x48, 0xd8, 0x36, 0x14, 0xf5, 0x5d, 0x07, 0xdf, 0xce, 0x0e, 0xb6, 0x58, 0x48,
	0xde, 0xc2, 0xe4, 0x5d, 0xf7, 0xde, 0xca, 0xee, 0xbd, 0x40, 0x90, 0xf8, 0xef, 0x74, 0x9d, 0x62,
	0x1d, 0x83, 0x21, 0xdd, 0xec, 0xfc, 0x10, 0x74, 0x4e, 0x88, 0xb4, 0x91, 0xbc, 0x24, 0xe8, 0x66,
	0xf0, 0x95, 0xef, 0x1c, 0x2d, 0x85, 0x53, 0xc0, 0xdb, 0x96, 0x16, 0x9e, 0x19, 0xd9, 0x62, 0xbf,
	0x94, 0xb0, 0x2d, 0x8d, 0xb6, 0x61, 0x0d, 0xe2, 0x86, 0x77, 0xec, 0x73, 0x45, 0x36, 0xcf, 0xbe,
	0x8a, 0x91, 0x20, 0xbb, 0x7f, 0x48, 0x74, 0x17, 0x4c, 0xe2, 0xec, 0x54, 0xcf, 0x86, 0x47, 0x43,
	0xfa, 0x53, 0xff, 0x00, 0x31, 0xd9, 0x7c, 0xfb, 0xf1, 0xb7, 0x6c, 0xfc, 0x93, 0x87, 0x88, 0xe1,
	0x63, 0x52, 0x10, 0x79, 0xe4, 0x3a, 0x24, 0x23, 0x5e, 0x42, 0x16, 0xd8, 0x4d, 0xec, 0x97, 0xdb,
	0x2f, 0x79, 0x8f, 0xc2, 0x10, 0xf4, 0x35, 0x15, 0x63, 0x3b, 0x38, 0xd0, 0x4a, 0xfe, 0xcb, 0x0c,
	0x33, 0x8d, 0x0a, 0x25, 0x48, 0xcc, 0xaf, 0xf8, 0xb0, 0xcf, 0x43, 0xca, 0xc1, 0xae, 0x65, 0x34,
	0xb1, 0x26, 0xeb, 0xb6, 0x2b, 0x22, 0x0a, 0x24, 0x19, 0xae, 0x2d, 0xda, 0x6e, 0xe1, 0x07, 0x04,
	0x30, 0x67, 0x99, 0xee, 0xb6, 0x41, 0x3d, 0x2e, 0x40, 0x5a, 0x37, 0x5d, 0xe2, 0xb5, 0x4a, 0x0e,
	0x8e, 0x97, 0x9e, 0x4b, 0x2a, 0x5c, 0xa4, 0x04, 0xe0, 0x0e, 0x01, 0x0c, 0x25, 0xa0, 0x7c, 0x1c,
	0x01, 0x07, 0x81, 0xff, 0x66, 0x0e, 0x7e, 0x45, 0x20, 0x84, 0xbd, 0xc4, 0x5a, 0xe7, 0x86, 0x71,
	0x03, 0x78, 0xef, 0x40, 0x40, 0x87, 0xc7, 0x9f, 0xe1, 0x73, 0xaf, 0xe9, 0x9d, 0x37, 0x7e, 0x9b,
	0xd3, 0x2e, 0xe5, 0x66, 0x01, 0x92, 0x2a, 0x05, 0xe4, 0x07, 0x60, 0x68, 0x80, 0xc2, 0xeb, 0xb1,
	0xd7, 0x62, 0x12, 0xa8, 0x07, 0x14, 0xdf, 0xf0, 0x47, 0x9c, 0xc6, 0x60, 0x5f, 0x5d, 0x44, 0xd0,
	0xc7, 0xe0, 0x1b, 0xe0, 0x3d, 0x56, 0x87, 0x21, 0xa3, 0x75, 0x80, 0xf9, 0x17, 0x07, 0xef, 0x0c,
	0xcd, 0x05, 0xb7, 0x85, 0x4f, 0x39, 0x48, 0xff, 0x1f, 0x3b, 0x75, 0xa2, 0x90, 0x6d, 0x97, 0x62,
	0x3e, 0xdf, 0x73, 0x01, 0xf2, 0xf9, 0xeb, 0xba, 0xee, 0xcc, 0x42, 0x3a, 0x1a, 0xd3, 0x0e, 0xa0,
	0xf5, 0xde, 0xbb, 0x16, 0xed, 0x59, 0x7f, 0xb4, 0xbc, 0xb8, 0x52, 0xea, 0xc0, 0x65, 0xd1, 0x16,
	0x2e, 0x77, 0x95, 0x45, 0x67, 0x9a, 0xa5, 0x33, 0x3d, 0x70, 0xb0, 0x4c, 0xcf, 0x64, 0xb3, 0x90,
	0x52, 0x0c, 0xc3, 0x52, 0x15, 0xe2, 0xa7, 0xe2, 0x68, 0xaa, 0xdc, 0xa1, 0x54, 0xcd, 0x7f, 0x46,
	0x93, 0x25, 0x3b, 0x3e, 0x8b, 0xb6, 0xf7, 0x25, 0x75, 0x75, 0x82, 0xc5, 0x3e, 0x8a, 0x84, 0x3e,
	0x0b, 0x1f, 0x40, 0x3a, 0xf8, 0xaa, 0xb8, 0x14, 0xba, 0x18, 0xa7, 0xca, 0xfc, 0xd7, 0x71, 0xcc,
	0x76, 0x71, 0x54, 0xae, 0x51, 0x57, 0x7f, 0x81, 0x8a, 0x4d, 0x4a, 0x35, 0x22, 0x4b, 0x42, 0xfd,
	0x10, 0xe9, 0x62, 0x82, 0xd6, 0x3d, 0x7a, 0x6c, 0xe7, 0x0e, 0x89, 0x2f, 0xca, 0x84, 0xb7, 0x36,
	0x82, 0x61, 0xf0, 0x50, 0xde, 0x23, 0x44, 0x3e, 0x13, 0x15, 0xf9, 0xc0, 0xc4, 0xc5, 0xe3, 0x32,
	0x46, 0x63, 0x45, 0x46, 0x61, 0x74, 0x14, 0x52, 0xd1, 0x2d, 0x21, 0x09, 0x89, 0xda, 0xc2, 0xec,
	0xf2, 0x6a, 0xed, 0x6e, 0x36, 0x26, 0xa4, 0xa1, 0xff, 0xce, 0x4a, 0xf8, 0x8a, 0xaa, 0xf7, 0xd1,
	0xfe, 0x93, 0x5c, 0xec, 0xd1, 0x93, 0x5c, 0xec, 0xf9, 0x93, 0x1c, 0xda, 0x6d, 0xe7, 0xd0, 0x17,
	0xed, 0x1c, 0xfa, 0xae, 0x9d, 0x43, 0xfb, 0xed, 0x1c, 0x7a, 0xd4, 0xce, 0xa1, 0xc7, 0xed, 0x1c,
	0x7a, 0xd6, 0xce, 0xc5, 0x9e, 0xb7, 0x73, 0xe8, 0xb3, 0xa7, 0xb9, 0xd8, 0xde, 0xd3, 0x1c, 0x7a,
	0x6f, 0x79, 0xc3, 0xb2, 0x37, 0x37, 0xca, 0x4d, 0xcb, 0x20, 0xd8, 0x71, 0x94, 0xf2, 0xb6, 0x5b,
	0xa1, 0x0f, 0xeb, 0x96, 0xb3, 0x75, 0xcd, 0x76, 0xac, 0xa6, 0xae, 0x61, 0xe7, 0x5a, 0xb8, 0x5d,
	0xb1, 0xd7, 0x36, 0xac, 0x0a, 0xfe, 0x90, 0x04, 0xff, 0x0e, 0xf4, 0xfc, 0xfd, 0xb1, 0x16, 0xa7,
	0xbf, 0x42, 0x93, 0x7f, 0x04, 0x00, 0x00, 0xff, 0xff, 0x6d, 0xf1, 0x35, 0x3a, 0x1f, 0x11, 0x00,
	0x00,
}
