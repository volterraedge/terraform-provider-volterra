// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/log/public_customapi.proto

// Logs
//
// x-displayName: "Logs"
// Two types of logs are supported, viz, access logs and audit logs.
//   * Access logs are sampled records of API calls made to a virtual host. It contains
//     both the request and the response data with more context like application type,
//     user, request path, method, request body, response code, source,
//     destination, etc.,
//   * Audit logs provides audit of all configuration changes made in the system using
//     public APIs provided by Volterra. It contains both the request and response body
//     with additional context necessary for post-mortem analysis such as user, request path,
//     method, request body, response code, source, destination service, etc.,
// Both the access logs and audit logs are used to find "who did what and when and what was the result?"
// who - answered by user/user-agent in the log.
// what - answered by request url/method/body in the log.
// when - answered by timestamp in the log.
// result - answered by response code in the log.

package log

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	access_log "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/log/access_log"
	audit_log "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/log/audit_log"
	firewall_log "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/log/firewall_log"
	k8s_audit_log "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/log/k8s_audit_log"
	k8s_events "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/log/k8s_events"
	vk8s_audit_log "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/log/vk8s_audit_log"
	vk8s_events "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/log/vk8s_events"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/vesenv"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AccessLogRequestV2
//
// x-displayName: "Access Log Request V2"
// Request to fetch access logs.
type AccessLogRequestV2 struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// fetch access logs for a given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "{vh_name=\"productpage\"}"
	// query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//   One or more of following fields in access log may be specified in the query.
	//     app_type - application type
	//     vh_name - name of the virtual host
	//     src_site - source site
	//     src - source service
	//     src_instance - source instance
	//     dst_site - destination site
	//     dst - destination service
	//     dst_instance - destination instance
	//     method - request method
	//     req_path - request path
	//     rsp_code - response code
	//     browser_type - browser type
	//     city - name of the city
	//     country - country code
	//     device_type - device type
	// <value> := string
	// <operator> := ["="|"!="|"=~"|"!~"]
	//   = : equal to
	//   != : not equal to
	//   =~ : regex match
	//   !~ : not regex match
	// When more than one matcher is specified in the query, then access logs matching ALL the matchers will be returned in the response.
	// Example: query={src="service1", dst="service2"} will return all access logs with source service "service1" and the destination service "service2"
	//          query={vh_name="vh1", rsp_code=~"4.*"} will return all access logs for virtual-host "vh1" with response code 4xx
	//
	// Optional: If not specified, all the access logs matching the given tenant, namespace will be returned in the response
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// fetch access logs whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "2019-09-24T12:30:11.733Z"
	// fetch access logs whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// sort order
	//
	// x-displayName: "Sort Order"
	// specifies whether the response should be sorted in ascending or descending order based on timestamp in the log
	// Optional: default is descending order
	Sort schema.SortOrder `protobuf:"varint,5,opt,name=sort,proto3,enum=ves.io.schema.SortOrder" json:"sort,omitempty"`
	// limit
	//
	// x-displayName: "Limit"
	// x-example: "0"
	// limits the number of logs returned in the response
	// Optional: If not specified, first or last 500 log messages that matches the query (depending on the sort order) will be returned in the response.
	//           The maximum value for limit is 500.
	Limit int32 `protobuf:"varint,6,opt,name=limit,proto3" json:"limit,omitempty"`
	// scroll
	//
	// x-displayName: "Scroll"
	// x-example: "true"
	// Scroll is used to retrieve large number of log messages (or all log messages) that matches the query.
	// If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next
	// batch of logs until there are no more logs left to return. The number of messages in each batch is determined
	// by the limit field.
	// Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.
	// Optional: default is false
	Scroll bool `protobuf:"varint,7,opt,name=scroll,proto3" json:"scroll,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*access_log.AggregationRequest `protobuf:"bytes,9,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AccessLogRequestV2) Reset()      { *m = AccessLogRequestV2{} }
func (*AccessLogRequestV2) ProtoMessage() {}
func (*AccessLogRequestV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb43ed5d81aff514, []int{0}
}
func (m *AccessLogRequestV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessLogRequestV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessLogRequestV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessLogRequestV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessLogRequestV2.Merge(m, src)
}
func (m *AccessLogRequestV2) XXX_Size() int {
	return m.Size()
}
func (m *AccessLogRequestV2) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessLogRequestV2.DiscardUnknown(m)
}

var xxx_messageInfo_AccessLogRequestV2 proto.InternalMessageInfo

func (m *AccessLogRequestV2) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *AccessLogRequestV2) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *AccessLogRequestV2) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *AccessLogRequestV2) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *AccessLogRequestV2) GetSort() schema.SortOrder {
	if m != nil {
		return m.Sort
	}
	return schema.DESCENDING
}

func (m *AccessLogRequestV2) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *AccessLogRequestV2) GetScroll() bool {
	if m != nil {
		return m.Scroll
	}
	return false
}

func (m *AccessLogRequestV2) GetAggs() map[string]*access_log.AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// AccessLogAggregationRequest
//
// x-displayName: "Access Log Aggregation Request"
// Request to get only aggregation data for access logs
type AccessLogAggregationRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// get aggregation data for a given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "{vh_name=\"productpage\"}"
	// query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//   One or more of following fields in access log may be specified in the query.
	//     app_type - application type
	//     vh_name - name of the virtual host
	//     src_site - source site
	//     src - source service
	//     src_instance - source instance
	//     dst_site - destination site
	//     dst - destination service
	//     dst_instance - destination instance
	//     method - request method
	//     req_path - request path
	//     rsp_code - response code
	//     browser_type - browser type
	//     city - name of the city
	//     country - country code
	//     device_type - device type
	// <value> := string
	// <operator> := ["="|"!="]
	//   = : equal to
	//   != : not equal to
	// When more than one matcher is specified in the query, then access logs matching ALL the matchers will be considered for aggregation.
	// Example: query={src="service1", dst="service2"} will consider all access logs with source service "service1" and the destination service "service2"
	//
	// Optional: If not specified, all the access logs matching the given tenant, namespace will be considered for aggregation
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// fetch access logs whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "2019-09-24T12:30:11.733Z"
	// fetch access logs whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*access_log.AggregationRequest `protobuf:"bytes,6,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AccessLogAggregationRequest) Reset()      { *m = AccessLogAggregationRequest{} }
func (*AccessLogAggregationRequest) ProtoMessage() {}
func (*AccessLogAggregationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb43ed5d81aff514, []int{1}
}
func (m *AccessLogAggregationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessLogAggregationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessLogAggregationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessLogAggregationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessLogAggregationRequest.Merge(m, src)
}
func (m *AccessLogAggregationRequest) XXX_Size() int {
	return m.Size()
}
func (m *AccessLogAggregationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessLogAggregationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AccessLogAggregationRequest proto.InternalMessageInfo

func (m *AccessLogAggregationRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *AccessLogAggregationRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *AccessLogAggregationRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *AccessLogAggregationRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *AccessLogAggregationRequest) GetAggs() map[string]*access_log.AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// AuditLogRequestV2
//
// x-displayName: "Audit Log Request V2"
// Request to fetch audit logs
type AuditLogRequestV2 struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// fetch audit logs for a given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "{user=\"abc\", rsp_code=\"404\"}"
	// query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//  One or more of the following fields in audit log may be specified in the query.
	//   user - user name
	//   src_site - source site
	//   src - source service
	//   src_instance - source instance
	//   dst_site - destination site
	//   dst - destination service
	//   dst_instance - destination instance
	//   method - request method
	//   req_path - request URL
	//   rsp_code - response code
	// <value> := string
	// <operator> := ["="|"!="|"=~"|"!~"]
	//   = : equal to
	//   != : not equal to
	//   =~ : regex match
	//   !~ : not regex match
	// When more than one matcher is specified in the query, then audit logs matching ALL the matchers will be returned in the response.
	// Example: query={req_path="/public/namespaces/system/registrations"} will return all audit logs with req_path equals /public/namespaces/system/registrations
	//
	// Optional: If not specified, all the audit logs matching the given tenant and namespace are returned
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// fetch audit logs whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "2019-09-24T12:30:11.733Z"
	// fetch audit logs whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// sort order
	//
	// x-displayName: "Sort Order"
	// specifies whether the response should be sorted in ascending or descending order based on timestamp in the log
	// Optional: default is descending order
	Sort schema.SortOrder `protobuf:"varint,5,opt,name=sort,proto3,enum=ves.io.schema.SortOrder" json:"sort,omitempty"`
	// limit
	//
	// x-displayName: "Limit"
	// x-example: "100"
	// limits the number of logs returned in the response
	// Optional: If not specified, first or last 500 log messages that matches the query (depending on the sort order) will be returned in the response.
	//           The maximum value for limit is 500.
	Limit int32 `protobuf:"varint,6,opt,name=limit,proto3" json:"limit,omitempty"`
	// scroll
	//
	// x-displayName: "Scroll"
	// x-example: "true"
	// Scroll is used to retrieve large number of log messages (or all log messages) that matches the query.
	// If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next
	// batch of logs until there are no more logs left to return. The number of messages in each batch is determined
	// by the limit field.
	// Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.
	// Optional: default is false
	Scroll bool `protobuf:"varint,7,opt,name=scroll,proto3" json:"scroll,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*audit_log.AggregationRequest `protobuf:"bytes,9,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AuditLogRequestV2) Reset()      { *m = AuditLogRequestV2{} }
func (*AuditLogRequestV2) ProtoMessage() {}
func (*AuditLogRequestV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb43ed5d81aff514, []int{2}
}
func (m *AuditLogRequestV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuditLogRequestV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuditLogRequestV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuditLogRequestV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuditLogRequestV2.Merge(m, src)
}
func (m *AuditLogRequestV2) XXX_Size() int {
	return m.Size()
}
func (m *AuditLogRequestV2) XXX_DiscardUnknown() {
	xxx_messageInfo_AuditLogRequestV2.DiscardUnknown(m)
}

var xxx_messageInfo_AuditLogRequestV2 proto.InternalMessageInfo

func (m *AuditLogRequestV2) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *AuditLogRequestV2) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *AuditLogRequestV2) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *AuditLogRequestV2) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *AuditLogRequestV2) GetSort() schema.SortOrder {
	if m != nil {
		return m.Sort
	}
	return schema.DESCENDING
}

func (m *AuditLogRequestV2) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *AuditLogRequestV2) GetScroll() bool {
	if m != nil {
		return m.Scroll
	}
	return false
}

func (m *AuditLogRequestV2) GetAggs() map[string]*audit_log.AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// AuditLogAggregationRequest
//
// x-displayName: "Audit Log Aggregation Request"
// Request to get only aggregation data for audit logs
type AuditLogAggregationRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// get aggregation data for a given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "{user=\"abc\", rsp_code=\"404\"}"
	// query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//  One or more of the following fields in audit log may be specified in the query.
	//   user - user name
	//   src_site - source site
	//   src - source service
	//   src_instance - source instance
	//   dst_site - destination site
	//   dst - destination service
	//   dst_instance - destination instance
	//   method - request method
	//   req_path - request URL
	//   rsp_code - response code
	// <value> := string
	// <operator> := ["="|"!="]
	//   = : equal to
	//   != : not equal to
	// When more than one matcher is specified in the query, then audit logs matching ALL the matchers will be returned in the response.
	// Example: query={req_path="/public/namespaces/system/registrations"} will return all audit logs with req_path equals /public/namespaces/system/registrations
	//
	// Optional: If not specified, all the audit logs matching the given tenant and namespace will be considered for aggregation
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// fetch audit logs whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "2019-09-24T12:30:11.733Z"
	// fetch audit logs whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*audit_log.AggregationRequest `protobuf:"bytes,9,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AuditLogAggregationRequest) Reset()      { *m = AuditLogAggregationRequest{} }
func (*AuditLogAggregationRequest) ProtoMessage() {}
func (*AuditLogAggregationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb43ed5d81aff514, []int{3}
}
func (m *AuditLogAggregationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuditLogAggregationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuditLogAggregationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuditLogAggregationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuditLogAggregationRequest.Merge(m, src)
}
func (m *AuditLogAggregationRequest) XXX_Size() int {
	return m.Size()
}
func (m *AuditLogAggregationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AuditLogAggregationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AuditLogAggregationRequest proto.InternalMessageInfo

func (m *AuditLogAggregationRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *AuditLogAggregationRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *AuditLogAggregationRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *AuditLogAggregationRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *AuditLogAggregationRequest) GetAggs() map[string]*audit_log.AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// VK8SAuditLogRequest
//
// x-displayName: "vK8s Audit Log Request"
// Request to fetch Virtual K8s audit logs
type VK8SAuditLogRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// fetch vK8s audit logs for a given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "query={objectRef.resource="deployments"}"
	// query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//  One or more of the following fields in audit log may be specified in the query.
	//   user.username - user name
	//   sourceIPs - source ip
	//   verb - method
	//   objectRef.resource - K8s resource
	//   requestURI - request URI
	// <value> := string
	// <operator> := ["="|"!="|"=~"|"!~"]
	//   = : equal to
	//   != : not equal to
	//   =~ : regex match
	//   !~ : not regex match
	// When more than one matcher is specified in the query, then audit logs matching ALL the matchers will be returned in the response.
	// Example: query={objectRef.resource="deployments"} will return all vK8s audit logs for all deployment objects in the given namespace
	//
	// Optional: If not specified, all the audit logs matching the given tenant and namespace are returned
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// fetch audit logs whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "2019-09-24T12:30:11.733Z"
	// fetch audit logs whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// sort order
	//
	// x-displayName: "Sort Order"
	// specifies whether the response should be sorted in ascending or descending order based on timestamp in the log
	// Optional: default is descending order
	Sort schema.SortOrder `protobuf:"varint,5,opt,name=sort,proto3,enum=ves.io.schema.SortOrder" json:"sort,omitempty"`
	// limit
	//
	// x-displayName: "Limit"
	// x-example: "100"
	// limits the number of logs returned in the response
	// Optional: If not specified, first or last 500 log messages that matches the query (depending on the sort order) will be returned in the response.
	//           The maximum value for limit is 500.
	Limit int32 `protobuf:"varint,6,opt,name=limit,proto3" json:"limit,omitempty"`
	// scroll
	//
	// x-displayName: "Scroll"
	// x-example: "true"
	// Scroll is used to retrieve large number of log messages (or all log messages) that matches the query.
	// If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next
	// batch of logs until there are no more logs left to return. The number of messages in each batch is determined
	// by the limit field.
	// Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.
	// Optional: default is false
	Scroll bool `protobuf:"varint,7,opt,name=scroll,proto3" json:"scroll,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*vk8s_audit_log.AggregationRequest `protobuf:"bytes,8,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *VK8SAuditLogRequest) Reset()      { *m = VK8SAuditLogRequest{} }
func (*VK8SAuditLogRequest) ProtoMessage() {}
func (*VK8SAuditLogRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb43ed5d81aff514, []int{4}
}
func (m *VK8SAuditLogRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VK8SAuditLogRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VK8SAuditLogRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VK8SAuditLogRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VK8SAuditLogRequest.Merge(m, src)
}
func (m *VK8SAuditLogRequest) XXX_Size() int {
	return m.Size()
}
func (m *VK8SAuditLogRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VK8SAuditLogRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VK8SAuditLogRequest proto.InternalMessageInfo

func (m *VK8SAuditLogRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *VK8SAuditLogRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *VK8SAuditLogRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *VK8SAuditLogRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *VK8SAuditLogRequest) GetSort() schema.SortOrder {
	if m != nil {
		return m.Sort
	}
	return schema.DESCENDING
}

func (m *VK8SAuditLogRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *VK8SAuditLogRequest) GetScroll() bool {
	if m != nil {
		return m.Scroll
	}
	return false
}

func (m *VK8SAuditLogRequest) GetAggs() map[string]*vk8s_audit_log.AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// VK8SAuditLogAggregationRequest
//
// x-displayName: "vK8s Audit Log Aggregation Request"
// Request to get only aggregation data for vK8s audit logs
type VK8SAuditLogAggregationRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// get aggregation data for a given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "query={objectRef.resource="deployments"}"
	// query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//  One or more of the following fields in audit log may be specified in the query.
	//   user.username - user name
	//   sourceIPs - source ip
	//   verb - method
	//   objectRef.resource - K8s resource
	//   requestURI - request URI
	// <value> := string
	// <operator> := ["="|"!="]
	//   = : equal to
	//   != : not equal to
	// When more than one matcher is specified in the query, then audit logs matching ALL the matchers will be returned in the response.
	// Example: query={objectRef.resource="deployments"} will return all vK8s audit logs for all deployment objects in the given namespace
	//
	// Optional: If not specified, all the audit logs matching the given tenant and namespace will be considered for aggregation
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// fetch audit logs whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "2019-09-24T12:30:11.733Z"
	// fetch audit logs whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*vk8s_audit_log.AggregationRequest `protobuf:"bytes,5,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *VK8SAuditLogAggregationRequest) Reset()      { *m = VK8SAuditLogAggregationRequest{} }
func (*VK8SAuditLogAggregationRequest) ProtoMessage() {}
func (*VK8SAuditLogAggregationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb43ed5d81aff514, []int{5}
}
func (m *VK8SAuditLogAggregationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VK8SAuditLogAggregationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VK8SAuditLogAggregationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VK8SAuditLogAggregationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VK8SAuditLogAggregationRequest.Merge(m, src)
}
func (m *VK8SAuditLogAggregationRequest) XXX_Size() int {
	return m.Size()
}
func (m *VK8SAuditLogAggregationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VK8SAuditLogAggregationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VK8SAuditLogAggregationRequest proto.InternalMessageInfo

func (m *VK8SAuditLogAggregationRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *VK8SAuditLogAggregationRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *VK8SAuditLogAggregationRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *VK8SAuditLogAggregationRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *VK8SAuditLogAggregationRequest) GetAggs() map[string]*vk8s_audit_log.AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// K8SAuditLogRequest
//
// x-displayName: "K8s Audit Log Request"
// Request to fetch K8s audit logs
type K8SAuditLogRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// fetch K8s audit logs for a given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// site
	//
	// x-displayName: "Site"
	// x-example: "ce-1"
	// Site where the K8s Cluster is running
	Site string `protobuf:"bytes,2,opt,name=site,proto3" json:"site,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "query={objectRef.resource="deployments"}"
	// query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//  One or more of the following fields in audit log may be specified in the query.
	//   user.username - user name
	//   sourceIPs - source ip
	//   verb - method
	//   objectRef.resource - K8s resource
	//   requestURI - request URI
	// <value> := string
	// <operator> := ["="|"!="|"=~"|"!~"]
	//   = : equal to
	//   != : not equal to
	//   =~ : regex match
	//   !~ : not regex match
	// When more than one matcher is specified in the query, then audit logs matching ALL the matchers will be returned in the response.
	// Example: query={objectRef.resource="deployments"} will return all K8s audit logs for all deployment objects in the given namespace
	//
	// Optional: If not specified, all the audit logs matching the given tenant and namespace are returned
	Query string `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// fetch audit logs whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "2019-09-24T12:30:11.733Z"
	// fetch audit logs whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,5,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// sort order
	//
	// x-displayName: "Sort Order"
	// specifies whether the response should be sorted in ascending or descending order based on timestamp in the log
	// Optional: default is descending order
	Sort schema.SortOrder `protobuf:"varint,6,opt,name=sort,proto3,enum=ves.io.schema.SortOrder" json:"sort,omitempty"`
	// limit
	//
	// x-displayName: "Limit"
	// x-example: "100"
	// limits the number of logs returned in the response
	// Optional: If not specified, first or last 500 log messages that matches the query (depending on the sort order) will be returned in the response.
	//           The maximum value for limit is 500.
	Limit int32 `protobuf:"varint,7,opt,name=limit,proto3" json:"limit,omitempty"`
	// scroll
	//
	// x-displayName: "Scroll"
	// x-example: "true"
	// Scroll is used to retrieve large number of log messages (or all log messages) that matches the query.
	// If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next
	// batch of logs until there are no more logs left to return. The number of messages in each batch is determined
	// by the limit field.
	// Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.
	// Optional: default is false
	Scroll bool `protobuf:"varint,8,opt,name=scroll,proto3" json:"scroll,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*k8s_audit_log.AggregationRequest `protobuf:"bytes,9,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *K8SAuditLogRequest) Reset()      { *m = K8SAuditLogRequest{} }
func (*K8SAuditLogRequest) ProtoMessage() {}
func (*K8SAuditLogRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb43ed5d81aff514, []int{6}
}
func (m *K8SAuditLogRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SAuditLogRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_K8SAuditLogRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *K8SAuditLogRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SAuditLogRequest.Merge(m, src)
}
func (m *K8SAuditLogRequest) XXX_Size() int {
	return m.Size()
}
func (m *K8SAuditLogRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SAuditLogRequest.DiscardUnknown(m)
}

var xxx_messageInfo_K8SAuditLogRequest proto.InternalMessageInfo

func (m *K8SAuditLogRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *K8SAuditLogRequest) GetSite() string {
	if m != nil {
		return m.Site
	}
	return ""
}

func (m *K8SAuditLogRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *K8SAuditLogRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *K8SAuditLogRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *K8SAuditLogRequest) GetSort() schema.SortOrder {
	if m != nil {
		return m.Sort
	}
	return schema.DESCENDING
}

func (m *K8SAuditLogRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *K8SAuditLogRequest) GetScroll() bool {
	if m != nil {
		return m.Scroll
	}
	return false
}

func (m *K8SAuditLogRequest) GetAggs() map[string]*k8s_audit_log.AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// K8SAuditLogAggregationRequest
//
// x-displayName: "K8s Audit Log Aggregation Request"
// Request to get only aggregation data for K8s audit logs
type K8SAuditLogAggregationRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// get aggregation data for a given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// site
	//
	// x-displayName: "Site"
	// x-example: "ce-1"
	// Site where the K8s Cluster is running
	Site string `protobuf:"bytes,2,opt,name=site,proto3" json:"site,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "query={objectRef.resource="deployments"}"
	// query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//  One or more of the following fields in audit log may be specified in the query.
	//   user.username - user name
	//   sourceIPs - source ip
	//   verb - method
	//   objectRef.resource - K8s resource
	//   requestURI - request URI
	// <value> := string
	// <operator> := ["="|"!="]
	//   = : equal to
	//   != : not equal to
	// When more than one matcher is specified in the query, then audit logs matching ALL the matchers will be returned in the response.
	// Example: query={objectRef.resource="deployments"} will return all K8s audit logs for all deployment objects in the given namespace
	//
	// Optional: If not specified, all the audit logs matching the given tenant and namespace will be considered for aggregation
	Query string `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// fetch audit logs whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "2019-09-24T12:30:11.733Z"
	// fetch audit logs whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,5,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*k8s_audit_log.AggregationRequest `protobuf:"bytes,6,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *K8SAuditLogAggregationRequest) Reset()      { *m = K8SAuditLogAggregationRequest{} }
func (*K8SAuditLogAggregationRequest) ProtoMessage() {}
func (*K8SAuditLogAggregationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb43ed5d81aff514, []int{7}
}
func (m *K8SAuditLogAggregationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SAuditLogAggregationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_K8SAuditLogAggregationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *K8SAuditLogAggregationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SAuditLogAggregationRequest.Merge(m, src)
}
func (m *K8SAuditLogAggregationRequest) XXX_Size() int {
	return m.Size()
}
func (m *K8SAuditLogAggregationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SAuditLogAggregationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_K8SAuditLogAggregationRequest proto.InternalMessageInfo

func (m *K8SAuditLogAggregationRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *K8SAuditLogAggregationRequest) GetSite() string {
	if m != nil {
		return m.Site
	}
	return ""
}

func (m *K8SAuditLogAggregationRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *K8SAuditLogAggregationRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *K8SAuditLogAggregationRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *K8SAuditLogAggregationRequest) GetAggs() map[string]*k8s_audit_log.AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// vK8s Events Request
//
// x-displayName: "vK8s Events Request"
// Request to fetch Virtual K8s events
type VK8SEventsRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// fetch vK8s events for the given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "query={involvedObject.kind="Pod"}"
	// query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//  One or more of the following fields in the event may be specified in the query.
	//   involvedObject.kind - The object that this event is about, like Pod, Deployment, Node, etc.
	//   involvedObject.name - Name of the object
	//   type - Type of event such as Warning or Normal
	//   reason - A one-word description for an event. For example Pending, Running, Succeeded, Failed are some of values for reason that indicate the phase of a Pod lifecycle.
	//   source.component - The K8s component reporting the event such as kubelet, kube-scheduler, etc.,
	//   site - Name of the site
	// <value> := string
	// <operator> := ["="|"!="|"=~"|"!~"]
	//   = : equal to
	//   != : not equal to
	//   =~ : regex match
	//   !~ : not regex match
	//
	// Optional: If not specified, all the vK8s events for the given tenant and namespace are returned
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// fetch vK8s events whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "2019-09-24T12:30:11.733Z"
	// fetch vK8s events whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// sort order
	//
	// x-displayName: "Sort Order"
	// specifies whether the response should be sorted in ascending or descending order based on timestamp in the event
	// Optional: default is descending order
	Sort schema.SortOrder `protobuf:"varint,5,opt,name=sort,proto3,enum=ves.io.schema.SortOrder" json:"sort,omitempty"`
	// limit
	//
	// x-displayName: "Limit"
	// x-example: "100"
	// limits the number of vK8s events returned in the response
	// Optional: If not specified, first or last 500 events that matches the query (depending on the sort order) will be returned in the response.
	//           The maximum value for limit is 500.
	Limit int32 `protobuf:"varint,6,opt,name=limit,proto3" json:"limit,omitempty"`
	// scroll
	//
	// x-displayName: "Scroll"
	// x-example: "true"
	// Scroll is used to retrieve large number of events (or all events) that matches the query.
	// If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next
	// batch of events until there are no more events left to return. The number of events in each batch is determined
	// by the limit field.
	// Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.
	// Optional: default is false
	Scroll bool `protobuf:"varint,7,opt,name=scroll,proto3" json:"scroll,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the events response. If the number of events that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*vk8s_events.AggregationRequest `protobuf:"bytes,8,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *VK8SEventsRequest) Reset()      { *m = VK8SEventsRequest{} }
func (*VK8SEventsRequest) ProtoMessage() {}
func (*VK8SEventsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb43ed5d81aff514, []int{8}
}
func (m *VK8SEventsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VK8SEventsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VK8SEventsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VK8SEventsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VK8SEventsRequest.Merge(m, src)
}
func (m *VK8SEventsRequest) XXX_Size() int {
	return m.Size()
}
func (m *VK8SEventsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VK8SEventsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VK8SEventsRequest proto.InternalMessageInfo

func (m *VK8SEventsRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *VK8SEventsRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *VK8SEventsRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *VK8SEventsRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *VK8SEventsRequest) GetSort() schema.SortOrder {
	if m != nil {
		return m.Sort
	}
	return schema.DESCENDING
}

func (m *VK8SEventsRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *VK8SEventsRequest) GetScroll() bool {
	if m != nil {
		return m.Scroll
	}
	return false
}

func (m *VK8SEventsRequest) GetAggs() map[string]*vk8s_events.AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// vK8s Events Aggregation Request
//
// x-displayName: "Virtual K8s Events Aggregation Request"
// Request to get only aggregation data for vK8s events
type VK8SEventsAggregationRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// get aggregation data for a given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "query={involvedObject.kind="Pod"}"
	// query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//  One or more of the following fields in the event may be specified in the query.
	//   involvedObject.kind - The object that this event is about, like Pod, Deployment, Node, etc.
	//   involvedObject.name - Name of the object
	//   type - Type of event such as Warning or Normal
	//   reason - A one-word description for an event. For example Pending, Running, Succeeded, Failed are some of values for reason that indicate the phase of a Pod lifecycle.
	//   source.component - The K8s component reporting the event such as kubelet, kube-scheduler, etc.,
	// <value> := string
	// <operator> := ["="|"!="|"=~"|"!~"]
	//   = : equal to
	//   != : not equal to
	//   =~ : regex match
	//   !~ : not regex match
	//
	// Optional: If not specified, all the vK8s events for the given tenant and namespace are returned
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// fetch vK8s events whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "2019-09-24T12:30:11.733Z"
	// fetch vK8s events whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the events response. If the number of events that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*vk8s_events.AggregationRequest `protobuf:"bytes,5,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *VK8SEventsAggregationRequest) Reset()      { *m = VK8SEventsAggregationRequest{} }
func (*VK8SEventsAggregationRequest) ProtoMessage() {}
func (*VK8SEventsAggregationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb43ed5d81aff514, []int{9}
}
func (m *VK8SEventsAggregationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VK8SEventsAggregationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VK8SEventsAggregationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VK8SEventsAggregationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VK8SEventsAggregationRequest.Merge(m, src)
}
func (m *VK8SEventsAggregationRequest) XXX_Size() int {
	return m.Size()
}
func (m *VK8SEventsAggregationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VK8SEventsAggregationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VK8SEventsAggregationRequest proto.InternalMessageInfo

func (m *VK8SEventsAggregationRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *VK8SEventsAggregationRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *VK8SEventsAggregationRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *VK8SEventsAggregationRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *VK8SEventsAggregationRequest) GetAggs() map[string]*vk8s_events.AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// K8s Events Request
//
// x-displayName: "K8s Events Request"
// Request to fetch physical K8s events
type K8SEventsRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// fetch K8s events for the given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// site
	//
	// x-displayName: "Site"
	// x-example: "ce-1"
	// Site where the K8s Cluster is running
	Site string `protobuf:"bytes,2,opt,name=site,proto3" json:"site,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "query={involvedObject.kind="Pod"}"
	// query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//  One or more of the following fields in the event may be specified in the query.
	//   involvedObject.kind - The object that this event is about, like Pod, Deployment, Node, etc.
	//   involvedObject.name - Name of the object
	//   type - Type of event such as Warning or Normal
	//   reason - A one-word description for an event. For example Pending, Running, Succeeded, Failed are some of values for reason that indicate the phase of a Pod lifecycle.
	//   source.component - The K8s component reporting the event such as kubelet, kube-scheduler, etc.,
	//   site - Name of the site
	// <value> := string
	// <operator> := ["="|"!="|"=~"|"!~"]
	//   = : equal to
	//   != : not equal to
	//   =~ : regex match
	//   !~ : not regex match
	//
	// Optional: If not specified, all the K8s events for the given tenant and namespace are returned
	Query string `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// fetch vK8s events whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "2019-09-24T12:30:11.733Z"
	// fetch vK8s events whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,5,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// sort order
	//
	// x-displayName: "Sort Order"
	// specifies whether the response should be sorted in ascending or descending order based on timestamp in the event
	// Optional: default is descending order
	Sort schema.SortOrder `protobuf:"varint,6,opt,name=sort,proto3,enum=ves.io.schema.SortOrder" json:"sort,omitempty"`
	// limit
	//
	// x-displayName: "Limit"
	// x-example: "100"
	// limits the number of K8s events returned in the response
	// Optional: If not specified, first or last 500 events that matches the query (depending on the sort order) will be returned in the response.
	//           The maximum value for limit is 500.
	Limit int32 `protobuf:"varint,7,opt,name=limit,proto3" json:"limit,omitempty"`
	// scroll
	//
	// x-displayName: "Scroll"
	// x-example: "true"
	// Scroll is used to retrieve large number of events (or all events) that matches the query.
	// If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next
	// batch of events until there are no more events left to return. The number of events in each batch is determined
	// by the limit field.
	// Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.
	// Optional: default is false
	Scroll bool `protobuf:"varint,8,opt,name=scroll,proto3" json:"scroll,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the events response. If the number of events that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*k8s_events.AggregationRequest `protobuf:"bytes,9,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *K8SEventsRequest) Reset()      { *m = K8SEventsRequest{} }
func (*K8SEventsRequest) ProtoMessage() {}
func (*K8SEventsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb43ed5d81aff514, []int{10}
}
func (m *K8SEventsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SEventsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_K8SEventsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *K8SEventsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SEventsRequest.Merge(m, src)
}
func (m *K8SEventsRequest) XXX_Size() int {
	return m.Size()
}
func (m *K8SEventsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SEventsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_K8SEventsRequest proto.InternalMessageInfo

func (m *K8SEventsRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *K8SEventsRequest) GetSite() string {
	if m != nil {
		return m.Site
	}
	return ""
}

func (m *K8SEventsRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *K8SEventsRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *K8SEventsRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *K8SEventsRequest) GetSort() schema.SortOrder {
	if m != nil {
		return m.Sort
	}
	return schema.DESCENDING
}

func (m *K8SEventsRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *K8SEventsRequest) GetScroll() bool {
	if m != nil {
		return m.Scroll
	}
	return false
}

func (m *K8SEventsRequest) GetAggs() map[string]*k8s_events.AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// K8s Events Aggregation Request
//
// x-displayName: "K8s Events Aggregation Request"
// Request to get only aggregation data for K8s events in a Cluster
type K8SEventsAggregationRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// get aggregation data for a given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// site
	//
	// x-displayName: "Site"
	// x-example: "ce-1"
	// Site where the K8s Cluster is running
	Site string `protobuf:"bytes,2,opt,name=site,proto3" json:"site,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "query={involvedObject.kind="Pod"}"
	// query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//  One or more of the following fields in the event may be specified in the query.
	//   involvedObject.kind - The object that this event is about, like Pod, Deployment, Node, etc.
	//   involvedObject.name - Name of the object
	//   type - Type of event such as Warning or Normal
	//   reason - A one-word description for an event. For example Pending, Running, Succeeded, Failed are some of values for reason that indicate the phase of a Pod lifecycle.
	//   source.component - The K8s component reporting the event such as kubelet, kube-scheduler, etc.,
	// <value> := string
	// <operator> := ["="|"!="|"=~"|"!~"]
	//   = : equal to
	//   != : not equal to
	//   =~ : regex match
	//   !~ : not regex match
	//
	// Optional: If not specified, all the K8s events for the given tenant and namespace are returned
	Query string `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// fetch vK8s events whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "2019-09-24T12:30:11.733Z"
	// fetch vK8s events whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,5,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the events response. If the number of events that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*k8s_events.AggregationRequest `protobuf:"bytes,6,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *K8SEventsAggregationRequest) Reset()      { *m = K8SEventsAggregationRequest{} }
func (*K8SEventsAggregationRequest) ProtoMessage() {}
func (*K8SEventsAggregationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb43ed5d81aff514, []int{11}
}
func (m *K8SEventsAggregationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SEventsAggregationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_K8SEventsAggregationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *K8SEventsAggregationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SEventsAggregationRequest.Merge(m, src)
}
func (m *K8SEventsAggregationRequest) XXX_Size() int {
	return m.Size()
}
func (m *K8SEventsAggregationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SEventsAggregationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_K8SEventsAggregationRequest proto.InternalMessageInfo

func (m *K8SEventsAggregationRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *K8SEventsAggregationRequest) GetSite() string {
	if m != nil {
		return m.Site
	}
	return ""
}

func (m *K8SEventsAggregationRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *K8SEventsAggregationRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *K8SEventsAggregationRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *K8SEventsAggregationRequest) GetAggs() map[string]*k8s_events.AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// FirewallLogRequest
//
// x-displayName: "Firewall Log Request"
// Request to fetch Firewall logs.
type FirewallLogRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// fetch Firewall logs for a given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "{site=\"site-1\"}"
	// query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//   One or more of following fields in Firewall log may be specified in the query.
	//     site - Name of the site
	//     src_ip - Source IP Address
	//     dst_ip - Destination IP Address
	//     policy_hits.policy - Policy Name
	//     policy_hits.policy_rule - Policy Rule Name
	//     policy_hits.result - allow|deny|default_deny
	// <value> := string
	// <operator> := ["="|"!="|"=~"|"!~"]
	//   = : equal to
	//   != : not equal to
	//   =~ : regex match
	//   !~ : not regex match
	// When more than one matcher is specified in the query, then Firewall logs matching ALL the matchers will be returned in the response.
	//
	// Optional: If not specified, all the Firewall logs matching the given tenant, namespace will be returned in the response
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// fetch Firewall logs whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "2019-09-24T12:30:11.733Z"
	// fetch Firewall logs whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// sort order
	//
	// x-displayName: "Sort Order"
	// specifies whether the response should be sorted in ascending or descending order based on timestamp in the log
	// Optional: default is descending order
	Sort schema.SortOrder `protobuf:"varint,5,opt,name=sort,proto3,enum=ves.io.schema.SortOrder" json:"sort,omitempty"`
	// limit
	//
	// x-displayName: "Limit"
	// x-example: "0"
	// limits the number of logs returned in the response
	// Optional: If not specified, first or last 500 log messages that matches the query (depending on the sort order) will be returned in the response.
	//           The maximum value for limit is 500.
	Limit int32 `protobuf:"varint,6,opt,name=limit,proto3" json:"limit,omitempty"`
	// scroll
	//
	// x-displayName: "Scroll"
	// x-example: "true"
	// Scroll is used to retrieve large number of log messages (or all log messages) that matches the query.
	// If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next
	// batch of logs until there are no more logs left to return. The number of messages in each batch is determined
	// by the limit field.
	// Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.
	// Optional: default is false
	Scroll bool `protobuf:"varint,7,opt,name=scroll,proto3" json:"scroll,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*firewall_log.AggregationRequest `protobuf:"bytes,9,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FirewallLogRequest) Reset()      { *m = FirewallLogRequest{} }
func (*FirewallLogRequest) ProtoMessage() {}
func (*FirewallLogRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb43ed5d81aff514, []int{12}
}
func (m *FirewallLogRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirewallLogRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirewallLogRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FirewallLogRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirewallLogRequest.Merge(m, src)
}
func (m *FirewallLogRequest) XXX_Size() int {
	return m.Size()
}
func (m *FirewallLogRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FirewallLogRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FirewallLogRequest proto.InternalMessageInfo

func (m *FirewallLogRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *FirewallLogRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *FirewallLogRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *FirewallLogRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *FirewallLogRequest) GetSort() schema.SortOrder {
	if m != nil {
		return m.Sort
	}
	return schema.DESCENDING
}

func (m *FirewallLogRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *FirewallLogRequest) GetScroll() bool {
	if m != nil {
		return m.Scroll
	}
	return false
}

func (m *FirewallLogRequest) GetAggs() map[string]*firewall_log.AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// FirewallLogAggregationRequest
//
// x-displayName: "Firewall Log Aggregation Request"
// Request to get only aggregation data for Firewall logs
type FirewallLogAggregationRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// get aggregation data for a given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "{site=\"site-1\"}"
	// query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//   One or more of following fields in Firewall log may be specified in the query.
	//     site - Name of the site
	//     src_ip - Source IP Address
	//     dst_ip - Destination IP Address
	//     policy_hits.policy - Policy Name
	//     policy_hits.policy_rule - Policy Rule Name
	//     policy_hits.result - allow|deny|default_deny
	// <value> := string
	// <operator> := ["="|"!="|"=~"|"!~"]
	//   = : equal to
	//   != : not equal to
	//   =~ : regex match
	//   !~ : not regex match
	// When more than one matcher is specified in the query, then Firewall logs matching ALL the matchers will be returned in the response.
	//
	// Optional: If not specified, all the Firewall logs matching the given tenant, namespace will be returned in the response
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// fetch Firewall logs whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "2019-09-24T12:30:11.733Z"
	// fetch Firewall logs whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*firewall_log.AggregationRequest `protobuf:"bytes,6,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FirewallLogAggregationRequest) Reset()      { *m = FirewallLogAggregationRequest{} }
func (*FirewallLogAggregationRequest) ProtoMessage() {}
func (*FirewallLogAggregationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb43ed5d81aff514, []int{13}
}
func (m *FirewallLogAggregationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirewallLogAggregationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirewallLogAggregationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FirewallLogAggregationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirewallLogAggregationRequest.Merge(m, src)
}
func (m *FirewallLogAggregationRequest) XXX_Size() int {
	return m.Size()
}
func (m *FirewallLogAggregationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FirewallLogAggregationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FirewallLogAggregationRequest proto.InternalMessageInfo

func (m *FirewallLogAggregationRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *FirewallLogAggregationRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *FirewallLogAggregationRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *FirewallLogAggregationRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *FirewallLogAggregationRequest) GetAggs() map[string]*firewall_log.AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// LogScrollRequest
//
// x-displayName: "Log Scroll Request"
// Scroll request is used to fetch large number of log messages in multiple batches with each LogResponse
// containing no more than 500 (max value for limit in the request) log messages. To scroll through more than 500 or
// all log messages, one can use the LogScrollRequest. Use the scroll_id returned in the LogResponse to fetch the next
// batch of log messages and one can continue this process till the scroll_id returned in the LogResponse is "" which
// indicates no more log messages to scroll.
type LogScrollRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// fetch the log messages scoped by namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// scroll id
	//
	// x-displayName: "Scroll ID"
	// x-example: "Vm9sdGVycmEgRWRnZSBQbGF0Zm9ybQ=="
	// Long Base-64 encoded string which can be used to retrieve next batch of log messages.
	ScrollId string `protobuf:"bytes,2,opt,name=scroll_id,json=scrollId,proto3" json:"scroll_id,omitempty"`
}

func (m *LogScrollRequest) Reset()      { *m = LogScrollRequest{} }
func (*LogScrollRequest) ProtoMessage() {}
func (*LogScrollRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb43ed5d81aff514, []int{14}
}
func (m *LogScrollRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogScrollRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogScrollRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogScrollRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogScrollRequest.Merge(m, src)
}
func (m *LogScrollRequest) XXX_Size() int {
	return m.Size()
}
func (m *LogScrollRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LogScrollRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LogScrollRequest proto.InternalMessageInfo

func (m *LogScrollRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *LogScrollRequest) GetScrollId() string {
	if m != nil {
		return m.ScrollId
	}
	return ""
}

// LogResponse
//
// x-displayName: "Log Response"
// Response message for AuditLogRequest/AccessLogRequest/LogScrollRequest
type LogResponse struct {
	// logs
	//
	// x-displayName: "Logs"
	// x-example: "value"
	// list of log messages that matched the query. Not all log messages that matched the query are returned in the response.
	Logs []string `protobuf:"bytes,1,rep,name=logs,proto3" json:"logs,omitempty"`
	// total hits
	//
	// x-displayName: "Total Hits"
	// x-example: "0"
	// total number of log messages that matched the query.
	TotalHits uint64 `protobuf:"varint,3,opt,name=total_hits,json=totalHits,proto3" json:"total_hits,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregation data is key'ed with the aggregation name specified in the request.
	Aggs map[string]*LogAggregationData `protobuf:"bytes,5,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// scroll id
	//
	// x-displayName: "Scroll ID"
	// x-example: "Vm9sdGVycmEgRWRnZSBQbGF0Zm9ybQ=="
	// Long Base-64 encoded string which can be used to retrieve next batch of log messages using the scroll request.
	// Empty scroll_id indicates no more messages to scroll (EOF).
	// Note: scroll_id is valid only for 2 minutes. i.e., If one intend to retrieve next batch of the result, then the
	//       scroll request should be sent within 2 minutes upon receiving the LogResponse.
	ScrollId string `protobuf:"bytes,2,opt,name=scroll_id,json=scrollId,proto3" json:"scroll_id,omitempty"`
}

func (m *LogResponse) Reset()      { *m = LogResponse{} }
func (*LogResponse) ProtoMessage() {}
func (*LogResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb43ed5d81aff514, []int{15}
}
func (m *LogResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogResponse.Merge(m, src)
}
func (m *LogResponse) XXX_Size() int {
	return m.Size()
}
func (m *LogResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LogResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LogResponse proto.InternalMessageInfo

func (m *LogResponse) GetLogs() []string {
	if m != nil {
		return m.Logs
	}
	return nil
}

func (m *LogResponse) GetTotalHits() uint64 {
	if m != nil {
		return m.TotalHits
	}
	return 0
}

func (m *LogResponse) GetAggs() map[string]*LogAggregationData {
	if m != nil {
		return m.Aggs
	}
	return nil
}

func (m *LogResponse) GetScrollId() string {
	if m != nil {
		return m.ScrollId
	}
	return ""
}

// LogAggregationResponse
//
// x-displayName: "Log Aggregation Response"
// Response message for AuditLogAggregationRequest/AccessLogAggregationRequest
type LogAggregationResponse struct {
	// total hits
	//
	// x-displayName: "Total Hits"
	// x-example: "0"
	// total number of log messages that matched the query.
	TotalHits uint64 `protobuf:"varint,1,opt,name=total_hits,json=totalHits,proto3" json:"total_hits,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregation data is key'ed with the aggregation name specified in the request.
	Aggs map[string]*LogAggregationData `protobuf:"bytes,3,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *LogAggregationResponse) Reset()      { *m = LogAggregationResponse{} }
func (*LogAggregationResponse) ProtoMessage() {}
func (*LogAggregationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb43ed5d81aff514, []int{16}
}
func (m *LogAggregationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogAggregationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogAggregationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogAggregationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogAggregationResponse.Merge(m, src)
}
func (m *LogAggregationResponse) XXX_Size() int {
	return m.Size()
}
func (m *LogAggregationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LogAggregationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LogAggregationResponse proto.InternalMessageInfo

func (m *LogAggregationResponse) GetTotalHits() uint64 {
	if m != nil {
		return m.TotalHits
	}
	return 0
}

func (m *LogAggregationResponse) GetAggs() map[string]*LogAggregationData {
	if m != nil {
		return m.Aggs
	}
	return nil
}

func init() {
	proto.RegisterType((*AccessLogRequestV2)(nil), "ves.io.schema.log.AccessLogRequestV2")
	golang_proto.RegisterType((*AccessLogRequestV2)(nil), "ves.io.schema.log.AccessLogRequestV2")
	proto.RegisterMapType((map[string]*access_log.AggregationRequest)(nil), "ves.io.schema.log.AccessLogRequestV2.AggsEntry")
	golang_proto.RegisterMapType((map[string]*access_log.AggregationRequest)(nil), "ves.io.schema.log.AccessLogRequestV2.AggsEntry")
	proto.RegisterType((*AccessLogAggregationRequest)(nil), "ves.io.schema.log.AccessLogAggregationRequest")
	golang_proto.RegisterType((*AccessLogAggregationRequest)(nil), "ves.io.schema.log.AccessLogAggregationRequest")
	proto.RegisterMapType((map[string]*access_log.AggregationRequest)(nil), "ves.io.schema.log.AccessLogAggregationRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*access_log.AggregationRequest)(nil), "ves.io.schema.log.AccessLogAggregationRequest.AggsEntry")
	proto.RegisterType((*AuditLogRequestV2)(nil), "ves.io.schema.log.AuditLogRequestV2")
	golang_proto.RegisterType((*AuditLogRequestV2)(nil), "ves.io.schema.log.AuditLogRequestV2")
	proto.RegisterMapType((map[string]*audit_log.AggregationRequest)(nil), "ves.io.schema.log.AuditLogRequestV2.AggsEntry")
	golang_proto.RegisterMapType((map[string]*audit_log.AggregationRequest)(nil), "ves.io.schema.log.AuditLogRequestV2.AggsEntry")
	proto.RegisterType((*AuditLogAggregationRequest)(nil), "ves.io.schema.log.AuditLogAggregationRequest")
	golang_proto.RegisterType((*AuditLogAggregationRequest)(nil), "ves.io.schema.log.AuditLogAggregationRequest")
	proto.RegisterMapType((map[string]*audit_log.AggregationRequest)(nil), "ves.io.schema.log.AuditLogAggregationRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*audit_log.AggregationRequest)(nil), "ves.io.schema.log.AuditLogAggregationRequest.AggsEntry")
	proto.RegisterType((*VK8SAuditLogRequest)(nil), "ves.io.schema.log.VK8SAuditLogRequest")
	golang_proto.RegisterType((*VK8SAuditLogRequest)(nil), "ves.io.schema.log.VK8SAuditLogRequest")
	proto.RegisterMapType((map[string]*vk8s_audit_log.AggregationRequest)(nil), "ves.io.schema.log.VK8SAuditLogRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*vk8s_audit_log.AggregationRequest)(nil), "ves.io.schema.log.VK8SAuditLogRequest.AggsEntry")
	proto.RegisterType((*VK8SAuditLogAggregationRequest)(nil), "ves.io.schema.log.VK8SAuditLogAggregationRequest")
	golang_proto.RegisterType((*VK8SAuditLogAggregationRequest)(nil), "ves.io.schema.log.VK8SAuditLogAggregationRequest")
	proto.RegisterMapType((map[string]*vk8s_audit_log.AggregationRequest)(nil), "ves.io.schema.log.VK8SAuditLogAggregationRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*vk8s_audit_log.AggregationRequest)(nil), "ves.io.schema.log.VK8SAuditLogAggregationRequest.AggsEntry")
	proto.RegisterType((*K8SAuditLogRequest)(nil), "ves.io.schema.log.K8SAuditLogRequest")
	golang_proto.RegisterType((*K8SAuditLogRequest)(nil), "ves.io.schema.log.K8SAuditLogRequest")
	proto.RegisterMapType((map[string]*k8s_audit_log.AggregationRequest)(nil), "ves.io.schema.log.K8SAuditLogRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*k8s_audit_log.AggregationRequest)(nil), "ves.io.schema.log.K8SAuditLogRequest.AggsEntry")
	proto.RegisterType((*K8SAuditLogAggregationRequest)(nil), "ves.io.schema.log.K8SAuditLogAggregationRequest")
	golang_proto.RegisterType((*K8SAuditLogAggregationRequest)(nil), "ves.io.schema.log.K8SAuditLogAggregationRequest")
	proto.RegisterMapType((map[string]*k8s_audit_log.AggregationRequest)(nil), "ves.io.schema.log.K8SAuditLogAggregationRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*k8s_audit_log.AggregationRequest)(nil), "ves.io.schema.log.K8SAuditLogAggregationRequest.AggsEntry")
	proto.RegisterType((*VK8SEventsRequest)(nil), "ves.io.schema.log.VK8SEventsRequest")
	golang_proto.RegisterType((*VK8SEventsRequest)(nil), "ves.io.schema.log.VK8SEventsRequest")
	proto.RegisterMapType((map[string]*vk8s_events.AggregationRequest)(nil), "ves.io.schema.log.VK8SEventsRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*vk8s_events.AggregationRequest)(nil), "ves.io.schema.log.VK8SEventsRequest.AggsEntry")
	proto.RegisterType((*VK8SEventsAggregationRequest)(nil), "ves.io.schema.log.VK8SEventsAggregationRequest")
	golang_proto.RegisterType((*VK8SEventsAggregationRequest)(nil), "ves.io.schema.log.VK8SEventsAggregationRequest")
	proto.RegisterMapType((map[string]*vk8s_events.AggregationRequest)(nil), "ves.io.schema.log.VK8SEventsAggregationRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*vk8s_events.AggregationRequest)(nil), "ves.io.schema.log.VK8SEventsAggregationRequest.AggsEntry")
	proto.RegisterType((*K8SEventsRequest)(nil), "ves.io.schema.log.K8SEventsRequest")
	golang_proto.RegisterType((*K8SEventsRequest)(nil), "ves.io.schema.log.K8SEventsRequest")
	proto.RegisterMapType((map[string]*k8s_events.AggregationRequest)(nil), "ves.io.schema.log.K8SEventsRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*k8s_events.AggregationRequest)(nil), "ves.io.schema.log.K8SEventsRequest.AggsEntry")
	proto.RegisterType((*K8SEventsAggregationRequest)(nil), "ves.io.schema.log.K8SEventsAggregationRequest")
	golang_proto.RegisterType((*K8SEventsAggregationRequest)(nil), "ves.io.schema.log.K8SEventsAggregationRequest")
	proto.RegisterMapType((map[string]*k8s_events.AggregationRequest)(nil), "ves.io.schema.log.K8SEventsAggregationRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*k8s_events.AggregationRequest)(nil), "ves.io.schema.log.K8SEventsAggregationRequest.AggsEntry")
	proto.RegisterType((*FirewallLogRequest)(nil), "ves.io.schema.log.FirewallLogRequest")
	golang_proto.RegisterType((*FirewallLogRequest)(nil), "ves.io.schema.log.FirewallLogRequest")
	proto.RegisterMapType((map[string]*firewall_log.AggregationRequest)(nil), "ves.io.schema.log.FirewallLogRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*firewall_log.AggregationRequest)(nil), "ves.io.schema.log.FirewallLogRequest.AggsEntry")
	proto.RegisterType((*FirewallLogAggregationRequest)(nil), "ves.io.schema.log.FirewallLogAggregationRequest")
	golang_proto.RegisterType((*FirewallLogAggregationRequest)(nil), "ves.io.schema.log.FirewallLogAggregationRequest")
	proto.RegisterMapType((map[string]*firewall_log.AggregationRequest)(nil), "ves.io.schema.log.FirewallLogAggregationRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*firewall_log.AggregationRequest)(nil), "ves.io.schema.log.FirewallLogAggregationRequest.AggsEntry")
	proto.RegisterType((*LogScrollRequest)(nil), "ves.io.schema.log.LogScrollRequest")
	golang_proto.RegisterType((*LogScrollRequest)(nil), "ves.io.schema.log.LogScrollRequest")
	proto.RegisterType((*LogResponse)(nil), "ves.io.schema.log.LogResponse")
	golang_proto.RegisterType((*LogResponse)(nil), "ves.io.schema.log.LogResponse")
	proto.RegisterMapType((map[string]*LogAggregationData)(nil), "ves.io.schema.log.LogResponse.AggsEntry")
	golang_proto.RegisterMapType((map[string]*LogAggregationData)(nil), "ves.io.schema.log.LogResponse.AggsEntry")
	proto.RegisterType((*LogAggregationResponse)(nil), "ves.io.schema.log.LogAggregationResponse")
	golang_proto.RegisterType((*LogAggregationResponse)(nil), "ves.io.schema.log.LogAggregationResponse")
	proto.RegisterMapType((map[string]*LogAggregationData)(nil), "ves.io.schema.log.LogAggregationResponse.AggsEntry")
	golang_proto.RegisterMapType((map[string]*LogAggregationData)(nil), "ves.io.schema.log.LogAggregationResponse.AggsEntry")
}

func init() {
	proto.RegisterFile("ves.io/schema/log/public_customapi.proto", fileDescriptor_bb43ed5d81aff514)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/log/public_customapi.proto", fileDescriptor_bb43ed5d81aff514)
}

var fileDescriptor_bb43ed5d81aff514 = []byte{
	// 1927 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x5a, 0xdb, 0x6f, 0x1b, 0x4b,
	0x1d, 0xce, 0x78, 0x93, 0x34, 0x9e, 0x4a, 0xe7, 0xa4, 0xdb, 0x36, 0x6c, 0x9c, 0x64, 0x15, 0xed,
	0x39, 0x39, 0x38, 0x25, 0xde, 0x6d, 0x9c, 0x93, 0x9e, 0x34, 0xe5, 0xa2, 0xe4, 0x34, 0xbd, 0x97,
	0x82, 0x5b, 0xa5, 0xa2, 0x88, 0x86, 0xb5, 0x3d, 0xd9, 0x6c, 0xb3, 0xf6, 0xba, 0x3b, 0x63, 0xd3,
	0xa8, 0xaa, 0xd4, 0x56, 0xfc, 0x01, 0x48, 0xbc, 0xf0, 0x8e, 0x40, 0x95, 0x40, 0x42, 0xa0, 0xaa,
	0x2a, 0x14, 0x44, 0x91, 0x90, 0x28, 0x42, 0x2a, 0x15, 0xe5, 0xa1, 0x08, 0x24, 0x1a, 0x87, 0xeb,
	0x5b, 0xdf, 0x10, 0xe2, 0x05, 0xed, 0xc5, 0xf1, 0xae, 0x77, 0xed, 0xd9, 0x75, 0x9d, 0x8b, 0x4e,
	0x5e, 0xa2, 0x5d, 0xcf, 0xc4, 0xf3, 0x5d, 0xe6, 0xdb, 0x99, 0xf9, 0xad, 0x61, 0xb2, 0x82, 0xb0,
	0xa8, 0xea, 0x12, 0xce, 0xad, 0xa0, 0x82, 0x2c, 0x69, 0xba, 0x22, 0x95, 0xca, 0x59, 0x4d, 0xcd,
	0x2d, 0xe5, 0xca, 0x98, 0xe8, 0x05, 0xb9, 0xa4, 0x8a, 0x25, 0x43, 0x27, 0x3a, 0x7b, 0xc0, 0xee,
	0x29, 0xda, 0x3d, 0x45, 0x4d, 0x57, 0x12, 0x29, 0x45, 0x25, 0x2b, 0xe5, 0xac, 0x98, 0xd3, 0x0b,
	0x92, 0xa2, 0x2b, 0xba, 0x64, 0xf5, 0xcc, 0x96, 0x97, 0xad, 0x3b, 0xeb, 0xc6, 0xba, 0xb2, 0xbf,
	0x21, 0x31, 0xac, 0xe8, 0xba, 0xa2, 0x21, 0x49, 0x2e, 0xa9, 0x92, 0x5c, 0x2c, 0xea, 0x44, 0x26,
	0xaa, 0x5e, 0xc4, 0x4e, 0x6b, 0x00, 0x12, 0x39, 0x97, 0x43, 0x18, 0x2f, 0x99, 0x97, 0x64, 0xad,
	0x84, 0x6a, 0x3d, 0x3f, 0x1d, 0xd0, 0xb3, 0x9c, 0x57, 0x89, 0xaf, 0xe3, 0x11, 0x7f, 0xc7, 0x65,
	0xd5, 0x40, 0xdf, 0x90, 0x35, 0xcd, 0xd7, 0xf7, 0x33, 0xfe, 0xbe, 0xab, 0x33, 0x78, 0x29, 0xf8,
	0x8b, 0x93, 0xc1, 0x9d, 0x51, 0x05, 0x15, 0x09, 0xf6, 0xf4, 0x1c, 0xf1, 0xf7, 0x74, 0x37, 0x4f,
	0xf8, 0x9b, 0x2b, 0xcd, 0x87, 0x1d, 0x6f, 0xd2, 0x3b, 0x60, 0xdc, 0x21, 0x6f, 0x57, 0xbd, 0xe4,
	0x96, 0x7a, 0xd0, 0xdb, 0xe8, 0xfe, 0xbf, 0x61, 0x6f, 0x53, 0x45, 0xd6, 0xd4, 0xbc, 0x4c, 0x90,
	0xd3, 0x2a, 0x34, 0xb4, 0x22, 0x8c, 0x8a, 0x15, 0xef, 0x97, 0x0b, 0xdf, 0x67, 0x20, 0x3b, 0x67,
	0x19, 0x77, 0x41, 0x57, 0x32, 0xe8, 0x66, 0x19, 0x61, 0xb2, 0x98, 0x66, 0x87, 0x61, 0xbc, 0x28,
	0x17, 0x10, 0x2e, 0xc9, 0x39, 0xc4, 0x81, 0x51, 0x90, 0x8c, 0x67, 0xea, 0x1f, 0xb0, 0x87, 0x60,
	0xcf, 0xcd, 0x32, 0x32, 0xd6, 0xb8, 0x98, 0xd5, 0x62, 0xdf, 0xb0, 0xe3, 0x10, 0x62, 0x22, 0x1b,
	0x64, 0x89, 0xa8, 0x05, 0xc4, 0x31, 0x66, 0xd3, 0x3c, 0xfc, 0xd9, 0xbf, 0x9f, 0x32, 0x3d, 0x06,
	0xf3, 0x9d, 0x6e, 0x90, 0x89, 0x5b, 0xad, 0x57, 0xd4, 0x02, 0x62, 0xc7, 0x60, 0x1f, 0x2a, 0xe6,
	0xed, 0x8e, 0xdd, 0xbe, 0x8e, 0xfb, 0x50, 0x31, 0x6f, 0x75, 0x9b, 0x80, 0xdd, 0x58, 0x37, 0x08,
	0xd7, 0x33, 0x0a, 0x92, 0xef, 0xa4, 0x39, 0xd1, 0x3b, 0xa7, 0x2f, 0xeb, 0x06, 0xb9, 0x64, 0xe4,
	0x91, 0x91, 0xb1, 0x7a, 0x99, 0xa8, 0x34, 0xb5, 0xa0, 0x12, 0xae, 0x77, 0x14, 0x24, 0x7b, 0x32,
	0xf6, 0x0d, 0x3b, 0x00, 0x7b, 0x71, 0xce, 0xd0, 0x35, 0x8d, 0xdb, 0x37, 0x0a, 0x92, 0x7d, 0x19,
	0xe7, 0x8e, 0xfd, 0x18, 0x76, 0xcb, 0x8a, 0x82, 0xb9, 0xf8, 0x28, 0x93, 0xdc, 0x9f, 0x96, 0x44,
	0x5f, 0x5e, 0x44, 0xbf, 0x2c, 0xe2, 0x9c, 0xa2, 0xe0, 0x85, 0x22, 0x31, 0xd6, 0x32, 0xd6, 0x3f,
	0x27, 0x54, 0x18, 0xdf, 0xfc, 0x88, 0xed, 0x87, 0xcc, 0x2a, 0x5a, 0x73, 0xd4, 0x32, 0x2f, 0xd9,
	0x53, 0xb0, 0xa7, 0x22, 0x6b, 0x65, 0x64, 0xe9, 0xb4, 0x3f, 0x7d, 0x34, 0x60, 0x90, 0x7a, 0x68,
	0xcc, 0x2f, 0x37, 0x90, 0x62, 0xa5, 0xcc, 0x19, 0x31, 0x63, 0xff, 0xfb, 0x6c, 0x6c, 0x06, 0x08,
	0x7f, 0x89, 0xc1, 0xa1, 0x4d, 0x44, 0xfe, 0xae, 0xbb, 0xc4, 0xb1, 0x0b, 0x8e, 0xaa, 0xbd, 0x96,
	0xaa, 0x33, 0xad, 0x54, 0xf5, 0x73, 0xd8, 0x49, 0x79, 0xbf, 0xcb, 0xc0, 0x03, 0x73, 0x66, 0x8c,
	0xf7, 0x58, 0x0c, 0xe6, 0x3d, 0x31, 0x10, 0x83, 0x0c, 0x6b, 0x54, 0xc5, 0x67, 0xd3, 0x4a, 0x6b,
	0x9b, 0x16, 0xbc, 0x36, 0x05, 0x45, 0x6d, 0xf3, 0x01, 0x4a, 0x71, 0xe9, 0x4f, 0x31, 0x98, 0xa8,
	0xe1, 0xd9, 0xb5, 0x19, 0x38, 0xef, 0x91, 0xf4, 0xa3, 0x16, 0x92, 0x86, 0x88, 0xc0, 0xf6, 0x69,
	0xfb, 0x43, 0x06, 0x1e, 0x5c, 0x3c, 0x3f, 0x73, 0xb9, 0xc1, 0xef, 0x3d, 0x90, 0x81, 0x93, 0x8e,
	0x61, 0x7d, 0x96, 0x61, 0x41, 0x8f, 0x91, 0x00, 0x5d, 0x7c, 0x4e, 0x15, 0x5a, 0x3b, 0x75, 0xce,
	0xeb, 0xd4, 0x87, 0x01, 0xa3, 0x78, 0xf7, 0x12, 0x14, 0xbb, 0xfe, 0x11, 0x83, 0xbc, 0x1b, 0xd6,
	0xae, 0x8d, 0xc3, 0x25, 0x47, 0xdd, 0x1e, 0x4b, 0xdd, 0x13, 0x14, 0x75, 0x43, 0x44, 0x62, 0x9b,
	0x85, 0xfe, 0x05, 0x03, 0xd9, 0xc8, 0xb1, 0x60, 0x61, 0x37, 0x56, 0x09, 0x72, 0xb4, 0xb5, 0xae,
	0xeb, 0x82, 0x33, 0xcd, 0x05, 0xef, 0x0e, 0x2b, 0x78, 0x0f, 0x3d, 0x2a, 0xbd, 0xd1, 0xa2, 0xb2,
	0x2f, 0x38, 0x2a, 0x7d, 0x11, 0x77, 0x4d, 0x21, 0x92, 0xa2, 0xb5, 0x36, 0xf0, 0xac, 0xd7, 0xc0,
	0xa9, 0x80, 0x41, 0xa2, 0xf8, 0xf7, 0x9f, 0x18, 0x1c, 0x79, 0x9b, 0x9c, 0xec, 0xa4, 0x95, 0x5f,
	0xf4, 0x6c, 0xa7, 0x66, 0x5b, 0xcb, 0x1d, 0x22, 0x3a, 0xdb, 0xab, 0xfc, 0xf7, 0x18, 0x78, 0xc0,
	0xcc, 0xf6, 0x82, 0x75, 0xe0, 0xd9, 0x3b, 0xeb, 0xc9, 0xbc, 0x67, 0x3d, 0x11, 0x9b, 0x3c, 0xf1,
	0x3c, 0xaa, 0xf8, 0x9c, 0xba, 0xd1, 0xda, 0xa9, 0xd3, 0x5e, 0xa7, 0x26, 0x9b, 0x3d, 0xe4, 0xec,
	0xb3, 0x26, 0xc5, 0xa7, 0xbf, 0xc6, 0xe0, 0x70, 0x1d, 0xd1, 0xae, 0x5d, 0x48, 0x2e, 0x7a, 0x16,
	0x92, 0xe3, 0x2d, 0x65, 0x0d, 0x91, 0x85, 0xed, 0x54, 0xf8, 0x11, 0x03, 0xfb, 0x23, 0x06, 0xe1,
	0x93, 0xba, 0x82, 0xcc, 0x79, 0x56, 0x90, 0x54, 0xf0, 0x23, 0xad, 0x75, 0x36, 0xde, 0xfe, 0x58,
	0x18, 0xda, 0xb8, 0x37, 0x31, 0x38, 0xd4, 0x7e, 0x32, 0x76, 0xd2, 0x43, 0xfa, 0x49, 0x3c, 0x4a,
	0x58, 0xb6, 0x51, 0xf2, 0x07, 0x0c, 0x64, 0x4f, 0x39, 0x75, 0xbf, 0x3d, 0x75, 0x0c, 0xa1, 0xef,
	0xad, 0xfc, 0xb2, 0xf8, 0x8c, 0x5a, 0x6d, 0x6d, 0xd4, 0x19, 0xaf, 0x51, 0xe9, 0x80, 0x41, 0xdc,
	0x35, 0x57, 0x8a, 0x55, 0xd5, 0x18, 0x1c, 0x71, 0x61, 0xda, 0xb5, 0x2b, 0x07, 0x7d, 0x1b, 0xd5,
	0x92, 0xc5, 0xce, 0x8a, 0x7c, 0x11, 0xf6, 0x5f, 0xd0, 0x95, 0xcb, 0xd6, 0x1c, 0x09, 0x27, 0xeb,
	0x10, 0x8c, 0xdb, 0x53, 0x6a, 0x49, 0xcd, 0x3b, 0xd2, 0xf6, 0xd9, 0x1f, 0x9c, 0xcd, 0x0b, 0xff,
	0x03, 0x70, 0xbf, 0x35, 0x7f, 0x70, 0x49, 0x2f, 0x62, 0xeb, 0x19, 0xa5, 0xe9, 0x0a, 0xe6, 0xc0,
	0x28, 0x63, 0x3e, 0xa3, 0xcc, 0x6b, 0x76, 0x04, 0x42, 0xa2, 0x13, 0x59, 0x5b, 0x5a, 0x51, 0x09,
	0xb6, 0x1c, 0xe8, 0xce, 0xc4, 0xad, 0x4f, 0xce, 0xa8, 0x04, 0xb3, 0x9f, 0xf5, 0x2c, 0xc4, 0xc9,
	0x00, 0x7a, 0xae, 0x01, 0x1a, 0xc5, 0x6b, 0x89, 0x2e, 0x71, 0xbd, 0xb5, 0xb2, 0x27, 0xbc, 0xca,
	0x8e, 0x05, 0x0f, 0xed, 0xd2, 0xf3, 0xa4, 0x4c, 0x64, 0xb7, 0x98, 0xaf, 0x01, 0x1c, 0x68, 0xf4,
	0xd8, 0x11, 0xc2, 0x4b, 0x1a, 0x34, 0x92, 0x3e, 0xed, 0x90, 0x66, 0x2c, 0xd2, 0x53, 0xd4, 0x91,
	0x9b, 0xf1, 0xdf, 0x6a, 0x8a, 0xe9, 0x7f, 0x4e, 0xc0, 0xf8, 0xc7, 0xd6, 0xdb, 0xa0, 0xb9, 0x2f,
	0x9d, 0x65, 0x7f, 0x02, 0x60, 0xff, 0x66, 0xc9, 0xf5, 0xcb, 0x66, 0xbe, 0x16, 0xd3, 0xec, 0x58,
	0xa8, 0x6a, 0x77, 0x82, 0x6f, 0xed, 0xac, 0x70, 0xf5, 0xd9, 0xe3, 0x18, 0xa8, 0xfe, 0x86, 0x4b,
	0x54, 0x10, 0x4e, 0xa9, 0x7a, 0x4a, 0x2d, 0x2e, 0x1b, 0x32, 0x26, 0x46, 0x39, 0x47, 0xca, 0x06,
	0x4a, 0x19, 0x48, 0xce, 0xdf, 0x7f, 0xf9, 0xb7, 0x6f, 0xc7, 0x24, 0xe1, 0x88, 0xf3, 0x9a, 0x4a,
	0xda, 0x9c, 0xa4, 0x58, 0xba, 0xbd, 0x79, 0x7d, 0xc7, 0xf5, 0xea, 0x08, 0xcf, 0x82, 0x23, 0xec,
	0x8f, 0x01, 0x3c, 0xb4, 0x89, 0xc7, 0x9e, 0xf9, 0x16, 0x74, 0xf6, 0xbd, 0x60, 0x44, 0x9e, 0x70,
	0x50, 0x61, 0x5f, 0x71, 0x60, 0x1f, 0x74, 0x60, 0x2b, 0xa8, 0x88, 0x0c, 0x59, 0xab, 0xe3, 0x9d,
	0x62, 0x27, 0xc3, 0xe3, 0x95, 0x9c, 0xa7, 0xf7, 0x23, 0x00, 0x07, 0x82, 0x30, 0x2f, 0xa6, 0x3b,
	0x83, 0xfa, 0x2a, 0x0d, 0xf5, 0x31, 0x21, 0x3a, 0x6a, 0x53, 0xec, 0x3f, 0x03, 0x38, 0x18, 0x54,
	0x94, 0xb7, 0x15, 0x17, 0xa3, 0x95, 0xf0, 0x13, 0xe3, 0xa1, 0x83, 0x21, 0xe4, 0x42, 0x4e, 0x9f,
	0x13, 0xc2, 0xb1, 0x08, 0xc4, 0xe4, 0xfa, 0x48, 0x26, 0xbb, 0x1f, 0x01, 0xf8, 0x6e, 0xed, 0x80,
	0x5c, 0xf3, 0xe3, 0xfd, 0x30, 0x55, 0x6e, 0xaa, 0x21, 0x8b, 0x21, 0xe1, 0x8b, 0xc2, 0x38, 0x0d,
	0x7e, 0xed, 0x3c, 0x6d, 0x4d, 0xfe, 0x47, 0x00, 0x1e, 0xac, 0xa1, 0xe9, 0xf8, 0xdc, 0xbf, 0x16,
	0x12, 0x74, 0x9a, 0x3d, 0x1a, 0x1a, 0x74, 0x2d, 0x01, 0x4f, 0x00, 0x3c, 0x1c, 0x00, 0xbc, 0x53,
	0x01, 0xf8, 0x5a, 0x48, 0xe8, 0xd3, 0x42, 0x64, 0xe8, 0xa6, 0xec, 0xaf, 0x00, 0xe4, 0x02, 0x2a,
	0x29, 0xb6, 0xf6, 0xa9, 0x48, 0x45, 0xfc, 0x28, 0x21, 0xc8, 0x86, 0x64, 0x35, 0x2b, 0x4c, 0x87,
	0x67, 0xd5, 0x90, 0x81, 0xc7, 0xc0, 0xae, 0xc3, 0x78, 0x72, 0xc0, 0x7e, 0x10, 0xae, 0xce, 0x4d,
	0xf5, 0xe5, 0xab, 0x21, 0x19, 0x4c, 0x09, 0x22, 0x85, 0x81, 0xb7, 0x2c, 0x6b, 0x85, 0xe1, 0x97,
	0x00, 0x7e, 0xca, 0x0d, 0xaa, 0xe3, 0x81, 0x58, 0x0a, 0x89, 0xfe, 0x23, 0x76, 0x3a, 0x1a, 0xfa,
	0x5a, 0x2a, 0x7e, 0x0d, 0xe0, 0x60, 0x13, 0x06, 0x9d, 0x4a, 0x46, 0xe7, 0xe6, 0x50, 0x30, 0x07,
	0xd3, 0x88, 0xbf, 0x03, 0xbb, 0x46, 0xd4, 0x34, 0x22, 0x93, 0x91, 0x0b, 0xfb, 0x51, 0x62, 0xa2,
	0x84, 0xa4, 0xf8, 0x05, 0x61, 0x36, 0x22, 0xc5, 0x86, 0xac, 0xbc, 0x04, 0x56, 0xa5, 0xc6, 0x1b,
	0x95, 0xb1, 0x50, 0x75, 0x6e, 0xaa, 0x4f, 0xb7, 0x1c, 0x12, 0x13, 0xcb, 0xd3, 0xb7, 0x72, 0x29,
	0xb9, 0x54, 0xc2, 0x44, 0xce, 0xad, 0xa6, 0xb2, 0x32, 0x56, 0x73, 0xa9, 0x82, 0x5e, 0x54, 0x89,
	0x6e, 0x4c, 0x8c, 0x3a, 0x0c, 0x57, 0x67, 0x70, 0x9d, 0xd6, 0xe7, 0x85, 0xe3, 0x14, 0x5a, 0x58,
	0x25, 0x48, 0xba, 0x6d, 0xfe, 0xbd, 0x23, 0xf9, 0x63, 0xf4, 0x7b, 0x00, 0x07, 0xb6, 0x32, 0x45,
	0xa5, 0xb6, 0x99, 0x1d, 0x63, 0x3f, 0xa4, 0x30, 0x0b, 0x8e, 0xd5, 0x1f, 0x01, 0xe4, 0xb6, 0x36,
	0x55, 0xb8, 0x6d, 0x4e, 0xc7, 0x85, 0xb6, 0x38, 0x99, 0x46, 0xdd, 0xb3, 0xeb, 0x4d, 0x4d, 0x53,
	0x76, 0x34, 0xea, 0x2b, 0x80, 0x28, 0x21, 0xfb, 0x26, 0x68, 0x9b, 0xf2, 0x39, 0x61, 0xa1, 0xed,
	0x09, 0xda, 0x18, 0xc1, 0x1f, 0x00, 0xf8, 0x6e, 0xbd, 0x92, 0x6b, 0xf3, 0x7e, 0x3f, 0x4c, 0x11,
	0x9d, 0x6a, 0x69, 0xc6, 0xe1, 0x77, 0xb8, 0xf6, 0x14, 0x91, 0x65, 0x9c, 0xca, 0x99, 0x7f, 0x22,
	0x9c, 0x55, 0x5c, 0x55, 0x5f, 0x13, 0xed, 0x43, 0x00, 0x0f, 0xd7, 0x91, 0x74, 0x3c, 0x59, 0x8b,
	0x74, 0xc8, 0xf4, 0xe3, 0x8a, 0xfb, 0x67, 0x67, 0x4e, 0x7e, 0x7e, 0xea, 0x2c, 0xac, 0x3e, 0xd8,
	0x9d, 0x8a, 0xcf, 0x57, 0xe8, 0xc0, 0xe9, 0x27, 0x16, 0x3f, 0x70, 0x67, 0xab, 0x96, 0x08, 0x2c,
	0xf5, 0xdb, 0xba, 0x4b, 0x11, 0xdf, 0x0c, 0x44, 0x89, 0xc8, 0x75, 0x3a, 0x2b, 0xfa, 0x71, 0xc5,
	0xcd, 0xaa, 0x61, 0xee, 0xff, 0x0e, 0xc0, 0x77, 0x1a, 0xa6, 0xfe, 0x7b, 0x21, 0x4a, 0xe4, 0x54,
	0x37, 0x48, 0xdb, 0xc9, 0xa6, 0x6f, 0x1a, 0x1a, 0x93, 0x5d, 0xcf, 0xc6, 0x6f, 0x01, 0x3c, 0xb4,
	0x75, 0xd1, 0xd0, 0xda, 0xe6, 0x44, 0x3f, 0xdd, 0xf8, 0x03, 0xf3, 0xdc, 0x5e, 0x42, 0xb7, 0x2c,
	0x2f, 0x7a, 0xdb, 0x6c, 0xe8, 0x07, 0x9e, 0xc0, 0x14, 0xfd, 0x17, 0xc0, 0xc1, 0xe6, 0x21, 0x12,
	0xa3, 0xbd, 0x30, 0x88, 0x92, 0xa1, 0xbb, 0xed, 0x2f, 0x33, 0xa7, 0x84, 0xb9, 0xb6, 0x26, 0x63,
	0x63, 0xcc, 0x1e, 0x02, 0xd8, 0xef, 0x2a, 0xf9, 0x36, 0xdf, 0xe5, 0xf9, 0x2b, 0xee, 0xa1, 0x1f,
	0x7c, 0xb4, 0xad, 0xea, 0xa4, 0x30, 0x41, 0xe1, 0xe2, 0x2e, 0x12, 0x5b, 0x79, 0xfa, 0x39, 0x80,
	0x03, 0x2e, 0x44, 0x1d, 0x4f, 0x54, 0xe8, 0x23, 0x36, 0x3b, 0x15, 0x05, 0x7a, 0x2d, 0x42, 0xbf,
	0x02, 0x90, 0x0b, 0x86, 0xdf, 0xa9, 0x10, 0x7d, 0x3d, 0x24, 0x81, 0x19, 0xa1, 0x1d, 0x02, 0xa6,
	0x05, 0xeb, 0x00, 0x0e, 0x05, 0xbf, 0x2c, 0x68, 0xbe, 0x41, 0x6b, 0xf9, 0x72, 0x21, 0x4a, 0x72,
	0x50, 0x48, 0x7a, 0x9f, 0x13, 0x66, 0x22, 0xd1, 0xf3, 0xa6, 0x23, 0xf1, 0xc1, 0xd3, 0x27, 0x80,
	0xf9, 0xc3, 0x13, 0xc0, 0xf9, 0x81, 0x5d, 0xca, 0xde, 0x40, 0x39, 0x72, 0xff, 0x39, 0x17, 0xe3,
	0xc0, 0xfc, 0x3d, 0xf0, 0x62, 0x9d, 0xef, 0x7a, 0xb5, 0xce, 0x77, 0xbd, 0x59, 0xe7, 0xc1, 0xdd,
	0x2a, 0x0f, 0x1e, 0x54, 0x79, 0xf0, 0xac, 0xca, 0x83, 0x17, 0x55, 0x1e, 0xbc, 0xae, 0xf2, 0xe0,
	0x5f, 0x55, 0xbe, 0xeb, 0x4d, 0x95, 0x07, 0xdf, 0xda, 0xe0, 0xbb, 0x9e, 0x6e, 0xf0, 0xe0, 0xc5,
	0x06, 0xdf, 0xf5, 0x6a, 0x83, 0xef, 0xba, 0x76, 0x5a, 0xd1, 0x4b, 0xab, 0x8a, 0x58, 0xd1, 0x35,
	0x82, 0x0c, 0x43, 0x16, 0xcb, 0x58, 0xb2, 0x2e, 0x96, 0x75, 0xa3, 0x90, 0x2a, 0x19, 0x7a, 0x45,
	0xcd, 0x23, 0x23, 0x55, 0x6b, 0x96, 0x4a, 0x59, 0x45, 0x97, 0xd0, 0x2d, 0xe2, 0xfc, 0x92, 0xbd,
	0xfe, 0x8b, 0xfa, 0x6c, 0xaf, 0xf5, 0x33, 0xf6, 0xa9, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0x25,
	0xb7, 0x2f, 0x32, 0x1a, 0x31, 0x00, 0x00,
}

func (this *AccessLogRequestV2) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccessLogRequestV2)
	if !ok {
		that2, ok := that.(AccessLogRequestV2)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if this.Sort != that1.Sort {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if this.Scroll != that1.Scroll {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *AccessLogAggregationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccessLogAggregationRequest)
	if !ok {
		that2, ok := that.(AccessLogAggregationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *AuditLogRequestV2) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuditLogRequestV2)
	if !ok {
		that2, ok := that.(AuditLogRequestV2)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if this.Sort != that1.Sort {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if this.Scroll != that1.Scroll {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *AuditLogAggregationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuditLogAggregationRequest)
	if !ok {
		that2, ok := that.(AuditLogAggregationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *VK8SAuditLogRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VK8SAuditLogRequest)
	if !ok {
		that2, ok := that.(VK8SAuditLogRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if this.Sort != that1.Sort {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if this.Scroll != that1.Scroll {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *VK8SAuditLogAggregationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VK8SAuditLogAggregationRequest)
	if !ok {
		that2, ok := that.(VK8SAuditLogAggregationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *K8SAuditLogRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAuditLogRequest)
	if !ok {
		that2, ok := that.(K8SAuditLogRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Site != that1.Site {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if this.Sort != that1.Sort {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if this.Scroll != that1.Scroll {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *K8SAuditLogAggregationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAuditLogAggregationRequest)
	if !ok {
		that2, ok := that.(K8SAuditLogAggregationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Site != that1.Site {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *VK8SEventsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VK8SEventsRequest)
	if !ok {
		that2, ok := that.(VK8SEventsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if this.Sort != that1.Sort {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if this.Scroll != that1.Scroll {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *VK8SEventsAggregationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VK8SEventsAggregationRequest)
	if !ok {
		that2, ok := that.(VK8SEventsAggregationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *K8SEventsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SEventsRequest)
	if !ok {
		that2, ok := that.(K8SEventsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Site != that1.Site {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if this.Sort != that1.Sort {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if this.Scroll != that1.Scroll {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *K8SEventsAggregationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SEventsAggregationRequest)
	if !ok {
		that2, ok := that.(K8SEventsAggregationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Site != that1.Site {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *FirewallLogRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FirewallLogRequest)
	if !ok {
		that2, ok := that.(FirewallLogRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if this.Sort != that1.Sort {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if this.Scroll != that1.Scroll {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *FirewallLogAggregationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FirewallLogAggregationRequest)
	if !ok {
		that2, ok := that.(FirewallLogAggregationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *LogScrollRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogScrollRequest)
	if !ok {
		that2, ok := that.(LogScrollRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.ScrollId != that1.ScrollId {
		return false
	}
	return true
}
func (this *LogResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogResponse)
	if !ok {
		that2, ok := that.(LogResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Logs) != len(that1.Logs) {
		return false
	}
	for i := range this.Logs {
		if this.Logs[i] != that1.Logs[i] {
			return false
		}
	}
	if this.TotalHits != that1.TotalHits {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	if this.ScrollId != that1.ScrollId {
		return false
	}
	return true
}
func (this *LogAggregationResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogAggregationResponse)
	if !ok {
		that2, ok := that.(LogAggregationResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TotalHits != that1.TotalHits {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *AccessLogRequestV2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&log.AccessLogRequestV2{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	s = append(s, "Sort: "+fmt.Sprintf("%#v", this.Sort)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "Scroll: "+fmt.Sprintf("%#v", this.Scroll)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*access_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AccessLogAggregationRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&log.AccessLogAggregationRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*access_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuditLogRequestV2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&log.AuditLogRequestV2{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	s = append(s, "Sort: "+fmt.Sprintf("%#v", this.Sort)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "Scroll: "+fmt.Sprintf("%#v", this.Scroll)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*audit_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuditLogAggregationRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&log.AuditLogAggregationRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*audit_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VK8SAuditLogRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&log.VK8SAuditLogRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	s = append(s, "Sort: "+fmt.Sprintf("%#v", this.Sort)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "Scroll: "+fmt.Sprintf("%#v", this.Scroll)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*vk8s_audit_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VK8SAuditLogAggregationRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&log.VK8SAuditLogAggregationRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*vk8s_audit_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SAuditLogRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&log.K8SAuditLogRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	s = append(s, "Sort: "+fmt.Sprintf("%#v", this.Sort)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "Scroll: "+fmt.Sprintf("%#v", this.Scroll)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*k8s_audit_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SAuditLogAggregationRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&log.K8SAuditLogAggregationRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*k8s_audit_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VK8SEventsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&log.VK8SEventsRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	s = append(s, "Sort: "+fmt.Sprintf("%#v", this.Sort)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "Scroll: "+fmt.Sprintf("%#v", this.Scroll)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*vk8s_events.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VK8SEventsAggregationRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&log.VK8SEventsAggregationRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*vk8s_events.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SEventsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&log.K8SEventsRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	s = append(s, "Sort: "+fmt.Sprintf("%#v", this.Sort)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "Scroll: "+fmt.Sprintf("%#v", this.Scroll)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*k8s_events.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SEventsAggregationRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&log.K8SEventsAggregationRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*k8s_events.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FirewallLogRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&log.FirewallLogRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	s = append(s, "Sort: "+fmt.Sprintf("%#v", this.Sort)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "Scroll: "+fmt.Sprintf("%#v", this.Scroll)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*firewall_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FirewallLogAggregationRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&log.FirewallLogAggregationRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*firewall_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LogScrollRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&log.LogScrollRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "ScrollId: "+fmt.Sprintf("%#v", this.ScrollId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LogResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&log.LogResponse{")
	s = append(s, "Logs: "+fmt.Sprintf("%#v", this.Logs)+",\n")
	s = append(s, "TotalHits: "+fmt.Sprintf("%#v", this.TotalHits)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "ScrollId: "+fmt.Sprintf("%#v", this.ScrollId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LogAggregationResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&log.LogAggregationResponse{")
	s = append(s, "TotalHits: "+fmt.Sprintf("%#v", this.TotalHits)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPublicCustomapi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CustomAPIClient is the client API for CustomAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CustomAPIClient interface {
	// Access Log Query V2
	//
	// x-displayName: "Access Log Query V2"
	// Request to get access logs that matches the criteria in request for a given namespace.
	// Typically, virtual host is specified as match condition in the request to get all access logs
	// for a virtual host. By default, the access logs in the response are sorted in the reverse chronological order.
	AccessLogQueryV2(ctx context.Context, in *AccessLogRequestV2, opts ...grpc.CallOption) (*LogResponse, error)
	// Access Log Scroll Query
	//
	// x-displayName: "Access Log Scroll Query"
	// The response for access log query contain no more than 500 records.
	// Scroll request is used scroll through more than 500 records or all records that matched the criteria in the
	// access log query in multiple batches. EOF is indicated by empty scroll_id in the response.
	AccessLogScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// Access Log Scroll Query V2
	//
	// x-displayName: "Access Log Scroll Query V2"
	// The response for access log query contain no more than 500 records.
	// Scroll request is used to scroll through more than 500 records or
	// all records that matched the criteria in the
	// access log query in multiple batches. EOF is indicated by empty scroll_id in the response.
	// This uses post request to pass the scroll_id in the body.
	AccessLogScrollQueryV2(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// Access Log Aggregation Query
	//
	// x-displayName: "Access Log Aggregation Query"
	// Request to get summary/analytics data for the access logs that matches the query in request for a given namespace.
	// Typically, virtual host is specified as match condition in the request to get the aggregaation data
	// for a virtual host.
	AccessLogAggregationQuery(ctx context.Context, in *AccessLogAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error)
	// Audit Log Query V2
	//
	// x-displayName: "Audit Log Query V2"
	// Request to get audit logs that matches the criteria in request for a given namespace.
	// If no match conditions are specified in the request, then the response contains all
	// CRUD operations performed in the namespace. User with access to the `system` namespace
	// may query for audit logs across all namespaces for a given tenant.
	AuditLogQueryV2(ctx context.Context, in *AuditLogRequestV2, opts ...grpc.CallOption) (*LogResponse, error)
	// Audit Log Scroll Query
	//
	// x-displayName: "Audit Log Scroll Query"
	// The response for audit log query contain no more than 500 messages.
	// One can use scroll request to scroll through more than 500 messages or all messages
	// in multiple batches. empty scroll_id in the response indicates no more messages to fetch (EOF).
	AuditLogScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// Audit Log Scroll Query V2
	//
	// x-displayName: "Audit Log Scroll Query V2"
	// The response for audit log query contain no more than 500 messages.
	// One can use scroll request to scroll through more than 500 messages or all messages
	// in multiple batches. empty scroll_id in the response indicates no more messages to fetch (EOF).
	// This uses post request to pass the scroll_id in the body.
	AuditLogScrollQueryV2(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// Audit Log Aggregation Query
	//
	// x-displayName: "Audit Log Aggregation Query"
	// Request to get summary/analytics data for the audit logs that matches the criteria in request for a given namespace.
	// User with access to the `system` namespace may query aggregated data for audit logs across all namespaces for a given tenant.
	AuditLogAggregationQuery(ctx context.Context, in *AuditLogAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error)
	// vK8s Audit Log Query
	//
	// x-displayName: "vK8s Audit Log Query"
	// Request to get Virtual K8s audit logs that matches the criteria in request for a given namespace.
	// If no match conditions are specified in the request, then the response contains all
	// CRUD operations performed in the namespace. User with access to the `system` namespace
	// may query for audit logs across all namespaces for a given tenant.
	VK8SAuditLogQuery(ctx context.Context, in *VK8SAuditLogRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// vK8s Audit Log Scroll Query
	//
	// x-displayName: "vK8s Audit Log Scroll Query"
	// The response for vK8s audit log query contain no more than 500 messages.
	// One can use scroll request to scroll through more than 500 messages or all messages
	// in multiple batches. empty scroll_id in the response indicates no more messages to fetch (EOF).
	VK8SAuditLogScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// vK8s Audit Log Scroll Query V2
	//
	// x-displayName: "vK8s Audit Log Scroll Query V2"
	// The response for vK8s audit log query contain no more than 500 messages.
	// One can use scroll request to scroll through more than 500 messages or all messages
	// in multiple batches. empty scroll_id in the response indicates no more messages to fetch (EOF).
	// This uses post request to pass the scroll_id in the body.
	VK8SAuditLogScrollQueryV2(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// vK8s Audit Log Aggregation Query
	//
	// x-displayName: "vK8s Audit Log Aggregation Query"
	// Request to get summary/analytics data for the vK8s audit logs that matches the criteria in request for a given namespace.
	// User with access to the `system` namespace may query aggregated data for audit logs across all namespaces for a given tenant.
	VK8SAuditLogAggregationQuery(ctx context.Context, in *VK8SAuditLogAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error)
	// K8s Audit Log Query
	//
	// x-displayName: "K8s Audit Log Query"
	// Request to get Physical K8s audit logs that matches the criteria in request for a given namespace.
	// If no match conditions are specified in the request, then the response contains all
	// CRUD operations performed in the namespace. User with access to the `system` namespace
	// may query for audit logs across all namespaces in a K8s Cluster.
	K8SAuditLogQuery(ctx context.Context, in *K8SAuditLogRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// K8s Audit Log Scroll Query
	//
	// x-displayName: "K8s Audit Log Scroll Query"
	// The response for K8s audit log query contain no more than 500 messages.
	// One can use scroll request to scroll through more than 500 messages or all messages
	// in multiple batches. empty scroll_id in the response indicates no more messages to fetch (EOF).
	K8SAuditLogScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// K8s Audit Log Scroll Query V2
	//
	// x-displayName: "K8s Audit Log Scroll Query V2"
	// The response for K8s audit log query contain no more than 500 messages.
	// One can use scroll request to scroll through more than 500 messages or all messages
	// in multiple batches. empty scroll_id in the response indicates no more messages to fetch (EOF).
	// This uses post request to pass the scroll_id in the body.
	K8SAuditLogScrollQueryV2(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// K8s Audit Log Aggregation Query
	//
	// x-displayName: "K8s Audit Log Aggregation Query"
	// Request to get summary/analytics data for the K8s audit logs that matches the criteria in request for a given namespace.
	// User with access to the `system` namespace may query aggregated data for audit logs across all namespaces in a K8s Cluster.
	K8SAuditLogAggregationQuery(ctx context.Context, in *K8SAuditLogAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error)
	// vK8s Events Query
	//
	// x-displayName: "vK8s Events Query"
	// Request to get Virtual K8s events that matches the criteria in request for a given namespace.
	// If no match conditions are specified in the request, then the response contains all
	// vK8s events in the namespace. User with access to the `system` namespace may query for vK8s across
	// all namespaces for a given tenant.
	VK8SEventsQuery(ctx context.Context, in *VK8SEventsRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// vK8s Events Scroll Query
	//
	// x-displayName: "vK8s Events Scroll Query"
	// The response for vK8s events query contain no more than 500 events.
	// One can use scroll request to scroll through more than 500 events or all events
	// in multiple batches. Empty scroll_id in the response indicates no more messages to fetch (EOF).
	VK8SEventsScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// vK8s Events Scroll Query V2
	//
	// x-displayName: "vK8s Events Scroll Query V2"
	// The response for vK8s events query contain no more than 500 events.
	// One can use scroll request to scroll through more than 500 events or all events
	// in multiple batches. Empty scroll_id in the response indicates no more messages to fetch (EOF).
	// This uses post request to pass the scroll_id in the body.
	VK8SEventsScrollQueryV2(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// vK8s Events Aggregation Query
	//
	// x-displayName: "vK8s Events Aggregation Query"
	// Request to get summary/analytics data for the vK8s events that matches the criteria in request for a given namespace.
	// User with access to the `system` namespace may query aggregated data for vK8s events across all namespaces for a given tenant.
	VK8SEventsAggregationQuery(ctx context.Context, in *VK8SEventsAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error)
	// K8s Events Query
	//
	// x-displayName: "K8s Events Query"
	// Request to get physical K8s events that matches the criteria in request for a given namespace.
	// If no match conditions are specified in the request, then the response contains all
	// K8s events in the namespace. User with access to the `system` namespace may query for K8s events across
	// all namespaces in a K8s Cluster.
	K8SEventsQuery(ctx context.Context, in *K8SEventsRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// K8s Events Scroll Query
	//
	// x-displayName: "K8s Events Scroll Query"
	// The response for K8s events query contain no more than 500 events.
	// One can use scroll request to scroll through more than 500 events or all events
	// in multiple batches. Empty scroll_id in the response indicates no more messages to fetch (EOF).
	K8SEventsScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// K8s Events Scroll Query V2
	//
	// x-displayName: "K8s Events Scroll Query V2"
	// The response for K8s events query contain no more than 500 events.
	// One can use scroll request to scroll through more than 500 events or all events
	// in multiple batches. Empty scroll_id in the response indicates no more messages to fetch (EOF).
	// This uses post request to pass the scroll_id in the body.
	K8SEventsScrollQueryV2(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// K8s Events Aggregation Query
	//
	// x-displayName: "K8s Events Aggregation Query"
	// Request to get summary/analytics data for the K8s events that matches the criteria in request for a given namespace.
	// User with access to the `system` namespace may query aggregated data for K8s events across all namespaces in a K8s Cluster.
	K8SEventsAggregationQuery(ctx context.Context, in *K8SEventsAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error)
	// Firewall Logs Query
	//
	// x-displayName: "Firewall Logs Query"
	// Request to get access logs and network logs with policy hits.
	// By default, the firewall logs in the response are sorted in the reverse chronological order.
	FirewallLogQuery(ctx context.Context, in *FirewallLogRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// Firewall Logs Scroll Query
	//
	// x-displayName: "Firewall Logs Scroll Query"
	// The response for firewall log query contain no more than 500 records.
	// Scroll request is used scroll through more than 500 records or all records that matched the criteria in the
	// firewall log query in multiple batches. EOF is indicated by empty scroll_id in the response.
	FirewallLogScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// Firewall Logs Scroll Query V2
	//
	// x-displayName: "Firewall Logs Scroll Query V2"
	// The response for firewall log query contain no more than 500 records.
	// Scroll request is used scroll through more than 500 records or all records that matched the criteria in the
	// firewall log query in multiple batches. EOF is indicated by empty scroll_id in the response.
	// This uses post request to pass the scroll_id in the body.
	FirewallLogScrollQueryV2(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// Firewall Logs Aggregation Query
	//
	// x-displayName: "Firewall Logs Aggregation Query"
	// Request to get summary/analytics data for the firewall logs that matches the query in request for a given namespace.
	FirewallLogAggregationQuery(ctx context.Context, in *FirewallLogAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error)
}

type customAPIClient struct {
	cc *grpc.ClientConn
}

func NewCustomAPIClient(cc *grpc.ClientConn) CustomAPIClient {
	return &customAPIClient{cc}
}

func (c *customAPIClient) AccessLogQueryV2(ctx context.Context, in *AccessLogRequestV2, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/AccessLogQueryV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) AccessLogScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/AccessLogScrollQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) AccessLogScrollQueryV2(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/AccessLogScrollQueryV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) AccessLogAggregationQuery(ctx context.Context, in *AccessLogAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error) {
	out := new(LogAggregationResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/AccessLogAggregationQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) AuditLogQueryV2(ctx context.Context, in *AuditLogRequestV2, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/AuditLogQueryV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) AuditLogScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/AuditLogScrollQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) AuditLogScrollQueryV2(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/AuditLogScrollQueryV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) AuditLogAggregationQuery(ctx context.Context, in *AuditLogAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error) {
	out := new(LogAggregationResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/AuditLogAggregationQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) VK8SAuditLogQuery(ctx context.Context, in *VK8SAuditLogRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/VK8SAuditLogQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) VK8SAuditLogScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/VK8SAuditLogScrollQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) VK8SAuditLogScrollQueryV2(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/VK8SAuditLogScrollQueryV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) VK8SAuditLogAggregationQuery(ctx context.Context, in *VK8SAuditLogAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error) {
	out := new(LogAggregationResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/VK8SAuditLogAggregationQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) K8SAuditLogQuery(ctx context.Context, in *K8SAuditLogRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/K8SAuditLogQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) K8SAuditLogScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/K8SAuditLogScrollQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) K8SAuditLogScrollQueryV2(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/K8SAuditLogScrollQueryV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) K8SAuditLogAggregationQuery(ctx context.Context, in *K8SAuditLogAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error) {
	out := new(LogAggregationResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/K8SAuditLogAggregationQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) VK8SEventsQuery(ctx context.Context, in *VK8SEventsRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/VK8SEventsQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) VK8SEventsScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/VK8SEventsScrollQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) VK8SEventsScrollQueryV2(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/VK8SEventsScrollQueryV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) VK8SEventsAggregationQuery(ctx context.Context, in *VK8SEventsAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error) {
	out := new(LogAggregationResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/VK8SEventsAggregationQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) K8SEventsQuery(ctx context.Context, in *K8SEventsRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/K8SEventsQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) K8SEventsScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/K8SEventsScrollQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) K8SEventsScrollQueryV2(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/K8SEventsScrollQueryV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) K8SEventsAggregationQuery(ctx context.Context, in *K8SEventsAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error) {
	out := new(LogAggregationResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/K8SEventsAggregationQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) FirewallLogQuery(ctx context.Context, in *FirewallLogRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/FirewallLogQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) FirewallLogScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/FirewallLogScrollQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) FirewallLogScrollQueryV2(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/FirewallLogScrollQueryV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) FirewallLogAggregationQuery(ctx context.Context, in *FirewallLogAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error) {
	out := new(LogAggregationResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.log.CustomAPI/FirewallLogAggregationQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CustomAPIServer is the server API for CustomAPI service.
type CustomAPIServer interface {
	// Access Log Query V2
	//
	// x-displayName: "Access Log Query V2"
	// Request to get access logs that matches the criteria in request for a given namespace.
	// Typically, virtual host is specified as match condition in the request to get all access logs
	// for a virtual host. By default, the access logs in the response are sorted in the reverse chronological order.
	AccessLogQueryV2(context.Context, *AccessLogRequestV2) (*LogResponse, error)
	// Access Log Scroll Query
	//
	// x-displayName: "Access Log Scroll Query"
	// The response for access log query contain no more than 500 records.
	// Scroll request is used scroll through more than 500 records or all records that matched the criteria in the
	// access log query in multiple batches. EOF is indicated by empty scroll_id in the response.
	AccessLogScrollQuery(context.Context, *LogScrollRequest) (*LogResponse, error)
	// Access Log Scroll Query V2
	//
	// x-displayName: "Access Log Scroll Query V2"
	// The response for access log query contain no more than 500 records.
	// Scroll request is used to scroll through more than 500 records or
	// all records that matched the criteria in the
	// access log query in multiple batches. EOF is indicated by empty scroll_id in the response.
	// This uses post request to pass the scroll_id in the body.
	AccessLogScrollQueryV2(context.Context, *LogScrollRequest) (*LogResponse, error)
	// Access Log Aggregation Query
	//
	// x-displayName: "Access Log Aggregation Query"
	// Request to get summary/analytics data for the access logs that matches the query in request for a given namespace.
	// Typically, virtual host is specified as match condition in the request to get the aggregaation data
	// for a virtual host.
	AccessLogAggregationQuery(context.Context, *AccessLogAggregationRequest) (*LogAggregationResponse, error)
	// Audit Log Query V2
	//
	// x-displayName: "Audit Log Query V2"
	// Request to get audit logs that matches the criteria in request for a given namespace.
	// If no match conditions are specified in the request, then the response contains all
	// CRUD operations performed in the namespace. User with access to the `system` namespace
	// may query for audit logs across all namespaces for a given tenant.
	AuditLogQueryV2(context.Context, *AuditLogRequestV2) (*LogResponse, error)
	// Audit Log Scroll Query
	//
	// x-displayName: "Audit Log Scroll Query"
	// The response for audit log query contain no more than 500 messages.
	// One can use scroll request to scroll through more than 500 messages or all messages
	// in multiple batches. empty scroll_id in the response indicates no more messages to fetch (EOF).
	AuditLogScrollQuery(context.Context, *LogScrollRequest) (*LogResponse, error)
	// Audit Log Scroll Query V2
	//
	// x-displayName: "Audit Log Scroll Query V2"
	// The response for audit log query contain no more than 500 messages.
	// One can use scroll request to scroll through more than 500 messages or all messages
	// in multiple batches. empty scroll_id in the response indicates no more messages to fetch (EOF).
	// This uses post request to pass the scroll_id in the body.
	AuditLogScrollQueryV2(context.Context, *LogScrollRequest) (*LogResponse, error)
	// Audit Log Aggregation Query
	//
	// x-displayName: "Audit Log Aggregation Query"
	// Request to get summary/analytics data for the audit logs that matches the criteria in request for a given namespace.
	// User with access to the `system` namespace may query aggregated data for audit logs across all namespaces for a given tenant.
	AuditLogAggregationQuery(context.Context, *AuditLogAggregationRequest) (*LogAggregationResponse, error)
	// vK8s Audit Log Query
	//
	// x-displayName: "vK8s Audit Log Query"
	// Request to get Virtual K8s audit logs that matches the criteria in request for a given namespace.
	// If no match conditions are specified in the request, then the response contains all
	// CRUD operations performed in the namespace. User with access to the `system` namespace
	// may query for audit logs across all namespaces for a given tenant.
	VK8SAuditLogQuery(context.Context, *VK8SAuditLogRequest) (*LogResponse, error)
	// vK8s Audit Log Scroll Query
	//
	// x-displayName: "vK8s Audit Log Scroll Query"
	// The response for vK8s audit log query contain no more than 500 messages.
	// One can use scroll request to scroll through more than 500 messages or all messages
	// in multiple batches. empty scroll_id in the response indicates no more messages to fetch (EOF).
	VK8SAuditLogScrollQuery(context.Context, *LogScrollRequest) (*LogResponse, error)
	// vK8s Audit Log Scroll Query V2
	//
	// x-displayName: "vK8s Audit Log Scroll Query V2"
	// The response for vK8s audit log query contain no more than 500 messages.
	// One can use scroll request to scroll through more than 500 messages or all messages
	// in multiple batches. empty scroll_id in the response indicates no more messages to fetch (EOF).
	// This uses post request to pass the scroll_id in the body.
	VK8SAuditLogScrollQueryV2(context.Context, *LogScrollRequest) (*LogResponse, error)
	// vK8s Audit Log Aggregation Query
	//
	// x-displayName: "vK8s Audit Log Aggregation Query"
	// Request to get summary/analytics data for the vK8s audit logs that matches the criteria in request for a given namespace.
	// User with access to the `system` namespace may query aggregated data for audit logs across all namespaces for a given tenant.
	VK8SAuditLogAggregationQuery(context.Context, *VK8SAuditLogAggregationRequest) (*LogAggregationResponse, error)
	// K8s Audit Log Query
	//
	// x-displayName: "K8s Audit Log Query"
	// Request to get Physical K8s audit logs that matches the criteria in request for a given namespace.
	// If no match conditions are specified in the request, then the response contains all
	// CRUD operations performed in the namespace. User with access to the `system` namespace
	// may query for audit logs across all namespaces in a K8s Cluster.
	K8SAuditLogQuery(context.Context, *K8SAuditLogRequest) (*LogResponse, error)
	// K8s Audit Log Scroll Query
	//
	// x-displayName: "K8s Audit Log Scroll Query"
	// The response for K8s audit log query contain no more than 500 messages.
	// One can use scroll request to scroll through more than 500 messages or all messages
	// in multiple batches. empty scroll_id in the response indicates no more messages to fetch (EOF).
	K8SAuditLogScrollQuery(context.Context, *LogScrollRequest) (*LogResponse, error)
	// K8s Audit Log Scroll Query V2
	//
	// x-displayName: "K8s Audit Log Scroll Query V2"
	// The response for K8s audit log query contain no more than 500 messages.
	// One can use scroll request to scroll through more than 500 messages or all messages
	// in multiple batches. empty scroll_id in the response indicates no more messages to fetch (EOF).
	// This uses post request to pass the scroll_id in the body.
	K8SAuditLogScrollQueryV2(context.Context, *LogScrollRequest) (*LogResponse, error)
	// K8s Audit Log Aggregation Query
	//
	// x-displayName: "K8s Audit Log Aggregation Query"
	// Request to get summary/analytics data for the K8s audit logs that matches the criteria in request for a given namespace.
	// User with access to the `system` namespace may query aggregated data for audit logs across all namespaces in a K8s Cluster.
	K8SAuditLogAggregationQuery(context.Context, *K8SAuditLogAggregationRequest) (*LogAggregationResponse, error)
	// vK8s Events Query
	//
	// x-displayName: "vK8s Events Query"
	// Request to get Virtual K8s events that matches the criteria in request for a given namespace.
	// If no match conditions are specified in the request, then the response contains all
	// vK8s events in the namespace. User with access to the `system` namespace may query for vK8s across
	// all namespaces for a given tenant.
	VK8SEventsQuery(context.Context, *VK8SEventsRequest) (*LogResponse, error)
	// vK8s Events Scroll Query
	//
	// x-displayName: "vK8s Events Scroll Query"
	// The response for vK8s events query contain no more than 500 events.
	// One can use scroll request to scroll through more than 500 events or all events
	// in multiple batches. Empty scroll_id in the response indicates no more messages to fetch (EOF).
	VK8SEventsScrollQuery(context.Context, *LogScrollRequest) (*LogResponse, error)
	// vK8s Events Scroll Query V2
	//
	// x-displayName: "vK8s Events Scroll Query V2"
	// The response for vK8s events query contain no more than 500 events.
	// One can use scroll request to scroll through more than 500 events or all events
	// in multiple batches. Empty scroll_id in the response indicates no more messages to fetch (EOF).
	// This uses post request to pass the scroll_id in the body.
	VK8SEventsScrollQueryV2(context.Context, *LogScrollRequest) (*LogResponse, error)
	// vK8s Events Aggregation Query
	//
	// x-displayName: "vK8s Events Aggregation Query"
	// Request to get summary/analytics data for the vK8s events that matches the criteria in request for a given namespace.
	// User with access to the `system` namespace may query aggregated data for vK8s events across all namespaces for a given tenant.
	VK8SEventsAggregationQuery(context.Context, *VK8SEventsAggregationRequest) (*LogAggregationResponse, error)
	// K8s Events Query
	//
	// x-displayName: "K8s Events Query"
	// Request to get physical K8s events that matches the criteria in request for a given namespace.
	// If no match conditions are specified in the request, then the response contains all
	// K8s events in the namespace. User with access to the `system` namespace may query for K8s events across
	// all namespaces in a K8s Cluster.
	K8SEventsQuery(context.Context, *K8SEventsRequest) (*LogResponse, error)
	// K8s Events Scroll Query
	//
	// x-displayName: "K8s Events Scroll Query"
	// The response for K8s events query contain no more than 500 events.
	// One can use scroll request to scroll through more than 500 events or all events
	// in multiple batches. Empty scroll_id in the response indicates no more messages to fetch (EOF).
	K8SEventsScrollQuery(context.Context, *LogScrollRequest) (*LogResponse, error)
	// K8s Events Scroll Query V2
	//
	// x-displayName: "K8s Events Scroll Query V2"
	// The response for K8s events query contain no more than 500 events.
	// One can use scroll request to scroll through more than 500 events or all events
	// in multiple batches. Empty scroll_id in the response indicates no more messages to fetch (EOF).
	// This uses post request to pass the scroll_id in the body.
	K8SEventsScrollQueryV2(context.Context, *LogScrollRequest) (*LogResponse, error)
	// K8s Events Aggregation Query
	//
	// x-displayName: "K8s Events Aggregation Query"
	// Request to get summary/analytics data for the K8s events that matches the criteria in request for a given namespace.
	// User with access to the `system` namespace may query aggregated data for K8s events across all namespaces in a K8s Cluster.
	K8SEventsAggregationQuery(context.Context, *K8SEventsAggregationRequest) (*LogAggregationResponse, error)
	// Firewall Logs Query
	//
	// x-displayName: "Firewall Logs Query"
	// Request to get access logs and network logs with policy hits.
	// By default, the firewall logs in the response are sorted in the reverse chronological order.
	FirewallLogQuery(context.Context, *FirewallLogRequest) (*LogResponse, error)
	// Firewall Logs Scroll Query
	//
	// x-displayName: "Firewall Logs Scroll Query"
	// The response for firewall log query contain no more than 500 records.
	// Scroll request is used scroll through more than 500 records or all records that matched the criteria in the
	// firewall log query in multiple batches. EOF is indicated by empty scroll_id in the response.
	FirewallLogScrollQuery(context.Context, *LogScrollRequest) (*LogResponse, error)
	// Firewall Logs Scroll Query V2
	//
	// x-displayName: "Firewall Logs Scroll Query V2"
	// The response for firewall log query contain no more than 500 records.
	// Scroll request is used scroll through more than 500 records or all records that matched the criteria in the
	// firewall log query in multiple batches. EOF is indicated by empty scroll_id in the response.
	// This uses post request to pass the scroll_id in the body.
	FirewallLogScrollQueryV2(context.Context, *LogScrollRequest) (*LogResponse, error)
	// Firewall Logs Aggregation Query
	//
	// x-displayName: "Firewall Logs Aggregation Query"
	// Request to get summary/analytics data for the firewall logs that matches the query in request for a given namespace.
	FirewallLogAggregationQuery(context.Context, *FirewallLogAggregationRequest) (*LogAggregationResponse, error)
}

// UnimplementedCustomAPIServer can be embedded to have forward compatible implementations.
type UnimplementedCustomAPIServer struct {
}

func (*UnimplementedCustomAPIServer) AccessLogQueryV2(ctx context.Context, req *AccessLogRequestV2) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccessLogQueryV2 not implemented")
}
func (*UnimplementedCustomAPIServer) AccessLogScrollQuery(ctx context.Context, req *LogScrollRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccessLogScrollQuery not implemented")
}
func (*UnimplementedCustomAPIServer) AccessLogScrollQueryV2(ctx context.Context, req *LogScrollRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccessLogScrollQueryV2 not implemented")
}
func (*UnimplementedCustomAPIServer) AccessLogAggregationQuery(ctx context.Context, req *AccessLogAggregationRequest) (*LogAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccessLogAggregationQuery not implemented")
}
func (*UnimplementedCustomAPIServer) AuditLogQueryV2(ctx context.Context, req *AuditLogRequestV2) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuditLogQueryV2 not implemented")
}
func (*UnimplementedCustomAPIServer) AuditLogScrollQuery(ctx context.Context, req *LogScrollRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuditLogScrollQuery not implemented")
}
func (*UnimplementedCustomAPIServer) AuditLogScrollQueryV2(ctx context.Context, req *LogScrollRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuditLogScrollQueryV2 not implemented")
}
func (*UnimplementedCustomAPIServer) AuditLogAggregationQuery(ctx context.Context, req *AuditLogAggregationRequest) (*LogAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuditLogAggregationQuery not implemented")
}
func (*UnimplementedCustomAPIServer) VK8SAuditLogQuery(ctx context.Context, req *VK8SAuditLogRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VK8SAuditLogQuery not implemented")
}
func (*UnimplementedCustomAPIServer) VK8SAuditLogScrollQuery(ctx context.Context, req *LogScrollRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VK8SAuditLogScrollQuery not implemented")
}
func (*UnimplementedCustomAPIServer) VK8SAuditLogScrollQueryV2(ctx context.Context, req *LogScrollRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VK8SAuditLogScrollQueryV2 not implemented")
}
func (*UnimplementedCustomAPIServer) VK8SAuditLogAggregationQuery(ctx context.Context, req *VK8SAuditLogAggregationRequest) (*LogAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VK8SAuditLogAggregationQuery not implemented")
}
func (*UnimplementedCustomAPIServer) K8SAuditLogQuery(ctx context.Context, req *K8SAuditLogRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method K8SAuditLogQuery not implemented")
}
func (*UnimplementedCustomAPIServer) K8SAuditLogScrollQuery(ctx context.Context, req *LogScrollRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method K8SAuditLogScrollQuery not implemented")
}
func (*UnimplementedCustomAPIServer) K8SAuditLogScrollQueryV2(ctx context.Context, req *LogScrollRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method K8SAuditLogScrollQueryV2 not implemented")
}
func (*UnimplementedCustomAPIServer) K8SAuditLogAggregationQuery(ctx context.Context, req *K8SAuditLogAggregationRequest) (*LogAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method K8SAuditLogAggregationQuery not implemented")
}
func (*UnimplementedCustomAPIServer) VK8SEventsQuery(ctx context.Context, req *VK8SEventsRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VK8SEventsQuery not implemented")
}
func (*UnimplementedCustomAPIServer) VK8SEventsScrollQuery(ctx context.Context, req *LogScrollRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VK8SEventsScrollQuery not implemented")
}
func (*UnimplementedCustomAPIServer) VK8SEventsScrollQueryV2(ctx context.Context, req *LogScrollRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VK8SEventsScrollQueryV2 not implemented")
}
func (*UnimplementedCustomAPIServer) VK8SEventsAggregationQuery(ctx context.Context, req *VK8SEventsAggregationRequest) (*LogAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VK8SEventsAggregationQuery not implemented")
}
func (*UnimplementedCustomAPIServer) K8SEventsQuery(ctx context.Context, req *K8SEventsRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method K8SEventsQuery not implemented")
}
func (*UnimplementedCustomAPIServer) K8SEventsScrollQuery(ctx context.Context, req *LogScrollRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method K8SEventsScrollQuery not implemented")
}
func (*UnimplementedCustomAPIServer) K8SEventsScrollQueryV2(ctx context.Context, req *LogScrollRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method K8SEventsScrollQueryV2 not implemented")
}
func (*UnimplementedCustomAPIServer) K8SEventsAggregationQuery(ctx context.Context, req *K8SEventsAggregationRequest) (*LogAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method K8SEventsAggregationQuery not implemented")
}
func (*UnimplementedCustomAPIServer) FirewallLogQuery(ctx context.Context, req *FirewallLogRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FirewallLogQuery not implemented")
}
func (*UnimplementedCustomAPIServer) FirewallLogScrollQuery(ctx context.Context, req *LogScrollRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FirewallLogScrollQuery not implemented")
}
func (*UnimplementedCustomAPIServer) FirewallLogScrollQueryV2(ctx context.Context, req *LogScrollRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FirewallLogScrollQueryV2 not implemented")
}
func (*UnimplementedCustomAPIServer) FirewallLogAggregationQuery(ctx context.Context, req *FirewallLogAggregationRequest) (*LogAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FirewallLogAggregationQuery not implemented")
}

func RegisterCustomAPIServer(s *grpc.Server, srv CustomAPIServer) {
	s.RegisterService(&_CustomAPI_serviceDesc, srv)
}

func _CustomAPI_AccessLogQueryV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessLogRequestV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).AccessLogQueryV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/AccessLogQueryV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).AccessLogQueryV2(ctx, req.(*AccessLogRequestV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_AccessLogScrollQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogScrollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).AccessLogScrollQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/AccessLogScrollQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).AccessLogScrollQuery(ctx, req.(*LogScrollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_AccessLogScrollQueryV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogScrollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).AccessLogScrollQueryV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/AccessLogScrollQueryV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).AccessLogScrollQueryV2(ctx, req.(*LogScrollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_AccessLogAggregationQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessLogAggregationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).AccessLogAggregationQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/AccessLogAggregationQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).AccessLogAggregationQuery(ctx, req.(*AccessLogAggregationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_AuditLogQueryV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuditLogRequestV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).AuditLogQueryV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/AuditLogQueryV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).AuditLogQueryV2(ctx, req.(*AuditLogRequestV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_AuditLogScrollQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogScrollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).AuditLogScrollQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/AuditLogScrollQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).AuditLogScrollQuery(ctx, req.(*LogScrollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_AuditLogScrollQueryV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogScrollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).AuditLogScrollQueryV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/AuditLogScrollQueryV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).AuditLogScrollQueryV2(ctx, req.(*LogScrollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_AuditLogAggregationQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuditLogAggregationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).AuditLogAggregationQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/AuditLogAggregationQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).AuditLogAggregationQuery(ctx, req.(*AuditLogAggregationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_VK8SAuditLogQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VK8SAuditLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).VK8SAuditLogQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/VK8SAuditLogQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).VK8SAuditLogQuery(ctx, req.(*VK8SAuditLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_VK8SAuditLogScrollQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogScrollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).VK8SAuditLogScrollQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/VK8SAuditLogScrollQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).VK8SAuditLogScrollQuery(ctx, req.(*LogScrollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_VK8SAuditLogScrollQueryV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogScrollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).VK8SAuditLogScrollQueryV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/VK8SAuditLogScrollQueryV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).VK8SAuditLogScrollQueryV2(ctx, req.(*LogScrollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_VK8SAuditLogAggregationQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VK8SAuditLogAggregationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).VK8SAuditLogAggregationQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/VK8SAuditLogAggregationQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).VK8SAuditLogAggregationQuery(ctx, req.(*VK8SAuditLogAggregationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_K8SAuditLogQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(K8SAuditLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).K8SAuditLogQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/K8SAuditLogQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).K8SAuditLogQuery(ctx, req.(*K8SAuditLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_K8SAuditLogScrollQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogScrollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).K8SAuditLogScrollQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/K8SAuditLogScrollQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).K8SAuditLogScrollQuery(ctx, req.(*LogScrollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_K8SAuditLogScrollQueryV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogScrollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).K8SAuditLogScrollQueryV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/K8SAuditLogScrollQueryV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).K8SAuditLogScrollQueryV2(ctx, req.(*LogScrollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_K8SAuditLogAggregationQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(K8SAuditLogAggregationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).K8SAuditLogAggregationQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/K8SAuditLogAggregationQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).K8SAuditLogAggregationQuery(ctx, req.(*K8SAuditLogAggregationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_VK8SEventsQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VK8SEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).VK8SEventsQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/VK8SEventsQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).VK8SEventsQuery(ctx, req.(*VK8SEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_VK8SEventsScrollQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogScrollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).VK8SEventsScrollQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/VK8SEventsScrollQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).VK8SEventsScrollQuery(ctx, req.(*LogScrollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_VK8SEventsScrollQueryV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogScrollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).VK8SEventsScrollQueryV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/VK8SEventsScrollQueryV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).VK8SEventsScrollQueryV2(ctx, req.(*LogScrollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_VK8SEventsAggregationQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VK8SEventsAggregationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).VK8SEventsAggregationQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/VK8SEventsAggregationQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).VK8SEventsAggregationQuery(ctx, req.(*VK8SEventsAggregationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_K8SEventsQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(K8SEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).K8SEventsQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/K8SEventsQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).K8SEventsQuery(ctx, req.(*K8SEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_K8SEventsScrollQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogScrollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).K8SEventsScrollQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/K8SEventsScrollQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).K8SEventsScrollQuery(ctx, req.(*LogScrollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_K8SEventsScrollQueryV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogScrollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).K8SEventsScrollQueryV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/K8SEventsScrollQueryV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).K8SEventsScrollQueryV2(ctx, req.(*LogScrollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_K8SEventsAggregationQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(K8SEventsAggregationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).K8SEventsAggregationQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/K8SEventsAggregationQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).K8SEventsAggregationQuery(ctx, req.(*K8SEventsAggregationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_FirewallLogQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FirewallLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).FirewallLogQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/FirewallLogQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).FirewallLogQuery(ctx, req.(*FirewallLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_FirewallLogScrollQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogScrollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).FirewallLogScrollQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/FirewallLogScrollQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).FirewallLogScrollQuery(ctx, req.(*LogScrollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_FirewallLogScrollQueryV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogScrollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).FirewallLogScrollQueryV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/FirewallLogScrollQueryV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).FirewallLogScrollQueryV2(ctx, req.(*LogScrollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_FirewallLogAggregationQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FirewallLogAggregationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).FirewallLogAggregationQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.log.CustomAPI/FirewallLogAggregationQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).FirewallLogAggregationQuery(ctx, req.(*FirewallLogAggregationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CustomAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ves.io.schema.log.CustomAPI",
	HandlerType: (*CustomAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AccessLogQueryV2",
			Handler:    _CustomAPI_AccessLogQueryV2_Handler,
		},
		{
			MethodName: "AccessLogScrollQuery",
			Handler:    _CustomAPI_AccessLogScrollQuery_Handler,
		},
		{
			MethodName: "AccessLogScrollQueryV2",
			Handler:    _CustomAPI_AccessLogScrollQueryV2_Handler,
		},
		{
			MethodName: "AccessLogAggregationQuery",
			Handler:    _CustomAPI_AccessLogAggregationQuery_Handler,
		},
		{
			MethodName: "AuditLogQueryV2",
			Handler:    _CustomAPI_AuditLogQueryV2_Handler,
		},
		{
			MethodName: "AuditLogScrollQuery",
			Handler:    _CustomAPI_AuditLogScrollQuery_Handler,
		},
		{
			MethodName: "AuditLogScrollQueryV2",
			Handler:    _CustomAPI_AuditLogScrollQueryV2_Handler,
		},
		{
			MethodName: "AuditLogAggregationQuery",
			Handler:    _CustomAPI_AuditLogAggregationQuery_Handler,
		},
		{
			MethodName: "VK8SAuditLogQuery",
			Handler:    _CustomAPI_VK8SAuditLogQuery_Handler,
		},
		{
			MethodName: "VK8SAuditLogScrollQuery",
			Handler:    _CustomAPI_VK8SAuditLogScrollQuery_Handler,
		},
		{
			MethodName: "VK8SAuditLogScrollQueryV2",
			Handler:    _CustomAPI_VK8SAuditLogScrollQueryV2_Handler,
		},
		{
			MethodName: "VK8SAuditLogAggregationQuery",
			Handler:    _CustomAPI_VK8SAuditLogAggregationQuery_Handler,
		},
		{
			MethodName: "K8SAuditLogQuery",
			Handler:    _CustomAPI_K8SAuditLogQuery_Handler,
		},
		{
			MethodName: "K8SAuditLogScrollQuery",
			Handler:    _CustomAPI_K8SAuditLogScrollQuery_Handler,
		},
		{
			MethodName: "K8SAuditLogScrollQueryV2",
			Handler:    _CustomAPI_K8SAuditLogScrollQueryV2_Handler,
		},
		{
			MethodName: "K8SAuditLogAggregationQuery",
			Handler:    _CustomAPI_K8SAuditLogAggregationQuery_Handler,
		},
		{
			MethodName: "VK8SEventsQuery",
			Handler:    _CustomAPI_VK8SEventsQuery_Handler,
		},
		{
			MethodName: "VK8SEventsScrollQuery",
			Handler:    _CustomAPI_VK8SEventsScrollQuery_Handler,
		},
		{
			MethodName: "VK8SEventsScrollQueryV2",
			Handler:    _CustomAPI_VK8SEventsScrollQueryV2_Handler,
		},
		{
			MethodName: "VK8SEventsAggregationQuery",
			Handler:    _CustomAPI_VK8SEventsAggregationQuery_Handler,
		},
		{
			MethodName: "K8SEventsQuery",
			Handler:    _CustomAPI_K8SEventsQuery_Handler,
		},
		{
			MethodName: "K8SEventsScrollQuery",
			Handler:    _CustomAPI_K8SEventsScrollQuery_Handler,
		},
		{
			MethodName: "K8SEventsScrollQueryV2",
			Handler:    _CustomAPI_K8SEventsScrollQueryV2_Handler,
		},
		{
			MethodName: "K8SEventsAggregationQuery",
			Handler:    _CustomAPI_K8SEventsAggregationQuery_Handler,
		},
		{
			MethodName: "FirewallLogQuery",
			Handler:    _CustomAPI_FirewallLogQuery_Handler,
		},
		{
			MethodName: "FirewallLogScrollQuery",
			Handler:    _CustomAPI_FirewallLogScrollQuery_Handler,
		},
		{
			MethodName: "FirewallLogScrollQueryV2",
			Handler:    _CustomAPI_FirewallLogScrollQueryV2_Handler,
		},
		{
			MethodName: "FirewallLogAggregationQuery",
			Handler:    _CustomAPI_FirewallLogAggregationQuery_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ves.io/schema/log/public_customapi.proto",
}

func (m *AccessLogRequestV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessLogRequestV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessLogRequestV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Scroll {
		i--
		if m.Scroll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Limit != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x30
	}
	if m.Sort != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccessLogAggregationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessLogAggregationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessLogAggregationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuditLogRequestV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuditLogRequestV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuditLogRequestV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Scroll {
		i--
		if m.Scroll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Limit != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x30
	}
	if m.Sort != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuditLogAggregationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuditLogAggregationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuditLogAggregationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VK8SAuditLogRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VK8SAuditLogRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VK8SAuditLogRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Scroll {
		i--
		if m.Scroll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Limit != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x30
	}
	if m.Sort != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VK8SAuditLogAggregationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VK8SAuditLogAggregationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VK8SAuditLogAggregationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *K8SAuditLogRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SAuditLogRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SAuditLogRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Scroll {
		i--
		if m.Scroll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Limit != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x38
	}
	if m.Sort != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x30
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Site) > 0 {
		i -= len(m.Site)
		copy(dAtA[i:], m.Site)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Site)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *K8SAuditLogAggregationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SAuditLogAggregationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SAuditLogAggregationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Site) > 0 {
		i -= len(m.Site)
		copy(dAtA[i:], m.Site)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Site)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VK8SEventsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VK8SEventsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VK8SEventsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Scroll {
		i--
		if m.Scroll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Limit != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x30
	}
	if m.Sort != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VK8SEventsAggregationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VK8SEventsAggregationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VK8SEventsAggregationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *K8SEventsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SEventsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SEventsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Scroll {
		i--
		if m.Scroll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Limit != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x38
	}
	if m.Sort != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x30
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Site) > 0 {
		i -= len(m.Site)
		copy(dAtA[i:], m.Site)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Site)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *K8SEventsAggregationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SEventsAggregationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SEventsAggregationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Site) > 0 {
		i -= len(m.Site)
		copy(dAtA[i:], m.Site)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Site)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FirewallLogRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirewallLogRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FirewallLogRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Scroll {
		i--
		if m.Scroll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Limit != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x30
	}
	if m.Sort != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FirewallLogAggregationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirewallLogAggregationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FirewallLogAggregationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogScrollRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogScrollRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogScrollRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ScrollId) > 0 {
		i -= len(m.ScrollId)
		copy(dAtA[i:], m.ScrollId)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ScrollId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.TotalHits != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.TotalHits))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ScrollId) > 0 {
		i -= len(m.ScrollId)
		copy(dAtA[i:], m.ScrollId)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ScrollId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Logs) > 0 {
		for iNdEx := len(m.Logs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Logs[iNdEx])
			copy(dAtA[i:], m.Logs[iNdEx])
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Logs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LogAggregationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogAggregationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogAggregationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.TotalHits != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.TotalHits))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPublicCustomapi(dAtA []byte, offset int, v uint64) int {
	offset -= sovPublicCustomapi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AccessLogRequestV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Sort != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Sort))
	}
	if m.Limit != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Limit))
	}
	if m.Scroll {
		n += 2
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AccessLogAggregationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AuditLogRequestV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Sort != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Sort))
	}
	if m.Limit != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Limit))
	}
	if m.Scroll {
		n += 2
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AuditLogAggregationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VK8SAuditLogRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Sort != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Sort))
	}
	if m.Limit != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Limit))
	}
	if m.Scroll {
		n += 2
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VK8SAuditLogAggregationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *K8SAuditLogRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Site)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Sort != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Sort))
	}
	if m.Limit != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Limit))
	}
	if m.Scroll {
		n += 2
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *K8SAuditLogAggregationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Site)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VK8SEventsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Sort != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Sort))
	}
	if m.Limit != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Limit))
	}
	if m.Scroll {
		n += 2
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VK8SEventsAggregationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *K8SEventsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Site)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Sort != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Sort))
	}
	if m.Limit != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Limit))
	}
	if m.Scroll {
		n += 2
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *K8SEventsAggregationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Site)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FirewallLogRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Sort != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Sort))
	}
	if m.Limit != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Limit))
	}
	if m.Scroll {
		n += 2
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FirewallLogAggregationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *LogScrollRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.ScrollId)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *LogResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Logs) > 0 {
		for _, s := range m.Logs {
			l = len(s)
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	l = len(m.ScrollId)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.TotalHits != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.TotalHits))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *LogAggregationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalHits != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.TotalHits))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func sovPublicCustomapi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPublicCustomapi(x uint64) (n int) {
	return sovPublicCustomapi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AccessLogRequestV2) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*access_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&AccessLogRequestV2{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Sort:` + fmt.Sprintf("%v", this.Sort) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Scroll:` + fmt.Sprintf("%v", this.Scroll) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *AccessLogAggregationRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*access_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&AccessLogAggregationRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuditLogRequestV2) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*audit_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&AuditLogRequestV2{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Sort:` + fmt.Sprintf("%v", this.Sort) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Scroll:` + fmt.Sprintf("%v", this.Scroll) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuditLogAggregationRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*audit_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&AuditLogAggregationRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *VK8SAuditLogRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*vk8s_audit_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&VK8SAuditLogRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Sort:` + fmt.Sprintf("%v", this.Sort) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Scroll:` + fmt.Sprintf("%v", this.Scroll) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *VK8SAuditLogAggregationRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*vk8s_audit_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&VK8SAuditLogAggregationRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAuditLogRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*k8s_audit_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&K8SAuditLogRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Site:` + fmt.Sprintf("%v", this.Site) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Sort:` + fmt.Sprintf("%v", this.Sort) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Scroll:` + fmt.Sprintf("%v", this.Scroll) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAuditLogAggregationRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*k8s_audit_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&K8SAuditLogAggregationRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Site:` + fmt.Sprintf("%v", this.Site) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *VK8SEventsRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*vk8s_events.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&VK8SEventsRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Sort:` + fmt.Sprintf("%v", this.Sort) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Scroll:` + fmt.Sprintf("%v", this.Scroll) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *VK8SEventsAggregationRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*vk8s_events.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&VK8SEventsAggregationRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SEventsRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*k8s_events.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&K8SEventsRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Site:` + fmt.Sprintf("%v", this.Site) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Sort:` + fmt.Sprintf("%v", this.Sort) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Scroll:` + fmt.Sprintf("%v", this.Scroll) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SEventsAggregationRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*k8s_events.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&K8SEventsAggregationRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Site:` + fmt.Sprintf("%v", this.Site) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *FirewallLogRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*firewall_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&FirewallLogRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Sort:` + fmt.Sprintf("%v", this.Sort) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Scroll:` + fmt.Sprintf("%v", this.Scroll) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *FirewallLogAggregationRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*firewall_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&FirewallLogAggregationRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *LogScrollRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LogScrollRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`ScrollId:` + fmt.Sprintf("%v", this.ScrollId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LogResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&LogResponse{`,
		`Logs:` + fmt.Sprintf("%v", this.Logs) + `,`,
		`ScrollId:` + fmt.Sprintf("%v", this.ScrollId) + `,`,
		`TotalHits:` + fmt.Sprintf("%v", this.TotalHits) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *LogAggregationResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&LogAggregationResponse{`,
		`TotalHits:` + fmt.Sprintf("%v", this.TotalHits) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringPublicCustomapi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AccessLogRequestV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessLogRequestV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessLogRequestV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= schema.SortOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scroll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Scroll = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*access_log.AggregationRequest)
			}
			var mapkey string
			var mapvalue *access_log.AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &access_log.AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessLogAggregationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessLogAggregationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessLogAggregationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*access_log.AggregationRequest)
			}
			var mapkey string
			var mapvalue *access_log.AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &access_log.AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuditLogRequestV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditLogRequestV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditLogRequestV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= schema.SortOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scroll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Scroll = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*audit_log.AggregationRequest)
			}
			var mapkey string
			var mapvalue *audit_log.AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &audit_log.AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuditLogAggregationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditLogAggregationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditLogAggregationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*audit_log.AggregationRequest)
			}
			var mapkey string
			var mapvalue *audit_log.AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &audit_log.AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VK8SAuditLogRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VK8SAuditLogRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VK8SAuditLogRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= schema.SortOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scroll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Scroll = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*vk8s_audit_log.AggregationRequest)
			}
			var mapkey string
			var mapvalue *vk8s_audit_log.AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &vk8s_audit_log.AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VK8SAuditLogAggregationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VK8SAuditLogAggregationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VK8SAuditLogAggregationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*vk8s_audit_log.AggregationRequest)
			}
			var mapkey string
			var mapvalue *vk8s_audit_log.AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &vk8s_audit_log.AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SAuditLogRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SAuditLogRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SAuditLogRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= schema.SortOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scroll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Scroll = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*k8s_audit_log.AggregationRequest)
			}
			var mapkey string
			var mapvalue *k8s_audit_log.AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &k8s_audit_log.AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SAuditLogAggregationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SAuditLogAggregationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SAuditLogAggregationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*k8s_audit_log.AggregationRequest)
			}
			var mapkey string
			var mapvalue *k8s_audit_log.AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &k8s_audit_log.AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VK8SEventsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VK8SEventsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VK8SEventsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= schema.SortOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scroll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Scroll = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*vk8s_events.AggregationRequest)
			}
			var mapkey string
			var mapvalue *vk8s_events.AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &vk8s_events.AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VK8SEventsAggregationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VK8SEventsAggregationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VK8SEventsAggregationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*vk8s_events.AggregationRequest)
			}
			var mapkey string
			var mapvalue *vk8s_events.AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &vk8s_events.AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SEventsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SEventsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SEventsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= schema.SortOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scroll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Scroll = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*k8s_events.AggregationRequest)
			}
			var mapkey string
			var mapvalue *k8s_events.AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &k8s_events.AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SEventsAggregationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SEventsAggregationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SEventsAggregationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*k8s_events.AggregationRequest)
			}
			var mapkey string
			var mapvalue *k8s_events.AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &k8s_events.AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirewallLogRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirewallLogRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirewallLogRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= schema.SortOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scroll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Scroll = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*firewall_log.AggregationRequest)
			}
			var mapkey string
			var mapvalue *firewall_log.AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &firewall_log.AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirewallLogAggregationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirewallLogAggregationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirewallLogAggregationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*firewall_log.AggregationRequest)
			}
			var mapkey string
			var mapvalue *firewall_log.AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &firewall_log.AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogScrollRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogScrollRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogScrollRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScrollId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScrollId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logs = append(m.Logs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScrollId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScrollId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHits", wireType)
			}
			m.TotalHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*LogAggregationData)
			}
			var mapkey string
			var mapvalue *LogAggregationData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &LogAggregationData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogAggregationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogAggregationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogAggregationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHits", wireType)
			}
			m.TotalHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*LogAggregationData)
			}
			var mapkey string
			var mapvalue *LogAggregationData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &LogAggregationData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPublicCustomapi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPublicCustomapi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPublicCustomapi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPublicCustomapi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPublicCustomapi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPublicCustomapi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPublicCustomapi = fmt.Errorf("proto: unexpected end of group")
)
