// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package log

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CardinalityAggregationData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CardinalityAggregationData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CardinalityAggregationData) DeepCopy() *CardinalityAggregationData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CardinalityAggregationData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CardinalityAggregationData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CardinalityAggregationData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CardinalityAggregationDataValidator().Validate(ctx, m, opts...)
}

type ValidateCardinalityAggregationData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCardinalityAggregationData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CardinalityAggregationData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CardinalityAggregationData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["count"]; exists {

		vOpts := append(opts, db.WithValidateField("count"))
		if err := fv(ctx, m.GetCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["trend_value"]; exists {

		vOpts := append(opts, db.WithValidateField("trend_value"))
		if err := fv(ctx, m.GetTrendValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCardinalityAggregationDataValidator = func() *ValidateCardinalityAggregationData {
	v := &ValidateCardinalityAggregationData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CardinalityAggregationDataValidator() db.Validator {
	return DefaultCardinalityAggregationDataValidator
}

// augmented methods on protoc/std generated struct

func (m *DateAggregationBucket) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DateAggregationBucket) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DateAggregationBucket) DeepCopy() *DateAggregationBucket {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DateAggregationBucket{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DateAggregationBucket) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DateAggregationBucket) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DateAggregationBucketValidator().Validate(ctx, m, opts...)
}

type ValidateDateAggregationBucket struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDateAggregationBucket) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DateAggregationBucket)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DateAggregationBucket got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["count"]; exists {

		vOpts := append(opts, db.WithValidateField("count"))
		if err := fv(ctx, m.GetCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sub_aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("sub_aggs"))
		for key, value := range m.GetSubAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["time"]; exists {

		vOpts := append(opts, db.WithValidateField("time"))
		if err := fv(ctx, m.GetTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["trend_value"]; exists {

		vOpts := append(opts, db.WithValidateField("trend_value"))
		if err := fv(ctx, m.GetTrendValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDateAggregationBucketValidator = func() *ValidateDateAggregationBucket {
	v := &ValidateDateAggregationBucket{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DateAggregationBucketValidator() db.Validator {
	return DefaultDateAggregationBucketValidator
}

// augmented methods on protoc/std generated struct

func (m *DateAggregationData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DateAggregationData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DateAggregationData) DeepCopy() *DateAggregationData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DateAggregationData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DateAggregationData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DateAggregationData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DateAggregationDataValidator().Validate(ctx, m, opts...)
}

type ValidateDateAggregationData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDateAggregationData) StepValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for step")
	}

	return validatorFn, nil
}

func (v *ValidateDateAggregationData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DateAggregationData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DateAggregationData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["buckets"]; exists {

		vOpts := append(opts, db.WithValidateField("buckets"))
		for idx, item := range m.GetBuckets() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["step"]; exists {

		vOpts := append(opts, db.WithValidateField("step"))
		if err := fv(ctx, m.GetStep(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDateAggregationDataValidator = func() *ValidateDateAggregationData {
	v := &ValidateDateAggregationData{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStep := v.StepValidationRuleHandler
	rulesStep := map[string]string{
		"ves.io.schema.rules.string.query_step": "true",
	}
	vFn, err = vrhStep(rulesStep)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DateAggregationData.step: %s", err)
		panic(errMsg)
	}
	v.FldValidators["step"] = vFn

	return v
}()

func DateAggregationDataValidator() db.Validator {
	return DefaultDateAggregationDataValidator
}

// augmented methods on protoc/std generated struct

func (m *DateSubAggregationData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DateSubAggregationData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DateSubAggregationData) DeepCopy() *DateSubAggregationData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DateSubAggregationData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DateSubAggregationData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DateSubAggregationData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DateSubAggregationDataValidator().Validate(ctx, m, opts...)
}

type ValidateDateSubAggregationData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDateSubAggregationData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DateSubAggregationData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DateSubAggregationData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["field_aggregation"]; exists {

		vOpts := append(opts, db.WithValidateField("field_aggregation"))
		if err := fv(ctx, m.GetFieldAggregation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["multi_field_aggregation"]; exists {

		vOpts := append(opts, db.WithValidateField("multi_field_aggregation"))
		if err := fv(ctx, m.GetMultiFieldAggregation(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDateSubAggregationDataValidator = func() *ValidateDateSubAggregationData {
	v := &ValidateDateSubAggregationData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DateSubAggregationDataValidator() db.Validator {
	return DefaultDateSubAggregationDataValidator
}

// augmented methods on protoc/std generated struct

func (m *FieldAggregationBucket) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FieldAggregationBucket) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FieldAggregationBucket) DeepCopy() *FieldAggregationBucket {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FieldAggregationBucket{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FieldAggregationBucket) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FieldAggregationBucket) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FieldAggregationBucketValidator().Validate(ctx, m, opts...)
}

type ValidateFieldAggregationBucket struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFieldAggregationBucket) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FieldAggregationBucket)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FieldAggregationBucket got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["count"]; exists {

		vOpts := append(opts, db.WithValidateField("count"))
		if err := fv(ctx, m.GetCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["order_by"]; exists {

		vOpts := append(opts, db.WithValidateField("order_by"))
		if err := fv(ctx, m.GetOrderBy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sub_aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("sub_aggs"))
		for key, value := range m.GetSubAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["trend_value"]; exists {

		vOpts := append(opts, db.WithValidateField("trend_value"))
		if err := fv(ctx, m.GetTrendValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFieldAggregationBucketValidator = func() *ValidateFieldAggregationBucket {
	v := &ValidateFieldAggregationBucket{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FieldAggregationBucketValidator() db.Validator {
	return DefaultFieldAggregationBucketValidator
}

// augmented methods on protoc/std generated struct

func (m *FieldAggregationData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FieldAggregationData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FieldAggregationData) DeepCopy() *FieldAggregationData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FieldAggregationData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FieldAggregationData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FieldAggregationData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FieldAggregationDataValidator().Validate(ctx, m, opts...)
}

type ValidateFieldAggregationData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFieldAggregationData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FieldAggregationData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FieldAggregationData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["buckets"]; exists {

		vOpts := append(opts, db.WithValidateField("buckets"))
		for idx, item := range m.GetBuckets() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFieldAggregationDataValidator = func() *ValidateFieldAggregationData {
	v := &ValidateFieldAggregationData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FieldAggregationDataValidator() db.Validator {
	return DefaultFieldAggregationDataValidator
}

// augmented methods on protoc/std generated struct

func (m *FieldSubAggregationBucket) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FieldSubAggregationBucket) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FieldSubAggregationBucket) DeepCopy() *FieldSubAggregationBucket {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FieldSubAggregationBucket{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FieldSubAggregationBucket) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FieldSubAggregationBucket) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FieldSubAggregationBucketValidator().Validate(ctx, m, opts...)
}

type ValidateFieldSubAggregationBucket struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFieldSubAggregationBucket) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FieldSubAggregationBucket)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FieldSubAggregationBucket got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["count"]; exists {

		vOpts := append(opts, db.WithValidateField("count"))
		if err := fv(ctx, m.GetCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["order_by"]; exists {

		vOpts := append(opts, db.WithValidateField("order_by"))
		if err := fv(ctx, m.GetOrderBy(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFieldSubAggregationBucketValidator = func() *ValidateFieldSubAggregationBucket {
	v := &ValidateFieldSubAggregationBucket{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FieldSubAggregationBucketValidator() db.Validator {
	return DefaultFieldSubAggregationBucketValidator
}

// augmented methods on protoc/std generated struct

func (m *FieldSubAggregationData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FieldSubAggregationData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FieldSubAggregationData) DeepCopy() *FieldSubAggregationData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FieldSubAggregationData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FieldSubAggregationData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FieldSubAggregationData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FieldSubAggregationDataValidator().Validate(ctx, m, opts...)
}

type ValidateFieldSubAggregationData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFieldSubAggregationData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FieldSubAggregationData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FieldSubAggregationData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["buckets"]; exists {

		vOpts := append(opts, db.WithValidateField("buckets"))
		for idx, item := range m.GetBuckets() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["cardinality_aggregation"]; exists {

		vOpts := append(opts, db.WithValidateField("cardinality_aggregation"))
		if err := fv(ctx, m.GetCardinalityAggregation(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFieldSubAggregationDataValidator = func() *ValidateFieldSubAggregationData {
	v := &ValidateFieldSubAggregationData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FieldSubAggregationDataValidator() db.Validator {
	return DefaultFieldSubAggregationDataValidator
}

// augmented methods on protoc/std generated struct

func (m *LogAggregationData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LogAggregationData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LogAggregationData) DeepCopy() *LogAggregationData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LogAggregationData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LogAggregationData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LogAggregationData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LogAggregationDataValidator().Validate(ctx, m, opts...)
}

type ValidateLogAggregationData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLogAggregationData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LogAggregationData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LogAggregationData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cardinality_aggregation"]; exists {

		vOpts := append(opts, db.WithValidateField("cardinality_aggregation"))
		if err := fv(ctx, m.GetCardinalityAggregation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["date_aggregation"]; exists {

		vOpts := append(opts, db.WithValidateField("date_aggregation"))
		if err := fv(ctx, m.GetDateAggregation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["field_aggregation"]; exists {

		vOpts := append(opts, db.WithValidateField("field_aggregation"))
		if err := fv(ctx, m.GetFieldAggregation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["metrics_aggregation"]; exists {

		vOpts := append(opts, db.WithValidateField("metrics_aggregation"))
		if err := fv(ctx, m.GetMetricsAggregation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["multi_field_aggregation"]; exists {

		vOpts := append(opts, db.WithValidateField("multi_field_aggregation"))
		if err := fv(ctx, m.GetMultiFieldAggregation(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLogAggregationDataValidator = func() *ValidateLogAggregationData {
	v := &ValidateLogAggregationData{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["date_aggregation"] = DateAggregationDataValidator().Validate

	return v
}()

func LogAggregationDataValidator() db.Validator {
	return DefaultLogAggregationDataValidator
}

// augmented methods on protoc/std generated struct

func (m *MetricsAggregationData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MetricsAggregationData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MetricsAggregationData) DeepCopy() *MetricsAggregationData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MetricsAggregationData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MetricsAggregationData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MetricsAggregationData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MetricsAggregationDataValidator().Validate(ctx, m, opts...)
}

type ValidateMetricsAggregationData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMetricsAggregationData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MetricsAggregationData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MetricsAggregationData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAggregationType().(type) {
	case *MetricsAggregationData_Percentile:
		if fv, exists := v.FldValidators["aggregation_type.percentile"]; exists {
			val := m.GetAggregationType().(*MetricsAggregationData_Percentile).Percentile
			vOpts := append(opts,
				db.WithValidateField("aggregation_type"),
				db.WithValidateField("percentile"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMetricsAggregationDataValidator = func() *ValidateMetricsAggregationData {
	v := &ValidateMetricsAggregationData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MetricsAggregationDataValidator() db.Validator {
	return DefaultMetricsAggregationDataValidator
}

// augmented methods on protoc/std generated struct

func (m *MultiFieldAggregationBucket) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MultiFieldAggregationBucket) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MultiFieldAggregationBucket) DeepCopy() *MultiFieldAggregationBucket {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MultiFieldAggregationBucket{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MultiFieldAggregationBucket) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MultiFieldAggregationBucket) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MultiFieldAggregationBucketValidator().Validate(ctx, m, opts...)
}

type ValidateMultiFieldAggregationBucket struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMultiFieldAggregationBucket) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MultiFieldAggregationBucket)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MultiFieldAggregationBucket got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["count"]; exists {

		vOpts := append(opts, db.WithValidateField("count"))
		if err := fv(ctx, m.GetCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["keys"]; exists {

		vOpts := append(opts, db.WithValidateField("keys"))
		for key, value := range m.GetKeys() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["order_by"]; exists {

		vOpts := append(opts, db.WithValidateField("order_by"))
		if err := fv(ctx, m.GetOrderBy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sub_aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("sub_aggs"))
		for key, value := range m.GetSubAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMultiFieldAggregationBucketValidator = func() *ValidateMultiFieldAggregationBucket {
	v := &ValidateMultiFieldAggregationBucket{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MultiFieldAggregationBucketValidator() db.Validator {
	return DefaultMultiFieldAggregationBucketValidator
}

// augmented methods on protoc/std generated struct

func (m *MultiFieldAggregationData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MultiFieldAggregationData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MultiFieldAggregationData) DeepCopy() *MultiFieldAggregationData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MultiFieldAggregationData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MultiFieldAggregationData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MultiFieldAggregationData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MultiFieldAggregationDataValidator().Validate(ctx, m, opts...)
}

type ValidateMultiFieldAggregationData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMultiFieldAggregationData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MultiFieldAggregationData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MultiFieldAggregationData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["buckets"]; exists {

		vOpts := append(opts, db.WithValidateField("buckets"))
		for idx, item := range m.GetBuckets() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMultiFieldAggregationDataValidator = func() *ValidateMultiFieldAggregationData {
	v := &ValidateMultiFieldAggregationData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MultiFieldAggregationDataValidator() db.Validator {
	return DefaultMultiFieldAggregationDataValidator
}

// augmented methods on protoc/std generated struct

func (m *MultiFieldSubAggregationData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MultiFieldSubAggregationData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MultiFieldSubAggregationData) DeepCopy() *MultiFieldSubAggregationData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MultiFieldSubAggregationData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MultiFieldSubAggregationData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MultiFieldSubAggregationData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MultiFieldSubAggregationDataValidator().Validate(ctx, m, opts...)
}

type ValidateMultiFieldSubAggregationData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMultiFieldSubAggregationData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MultiFieldSubAggregationData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MultiFieldSubAggregationData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cardinality_aggregation"]; exists {

		vOpts := append(opts, db.WithValidateField("cardinality_aggregation"))
		if err := fv(ctx, m.GetCardinalityAggregation(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMultiFieldSubAggregationDataValidator = func() *ValidateMultiFieldSubAggregationData {
	v := &ValidateMultiFieldSubAggregationData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MultiFieldSubAggregationDataValidator() db.Validator {
	return DefaultMultiFieldSubAggregationDataValidator
}

// augmented methods on protoc/std generated struct

func (m *OrderByData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OrderByData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OrderByData) DeepCopy() *OrderByData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OrderByData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OrderByData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OrderByData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OrderByDataValidator().Validate(ctx, m, opts...)
}

type ValidateOrderByData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOrderByData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OrderByData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OrderByData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["metrics_aggregation"]; exists {

		vOpts := append(opts, db.WithValidateField("metrics_aggregation"))
		if err := fv(ctx, m.GetMetricsAggregation(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOrderByDataValidator = func() *ValidateOrderByData {
	v := &ValidateOrderByData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func OrderByDataValidator() db.Validator {
	return DefaultOrderByDataValidator
}

// augmented methods on protoc/std generated struct

func (m *PercentileAggregationData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PercentileAggregationData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PercentileAggregationData) DeepCopy() *PercentileAggregationData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PercentileAggregationData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PercentileAggregationData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PercentileAggregationData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PercentileAggregationDataValidator().Validate(ctx, m, opts...)
}

type ValidatePercentileAggregationData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePercentileAggregationData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PercentileAggregationData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PercentileAggregationData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPercentileAggregationDataValidator = func() *ValidatePercentileAggregationData {
	v := &ValidatePercentileAggregationData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PercentileAggregationDataValidator() db.Validator {
	return DefaultPercentileAggregationDataValidator
}
