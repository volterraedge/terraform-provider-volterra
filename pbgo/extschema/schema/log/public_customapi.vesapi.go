//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//

package log

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create CustomAPI GRPC Client satisfying server.CustomClient
type CustomAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient CustomAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *CustomAPIGrpcClient) doRPCAccessLogAggregationQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &AccessLogAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.AccessLogAggregationRequest", yamlReq)
	}
	rsp, err := c.grpcClient.AccessLogAggregationQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCAccessLogQueryV2(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &AccessLogRequestV2{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.AccessLogRequestV2", yamlReq)
	}
	rsp, err := c.grpcClient.AccessLogQueryV2(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCAccessLogScrollQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &LogScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.LogScrollRequest", yamlReq)
	}
	rsp, err := c.grpcClient.AccessLogScrollQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCAuditLogAggregationQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &AuditLogAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.AuditLogAggregationRequest", yamlReq)
	}
	rsp, err := c.grpcClient.AuditLogAggregationQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCAuditLogQueryV2(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &AuditLogRequestV2{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.AuditLogRequestV2", yamlReq)
	}
	rsp, err := c.grpcClient.AuditLogQueryV2(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCAuditLogScrollQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &LogScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.LogScrollRequest", yamlReq)
	}
	rsp, err := c.grpcClient.AuditLogScrollQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCFirewallLogAggregationQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &FirewallLogAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.FirewallLogAggregationRequest", yamlReq)
	}
	rsp, err := c.grpcClient.FirewallLogAggregationQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCFirewallLogQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &FirewallLogRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.FirewallLogRequest", yamlReq)
	}
	rsp, err := c.grpcClient.FirewallLogQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCFirewallLogScrollQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &LogScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.LogScrollRequest", yamlReq)
	}
	rsp, err := c.grpcClient.FirewallLogScrollQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCK8SAuditLogAggregationQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &K8SAuditLogAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.K8SAuditLogAggregationRequest", yamlReq)
	}
	rsp, err := c.grpcClient.K8SAuditLogAggregationQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCK8SAuditLogQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &K8SAuditLogRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.K8SAuditLogRequest", yamlReq)
	}
	rsp, err := c.grpcClient.K8SAuditLogQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCK8SAuditLogScrollQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &LogScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.LogScrollRequest", yamlReq)
	}
	rsp, err := c.grpcClient.K8SAuditLogScrollQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCK8SEventsAggregationQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &K8SEventsAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.K8SEventsAggregationRequest", yamlReq)
	}
	rsp, err := c.grpcClient.K8SEventsAggregationQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCK8SEventsQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &K8SEventsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.K8SEventsRequest", yamlReq)
	}
	rsp, err := c.grpcClient.K8SEventsQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCK8SEventsScrollQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &LogScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.LogScrollRequest", yamlReq)
	}
	rsp, err := c.grpcClient.K8SEventsScrollQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCVK8SAuditLogAggregationQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &VK8SAuditLogAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.VK8SAuditLogAggregationRequest", yamlReq)
	}
	rsp, err := c.grpcClient.VK8SAuditLogAggregationQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCVK8SAuditLogQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &VK8SAuditLogRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.VK8SAuditLogRequest", yamlReq)
	}
	rsp, err := c.grpcClient.VK8SAuditLogQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCVK8SAuditLogScrollQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &LogScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.LogScrollRequest", yamlReq)
	}
	rsp, err := c.grpcClient.VK8SAuditLogScrollQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCVK8SEventsAggregationQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &VK8SEventsAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.VK8SEventsAggregationRequest", yamlReq)
	}
	rsp, err := c.grpcClient.VK8SEventsAggregationQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCVK8SEventsQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &VK8SEventsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.VK8SEventsRequest", yamlReq)
	}
	rsp, err := c.grpcClient.VK8SEventsQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCVK8SEventsScrollQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &LogScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.LogScrollRequest", yamlReq)
	}
	rsp, err := c.grpcClient.VK8SEventsScrollQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func NewCustomAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &CustomAPIGrpcClient{
		conn:       cc,
		grpcClient: NewCustomAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["AccessLogAggregationQuery"] = ccl.doRPCAccessLogAggregationQuery

	rpcFns["AccessLogQueryV2"] = ccl.doRPCAccessLogQueryV2

	rpcFns["AccessLogScrollQuery"] = ccl.doRPCAccessLogScrollQuery

	rpcFns["AuditLogAggregationQuery"] = ccl.doRPCAuditLogAggregationQuery

	rpcFns["AuditLogQueryV2"] = ccl.doRPCAuditLogQueryV2

	rpcFns["AuditLogScrollQuery"] = ccl.doRPCAuditLogScrollQuery

	rpcFns["FirewallLogAggregationQuery"] = ccl.doRPCFirewallLogAggregationQuery

	rpcFns["FirewallLogQuery"] = ccl.doRPCFirewallLogQuery

	rpcFns["FirewallLogScrollQuery"] = ccl.doRPCFirewallLogScrollQuery

	rpcFns["K8SAuditLogAggregationQuery"] = ccl.doRPCK8SAuditLogAggregationQuery

	rpcFns["K8SAuditLogQuery"] = ccl.doRPCK8SAuditLogQuery

	rpcFns["K8SAuditLogScrollQuery"] = ccl.doRPCK8SAuditLogScrollQuery

	rpcFns["K8SEventsAggregationQuery"] = ccl.doRPCK8SEventsAggregationQuery

	rpcFns["K8SEventsQuery"] = ccl.doRPCK8SEventsQuery

	rpcFns["K8SEventsScrollQuery"] = ccl.doRPCK8SEventsScrollQuery

	rpcFns["VK8SAuditLogAggregationQuery"] = ccl.doRPCVK8SAuditLogAggregationQuery

	rpcFns["VK8SAuditLogQuery"] = ccl.doRPCVK8SAuditLogQuery

	rpcFns["VK8SAuditLogScrollQuery"] = ccl.doRPCVK8SAuditLogScrollQuery

	rpcFns["VK8SEventsAggregationQuery"] = ccl.doRPCVK8SEventsAggregationQuery

	rpcFns["VK8SEventsQuery"] = ccl.doRPCVK8SEventsQuery

	rpcFns["VK8SEventsScrollQuery"] = ccl.doRPCVK8SEventsScrollQuery

	ccl.rpcFns = rpcFns

	return ccl
}

// Create CustomAPI REST Client satisfying server.CustomClient
type CustomAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *CustomAPIRestClient) doRPCAccessLogAggregationQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &AccessLogAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.AccessLogAggregationRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogAggregationResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogAggregationResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCAccessLogQueryV2(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &AccessLogRequestV2{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.AccessLogRequestV2: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("limit", fmt.Sprintf("%v", req.Limit))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("scroll", fmt.Sprintf("%v", req.Scroll))
		q.Add("sort", fmt.Sprintf("%v", req.Sort))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCAccessLogScrollQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &LogScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.LogScrollRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("scroll_id", fmt.Sprintf("%v", req.ScrollId))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCAuditLogAggregationQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &AuditLogAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.AuditLogAggregationRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogAggregationResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogAggregationResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCAuditLogQueryV2(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &AuditLogRequestV2{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.AuditLogRequestV2: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("limit", fmt.Sprintf("%v", req.Limit))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("scroll", fmt.Sprintf("%v", req.Scroll))
		q.Add("sort", fmt.Sprintf("%v", req.Sort))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCAuditLogScrollQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &LogScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.LogScrollRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("scroll_id", fmt.Sprintf("%v", req.ScrollId))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCFirewallLogAggregationQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &FirewallLogAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.FirewallLogAggregationRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogAggregationResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogAggregationResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCFirewallLogQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &FirewallLogRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.FirewallLogRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("limit", fmt.Sprintf("%v", req.Limit))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("scroll", fmt.Sprintf("%v", req.Scroll))
		q.Add("sort", fmt.Sprintf("%v", req.Sort))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCFirewallLogScrollQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &LogScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.LogScrollRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("scroll_id", fmt.Sprintf("%v", req.ScrollId))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCK8SAuditLogAggregationQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &K8SAuditLogAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.K8SAuditLogAggregationRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("site", fmt.Sprintf("%v", req.Site))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogAggregationResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogAggregationResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCK8SAuditLogQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &K8SAuditLogRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.K8SAuditLogRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("limit", fmt.Sprintf("%v", req.Limit))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("scroll", fmt.Sprintf("%v", req.Scroll))
		q.Add("site", fmt.Sprintf("%v", req.Site))
		q.Add("sort", fmt.Sprintf("%v", req.Sort))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCK8SAuditLogScrollQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &LogScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.LogScrollRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("scroll_id", fmt.Sprintf("%v", req.ScrollId))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCK8SEventsAggregationQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &K8SEventsAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.K8SEventsAggregationRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("site", fmt.Sprintf("%v", req.Site))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogAggregationResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogAggregationResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCK8SEventsQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &K8SEventsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.K8SEventsRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("limit", fmt.Sprintf("%v", req.Limit))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("scroll", fmt.Sprintf("%v", req.Scroll))
		q.Add("site", fmt.Sprintf("%v", req.Site))
		q.Add("sort", fmt.Sprintf("%v", req.Sort))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCK8SEventsScrollQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &LogScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.LogScrollRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("scroll_id", fmt.Sprintf("%v", req.ScrollId))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCVK8SAuditLogAggregationQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &VK8SAuditLogAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.VK8SAuditLogAggregationRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogAggregationResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogAggregationResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCVK8SAuditLogQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &VK8SAuditLogRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.VK8SAuditLogRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("limit", fmt.Sprintf("%v", req.Limit))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("scroll", fmt.Sprintf("%v", req.Scroll))
		q.Add("sort", fmt.Sprintf("%v", req.Sort))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCVK8SAuditLogScrollQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &LogScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.LogScrollRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("scroll_id", fmt.Sprintf("%v", req.ScrollId))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCVK8SEventsAggregationQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &VK8SEventsAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.VK8SEventsAggregationRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogAggregationResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogAggregationResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCVK8SEventsQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &VK8SEventsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.VK8SEventsRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("limit", fmt.Sprintf("%v", req.Limit))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("scroll", fmt.Sprintf("%v", req.Scroll))
		q.Add("sort", fmt.Sprintf("%v", req.Sort))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCVK8SEventsScrollQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &LogScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.log.LogScrollRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("scroll_id", fmt.Sprintf("%v", req.ScrollId))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LogResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.log.LogResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewCustomAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &CustomAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["AccessLogAggregationQuery"] = ccl.doRPCAccessLogAggregationQuery

	rpcFns["AccessLogQueryV2"] = ccl.doRPCAccessLogQueryV2

	rpcFns["AccessLogScrollQuery"] = ccl.doRPCAccessLogScrollQuery

	rpcFns["AuditLogAggregationQuery"] = ccl.doRPCAuditLogAggregationQuery

	rpcFns["AuditLogQueryV2"] = ccl.doRPCAuditLogQueryV2

	rpcFns["AuditLogScrollQuery"] = ccl.doRPCAuditLogScrollQuery

	rpcFns["FirewallLogAggregationQuery"] = ccl.doRPCFirewallLogAggregationQuery

	rpcFns["FirewallLogQuery"] = ccl.doRPCFirewallLogQuery

	rpcFns["FirewallLogScrollQuery"] = ccl.doRPCFirewallLogScrollQuery

	rpcFns["K8SAuditLogAggregationQuery"] = ccl.doRPCK8SAuditLogAggregationQuery

	rpcFns["K8SAuditLogQuery"] = ccl.doRPCK8SAuditLogQuery

	rpcFns["K8SAuditLogScrollQuery"] = ccl.doRPCK8SAuditLogScrollQuery

	rpcFns["K8SEventsAggregationQuery"] = ccl.doRPCK8SEventsAggregationQuery

	rpcFns["K8SEventsQuery"] = ccl.doRPCK8SEventsQuery

	rpcFns["K8SEventsScrollQuery"] = ccl.doRPCK8SEventsScrollQuery

	rpcFns["VK8SAuditLogAggregationQuery"] = ccl.doRPCVK8SAuditLogAggregationQuery

	rpcFns["VK8SAuditLogQuery"] = ccl.doRPCVK8SAuditLogQuery

	rpcFns["VK8SAuditLogScrollQuery"] = ccl.doRPCVK8SAuditLogScrollQuery

	rpcFns["VK8SEventsAggregationQuery"] = ccl.doRPCVK8SEventsAggregationQuery

	rpcFns["VK8SEventsQuery"] = ccl.doRPCVK8SEventsQuery

	rpcFns["VK8SEventsScrollQuery"] = ccl.doRPCVK8SEventsScrollQuery

	ccl.rpcFns = rpcFns

	return ccl
}

// Create CustomAPIInprocClient

// INPROC Client (satisfying CustomAPIClient interface)
type CustomAPIInprocClient struct {
	svc svcfw.Service
}

func (c *CustomAPIInprocClient) AccessLogAggregationQuery(ctx context.Context, in *AccessLogAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogAggregationResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.AccessLogAggregationRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.AccessLogAggregationQuery' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.AccessLogAggregationQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.AccessLogAggregationQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogAggregationResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) AccessLogQueryV2(ctx context.Context, in *AccessLogRequestV2, opts ...grpc.CallOption) (*LogResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.AccessLogRequestV2", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.AccessLogQueryV2' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.AccessLogQueryV2"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.AccessLogQueryV2(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) AccessLogScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.LogScrollRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.AccessLogScrollQuery' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.AccessLogScrollQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.AccessLogScrollQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) AuditLogAggregationQuery(ctx context.Context, in *AuditLogAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogAggregationResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.AuditLogAggregationRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.AuditLogAggregationQuery' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.AuditLogAggregationQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.AuditLogAggregationQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogAggregationResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) AuditLogQueryV2(ctx context.Context, in *AuditLogRequestV2, opts ...grpc.CallOption) (*LogResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.AuditLogRequestV2", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.AuditLogQueryV2' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.AuditLogQueryV2"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.AuditLogQueryV2(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) AuditLogScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.LogScrollRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.AuditLogScrollQuery' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.AuditLogScrollQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.AuditLogScrollQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) FirewallLogAggregationQuery(ctx context.Context, in *FirewallLogAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogAggregationResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.FirewallLogAggregationRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.FirewallLogAggregationQuery' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.FirewallLogAggregationQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.FirewallLogAggregationQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogAggregationResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) FirewallLogQuery(ctx context.Context, in *FirewallLogRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.FirewallLogRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.FirewallLogQuery' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.FirewallLogQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.FirewallLogQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) FirewallLogScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.LogScrollRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.FirewallLogScrollQuery' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.FirewallLogScrollQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.FirewallLogScrollQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) K8SAuditLogAggregationQuery(ctx context.Context, in *K8SAuditLogAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogAggregationResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.K8SAuditLogAggregationRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.K8SAuditLogAggregationQuery' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.K8SAuditLogAggregationQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.K8SAuditLogAggregationQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogAggregationResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) K8SAuditLogQuery(ctx context.Context, in *K8SAuditLogRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.K8SAuditLogRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.K8SAuditLogQuery' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.K8SAuditLogQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.K8SAuditLogQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) K8SAuditLogScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.LogScrollRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.K8SAuditLogScrollQuery' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.K8SAuditLogScrollQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.K8SAuditLogScrollQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) K8SEventsAggregationQuery(ctx context.Context, in *K8SEventsAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogAggregationResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.K8SEventsAggregationRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.K8SEventsAggregationQuery' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.K8SEventsAggregationQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.K8SEventsAggregationQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogAggregationResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) K8SEventsQuery(ctx context.Context, in *K8SEventsRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.K8SEventsRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.K8SEventsQuery' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.K8SEventsQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.K8SEventsQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) K8SEventsScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.LogScrollRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.K8SEventsScrollQuery' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.K8SEventsScrollQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.K8SEventsScrollQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) VK8SAuditLogAggregationQuery(ctx context.Context, in *VK8SAuditLogAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogAggregationResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.VK8SAuditLogAggregationRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.VK8SAuditLogAggregationQuery' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.VK8SAuditLogAggregationQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.VK8SAuditLogAggregationQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogAggregationResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) VK8SAuditLogQuery(ctx context.Context, in *VK8SAuditLogRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.VK8SAuditLogRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.VK8SAuditLogQuery' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.VK8SAuditLogQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.VK8SAuditLogQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) VK8SAuditLogScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.LogScrollRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.VK8SAuditLogScrollQuery' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.VK8SAuditLogScrollQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.VK8SAuditLogScrollQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) VK8SEventsAggregationQuery(ctx context.Context, in *VK8SEventsAggregationRequest, opts ...grpc.CallOption) (*LogAggregationResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogAggregationResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.VK8SEventsAggregationRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.VK8SEventsAggregationQuery' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.VK8SEventsAggregationQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.VK8SEventsAggregationQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogAggregationResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) VK8SEventsQuery(ctx context.Context, in *VK8SEventsRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.VK8SEventsRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.VK8SEventsQuery' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.VK8SEventsQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.VK8SEventsQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogResponse", rsp)...)

	return rsp, nil
}
func (c *CustomAPIInprocClient) VK8SEventsScrollQuery(ctx context.Context, in *LogScrollRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.log.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPISrv", ah)
	}

	var (
		rsp *LogResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.log.LogScrollRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.VK8SEventsScrollQuery' operation on 'log'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, c.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.log.CustomAPI.VK8SEventsScrollQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.VK8SEventsScrollQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.log.LogResponse", rsp)...)

	return rsp, nil
}

func NewCustomAPIInprocClient(svc svcfw.Service) CustomAPIClient {
	return &CustomAPIInprocClient{svc: svc}
}

// RegisterGwCustomAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwCustomAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterCustomAPIHandlerClient(ctx, mux, NewCustomAPIInprocClient(s))
}

var CustomAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "Logs",
        "description": "Two types of logs are supported, viz, access logs and audit logs.\n  * Access logs are sampled records of API calls made to a virtual host. It contains\n    both the request and the response data with more context like application type,\n    user, request path, method, request body, response code, source,\n    destination, etc.,\n  * Audit logs provides audit of all configuration changes made in the system using\n    public APIs provided by Volterra. It contains both the request and response body\n    with additional context necessary for post-mortem analysis such as user, request path,\n    method, request body, response code, source, destination service, etc.,\nBoth the access logs and audit logs are used to find \"who did what and when and what was the result?\"\nwho - answered by user/user-agent in the log.\nwhat - answered by request url/method/body in the log.\nwhen - answered by timestamp in the log.\nresult - answered by response code in the log.",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/public/namespaces/{namespace}/access_logs": {
            "post": {
                "summary": "Access Log Query V2",
                "description": "Request to get access logs that matches the criteria in request for a given namespace.\nTypically, virtual host is specified as match condition in the request to get all access logs\nfor a virtual host. By default, the access logs in the response are sorted in the reverse chronological order.",
                "operationId": "ves.io.schema.log.CustomAPI.AccessLogQueryV2",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nfetch access logs for a given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/logAccessLogRequestV2"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-accesslogqueryv2"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.AccessLogQueryV2"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/access_logs/aggregation": {
            "post": {
                "summary": "Access Log Aggregation Query",
                "description": "Request to get summary/analytics data for the access logs that matches the query in request for a given namespace.\nTypically, virtual host is specified as match condition in the request to get the aggregaation data\nfor a virtual host.",
                "operationId": "ves.io.schema.log.CustomAPI.AccessLogAggregationQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogAggregationResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nget aggregation data for a given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/logAccessLogAggregationRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-accesslogaggregationquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.AccessLogAggregationQuery"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/access_logs/scroll": {
            "get": {
                "summary": "Access Log Scroll Query",
                "description": "The response for access log query contain no more than 500 records.\nScroll request is used scroll through more than 500 records or all records that matched the criteria in the\naccess log query in multiple batches. EOF is indicated by empty scroll_id in the response.",
                "operationId": "ves.io.schema.log.CustomAPI.AccessLogScrollQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nfetch the log messages scoped by namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "scroll_id",
                        "description": "x-example: \"Vm9sdGVycmEgRWRnZSBQbGF0Zm9ybQ==\"\nLong Base-64 encoded string which can be used to retrieve next batch of log messages.",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Scroll ID"
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-accesslogscrollquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.AccessLogScrollQuery"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/audit_logs": {
            "post": {
                "summary": "Audit Log Query V2",
                "description": "Request to get audit logs that matches the criteria in request for a given namespace.\nIf no match conditions are specified in the request, then the response contains all\nCRUD operations performed in the namespace. User with access to the -system- namespace\nmay query for audit logs across all namespaces for a given tenant.",
                "operationId": "ves.io.schema.log.CustomAPI.AuditLogQueryV2",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nfetch audit logs for a given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/logAuditLogRequestV2"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-auditlogqueryv2"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.AuditLogQueryV2"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/audit_logs/aggregation": {
            "post": {
                "summary": "Audit Log Aggregation Query",
                "description": "Request to get summary/analytics data for the audit logs that matches the criteria in request for a given namespace.\nUser with access to the -system- namespace may query aggregated data for audit logs across all namespaces for a given tenant.",
                "operationId": "ves.io.schema.log.CustomAPI.AuditLogAggregationQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogAggregationResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nget aggregation data for a given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/logAuditLogAggregationRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-auditlogaggregationquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.AuditLogAggregationQuery"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/audit_logs/scroll": {
            "get": {
                "summary": "Audit Log Scroll Query",
                "description": "The response for audit log query contain no more than 500 messages.\nOne can use scroll request to scroll through more than 500 messages or all messages\nin multiple batches. empty scroll_id in the response indicates no more messages to fetch (EOF).",
                "operationId": "ves.io.schema.log.CustomAPI.AuditLogScrollQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nfetch the log messages scoped by namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "scroll_id",
                        "description": "x-example: \"Vm9sdGVycmEgRWRnZSBQbGF0Zm9ybQ==\"\nLong Base-64 encoded string which can be used to retrieve next batch of log messages.",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Scroll ID"
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-auditlogscrollquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.AuditLogScrollQuery"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/firewall_logs": {
            "post": {
                "summary": "Firewall Logs Query",
                "description": "Request to get access logs and network logs with policy hits.\nBy default, the firewall logs in the response are sorted in the reverse chronological order.",
                "operationId": "ves.io.schema.log.CustomAPI.FirewallLogQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nfetch Firewall logs for a given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/logFirewallLogRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-firewalllogquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.FirewallLogQuery"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/firewall_logs/aggregation": {
            "post": {
                "summary": "Firewall Logs Aggregation Query",
                "description": "Request to get summary/analytics data for the firewall logs that matches the query in request for a given namespace.",
                "operationId": "ves.io.schema.log.CustomAPI.FirewallLogAggregationQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogAggregationResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nget aggregation data for a given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/logFirewallLogAggregationRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-firewalllogaggregationquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.FirewallLogAggregationQuery"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/firewall_logs/scroll": {
            "get": {
                "summary": "Firewall Logs Scroll Query",
                "description": "The response for firewall log query contain no more than 500 records.\nScroll request is used scroll through more than 500 records or all records that matched the criteria in the\nfirewall log query in multiple batches. EOF is indicated by empty scroll_id in the response.",
                "operationId": "ves.io.schema.log.CustomAPI.FirewallLogScrollQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nfetch the log messages scoped by namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "scroll_id",
                        "description": "x-example: \"Vm9sdGVycmEgRWRnZSBQbGF0Zm9ybQ==\"\nLong Base-64 encoded string which can be used to retrieve next batch of log messages.",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Scroll ID"
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-firewalllogscrollquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.FirewallLogScrollQuery"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/k8s_audit_logs/scroll": {
            "get": {
                "summary": "K8s Audit Log Scroll Query",
                "description": "The response for K8s audit log query contain no more than 500 messages.\nOne can use scroll request to scroll through more than 500 messages or all messages\nin multiple batches. empty scroll_id in the response indicates no more messages to fetch (EOF).",
                "operationId": "ves.io.schema.log.CustomAPI.K8SAuditLogScrollQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nfetch the log messages scoped by namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "scroll_id",
                        "description": "x-example: \"Vm9sdGVycmEgRWRnZSBQbGF0Zm9ybQ==\"\nLong Base-64 encoded string which can be used to retrieve next batch of log messages.",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Scroll ID"
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-k8sauditlogscrollquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.K8SAuditLogScrollQuery"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/k8s_events/scroll": {
            "get": {
                "summary": "K8s Events Scroll Query",
                "description": "The response for K8s events query contain no more than 500 events.\nOne can use scroll request to scroll through more than 500 events or all events\nin multiple batches. Empty scroll_id in the response indicates no more messages to fetch (EOF).",
                "operationId": "ves.io.schema.log.CustomAPI.K8SEventsScrollQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nfetch the log messages scoped by namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "scroll_id",
                        "description": "x-example: \"Vm9sdGVycmEgRWRnZSBQbGF0Zm9ybQ==\"\nLong Base-64 encoded string which can be used to retrieve next batch of log messages.",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Scroll ID"
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-k8seventsscrollquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.K8SEventsScrollQuery"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/site/{site}/k8s_audit_logs": {
            "post": {
                "summary": "K8s Audit Log Query",
                "description": "Request to get Physical K8s audit logs that matches the criteria in request for a given namespace.\nIf no match conditions are specified in the request, then the response contains all\nCRUD operations performed in the namespace. User with access to the -system- namespace\nmay query for audit logs across all namespaces in a K8s Cluster.",
                "operationId": "ves.io.schema.log.CustomAPI.K8SAuditLogQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nfetch K8s audit logs for a given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "site",
                        "description": "site\n\nx-example: \"ce-1\"\nSite where the K8s Cluster is running",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Site"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/logK8SAuditLogRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-k8sauditlogquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.K8SAuditLogQuery"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/site/{site}/k8s_audit_logs/aggregation": {
            "post": {
                "summary": "K8s Audit Log Aggregation Query",
                "description": "Request to get summary/analytics data for the K8s audit logs that matches the criteria in request for a given namespace.\nUser with access to the -system- namespace may query aggregated data for audit logs across all namespaces in a K8s Cluster.",
                "operationId": "ves.io.schema.log.CustomAPI.K8SAuditLogAggregationQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogAggregationResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nget aggregation data for a given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "site",
                        "description": "site\n\nx-example: \"ce-1\"\nSite where the K8s Cluster is running",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Site"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/logK8SAuditLogAggregationRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-k8sauditlogaggregationquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.K8SAuditLogAggregationQuery"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/site/{site}/k8s_events": {
            "post": {
                "summary": "K8s Events Query",
                "description": "Request to get physical K8s events that matches the criteria in request for a given namespace.\nIf no match conditions are specified in the request, then the response contains all\nK8s events in the namespace. User with access to the -system- namespace may query for K8s events across\nall namespaces in a K8s Cluster.",
                "operationId": "ves.io.schema.log.CustomAPI.K8SEventsQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nfetch K8s events for the given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "site",
                        "description": "site\n\nx-example: \"ce-1\"\nSite where the K8s Cluster is running",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Site"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/logK8SEventsRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-k8seventsquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.K8SEventsQuery"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/site/{site}/k8s_events/aggregation": {
            "post": {
                "summary": "K8s Events Aggregation Query",
                "description": "Request to get summary/analytics data for the K8s events that matches the criteria in request for a given namespace.\nUser with access to the -system- namespace may query aggregated data for K8s events across all namespaces in a K8s Cluster.",
                "operationId": "ves.io.schema.log.CustomAPI.K8SEventsAggregationQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogAggregationResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nget aggregation data for a given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "site",
                        "description": "site\n\nx-example: \"ce-1\"\nSite where the K8s Cluster is running",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Site"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/logK8SEventsAggregationRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-k8seventsaggregationquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.K8SEventsAggregationQuery"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/vk8s_audit_logs": {
            "post": {
                "summary": "vK8s Audit Log Query",
                "description": "Request to get Virtual K8s audit logs that matches the criteria in request for a given namespace.\nIf no match conditions are specified in the request, then the response contains all\nCRUD operations performed in the namespace. User with access to the -system- namespace\nmay query for audit logs across all namespaces for a given tenant.",
                "operationId": "ves.io.schema.log.CustomAPI.VK8SAuditLogQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nfetch vK8s audit logs for a given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/logVK8SAuditLogRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-vk8sauditlogquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.VK8SAuditLogQuery"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/vk8s_audit_logs/aggregation": {
            "post": {
                "summary": "vK8s Audit Log Aggregation Query",
                "description": "Request to get summary/analytics data for the vK8s audit logs that matches the criteria in request for a given namespace.\nUser with access to the -system- namespace may query aggregated data for audit logs across all namespaces for a given tenant.",
                "operationId": "ves.io.schema.log.CustomAPI.VK8SAuditLogAggregationQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogAggregationResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nget aggregation data for a given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/logVK8SAuditLogAggregationRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-vk8sauditlogaggregationquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.VK8SAuditLogAggregationQuery"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/vk8s_audit_logs/scroll": {
            "get": {
                "summary": "vK8s Audit Log Scroll Query",
                "description": "The response for vK8s audit log query contain no more than 500 messages.\nOne can use scroll request to scroll through more than 500 messages or all messages\nin multiple batches. empty scroll_id in the response indicates no more messages to fetch (EOF).",
                "operationId": "ves.io.schema.log.CustomAPI.VK8SAuditLogScrollQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nfetch the log messages scoped by namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "scroll_id",
                        "description": "x-example: \"Vm9sdGVycmEgRWRnZSBQbGF0Zm9ybQ==\"\nLong Base-64 encoded string which can be used to retrieve next batch of log messages.",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Scroll ID"
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-vk8sauditlogscrollquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.VK8SAuditLogScrollQuery"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/vk8s_events": {
            "post": {
                "summary": "vK8s Events Query",
                "description": "Request to get Virtual K8s events that matches the criteria in request for a given namespace.\nIf no match conditions are specified in the request, then the response contains all\nvK8s events in the namespace. User with access to the -system- namespace may query for vK8s across\nall namespaces for a given tenant.",
                "operationId": "ves.io.schema.log.CustomAPI.VK8SEventsQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nfetch vK8s events for the given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/logVK8SEventsRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-vk8seventsquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.VK8SEventsQuery"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/vk8s_events/aggregation": {
            "post": {
                "summary": "vK8s Events Aggregation Query",
                "description": "Request to get summary/analytics data for the vK8s events that matches the criteria in request for a given namespace.\nUser with access to the -system- namespace may query aggregated data for vK8s events across all namespaces for a given tenant.",
                "operationId": "ves.io.schema.log.CustomAPI.VK8SEventsAggregationQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogAggregationResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nget aggregation data for a given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/logVK8SEventsAggregationRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-vk8seventsaggregationquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.VK8SEventsAggregationQuery"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/vk8s_events/scroll": {
            "get": {
                "summary": "vK8s Events Scroll Query",
                "description": "The response for vK8s events query contain no more than 500 events.\nOne can use scroll request to scroll through more than 500 events or all events\nin multiple batches. Empty scroll_id in the response indicates no more messages to fetch (EOF).",
                "operationId": "ves.io.schema.log.CustomAPI.VK8SEventsScrollQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/logLogResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nfetch the log messages scoped by namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "scroll_id",
                        "description": "x-example: \"Vm9sdGVycmEgRWRnZSBQbGF0Zm9ybQ==\"\nLong Base-64 encoded string which can be used to retrieve next batch of log messages.",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Scroll ID"
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-log-customapi-vk8seventsscrollquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.log.CustomAPI.VK8SEventsScrollQuery"
            },
            "x-displayname": "Log",
            "x-ves-proto-service": "ves.io.schema.log.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        }
    },
    "definitions": {
        "logAccessLogAggregationRequest": {
            "type": "object",
            "description": "Request to get only aggregation data for access logs",
            "title": "AccessLogAggregationRequest",
            "x-displayname": "Access Log Aggregation Request",
            "x-ves-proto-message": "ves.io.schema.log.AccessLogAggregationRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch access logs whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"2019-09-24T12:30:11.733Z\"-",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "2019-09-24T12:30:11.733Z"
                },
                "namespace": {
                    "type": "string",
                    "description": " get aggregation data for a given namespace\n\nExample: - \"value\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "value"
                },
                "query": {
                    "type": "string",
                    "description": " query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n   One or more of following fields in access log may be specified in the query.\n     app_type - application type\n     vh_name - name of the virtual host\n     src_site - source site\n     src - source service\n     src_instance - source instance\n     dst_site - destination site\n     dst - destination service\n     dst_instance - destination instance\n     method - request method\n     req_path - request path\n     rsp_code - response code\n     browser_type - browser type\n     city - name of the city\n     country - country code\n     device_type - device type\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"]\n   = : equal to\n   != : not equal to\n When more than one matcher is specified in the query, then access logs matching ALL the matchers will be considered for aggregation.\n Example: query={src=\"service1\", dst=\"service2\"} will consider all access logs with source service \"service1\" and the destination service \"service2\"\n\n Optional: If not specified, all the access logs matching the given tenant, namespace will be considered for aggregation\n\nExample: - \"{vh_name=\\\"productpage\\\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "{vh_name=\\\"productpage\\\"}"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch access logs whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"2019-09-23T12:30:11.733Z\"-",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "2019-09-23T12:30:11.733Z"
                }
            }
        },
        "logAccessLogRequestV2": {
            "type": "object",
            "description": "Request to fetch access logs.",
            "title": "AccessLogRequestV2",
            "x-displayname": "Access Log Request V2",
            "x-ves-proto-message": "ves.io.schema.log.AccessLogRequestV2",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch access logs whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"2019-09-24T12:30:11.733Z\"-",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "2019-09-24T12:30:11.733Z"
                },
                "limit": {
                    "type": "integer",
                    "description": " limits the number of logs returned in the response\n Optional: If not specified, first or last 500 log messages that matches the query (depending on the sort order) will be returned in the response.\n           The maximum value for limit is 500.\n\nExample: - \"0\"-",
                    "title": "limit",
                    "format": "int32",
                    "x-displayname": "Limit",
                    "x-ves-example": "0"
                },
                "namespace": {
                    "type": "string",
                    "description": " fetch access logs for a given namespace\n\nExample: - \"value\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "value"
                },
                "query": {
                    "type": "string",
                    "description": " query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n   One or more of following fields in access log may be specified in the query.\n     app_type - application type\n     vh_name - name of the virtual host\n     src_site - source site\n     src - source service\n     src_instance - source instance\n     dst_site - destination site\n     dst - destination service\n     dst_instance - destination instance\n     method - request method\n     req_path - request path\n     rsp_code - response code\n     browser_type - browser type\n     city - name of the city\n     country - country code\n     device_type - device type\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"|\"=~\"|\"!~\"]\n   = : equal to\n   != : not equal to\n   =~ : regex match\n   !~ : not regex match\n When more than one matcher is specified in the query, then access logs matching ALL the matchers will be returned in the response.\n Example: query={src=\"service1\", dst=\"service2\"} will return all access logs with source service \"service1\" and the destination service \"service2\"\n          query={vh_name=\"vh1\", rsp_code=~\"4.*\"} will return all access logs for virtual-host \"vh1\" with response code 4xx\n\n Optional: If not specified, all the access logs matching the given tenant, namespace will be returned in the response\n\nExample: - \"{vh_name=\\\"productpage\\\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "{vh_name=\\\"productpage\\\"}"
                },
                "scroll": {
                    "type": "boolean",
                    "description": " Scroll is used to retrieve large number of log messages (or all log messages) that matches the query.\n If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next\n batch of logs until there are no more logs left to return. The number of messages in each batch is determined\n by the limit field.\n Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.\n Optional: default is false\n\nExample: - \"true\"-",
                    "title": "scroll",
                    "format": "boolean",
                    "x-displayname": "Scroll",
                    "x-ves-example": "true"
                },
                "sort": {
                    "description": " specifies whether the response should be sorted in ascending or descending order based on timestamp in the log\n Optional: default is descending order",
                    "title": "sort order",
                    "$ref": "#/definitions/schemaSortOrder",
                    "x-displayname": "Sort Order"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch access logs whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"2019-09-23T12:30:11.733Z\"-",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "2019-09-23T12:30:11.733Z"
                }
            }
        },
        "logAuditLogAggregationRequest": {
            "type": "object",
            "description": "Request to get only aggregation data for audit logs",
            "title": "AuditLogAggregationRequest",
            "x-displayname": "Audit Log Aggregation Request",
            "x-ves-proto-message": "ves.io.schema.log.AuditLogAggregationRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch audit logs whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"2019-09-24T12:30:11.733Z\"-",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "2019-09-24T12:30:11.733Z"
                },
                "namespace": {
                    "type": "string",
                    "description": " get aggregation data for a given namespace\n\nExample: - \"value\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "value"
                },
                "query": {
                    "type": "string",
                    "description": " query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n  One or more of the following fields in audit log may be specified in the query.\n   user - user name\n   src_site - source site\n   src - source service\n   src_instance - source instance\n   dst_site - destination site\n   dst - destination service\n   dst_instance - destination instance\n   method - request method\n   req_path - request URL\n   rsp_code - response code\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"]\n   = : equal to\n   != : not equal to\n When more than one matcher is specified in the query, then audit logs matching ALL the matchers will be returned in the response.\n Example: query={req_path=\"/public/namespaces/system/registrations\"} will return all audit logs with req_path equals /public/namespaces/system/registrations\n\n Optional: If not specified, all the audit logs matching the given tenant and namespace will be considered for aggregation\n\nExample: - \"{user=\\\"abc\\\", rsp_code=\\\"404\\\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "{user=\\\"abc\\\", rsp_code=\\\"404\\\"}"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch audit logs whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"2019-09-23T12:30:11.733Z\"-",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "2019-09-23T12:30:11.733Z"
                }
            }
        },
        "logAuditLogRequestV2": {
            "type": "object",
            "description": "Request to fetch audit logs",
            "title": "AuditLogRequestV2",
            "x-displayname": "Audit Log Request V2",
            "x-ves-proto-message": "ves.io.schema.log.AuditLogRequestV2",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch audit logs whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"2019-09-24T12:30:11.733Z\"-",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "2019-09-24T12:30:11.733Z"
                },
                "limit": {
                    "type": "integer",
                    "description": " limits the number of logs returned in the response\n Optional: If not specified, first or last 500 log messages that matches the query (depending on the sort order) will be returned in the response.\n           The maximum value for limit is 500.\n\nExample: - \"100\"-",
                    "title": "limit",
                    "format": "int32",
                    "x-displayname": "Limit",
                    "x-ves-example": "100"
                },
                "namespace": {
                    "type": "string",
                    "description": " fetch audit logs for a given namespace\n\nExample: - \"value\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "value"
                },
                "query": {
                    "type": "string",
                    "description": " query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n  One or more of the following fields in audit log may be specified in the query.\n   user - user name\n   src_site - source site\n   src - source service\n   src_instance - source instance\n   dst_site - destination site\n   dst - destination service\n   dst_instance - destination instance\n   method - request method\n   req_path - request URL\n   rsp_code - response code\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"|\"=~\"|\"!~\"]\n   = : equal to\n   != : not equal to\n   =~ : regex match\n   !~ : not regex match\n When more than one matcher is specified in the query, then audit logs matching ALL the matchers will be returned in the response.\n Example: query={req_path=\"/public/namespaces/system/registrations\"} will return all audit logs with req_path equals /public/namespaces/system/registrations\n\n Optional: If not specified, all the audit logs matching the given tenant and namespace are returned\n\nExample: - \"{user=\\\"abc\\\", rsp_code=\\\"404\\\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "{user=\\\"abc\\\", rsp_code=\\\"404\\\"}"
                },
                "scroll": {
                    "type": "boolean",
                    "description": " Scroll is used to retrieve large number of log messages (or all log messages) that matches the query.\n If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next\n batch of logs until there are no more logs left to return. The number of messages in each batch is determined\n by the limit field.\n Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.\n Optional: default is false\n\nExample: - \"true\"-",
                    "title": "scroll",
                    "format": "boolean",
                    "x-displayname": "Scroll",
                    "x-ves-example": "true"
                },
                "sort": {
                    "description": " specifies whether the response should be sorted in ascending or descending order based on timestamp in the log\n Optional: default is descending order",
                    "title": "sort order",
                    "$ref": "#/definitions/schemaSortOrder",
                    "x-displayname": "Sort Order"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch audit logs whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"2019-09-23T12:30:11.733Z\"-",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "2019-09-23T12:30:11.733Z"
                }
            }
        },
        "logCardinalityAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Cardinality Aggregation Data\"\nApproximate count of distinct values of the log field specified in the request.",
            "title": "CardinalityAggregationData",
            "properties": {
                "count": {
                    "type": "string",
                    "description": "x-displayName: \"Count\"\nx-example: 100\nCount of distinct values of a log field",
                    "title": "count",
                    "format": "uint64"
                }
            }
        },
        "logDateAggregationBucket": {
            "type": "object",
            "description": "x-displayName: \"Date Aggregation Bucket\"\nDate histogram bucket containing the timestamp and the number of logs in that bucket.",
            "title": "DateAggregationBucket",
            "properties": {
                "count": {
                    "type": "string",
                    "description": "x-displayName: \"Count\"\nx-example: 45\n\nnumber of logs in this bucket",
                    "title": "count",
                    "format": "uint64"
                },
                "sub_aggs": {
                    "type": "object",
                    "description": "x-displayName: \"Sub Aggregation\"\nSub aggregation data for the date bucket",
                    "title": "sub aggregation"
                },
                "time": {
                    "type": "string",
                    "description": "x-displayName: \"Time\"\nx-example: 1578710280000\n\nunix timestamp",
                    "title": "time",
                    "format": "uint64"
                }
            }
        },
        "logDateAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Date Aggregation Data\"\nDate aggregation data",
            "title": "DateAggregationData",
            "properties": {
                "buckets": {
                    "type": "array",
                    "description": "x-displayName: \"Buckets\"\nLists of buckets containing timestamp and the corresponding log count",
                    "title": "buckets",
                    "items": {
                        "$ref": "#/definitions/logDateAggregationBucket"
                    }
                }
            }
        },
        "logDateSubAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Date SubAggregation\"\n\nDate subaggregation data",
            "title": "DateSubAggregationData",
            "properties": {
                "field_aggregation": {
                    "description": "Field aggregation data",
                    "title": "field aggregation\nx-displayName: \"Field Aggregation\"",
                    "$ref": "#/definitions/logFieldAggregationData"
                }
            }
        },
        "logFieldAggregationBucket": {
            "type": "object",
            "description": "x-displayName: \"Field Aggregation Bucket\"\nField aggregation bucket containing field value and the number of logs.",
            "title": "FieldAggregationBucket",
            "properties": {
                "count": {
                    "type": "string",
                    "description": "x-displayName: \"Count\"\nx-example: 45\n\nnumber of logs in this bucket",
                    "title": "count",
                    "format": "uint64"
                },
                "key": {
                    "type": "string",
                    "description": "x-displayName: \"Key\"\nx-example: \"US\"",
                    "title": "key"
                },
                "sub_aggs": {
                    "type": "object",
                    "description": "x-displayName: \"Sub Aggregation\"\nSub aggregation data for the field aggregation bucket",
                    "title": "sub aggregation"
                }
            }
        },
        "logFieldAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Field Aggregation Data\"\nField Aggregation data",
            "title": "FieldAggregationData",
            "properties": {
                "buckets": {
                    "type": "array",
                    "description": "x-displayName: \"Buckets\"\nLists of buckets containing field value and the corresponding log count",
                    "title": "buckets",
                    "items": {
                        "$ref": "#/definitions/logFieldAggregationBucket"
                    }
                }
            }
        },
        "logFieldSubAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Field SubAggregation\"\nField subaggregation data",
            "title": "FieldSubAggregationData",
            "properties": {
                "cardinality_aggregation": {
                    "description": "cardinality aggregation data",
                    "title": "cardinality aggregation\nx-displayName: \"Cardinality Aggregation\"",
                    "$ref": "#/definitions/logCardinalityAggregationData"
                }
            }
        },
        "logFirewallLogAggregationRequest": {
            "type": "object",
            "description": "Request to get only aggregation data for Firewall logs",
            "title": "FirewallLogAggregationRequest",
            "x-displayname": "Firewall Log Aggregation Request",
            "x-ves-proto-message": "ves.io.schema.log.FirewallLogAggregationRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch Firewall logs whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"2019-09-24T12:30:11.733Z\"-",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "2019-09-24T12:30:11.733Z"
                },
                "namespace": {
                    "type": "string",
                    "description": " get aggregation data for a given namespace\n\nExample: - \"value\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "value"
                },
                "query": {
                    "type": "string",
                    "description": " query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n   One or more of following fields in Firewall log may be specified in the query.\n     site - Name of the site\n     src_ip - Source IP Address\n     dst_ip - Destination IP Address\n     policy_hits.policy - Policy Name\n     policy_hits.policy_rule - Policy Rule Name\n     policy_hits.result - allow|deny|default_deny\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"|\"=~\"|\"!~\"]\n   = : equal to\n   != : not equal to\n   =~ : regex match\n   !~ : not regex match\n When more than one matcher is specified in the query, then Firewall logs matching ALL the matchers will be returned in the response.\n\n Optional: If not specified, all the Firewall logs matching the given tenant, namespace will be returned in the response\n\nExample: - \"{site=\\\"site-1\\\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "{site=\\\"site-1\\\"}"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch Firewall logs whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"2019-09-23T12:30:11.733Z\"-",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "2019-09-23T12:30:11.733Z"
                }
            }
        },
        "logFirewallLogRequest": {
            "type": "object",
            "description": "Request to fetch Firewall logs.",
            "title": "FirewallLogRequest",
            "x-displayname": "Firewall Log Request",
            "x-ves-proto-message": "ves.io.schema.log.FirewallLogRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch Firewall logs whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"2019-09-24T12:30:11.733Z\"-",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "2019-09-24T12:30:11.733Z"
                },
                "limit": {
                    "type": "integer",
                    "description": " limits the number of logs returned in the response\n Optional: If not specified, first or last 500 log messages that matches the query (depending on the sort order) will be returned in the response.\n           The maximum value for limit is 500.\n\nExample: - \"0\"-",
                    "title": "limit",
                    "format": "int32",
                    "x-displayname": "Limit",
                    "x-ves-example": "0"
                },
                "namespace": {
                    "type": "string",
                    "description": " fetch Firewall logs for a given namespace\n\nExample: - \"value\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "value"
                },
                "query": {
                    "type": "string",
                    "description": " query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n   One or more of following fields in Firewall log may be specified in the query.\n     site - Name of the site\n     src_ip - Source IP Address\n     dst_ip - Destination IP Address\n     policy_hits.policy - Policy Name\n     policy_hits.policy_rule - Policy Rule Name\n     policy_hits.result - allow|deny|default_deny\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"|\"=~\"|\"!~\"]\n   = : equal to\n   != : not equal to\n   =~ : regex match\n   !~ : not regex match\n When more than one matcher is specified in the query, then Firewall logs matching ALL the matchers will be returned in the response.\n\n Optional: If not specified, all the Firewall logs matching the given tenant, namespace will be returned in the response\n\nExample: - \"{site=\\\"site-1\\\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "{site=\\\"site-1\\\"}"
                },
                "scroll": {
                    "type": "boolean",
                    "description": " Scroll is used to retrieve large number of log messages (or all log messages) that matches the query.\n If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next\n batch of logs until there are no more logs left to return. The number of messages in each batch is determined\n by the limit field.\n Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.\n Optional: default is false\n\nExample: - \"true\"-",
                    "title": "scroll",
                    "format": "boolean",
                    "x-displayname": "Scroll",
                    "x-ves-example": "true"
                },
                "sort": {
                    "description": " specifies whether the response should be sorted in ascending or descending order based on timestamp in the log\n Optional: default is descending order",
                    "title": "sort order",
                    "$ref": "#/definitions/schemaSortOrder",
                    "x-displayname": "Sort Order"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch Firewall logs whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"2019-09-23T12:30:11.733Z\"-",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "2019-09-23T12:30:11.733Z"
                }
            }
        },
        "logK8SAuditLogAggregationRequest": {
            "type": "object",
            "description": "Request to get only aggregation data for K8s audit logs",
            "title": "K8SAuditLogAggregationRequest",
            "x-displayname": "K8s Audit Log Aggregation Request",
            "x-ves-proto-message": "ves.io.schema.log.K8SAuditLogAggregationRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch audit logs whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"2019-09-24T12:30:11.733Z\"-",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "2019-09-24T12:30:11.733Z"
                },
                "namespace": {
                    "type": "string",
                    "description": " get aggregation data for a given namespace\n\nExample: - \"value\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "value"
                },
                "query": {
                    "type": "string",
                    "description": " query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n  One or more of the following fields in audit log may be specified in the query.\n   user.username - user name\n   sourceIPs - source ip\n   verb - method\n   objectRef.resource - K8s resource\n   requestURI - request URI\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"]\n   = : equal to\n   != : not equal to\n When more than one matcher is specified in the query, then audit logs matching ALL the matchers will be returned in the response.\n Example: query={objectRef.resource=\"deployments\"} will return all K8s audit logs for all deployment objects in the given namespace\n\n Optional: If not specified, all the audit logs matching the given tenant and namespace will be considered for aggregation\n\nExample: - \"query={objectRef.resource=\"deployments\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "query={objectRef.resource=\"deployments\"}"
                },
                "site": {
                    "type": "string",
                    "description": " Site where the K8s Cluster is running\n\nExample: - \"ce-1\"-",
                    "title": "site",
                    "x-displayname": "Site",
                    "x-ves-example": "ce-1"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch audit logs whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"2019-09-23T12:30:11.733Z\"-",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "2019-09-23T12:30:11.733Z"
                }
            }
        },
        "logK8SAuditLogRequest": {
            "type": "object",
            "description": "Request to fetch K8s audit logs",
            "title": "K8SAuditLogRequest",
            "x-displayname": "K8s Audit Log Request",
            "x-ves-proto-message": "ves.io.schema.log.K8SAuditLogRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch audit logs whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"2019-09-24T12:30:11.733Z\"-",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "2019-09-24T12:30:11.733Z"
                },
                "limit": {
                    "type": "integer",
                    "description": " limits the number of logs returned in the response\n Optional: If not specified, first or last 500 log messages that matches the query (depending on the sort order) will be returned in the response.\n           The maximum value for limit is 500.\n\nExample: - \"100\"-",
                    "title": "limit",
                    "format": "int32",
                    "x-displayname": "Limit",
                    "x-ves-example": "100"
                },
                "namespace": {
                    "type": "string",
                    "description": " fetch K8s audit logs for a given namespace\n\nExample: - \"value\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "value"
                },
                "query": {
                    "type": "string",
                    "description": " query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n  One or more of the following fields in audit log may be specified in the query.\n   user.username - user name\n   sourceIPs - source ip\n   verb - method\n   objectRef.resource - K8s resource\n   requestURI - request URI\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"|\"=~\"|\"!~\"]\n   = : equal to\n   != : not equal to\n   =~ : regex match\n   !~ : not regex match\n When more than one matcher is specified in the query, then audit logs matching ALL the matchers will be returned in the response.\n Example: query={objectRef.resource=\"deployments\"} will return all K8s audit logs for all deployment objects in the given namespace\n\n Optional: If not specified, all the audit logs matching the given tenant and namespace are returned\n\nExample: - \"query={objectRef.resource=\"deployments\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "query={objectRef.resource=\"deployments\"}"
                },
                "scroll": {
                    "type": "boolean",
                    "description": " Scroll is used to retrieve large number of log messages (or all log messages) that matches the query.\n If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next\n batch of logs until there are no more logs left to return. The number of messages in each batch is determined\n by the limit field.\n Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.\n Optional: default is false\n\nExample: - \"true\"-",
                    "title": "scroll",
                    "format": "boolean",
                    "x-displayname": "Scroll",
                    "x-ves-example": "true"
                },
                "site": {
                    "type": "string",
                    "description": " Site where the K8s Cluster is running\n\nExample: - \"ce-1\"-",
                    "title": "site",
                    "x-displayname": "Site",
                    "x-ves-example": "ce-1"
                },
                "sort": {
                    "description": " specifies whether the response should be sorted in ascending or descending order based on timestamp in the log\n Optional: default is descending order",
                    "title": "sort order",
                    "$ref": "#/definitions/schemaSortOrder",
                    "x-displayname": "Sort Order"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch audit logs whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"2019-09-23T12:30:11.733Z\"-",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "2019-09-23T12:30:11.733Z"
                }
            }
        },
        "logK8SEventsAggregationRequest": {
            "type": "object",
            "description": "Request to get only aggregation data for K8s events in a Cluster",
            "title": "K8s Events Aggregation Request",
            "x-displayname": "K8s Events Aggregation Request",
            "x-ves-proto-message": "ves.io.schema.log.K8SEventsAggregationRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the events response. If the number of events that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch vK8s events whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"2019-09-24T12:30:11.733Z\"-",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "2019-09-24T12:30:11.733Z"
                },
                "namespace": {
                    "type": "string",
                    "description": " get aggregation data for a given namespace\n\nExample: - \"value\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "value"
                },
                "query": {
                    "type": "string",
                    "description": " query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n  One or more of the following fields in the event may be specified in the query.\n   involvedObject.kind - The object that this event is about, like Pod, Deployment, Node, etc.\n   involvedObject.name - Name of the object\n   type - Type of event such as Warning or Normal\n   reason - A one-word description for an event. For example Pending, Running, Succeeded, Failed are some of values for reason that indicate the phase of a Pod lifecycle.\n   source.component - The K8s component reporting the event such as kubelet, kube-scheduler, etc.,\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"|\"=~\"|\"!~\"]\n   = : equal to\n   != : not equal to\n   =~ : regex match\n   !~ : not regex match\n\n Optional: If not specified, all the K8s events for the given tenant and namespace are returned\n\nExample: - \"query={involvedObject.kind=\"Pod\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "query={involvedObject.kind=\"Pod\"}"
                },
                "site": {
                    "type": "string",
                    "description": " Site where the K8s Cluster is running\n\nExample: - \"ce-1\"-",
                    "title": "site",
                    "x-displayname": "Site",
                    "x-ves-example": "ce-1"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch vK8s events whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"2019-09-23T12:30:11.733Z\"-",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "2019-09-23T12:30:11.733Z"
                }
            }
        },
        "logK8SEventsRequest": {
            "type": "object",
            "description": "Request to fetch physical K8s events",
            "title": "K8s Events Request",
            "x-displayname": "K8s Events Request",
            "x-ves-proto-message": "ves.io.schema.log.K8SEventsRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the events response. If the number of events that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch vK8s events whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"2019-09-24T12:30:11.733Z\"-",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "2019-09-24T12:30:11.733Z"
                },
                "limit": {
                    "type": "integer",
                    "description": " limits the number of K8s events returned in the response\n Optional: If not specified, first or last 500 events that matches the query (depending on the sort order) will be returned in the response.\n           The maximum value for limit is 500.\n\nExample: - \"100\"-",
                    "title": "limit",
                    "format": "int32",
                    "x-displayname": "Limit",
                    "x-ves-example": "100"
                },
                "namespace": {
                    "type": "string",
                    "description": " fetch K8s events for the given namespace\n\nExample: - \"value\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "value"
                },
                "query": {
                    "type": "string",
                    "description": " query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n  One or more of the following fields in the event may be specified in the query.\n   involvedObject.kind - The object that this event is about, like Pod, Deployment, Node, etc.\n   involvedObject.name - Name of the object\n   type - Type of event such as Warning or Normal\n   reason - A one-word description for an event. For example Pending, Running, Succeeded, Failed are some of values for reason that indicate the phase of a Pod lifecycle.\n   source.component - The K8s component reporting the event such as kubelet, kube-scheduler, etc.,\n   site - Name of the site\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"|\"=~\"|\"!~\"]\n   = : equal to\n   != : not equal to\n   =~ : regex match\n   !~ : not regex match\n\n Optional: If not specified, all the K8s events for the given tenant and namespace are returned\n\nExample: - \"query={involvedObject.kind=\"Pod\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "query={involvedObject.kind=\"Pod\"}"
                },
                "scroll": {
                    "type": "boolean",
                    "description": " Scroll is used to retrieve large number of events (or all events) that matches the query.\n If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next\n batch of events until there are no more events left to return. The number of events in each batch is determined\n by the limit field.\n Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.\n Optional: default is false\n\nExample: - \"true\"-",
                    "title": "scroll",
                    "format": "boolean",
                    "x-displayname": "Scroll",
                    "x-ves-example": "true"
                },
                "site": {
                    "type": "string",
                    "description": " Site where the K8s Cluster is running\n\nExample: - \"ce-1\"-",
                    "title": "site",
                    "x-displayname": "Site",
                    "x-ves-example": "ce-1"
                },
                "sort": {
                    "description": " specifies whether the response should be sorted in ascending or descending order based on timestamp in the event\n Optional: default is descending order",
                    "title": "sort order",
                    "$ref": "#/definitions/schemaSortOrder",
                    "x-displayname": "Sort Order"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch vK8s events whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"2019-09-23T12:30:11.733Z\"-",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "2019-09-23T12:30:11.733Z"
                }
            }
        },
        "logLogAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Log Aggregation\"\nLog aggregation response data",
            "title": "LogAggregationData",
            "properties": {
                "cardinality_aggregation": {
                    "description": "Cardinality aggregation data",
                    "title": "cardinality aggregation\nx-displayName: \"Cardinality Aggregation\"",
                    "$ref": "#/definitions/logCardinalityAggregationData"
                },
                "date_aggregation": {
                    "description": "Date aggregation data",
                    "title": "date aggregation\nx-displayName: \"Date Aggregation\"",
                    "$ref": "#/definitions/logDateAggregationData"
                },
                "field_aggregation": {
                    "description": "Field aggregation data",
                    "title": "field aggregation\nx-displayName: \"Field Aggregation\"",
                    "$ref": "#/definitions/logFieldAggregationData"
                }
            }
        },
        "logLogAggregationResponse": {
            "type": "object",
            "description": "Response message for AuditLogAggregationRequest/AccessLogAggregationRequest",
            "title": "LogAggregationResponse",
            "x-displayname": "Log Aggregation Response",
            "x-ves-proto-message": "ves.io.schema.log.LogAggregationResponse",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregation data is key'ed with the aggregation name specified in the request.",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "total_hits": {
                    "type": "string",
                    "description": " total number of log messages that matched the query.\n\nExample: - \"0\"-",
                    "title": "total hits",
                    "format": "uint64",
                    "x-displayname": "Total Hits",
                    "x-ves-example": "0"
                }
            }
        },
        "logLogResponse": {
            "type": "object",
            "description": "Response message for AuditLogRequest/AccessLogRequest/LogScrollRequest",
            "title": "LogResponse",
            "x-displayname": "Log Response",
            "x-ves-proto-message": "ves.io.schema.log.LogResponse",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregation data is key'ed with the aggregation name specified in the request.",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "logs": {
                    "type": "array",
                    "description": " list of log messages that matched the query. Not all log messages that matched the query are returned in the response.\n\nExample: - \"value\"-",
                    "title": "logs",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Logs",
                    "x-ves-example": "value"
                },
                "scroll_id": {
                    "type": "string",
                    "description": " Long Base-64 encoded string which can be used to retrieve next batch of log messages using the scroll request.\n Empty scroll_id indicates no more messages to scroll (EOF).\n Note: scroll_id is valid only for 2 minutes. i.e., If one intend to retrieve next batch of the result, then the\n       scroll request should be sent within 2 minutes upon receiving the LogResponse.\n\nExample: - \"Vm9sdGVycmEgRWRnZSBQbGF0Zm9ybQ==\"-",
                    "title": "scroll id",
                    "x-displayname": "Scroll ID",
                    "x-ves-example": "Vm9sdGVycmEgRWRnZSBQbGF0Zm9ybQ=="
                },
                "total_hits": {
                    "type": "string",
                    "description": " total number of log messages that matched the query.\n\nExample: - \"0\"-",
                    "title": "total hits",
                    "format": "uint64",
                    "x-displayname": "Total Hits",
                    "x-ves-example": "0"
                }
            }
        },
        "logVK8SAuditLogAggregationRequest": {
            "type": "object",
            "description": "Request to get only aggregation data for vK8s audit logs",
            "title": "VK8SAuditLogAggregationRequest",
            "x-displayname": "vK8s Audit Log Aggregation Request",
            "x-ves-proto-message": "ves.io.schema.log.VK8SAuditLogAggregationRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch audit logs whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"2019-09-24T12:30:11.733Z\"-",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "2019-09-24T12:30:11.733Z"
                },
                "namespace": {
                    "type": "string",
                    "description": " get aggregation data for a given namespace\n\nExample: - \"value\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "value"
                },
                "query": {
                    "type": "string",
                    "description": " query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n  One or more of the following fields in audit log may be specified in the query.\n   user.username - user name\n   sourceIPs - source ip\n   verb - method\n   objectRef.resource - K8s resource\n   requestURI - request URI\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"]\n   = : equal to\n   != : not equal to\n When more than one matcher is specified in the query, then audit logs matching ALL the matchers will be returned in the response.\n Example: query={objectRef.resource=\"deployments\"} will return all vK8s audit logs for all deployment objects in the given namespace\n\n Optional: If not specified, all the audit logs matching the given tenant and namespace will be considered for aggregation\n\nExample: - \"query={objectRef.resource=\"deployments\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "query={objectRef.resource=\"deployments\"}"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch audit logs whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"2019-09-23T12:30:11.733Z\"-",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "2019-09-23T12:30:11.733Z"
                }
            }
        },
        "logVK8SAuditLogRequest": {
            "type": "object",
            "description": "Request to fetch Virtual K8s audit logs",
            "title": "VK8SAuditLogRequest",
            "x-displayname": "vK8s Audit Log Request",
            "x-ves-proto-message": "ves.io.schema.log.VK8SAuditLogRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch audit logs whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"2019-09-24T12:30:11.733Z\"-",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "2019-09-24T12:30:11.733Z"
                },
                "limit": {
                    "type": "integer",
                    "description": " limits the number of logs returned in the response\n Optional: If not specified, first or last 500 log messages that matches the query (depending on the sort order) will be returned in the response.\n           The maximum value for limit is 500.\n\nExample: - \"100\"-",
                    "title": "limit",
                    "format": "int32",
                    "x-displayname": "Limit",
                    "x-ves-example": "100"
                },
                "namespace": {
                    "type": "string",
                    "description": " fetch vK8s audit logs for a given namespace\n\nExample: - \"value\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "value"
                },
                "query": {
                    "type": "string",
                    "description": " query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n  One or more of the following fields in audit log may be specified in the query.\n   user.username - user name\n   sourceIPs - source ip\n   verb - method\n   objectRef.resource - K8s resource\n   requestURI - request URI\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"|\"=~\"|\"!~\"]\n   = : equal to\n   != : not equal to\n   =~ : regex match\n   !~ : not regex match\n When more than one matcher is specified in the query, then audit logs matching ALL the matchers will be returned in the response.\n Example: query={objectRef.resource=\"deployments\"} will return all vK8s audit logs for all deployment objects in the given namespace\n\n Optional: If not specified, all the audit logs matching the given tenant and namespace are returned\n\nExample: - \"query={objectRef.resource=\"deployments\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "query={objectRef.resource=\"deployments\"}"
                },
                "scroll": {
                    "type": "boolean",
                    "description": " Scroll is used to retrieve large number of log messages (or all log messages) that matches the query.\n If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next\n batch of logs until there are no more logs left to return. The number of messages in each batch is determined\n by the limit field.\n Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.\n Optional: default is false\n\nExample: - \"true\"-",
                    "title": "scroll",
                    "format": "boolean",
                    "x-displayname": "Scroll",
                    "x-ves-example": "true"
                },
                "sort": {
                    "description": " specifies whether the response should be sorted in ascending or descending order based on timestamp in the log\n Optional: default is descending order",
                    "title": "sort order",
                    "$ref": "#/definitions/schemaSortOrder",
                    "x-displayname": "Sort Order"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch audit logs whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"2019-09-23T12:30:11.733Z\"-",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "2019-09-23T12:30:11.733Z"
                }
            }
        },
        "logVK8SEventsAggregationRequest": {
            "type": "object",
            "description": "Request to get only aggregation data for vK8s events",
            "title": "vK8s Events Aggregation Request",
            "x-displayname": "Virtual K8s Events Aggregation Request",
            "x-ves-proto-message": "ves.io.schema.log.VK8SEventsAggregationRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the events response. If the number of events that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch vK8s events whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"2019-09-24T12:30:11.733Z\"-",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "2019-09-24T12:30:11.733Z"
                },
                "namespace": {
                    "type": "string",
                    "description": " get aggregation data for a given namespace\n\nExample: - \"value\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "value"
                },
                "query": {
                    "type": "string",
                    "description": " query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n  One or more of the following fields in the event may be specified in the query.\n   involvedObject.kind - The object that this event is about, like Pod, Deployment, Node, etc.\n   involvedObject.name - Name of the object\n   type - Type of event such as Warning or Normal\n   reason - A one-word description for an event. For example Pending, Running, Succeeded, Failed are some of values for reason that indicate the phase of a Pod lifecycle.\n   source.component - The K8s component reporting the event such as kubelet, kube-scheduler, etc.,\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"|\"=~\"|\"!~\"]\n   = : equal to\n   != : not equal to\n   =~ : regex match\n   !~ : not regex match\n\n Optional: If not specified, all the vK8s events for the given tenant and namespace are returned\n\nExample: - \"query={involvedObject.kind=\"Pod\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "query={involvedObject.kind=\"Pod\"}"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch vK8s events whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"2019-09-23T12:30:11.733Z\"-",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "2019-09-23T12:30:11.733Z"
                }
            }
        },
        "logVK8SEventsRequest": {
            "type": "object",
            "description": "Request to fetch Virtual K8s events",
            "title": "vK8s Events Request",
            "x-displayname": "vK8s Events Request",
            "x-ves-proto-message": "ves.io.schema.log.VK8SEventsRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the events response. If the number of events that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch vK8s events whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"2019-09-24T12:30:11.733Z\"-",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "2019-09-24T12:30:11.733Z"
                },
                "limit": {
                    "type": "integer",
                    "description": " limits the number of vK8s events returned in the response\n Optional: If not specified, first or last 500 events that matches the query (depending on the sort order) will be returned in the response.\n           The maximum value for limit is 500.\n\nExample: - \"100\"-",
                    "title": "limit",
                    "format": "int32",
                    "x-displayname": "Limit",
                    "x-ves-example": "100"
                },
                "namespace": {
                    "type": "string",
                    "description": " fetch vK8s events for the given namespace\n\nExample: - \"value\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "value"
                },
                "query": {
                    "type": "string",
                    "description": " query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n  One or more of the following fields in the event may be specified in the query.\n   involvedObject.kind - The object that this event is about, like Pod, Deployment, Node, etc.\n   involvedObject.name - Name of the object\n   type - Type of event such as Warning or Normal\n   reason - A one-word description for an event. For example Pending, Running, Succeeded, Failed are some of values for reason that indicate the phase of a Pod lifecycle.\n   source.component - The K8s component reporting the event such as kubelet, kube-scheduler, etc.,\n   site - Name of the site\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"|\"=~\"|\"!~\"]\n   = : equal to\n   != : not equal to\n   =~ : regex match\n   !~ : not regex match\n\n Optional: If not specified, all the vK8s events for the given tenant and namespace are returned\n\nExample: - \"query={involvedObject.kind=\"Pod\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "query={involvedObject.kind=\"Pod\"}"
                },
                "scroll": {
                    "type": "boolean",
                    "description": " Scroll is used to retrieve large number of events (or all events) that matches the query.\n If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next\n batch of events until there are no more events left to return. The number of events in each batch is determined\n by the limit field.\n Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.\n Optional: default is false\n\nExample: - \"true\"-",
                    "title": "scroll",
                    "format": "boolean",
                    "x-displayname": "Scroll",
                    "x-ves-example": "true"
                },
                "sort": {
                    "description": " specifies whether the response should be sorted in ascending or descending order based on timestamp in the event\n Optional: default is descending order",
                    "title": "sort order",
                    "$ref": "#/definitions/schemaSortOrder",
                    "x-displayname": "Sort Order"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch vK8s events whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"2019-09-23T12:30:11.733Z\"-",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "2019-09-23T12:30:11.733Z"
                }
            }
        },
        "logaccess_logAggregationRequest": {
            "type": "object",
            "description": "x-displayName: \"Aggregation Request\"\nAggregation request to provide analytics data over the log response",
            "title": "Aggregation Request",
            "properties": {
                "cardinality_aggregation": {
                    "description": "x-displayName: \"Cardinality Aggregation\"\nGet approximate count of distinct values for a field in the log",
                    "title": "Cardinality Aggregation",
                    "$ref": "#/definitions/logaccess_logCardinalityAggregation"
                },
                "date_aggregation": {
                    "description": "x-displayName: \"Date Aggregation\"\nAggregate based on timestamp in the log",
                    "title": "Date Aggregation",
                    "$ref": "#/definitions/logaccess_logDateAggregation"
                },
                "field_aggregation": {
                    "description": "x-displayName: \"Field Aggregation\"\nAggregate based on one of the key fields in the log",
                    "title": "Field Aggregation",
                    "$ref": "#/definitions/logaccess_logFieldAggregation"
                }
            }
        },
        "logaccess_logCardinalityAggregation": {
            "type": "object",
            "description": "x-displayName: \"Cardinality Aggregation\"\nGet approximate count of distinct values for the field in the access log.",
            "title": "Cardinality Aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name for which count of distinct values should be computed.",
                    "title": "field",
                    "$ref": "#/definitions/logaccess_logKeyField"
                }
            }
        },
        "logaccess_logDateAggregation": {
            "type": "object",
            "description": "x-displayName: Date Aggregation\nAggregate access logs based on timestamp in the log",
            "title": "Date Aggregation",
            "properties": {
                "step": {
                    "type": "string",
                    "description": "x-displayName: \"Step\"\nx-required\nx-example: \"5m\"\n\nstep is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\nThe timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\nFormat: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days",
                    "title": "step"
                },
                "sub_aggs": {
                    "type": "object",
                    "description": "x-displayName: \"Sub Aggregation\"\nThis option provides sub-aggregation for each date bucket",
                    "title": "sub aggregation"
                }
            }
        },
        "logaccess_logDateSubAggregation": {
            "type": "object",
            "description": "x-displayName: Date SubAggregation\nAggregate access logs in each date bucket based on one of the sub aggregation types",
            "title": "Date SubAggregation",
            "properties": {
                "field_aggregation": {
                    "description": "x-displayName: \"Field Aggregation\"\nAggregate based on one of the key fields in the access log",
                    "title": "Field Aggregation",
                    "$ref": "#/definitions/logaccess_logFieldAggregation"
                }
            }
        },
        "logaccess_logFieldAggregation": {
            "type": "object",
            "description": "x-displayName: \"Field Aggregation\"\nAggregate access logs based on the key fields in the log.",
            "title": "Field Aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name by which the logs should be aggregated.",
                    "title": "field",
                    "$ref": "#/definitions/logaccess_logKeyField"
                },
                "topk": {
                    "type": "integer",
                    "description": "x-displayName: \"TopK\"\n\nNumber of top field values to be returned in the response.\nOptional: If not specified, top 5 values will be returned in the response.",
                    "title": "topk",
                    "format": "int64"
                }
            }
        },
        "logaccess_logKeyField": {
            "type": "string",
            "description": "x-displayName: \"Key Field\"\nAccess log can be aggregated based on these fields.\n\n - API_ENDPOINT: x-displayName: \"API Endpoint\"\n - APP_TYPE: x-displayName: \"App Type\"\n - AUTHORITY: x-displayName: \"Authority\"\n - ASN: x-displayName: \"ASN\"\n - BROWSER_TYPE: x-displayName: \"Browser Type\"\n - CITY: x-displayName: \"City\"\n - COUNTRY: x-displayName: \"Country\"\n - DEVICE_TYPE: x-displayName: \"Device Type\"\n - DST: x-displayName: \"Destination Service\"\n - DST_INSTANCE: x-displayName: \"Destination Instance\"\n - DST_SITE: x-displayName: \"Destination Site\"\n - METHOD: x-displayName: \"Method\"\n - SCHEME: x-displayName: \"Scheme\"\n - REMOTE_LOCATION: x-displayName: \"Remote Location\"\n - REQ_PATH: x-displayName: \"Request Path\"\n - RSP_CODE: x-displayName: \"Response Code\"\n - RSP_CODE_CLASS: x-displayName: \"Response Code Class\"\n - SRC: x-displayName: \"Source Service\"\n - SRC_INSTANCE: x-displayName: \"Source Instance\"\n - SRC_IP: x-displayName: \"Source IP\"\n - SRC_SITE: x-displayName: \"Source Site\"\n - TLS_CIPHER_SUITE: x-displayName: \"TLS Cipher Suite\"\n - TLS_FINGERPRINT: x-displayName: \"TLS Fingerprint\"\n - TLS_VERSION: x-displayName: \"TLS Version\"\n - USER: x-displayName: \"User\"\n - VH_NAME: x-displayName: \"Virtual Host Name\"\n - VH_TYPE: x-displayName: \"Virtual Host Type\"\n - VISITOR_ID: x-displayName: \"Visitor Id\"",
            "title": "Key Field",
            "enum": [
                "API_ENDPOINT",
                "APP_TYPE",
                "AUTHORITY",
                "ASN",
                "BROWSER_TYPE",
                "CITY",
                "COUNTRY",
                "DEVICE_TYPE",
                "DST",
                "DST_INSTANCE",
                "DST_SITE",
                "METHOD",
                "SCHEME",
                "REMOTE_LOCATION",
                "REQ_PATH",
                "RSP_CODE",
                "RSP_CODE_CLASS",
                "SRC",
                "SRC_INSTANCE",
                "SRC_IP",
                "SRC_SITE",
                "TLS_CIPHER_SUITE",
                "TLS_FINGERPRINT",
                "TLS_VERSION",
                "USER",
                "VH_NAME",
                "VH_TYPE",
                "VISITOR_ID"
            ],
            "default": "API_ENDPOINT"
        },
        "logaudit_logAggregationRequest": {
            "type": "object",
            "description": "x-displayName: \"Aggregation Request\"\nAggregation request to provide analytics data over the log response",
            "title": "Aggregation Request",
            "properties": {
                "date_aggregation": {
                    "description": "x-displayName: \"Date Aggregation\"\nAggregate based on timestamp in the log",
                    "title": "Date Aggregation",
                    "$ref": "#/definitions/logaudit_logDateAggregation"
                },
                "field_aggregation": {
                    "description": "x-displayName: \"Field Aggregation\"\nAggregate based on one of the key fields in the log",
                    "title": "Field Aggregation",
                    "$ref": "#/definitions/logaudit_logFieldAggregation"
                }
            }
        },
        "logaudit_logDateAggregation": {
            "type": "object",
            "description": "x-displayName: \"Date Aggregation\"\nAggregate access logs based on timestamp in the log",
            "title": "Date Aggregation",
            "properties": {
                "step": {
                    "type": "string",
                    "description": "x-displayName: \"Step\"\nx-required\nx-example: \"5m\"\n\nstep is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\nThe timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\nFormat: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days",
                    "title": "step"
                }
            }
        },
        "logaudit_logFieldAggregation": {
            "type": "object",
            "description": "x-displayName: \"Field Aggregation\"\nAggregate access logs based on the key fields in the log.",
            "title": "Field Aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name by which the logs should be aggregated.",
                    "title": "field",
                    "$ref": "#/definitions/logaudit_logKeyField"
                },
                "topk": {
                    "type": "integer",
                    "description": "x-displayName: \"TopK\"\n\nNumber of top field values to be returned in the response.\nOptional: If not specified, top 5 values will be returned in the response.",
                    "title": "topk",
                    "format": "int64"
                }
            }
        },
        "logaudit_logKeyField": {
            "type": "string",
            "description": "x-displayName: \"Key Field\"\n\n - AUTHORITY: x-displayName: \"Authority\"\n - DST: x-displayName: \"Destination Service\"\n - DST_INSTANCE: x-displayName: \"Destination Instance\"\n - DST_SITE: x-displayName: \"Destination Site\"\n - METHOD: x-displayName: \"Method\"\n - SCHEME: x-displayName: \"Scheme\"\n - REQ_PATH: x-displayName: \"Request Path\"\n - RSP_CODE: x-displayName: \"Response Code\"\n - SRC: x-displayName: \"Source Service\"\n - SRC_INSTANCE: x-displayName: \"Source Instance\"\n - SRC_SITE: x-displayName: \"Source Site\"\n - TRANSPORT: x-displayName: \"Trasnsport\"\n - USER: x-displayName: \"User\"",
            "title": "KeyField",
            "enum": [
                "AUTHORITY",
                "DST",
                "DST_INSTANCE",
                "DST_SITE",
                "METHOD",
                "SCHEME",
                "REQ_PATH",
                "RSP_CODE",
                "SRC",
                "SRC_INSTANCE",
                "SRC_SITE",
                "TRANSPORT",
                "USER"
            ],
            "default": "AUTHORITY"
        },
        "logfirewall_logAggregationRequest": {
            "type": "object",
            "description": "x-displayName: \"Aggregation Request\"\nAggregation request to provide analytics data over the log response",
            "title": "Aggregation Request",
            "properties": {
                "cardinality_aggregation": {
                    "description": "x-displayName: \"Cardinality Aggregation\"\nGet approximate count of distinct values for a field in the log",
                    "title": "Cardinality Aggregation",
                    "$ref": "#/definitions/logfirewall_logCardinalityAggregation"
                },
                "date_aggregation": {
                    "description": "x-displayName: \"Date Aggregation\"\nAggregate based on timestamp in the log",
                    "title": "Date Aggregation",
                    "$ref": "#/definitions/logfirewall_logDateAggregation"
                },
                "field_aggregation": {
                    "description": "x-displayName: \"Field Aggregation\"\nAggregate based on one of the key fields in the log",
                    "title": "Field Aggregation",
                    "$ref": "#/definitions/logfirewall_logFieldAggregation"
                }
            }
        },
        "logfirewall_logCardinalityAggregation": {
            "type": "object",
            "description": "x-displayName: \"Cardinality Aggregation\"\nGet approximate count of distinct values for the field in the firewall log.",
            "title": "Cardinality Aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name for which count of distinct values should be computed.",
                    "title": "field",
                    "$ref": "#/definitions/logfirewall_logKeyField"
                }
            }
        },
        "logfirewall_logDateAggregation": {
            "type": "object",
            "description": "x-displayName: Date Aggregation\nAggregate firewall logs based on timestamp in the log",
            "title": "Date Aggregation",
            "properties": {
                "step": {
                    "type": "string",
                    "description": "x-displayName: \"Step\"\nx-required\nx-example: \"5m\"\n\nstep is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\nThe timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\nFormat: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days",
                    "title": "step"
                },
                "sub_aggs": {
                    "type": "object",
                    "description": "x-displayName: \"Sub Aggregation\"\nThis option provides sub-aggregation for each date bucket",
                    "title": "sub aggregation"
                }
            }
        },
        "logfirewall_logDateSubAggregation": {
            "type": "object",
            "description": "x-displayName: Date SubAggregation\nAggregate firewall logs in each date bucket based on one of the sub aggregation types",
            "title": "Date SubAggregation",
            "properties": {
                "field_aggregation": {
                    "description": "x-displayName: \"Field Aggregation\"\nAggregate based on one of the key fields in the firewall log",
                    "title": "Field Aggregation",
                    "$ref": "#/definitions/logfirewall_logFieldAggregation"
                }
            }
        },
        "logfirewall_logFieldAggregation": {
            "type": "object",
            "description": "x-displayName: \"Field Aggregation\"\nAggregate firewall logs based on the key fields in the log.",
            "title": "Field Aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name by which the logs should be aggregated.",
                    "title": "field",
                    "$ref": "#/definitions/logfirewall_logKeyField"
                },
                "topk": {
                    "type": "integer",
                    "description": "x-displayName: \"TopK\"\n\nNumber of top field values to be returned in the response.\nOptional: If not specified, top 5 values will be returned in the response.",
                    "title": "topk",
                    "format": "int64"
                }
            }
        },
        "logfirewall_logKeyField": {
            "type": "string",
            "description": "x-displayName: \"Key Field\"\nFirewall log can be aggregated based on these fields.\n\n - SITE: x-displayName: \"Site\"\n - SRC_IP: x-displayName: \"Source IP Address\"\n - DST_IP: x-displayName: \"Destination IP Address\"\n - POLICY: x-displayName: \"Policy\"\n - POLICY_RULE: x-displayName: \"Policy Rule\"\n - POLICY_HITS_RESULT: x-displayName: \"Policy Hit Result\"",
            "title": "Key Field",
            "enum": [
                "SITE",
                "SRC_IP",
                "DST_IP",
                "POLICY",
                "POLICY_RULE",
                "POLICY_HITS_RESULT"
            ],
            "default": "SITE"
        },
        "logk8s_audit_logAggregationRequest": {
            "type": "object",
            "description": "x-displayName: \"Aggregation Request\"\nAggregation request to provide analytics data over the log response",
            "title": "Aggregation Request",
            "properties": {
                "date_aggregation": {
                    "description": "x-displayName: \"Date Aggregation\"\nAggregate based on timestamp in the log",
                    "title": "Date Aggregation",
                    "$ref": "#/definitions/logk8s_audit_logDateAggregation"
                }
            }
        },
        "logk8s_audit_logDateAggregation": {
            "type": "object",
            "description": "x-displayName: Date Aggregation\nAggregate K8s audit logs based on timestamp in the log",
            "title": "Date Aggregation",
            "properties": {
                "step": {
                    "type": "string",
                    "description": "x-displayName: \"Step\"\nx-required\nx-example: \"5m\"\n\nstep is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\nThe timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\nFormat: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days",
                    "title": "step"
                }
            }
        },
        "logk8s_eventsAggregationRequest": {
            "type": "object",
            "description": "x-displayName: \"Aggregation Request\"\nAggregation request to provide analytics data over the K8s events",
            "title": "Aggregation Request",
            "properties": {
                "date_aggregation": {
                    "description": "x-displayName: \"Date Aggregation\"\nAggregate based on timestamp in the K8s event",
                    "title": "Date Aggregation",
                    "$ref": "#/definitions/logk8s_eventsDateAggregation"
                },
                "field_aggregation": {
                    "description": "x-displayName: \"Field Aggregation\"\nAggregate based on one of the key fields in the K8s event",
                    "title": "Field Aggregation",
                    "$ref": "#/definitions/logk8s_eventsFieldAggregation"
                }
            }
        },
        "logk8s_eventsDateAggregation": {
            "type": "object",
            "description": "x-displayName: Date Aggregation\nAggregate K8s events based on timestamp in the event",
            "title": "Date Aggregation",
            "properties": {
                "step": {
                    "type": "string",
                    "description": "x-displayName: \"Step\"\nx-required\nx-example: \"5m\"\n\nstep is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\nThe timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\nFormat: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days",
                    "title": "step"
                }
            }
        },
        "logk8s_eventsFieldAggregation": {
            "type": "object",
            "description": "x-displayName: \"Field Aggregation\"\nAggregate K8s events based on the key fields.",
            "title": "Field Aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name by which the K8s events should be aggregated.",
                    "title": "field",
                    "$ref": "#/definitions/logk8s_eventsKeyField"
                },
                "topk": {
                    "type": "integer",
                    "description": "x-displayName: \"TopK\"\n\nNumber of top field values to be returned in the response.\nOptional: If not specified, top 5 values will be returned in the response.",
                    "title": "topk",
                    "format": "int64"
                }
            }
        },
        "logk8s_eventsKeyField": {
            "type": "string",
            "description": "x-displayName: \"Key Field\"\nK8s events can be aggregated based on these fields.\n\n - INVOLVED_OBJECT_KIND: x-displayName: \"Involved Object Kind\"\n - INVOLVED_OBJECT_NAME: x-displayName: \"Involved Object Name\"\n - TYPE: x-displayName: \"Type\"\n - REASON: x-displayName: \"Reason\"\n - SOURCE_COMPONENT: x-displayName: \"Source Component\"",
            "title": "Key Field",
            "enum": [
                "INVOLVED_OBJECT_KIND",
                "INVOLVED_OBJECT_NAME",
                "TYPE",
                "REASON",
                "SOURCE_COMPONENT"
            ],
            "default": "INVOLVED_OBJECT_KIND"
        },
        "logvk8s_audit_logAggregationRequest": {
            "type": "object",
            "description": "x-displayName: \"Aggregation Request\"\nAggregation request to provide analytics data over the log response",
            "title": "Aggregation Request",
            "properties": {
                "date_aggregation": {
                    "description": "x-displayName: \"Date Aggregation\"\nAggregate based on timestamp in the log",
                    "title": "Date Aggregation",
                    "$ref": "#/definitions/logvk8s_audit_logDateAggregation"
                }
            }
        },
        "logvk8s_audit_logDateAggregation": {
            "type": "object",
            "description": "x-displayName: Date Aggregation\nAggregate vK8s audit logs based on timestamp in the log",
            "title": "Date Aggregation",
            "properties": {
                "step": {
                    "type": "string",
                    "description": "x-displayName: \"Step\"\nx-required\nx-example: \"5m\"\n\nstep is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\nThe timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\nFormat: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days",
                    "title": "step"
                }
            }
        },
        "logvk8s_eventsAggregationRequest": {
            "type": "object",
            "description": "x-displayName: \"Aggregation Request\"\nAggregation request to provide analytics data over the vK8s events",
            "title": "Aggregation Request",
            "properties": {
                "date_aggregation": {
                    "description": "x-displayName: \"Date Aggregation\"\nAggregate based on timestamp in the vK8s event",
                    "title": "Date Aggregation",
                    "$ref": "#/definitions/logvk8s_eventsDateAggregation"
                },
                "field_aggregation": {
                    "description": "x-displayName: \"Field Aggregation\"\nAggregate based on one of the key fields in the vK8s event",
                    "title": "Field Aggregation",
                    "$ref": "#/definitions/logvk8s_eventsFieldAggregation"
                }
            }
        },
        "logvk8s_eventsDateAggregation": {
            "type": "object",
            "description": "x-displayName: Date Aggregation\nAggregate vK8s events based on timestamp in the event",
            "title": "Date Aggregation",
            "properties": {
                "step": {
                    "type": "string",
                    "description": "x-displayName: \"Step\"\nx-required\nx-example: \"5m\"\n\nstep is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\nThe timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\nFormat: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days",
                    "title": "step"
                }
            }
        },
        "logvk8s_eventsFieldAggregation": {
            "type": "object",
            "description": "x-displayName: \"Field Aggregation\"\nAggregate vK8s events based on the key fields.",
            "title": "Field Aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name by which the vK8s events should be aggregated.",
                    "title": "field",
                    "$ref": "#/definitions/logvk8s_eventsKeyField"
                },
                "topk": {
                    "type": "integer",
                    "description": "x-displayName: \"TopK\"\n\nNumber of top field values to be returned in the response.\nOptional: If not specified, top 5 values will be returned in the response.",
                    "title": "topk",
                    "format": "int64"
                }
            }
        },
        "logvk8s_eventsKeyField": {
            "type": "string",
            "description": "x-displayName: \"Key Field\"\nvK8s events can be aggregated based on these fields.\n\n - INVOLVED_OBJECT_KIND: x-displayName: \"Involved Object Kind\"\n - INVOLVED_OBJECT_NAME: x-displayName: \"Involved Object Name\"\n - TYPE: x-displayName: \"Type\"\n - REASON: x-displayName: \"Reason\"\n - SOURCE_COMPONENT: x-displayName: \"Source Component\"\n - SITE: x-displayName: \"Site\"",
            "title": "Key Field",
            "enum": [
                "INVOLVED_OBJECT_KIND",
                "INVOLVED_OBJECT_NAME",
                "TYPE",
                "REASON",
                "SOURCE_COMPONENT",
                "SITE"
            ],
            "default": "INVOLVED_OBJECT_KIND"
        },
        "schemaSortOrder": {
            "type": "string",
            "description": "Sort algorithm\n\nSort in descending order\nSort in ascending order",
            "title": "SortOrder",
            "enum": [
                "DESCENDING",
                "ASCENDING"
            ],
            "default": "DESCENDING",
            "x-displayname": "Sort Order",
            "x-ves-proto-enum": "ves.io.schema.SortOrder"
        }
    },
    "x-displayname": "Logs",
    "x-ves-proto-file": "ves.io/schema/log/public_customapi.proto"
}`
