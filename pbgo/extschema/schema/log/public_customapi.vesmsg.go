//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package log

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema_log_access_log "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema/log/access_log"
	ves_io_schema_log_audit_log "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema/log/audit_log"
	ves_io_schema_log_firewall_log "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema/log/firewall_log"
	ves_io_schema_log_vk8s_audit_log "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema/log/vk8s_audit_log"
	ves_io_schema_log_vk8s_events "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema/log/vk8s_events"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AccessLogAggregationRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AccessLogAggregationRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AccessLogAggregationRequest) DeepCopy() *AccessLogAggregationRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AccessLogAggregationRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AccessLogAggregationRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AccessLogAggregationRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AccessLogAggregationRequestValidator().Validate(ctx, m, opts...)
}

type ValidateAccessLogAggregationRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAccessLogAggregationRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AccessLogAggregationRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AccessLogAggregationRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAccessLogAggregationRequestValidator = func() *ValidateAccessLogAggregationRequest {
	v := &ValidateAccessLogAggregationRequest{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggs"] = ves_io_schema_log_access_log.AggregationRequestValidator().Validate

	return v
}()

func AccessLogAggregationRequestValidator() db.Validator {
	return DefaultAccessLogAggregationRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *AccessLogRequestV2) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AccessLogRequestV2) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AccessLogRequestV2) DeepCopy() *AccessLogRequestV2 {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AccessLogRequestV2{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AccessLogRequestV2) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AccessLogRequestV2) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AccessLogRequestV2Validator().Validate(ctx, m, opts...)
}

type ValidateAccessLogRequestV2 struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAccessLogRequestV2) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AccessLogRequestV2)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AccessLogRequestV2 got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit"]; exists {

		vOpts := append(opts, db.WithValidateField("limit"))
		if err := fv(ctx, m.GetLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scroll"]; exists {

		vOpts := append(opts, db.WithValidateField("scroll"))
		if err := fv(ctx, m.GetScroll(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sort"]; exists {

		vOpts := append(opts, db.WithValidateField("sort"))
		if err := fv(ctx, m.GetSort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAccessLogRequestV2Validator = func() *ValidateAccessLogRequestV2 {
	v := &ValidateAccessLogRequestV2{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggs"] = ves_io_schema_log_access_log.AggregationRequestValidator().Validate

	return v
}()

func AccessLogRequestV2Validator() db.Validator {
	return DefaultAccessLogRequestV2Validator
}

// augmented methods on protoc/std generated struct

func (m *AuditLogAggregationRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AuditLogAggregationRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AuditLogAggregationRequest) DeepCopy() *AuditLogAggregationRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AuditLogAggregationRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AuditLogAggregationRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AuditLogAggregationRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AuditLogAggregationRequestValidator().Validate(ctx, m, opts...)
}

type ValidateAuditLogAggregationRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAuditLogAggregationRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AuditLogAggregationRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AuditLogAggregationRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAuditLogAggregationRequestValidator = func() *ValidateAuditLogAggregationRequest {
	v := &ValidateAuditLogAggregationRequest{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggs"] = ves_io_schema_log_audit_log.AggregationRequestValidator().Validate

	return v
}()

func AuditLogAggregationRequestValidator() db.Validator {
	return DefaultAuditLogAggregationRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *AuditLogRequestV2) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AuditLogRequestV2) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AuditLogRequestV2) DeepCopy() *AuditLogRequestV2 {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AuditLogRequestV2{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AuditLogRequestV2) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AuditLogRequestV2) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AuditLogRequestV2Validator().Validate(ctx, m, opts...)
}

type ValidateAuditLogRequestV2 struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAuditLogRequestV2) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AuditLogRequestV2)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AuditLogRequestV2 got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit"]; exists {

		vOpts := append(opts, db.WithValidateField("limit"))
		if err := fv(ctx, m.GetLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scroll"]; exists {

		vOpts := append(opts, db.WithValidateField("scroll"))
		if err := fv(ctx, m.GetScroll(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sort"]; exists {

		vOpts := append(opts, db.WithValidateField("sort"))
		if err := fv(ctx, m.GetSort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAuditLogRequestV2Validator = func() *ValidateAuditLogRequestV2 {
	v := &ValidateAuditLogRequestV2{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggs"] = ves_io_schema_log_audit_log.AggregationRequestValidator().Validate

	return v
}()

func AuditLogRequestV2Validator() db.Validator {
	return DefaultAuditLogRequestV2Validator
}

// augmented methods on protoc/std generated struct

func (m *FirewallLogAggregationRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FirewallLogAggregationRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FirewallLogAggregationRequest) DeepCopy() *FirewallLogAggregationRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FirewallLogAggregationRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FirewallLogAggregationRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FirewallLogAggregationRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FirewallLogAggregationRequestValidator().Validate(ctx, m, opts...)
}

type ValidateFirewallLogAggregationRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFirewallLogAggregationRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FirewallLogAggregationRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FirewallLogAggregationRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFirewallLogAggregationRequestValidator = func() *ValidateFirewallLogAggregationRequest {
	v := &ValidateFirewallLogAggregationRequest{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggs"] = ves_io_schema_log_firewall_log.AggregationRequestValidator().Validate

	return v
}()

func FirewallLogAggregationRequestValidator() db.Validator {
	return DefaultFirewallLogAggregationRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *FirewallLogRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FirewallLogRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FirewallLogRequest) DeepCopy() *FirewallLogRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FirewallLogRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FirewallLogRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FirewallLogRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FirewallLogRequestValidator().Validate(ctx, m, opts...)
}

type ValidateFirewallLogRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFirewallLogRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FirewallLogRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FirewallLogRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit"]; exists {

		vOpts := append(opts, db.WithValidateField("limit"))
		if err := fv(ctx, m.GetLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scroll"]; exists {

		vOpts := append(opts, db.WithValidateField("scroll"))
		if err := fv(ctx, m.GetScroll(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sort"]; exists {

		vOpts := append(opts, db.WithValidateField("sort"))
		if err := fv(ctx, m.GetSort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFirewallLogRequestValidator = func() *ValidateFirewallLogRequest {
	v := &ValidateFirewallLogRequest{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggs"] = ves_io_schema_log_firewall_log.AggregationRequestValidator().Validate

	return v
}()

func FirewallLogRequestValidator() db.Validator {
	return DefaultFirewallLogRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *LogAggregationResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LogAggregationResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LogAggregationResponse) DeepCopy() *LogAggregationResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LogAggregationResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LogAggregationResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LogAggregationResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LogAggregationResponseValidator().Validate(ctx, m, opts...)
}

type ValidateLogAggregationResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLogAggregationResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LogAggregationResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LogAggregationResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["total_hits"]; exists {

		vOpts := append(opts, db.WithValidateField("total_hits"))
		if err := fv(ctx, m.GetTotalHits(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLogAggregationResponseValidator = func() *ValidateLogAggregationResponse {
	v := &ValidateLogAggregationResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LogAggregationResponseValidator() db.Validator {
	return DefaultLogAggregationResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *LogResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LogResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LogResponse) DeepCopy() *LogResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LogResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LogResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LogResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LogResponseValidator().Validate(ctx, m, opts...)
}

type ValidateLogResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLogResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LogResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LogResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["logs"]; exists {

		vOpts := append(opts, db.WithValidateField("logs"))
		for idx, item := range m.GetLogs() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["scroll_id"]; exists {

		vOpts := append(opts, db.WithValidateField("scroll_id"))
		if err := fv(ctx, m.GetScrollId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["total_hits"]; exists {

		vOpts := append(opts, db.WithValidateField("total_hits"))
		if err := fv(ctx, m.GetTotalHits(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLogResponseValidator = func() *ValidateLogResponse {
	v := &ValidateLogResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LogResponseValidator() db.Validator {
	return DefaultLogResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *LogScrollRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LogScrollRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LogScrollRequest) DeepCopy() *LogScrollRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LogScrollRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LogScrollRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LogScrollRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LogScrollRequestValidator().Validate(ctx, m, opts...)
}

type ValidateLogScrollRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLogScrollRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LogScrollRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LogScrollRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scroll_id"]; exists {

		vOpts := append(opts, db.WithValidateField("scroll_id"))
		if err := fv(ctx, m.GetScrollId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLogScrollRequestValidator = func() *ValidateLogScrollRequest {
	v := &ValidateLogScrollRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LogScrollRequestValidator() db.Validator {
	return DefaultLogScrollRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *VK8SAuditLogAggregationRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VK8SAuditLogAggregationRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VK8SAuditLogAggregationRequest) DeepCopy() *VK8SAuditLogAggregationRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VK8SAuditLogAggregationRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VK8SAuditLogAggregationRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VK8SAuditLogAggregationRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VK8SAuditLogAggregationRequestValidator().Validate(ctx, m, opts...)
}

type ValidateVK8SAuditLogAggregationRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVK8SAuditLogAggregationRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VK8SAuditLogAggregationRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VK8SAuditLogAggregationRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVK8SAuditLogAggregationRequestValidator = func() *ValidateVK8SAuditLogAggregationRequest {
	v := &ValidateVK8SAuditLogAggregationRequest{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggs"] = ves_io_schema_log_vk8s_audit_log.AggregationRequestValidator().Validate

	return v
}()

func VK8SAuditLogAggregationRequestValidator() db.Validator {
	return DefaultVK8SAuditLogAggregationRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *VK8SAuditLogRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VK8SAuditLogRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VK8SAuditLogRequest) DeepCopy() *VK8SAuditLogRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VK8SAuditLogRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VK8SAuditLogRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VK8SAuditLogRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VK8SAuditLogRequestValidator().Validate(ctx, m, opts...)
}

type ValidateVK8SAuditLogRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVK8SAuditLogRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VK8SAuditLogRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VK8SAuditLogRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit"]; exists {

		vOpts := append(opts, db.WithValidateField("limit"))
		if err := fv(ctx, m.GetLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scroll"]; exists {

		vOpts := append(opts, db.WithValidateField("scroll"))
		if err := fv(ctx, m.GetScroll(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sort"]; exists {

		vOpts := append(opts, db.WithValidateField("sort"))
		if err := fv(ctx, m.GetSort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVK8SAuditLogRequestValidator = func() *ValidateVK8SAuditLogRequest {
	v := &ValidateVK8SAuditLogRequest{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggs"] = ves_io_schema_log_vk8s_audit_log.AggregationRequestValidator().Validate

	return v
}()

func VK8SAuditLogRequestValidator() db.Validator {
	return DefaultVK8SAuditLogRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *VK8SEventsAggregationRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VK8SEventsAggregationRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VK8SEventsAggregationRequest) DeepCopy() *VK8SEventsAggregationRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VK8SEventsAggregationRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VK8SEventsAggregationRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VK8SEventsAggregationRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VK8SEventsAggregationRequestValidator().Validate(ctx, m, opts...)
}

type ValidateVK8SEventsAggregationRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVK8SEventsAggregationRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VK8SEventsAggregationRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VK8SEventsAggregationRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVK8SEventsAggregationRequestValidator = func() *ValidateVK8SEventsAggregationRequest {
	v := &ValidateVK8SEventsAggregationRequest{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggs"] = ves_io_schema_log_vk8s_events.AggregationRequestValidator().Validate

	return v
}()

func VK8SEventsAggregationRequestValidator() db.Validator {
	return DefaultVK8SEventsAggregationRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *VK8SEventsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VK8SEventsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VK8SEventsRequest) DeepCopy() *VK8SEventsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VK8SEventsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VK8SEventsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VK8SEventsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VK8SEventsRequestValidator().Validate(ctx, m, opts...)
}

type ValidateVK8SEventsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVK8SEventsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VK8SEventsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VK8SEventsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit"]; exists {

		vOpts := append(opts, db.WithValidateField("limit"))
		if err := fv(ctx, m.GetLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scroll"]; exists {

		vOpts := append(opts, db.WithValidateField("scroll"))
		if err := fv(ctx, m.GetScroll(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sort"]; exists {

		vOpts := append(opts, db.WithValidateField("sort"))
		if err := fv(ctx, m.GetSort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVK8SEventsRequestValidator = func() *ValidateVK8SEventsRequest {
	v := &ValidateVK8SEventsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggs"] = ves_io_schema_log_vk8s_events.AggregationRequestValidator().Validate

	return v
}()

func VK8SEventsRequestValidator() db.Validator {
	return DefaultVK8SEventsRequestValidator
}
