// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package report_config

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_report "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/report"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CustomAPIListResponseItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CustomAPIListResponseItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CustomAPIListResponseItem) DeepCopy() *CustomAPIListResponseItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CustomAPIListResponseItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CustomAPIListResponseItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CustomAPIListResponseItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CustomAPIListResponseItemValidator().Validate(ctx, m, opts...)
}

func (m *CustomAPIListResponseItem) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetGetSpecDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetGetSpecDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *CustomAPIListResponseItem) GetGetSpecDRefInfo() ([]db.DRefInfo, error) {
	if m.GetGetSpec() == nil {
		return nil, nil
	}

	drInfos, err := m.GetGetSpec().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetGetSpec().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "get_spec." + dri.DRField
	}
	return drInfos, err

}

type ValidateCustomAPIListResponseItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCustomAPIListResponseItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CustomAPIListResponseItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CustomAPIListResponseItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["annotations"]; exists {

		vOpts := append(opts, db.WithValidateField("annotations"))
		for key, value := range m.GetAnnotations() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disabled"]; exists {

		vOpts := append(opts, db.WithValidateField("disabled"))
		if err := fv(ctx, m.GetDisabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["get_spec"]; exists {

		vOpts := append(opts, db.WithValidateField("get_spec"))
		if err := fv(ctx, m.GetGetSpec(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["object"]; exists {

		vOpts := append(opts, db.WithValidateField("object"))
		if err := fv(ctx, m.GetObject(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["owner_view"]; exists {

		vOpts := append(opts, db.WithValidateField("owner_view"))
		if err := fv(ctx, m.GetOwnerView(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["system_metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("system_metadata"))
		if err := fv(ctx, m.GetSystemMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant"))
		if err := fv(ctx, m.GetTenant(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["uid"]; exists {

		vOpts := append(opts, db.WithValidateField("uid"))
		if err := fv(ctx, m.GetUid(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCustomAPIListResponseItemValidator = func() *ValidateCustomAPIListResponseItem {
	v := &ValidateCustomAPIListResponseItem{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["object"] = ves_io_schema_report.ObjectValidator().Validate

	v.FldValidators["get_spec"] = ves_io_schema_report.GetSpecTypeValidator().Validate

	v.FldValidators["metadata"] = ves_io_schema.ObjectGetMetaTypeValidator().Validate

	return v
}()

func CustomAPIListResponseItemValidator() db.Validator {
	return DefaultCustomAPIListResponseItemValidator
}

// augmented methods on protoc/std generated struct

func (m *GenerateReportRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GenerateReportRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GenerateReportRequest) DeepCopy() *GenerateReportRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GenerateReportRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GenerateReportRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GenerateReportRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GenerateReportRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGenerateReportRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGenerateReportRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateGenerateReportRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateGenerateReportRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GenerateReportRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GenerateReportRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGenerateReportRequestValidator = func() *ValidateGenerateReportRequest {
	v := &ValidateGenerateReportRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GenerateReportRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GenerateReportRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func GenerateReportRequestValidator() db.Validator {
	return DefaultGenerateReportRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GenerateReportResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GenerateReportResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GenerateReportResponse) DeepCopy() *GenerateReportResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GenerateReportResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GenerateReportResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GenerateReportResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GenerateReportResponseValidator().Validate(ctx, m, opts...)
}

type ValidateGenerateReportResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGenerateReportResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GenerateReportResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GenerateReportResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGenerateReportResponseValidator = func() *ValidateGenerateReportResponse {
	v := &ValidateGenerateReportResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GenerateReportResponseValidator() db.Validator {
	return DefaultGenerateReportResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListReportsHistoryRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListReportsHistoryRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListReportsHistoryRequest) DeepCopy() *ListReportsHistoryRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListReportsHistoryRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListReportsHistoryRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListReportsHistoryRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListReportsHistoryRequestValidator().Validate(ctx, m, opts...)
}

type ValidateListReportsHistoryRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListReportsHistoryRequest) ReportConfigurationNamesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for report_configuration_names")
	}
	return validatorFn, nil
}

func (v *ValidateListReportsHistoryRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateListReportsHistoryRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListReportsHistoryRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListReportsHistoryRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["report_configuration_names"]; exists {
		val := m.GetReportConfigurationNames()
		vOpts := append(opts,
			db.WithValidateField("report_configuration_names"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetReportConfigurationNames().(type) {
	case *ListReportsHistoryRequest_ReportConfigNames:
		if fv, exists := v.FldValidators["report_configuration_names.report_config_names"]; exists {
			val := m.GetReportConfigurationNames().(*ListReportsHistoryRequest_ReportConfigNames).ReportConfigNames
			vOpts := append(opts,
				db.WithValidateField("report_configuration_names"),
				db.WithValidateField("report_config_names"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ListReportsHistoryRequest_IncludeAll:
		if fv, exists := v.FldValidators["report_configuration_names.include_all"]; exists {
			val := m.GetReportConfigurationNames().(*ListReportsHistoryRequest_IncludeAll).IncludeAll
			vOpts := append(opts,
				db.WithValidateField("report_configuration_names"),
				db.WithValidateField("include_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListReportsHistoryRequestValidator = func() *ValidateListReportsHistoryRequest {
	v := &ValidateListReportsHistoryRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhReportConfigurationNames := v.ReportConfigurationNamesValidationRuleHandler
	rulesReportConfigurationNames := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhReportConfigurationNames(rulesReportConfigurationNames)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListReportsHistoryRequest.report_configuration_names: %s", err)
		panic(errMsg)
	}
	v.FldValidators["report_configuration_names"] = vFn

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListReportsHistoryRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	v.FldValidators["report_configuration_names.report_config_names"] = ReportConfigurationNamesListValidator().Validate

	return v
}()

func ListReportsHistoryRequestValidator() db.Validator {
	return DefaultListReportsHistoryRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListReportsHistoryResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListReportsHistoryResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListReportsHistoryResponse) DeepCopy() *ListReportsHistoryResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListReportsHistoryResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListReportsHistoryResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListReportsHistoryResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListReportsHistoryResponseValidator().Validate(ctx, m, opts...)
}

func (m *ListReportsHistoryResponse) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetItemsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetItemsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetReportsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetReportsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetReportsListDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetReportsListDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *ListReportsHistoryResponse) GetItemsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetItems() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetItems() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetItems() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("items[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *ListReportsHistoryResponse) GetReportsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetReports() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetReports() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetReports() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("reports[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *ListReportsHistoryResponse) GetReportsListDRefInfo() ([]db.DRefInfo, error) {
	if m.GetReportsList() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetReportsList() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetReportsList() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("reports_list[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateListReportsHistoryResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListReportsHistoryResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListReportsHistoryResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListReportsHistoryResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["items"]; exists {

		vOpts := append(opts, db.WithValidateField("items"))
		for idx, item := range m.GetItems() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["reports"]; exists {

		vOpts := append(opts, db.WithValidateField("reports"))
		for idx, item := range m.GetReports() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["reports_list"]; exists {

		vOpts := append(opts, db.WithValidateField("reports_list"))
		for idx, item := range m.GetReportsList() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListReportsHistoryResponseValidator = func() *ValidateListReportsHistoryResponse {
	v := &ValidateListReportsHistoryResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["reports"] = ves_io_schema_report.GlobalSpecTypeValidator().Validate

	v.FldValidators["reports_list"] = ListReportsHistoryResponseItemValidator().Validate

	v.FldValidators["items"] = CustomAPIListResponseItemValidator().Validate

	return v
}()

func ListReportsHistoryResponseValidator() db.Validator {
	return DefaultListReportsHistoryResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListReportsHistoryResponseItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListReportsHistoryResponseItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListReportsHistoryResponseItem) DeepCopy() *ListReportsHistoryResponseItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListReportsHistoryResponseItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListReportsHistoryResponseItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListReportsHistoryResponseItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListReportsHistoryResponseItemValidator().Validate(ctx, m, opts...)
}

func (m *ListReportsHistoryResponseItem) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetSpecDRefInfo()

}

// GetDRefInfo for the field's type
func (m *ListReportsHistoryResponseItem) GetSpecDRefInfo() ([]db.DRefInfo, error) {
	if m.GetSpec() == nil {
		return nil, nil
	}

	drInfos, err := m.GetSpec().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetSpec().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "spec." + dri.DRField
	}
	return drInfos, err

}

type ValidateListReportsHistoryResponseItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListReportsHistoryResponseItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListReportsHistoryResponseItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListReportsHistoryResponseItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["spec"]; exists {

		vOpts := append(opts, db.WithValidateField("spec"))
		if err := fv(ctx, m.GetSpec(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListReportsHistoryResponseItemValidator = func() *ValidateListReportsHistoryResponseItem {
	v := &ValidateListReportsHistoryResponseItem{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["metadata"] = ves_io_schema.ObjectMetaTypeValidator().Validate

	v.FldValidators["spec"] = ves_io_schema_report.SpecTypeValidator().Validate

	return v
}()

func ListReportsHistoryResponseItemValidator() db.Validator {
	return DefaultListReportsHistoryResponseItemValidator
}

// augmented methods on protoc/std generated struct

func (m *ReportConfigurationNamesList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReportConfigurationNamesList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReportConfigurationNamesList) DeepCopy() *ReportConfigurationNamesList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReportConfigurationNamesList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReportConfigurationNamesList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReportConfigurationNamesList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReportConfigurationNamesListValidator().Validate(ctx, m, opts...)
}

type ValidateReportConfigurationNamesList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReportConfigurationNamesList) NamesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for names")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for names")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated names")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items names")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReportConfigurationNamesList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReportConfigurationNamesList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReportConfigurationNamesList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["names"]; exists {
		vOpts := append(opts, db.WithValidateField("names"))
		if err := fv(ctx, m.GetNames(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReportConfigurationNamesListValidator = func() *ValidateReportConfigurationNamesList {
	v := &ValidateReportConfigurationNamesList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNames := v.NamesValidationRuleHandler
	rulesNames := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "256",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhNames(rulesNames)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReportConfigurationNamesList.names: %s", err)
		panic(errMsg)
	}
	v.FldValidators["names"] = vFn

	return v
}()

func ReportConfigurationNamesListValidator() db.Validator {
	return DefaultReportConfigurationNamesListValidator
}
