//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package app_setting

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AppTypeSettings) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AppTypeSettings) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AppTypeSettings) DeepCopy() *AppTypeSettings {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AppTypeSettings{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AppTypeSettings) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AppTypeSettings) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AppTypeSettingsValidator().Validate(ctx, m, opts...)
}

func (m *AppTypeSettings) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAppTypeRefDRefInfo()

}

func (m *AppTypeSettings) GetAppTypeRefDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAppTypeRef()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("AppTypeSettings.app_type_ref[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "app_type.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "app_type_ref",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAppTypeRefDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *AppTypeSettings) GetAppTypeRefDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "app_type.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: app_type")
	}
	for _, ref := range m.GetAppTypeRef() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateAppTypeSettings struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAppTypeSettings) AppTypeRefValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for app_type_ref")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated app_type_ref")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items app_type_ref")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAppTypeSettings) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AppTypeSettings)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AppTypeSettings got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["app_type_ref"]; exists {
		vOpts := append(opts, db.WithValidateField("app_type_ref"))
		if err := fv(ctx, m.GetAppTypeRef(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["business_logic_markup_setting"]; exists {

		vOpts := append(opts, db.WithValidateField("business_logic_markup_setting"))
		if err := fv(ctx, m.GetBusinessLogicMarkupSetting(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["timeseries_analyses_setting"]; exists {

		vOpts := append(opts, db.WithValidateField("timeseries_analyses_setting"))
		if err := fv(ctx, m.GetTimeseriesAnalysesSetting(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_behavior_analysis_setting"]; exists {

		vOpts := append(opts, db.WithValidateField("user_behavior_analysis_setting"))
		if err := fv(ctx, m.GetUserBehaviorAnalysisSetting(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAppTypeSettingsValidator = func() *ValidateAppTypeSettings {
	v := &ValidateAppTypeSettings{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAppTypeRef := v.AppTypeRefValidationRuleHandler
	rulesAppTypeRef := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhAppTypeRef(rulesAppTypeRef)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppTypeSettings.app_type_ref: %s", err)
		panic(errMsg)
	}
	v.FldValidators["app_type_ref"] = vFn

	v.FldValidators["timeseries_analyses_setting"] = TimeseriesAnalysesSettingValidator().Validate

	v.FldValidators["user_behavior_analysis_setting"] = UserBehaviorAnalysisSettingValidator().Validate

	return v
}()

func AppTypeSettingsValidator() db.Validator {
	return DefaultAppTypeSettingsValidator
}

// augmented methods on protoc/std generated struct

func (m *BusinessLogicMarkupSetting) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BusinessLogicMarkupSetting) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BusinessLogicMarkupSetting) DeepCopy() *BusinessLogicMarkupSetting {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BusinessLogicMarkupSetting{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BusinessLogicMarkupSetting) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BusinessLogicMarkupSetting) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BusinessLogicMarkupSettingValidator().Validate(ctx, m, opts...)
}

type ValidateBusinessLogicMarkupSetting struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBusinessLogicMarkupSetting) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BusinessLogicMarkupSetting)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BusinessLogicMarkupSetting got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetLearnFromNamespace().(type) {
	case *BusinessLogicMarkupSetting_Enable:
		if fv, exists := v.FldValidators["learn_from_namespace.enable"]; exists {
			val := m.GetLearnFromNamespace().(*BusinessLogicMarkupSetting_Enable).Enable
			vOpts := append(opts,
				db.WithValidateField("learn_from_namespace"),
				db.WithValidateField("enable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BusinessLogicMarkupSetting_Disable:
		if fv, exists := v.FldValidators["learn_from_namespace.disable"]; exists {
			val := m.GetLearnFromNamespace().(*BusinessLogicMarkupSetting_Disable).Disable
			vOpts := append(opts,
				db.WithValidateField("learn_from_namespace"),
				db.WithValidateField("disable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBusinessLogicMarkupSettingValidator = func() *ValidateBusinessLogicMarkupSetting {
	v := &ValidateBusinessLogicMarkupSetting{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BusinessLogicMarkupSettingValidator() db.Validator {
	return DefaultBusinessLogicMarkupSettingValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAppTypeRefsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAppTypeRefsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetAppTypeSettingsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAppTypeSettingsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *CreateSpecType) GetAppTypeRefsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAppTypeRefs()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.app_type_refs[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "app_type.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "app_type_refs",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAppTypeRefsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetAppTypeRefsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "app_type.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: app_type")
	}
	for _, ref := range m.GetAppTypeRefs() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetAppTypeSettingsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAppTypeSettings() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetAppTypeSettings() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAppTypeSettings() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("app_type_settings[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) AppTypeSettingsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*AppTypeSettings, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := AppTypeSettingsValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for app_type_settings")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AppTypeSettings)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AppTypeSettings, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated app_type_settings")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items app_type_settings")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["anomaly_types"]; exists {

		vOpts := append(opts, db.WithValidateField("anomaly_types"))
		for idx, item := range m.GetAnomalyTypes() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["app_type_refs"]; exists {

		vOpts := append(opts, db.WithValidateField("app_type_refs"))
		for idx, item := range m.GetAppTypeRefs() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["app_type_settings"]; exists {
		vOpts := append(opts, db.WithValidateField("app_type_settings"))
		if err := fv(ctx, m.GetAppTypeSettings(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAppTypeSettings := v.AppTypeSettingsValidationRuleHandler
	rulesAppTypeSettings := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.min_items": "1",
	}
	vFn, err = vrhAppTypeSettings(rulesAppTypeSettings)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.app_type_settings: %s", err)
		panic(errMsg)
	}
	v.FldValidators["app_type_settings"] = vFn

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *FailedLoginActivitySetting) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FailedLoginActivitySetting) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FailedLoginActivitySetting) DeepCopy() *FailedLoginActivitySetting {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FailedLoginActivitySetting{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FailedLoginActivitySetting) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FailedLoginActivitySetting) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FailedLoginActivitySettingValidator().Validate(ctx, m, opts...)
}

type ValidateFailedLoginActivitySetting struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFailedLoginActivitySetting) LoginFailuresThresholdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for login_failures_threshold")
	}

	return validatorFn, nil
}

func (v *ValidateFailedLoginActivitySetting) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FailedLoginActivitySetting)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FailedLoginActivitySetting got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["login_failures_threshold"]; exists {

		vOpts := append(opts, db.WithValidateField("login_failures_threshold"))
		if err := fv(ctx, m.GetLoginFailuresThreshold(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFailedLoginActivitySettingValidator = func() *ValidateFailedLoginActivitySetting {
	v := &ValidateFailedLoginActivitySetting{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLoginFailuresThreshold := v.LoginFailuresThresholdValidationRuleHandler
	rulesLoginFailuresThreshold := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gt":        "0",
	}
	vFn, err = vrhLoginFailuresThreshold(rulesLoginFailuresThreshold)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FailedLoginActivitySetting.login_failures_threshold: %s", err)
		panic(errMsg)
	}
	v.FldValidators["login_failures_threshold"] = vFn

	return v
}()

func FailedLoginActivitySettingValidator() db.Validator {
	return DefaultFailedLoginActivitySettingValidator
}

// augmented methods on protoc/std generated struct

func (m *ForbiddenActivitySetting) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ForbiddenActivitySetting) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ForbiddenActivitySetting) DeepCopy() *ForbiddenActivitySetting {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ForbiddenActivitySetting{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ForbiddenActivitySetting) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ForbiddenActivitySetting) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ForbiddenActivitySettingValidator().Validate(ctx, m, opts...)
}

type ValidateForbiddenActivitySetting struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateForbiddenActivitySetting) ForbiddenRequestsThresholdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for forbidden_requests_threshold")
	}

	return validatorFn, nil
}

func (v *ValidateForbiddenActivitySetting) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ForbiddenActivitySetting)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ForbiddenActivitySetting got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["forbidden_requests_threshold"]; exists {

		vOpts := append(opts, db.WithValidateField("forbidden_requests_threshold"))
		if err := fv(ctx, m.GetForbiddenRequestsThreshold(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultForbiddenActivitySettingValidator = func() *ValidateForbiddenActivitySetting {
	v := &ValidateForbiddenActivitySetting{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhForbiddenRequestsThreshold := v.ForbiddenRequestsThresholdValidationRuleHandler
	rulesForbiddenRequestsThreshold := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gt":        "0",
	}
	vFn, err = vrhForbiddenRequestsThreshold(rulesForbiddenRequestsThreshold)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ForbiddenActivitySetting.forbidden_requests_threshold: %s", err)
		panic(errMsg)
	}
	v.FldValidators["forbidden_requests_threshold"] = vFn

	return v
}()

func ForbiddenActivitySettingValidator() db.Validator {
	return DefaultForbiddenActivitySettingValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAppTypeRefsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAppTypeRefsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetAppTypeSettingsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAppTypeSettingsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GetSpecType) GetAppTypeRefsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAppTypeRefs()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.app_type_refs[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "app_type.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "app_type_refs",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAppTypeRefsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetAppTypeRefsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "app_type.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: app_type")
	}
	for _, ref := range m.GetAppTypeRefs() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetAppTypeSettingsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAppTypeSettings() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetAppTypeSettings() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAppTypeSettings() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("app_type_settings[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) AppTypeSettingsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*AppTypeSettings, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := AppTypeSettingsValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for app_type_settings")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AppTypeSettings)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AppTypeSettings, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated app_type_settings")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items app_type_settings")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["anomaly_types"]; exists {

		vOpts := append(opts, db.WithValidateField("anomaly_types"))
		for idx, item := range m.GetAnomalyTypes() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["app_type_refs"]; exists {

		vOpts := append(opts, db.WithValidateField("app_type_refs"))
		for idx, item := range m.GetAppTypeRefs() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["app_type_settings"]; exists {
		vOpts := append(opts, db.WithValidateField("app_type_settings"))
		if err := fv(ctx, m.GetAppTypeSettings(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAppTypeSettings := v.AppTypeSettingsValidationRuleHandler
	rulesAppTypeSettings := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.min_items": "1",
	}
	vFn, err = vrhAppTypeSettings(rulesAppTypeSettings)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.app_type_settings: %s", err)
		panic(errMsg)
	}
	v.FldValidators["app_type_settings"] = vFn

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAppTypeRefsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAppTypeRefsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetAppTypeSettingsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAppTypeSettingsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GlobalSpecType) GetAppTypeRefsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAppTypeRefs()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.app_type_refs[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "app_type.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "app_type_refs",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAppTypeRefsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetAppTypeRefsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "app_type.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: app_type")
	}
	for _, ref := range m.GetAppTypeRefs() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetAppTypeSettingsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAppTypeSettings() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetAppTypeSettings() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAppTypeSettings() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("app_type_settings[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) AppTypeSettingsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*AppTypeSettings, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := AppTypeSettingsValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for app_type_settings")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AppTypeSettings)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AppTypeSettings, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated app_type_settings")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items app_type_settings")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["anomaly_types"]; exists {

		vOpts := append(opts, db.WithValidateField("anomaly_types"))
		for idx, item := range m.GetAnomalyTypes() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["app_type_refs"]; exists {

		vOpts := append(opts, db.WithValidateField("app_type_refs"))
		for idx, item := range m.GetAppTypeRefs() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["app_type_settings"]; exists {
		vOpts := append(opts, db.WithValidateField("app_type_settings"))
		if err := fv(ctx, m.GetAppTypeSettings(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAppTypeSettings := v.AppTypeSettingsValidationRuleHandler
	rulesAppTypeSettings := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.min_items": "1",
	}
	vFn, err = vrhAppTypeSettings(rulesAppTypeSettings)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.app_type_settings: %s", err)
		panic(errMsg)
	}
	v.FldValidators["app_type_settings"] = vFn

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *MaliciousUserDetectionSetting) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MaliciousUserDetectionSetting) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MaliciousUserDetectionSetting) DeepCopy() *MaliciousUserDetectionSetting {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MaliciousUserDetectionSetting{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MaliciousUserDetectionSetting) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MaliciousUserDetectionSetting) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MaliciousUserDetectionSettingValidator().Validate(ctx, m, opts...)
}

type ValidateMaliciousUserDetectionSetting struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMaliciousUserDetectionSetting) CoolingOffPeriodSettingValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cooling_off_period_setting")
	}
	return validatorFn, nil
}

func (v *ValidateMaliciousUserDetectionSetting) CoolingOffPeriodSettingCoolingOffPeriodValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_CoolingOffPeriod, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cooling_off_period")
	}
	return oValidatorFn_CoolingOffPeriod, nil
}

func (v *ValidateMaliciousUserDetectionSetting) FailedLoginActivityChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for failed_login_activity_choice")
	}
	return validatorFn, nil
}

func (v *ValidateMaliciousUserDetectionSetting) ForbiddenActivityChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for forbidden_activity_choice")
	}
	return validatorFn, nil
}

func (v *ValidateMaliciousUserDetectionSetting) WafActivityChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for waf_activity_choice")
	}
	return validatorFn, nil
}

func (v *ValidateMaliciousUserDetectionSetting) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MaliciousUserDetectionSetting)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MaliciousUserDetectionSetting got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cooling_off_period_setting"]; exists {
		val := m.GetCoolingOffPeriodSetting()
		vOpts := append(opts,
			db.WithValidateField("cooling_off_period_setting"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCoolingOffPeriodSetting().(type) {
	case *MaliciousUserDetectionSetting_CoolingOffPeriod:
		if fv, exists := v.FldValidators["cooling_off_period_setting.cooling_off_period"]; exists {
			val := m.GetCoolingOffPeriodSetting().(*MaliciousUserDetectionSetting_CoolingOffPeriod).CoolingOffPeriod
			vOpts := append(opts,
				db.WithValidateField("cooling_off_period_setting"),
				db.WithValidateField("cooling_off_period"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["failed_login_activity_choice"]; exists {
		val := m.GetFailedLoginActivityChoice()
		vOpts := append(opts,
			db.WithValidateField("failed_login_activity_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetFailedLoginActivityChoice().(type) {
	case *MaliciousUserDetectionSetting_IncludeFailedLoginActivity:
		if fv, exists := v.FldValidators["failed_login_activity_choice.include_failed_login_activity"]; exists {
			val := m.GetFailedLoginActivityChoice().(*MaliciousUserDetectionSetting_IncludeFailedLoginActivity).IncludeFailedLoginActivity
			vOpts := append(opts,
				db.WithValidateField("failed_login_activity_choice"),
				db.WithValidateField("include_failed_login_activity"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *MaliciousUserDetectionSetting_ExcludeFailedLoginActivity:
		if fv, exists := v.FldValidators["failed_login_activity_choice.exclude_failed_login_activity"]; exists {
			val := m.GetFailedLoginActivityChoice().(*MaliciousUserDetectionSetting_ExcludeFailedLoginActivity).ExcludeFailedLoginActivity
			vOpts := append(opts,
				db.WithValidateField("failed_login_activity_choice"),
				db.WithValidateField("exclude_failed_login_activity"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["forbidden_activity_choice"]; exists {
		val := m.GetForbiddenActivityChoice()
		vOpts := append(opts,
			db.WithValidateField("forbidden_activity_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetForbiddenActivityChoice().(type) {
	case *MaliciousUserDetectionSetting_IncludeForbiddenActivity:
		if fv, exists := v.FldValidators["forbidden_activity_choice.include_forbidden_activity"]; exists {
			val := m.GetForbiddenActivityChoice().(*MaliciousUserDetectionSetting_IncludeForbiddenActivity).IncludeForbiddenActivity
			vOpts := append(opts,
				db.WithValidateField("forbidden_activity_choice"),
				db.WithValidateField("include_forbidden_activity"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *MaliciousUserDetectionSetting_ExcludeForbiddenActivity:
		if fv, exists := v.FldValidators["forbidden_activity_choice.exclude_forbidden_activity"]; exists {
			val := m.GetForbiddenActivityChoice().(*MaliciousUserDetectionSetting_ExcludeForbiddenActivity).ExcludeForbiddenActivity
			vOpts := append(opts,
				db.WithValidateField("forbidden_activity_choice"),
				db.WithValidateField("exclude_forbidden_activity"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["waf_activity_choice"]; exists {
		val := m.GetWafActivityChoice()
		vOpts := append(opts,
			db.WithValidateField("waf_activity_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetWafActivityChoice().(type) {
	case *MaliciousUserDetectionSetting_IncludeWafActivity:
		if fv, exists := v.FldValidators["waf_activity_choice.include_waf_activity"]; exists {
			val := m.GetWafActivityChoice().(*MaliciousUserDetectionSetting_IncludeWafActivity).IncludeWafActivity
			vOpts := append(opts,
				db.WithValidateField("waf_activity_choice"),
				db.WithValidateField("include_waf_activity"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *MaliciousUserDetectionSetting_ExcludeWafActivity:
		if fv, exists := v.FldValidators["waf_activity_choice.exclude_waf_activity"]; exists {
			val := m.GetWafActivityChoice().(*MaliciousUserDetectionSetting_ExcludeWafActivity).ExcludeWafActivity
			vOpts := append(opts,
				db.WithValidateField("waf_activity_choice"),
				db.WithValidateField("exclude_waf_activity"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMaliciousUserDetectionSettingValidator = func() *ValidateMaliciousUserDetectionSetting {
	v := &ValidateMaliciousUserDetectionSetting{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCoolingOffPeriodSetting := v.CoolingOffPeriodSettingValidationRuleHandler
	rulesCoolingOffPeriodSetting := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCoolingOffPeriodSetting(rulesCoolingOffPeriodSetting)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MaliciousUserDetectionSetting.cooling_off_period_setting: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cooling_off_period_setting"] = vFn

	vrhCoolingOffPeriodSettingCoolingOffPeriod := v.CoolingOffPeriodSettingCoolingOffPeriodValidationRuleHandler
	rulesCoolingOffPeriodSettingCoolingOffPeriod := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gt":        "0",
		"ves.io.schema.rules.uint32.lte":       "120",
	}
	vFnMap["cooling_off_period_setting.cooling_off_period"], err = vrhCoolingOffPeriodSettingCoolingOffPeriod(rulesCoolingOffPeriodSettingCoolingOffPeriod)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field MaliciousUserDetectionSetting.cooling_off_period_setting_cooling_off_period: %s", err)
		panic(errMsg)
	}

	v.FldValidators["cooling_off_period_setting.cooling_off_period"] = vFnMap["cooling_off_period_setting.cooling_off_period"]

	vrhFailedLoginActivityChoice := v.FailedLoginActivityChoiceValidationRuleHandler
	rulesFailedLoginActivityChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhFailedLoginActivityChoice(rulesFailedLoginActivityChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MaliciousUserDetectionSetting.failed_login_activity_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["failed_login_activity_choice"] = vFn

	vrhForbiddenActivityChoice := v.ForbiddenActivityChoiceValidationRuleHandler
	rulesForbiddenActivityChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhForbiddenActivityChoice(rulesForbiddenActivityChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MaliciousUserDetectionSetting.forbidden_activity_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["forbidden_activity_choice"] = vFn

	vrhWafActivityChoice := v.WafActivityChoiceValidationRuleHandler
	rulesWafActivityChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhWafActivityChoice(rulesWafActivityChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MaliciousUserDetectionSetting.waf_activity_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["waf_activity_choice"] = vFn

	v.FldValidators["failed_login_activity_choice.include_failed_login_activity"] = FailedLoginActivitySettingValidator().Validate

	v.FldValidators["forbidden_activity_choice.include_forbidden_activity"] = ForbiddenActivitySettingValidator().Validate

	return v
}()

func MaliciousUserDetectionSettingValidator() db.Validator {
	return DefaultMaliciousUserDetectionSettingValidator
}

// augmented methods on protoc/std generated struct

func (m *MetricSelector) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MetricSelector) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MetricSelector) DeepCopy() *MetricSelector {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MetricSelector{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MetricSelector) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MetricSelector) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MetricSelectorValidator().Validate(ctx, m, opts...)
}

type ValidateMetricSelector struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMetricSelector) MetricValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(Metric)
		return int32(i)
	}
	// Metric_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, Metric_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for metric")
	}
	itemsValidatorFn := func(ctx context.Context, elems []Metric, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for metric")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]Metric)
		if !ok {
			return fmt.Errorf("Repeated validation expected []Metric, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated metric")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items metric")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMetricSelector) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MetricSelector)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MetricSelector got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["metric"]; exists {
		vOpts := append(opts, db.WithValidateField("metric"))
		if err := fv(ctx, m.GetMetric(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["metrics_source"]; exists {

		vOpts := append(opts, db.WithValidateField("metrics_source"))
		if err := fv(ctx, m.GetMetricsSource(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMetricSelectorValidator = func() *ValidateMetricSelector {
	v := &ValidateMetricSelector{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMetric := v.MetricValidationRuleHandler
	rulesMetric := map[string]string{
		"ves.io.schema.rules.repeated.unique": "true",
	}
	vFn, err = vrhMetric(rulesMetric)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MetricSelector.metric: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metric"] = vFn

	return v
}()

func MetricSelectorValidator() db.Validator {
	return DefaultMetricSelectorValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAppTypeRefsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAppTypeRefsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetAppTypeSettingsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAppTypeSettingsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *ReplaceSpecType) GetAppTypeRefsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAppTypeRefs()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.app_type_refs[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "app_type.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "app_type_refs",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAppTypeRefsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetAppTypeRefsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "app_type.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: app_type")
	}
	for _, ref := range m.GetAppTypeRefs() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetAppTypeSettingsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAppTypeSettings() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetAppTypeSettings() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAppTypeSettings() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("app_type_settings[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) AppTypeSettingsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*AppTypeSettings, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := AppTypeSettingsValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for app_type_settings")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AppTypeSettings)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AppTypeSettings, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated app_type_settings")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items app_type_settings")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["anomaly_types"]; exists {

		vOpts := append(opts, db.WithValidateField("anomaly_types"))
		for idx, item := range m.GetAnomalyTypes() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["app_type_refs"]; exists {

		vOpts := append(opts, db.WithValidateField("app_type_refs"))
		for idx, item := range m.GetAppTypeRefs() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["app_type_settings"]; exists {
		vOpts := append(opts, db.WithValidateField("app_type_settings"))
		if err := fv(ctx, m.GetAppTypeSettings(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAppTypeSettings := v.AppTypeSettingsValidationRuleHandler
	rulesAppTypeSettings := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.min_items": "1",
	}
	vFn, err = vrhAppTypeSettings(rulesAppTypeSettings)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.app_type_settings: %s", err)
		panic(errMsg)
	}
	v.FldValidators["app_type_settings"] = vFn

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TimeseriesAnalysesSetting) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TimeseriesAnalysesSetting) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TimeseriesAnalysesSetting) DeepCopy() *TimeseriesAnalysesSetting {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TimeseriesAnalysesSetting{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TimeseriesAnalysesSetting) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TimeseriesAnalysesSetting) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TimeseriesAnalysesSettingValidator().Validate(ctx, m, opts...)
}

type ValidateTimeseriesAnalysesSetting struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTimeseriesAnalysesSetting) MetricSelectorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*MetricSelector, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := MetricSelectorValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for metric_selectors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*MetricSelector)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*MetricSelector, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated metric_selectors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items metric_selectors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateTimeseriesAnalysesSetting) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TimeseriesAnalysesSetting)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TimeseriesAnalysesSetting got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["metric_selectors"]; exists {
		vOpts := append(opts, db.WithValidateField("metric_selectors"))
		if err := fv(ctx, m.GetMetricSelectors(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTimeseriesAnalysesSettingValidator = func() *ValidateTimeseriesAnalysesSetting {
	v := &ValidateTimeseriesAnalysesSetting{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMetricSelectors := v.MetricSelectorsValidationRuleHandler
	rulesMetricSelectors := map[string]string{
		"ves.io.schema.rules.repeated.unique": "true",
	}
	vFn, err = vrhMetricSelectors(rulesMetricSelectors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TimeseriesAnalysesSetting.metric_selectors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metric_selectors"] = vFn

	return v
}()

func TimeseriesAnalysesSettingValidator() db.Validator {
	return DefaultTimeseriesAnalysesSettingValidator
}

// augmented methods on protoc/std generated struct

func (m *UserBehaviorAnalysisSetting) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UserBehaviorAnalysisSetting) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UserBehaviorAnalysisSetting) DeepCopy() *UserBehaviorAnalysisSetting {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UserBehaviorAnalysisSetting{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UserBehaviorAnalysisSetting) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UserBehaviorAnalysisSetting) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UserBehaviorAnalysisSettingValidator().Validate(ctx, m, opts...)
}

type ValidateUserBehaviorAnalysisSetting struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUserBehaviorAnalysisSetting) LearnFromNamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for learn_from_namespace")
	}
	return validatorFn, nil
}

func (v *ValidateUserBehaviorAnalysisSetting) MaliciousUserDetectionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for malicious_user_detection")
	}
	return validatorFn, nil
}

func (v *ValidateUserBehaviorAnalysisSetting) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UserBehaviorAnalysisSetting)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UserBehaviorAnalysisSetting got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["learn_from_namespace"]; exists {
		val := m.GetLearnFromNamespace()
		vOpts := append(opts,
			db.WithValidateField("learn_from_namespace"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLearnFromNamespace().(type) {
	case *UserBehaviorAnalysisSetting_EnableLearning:
		if fv, exists := v.FldValidators["learn_from_namespace.enable_learning"]; exists {
			val := m.GetLearnFromNamespace().(*UserBehaviorAnalysisSetting_EnableLearning).EnableLearning
			vOpts := append(opts,
				db.WithValidateField("learn_from_namespace"),
				db.WithValidateField("enable_learning"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *UserBehaviorAnalysisSetting_DisableLearning:
		if fv, exists := v.FldValidators["learn_from_namespace.disable_learning"]; exists {
			val := m.GetLearnFromNamespace().(*UserBehaviorAnalysisSetting_DisableLearning).DisableLearning
			vOpts := append(opts,
				db.WithValidateField("learn_from_namespace"),
				db.WithValidateField("disable_learning"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["malicious_user_detection"]; exists {
		val := m.GetMaliciousUserDetection()
		vOpts := append(opts,
			db.WithValidateField("malicious_user_detection"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMaliciousUserDetection().(type) {
	case *UserBehaviorAnalysisSetting_EnableDetection:
		if fv, exists := v.FldValidators["malicious_user_detection.enable_detection"]; exists {
			val := m.GetMaliciousUserDetection().(*UserBehaviorAnalysisSetting_EnableDetection).EnableDetection
			vOpts := append(opts,
				db.WithValidateField("malicious_user_detection"),
				db.WithValidateField("enable_detection"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *UserBehaviorAnalysisSetting_DisableDetection:
		if fv, exists := v.FldValidators["malicious_user_detection.disable_detection"]; exists {
			val := m.GetMaliciousUserDetection().(*UserBehaviorAnalysisSetting_DisableDetection).DisableDetection
			vOpts := append(opts,
				db.WithValidateField("malicious_user_detection"),
				db.WithValidateField("disable_detection"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUserBehaviorAnalysisSettingValidator = func() *ValidateUserBehaviorAnalysisSetting {
	v := &ValidateUserBehaviorAnalysisSetting{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLearnFromNamespace := v.LearnFromNamespaceValidationRuleHandler
	rulesLearnFromNamespace := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLearnFromNamespace(rulesLearnFromNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UserBehaviorAnalysisSetting.learn_from_namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["learn_from_namespace"] = vFn

	vrhMaliciousUserDetection := v.MaliciousUserDetectionValidationRuleHandler
	rulesMaliciousUserDetection := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMaliciousUserDetection(rulesMaliciousUserDetection)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UserBehaviorAnalysisSetting.malicious_user_detection: %s", err)
		panic(errMsg)
	}
	v.FldValidators["malicious_user_detection"] = vFn

	v.FldValidators["malicious_user_detection.enable_detection"] = MaliciousUserDetectionSettingValidator().Validate

	return v
}()

func UserBehaviorAnalysisSettingValidator() db.Validator {
	return DefaultUserBehaviorAnalysisSettingValidator
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.AnomalyTypes = f.GetAnomalyTypes()
	m.AppTypeRefs = f.GetAppTypeRefs()
	m.AppTypeSettings = f.GetAppTypeSettings()
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	f.AnomalyTypes = m1.AnomalyTypes
	f.AppTypeRefs = m1.AppTypeRefs
	f.AppTypeSettings = m1.AppTypeSettings
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.AnomalyTypes = f.GetAnomalyTypes()
	m.AppTypeRefs = f.GetAppTypeRefs()
	m.AppTypeSettings = f.GetAppTypeSettings()
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	f.AnomalyTypes = m1.AnomalyTypes
	f.AppTypeRefs = m1.AppTypeRefs
	f.AppTypeSettings = m1.AppTypeSettings
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.AnomalyTypes = f.GetAnomalyTypes()
	m.AppTypeRefs = f.GetAppTypeRefs()
	m.AppTypeSettings = f.GetAppTypeSettings()
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	f.AnomalyTypes = m1.AnomalyTypes
	f.AppTypeRefs = m1.AppTypeRefs
	f.AppTypeSettings = m1.AppTypeSettings
}
