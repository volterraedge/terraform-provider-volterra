// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/virtual_host/types.proto

package virtual_host

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	authentication "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/authentication"
	cluster "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/cluster"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/service_policy"
	virtual_host_dns_info "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/virtual_host_dns_info"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// VirtualHostType
//
// x-displayName: "Virtual Host Type"
// VirtualHostType tells the type of virtual_host. Functionally, all types are same,
// this is mainly used for categorizing metrics.
type VirtualHostType int32

const (
	// VirtualService
	//
	// x-displayName: "Virtual Service"
	// Virtual Host used Virtual Service
	VIRTUAL_SERVICE VirtualHostType = 0
	// HTTP LoadBalancer
	//
	// x-displayName: "HTTP Load Balancer"
	// Virtual Host used as Load Balancer
	HTTP_LOAD_BALANCER VirtualHostType = 1
	// APIGateway
	//
	// x-displayName: "API Gateway"
	// Virtual Host used API Gateway
	API_GATEWAY VirtualHostType = 2
	// TCP LoadBalancer
	//
	// x-displayName: "Load balancer"
	// Virtual Host used as Load Balancer
	TCP_LOAD_BALANCER VirtualHostType = 3
	// Proxy
	//
	// x-displayName: "Proxy"
	// Virtual Host used as Proxy
	PROXY VirtualHostType = 4
	// LOCAL_K8S_API_GATEWAY
	//
	// x-displayName: "Local K8s API Gateway"
	// Internal use only, used for k8s cluster api gateway on the site.
	LOCAL_K8S_API_GATEWAY VirtualHostType = 5
)

var VirtualHostType_name = map[int32]string{
	0: "VIRTUAL_SERVICE",
	1: "HTTP_LOAD_BALANCER",
	2: "API_GATEWAY",
	3: "TCP_LOAD_BALANCER",
	4: "PROXY",
	5: "LOCAL_K8S_API_GATEWAY",
}

var VirtualHostType_value = map[string]int32{
	"VIRTUAL_SERVICE":       0,
	"HTTP_LOAD_BALANCER":    1,
	"API_GATEWAY":           2,
	"TCP_LOAD_BALANCER":     3,
	"PROXY":                 4,
	"LOCAL_K8S_API_GATEWAY": 5,
}

func (VirtualHostType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_df61af5ea37a6592, []int{0}
}

// ProxyType tells the type of proxy to install for the virtual host.
//
// x-displayName: "Type of Proxy"
// Only the following combination of VirtualHosts within same AdvertisePolicy is permitted
// (None of them should have "*" in domains when used with other VirtualHosts in same AdvertisePolicy)
// 1. Multiple TCP_PROXY_WITH_SNI and multiple HTTPS_PROXY
// 2. Multiple HTTP_PROXY
// 3. Multiple HTTPS_PROXY
// 4. Multiple TCP_PROXY_WITH_SNI
//
// HTTPS_PROXY without TLS parameters is not permitted
// HTTP_PROXY/HTTPS_PROXY/TCP_PROXY_WITH_SNI/SMA_PROXY with empty domains is not permitted
// TCP_PROXY_WITH_SNI/SMA_PROXY should not have "*" in domains
type ProxyType int32

const (
	// HTTP_PROXY
	//
	// x-displayName: "HTTP Proxy"
	// Install HTTP proxy. HTTP Proxy is the default proxy installed.
	HTTP_PROXY ProxyType = 0
	// TCP_PROXY
	//
	// x-displayName: "TCP Proxy"
	// Install TCP proxy
	TCP_PROXY ProxyType = 1
	// TCP_PROXY_WITH_SNI
	//
	// x-displayName: "TCP Proxy with SNI"
	// Install TCP proxy with SNI Routing
	TCP_PROXY_WITH_SNI ProxyType = 2
	// HTTPS_PROXY
	//
	// x-displayName: "HTTPS Proxy"
	// Install HTTPS proxy
	HTTPS_PROXY ProxyType = 3
	// UDP_PROXY
	//
	// x-displayName: "UDP Proxy"
	// Install UDP proxy
	UDP_PROXY ProxyType = 4
	// SMA_PROXY
	//
	// x-displayName: "Secret Management Access Proxy"
	// Install Secret Management Access proxy
	SMA_PROXY ProxyType = 5
)

var ProxyType_name = map[int32]string{
	0: "HTTP_PROXY",
	1: "TCP_PROXY",
	2: "TCP_PROXY_WITH_SNI",
	3: "HTTPS_PROXY",
	4: "UDP_PROXY",
	5: "SMA_PROXY",
}

var ProxyType_value = map[string]int32{
	"HTTP_PROXY":         0,
	"TCP_PROXY":          1,
	"TCP_PROXY_WITH_SNI": 2,
	"HTTPS_PROXY":        3,
	"UDP_PROXY":          4,
	"SMA_PROXY":          5,
}

func (ProxyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_df61af5ea37a6592, []int{1}
}

// VirtualHostState
//
// x-displayName: "Virtual Host State"
// State of the virtual host
type VirtualHostState int32

const (
	// VIRTUAL_HOST_READY
	//
	// x-displayName: "Ready"
	// Virtual host is ready to install
	VIRTUAL_HOST_READY VirtualHostState = 0
	// VIRTUAL_HOST_PENDING_VERIFICATION
	//
	// x-displayName: "Pending Verification"
	// Virtual host is verfication pending for some or all of its domains
	VIRTUAL_HOST_PENDING_VERIFICATION VirtualHostState = 1
	// VIRTUAL_HOST_VERIFICATION_FAILED
	//
	// x-displayName: "Verification Failed"
	// Virtual host has one or more domains for which verification failed
	VIRTUAL_HOST_VERIFICATION_FAILED VirtualHostState = 2
	// VIRTUAL_HOST_PENDING_DNS_DELEGATION
	//
	// x-displayName: "Pending DNS delegation"
	// Virtual host is pending DNS delegation
	VIRTUAL_HOST_PENDING_DNS_DELEGATION VirtualHostState = 3
	// VIRTUAL_HOST_PENDING_A_RECORD
	//
	// x-displayName: "Pending A record"
	// Virtual host is waiting for one or more A records to be created
	VIRTUAL_HOST_PENDING_A_RECORD VirtualHostState = 4
	// VIRTUAL_HOST_DNS_A_RECORD_ADDED
	//
	// x-displayName: "DNS A record was added"
	// DNS A record has been added for this Virtual host
	VIRTUAL_HOST_DNS_A_RECORD_ADDED VirtualHostState = 5
)

var VirtualHostState_name = map[int32]string{
	0: "VIRTUAL_HOST_READY",
	1: "VIRTUAL_HOST_PENDING_VERIFICATION",
	2: "VIRTUAL_HOST_VERIFICATION_FAILED",
	3: "VIRTUAL_HOST_PENDING_DNS_DELEGATION",
	4: "VIRTUAL_HOST_PENDING_A_RECORD",
	5: "VIRTUAL_HOST_DNS_A_RECORD_ADDED",
}

var VirtualHostState_value = map[string]int32{
	"VIRTUAL_HOST_READY":                  0,
	"VIRTUAL_HOST_PENDING_VERIFICATION":   1,
	"VIRTUAL_HOST_VERIFICATION_FAILED":    2,
	"VIRTUAL_HOST_PENDING_DNS_DELEGATION": 3,
	"VIRTUAL_HOST_PENDING_A_RECORD":       4,
	"VIRTUAL_HOST_DNS_A_RECORD_ADDED":     5,
}

func (VirtualHostState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_df61af5ea37a6592, []int{2}
}

// Certification State
//
// x-displayName: "Certification State"
// State of auto certification generation for the virtual host
type CertificationState int32

const (
	// Auto Cert Disabled
	//
	// x-displayName: "Auto Cert Disabled"
	// Auto Certification is disabled.
	AutoCertDisabled CertificationState = 0
	// Dns Domain Verification
	//
	// x-displayName: "DnsDomainVerification"
	// Auto Certification is waiting for domain verification.
	DnsDomainVerification CertificationState = 1
	// Auto Cert Started
	//
	// x-displayName: "Auto Cert Started"
	// Auto Certificate generation action has started.
	AutoCertStarted CertificationState = 2
	// Domain Challenge Pending
	//
	// x-displayName: "Domain Challenge Pending"
	// The domains in the virtual host configuration are being verified. This requires
	// the _acme-challenge TXT record in the domain to have the correct TXT.
	DomainChallengePending CertificationState = 3
	// Domain Challenge Verified
	//
	// x-displayName: "Domain Challenge Verified"
	// All the domains in the virtual host have been verified.
	DomainChallengeVerified CertificationState = 4
	// Auto Cert Finalize
	//
	// x-displayName: "Auto Cert Finalize"
	// Certificate generation order is Ready and Finalized.
	AutoCertFinalize CertificationState = 5
	// Certificate Invalid
	//
	// x-displayName: "Certificate Invalid"
	// Certificate is invalid
	CertificateInvalid CertificationState = 6
	// Certificate Valid
	//
	// x-displayName: "Certificate Valid"
	// Valid certificate generated and tls_parameters are updated
	CertificateValid CertificationState = 7
	// Auto Cert Not Applicable
	//
	// x-displayName: "Not Applicable"
	// Auto certificate not applicable because virtual host does not use TLS
	AutoCertNotApplicable CertificationState = 8
	// Auto Cert Rate Limited
	//
	// x-displayName: "Rate Limited"
	// Auto certificate not available because CA has rate limited the request
	AutoCertRateLimited CertificationState = 9
	// Auto Cert Generation Retry
	//
	// x-displayName: "Auto Cert Generation Retry"
	// Auto certificate generate failed in the previous attempt, will be retried automatically
	AutoCertGenerationRetry CertificationState = 10
	// Auto Cert Error
	//
	// x-displayName: "Auto Cert Error"
	// Error in Certificate generation
	AutoCertError CertificationState = 11
)

var CertificationState_name = map[int32]string{
	0:  "AutoCertDisabled",
	1:  "DnsDomainVerification",
	2:  "AutoCertStarted",
	3:  "DomainChallengePending",
	4:  "DomainChallengeVerified",
	5:  "AutoCertFinalize",
	6:  "CertificateInvalid",
	7:  "CertificateValid",
	8:  "AutoCertNotApplicable",
	9:  "AutoCertRateLimited",
	10: "AutoCertGenerationRetry",
	11: "AutoCertError",
}

var CertificationState_value = map[string]int32{
	"AutoCertDisabled":        0,
	"DnsDomainVerification":   1,
	"AutoCertStarted":         2,
	"DomainChallengePending":  3,
	"DomainChallengeVerified": 4,
	"AutoCertFinalize":        5,
	"CertificateInvalid":      6,
	"CertificateValid":        7,
	"AutoCertNotApplicable":   8,
	"AutoCertRateLimited":     9,
	"AutoCertGenerationRetry": 10,
	"AutoCertError":           11,
}

func (CertificationState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_df61af5ea37a6592, []int{3}
}

// JavaScriptConfigType
//
// x-displayName: "JavaScript Configuration"
// Custom JavaScript Configuration. Custom JavaScript code can be executed at various stages of request processing.
type JavaScriptConfigType struct {
	// CachePrefix
	//
	// x-displayName: "Cache Identifier"
	// Identifier for data store to be used by JavaScript. Data store can be
	// KeyValue store referred by script.
	CachePrefix string `protobuf:"bytes,1,opt,name=cache_prefix,json=cachePrefix,proto3" json:"cache_prefix,omitempty"`
	// ScriptConfig
	//
	// x-displayName: "Configuration for Script"
	// Input passed to the script
	ScriptConfig *types.Struct `protobuf:"bytes,2,opt,name=script_config,json=scriptConfig,proto3" json:"script_config,omitempty"`
	// ScriptURL
	//
	// x-displayName: "Path of Javascript"
	// URL of JavaScript that gets executed
	CustomScriptUrl string `protobuf:"bytes,3,opt,name=custom_script_url,json=customScriptUrl,proto3" json:"custom_script_url,omitempty"`
}

func (m *JavaScriptConfigType) Reset()      { *m = JavaScriptConfigType{} }
func (*JavaScriptConfigType) ProtoMessage() {}
func (*JavaScriptConfigType) Descriptor() ([]byte, []int) {
	return fileDescriptor_df61af5ea37a6592, []int{0}
}
func (m *JavaScriptConfigType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JavaScriptConfigType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JavaScriptConfigType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JavaScriptConfigType.Merge(m, src)
}
func (m *JavaScriptConfigType) XXX_Size() int {
	return m.Size()
}
func (m *JavaScriptConfigType) XXX_DiscardUnknown() {
	xxx_messageInfo_JavaScriptConfigType.DiscardUnknown(m)
}

var xxx_messageInfo_JavaScriptConfigType proto.InternalMessageInfo

func (m *JavaScriptConfigType) GetCachePrefix() string {
	if m != nil {
		return m.CachePrefix
	}
	return ""
}

func (m *JavaScriptConfigType) GetScriptConfig() *types.Struct {
	if m != nil {
		return m.ScriptConfig
	}
	return nil
}

func (m *JavaScriptConfigType) GetCustomScriptUrl() string {
	if m != nil {
		return m.CustomScriptUrl
	}
	return ""
}

// DynamicReverseProxyType
//
// x-displayName: "Dynamic Reverse Proxy Type"
// In this mode of proxy, virtual host will resolve the destination endpoint dynamically.
//
// The dynamic resolution is done using a predefined field in the request. This predefined
// field depends on the ProxyType configured on the Virtual Host.
//
// For HTTP traffic, i.e. with ProxyType as HTTP_PROXY or HTTPS_PROXY, virtual host will use the
// "HOST" http header from the request and perform DNS resolution to select destination endpoint.
//
// For TCP traffic with SNI, (If the ProxyType is TCP_PROXY_WITH_SNI), virtual host will perform DNS
// resolution using the SNI.
//
// The DNS resolution is performed in the virtual network specified in outside_network_type or
// outside_network
//
// In both modes of operation(either using Host header or SNI), the DNS resolution could return
// multiple addresses. First IPv4 address from such returned list is used as endpoint for the
// request. The DNS response is cached for 60s by default.
type DynamicReverseProxyType struct {
	// Enable the dynamic resolution of the endpoint
	//
	// x-displayName: "Dynamic Endpoint Resolution"
	// x-example : true
	// In this mode of proxy, virtual host will resolve the destination endpoint dynamically.
	//
	// The dynamic resolution is done using a predefined field in the request. This predefined
	// field depends on the ProxyType configured on the Virtual Host.
	//
	// For HTTP traffic, i.e. with ProxyType as HTTP_PROXY or HTTPS_PROXY, virtual host will use the
	// "HOST" http header from the request and perform DNS resolution to select destination endpoint.
	//
	// For TCP traffic with SNI, (If the ProxyType is TCP_PROXY_WITH_SNI), virtual host will perform DNS
	// resolution using the SNI.
	//
	// The DNS resolution is performed in the virtual network specified in outside_network_type or
	// outside_network
	//
	// In both modes of operation(either using Host header or SNI), the DNS resolution could return
	// multiple addresses. First IPv4 address from such returned list is used as endpoint for the
	// request. The DNS response is cached for 60s by default.
	ResolveEndpointDynamically bool `protobuf:"varint,1,opt,name=resolve_endpoint_dynamically,json=resolveEndpointDynamically,proto3" json:"resolve_endpoint_dynamically,omitempty"`
	// resolution_network_type
	//
	// x-displayName: "Resolution Network Type"
	// Type of the network to resolve the destination
	ResolutionNetworkType schema.VirtualNetworkType `protobuf:"varint,2,opt,name=resolution_network_type,json=resolutionNetworkType,proto3,enum=ves.io.schema.VirtualNetworkType" json:"resolution_network_type,omitempty"`
	// resolution_network
	//
	// x-displayName: "Resolution Network"
	// Reference to virtual network where the endpoint is resolved.
	// Reference is valid only when the network type is VIRTUAL_NETWORK_PER_SITE or
	// VIRTUAL_NETWORK_GLOBAL. It is ignored for all other network types
	ResolutionNetwork []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=resolution_network,json=resolutionNetwork,proto3" json:"resolution_network,omitempty"`
	// connection_timeout
	//
	// x-displayName: "Connection Timeout"
	// x-example: "4000"
	// The timeout for new network connections to upstream server.
	// This is specified in milliseconds. The default value is 2000 (2 seconds)
	ConnectionTimeout uint32 `protobuf:"varint,5,opt,name=connection_timeout,json=connectionTimeout,proto3" json:"connection_timeout,omitempty"`
}

func (m *DynamicReverseProxyType) Reset()      { *m = DynamicReverseProxyType{} }
func (*DynamicReverseProxyType) ProtoMessage() {}
func (*DynamicReverseProxyType) Descriptor() ([]byte, []int) {
	return fileDescriptor_df61af5ea37a6592, []int{1}
}
func (m *DynamicReverseProxyType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynamicReverseProxyType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DynamicReverseProxyType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynamicReverseProxyType.Merge(m, src)
}
func (m *DynamicReverseProxyType) XXX_Size() int {
	return m.Size()
}
func (m *DynamicReverseProxyType) XXX_DiscardUnknown() {
	xxx_messageInfo_DynamicReverseProxyType.DiscardUnknown(m)
}

var xxx_messageInfo_DynamicReverseProxyType proto.InternalMessageInfo

func (m *DynamicReverseProxyType) GetResolveEndpointDynamically() bool {
	if m != nil {
		return m.ResolveEndpointDynamically
	}
	return false
}

func (m *DynamicReverseProxyType) GetResolutionNetworkType() schema.VirtualNetworkType {
	if m != nil {
		return m.ResolutionNetworkType
	}
	return schema.VIRTUAL_NETWORK_SITE_LOCAL
}

func (m *DynamicReverseProxyType) GetResolutionNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.ResolutionNetwork
	}
	return nil
}

func (m *DynamicReverseProxyType) GetConnectionTimeout() uint32 {
	if m != nil {
		return m.ConnectionTimeout
	}
	return 0
}

// CompressionType
//
// x-displayName: "Compression Parameters"
// Enables loadbalancer to compress dispatched data from an upstream service upon client request.
// The content is compressed and then sent to the client with the appropriate headers if either response and request allow.
// Only GZIP compression is supported.
//
// By default compression will be skipped when:
//
//   A request does NOT contain accept-encoding header.
//   A request includes accept-encoding header, but it does not contain “gzip” or “*”.
//   A request includes accept-encoding with “gzip” or “*” with the weight “q=0”. Note that the “gzip” will have a higher weight then “*”. For example, if accept-encoding is “gzip;q=0,*;q=1”, the filter will not compress. But if the header is set to “*;q=0,gzip;q=1”, the filter will compress.
//   A request whose accept-encoding header includes “identity”.
//   A response contains a content-encoding header.
//   A response contains a cache-control header whose value includes “no-transform”.
//   A response contains a transfer-encoding header whose value includes “gzip”.
//   A response does not contain a content-type value that matches one of the selected mime-types, which default to application/javascript, application/json, application/xhtml+xml, image/svg+xml, text/css, text/html, text/plain, text/xml.
//   Neither content-length nor transfer-encoding headers are present in the response.
//   Response size is smaller than 30 bytes (only applicable when transfer-encoding is not chunked).
//
// When compression is applied:
//
//   The content-length is removed from response headers.
//   Response headers contain “transfer-encoding: chunked” and do not contain “content-encoding” header.
//   The “vary: accept-encoding” header is inserted on every response.
//
// GZIP Compression Level:
//
// A value which is optimal balance between speed of compression and amount of compression is chosen.
type CompressionType struct {
	// content_length
	//
	// x-displayName: "Content Length"
	// x-example: 100
	// Minimum response length, in bytes, which will trigger compression. The default value is 30.
	ContentLength uint32 `protobuf:"varint,1,opt,name=content_length,json=contentLength,proto3" json:"content_length,omitempty"`
	// content_type
	//
	// x-displayName: "Content Type"
	// x-example: "application/json"
	// Set of strings that allows specifying which mime-types yield compression
	// When this field is not defined, compression will be applied
	// to the following mime-types:
	//     "application/javascript"
	//     "application/json",
	//     "application/xhtml+xml"
	//     "image/svg+xml"
	//     "text/css"
	//     "text/html"
	//     "text/plain"
	//     "text/xml"
	ContentType []string `protobuf:"bytes,2,rep,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	// disable_on_etag_header
	//
	// x-displayName: "Disable On Etag Header"
	// x-example: "true"
	// If true, disables compression when the response contains an etag header. When it is false,
	// weak etags will be preserved and the ones that require strong validation will be removed.
	DisableOnEtagHeader bool `protobuf:"varint,3,opt,name=disable_on_etag_header,json=disableOnEtagHeader,proto3" json:"disable_on_etag_header,omitempty"`
	// remove_accept_encoding_header
	//
	// x-displayName: "Remove Accept-Encoding Header"
	// x-example: "true"
	// If true, removes accept-encoding from the request headers before dispatching it to the upstream
	// so that responses do not get compressed before reaching the filter.
	RemoveAcceptEncodingHeader bool `protobuf:"varint,4,opt,name=remove_accept_encoding_header,json=removeAcceptEncodingHeader,proto3" json:"remove_accept_encoding_header,omitempty"`
}

func (m *CompressionType) Reset()      { *m = CompressionType{} }
func (*CompressionType) ProtoMessage() {}
func (*CompressionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_df61af5ea37a6592, []int{2}
}
func (m *CompressionType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompressionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CompressionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompressionType.Merge(m, src)
}
func (m *CompressionType) XXX_Size() int {
	return m.Size()
}
func (m *CompressionType) XXX_DiscardUnknown() {
	xxx_messageInfo_CompressionType.DiscardUnknown(m)
}

var xxx_messageInfo_CompressionType proto.InternalMessageInfo

func (m *CompressionType) GetContentLength() uint32 {
	if m != nil {
		return m.ContentLength
	}
	return 0
}

func (m *CompressionType) GetContentType() []string {
	if m != nil {
		return m.ContentType
	}
	return nil
}

func (m *CompressionType) GetDisableOnEtagHeader() bool {
	if m != nil {
		return m.DisableOnEtagHeader
	}
	return false
}

func (m *CompressionType) GetRemoveAcceptEncodingHeader() bool {
	if m != nil {
		return m.RemoveAcceptEncodingHeader
	}
	return false
}

// JavascriptChallengeType
//
// x-displayName: "Javascript Challenge Parameters"
//
// Enables loadbalancer to perform client browser compatibility test by redirecting to a page
// with Javascript.
//
// With this feature enabled, only clients that are capable of executing Javascript(mostly browsers)
// will be allowed to complete the HTTP request.
//
// When loadbalancer is configured to do Javascript Challenge, it will redirect the browser to an
// HTML page on every new HTTP request. This HTML page will have Javascript embedded in it.
// Loadbalancer chooses a set of random numbers for every new client and sends these numbers along with an
// encrypted answer with the request such that it embed these numbers as input in the Javascript.
// Javascript will run on the requestor browser and perform a complex Math operation.
// Script will submit the answer to loadbalancer. Loadbalancer will validate the answer by comparing the calculated
// answer with the decrypted answer (which was encrypted when it was sent back as reply) and allow
// the request to the upstream server only if the answer is correct.
// Loadbalancer will tag response header with a cookie to avoid Javascript challenge for subsequent requests.
//
// Javascript challenge serves following purposes
//    * Validate that the request is coming via a browser that is capable for running Javascript
//    * Force the browser to run a complex operation, f(X), that requires it to spend a large number
//      of CPU cycles. This is to slow down a potential DoS attacker by making it difficult to launch
//    a large request flood without having to spend even larger CPU cost at their end.
//
// You can enable either Javascript challenge or Captcha challenge on a virtual host
type JavascriptChallengeType struct {
	// js_script_delay
	//
	// x-displayName: "Javascript Delay"
	// x-example: 1000
	// Delay introduced by Javascript, in milliseconds.
	JsScriptDelay uint32 `protobuf:"varint,2,opt,name=js_script_delay,json=jsScriptDelay,proto3" json:"js_script_delay,omitempty"`
	// cookie_expiry
	//
	// x-displayName: "Cookie Expiration Period"
	// x-example: 1000
	// Cookie expiration period, in seconds.
	// An expired cookie causes the loadbalancer to issue a new challenge.
	CookieExpiry uint32 `protobuf:"varint,3,opt,name=cookie_expiry,json=cookieExpiry,proto3" json:"cookie_expiry,omitempty"`
	// custom_page
	//
	// x-displayName: "Custom Message for Javascript Challenge"
	// x-example: "string:///PHA+IFBsZWFzZSBXYWl0IDwvcD4="
	// Custom message is of type uri_ref. Currently supported URL schemes is string:///.
	// For string:/// scheme, message needs to be encoded in Base64 format.
	// You can specify this message as base64 encoded plain text message e.g. "Please Wait.."
	// or it can be HTML paragraph or a body string encoded as base64 string
	// E.g. "<p> Please Wait </p>". Base64 encoded string for this html is "PHA+IFBsZWFzZSBXYWl0IDwvcD4="
	CustomPage string `protobuf:"bytes,4,opt,name=custom_page,json=customPage,proto3" json:"custom_page,omitempty"`
}

func (m *JavascriptChallengeType) Reset()      { *m = JavascriptChallengeType{} }
func (*JavascriptChallengeType) ProtoMessage() {}
func (*JavascriptChallengeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_df61af5ea37a6592, []int{3}
}
func (m *JavascriptChallengeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JavascriptChallengeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JavascriptChallengeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JavascriptChallengeType.Merge(m, src)
}
func (m *JavascriptChallengeType) XXX_Size() int {
	return m.Size()
}
func (m *JavascriptChallengeType) XXX_DiscardUnknown() {
	xxx_messageInfo_JavascriptChallengeType.DiscardUnknown(m)
}

var xxx_messageInfo_JavascriptChallengeType proto.InternalMessageInfo

func (m *JavascriptChallengeType) GetJsScriptDelay() uint32 {
	if m != nil {
		return m.JsScriptDelay
	}
	return 0
}

func (m *JavascriptChallengeType) GetCookieExpiry() uint32 {
	if m != nil {
		return m.CookieExpiry
	}
	return 0
}

func (m *JavascriptChallengeType) GetCustomPage() string {
	if m != nil {
		return m.CustomPage
	}
	return ""
}

// CaptchaChallengeType
//
// x-displayName: "Captcha Challenge Parameters"
//
// Enables loadbalancer to perform captcha challenge
//
// Captcha challenge will be based on Google Recaptcha.
//
// With this feature enabled, only clients that pass the captcha challenge will be allowed to
// complete the HTTP request.
//
// When loadbalancer is configured to do Captcha Challenge, it will redirect the browser to an
// HTML page on every new HTTP request. This HTML page will have captcha challenge embedded in it.
// Client will be allowed to make the request only if the captcha challenge is successful.
// Loadbalancer will tag response header with a cookie to avoid Captcha challenge for subsequent requests.
//
// CAPTCHA is mainly used as a security check to ensure only human users can pass through.
// Generally, computers or bots are not capable of solving a captcha.
//
// You can enable either Javascript challenge or Captcha challenge on a virtual host
type CaptchaChallengeType struct {
	// cookie_expiry
	//
	// x-displayName: "Cookie Expiration Period"
	// x-example: 1000
	// Cookie expiration period, in seconds.
	// An expired cookie causes the loadbalancer to issue a new challenge.
	CookieExpiry uint32 `protobuf:"varint,2,opt,name=cookie_expiry,json=cookieExpiry,proto3" json:"cookie_expiry,omitempty"`
	// custom_page
	//
	// x-displayName: "Custom message for Captcha Challenge"
	// x-example: "string:///PHA+IFBsZWFzZSBXYWl0IDwvcD4="
	// Custom message is of type uri_ref. Currently supported URL schemes is string:///.
	// For string:/// scheme, message needs to be encoded in Base64 format.
	// You can specify this message as base64 encoded plain text message e.g. "Please Wait.."
	// or it can be HTML paragraph or a body string encoded as base64 string
	// E.g. "<p> Please Wait </p>". Base64 encoded string for this html is "PHA+IFBsZWFzZSBXYWl0IDwvcD4="
	CustomPage string `protobuf:"bytes,3,opt,name=custom_page,json=customPage,proto3" json:"custom_page,omitempty"`
}

func (m *CaptchaChallengeType) Reset()      { *m = CaptchaChallengeType{} }
func (*CaptchaChallengeType) ProtoMessage() {}
func (*CaptchaChallengeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_df61af5ea37a6592, []int{4}
}
func (m *CaptchaChallengeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CaptchaChallengeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CaptchaChallengeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CaptchaChallengeType.Merge(m, src)
}
func (m *CaptchaChallengeType) XXX_Size() int {
	return m.Size()
}
func (m *CaptchaChallengeType) XXX_DiscardUnknown() {
	xxx_messageInfo_CaptchaChallengeType.DiscardUnknown(m)
}

var xxx_messageInfo_CaptchaChallengeType proto.InternalMessageInfo

func (m *CaptchaChallengeType) GetCookieExpiry() uint32 {
	if m != nil {
		return m.CookieExpiry
	}
	return 0
}

func (m *CaptchaChallengeType) GetCustomPage() string {
	if m != nil {
		return m.CustomPage
	}
	return ""
}

// TemporaryUserBlockingType
//
// x-displayName: "Temporary User Blocking"
//
// Specifies configuration for temporary user blocking resulting from user behavior analysis.
//
// When Malicious User Mitigation is enabled from service policy rules, users' accessing the application will be analyzed for
// malicious activity and the configured mitigation actions will be taken on identified malicious users.
// These mitigation actions include setting up temporary blocking on that user.
// This configuration specifies settings on how that blocking should be done by the loadbalancer.
type TemporaryUserBlockingType struct {
	// custom_page
	//
	// x-displayName: "Custom Message for Temporary Blocking"
	// x-example: "string:///PHA+IFBsZWFzZSBXYWl0IDwvcD4="
	// Custom message is of type `uri_ref`. Currently supported URL schemes is `string:///`.
	// For `string:///` scheme, message needs to be encoded in Base64 format.
	// You can specify this message as base64 encoded plain text message e.g. "Blocked.."
	// or it can be HTML paragraph or a body string encoded as base64 string
	// E.g. "<p> Blocked </p>". Base64 encoded string for this html is "PHA+IFBsZWFzZSBXYWl0IDwvcD4="
	CustomPage string `protobuf:"bytes,1,opt,name=custom_page,json=customPage,proto3" json:"custom_page,omitempty"`
}

func (m *TemporaryUserBlockingType) Reset()      { *m = TemporaryUserBlockingType{} }
func (*TemporaryUserBlockingType) ProtoMessage() {}
func (*TemporaryUserBlockingType) Descriptor() ([]byte, []int) {
	return fileDescriptor_df61af5ea37a6592, []int{5}
}
func (m *TemporaryUserBlockingType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TemporaryUserBlockingType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TemporaryUserBlockingType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TemporaryUserBlockingType.Merge(m, src)
}
func (m *TemporaryUserBlockingType) XXX_Size() int {
	return m.Size()
}
func (m *TemporaryUserBlockingType) XXX_DiscardUnknown() {
	xxx_messageInfo_TemporaryUserBlockingType.DiscardUnknown(m)
}

var xxx_messageInfo_TemporaryUserBlockingType proto.InternalMessageInfo

func (m *TemporaryUserBlockingType) GetCustomPage() string {
	if m != nil {
		return m.CustomPage
	}
	return ""
}

// AutoCertInfoType
//
// x-displayName: "Auto Cert Information"
// Information related to auto certificate
type AutoCertInfoType struct {
	// Auto Cert State
	//
	// x-displayName: "Auto Cert State"
	// State of auto certificate generation.
	AutoCertState CertificationState `protobuf:"varint,1,opt,name=auto_cert_state,json=autoCertState,proto3,enum=ves.io.schema.virtual_host.CertificationState" json:"auto_cert_state,omitempty"`
	// Auto Cert Expiry Timestamp
	//
	// x-displayName: "Auto Cert Expiry Timestamp"
	// Auto certificate expiry timestamp
	AutoCertExpiry *types.Timestamp `protobuf:"bytes,2,opt,name=auto_cert_expiry,json=autoCertExpiry,proto3" json:"auto_cert_expiry,omitempty"`
	// Auto Cert Subject
	//
	// x-displayName: "Auto Cert Subject"
	// Subject of the auto certificate
	AutoCertSubject string `protobuf:"bytes,3,opt,name=auto_cert_subject,json=autoCertSubject,proto3" json:"auto_cert_subject,omitempty"`
	// Auto Cert Issuer
	//
	// x-displayName: "Auto Cert Issuer"
	// Issuer of the auto certificate
	AutoCertIssuer string `protobuf:"bytes,4,opt,name=auto_cert_issuer,json=autoCertIssuer,proto3" json:"auto_cert_issuer,omitempty"`
}

func (m *AutoCertInfoType) Reset()      { *m = AutoCertInfoType{} }
func (*AutoCertInfoType) ProtoMessage() {}
func (*AutoCertInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_df61af5ea37a6592, []int{6}
}
func (m *AutoCertInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutoCertInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AutoCertInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutoCertInfoType.Merge(m, src)
}
func (m *AutoCertInfoType) XXX_Size() int {
	return m.Size()
}
func (m *AutoCertInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_AutoCertInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_AutoCertInfoType proto.InternalMessageInfo

func (m *AutoCertInfoType) GetAutoCertState() CertificationState {
	if m != nil {
		return m.AutoCertState
	}
	return AutoCertDisabled
}

func (m *AutoCertInfoType) GetAutoCertExpiry() *types.Timestamp {
	if m != nil {
		return m.AutoCertExpiry
	}
	return nil
}

func (m *AutoCertInfoType) GetAutoCertSubject() string {
	if m != nil {
		return m.AutoCertSubject
	}
	return ""
}

func (m *AutoCertInfoType) GetAutoCertIssuer() string {
	if m != nil {
		return m.AutoCertIssuer
	}
	return ""
}

// AuthenticationDetails
//
// x-displayName: "Authentication Details"
// Authentication related information. This allows to configure the URL to redirect after the authentication
// Authentication Object Reference, configuration of cookie params etc
type AuthenticationDetails struct {
	// Authentication Object
	//
	// x-displayName: "Reference to Authentication Object"
	// x-required
	// Reference to Authentication Config Object
	AuthConfig []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=auth_config,json=authConfig,proto3" json:"auth_config,omitempty"`
	// Cookie Parameters Configuration
	//
	// x-displayName: "Cookie Parameters"
	//
	// Types that are valid to be assigned to CookieParamsChoice:
	//	*AuthenticationDetails_UseAuthObjectConfig
	//	*AuthenticationDetails_CookieParams
	CookieParamsChoice isAuthenticationDetails_CookieParamsChoice `protobuf_oneof:"cookie_params_choice"`
	// Redirect URL Choice
	//
	// x-displayName: "Redirect URL Configuration"
	// x-required
	// Select Redirect URL
	//
	// Types that are valid to be assigned to RedirectUrlChoice:
	//	*AuthenticationDetails_RedirectUrl
	//	*AuthenticationDetails_RedirectDynamic
	RedirectUrlChoice isAuthenticationDetails_RedirectUrlChoice `protobuf_oneof:"redirect_url_choice"`
}

func (m *AuthenticationDetails) Reset()      { *m = AuthenticationDetails{} }
func (*AuthenticationDetails) ProtoMessage() {}
func (*AuthenticationDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_df61af5ea37a6592, []int{7}
}
func (m *AuthenticationDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthenticationDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AuthenticationDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticationDetails.Merge(m, src)
}
func (m *AuthenticationDetails) XXX_Size() int {
	return m.Size()
}
func (m *AuthenticationDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticationDetails.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticationDetails proto.InternalMessageInfo

type isAuthenticationDetails_CookieParamsChoice interface {
	isAuthenticationDetails_CookieParamsChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isAuthenticationDetails_RedirectUrlChoice interface {
	isAuthenticationDetails_RedirectUrlChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AuthenticationDetails_UseAuthObjectConfig struct {
	UseAuthObjectConfig *schema.Empty `protobuf:"bytes,3,opt,name=use_auth_object_config,json=useAuthObjectConfig,proto3,oneof" json:"use_auth_object_config,omitempty"`
}
type AuthenticationDetails_CookieParams struct {
	CookieParams *authentication.CookieParams `protobuf:"bytes,4,opt,name=cookie_params,json=cookieParams,proto3,oneof" json:"cookie_params,omitempty"`
}
type AuthenticationDetails_RedirectUrl struct {
	RedirectUrl string `protobuf:"bytes,6,opt,name=redirect_url,json=redirectUrl,proto3,oneof" json:"redirect_url,omitempty"`
}
type AuthenticationDetails_RedirectDynamic struct {
	RedirectDynamic *schema.Empty `protobuf:"bytes,7,opt,name=redirect_dynamic,json=redirectDynamic,proto3,oneof" json:"redirect_dynamic,omitempty"`
}

func (*AuthenticationDetails_UseAuthObjectConfig) isAuthenticationDetails_CookieParamsChoice() {}
func (*AuthenticationDetails_CookieParams) isAuthenticationDetails_CookieParamsChoice()        {}
func (*AuthenticationDetails_RedirectUrl) isAuthenticationDetails_RedirectUrlChoice()          {}
func (*AuthenticationDetails_RedirectDynamic) isAuthenticationDetails_RedirectUrlChoice()      {}

func (m *AuthenticationDetails) GetCookieParamsChoice() isAuthenticationDetails_CookieParamsChoice {
	if m != nil {
		return m.CookieParamsChoice
	}
	return nil
}
func (m *AuthenticationDetails) GetRedirectUrlChoice() isAuthenticationDetails_RedirectUrlChoice {
	if m != nil {
		return m.RedirectUrlChoice
	}
	return nil
}

func (m *AuthenticationDetails) GetAuthConfig() []*schema.ObjectRefType {
	if m != nil {
		return m.AuthConfig
	}
	return nil
}

func (m *AuthenticationDetails) GetUseAuthObjectConfig() *schema.Empty {
	if x, ok := m.GetCookieParamsChoice().(*AuthenticationDetails_UseAuthObjectConfig); ok {
		return x.UseAuthObjectConfig
	}
	return nil
}

func (m *AuthenticationDetails) GetCookieParams() *authentication.CookieParams {
	if x, ok := m.GetCookieParamsChoice().(*AuthenticationDetails_CookieParams); ok {
		return x.CookieParams
	}
	return nil
}

func (m *AuthenticationDetails) GetRedirectUrl() string {
	if x, ok := m.GetRedirectUrlChoice().(*AuthenticationDetails_RedirectUrl); ok {
		return x.RedirectUrl
	}
	return ""
}

func (m *AuthenticationDetails) GetRedirectDynamic() *schema.Empty {
	if x, ok := m.GetRedirectUrlChoice().(*AuthenticationDetails_RedirectDynamic); ok {
		return x.RedirectDynamic
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AuthenticationDetails) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AuthenticationDetails_UseAuthObjectConfig)(nil),
		(*AuthenticationDetails_CookieParams)(nil),
		(*AuthenticationDetails_RedirectUrl)(nil),
		(*AuthenticationDetails_RedirectDynamic)(nil),
	}
}

// policy based challenge
//
// x-displayName: "Policy Based Challenge"
// Specifies the settings for policy rule based challenge
type PolicyBasedChallenge struct {
	// Javascript Challenge
	//
	// x-displayName: "Javascript Challenge Parameters"
	// Configure Javascript challenge parameters
	JsChallenge *JavascriptChallengeType `protobuf:"bytes,1,opt,name=js_challenge,json=jsChallenge,proto3" json:"js_challenge,omitempty"`
	// Captcha Challenge
	//
	// x-displayName: "Captcha Challenge"
	// Configure Captcha challenge parameters
	CaptchaChallenge *CaptchaChallengeType `protobuf:"bytes,2,opt,name=captcha_challenge,json=captchaChallenge,proto3" json:"captcha_challenge,omitempty"`
	// Temporary User Blocking
	//
	// x-displayName: "Temporary User Blocking"
	// Specifies configuration for temporary user blocking resulting from malicious user detection
	TemporaryUserBlocking *TemporaryUserBlockingType `protobuf:"bytes,3,opt,name=temporary_user_blocking,json=temporaryUserBlocking,proto3" json:"temporary_user_blocking,omitempty"`
	// challenge choice
	//
	// x-displayName: "Select Type of Challenge"
	// x-required
	// Select the default challenge type for all requests. This can be overriden using the challenge rule list.
	//
	// Types that are valid to be assigned to ChallengeChoice:
	//	*PolicyBasedChallenge_NoChallenge
	//	*PolicyBasedChallenge_AlwaysEnableJsChallenge
	//	*PolicyBasedChallenge_AlwaysEnableCaptchaChallenge
	ChallengeChoice isPolicyBasedChallenge_ChallengeChoice `protobuf_oneof:"challenge_choice"`
	// Malicious User Mitigation
	//
	// x-displayName: "Malicious User Mitigation"
	// Settings that specify the actions to be taken when malicious users are determined to be at different threat levels.
	// User's activity is monitored and continuously analyzed for malicious behavior. From this analysis, a threat level is assigned to each user.
	// The settings defined in malicious user mitigation specify what mitigation actions to take for users determined to be at different threat levels.
	MaliciousUserMitigation []*schema.ObjectRefType `protobuf:"bytes,8,rep,name=malicious_user_mitigation,json=maliciousUserMitigation,proto3" json:"malicious_user_mitigation,omitempty"`
}

func (m *PolicyBasedChallenge) Reset()      { *m = PolicyBasedChallenge{} }
func (*PolicyBasedChallenge) ProtoMessage() {}
func (*PolicyBasedChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_df61af5ea37a6592, []int{8}
}
func (m *PolicyBasedChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyBasedChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PolicyBasedChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyBasedChallenge.Merge(m, src)
}
func (m *PolicyBasedChallenge) XXX_Size() int {
	return m.Size()
}
func (m *PolicyBasedChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyBasedChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyBasedChallenge proto.InternalMessageInfo

type isPolicyBasedChallenge_ChallengeChoice interface {
	isPolicyBasedChallenge_ChallengeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PolicyBasedChallenge_NoChallenge struct {
	NoChallenge *schema.Empty `protobuf:"bytes,5,opt,name=no_challenge,json=noChallenge,proto3,oneof" json:"no_challenge,omitempty"`
}
type PolicyBasedChallenge_AlwaysEnableJsChallenge struct {
	AlwaysEnableJsChallenge *schema.Empty `protobuf:"bytes,6,opt,name=always_enable_js_challenge,json=alwaysEnableJsChallenge,proto3,oneof" json:"always_enable_js_challenge,omitempty"`
}
type PolicyBasedChallenge_AlwaysEnableCaptchaChallenge struct {
	AlwaysEnableCaptchaChallenge *schema.Empty `protobuf:"bytes,7,opt,name=always_enable_captcha_challenge,json=alwaysEnableCaptchaChallenge,proto3,oneof" json:"always_enable_captcha_challenge,omitempty"`
}

func (*PolicyBasedChallenge_NoChallenge) isPolicyBasedChallenge_ChallengeChoice()                  {}
func (*PolicyBasedChallenge_AlwaysEnableJsChallenge) isPolicyBasedChallenge_ChallengeChoice()      {}
func (*PolicyBasedChallenge_AlwaysEnableCaptchaChallenge) isPolicyBasedChallenge_ChallengeChoice() {}

func (m *PolicyBasedChallenge) GetChallengeChoice() isPolicyBasedChallenge_ChallengeChoice {
	if m != nil {
		return m.ChallengeChoice
	}
	return nil
}

func (m *PolicyBasedChallenge) GetJsChallenge() *JavascriptChallengeType {
	if m != nil {
		return m.JsChallenge
	}
	return nil
}

func (m *PolicyBasedChallenge) GetCaptchaChallenge() *CaptchaChallengeType {
	if m != nil {
		return m.CaptchaChallenge
	}
	return nil
}

func (m *PolicyBasedChallenge) GetTemporaryUserBlocking() *TemporaryUserBlockingType {
	if m != nil {
		return m.TemporaryUserBlocking
	}
	return nil
}

func (m *PolicyBasedChallenge) GetNoChallenge() *schema.Empty {
	if x, ok := m.GetChallengeChoice().(*PolicyBasedChallenge_NoChallenge); ok {
		return x.NoChallenge
	}
	return nil
}

func (m *PolicyBasedChallenge) GetAlwaysEnableJsChallenge() *schema.Empty {
	if x, ok := m.GetChallengeChoice().(*PolicyBasedChallenge_AlwaysEnableJsChallenge); ok {
		return x.AlwaysEnableJsChallenge
	}
	return nil
}

func (m *PolicyBasedChallenge) GetAlwaysEnableCaptchaChallenge() *schema.Empty {
	if x, ok := m.GetChallengeChoice().(*PolicyBasedChallenge_AlwaysEnableCaptchaChallenge); ok {
		return x.AlwaysEnableCaptchaChallenge
	}
	return nil
}

func (m *PolicyBasedChallenge) GetMaliciousUserMitigation() []*schema.ObjectRefType {
	if m != nil {
		return m.MaliciousUserMitigation
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PolicyBasedChallenge) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PolicyBasedChallenge_NoChallenge)(nil),
		(*PolicyBasedChallenge_AlwaysEnableJsChallenge)(nil),
		(*PolicyBasedChallenge_AlwaysEnableCaptchaChallenge)(nil),
	}
}

// GlobalSpecType
//
// x-displayName: "Global Configuration Specification"
// Configuration specification for VirtualHost
type GlobalSpecType struct {
	// domains
	//
	// x-displayName: "Domains"
	// x-example: "www.foo.com"
	// A list of domains (host/authority header) that will be matched to this virtual host.
	// Wildcard hosts are supported in the suffix or prefix form
	//
	// Domain search order:
	//  1. Exact domain names: www.foo.com.
	//  2. Prefix domain wildcards: *.foo.com or *-bar.foo.com.
	//  3. Special wildcard * matching any domain.
	//
	// Wildcard will not match empty string.
	// e.g. *-bar.foo.com will match baz-bar.foo.com but not -bar.foo.com.
	// The longest wildcards match first.
	// Only a single virtual host in the entire route configuration can match on *.
	// Also a domain must be unique across all virtual hosts within an advertise policy.
	//
	// Domains are also used for SNI matching if the virtual host proxy type is TCP_PROXY_WITH_SNI/HTTPS_PROXY
	// Domains also indicate the list of names for which DNS resolution will be done by VER
	Domains []string `protobuf:"bytes,2,rep,name=domains,proto3" json:"domains,omitempty"`
	// routes
	//
	// x-displayName: "Routes"
	// The list of routes that will be matched, in order, for incoming requests.
	// The first route that matches will be used. Currently route object is redundant in case of TCP proxy but required.
	// For TCP_PROXY/TCP_PROXY_WITH_SNI/SMA_PROXY VirtualHosts, the route object only specifies the cluster/weighted-cluster
	// as route destination without any match condition. In other words, match condition in route object is ignored for
	// TCP_PROXY/TCP_PROXY_WITH_SNI/SMA_PROXY VirtualHosts. Routes used for TCP_PROXY/TCP_PROXY_WITH_SNI/SMA_PROXY
	// VirtualHosts cannot have DirectResponse or Redirect as actions.
	Routes []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=routes,proto3" json:"routes,omitempty"`
	// javascript_info
	//
	// x-displayName: "Javascript Info"
	// Custom JavaScript Configuration. Custom JavaScript code can be executed at various stages of request processing.
	JavascriptInfo *JavaScriptConfigType `protobuf:"bytes,4,opt,name=javascript_info,json=javascriptInfo,proto3" json:"javascript_info,omitempty"`
	// Advertise Policy
	//
	// x-displayName: "Advertise Policies"
	// Advertise Policy allows you to define networks or sites where you want a VIP for this virtual host to be advertised.
	// Each Policy rule can have different parameters, like TLS configuration, ports, optionally ip address to be used for VIP.
	// If advertise policy is not specified then no VIP is assigned for this virtual host.
	AdvertisePolicies []*schema.ObjectRefType `protobuf:"bytes,5,rep,name=advertise_policies,json=advertisePolicies,proto3" json:"advertise_policies,omitempty"`
	// Headers to add in request
	//
	// x-displayName: "Add Request Headers"
	// Headers are key-value pairs to be added to HTTP request being routed towards upstream.
	// Headers specified at this level are applied after headers from matched Route are applied
	RequestHeadersToAdd []*schema.HeaderManipulationOptionType `protobuf:"bytes,6,rep,name=request_headers_to_add,json=requestHeadersToAdd,proto3" json:"request_headers_to_add,omitempty"`
	// Headers to add in response
	//
	// x-displayName: "Add Response Headers"
	// Headers are key-value pairs to be added to HTTP response being sent towards downstream.
	// Headers specified at this level are applied after headers from matched Route are applied
	ResponseHeadersToAdd []*schema.HeaderManipulationOptionType `protobuf:"bytes,7,rep,name=response_headers_to_add,json=responseHeadersToAdd,proto3" json:"response_headers_to_add,omitempty"`
	// Header to be removed from request
	//
	// x-displayName: "Remove Request Headers"
	// x-example: "host"
	// List of keys of Headers to be removed from the HTTP request being sent towards upstream.
	RequestHeadersToRemove []string `protobuf:"bytes,17,rep,name=request_headers_to_remove,json=requestHeadersToRemove,proto3" json:"request_headers_to_remove,omitempty"`
	// Header to be removed from response
	//
	// x-displayName: "Remove Response Headers"
	// x-example: "host"
	// List of keys of Headers to be removed from the HTTP response being sent towards downstream.
	ResponseHeadersToRemove []string `protobuf:"bytes,8,rep,name=response_headers_to_remove,json=responseHeadersToRemove,proto3" json:"response_headers_to_remove,omitempty"`
	// TLS parameters.
	//
	// x-displayName: "TLS Parameters"
	// TLS parameters for downstream connections. These parameters are used if not specified
	// in advertise policy
	TlsParameters *schema.DownstreamTlsParamsType `protobuf:"bytes,9,opt,name=tls_parameters,json=tlsParameters,proto3" json:"tls_parameters,omitempty"`
	// Virtual host type
	//
	// x-displayName: "Virtual Host Type"
	// VirtualHostType indicates if virtual_host is used as VIRTUAL_SERVICE/LOAD_BALANCER/API_GATEWAY.
	// Functionally, all types are same, this is mainly used for categorizing metrics and UI visualization.
	Type VirtualHostType `protobuf:"varint,10,opt,name=type,proto3,enum=ves.io.schema.virtual_host.VirtualHostType" json:"type,omitempty"`
	// Buffer configuration for requests
	//
	// x-displayName: "Buffer Policy"
	// Some upstream applications are not capable of handling streamed data and high network latency.
	// This config enables buffering the entire request before sending to upstream application. We can
	// specify the maximum buffer size and buffer interval with this config.
	BufferPolicy *schema.BufferConfigType `protobuf:"bytes,12,opt,name=buffer_policy,json=bufferPolicy,proto3" json:"buffer_policy,omitempty"`
	// Cross-Origin Resource Sharing (CORS) configuration for requests
	//
	// x-displayName: "CORS Policy"
	// CORS is a mechanism that uses additional HTTP headers to tell a browser to let
	// a web application running at one origin (domain) have permission to access selected
	// resources from a server at a different origin
	CorsPolicy *schema.CorsPolicy `protobuf:"bytes,13,opt,name=cors_policy,json=corsPolicy,proto3" json:"cors_policy,omitempty"`
	// Proxy Type
	//
	// x-displayName: "Proxy Type"
	// Indicates whether the type of proxy is HTTP/HTTPS/TCP/UDP/Secret Management Access
	Proxy ProxyType `protobuf:"varint,15,opt,name=proxy,proto3,enum=ves.io.schema.virtual_host.ProxyType" json:"proxy,omitempty"`
	// JSON Web Token authentication (JWT) configuration for requests
	//
	// x-displayName: "JWT Config"
	// This HTTP filter specifies how to verify JSON Web Token (JWT). It will verify its signature,
	// audiences and issuer
	Jwt []*schema.ObjectRefType `protobuf:"bytes,16,rep,name=jwt,proto3" json:"jwt,omitempty"`
	// Enable the WAF (Web Application Firewall) functionality for VirtualHost
	//
	// x-displayName: "WAF Config"
	// WAF can be used to analyze inbound and outbound http/https traffic.
	// WAF can be configured either in BLOCKing Mode or ALERTing Mode.
	// In BLOCKing mode if WAF detects suspicious inbound/outbound traffic it blocks the request or response.
	// In ALERTing mode if suspicious traffic is detected, WAF generates ALERTs with details on the
	// suspicious traffic (instead of blocking traffic).
	//
	// waf_type can be either WAF or WAFRules.
	// WAF Object allows to
	//     Configure mode of the WAF (BLOCK/ALERT)
	//     Configure language used by the application which is being protected by the WAF
	//     Disable different high level security tags if required (e.g. SQLI_DETECTION, XSS_DETECTION etc)
	// WAFRules allows to
	//     Configure mode of the WAF (BLOCK/ALERT)
	//     Enable/Disable individual WAF security rules
	WafType *schema.WafType `protobuf:"bytes,18,opt,name=waf_type,json=wafType,proto3" json:"waf_type,omitempty"`
	// Enable the dynamic resolution of the endpoint
	//
	// x-displayName: "Dynamic Reverse Proxy"
	// In this mode of proxy, virtual host will resolve the destination endpoint dynamically.
	//
	// The dynamic resolution is done using a predefined field in the request. This predefined
	// field depends on the ProxyType configured on the Virtual Host.
	//
	// For HTTP traffic, i.e. with ProxyType as HTTP_PROXY or HTTPS_PROXY, virtual host will use the
	// "HOST" http header from the request and perform DNS resolution to select destination endpoint.
	//
	// For TCP traffic with SNI, (If the ProxyType is TCP_PROXY_WITH_SNI), virtual host will perform DNS
	// resolution using the SNI.
	//
	// The DNS resolution is performed in the virtual network specified in outside_network_type or
	// outside_network
	//
	// In both modes of operation(either using Host header or SNI), the DNS resolution could return
	// multiple addresses. First IPv4 address from such returned list is used as endpoint for the
	// request. The DNS response is cached for 60s by default.
	DynamicReverseProxy *DynamicReverseProxyType `protobuf:"bytes,19,opt,name=dynamic_reverse_proxy,json=dynamicReverseProxy,proto3" json:"dynamic_reverse_proxy,omitempty"`
	// Add Site information
	//
	// x-displayName: "Add Location"
	// x-example: "true"
	// x-example: true
	// Appends header x-volterra-location = <re-site-name> in responses. This configuration
	// is ignored on CE sites.
	AddLocation bool `protobuf:"varint,20,opt,name=add_location,json=addLocation,proto3" json:"add_location,omitempty"`
	// Compression configuration
	//
	// x-displayName: "Compression Parameters"
	// Enables loadbalancer to compress dispatched data from an upstream service upon client request.
	// Only GZIP compression is supported
	CompressionParams *CompressionType `protobuf:"bytes,21,opt,name=compression_params,json=compressionParams,proto3" json:"compression_params,omitempty"`
	// Custom Errors
	//
	// x-displayName: "Custom Error Responses"
	// x-example: "value"
	//
	// Map of integer error codes as keys and string values that can be used to provide custom
	// http pages for each error code.
	// Key of the map can be either response code class or HTTP Error code. Response code classes
	// for key is configured as follows
	// 3 -- for 3xx response code class
	// 4 -- for 4xx response code class
	// 5 -- for 5xx response code class
	// Value is the uri_ref. Currently supported URL schemes is string:///.
	// For string:/// scheme, message needs to be encoded in Base64 format.
	// You can specify this message as base64 encoded plain text message e.g. "Access Denied"
	// or it can be HTML paragraph or a body string encoded as base64 string
	// E.g. "<p> Access Denied </p>". Base64 encoded string for this html is "PHA+IEFjY2VzcyBEZW5pZWQgPC9wPg=="
	// Specific response code takes preference when both response code and response code class
	// matches for a request.
	//
	// The configured custom errors are only applicable for loadbalancer generated errors.
	// Errors returned from upstream server is propagated as is.
	//
	// Volterra provides default error pages for the errors generated by the loadbalancer. Content of
	// these pages are not editable. User has an option to disable the use of default Volterra error pages
	CustomErrors map[uint32]string `protobuf:"bytes,22,rep,name=custom_errors,json=customErrors,proto3" json:"custom_errors,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Disable use of default Error page
	//
	// x-displayName: "Disable default error pages"
	// x-example: "true"
	//
	// An option to specify whether to disable using default Volterra error pages
	DisableDefaultErrorPages bool `protobuf:"varint,33,opt,name=disable_default_error_pages,json=disableDefaultErrorPages,proto3" json:"disable_default_error_pages,omitempty"`
	// Maximum request header size
	//
	// x-displayName: "Maximum Request Header Size (KiB)"
	// x-example: "42"
	//
	// The maximum request header size in KiB for incoming connections.
	//
	// If un-configured, the default max request headers allowed is 60 KiB.
	//
	// Requests that exceed this limit will receive a 431 response.
	//
	// The max configurable limit is 96 KiB, based on current implementation constraints.
	//
	// Note:
	//   a. This configuration parameter is applicable only for HTTP_PROXY and HTTPS_PROXY
	//   b. When multiple HTTP_PROXY virtual hosts share the same advertise policy, the effective
	//      "maximum request header size" for such virtual hosts is the highest value configured
	//      on any of the virtual hosts
	MaxRequestHeaderSize uint32 `protobuf:"varint,23,opt,name=max_request_header_size,json=maxRequestHeaderSize,proto3" json:"max_request_header_size,omitempty"`
	// Challenge choice
	//
	// x-displayName: "Select Type of Challenge"
	// x-required
	// Selection of different types of challenge at Virtual Host
	//
	// Types that are valid to be assigned to ChallengeType:
	//	*GlobalSpecType_NoChallenge
	//	*GlobalSpecType_JsChallenge
	//	*GlobalSpecType_CaptchaChallenge
	//	*GlobalSpecType_PolicyBasedChallenge
	ChallengeType isGlobalSpecType_ChallengeType `protobuf_oneof:"challenge_type"`
	// user_identification
	//
	// x-displayName: "User Identification Policy"
	// A reference to user_identification object.
	// The rules in the user_identification object are evaluated to determine the user identifier to be rate limited.
	UserIdentification []*schema.ObjectRefType `protobuf:"bytes,25,rep,name=user_identification,json=userIdentification,proto3" json:"user_identification,omitempty"`
	// rate_limiter
	//
	// x-displayName: "Rate Limiter"
	// A reference to rate_limiter object.
	// Requests to the virtual_host are rate limited based on the parameters specified in the rate_limiter.
	RateLimiter []*schema.ObjectRefType `protobuf:"bytes,26,rep,name=rate_limiter,json=rateLimiter,proto3" json:"rate_limiter,omitempty"`
	// rate_limiter_allowed_prefixes
	//
	// x-displayName: "Rate Limiter Allowed Prefixes"
	// References to ip_prefix_set objects.
	// Requests from source IP addresses that are covered by one of the allowed IP Prefixes are not subjected to rate limiting.
	RateLimiterAllowedPrefixes []*schema.ObjectRefType `protobuf:"bytes,27,rep,name=rate_limiter_allowed_prefixes,json=rateLimiterAllowedPrefixes,proto3" json:"rate_limiter_allowed_prefixes,omitempty"`
	// retry_policy
	//
	// x-displayName: "Retry Policy"
	// Indicates that the virtual_host has a retry policy.
	RetryPolicy *schema.RetryPolicyType `protobuf:"bytes,28,opt,name=retry_policy,json=retryPolicy,proto3" json:"retry_policy,omitempty"`
	// Temporary User Blocking
	//
	// x-displayName: "Temporary User Blocking"
	// Specifies configuration for temporary user blocking resulting from malicious user detection
	TemporaryUserBlocking *TemporaryUserBlockingType `protobuf:"bytes,35,opt,name=temporary_user_blocking,json=temporaryUserBlocking,proto3" json:"temporary_user_blocking,omitempty"` // Deprecated: Do not use.
	// Malicious User Mitigation
	//
	// x-displayName: "Malicious User Mitigation"
	// Settings that specify the actions to be taken when malicious users are determined to be at different threat levels.
	// User's activity is monitored and continuously analyzed for malicious behavior. From this analysis, a threat level is assigned to each user.
	// The settings defined in malicious user mitigation specify what mitigation actions to take for users determined to be at different threat levels.
	MaliciousUserMitigation []*schema.ObjectRefType `protobuf:"bytes,36,rep,name=malicious_user_mitigation,json=maliciousUserMitigation,proto3" json:"malicious_user_mitigation,omitempty"` // Deprecated: Do not use.
	// TLS Interception
	//
	// x-displayName: "TLS Interception"
	//
	// Specify TLS interception configuration for the virtual host
	TlsIntercept *schema.TlsInterceptionType `protobuf:"bytes,37,opt,name=tls_intercept,json=tlsIntercept,proto3" json:"tls_intercept,omitempty"`
	// Authentication Configuration
	//
	// x-displayName: "Authentication Details"
	// Enable or Disable Authentication
	//
	// Types that are valid to be assigned to AuthenticationChoice:
	//	*GlobalSpecType_NoAuthentication
	//	*GlobalSpecType_Authentication
	AuthenticationChoice isGlobalSpecType_AuthenticationChoice `protobuf_oneof:"authentication_choice"`
	// Idle timeout
	//
	// x-displayName: "Idle timeout (in milliseconds)"
	// x-example: "2000"
	// Idle timeout is the amount of time that the loadbalancer will allow a stream to exist with
	// no upstream or downstream activity.
	//
	// Idle timeout and Proxy Type:
	//
	// HTTP_PROXY, HTTPS_PROXY:
	// Idle timer is started when the first byte is received on the connection.
	// Each time an encode/decode event for headers or data is processed for the stream,
	// the timer will be reset.
	// If the timeout fires, the stream is terminated with a 408 (Request Timeout) error code if
	// no upstream response header has been received, otherwise a stream reset occurs.
	// The default idle timeout is 30 seconds
	//
	// TCP PROXY, TCP_PROXY_WITH_SNI, SMA_PROXY:
	// The idle timeout is defined as the period in which there are no bytes sent or received on
	// either the upstream or downstream connection.
	// The default idle timeout is 1 hour.
	//
	// UDP PROXY:
	// The idle timeout for sessions. Idle timeout is defined as the period in which there are no
	// datagrams sent or received on the session.
	// The default if not specified is 1 minute.
	IdleTimeout uint32 `protobuf:"varint,32,opt,name=idle_timeout,json=idleTimeout,proto3" json:"idle_timeout,omitempty"`
	// Disable DNS Resolve
	//
	// x-displayName: "Disable DNS resolution"
	// x-example: "false"
	//
	// Disable DNS resolution for domains specified in the virtual host
	//
	// When the  virtual host is configured as Dynamive Resolve Proxy (DRP), disable DNS resolution
	// for domains configured.  This configuration is suitable for HTTP CONNECT proxy.
	DisableDnsResolve bool `protobuf:"varint,34,opt,name=disable_dns_resolve,json=disableDnsResolve,proto3" json:"disable_dns_resolve,omitempty"`
	// Server Header configuration
	//
	// x-displayName: "Server Header value to be used in response"
	// Specify Server Header value to be used in responses
	//
	// Types that are valid to be assigned to ServerHeaderChoice:
	//	*GlobalSpecType_DefaultHeader
	//	*GlobalSpecType_ServerName
	//	*GlobalSpecType_AppendServerName
	//	*GlobalSpecType_PassThrough
	ServerHeaderChoice isGlobalSpecType_ServerHeaderChoice `protobuf_oneof:"server_header_choice"`
	// DNS Volterra Managed
	//
	// x-displayName: "DNS Volterra Managed"
	// Is DNS for the specified domain managed by volterra. If this field is set, DNS record will be automatically added to the DNS domain.
	DnsVolterraManaged bool `protobuf:"varint,1000,opt,name=dns_volterra_managed,json=dnsVolterraManaged,proto3" json:"dns_volterra_managed,omitempty"`
	// DNS domain refs
	//
	// x-displayName: "DNS Domains"
	// Internal reference to dns_domain object
	DnsDomains []*schema.ObjectRefType `protobuf:"bytes,1001,rep,name=dns_domains,json=dnsDomains,proto3" json:"dns_domains,omitempty"`
	// Auto Certificates
	//
	// x-displayName: "Auto Certificates"
	// Automatically generated certificates. If this field is set, the user cannot specifi the TLS certificates
	AutoCert bool `protobuf:"varint,1002,opt,name=auto_cert,json=autoCert,proto3" json:"auto_cert,omitempty"`
	// Virtual Host state
	//
	// x-displayName: "Virtual Host State"
	// State of the virtual host
	State VirtualHostState `protobuf:"varint,1003,opt,name=state,proto3,enum=ves.io.schema.virtual_host.VirtualHostState" json:"state,omitempty"`
	// host name
	//
	// x-displayName: "Host Name"
	// x-example: "ves-io-cf8684b9-a18f-4843-a24f-1f9ee8ea2776.ac.vh.ves.io"
	// Internally generated host name to be used for the virtual host
	HostName string `protobuf:"bytes,1004,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	// DNS information
	//
	// x-displayName: "DNS Information"
	// DNS information for this virtual host
	DnsInfo []*virtual_host_dns_info.DnsInfo `protobuf:"bytes,1005,rep,name=dns_info,json=dnsInfo,proto3" json:"dns_info,omitempty"`
	// Auto Cert State
	//
	// x-displayName: "Auto Cert State"
	// State of auto certificate generation.
	AutoCertState CertificationState `protobuf:"varint,1006,opt,name=auto_cert_state,json=autoCertState,proto3,enum=ves.io.schema.virtual_host.CertificationState" json:"auto_cert_state,omitempty"` // Deprecated: Do not use.
	// Auto Cert Information
	//
	// x-displayName: "Auto Cert Information"
	// Auto certificate related information
	AutoCertInfo *AutoCertInfoType `protobuf:"bytes,1010,opt,name=auto_cert_info,json=autoCertInfo,proto3" json:"auto_cert_info,omitempty"`
	// User Domains
	//
	// x-displayName: "User Provided Domains"
	// User Provided domains. Used internally.
	UserDomains []string `protobuf:"bytes,1011,rep,name=user_domains,json=userDomains,proto3" json:"user_domains,omitempty"`
	// Service Policy Sets
	//
	// x-displayName: "Service Policy Sets"
	// Per VH service policy sets, created by system via policies in the http load balancer and http connect view.
	ServicePolicySets []*schema.ObjectRefType `protobuf:"bytes,1012,rep,name=service_policy_sets,json=servicePolicySets,proto3" json:"service_policy_sets,omitempty"`
	// loadbalancer_algorithm
	//
	// x-displayName: "LoadBalancer Algorithm"
	// When a connection to a endpoint in an upstream cluster is required, the loadbalancer uses
	// loadbalancer_algorithm to determine which host is selected.
	LoadbalancerAlgorithm cluster.LoadbalancerAlgorithm `protobuf:"varint,1013,opt,name=loadbalancer_algorithm,json=loadbalancerAlgorithm,proto3,enum=ves.io.schema.cluster.LoadbalancerAlgorithm" json:"loadbalancer_algorithm,omitempty"`
	// Volterra Certificates
	//
	// x-displayName: "Volterra Certificates"
	// Volterra managed certificates. If this field is set, the user cannot specifi the TLS certificates
	VolterraCert bool `protobuf:"varint,1014,opt,name=volterra_cert,json=volterraCert,proto3" json:"volterra_cert,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_df61af5ea37a6592, []int{9}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_ChallengeType interface {
	isGlobalSpecType_ChallengeType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_AuthenticationChoice interface {
	isGlobalSpecType_AuthenticationChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_ServerHeaderChoice interface {
	isGlobalSpecType_ServerHeaderChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_NoChallenge struct {
	NoChallenge *schema.Empty `protobuf:"bytes,31,opt,name=no_challenge,json=noChallenge,proto3,oneof" json:"no_challenge,omitempty"`
}
type GlobalSpecType_JsChallenge struct {
	JsChallenge *JavascriptChallengeType `protobuf:"bytes,24,opt,name=js_challenge,json=jsChallenge,proto3,oneof" json:"js_challenge,omitempty"`
}
type GlobalSpecType_CaptchaChallenge struct {
	CaptchaChallenge *CaptchaChallengeType `protobuf:"bytes,29,opt,name=captcha_challenge,json=captchaChallenge,proto3,oneof" json:"captcha_challenge,omitempty"`
}
type GlobalSpecType_PolicyBasedChallenge struct {
	PolicyBasedChallenge *PolicyBasedChallenge `protobuf:"bytes,41,opt,name=policy_based_challenge,json=policyBasedChallenge,proto3,oneof" json:"policy_based_challenge,omitempty"`
}
type GlobalSpecType_NoAuthentication struct {
	NoAuthentication *schema.Empty `protobuf:"bytes,39,opt,name=no_authentication,json=noAuthentication,proto3,oneof" json:"no_authentication,omitempty"`
}
type GlobalSpecType_Authentication struct {
	Authentication *AuthenticationDetails `protobuf:"bytes,40,opt,name=authentication,proto3,oneof" json:"authentication,omitempty"`
}
type GlobalSpecType_DefaultHeader struct {
	DefaultHeader *schema.Empty `protobuf:"bytes,43,opt,name=default_header,json=defaultHeader,proto3,oneof" json:"default_header,omitempty"`
}
type GlobalSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,44,opt,name=server_name,json=serverName,proto3,oneof" json:"server_name,omitempty"`
}
type GlobalSpecType_AppendServerName struct {
	AppendServerName string `protobuf:"bytes,45,opt,name=append_server_name,json=appendServerName,proto3,oneof" json:"append_server_name,omitempty"`
}
type GlobalSpecType_PassThrough struct {
	PassThrough *schema.Empty `protobuf:"bytes,46,opt,name=pass_through,json=passThrough,proto3,oneof" json:"pass_through,omitempty"`
}

func (*GlobalSpecType_NoChallenge) isGlobalSpecType_ChallengeType()             {}
func (*GlobalSpecType_JsChallenge) isGlobalSpecType_ChallengeType()             {}
func (*GlobalSpecType_CaptchaChallenge) isGlobalSpecType_ChallengeType()        {}
func (*GlobalSpecType_PolicyBasedChallenge) isGlobalSpecType_ChallengeType()    {}
func (*GlobalSpecType_NoAuthentication) isGlobalSpecType_AuthenticationChoice() {}
func (*GlobalSpecType_Authentication) isGlobalSpecType_AuthenticationChoice()   {}
func (*GlobalSpecType_DefaultHeader) isGlobalSpecType_ServerHeaderChoice()      {}
func (*GlobalSpecType_ServerName) isGlobalSpecType_ServerHeaderChoice()         {}
func (*GlobalSpecType_AppendServerName) isGlobalSpecType_ServerHeaderChoice()   {}
func (*GlobalSpecType_PassThrough) isGlobalSpecType_ServerHeaderChoice()        {}

func (m *GlobalSpecType) GetChallengeType() isGlobalSpecType_ChallengeType {
	if m != nil {
		return m.ChallengeType
	}
	return nil
}
func (m *GlobalSpecType) GetAuthenticationChoice() isGlobalSpecType_AuthenticationChoice {
	if m != nil {
		return m.AuthenticationChoice
	}
	return nil
}
func (m *GlobalSpecType) GetServerHeaderChoice() isGlobalSpecType_ServerHeaderChoice {
	if m != nil {
		return m.ServerHeaderChoice
	}
	return nil
}

func (m *GlobalSpecType) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *GlobalSpecType) GetRoutes() []*schema.ObjectRefType {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *GlobalSpecType) GetJavascriptInfo() *JavaScriptConfigType {
	if m != nil {
		return m.JavascriptInfo
	}
	return nil
}

func (m *GlobalSpecType) GetAdvertisePolicies() []*schema.ObjectRefType {
	if m != nil {
		return m.AdvertisePolicies
	}
	return nil
}

func (m *GlobalSpecType) GetRequestHeadersToAdd() []*schema.HeaderManipulationOptionType {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

func (m *GlobalSpecType) GetResponseHeadersToAdd() []*schema.HeaderManipulationOptionType {
	if m != nil {
		return m.ResponseHeadersToAdd
	}
	return nil
}

func (m *GlobalSpecType) GetRequestHeadersToRemove() []string {
	if m != nil {
		return m.RequestHeadersToRemove
	}
	return nil
}

func (m *GlobalSpecType) GetResponseHeadersToRemove() []string {
	if m != nil {
		return m.ResponseHeadersToRemove
	}
	return nil
}

func (m *GlobalSpecType) GetTlsParameters() *schema.DownstreamTlsParamsType {
	if m != nil {
		return m.TlsParameters
	}
	return nil
}

func (m *GlobalSpecType) GetType() VirtualHostType {
	if m != nil {
		return m.Type
	}
	return VIRTUAL_SERVICE
}

func (m *GlobalSpecType) GetBufferPolicy() *schema.BufferConfigType {
	if m != nil {
		return m.BufferPolicy
	}
	return nil
}

func (m *GlobalSpecType) GetCorsPolicy() *schema.CorsPolicy {
	if m != nil {
		return m.CorsPolicy
	}
	return nil
}

func (m *GlobalSpecType) GetProxy() ProxyType {
	if m != nil {
		return m.Proxy
	}
	return HTTP_PROXY
}

func (m *GlobalSpecType) GetJwt() []*schema.ObjectRefType {
	if m != nil {
		return m.Jwt
	}
	return nil
}

func (m *GlobalSpecType) GetWafType() *schema.WafType {
	if m != nil {
		return m.WafType
	}
	return nil
}

func (m *GlobalSpecType) GetDynamicReverseProxy() *DynamicReverseProxyType {
	if m != nil {
		return m.DynamicReverseProxy
	}
	return nil
}

func (m *GlobalSpecType) GetAddLocation() bool {
	if m != nil {
		return m.AddLocation
	}
	return false
}

func (m *GlobalSpecType) GetCompressionParams() *CompressionType {
	if m != nil {
		return m.CompressionParams
	}
	return nil
}

func (m *GlobalSpecType) GetCustomErrors() map[uint32]string {
	if m != nil {
		return m.CustomErrors
	}
	return nil
}

func (m *GlobalSpecType) GetDisableDefaultErrorPages() bool {
	if m != nil {
		return m.DisableDefaultErrorPages
	}
	return false
}

func (m *GlobalSpecType) GetMaxRequestHeaderSize() uint32 {
	if m != nil {
		return m.MaxRequestHeaderSize
	}
	return 0
}

func (m *GlobalSpecType) GetNoChallenge() *schema.Empty {
	if x, ok := m.GetChallengeType().(*GlobalSpecType_NoChallenge); ok {
		return x.NoChallenge
	}
	return nil
}

func (m *GlobalSpecType) GetJsChallenge() *JavascriptChallengeType {
	if x, ok := m.GetChallengeType().(*GlobalSpecType_JsChallenge); ok {
		return x.JsChallenge
	}
	return nil
}

func (m *GlobalSpecType) GetCaptchaChallenge() *CaptchaChallengeType {
	if x, ok := m.GetChallengeType().(*GlobalSpecType_CaptchaChallenge); ok {
		return x.CaptchaChallenge
	}
	return nil
}

func (m *GlobalSpecType) GetPolicyBasedChallenge() *PolicyBasedChallenge {
	if x, ok := m.GetChallengeType().(*GlobalSpecType_PolicyBasedChallenge); ok {
		return x.PolicyBasedChallenge
	}
	return nil
}

func (m *GlobalSpecType) GetUserIdentification() []*schema.ObjectRefType {
	if m != nil {
		return m.UserIdentification
	}
	return nil
}

func (m *GlobalSpecType) GetRateLimiter() []*schema.ObjectRefType {
	if m != nil {
		return m.RateLimiter
	}
	return nil
}

func (m *GlobalSpecType) GetRateLimiterAllowedPrefixes() []*schema.ObjectRefType {
	if m != nil {
		return m.RateLimiterAllowedPrefixes
	}
	return nil
}

func (m *GlobalSpecType) GetRetryPolicy() *schema.RetryPolicyType {
	if m != nil {
		return m.RetryPolicy
	}
	return nil
}

// Deprecated: Do not use.
func (m *GlobalSpecType) GetTemporaryUserBlocking() *TemporaryUserBlockingType {
	if m != nil {
		return m.TemporaryUserBlocking
	}
	return nil
}

// Deprecated: Do not use.
func (m *GlobalSpecType) GetMaliciousUserMitigation() []*schema.ObjectRefType {
	if m != nil {
		return m.MaliciousUserMitigation
	}
	return nil
}

func (m *GlobalSpecType) GetTlsIntercept() *schema.TlsInterceptionType {
	if m != nil {
		return m.TlsIntercept
	}
	return nil
}

func (m *GlobalSpecType) GetNoAuthentication() *schema.Empty {
	if x, ok := m.GetAuthenticationChoice().(*GlobalSpecType_NoAuthentication); ok {
		return x.NoAuthentication
	}
	return nil
}

func (m *GlobalSpecType) GetAuthentication() *AuthenticationDetails {
	if x, ok := m.GetAuthenticationChoice().(*GlobalSpecType_Authentication); ok {
		return x.Authentication
	}
	return nil
}

func (m *GlobalSpecType) GetIdleTimeout() uint32 {
	if m != nil {
		return m.IdleTimeout
	}
	return 0
}

func (m *GlobalSpecType) GetDisableDnsResolve() bool {
	if m != nil {
		return m.DisableDnsResolve
	}
	return false
}

func (m *GlobalSpecType) GetDefaultHeader() *schema.Empty {
	if x, ok := m.GetServerHeaderChoice().(*GlobalSpecType_DefaultHeader); ok {
		return x.DefaultHeader
	}
	return nil
}

func (m *GlobalSpecType) GetServerName() string {
	if x, ok := m.GetServerHeaderChoice().(*GlobalSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *GlobalSpecType) GetAppendServerName() string {
	if x, ok := m.GetServerHeaderChoice().(*GlobalSpecType_AppendServerName); ok {
		return x.AppendServerName
	}
	return ""
}

func (m *GlobalSpecType) GetPassThrough() *schema.Empty {
	if x, ok := m.GetServerHeaderChoice().(*GlobalSpecType_PassThrough); ok {
		return x.PassThrough
	}
	return nil
}

func (m *GlobalSpecType) GetDnsVolterraManaged() bool {
	if m != nil {
		return m.DnsVolterraManaged
	}
	return false
}

func (m *GlobalSpecType) GetDnsDomains() []*schema.ObjectRefType {
	if m != nil {
		return m.DnsDomains
	}
	return nil
}

func (m *GlobalSpecType) GetAutoCert() bool {
	if m != nil {
		return m.AutoCert
	}
	return false
}

func (m *GlobalSpecType) GetState() VirtualHostState {
	if m != nil {
		return m.State
	}
	return VIRTUAL_HOST_READY
}

func (m *GlobalSpecType) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *GlobalSpecType) GetDnsInfo() []*virtual_host_dns_info.DnsInfo {
	if m != nil {
		return m.DnsInfo
	}
	return nil
}

// Deprecated: Do not use.
func (m *GlobalSpecType) GetAutoCertState() CertificationState {
	if m != nil {
		return m.AutoCertState
	}
	return AutoCertDisabled
}

func (m *GlobalSpecType) GetAutoCertInfo() *AutoCertInfoType {
	if m != nil {
		return m.AutoCertInfo
	}
	return nil
}

func (m *GlobalSpecType) GetUserDomains() []string {
	if m != nil {
		return m.UserDomains
	}
	return nil
}

func (m *GlobalSpecType) GetServicePolicySets() []*schema.ObjectRefType {
	if m != nil {
		return m.ServicePolicySets
	}
	return nil
}

func (m *GlobalSpecType) GetLoadbalancerAlgorithm() cluster.LoadbalancerAlgorithm {
	if m != nil {
		return m.LoadbalancerAlgorithm
	}
	return cluster.ROUND_ROBIN
}

func (m *GlobalSpecType) GetVolterraCert() bool {
	if m != nil {
		return m.VolterraCert
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_NoChallenge)(nil),
		(*GlobalSpecType_JsChallenge)(nil),
		(*GlobalSpecType_CaptchaChallenge)(nil),
		(*GlobalSpecType_PolicyBasedChallenge)(nil),
		(*GlobalSpecType_NoAuthentication)(nil),
		(*GlobalSpecType_Authentication)(nil),
		(*GlobalSpecType_DefaultHeader)(nil),
		(*GlobalSpecType_ServerName)(nil),
		(*GlobalSpecType_AppendServerName)(nil),
		(*GlobalSpecType_PassThrough)(nil),
	}
}

// Create virtual host
//
// x-displayName: "Create Virtual Host"
// Creates virtual host in a given namespace.
type CreateSpecType struct {
	Domains                  []string                               `protobuf:"bytes,2,rep,name=domains,proto3" json:"domains,omitempty"`
	Routes                   []*schema.ObjectRefType                `protobuf:"bytes,3,rep,name=routes,proto3" json:"routes,omitempty"`
	AdvertisePolicies        []*schema.ObjectRefType                `protobuf:"bytes,5,rep,name=advertise_policies,json=advertisePolicies,proto3" json:"advertise_policies,omitempty"`
	RequestHeadersToAdd      []*schema.HeaderManipulationOptionType `protobuf:"bytes,6,rep,name=request_headers_to_add,json=requestHeadersToAdd,proto3" json:"request_headers_to_add,omitempty"`
	ResponseHeadersToAdd     []*schema.HeaderManipulationOptionType `protobuf:"bytes,7,rep,name=response_headers_to_add,json=responseHeadersToAdd,proto3" json:"response_headers_to_add,omitempty"`
	RequestHeadersToRemove   []string                               `protobuf:"bytes,17,rep,name=request_headers_to_remove,json=requestHeadersToRemove,proto3" json:"request_headers_to_remove,omitempty"`
	ResponseHeadersToRemove  []string                               `protobuf:"bytes,8,rep,name=response_headers_to_remove,json=responseHeadersToRemove,proto3" json:"response_headers_to_remove,omitempty"`
	TlsParameters            *schema.DownstreamTlsParamsType        `protobuf:"bytes,9,opt,name=tls_parameters,json=tlsParameters,proto3" json:"tls_parameters,omitempty"`
	BufferPolicy             *schema.BufferConfigType               `protobuf:"bytes,12,opt,name=buffer_policy,json=bufferPolicy,proto3" json:"buffer_policy,omitempty"`
	CorsPolicy               *schema.CorsPolicy                     `protobuf:"bytes,13,opt,name=cors_policy,json=corsPolicy,proto3" json:"cors_policy,omitempty"`
	Proxy                    ProxyType                              `protobuf:"varint,15,opt,name=proxy,proto3,enum=ves.io.schema.virtual_host.ProxyType" json:"proxy,omitempty"`
	WafType                  *schema.WafType                        `protobuf:"bytes,18,opt,name=waf_type,json=wafType,proto3" json:"waf_type,omitempty"`
	DynamicReverseProxy      *DynamicReverseProxyType               `protobuf:"bytes,19,opt,name=dynamic_reverse_proxy,json=dynamicReverseProxy,proto3" json:"dynamic_reverse_proxy,omitempty"`
	AddLocation              bool                                   `protobuf:"varint,20,opt,name=add_location,json=addLocation,proto3" json:"add_location,omitempty"`
	CompressionParams        *CompressionType                       `protobuf:"bytes,21,opt,name=compression_params,json=compressionParams,proto3" json:"compression_params,omitempty"`
	CustomErrors             map[uint32]string                      `protobuf:"bytes,22,rep,name=custom_errors,json=customErrors,proto3" json:"custom_errors,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	DisableDefaultErrorPages bool                                   `protobuf:"varint,33,opt,name=disable_default_error_pages,json=disableDefaultErrorPages,proto3" json:"disable_default_error_pages,omitempty"`
	MaxRequestHeaderSize     uint32                                 `protobuf:"varint,23,opt,name=max_request_header_size,json=maxRequestHeaderSize,proto3" json:"max_request_header_size,omitempty"`
	// Types that are valid to be assigned to ChallengeType:
	//	*CreateSpecType_NoChallenge
	//	*CreateSpecType_JsChallenge
	//	*CreateSpecType_CaptchaChallenge
	ChallengeType              isCreateSpecType_ChallengeType `protobuf_oneof:"challenge_type"`
	UserIdentification         []*schema.ObjectRefType        `protobuf:"bytes,25,rep,name=user_identification,json=userIdentification,proto3" json:"user_identification,omitempty"`
	RateLimiter                []*schema.ObjectRefType        `protobuf:"bytes,26,rep,name=rate_limiter,json=rateLimiter,proto3" json:"rate_limiter,omitempty"`
	RateLimiterAllowedPrefixes []*schema.ObjectRefType        `protobuf:"bytes,27,rep,name=rate_limiter_allowed_prefixes,json=rateLimiterAllowedPrefixes,proto3" json:"rate_limiter_allowed_prefixes,omitempty"`
	RetryPolicy                *schema.RetryPolicyType        `protobuf:"bytes,28,opt,name=retry_policy,json=retryPolicy,proto3" json:"retry_policy,omitempty"`
	IdleTimeout                uint32                         `protobuf:"varint,32,opt,name=idle_timeout,json=idleTimeout,proto3" json:"idle_timeout,omitempty"`
	DisableDnsResolve          bool                           `protobuf:"varint,34,opt,name=disable_dns_resolve,json=disableDnsResolve,proto3" json:"disable_dns_resolve,omitempty"`
	TemporaryUserBlocking      *TemporaryUserBlockingType     `protobuf:"bytes,35,opt,name=temporary_user_blocking,json=temporaryUserBlocking,proto3" json:"temporary_user_blocking,omitempty"`
	// Types that are valid to be assigned to AuthenticationChoice:
	//	*CreateSpecType_NoAuthentication
	//	*CreateSpecType_Authentication
	AuthenticationChoice isCreateSpecType_AuthenticationChoice `protobuf_oneof:"authentication_choice"`
	// Types that are valid to be assigned to ServerHeaderChoice:
	//	*CreateSpecType_DefaultHeader
	//	*CreateSpecType_ServerName
	//	*CreateSpecType_AppendServerName
	//	*CreateSpecType_PassThrough
	ServerHeaderChoice isCreateSpecType_ServerHeaderChoice `protobuf_oneof:"server_header_choice"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_df61af5ea37a6592, []int{10}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_ChallengeType interface {
	isCreateSpecType_ChallengeType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_AuthenticationChoice interface {
	isCreateSpecType_AuthenticationChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_ServerHeaderChoice interface {
	isCreateSpecType_ServerHeaderChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_NoChallenge struct {
	NoChallenge *schema.Empty `protobuf:"bytes,31,opt,name=no_challenge,json=noChallenge,proto3,oneof" json:"no_challenge,omitempty"`
}
type CreateSpecType_JsChallenge struct {
	JsChallenge *JavascriptChallengeType `protobuf:"bytes,24,opt,name=js_challenge,json=jsChallenge,proto3,oneof" json:"js_challenge,omitempty"`
}
type CreateSpecType_CaptchaChallenge struct {
	CaptchaChallenge *CaptchaChallengeType `protobuf:"bytes,29,opt,name=captcha_challenge,json=captchaChallenge,proto3,oneof" json:"captcha_challenge,omitempty"`
}
type CreateSpecType_NoAuthentication struct {
	NoAuthentication *schema.Empty `protobuf:"bytes,39,opt,name=no_authentication,json=noAuthentication,proto3,oneof" json:"no_authentication,omitempty"`
}
type CreateSpecType_Authentication struct {
	Authentication *AuthenticationDetails `protobuf:"bytes,40,opt,name=authentication,proto3,oneof" json:"authentication,omitempty"`
}
type CreateSpecType_DefaultHeader struct {
	DefaultHeader *schema.Empty `protobuf:"bytes,43,opt,name=default_header,json=defaultHeader,proto3,oneof" json:"default_header,omitempty"`
}
type CreateSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,44,opt,name=server_name,json=serverName,proto3,oneof" json:"server_name,omitempty"`
}
type CreateSpecType_AppendServerName struct {
	AppendServerName string `protobuf:"bytes,45,opt,name=append_server_name,json=appendServerName,proto3,oneof" json:"append_server_name,omitempty"`
}
type CreateSpecType_PassThrough struct {
	PassThrough *schema.Empty `protobuf:"bytes,46,opt,name=pass_through,json=passThrough,proto3,oneof" json:"pass_through,omitempty"`
}

func (*CreateSpecType_NoChallenge) isCreateSpecType_ChallengeType()             {}
func (*CreateSpecType_JsChallenge) isCreateSpecType_ChallengeType()             {}
func (*CreateSpecType_CaptchaChallenge) isCreateSpecType_ChallengeType()        {}
func (*CreateSpecType_NoAuthentication) isCreateSpecType_AuthenticationChoice() {}
func (*CreateSpecType_Authentication) isCreateSpecType_AuthenticationChoice()   {}
func (*CreateSpecType_DefaultHeader) isCreateSpecType_ServerHeaderChoice()      {}
func (*CreateSpecType_ServerName) isCreateSpecType_ServerHeaderChoice()         {}
func (*CreateSpecType_AppendServerName) isCreateSpecType_ServerHeaderChoice()   {}
func (*CreateSpecType_PassThrough) isCreateSpecType_ServerHeaderChoice()        {}

func (m *CreateSpecType) GetChallengeType() isCreateSpecType_ChallengeType {
	if m != nil {
		return m.ChallengeType
	}
	return nil
}
func (m *CreateSpecType) GetAuthenticationChoice() isCreateSpecType_AuthenticationChoice {
	if m != nil {
		return m.AuthenticationChoice
	}
	return nil
}
func (m *CreateSpecType) GetServerHeaderChoice() isCreateSpecType_ServerHeaderChoice {
	if m != nil {
		return m.ServerHeaderChoice
	}
	return nil
}

func (m *CreateSpecType) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *CreateSpecType) GetRoutes() []*schema.ObjectRefType {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *CreateSpecType) GetAdvertisePolicies() []*schema.ObjectRefType {
	if m != nil {
		return m.AdvertisePolicies
	}
	return nil
}

func (m *CreateSpecType) GetRequestHeadersToAdd() []*schema.HeaderManipulationOptionType {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

func (m *CreateSpecType) GetResponseHeadersToAdd() []*schema.HeaderManipulationOptionType {
	if m != nil {
		return m.ResponseHeadersToAdd
	}
	return nil
}

func (m *CreateSpecType) GetRequestHeadersToRemove() []string {
	if m != nil {
		return m.RequestHeadersToRemove
	}
	return nil
}

func (m *CreateSpecType) GetResponseHeadersToRemove() []string {
	if m != nil {
		return m.ResponseHeadersToRemove
	}
	return nil
}

func (m *CreateSpecType) GetTlsParameters() *schema.DownstreamTlsParamsType {
	if m != nil {
		return m.TlsParameters
	}
	return nil
}

func (m *CreateSpecType) GetBufferPolicy() *schema.BufferConfigType {
	if m != nil {
		return m.BufferPolicy
	}
	return nil
}

func (m *CreateSpecType) GetCorsPolicy() *schema.CorsPolicy {
	if m != nil {
		return m.CorsPolicy
	}
	return nil
}

func (m *CreateSpecType) GetProxy() ProxyType {
	if m != nil {
		return m.Proxy
	}
	return HTTP_PROXY
}

func (m *CreateSpecType) GetWafType() *schema.WafType {
	if m != nil {
		return m.WafType
	}
	return nil
}

func (m *CreateSpecType) GetDynamicReverseProxy() *DynamicReverseProxyType {
	if m != nil {
		return m.DynamicReverseProxy
	}
	return nil
}

func (m *CreateSpecType) GetAddLocation() bool {
	if m != nil {
		return m.AddLocation
	}
	return false
}

func (m *CreateSpecType) GetCompressionParams() *CompressionType {
	if m != nil {
		return m.CompressionParams
	}
	return nil
}

func (m *CreateSpecType) GetCustomErrors() map[uint32]string {
	if m != nil {
		return m.CustomErrors
	}
	return nil
}

func (m *CreateSpecType) GetDisableDefaultErrorPages() bool {
	if m != nil {
		return m.DisableDefaultErrorPages
	}
	return false
}

func (m *CreateSpecType) GetMaxRequestHeaderSize() uint32 {
	if m != nil {
		return m.MaxRequestHeaderSize
	}
	return 0
}

func (m *CreateSpecType) GetNoChallenge() *schema.Empty {
	if x, ok := m.GetChallengeType().(*CreateSpecType_NoChallenge); ok {
		return x.NoChallenge
	}
	return nil
}

func (m *CreateSpecType) GetJsChallenge() *JavascriptChallengeType {
	if x, ok := m.GetChallengeType().(*CreateSpecType_JsChallenge); ok {
		return x.JsChallenge
	}
	return nil
}

func (m *CreateSpecType) GetCaptchaChallenge() *CaptchaChallengeType {
	if x, ok := m.GetChallengeType().(*CreateSpecType_CaptchaChallenge); ok {
		return x.CaptchaChallenge
	}
	return nil
}

func (m *CreateSpecType) GetUserIdentification() []*schema.ObjectRefType {
	if m != nil {
		return m.UserIdentification
	}
	return nil
}

func (m *CreateSpecType) GetRateLimiter() []*schema.ObjectRefType {
	if m != nil {
		return m.RateLimiter
	}
	return nil
}

func (m *CreateSpecType) GetRateLimiterAllowedPrefixes() []*schema.ObjectRefType {
	if m != nil {
		return m.RateLimiterAllowedPrefixes
	}
	return nil
}

func (m *CreateSpecType) GetRetryPolicy() *schema.RetryPolicyType {
	if m != nil {
		return m.RetryPolicy
	}
	return nil
}

func (m *CreateSpecType) GetIdleTimeout() uint32 {
	if m != nil {
		return m.IdleTimeout
	}
	return 0
}

func (m *CreateSpecType) GetDisableDnsResolve() bool {
	if m != nil {
		return m.DisableDnsResolve
	}
	return false
}

func (m *CreateSpecType) GetTemporaryUserBlocking() *TemporaryUserBlockingType {
	if m != nil {
		return m.TemporaryUserBlocking
	}
	return nil
}

func (m *CreateSpecType) GetNoAuthentication() *schema.Empty {
	if x, ok := m.GetAuthenticationChoice().(*CreateSpecType_NoAuthentication); ok {
		return x.NoAuthentication
	}
	return nil
}

func (m *CreateSpecType) GetAuthentication() *AuthenticationDetails {
	if x, ok := m.GetAuthenticationChoice().(*CreateSpecType_Authentication); ok {
		return x.Authentication
	}
	return nil
}

func (m *CreateSpecType) GetDefaultHeader() *schema.Empty {
	if x, ok := m.GetServerHeaderChoice().(*CreateSpecType_DefaultHeader); ok {
		return x.DefaultHeader
	}
	return nil
}

func (m *CreateSpecType) GetServerName() string {
	if x, ok := m.GetServerHeaderChoice().(*CreateSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *CreateSpecType) GetAppendServerName() string {
	if x, ok := m.GetServerHeaderChoice().(*CreateSpecType_AppendServerName); ok {
		return x.AppendServerName
	}
	return ""
}

func (m *CreateSpecType) GetPassThrough() *schema.Empty {
	if x, ok := m.GetServerHeaderChoice().(*CreateSpecType_PassThrough); ok {
		return x.PassThrough
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_NoChallenge)(nil),
		(*CreateSpecType_JsChallenge)(nil),
		(*CreateSpecType_CaptchaChallenge)(nil),
		(*CreateSpecType_NoAuthentication)(nil),
		(*CreateSpecType_Authentication)(nil),
		(*CreateSpecType_DefaultHeader)(nil),
		(*CreateSpecType_ServerName)(nil),
		(*CreateSpecType_AppendServerName)(nil),
		(*CreateSpecType_PassThrough)(nil),
	}
}

// Replace virtual host
//
// x-displayName: "Replace Virtual Host"
// Replace a given virtual host in a given namespace.
type ReplaceSpecType struct {
	Domains                  []string                               `protobuf:"bytes,2,rep,name=domains,proto3" json:"domains,omitempty"`
	Routes                   []*schema.ObjectRefType                `protobuf:"bytes,3,rep,name=routes,proto3" json:"routes,omitempty"`
	AdvertisePolicies        []*schema.ObjectRefType                `protobuf:"bytes,5,rep,name=advertise_policies,json=advertisePolicies,proto3" json:"advertise_policies,omitempty"`
	RequestHeadersToAdd      []*schema.HeaderManipulationOptionType `protobuf:"bytes,6,rep,name=request_headers_to_add,json=requestHeadersToAdd,proto3" json:"request_headers_to_add,omitempty"`
	ResponseHeadersToAdd     []*schema.HeaderManipulationOptionType `protobuf:"bytes,7,rep,name=response_headers_to_add,json=responseHeadersToAdd,proto3" json:"response_headers_to_add,omitempty"`
	RequestHeadersToRemove   []string                               `protobuf:"bytes,17,rep,name=request_headers_to_remove,json=requestHeadersToRemove,proto3" json:"request_headers_to_remove,omitempty"`
	ResponseHeadersToRemove  []string                               `protobuf:"bytes,8,rep,name=response_headers_to_remove,json=responseHeadersToRemove,proto3" json:"response_headers_to_remove,omitempty"`
	TlsParameters            *schema.DownstreamTlsParamsType        `protobuf:"bytes,9,opt,name=tls_parameters,json=tlsParameters,proto3" json:"tls_parameters,omitempty"`
	BufferPolicy             *schema.BufferConfigType               `protobuf:"bytes,12,opt,name=buffer_policy,json=bufferPolicy,proto3" json:"buffer_policy,omitempty"`
	CorsPolicy               *schema.CorsPolicy                     `protobuf:"bytes,13,opt,name=cors_policy,json=corsPolicy,proto3" json:"cors_policy,omitempty"`
	Proxy                    ProxyType                              `protobuf:"varint,15,opt,name=proxy,proto3,enum=ves.io.schema.virtual_host.ProxyType" json:"proxy,omitempty"`
	WafType                  *schema.WafType                        `protobuf:"bytes,18,opt,name=waf_type,json=wafType,proto3" json:"waf_type,omitempty"`
	DynamicReverseProxy      *DynamicReverseProxyType               `protobuf:"bytes,19,opt,name=dynamic_reverse_proxy,json=dynamicReverseProxy,proto3" json:"dynamic_reverse_proxy,omitempty"`
	AddLocation              bool                                   `protobuf:"varint,20,opt,name=add_location,json=addLocation,proto3" json:"add_location,omitempty"`
	CompressionParams        *CompressionType                       `protobuf:"bytes,21,opt,name=compression_params,json=compressionParams,proto3" json:"compression_params,omitempty"`
	CustomErrors             map[uint32]string                      `protobuf:"bytes,22,rep,name=custom_errors,json=customErrors,proto3" json:"custom_errors,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	DisableDefaultErrorPages bool                                   `protobuf:"varint,33,opt,name=disable_default_error_pages,json=disableDefaultErrorPages,proto3" json:"disable_default_error_pages,omitempty"`
	MaxRequestHeaderSize     uint32                                 `protobuf:"varint,23,opt,name=max_request_header_size,json=maxRequestHeaderSize,proto3" json:"max_request_header_size,omitempty"`
	// Types that are valid to be assigned to ChallengeType:
	//	*ReplaceSpecType_NoChallenge
	//	*ReplaceSpecType_JsChallenge
	//	*ReplaceSpecType_CaptchaChallenge
	ChallengeType              isReplaceSpecType_ChallengeType `protobuf_oneof:"challenge_type"`
	UserIdentification         []*schema.ObjectRefType         `protobuf:"bytes,25,rep,name=user_identification,json=userIdentification,proto3" json:"user_identification,omitempty"`
	RateLimiter                []*schema.ObjectRefType         `protobuf:"bytes,26,rep,name=rate_limiter,json=rateLimiter,proto3" json:"rate_limiter,omitempty"`
	RateLimiterAllowedPrefixes []*schema.ObjectRefType         `protobuf:"bytes,27,rep,name=rate_limiter_allowed_prefixes,json=rateLimiterAllowedPrefixes,proto3" json:"rate_limiter_allowed_prefixes,omitempty"`
	RetryPolicy                *schema.RetryPolicyType         `protobuf:"bytes,28,opt,name=retry_policy,json=retryPolicy,proto3" json:"retry_policy,omitempty"`
	IdleTimeout                uint32                          `protobuf:"varint,32,opt,name=idle_timeout,json=idleTimeout,proto3" json:"idle_timeout,omitempty"`
	DisableDnsResolve          bool                            `protobuf:"varint,34,opt,name=disable_dns_resolve,json=disableDnsResolve,proto3" json:"disable_dns_resolve,omitempty"`
	TemporaryUserBlocking      *TemporaryUserBlockingType      `protobuf:"bytes,35,opt,name=temporary_user_blocking,json=temporaryUserBlocking,proto3" json:"temporary_user_blocking,omitempty"`
	// Types that are valid to be assigned to AuthenticationChoice:
	//	*ReplaceSpecType_NoAuthentication
	//	*ReplaceSpecType_Authentication
	AuthenticationChoice isReplaceSpecType_AuthenticationChoice `protobuf_oneof:"authentication_choice"`
	// Types that are valid to be assigned to ServerHeaderChoice:
	//	*ReplaceSpecType_DefaultHeader
	//	*ReplaceSpecType_ServerName
	//	*ReplaceSpecType_AppendServerName
	//	*ReplaceSpecType_PassThrough
	ServerHeaderChoice isReplaceSpecType_ServerHeaderChoice `protobuf_oneof:"server_header_choice"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_df61af5ea37a6592, []int{11}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_ChallengeType interface {
	isReplaceSpecType_ChallengeType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_AuthenticationChoice interface {
	isReplaceSpecType_AuthenticationChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_ServerHeaderChoice interface {
	isReplaceSpecType_ServerHeaderChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_NoChallenge struct {
	NoChallenge *schema.Empty `protobuf:"bytes,31,opt,name=no_challenge,json=noChallenge,proto3,oneof" json:"no_challenge,omitempty"`
}
type ReplaceSpecType_JsChallenge struct {
	JsChallenge *JavascriptChallengeType `protobuf:"bytes,24,opt,name=js_challenge,json=jsChallenge,proto3,oneof" json:"js_challenge,omitempty"`
}
type ReplaceSpecType_CaptchaChallenge struct {
	CaptchaChallenge *CaptchaChallengeType `protobuf:"bytes,29,opt,name=captcha_challenge,json=captchaChallenge,proto3,oneof" json:"captcha_challenge,omitempty"`
}
type ReplaceSpecType_NoAuthentication struct {
	NoAuthentication *schema.Empty `protobuf:"bytes,39,opt,name=no_authentication,json=noAuthentication,proto3,oneof" json:"no_authentication,omitempty"`
}
type ReplaceSpecType_Authentication struct {
	Authentication *AuthenticationDetails `protobuf:"bytes,40,opt,name=authentication,proto3,oneof" json:"authentication,omitempty"`
}
type ReplaceSpecType_DefaultHeader struct {
	DefaultHeader *schema.Empty `protobuf:"bytes,43,opt,name=default_header,json=defaultHeader,proto3,oneof" json:"default_header,omitempty"`
}
type ReplaceSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,44,opt,name=server_name,json=serverName,proto3,oneof" json:"server_name,omitempty"`
}
type ReplaceSpecType_AppendServerName struct {
	AppendServerName string `protobuf:"bytes,45,opt,name=append_server_name,json=appendServerName,proto3,oneof" json:"append_server_name,omitempty"`
}
type ReplaceSpecType_PassThrough struct {
	PassThrough *schema.Empty `protobuf:"bytes,46,opt,name=pass_through,json=passThrough,proto3,oneof" json:"pass_through,omitempty"`
}

func (*ReplaceSpecType_NoChallenge) isReplaceSpecType_ChallengeType()             {}
func (*ReplaceSpecType_JsChallenge) isReplaceSpecType_ChallengeType()             {}
func (*ReplaceSpecType_CaptchaChallenge) isReplaceSpecType_ChallengeType()        {}
func (*ReplaceSpecType_NoAuthentication) isReplaceSpecType_AuthenticationChoice() {}
func (*ReplaceSpecType_Authentication) isReplaceSpecType_AuthenticationChoice()   {}
func (*ReplaceSpecType_DefaultHeader) isReplaceSpecType_ServerHeaderChoice()      {}
func (*ReplaceSpecType_ServerName) isReplaceSpecType_ServerHeaderChoice()         {}
func (*ReplaceSpecType_AppendServerName) isReplaceSpecType_ServerHeaderChoice()   {}
func (*ReplaceSpecType_PassThrough) isReplaceSpecType_ServerHeaderChoice()        {}

func (m *ReplaceSpecType) GetChallengeType() isReplaceSpecType_ChallengeType {
	if m != nil {
		return m.ChallengeType
	}
	return nil
}
func (m *ReplaceSpecType) GetAuthenticationChoice() isReplaceSpecType_AuthenticationChoice {
	if m != nil {
		return m.AuthenticationChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetServerHeaderChoice() isReplaceSpecType_ServerHeaderChoice {
	if m != nil {
		return m.ServerHeaderChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *ReplaceSpecType) GetRoutes() []*schema.ObjectRefType {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *ReplaceSpecType) GetAdvertisePolicies() []*schema.ObjectRefType {
	if m != nil {
		return m.AdvertisePolicies
	}
	return nil
}

func (m *ReplaceSpecType) GetRequestHeadersToAdd() []*schema.HeaderManipulationOptionType {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

func (m *ReplaceSpecType) GetResponseHeadersToAdd() []*schema.HeaderManipulationOptionType {
	if m != nil {
		return m.ResponseHeadersToAdd
	}
	return nil
}

func (m *ReplaceSpecType) GetRequestHeadersToRemove() []string {
	if m != nil {
		return m.RequestHeadersToRemove
	}
	return nil
}

func (m *ReplaceSpecType) GetResponseHeadersToRemove() []string {
	if m != nil {
		return m.ResponseHeadersToRemove
	}
	return nil
}

func (m *ReplaceSpecType) GetTlsParameters() *schema.DownstreamTlsParamsType {
	if m != nil {
		return m.TlsParameters
	}
	return nil
}

func (m *ReplaceSpecType) GetBufferPolicy() *schema.BufferConfigType {
	if m != nil {
		return m.BufferPolicy
	}
	return nil
}

func (m *ReplaceSpecType) GetCorsPolicy() *schema.CorsPolicy {
	if m != nil {
		return m.CorsPolicy
	}
	return nil
}

func (m *ReplaceSpecType) GetProxy() ProxyType {
	if m != nil {
		return m.Proxy
	}
	return HTTP_PROXY
}

func (m *ReplaceSpecType) GetWafType() *schema.WafType {
	if m != nil {
		return m.WafType
	}
	return nil
}

func (m *ReplaceSpecType) GetDynamicReverseProxy() *DynamicReverseProxyType {
	if m != nil {
		return m.DynamicReverseProxy
	}
	return nil
}

func (m *ReplaceSpecType) GetAddLocation() bool {
	if m != nil {
		return m.AddLocation
	}
	return false
}

func (m *ReplaceSpecType) GetCompressionParams() *CompressionType {
	if m != nil {
		return m.CompressionParams
	}
	return nil
}

func (m *ReplaceSpecType) GetCustomErrors() map[uint32]string {
	if m != nil {
		return m.CustomErrors
	}
	return nil
}

func (m *ReplaceSpecType) GetDisableDefaultErrorPages() bool {
	if m != nil {
		return m.DisableDefaultErrorPages
	}
	return false
}

func (m *ReplaceSpecType) GetMaxRequestHeaderSize() uint32 {
	if m != nil {
		return m.MaxRequestHeaderSize
	}
	return 0
}

func (m *ReplaceSpecType) GetNoChallenge() *schema.Empty {
	if x, ok := m.GetChallengeType().(*ReplaceSpecType_NoChallenge); ok {
		return x.NoChallenge
	}
	return nil
}

func (m *ReplaceSpecType) GetJsChallenge() *JavascriptChallengeType {
	if x, ok := m.GetChallengeType().(*ReplaceSpecType_JsChallenge); ok {
		return x.JsChallenge
	}
	return nil
}

func (m *ReplaceSpecType) GetCaptchaChallenge() *CaptchaChallengeType {
	if x, ok := m.GetChallengeType().(*ReplaceSpecType_CaptchaChallenge); ok {
		return x.CaptchaChallenge
	}
	return nil
}

func (m *ReplaceSpecType) GetUserIdentification() []*schema.ObjectRefType {
	if m != nil {
		return m.UserIdentification
	}
	return nil
}

func (m *ReplaceSpecType) GetRateLimiter() []*schema.ObjectRefType {
	if m != nil {
		return m.RateLimiter
	}
	return nil
}

func (m *ReplaceSpecType) GetRateLimiterAllowedPrefixes() []*schema.ObjectRefType {
	if m != nil {
		return m.RateLimiterAllowedPrefixes
	}
	return nil
}

func (m *ReplaceSpecType) GetRetryPolicy() *schema.RetryPolicyType {
	if m != nil {
		return m.RetryPolicy
	}
	return nil
}

func (m *ReplaceSpecType) GetIdleTimeout() uint32 {
	if m != nil {
		return m.IdleTimeout
	}
	return 0
}

func (m *ReplaceSpecType) GetDisableDnsResolve() bool {
	if m != nil {
		return m.DisableDnsResolve
	}
	return false
}

func (m *ReplaceSpecType) GetTemporaryUserBlocking() *TemporaryUserBlockingType {
	if m != nil {
		return m.TemporaryUserBlocking
	}
	return nil
}

func (m *ReplaceSpecType) GetNoAuthentication() *schema.Empty {
	if x, ok := m.GetAuthenticationChoice().(*ReplaceSpecType_NoAuthentication); ok {
		return x.NoAuthentication
	}
	return nil
}

func (m *ReplaceSpecType) GetAuthentication() *AuthenticationDetails {
	if x, ok := m.GetAuthenticationChoice().(*ReplaceSpecType_Authentication); ok {
		return x.Authentication
	}
	return nil
}

func (m *ReplaceSpecType) GetDefaultHeader() *schema.Empty {
	if x, ok := m.GetServerHeaderChoice().(*ReplaceSpecType_DefaultHeader); ok {
		return x.DefaultHeader
	}
	return nil
}

func (m *ReplaceSpecType) GetServerName() string {
	if x, ok := m.GetServerHeaderChoice().(*ReplaceSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *ReplaceSpecType) GetAppendServerName() string {
	if x, ok := m.GetServerHeaderChoice().(*ReplaceSpecType_AppendServerName); ok {
		return x.AppendServerName
	}
	return ""
}

func (m *ReplaceSpecType) GetPassThrough() *schema.Empty {
	if x, ok := m.GetServerHeaderChoice().(*ReplaceSpecType_PassThrough); ok {
		return x.PassThrough
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_NoChallenge)(nil),
		(*ReplaceSpecType_JsChallenge)(nil),
		(*ReplaceSpecType_CaptchaChallenge)(nil),
		(*ReplaceSpecType_NoAuthentication)(nil),
		(*ReplaceSpecType_Authentication)(nil),
		(*ReplaceSpecType_DefaultHeader)(nil),
		(*ReplaceSpecType_ServerName)(nil),
		(*ReplaceSpecType_AppendServerName)(nil),
		(*ReplaceSpecType_PassThrough)(nil),
	}
}

// Get virtual host
//
// x-displayName: "Get Virtual Host"
// Get virtual host from a given namespace.
type GetSpecType struct {
	Domains                  []string                               `protobuf:"bytes,2,rep,name=domains,proto3" json:"domains,omitempty"`
	Routes                   []*schema.ObjectRefType                `protobuf:"bytes,3,rep,name=routes,proto3" json:"routes,omitempty"`
	AdvertisePolicies        []*schema.ObjectRefType                `protobuf:"bytes,5,rep,name=advertise_policies,json=advertisePolicies,proto3" json:"advertise_policies,omitempty"`
	RequestHeadersToAdd      []*schema.HeaderManipulationOptionType `protobuf:"bytes,6,rep,name=request_headers_to_add,json=requestHeadersToAdd,proto3" json:"request_headers_to_add,omitempty"`
	ResponseHeadersToAdd     []*schema.HeaderManipulationOptionType `protobuf:"bytes,7,rep,name=response_headers_to_add,json=responseHeadersToAdd,proto3" json:"response_headers_to_add,omitempty"`
	RequestHeadersToRemove   []string                               `protobuf:"bytes,17,rep,name=request_headers_to_remove,json=requestHeadersToRemove,proto3" json:"request_headers_to_remove,omitempty"`
	ResponseHeadersToRemove  []string                               `protobuf:"bytes,8,rep,name=response_headers_to_remove,json=responseHeadersToRemove,proto3" json:"response_headers_to_remove,omitempty"`
	TlsParameters            *schema.DownstreamTlsParamsType        `protobuf:"bytes,9,opt,name=tls_parameters,json=tlsParameters,proto3" json:"tls_parameters,omitempty"`
	Type                     VirtualHostType                        `protobuf:"varint,10,opt,name=type,proto3,enum=ves.io.schema.virtual_host.VirtualHostType" json:"type,omitempty"`
	BufferPolicy             *schema.BufferConfigType               `protobuf:"bytes,12,opt,name=buffer_policy,json=bufferPolicy,proto3" json:"buffer_policy,omitempty"`
	CorsPolicy               *schema.CorsPolicy                     `protobuf:"bytes,13,opt,name=cors_policy,json=corsPolicy,proto3" json:"cors_policy,omitempty"`
	Proxy                    ProxyType                              `protobuf:"varint,15,opt,name=proxy,proto3,enum=ves.io.schema.virtual_host.ProxyType" json:"proxy,omitempty"`
	WafType                  *schema.WafType                        `protobuf:"bytes,18,opt,name=waf_type,json=wafType,proto3" json:"waf_type,omitempty"`
	DynamicReverseProxy      *DynamicReverseProxyType               `protobuf:"bytes,19,opt,name=dynamic_reverse_proxy,json=dynamicReverseProxy,proto3" json:"dynamic_reverse_proxy,omitempty"`
	AddLocation              bool                                   `protobuf:"varint,20,opt,name=add_location,json=addLocation,proto3" json:"add_location,omitempty"`
	CompressionParams        *CompressionType                       `protobuf:"bytes,21,opt,name=compression_params,json=compressionParams,proto3" json:"compression_params,omitempty"`
	CustomErrors             map[uint32]string                      `protobuf:"bytes,22,rep,name=custom_errors,json=customErrors,proto3" json:"custom_errors,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	DisableDefaultErrorPages bool                                   `protobuf:"varint,33,opt,name=disable_default_error_pages,json=disableDefaultErrorPages,proto3" json:"disable_default_error_pages,omitempty"`
	MaxRequestHeaderSize     uint32                                 `protobuf:"varint,23,opt,name=max_request_header_size,json=maxRequestHeaderSize,proto3" json:"max_request_header_size,omitempty"`
	// Types that are valid to be assigned to ChallengeType:
	//	*GetSpecType_NoChallenge
	//	*GetSpecType_JsChallenge
	//	*GetSpecType_CaptchaChallenge
	ChallengeType              isGetSpecType_ChallengeType `protobuf_oneof:"challenge_type"`
	UserIdentification         []*schema.ObjectRefType     `protobuf:"bytes,25,rep,name=user_identification,json=userIdentification,proto3" json:"user_identification,omitempty"`
	RateLimiter                []*schema.ObjectRefType     `protobuf:"bytes,26,rep,name=rate_limiter,json=rateLimiter,proto3" json:"rate_limiter,omitempty"`
	RateLimiterAllowedPrefixes []*schema.ObjectRefType     `protobuf:"bytes,27,rep,name=rate_limiter_allowed_prefixes,json=rateLimiterAllowedPrefixes,proto3" json:"rate_limiter_allowed_prefixes,omitempty"`
	RetryPolicy                *schema.RetryPolicyType     `protobuf:"bytes,28,opt,name=retry_policy,json=retryPolicy,proto3" json:"retry_policy,omitempty"`
	IdleTimeout                uint32                      `protobuf:"varint,32,opt,name=idle_timeout,json=idleTimeout,proto3" json:"idle_timeout,omitempty"`
	TemporaryUserBlocking      *TemporaryUserBlockingType  `protobuf:"bytes,35,opt,name=temporary_user_blocking,json=temporaryUserBlocking,proto3" json:"temporary_user_blocking,omitempty"`
	// Types that are valid to be assigned to AuthenticationChoice:
	//	*GetSpecType_NoAuthentication
	//	*GetSpecType_Authentication
	AuthenticationChoice isGetSpecType_AuthenticationChoice `protobuf_oneof:"authentication_choice"`
	// Types that are valid to be assigned to ServerHeaderChoice:
	//	*GetSpecType_DefaultHeader
	//	*GetSpecType_ServerName
	//	*GetSpecType_AppendServerName
	//	*GetSpecType_PassThrough
	ServerHeaderChoice isGetSpecType_ServerHeaderChoice `protobuf_oneof:"server_header_choice"`
	State              VirtualHostState                 `protobuf:"varint,1003,opt,name=state,proto3,enum=ves.io.schema.virtual_host.VirtualHostState" json:"state,omitempty"`
	HostName           string                           `protobuf:"bytes,1004,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	DnsInfo            []*virtual_host_dns_info.DnsInfo `protobuf:"bytes,1005,rep,name=dns_info,json=dnsInfo,proto3" json:"dns_info,omitempty"`
	AutoCertState      CertificationState               `protobuf:"varint,1006,opt,name=auto_cert_state,json=autoCertState,proto3,enum=ves.io.schema.virtual_host.CertificationState" json:"auto_cert_state,omitempty"`
	AutoCertInfo       *AutoCertInfoType                `protobuf:"bytes,1010,opt,name=auto_cert_info,json=autoCertInfo,proto3" json:"auto_cert_info,omitempty"`
	DisableDnsResolve  bool                             `protobuf:"varint,34,opt,name=disable_dns_resolve,json=disableDnsResolve,proto3" json:"disable_dns_resolve,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_df61af5ea37a6592, []int{12}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_ChallengeType interface {
	isGetSpecType_ChallengeType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_AuthenticationChoice interface {
	isGetSpecType_AuthenticationChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_ServerHeaderChoice interface {
	isGetSpecType_ServerHeaderChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_NoChallenge struct {
	NoChallenge *schema.Empty `protobuf:"bytes,31,opt,name=no_challenge,json=noChallenge,proto3,oneof" json:"no_challenge,omitempty"`
}
type GetSpecType_JsChallenge struct {
	JsChallenge *JavascriptChallengeType `protobuf:"bytes,24,opt,name=js_challenge,json=jsChallenge,proto3,oneof" json:"js_challenge,omitempty"`
}
type GetSpecType_CaptchaChallenge struct {
	CaptchaChallenge *CaptchaChallengeType `protobuf:"bytes,29,opt,name=captcha_challenge,json=captchaChallenge,proto3,oneof" json:"captcha_challenge,omitempty"`
}
type GetSpecType_NoAuthentication struct {
	NoAuthentication *schema.Empty `protobuf:"bytes,39,opt,name=no_authentication,json=noAuthentication,proto3,oneof" json:"no_authentication,omitempty"`
}
type GetSpecType_Authentication struct {
	Authentication *AuthenticationDetails `protobuf:"bytes,40,opt,name=authentication,proto3,oneof" json:"authentication,omitempty"`
}
type GetSpecType_DefaultHeader struct {
	DefaultHeader *schema.Empty `protobuf:"bytes,43,opt,name=default_header,json=defaultHeader,proto3,oneof" json:"default_header,omitempty"`
}
type GetSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,44,opt,name=server_name,json=serverName,proto3,oneof" json:"server_name,omitempty"`
}
type GetSpecType_AppendServerName struct {
	AppendServerName string `protobuf:"bytes,45,opt,name=append_server_name,json=appendServerName,proto3,oneof" json:"append_server_name,omitempty"`
}
type GetSpecType_PassThrough struct {
	PassThrough *schema.Empty `protobuf:"bytes,46,opt,name=pass_through,json=passThrough,proto3,oneof" json:"pass_through,omitempty"`
}

func (*GetSpecType_NoChallenge) isGetSpecType_ChallengeType()             {}
func (*GetSpecType_JsChallenge) isGetSpecType_ChallengeType()             {}
func (*GetSpecType_CaptchaChallenge) isGetSpecType_ChallengeType()        {}
func (*GetSpecType_NoAuthentication) isGetSpecType_AuthenticationChoice() {}
func (*GetSpecType_Authentication) isGetSpecType_AuthenticationChoice()   {}
func (*GetSpecType_DefaultHeader) isGetSpecType_ServerHeaderChoice()      {}
func (*GetSpecType_ServerName) isGetSpecType_ServerHeaderChoice()         {}
func (*GetSpecType_AppendServerName) isGetSpecType_ServerHeaderChoice()   {}
func (*GetSpecType_PassThrough) isGetSpecType_ServerHeaderChoice()        {}

func (m *GetSpecType) GetChallengeType() isGetSpecType_ChallengeType {
	if m != nil {
		return m.ChallengeType
	}
	return nil
}
func (m *GetSpecType) GetAuthenticationChoice() isGetSpecType_AuthenticationChoice {
	if m != nil {
		return m.AuthenticationChoice
	}
	return nil
}
func (m *GetSpecType) GetServerHeaderChoice() isGetSpecType_ServerHeaderChoice {
	if m != nil {
		return m.ServerHeaderChoice
	}
	return nil
}

func (m *GetSpecType) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *GetSpecType) GetRoutes() []*schema.ObjectRefType {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *GetSpecType) GetAdvertisePolicies() []*schema.ObjectRefType {
	if m != nil {
		return m.AdvertisePolicies
	}
	return nil
}

func (m *GetSpecType) GetRequestHeadersToAdd() []*schema.HeaderManipulationOptionType {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

func (m *GetSpecType) GetResponseHeadersToAdd() []*schema.HeaderManipulationOptionType {
	if m != nil {
		return m.ResponseHeadersToAdd
	}
	return nil
}

func (m *GetSpecType) GetRequestHeadersToRemove() []string {
	if m != nil {
		return m.RequestHeadersToRemove
	}
	return nil
}

func (m *GetSpecType) GetResponseHeadersToRemove() []string {
	if m != nil {
		return m.ResponseHeadersToRemove
	}
	return nil
}

func (m *GetSpecType) GetTlsParameters() *schema.DownstreamTlsParamsType {
	if m != nil {
		return m.TlsParameters
	}
	return nil
}

func (m *GetSpecType) GetType() VirtualHostType {
	if m != nil {
		return m.Type
	}
	return VIRTUAL_SERVICE
}

func (m *GetSpecType) GetBufferPolicy() *schema.BufferConfigType {
	if m != nil {
		return m.BufferPolicy
	}
	return nil
}

func (m *GetSpecType) GetCorsPolicy() *schema.CorsPolicy {
	if m != nil {
		return m.CorsPolicy
	}
	return nil
}

func (m *GetSpecType) GetProxy() ProxyType {
	if m != nil {
		return m.Proxy
	}
	return HTTP_PROXY
}

func (m *GetSpecType) GetWafType() *schema.WafType {
	if m != nil {
		return m.WafType
	}
	return nil
}

func (m *GetSpecType) GetDynamicReverseProxy() *DynamicReverseProxyType {
	if m != nil {
		return m.DynamicReverseProxy
	}
	return nil
}

func (m *GetSpecType) GetAddLocation() bool {
	if m != nil {
		return m.AddLocation
	}
	return false
}

func (m *GetSpecType) GetCompressionParams() *CompressionType {
	if m != nil {
		return m.CompressionParams
	}
	return nil
}

func (m *GetSpecType) GetCustomErrors() map[uint32]string {
	if m != nil {
		return m.CustomErrors
	}
	return nil
}

func (m *GetSpecType) GetDisableDefaultErrorPages() bool {
	if m != nil {
		return m.DisableDefaultErrorPages
	}
	return false
}

func (m *GetSpecType) GetMaxRequestHeaderSize() uint32 {
	if m != nil {
		return m.MaxRequestHeaderSize
	}
	return 0
}

func (m *GetSpecType) GetNoChallenge() *schema.Empty {
	if x, ok := m.GetChallengeType().(*GetSpecType_NoChallenge); ok {
		return x.NoChallenge
	}
	return nil
}

func (m *GetSpecType) GetJsChallenge() *JavascriptChallengeType {
	if x, ok := m.GetChallengeType().(*GetSpecType_JsChallenge); ok {
		return x.JsChallenge
	}
	return nil
}

func (m *GetSpecType) GetCaptchaChallenge() *CaptchaChallengeType {
	if x, ok := m.GetChallengeType().(*GetSpecType_CaptchaChallenge); ok {
		return x.CaptchaChallenge
	}
	return nil
}

func (m *GetSpecType) GetUserIdentification() []*schema.ObjectRefType {
	if m != nil {
		return m.UserIdentification
	}
	return nil
}

func (m *GetSpecType) GetRateLimiter() []*schema.ObjectRefType {
	if m != nil {
		return m.RateLimiter
	}
	return nil
}

func (m *GetSpecType) GetRateLimiterAllowedPrefixes() []*schema.ObjectRefType {
	if m != nil {
		return m.RateLimiterAllowedPrefixes
	}
	return nil
}

func (m *GetSpecType) GetRetryPolicy() *schema.RetryPolicyType {
	if m != nil {
		return m.RetryPolicy
	}
	return nil
}

func (m *GetSpecType) GetIdleTimeout() uint32 {
	if m != nil {
		return m.IdleTimeout
	}
	return 0
}

func (m *GetSpecType) GetTemporaryUserBlocking() *TemporaryUserBlockingType {
	if m != nil {
		return m.TemporaryUserBlocking
	}
	return nil
}

func (m *GetSpecType) GetNoAuthentication() *schema.Empty {
	if x, ok := m.GetAuthenticationChoice().(*GetSpecType_NoAuthentication); ok {
		return x.NoAuthentication
	}
	return nil
}

func (m *GetSpecType) GetAuthentication() *AuthenticationDetails {
	if x, ok := m.GetAuthenticationChoice().(*GetSpecType_Authentication); ok {
		return x.Authentication
	}
	return nil
}

func (m *GetSpecType) GetDefaultHeader() *schema.Empty {
	if x, ok := m.GetServerHeaderChoice().(*GetSpecType_DefaultHeader); ok {
		return x.DefaultHeader
	}
	return nil
}

func (m *GetSpecType) GetServerName() string {
	if x, ok := m.GetServerHeaderChoice().(*GetSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *GetSpecType) GetAppendServerName() string {
	if x, ok := m.GetServerHeaderChoice().(*GetSpecType_AppendServerName); ok {
		return x.AppendServerName
	}
	return ""
}

func (m *GetSpecType) GetPassThrough() *schema.Empty {
	if x, ok := m.GetServerHeaderChoice().(*GetSpecType_PassThrough); ok {
		return x.PassThrough
	}
	return nil
}

func (m *GetSpecType) GetState() VirtualHostState {
	if m != nil {
		return m.State
	}
	return VIRTUAL_HOST_READY
}

func (m *GetSpecType) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *GetSpecType) GetDnsInfo() []*virtual_host_dns_info.DnsInfo {
	if m != nil {
		return m.DnsInfo
	}
	return nil
}

func (m *GetSpecType) GetAutoCertState() CertificationState {
	if m != nil {
		return m.AutoCertState
	}
	return AutoCertDisabled
}

func (m *GetSpecType) GetAutoCertInfo() *AutoCertInfoType {
	if m != nil {
		return m.AutoCertInfo
	}
	return nil
}

func (m *GetSpecType) GetDisableDnsResolve() bool {
	if m != nil {
		return m.DisableDnsResolve
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_NoChallenge)(nil),
		(*GetSpecType_JsChallenge)(nil),
		(*GetSpecType_CaptchaChallenge)(nil),
		(*GetSpecType_NoAuthentication)(nil),
		(*GetSpecType_Authentication)(nil),
		(*GetSpecType_DefaultHeader)(nil),
		(*GetSpecType_ServerName)(nil),
		(*GetSpecType_AppendServerName)(nil),
		(*GetSpecType_PassThrough)(nil),
	}
}

func init() {
	proto.RegisterEnum("ves.io.schema.virtual_host.VirtualHostType", VirtualHostType_name, VirtualHostType_value)
	golang_proto.RegisterEnum("ves.io.schema.virtual_host.VirtualHostType", VirtualHostType_name, VirtualHostType_value)
	proto.RegisterEnum("ves.io.schema.virtual_host.ProxyType", ProxyType_name, ProxyType_value)
	golang_proto.RegisterEnum("ves.io.schema.virtual_host.ProxyType", ProxyType_name, ProxyType_value)
	proto.RegisterEnum("ves.io.schema.virtual_host.VirtualHostState", VirtualHostState_name, VirtualHostState_value)
	golang_proto.RegisterEnum("ves.io.schema.virtual_host.VirtualHostState", VirtualHostState_name, VirtualHostState_value)
	proto.RegisterEnum("ves.io.schema.virtual_host.CertificationState", CertificationState_name, CertificationState_value)
	golang_proto.RegisterEnum("ves.io.schema.virtual_host.CertificationState", CertificationState_name, CertificationState_value)
	proto.RegisterType((*JavaScriptConfigType)(nil), "ves.io.schema.virtual_host.JavaScriptConfigType")
	golang_proto.RegisterType((*JavaScriptConfigType)(nil), "ves.io.schema.virtual_host.JavaScriptConfigType")
	proto.RegisterType((*DynamicReverseProxyType)(nil), "ves.io.schema.virtual_host.DynamicReverseProxyType")
	golang_proto.RegisterType((*DynamicReverseProxyType)(nil), "ves.io.schema.virtual_host.DynamicReverseProxyType")
	proto.RegisterType((*CompressionType)(nil), "ves.io.schema.virtual_host.CompressionType")
	golang_proto.RegisterType((*CompressionType)(nil), "ves.io.schema.virtual_host.CompressionType")
	proto.RegisterType((*JavascriptChallengeType)(nil), "ves.io.schema.virtual_host.JavascriptChallengeType")
	golang_proto.RegisterType((*JavascriptChallengeType)(nil), "ves.io.schema.virtual_host.JavascriptChallengeType")
	proto.RegisterType((*CaptchaChallengeType)(nil), "ves.io.schema.virtual_host.CaptchaChallengeType")
	golang_proto.RegisterType((*CaptchaChallengeType)(nil), "ves.io.schema.virtual_host.CaptchaChallengeType")
	proto.RegisterType((*TemporaryUserBlockingType)(nil), "ves.io.schema.virtual_host.TemporaryUserBlockingType")
	golang_proto.RegisterType((*TemporaryUserBlockingType)(nil), "ves.io.schema.virtual_host.TemporaryUserBlockingType")
	proto.RegisterType((*AutoCertInfoType)(nil), "ves.io.schema.virtual_host.AutoCertInfoType")
	golang_proto.RegisterType((*AutoCertInfoType)(nil), "ves.io.schema.virtual_host.AutoCertInfoType")
	proto.RegisterType((*AuthenticationDetails)(nil), "ves.io.schema.virtual_host.AuthenticationDetails")
	golang_proto.RegisterType((*AuthenticationDetails)(nil), "ves.io.schema.virtual_host.AuthenticationDetails")
	proto.RegisterType((*PolicyBasedChallenge)(nil), "ves.io.schema.virtual_host.PolicyBasedChallenge")
	golang_proto.RegisterType((*PolicyBasedChallenge)(nil), "ves.io.schema.virtual_host.PolicyBasedChallenge")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.virtual_host.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.virtual_host.GlobalSpecType")
	proto.RegisterMapType((map[uint32]string)(nil), "ves.io.schema.virtual_host.GlobalSpecType.CustomErrorsEntry")
	golang_proto.RegisterMapType((map[uint32]string)(nil), "ves.io.schema.virtual_host.GlobalSpecType.CustomErrorsEntry")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.virtual_host.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.virtual_host.CreateSpecType")
	proto.RegisterMapType((map[uint32]string)(nil), "ves.io.schema.virtual_host.CreateSpecType.CustomErrorsEntry")
	golang_proto.RegisterMapType((map[uint32]string)(nil), "ves.io.schema.virtual_host.CreateSpecType.CustomErrorsEntry")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.virtual_host.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.virtual_host.ReplaceSpecType")
	proto.RegisterMapType((map[uint32]string)(nil), "ves.io.schema.virtual_host.ReplaceSpecType.CustomErrorsEntry")
	golang_proto.RegisterMapType((map[uint32]string)(nil), "ves.io.schema.virtual_host.ReplaceSpecType.CustomErrorsEntry")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.virtual_host.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.virtual_host.GetSpecType")
	proto.RegisterMapType((map[uint32]string)(nil), "ves.io.schema.virtual_host.GetSpecType.CustomErrorsEntry")
	golang_proto.RegisterMapType((map[uint32]string)(nil), "ves.io.schema.virtual_host.GetSpecType.CustomErrorsEntry")
}

func init() {
	proto.RegisterFile("ves.io/schema/virtual_host/types.proto", fileDescriptor_df61af5ea37a6592)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/virtual_host/types.proto", fileDescriptor_df61af5ea37a6592)
}

var fileDescriptor_df61af5ea37a6592 = []byte{
	// 4316 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7c, 0xdb, 0x6f, 0x1b, 0x57,
	0x7e, 0xbf, 0x0e, 0x2f, 0x12, 0x75, 0x48, 0x4a, 0xa3, 0xa3, 0xdb, 0x58, 0xb6, 0xe9, 0xb1, 0x1c,
	0xdb, 0x8a, 0x32, 0xa6, 0x29, 0x52, 0x72, 0xac, 0x64, 0x9d, 0x2c, 0x29, 0xd2, 0x96, 0xbc, 0x8a,
	0xad, 0x1d, 0xc9, 0x4e, 0x9c, 0xfd, 0xed, 0x4e, 0x46, 0x33, 0x47, 0xd4, 0xd8, 0xc3, 0x19, 0x66,
	0x66, 0x28, 0x4b, 0xf9, 0x55, 0x80, 0x91, 0x87, 0x76, 0xd7, 0x0f, 0x45, 0x9a, 0xc7, 0x3c, 0xb5,
	0xdd, 0x97, 0x42, 0xfb, 0x0f, 0x14, 0xa5, 0x0b, 0x08, 0x01, 0x16, 0x0d, 0xfa, 0x52, 0x17, 0x5d,
	0xa0, 0x41, 0x9f, 0x12, 0xe5, 0xa1, 0x49, 0x7a, 0xc1, 0x62, 0xbb, 0x2d, 0x82, 0x3c, 0x15, 0xe7,
	0xcc, 0x0c, 0x39, 0x1c, 0x51, 0xb2, 0x62, 0x2b, 0x01, 0xb2, 0xd5, 0x8b, 0xc1, 0x39, 0xe7, 0x7b,
	0x3b, 0xb7, 0xef, 0xf9, 0x7c, 0xbe, 0x33, 0x16, 0x3c, 0xb7, 0x86, 0xad, 0xb4, 0x6a, 0x5c, 0xb4,
	0xe4, 0x55, 0x5c, 0x91, 0x2e, 0xae, 0xa9, 0xa6, 0x5d, 0x93, 0x34, 0x71, 0xd5, 0xb0, 0xec, 0x8b,
	0xf6, 0x46, 0x15, 0x5b, 0xe9, 0xaa, 0x69, 0xd8, 0x06, 0x1a, 0x71, 0xe4, 0xd2, 0x8e, 0x5c, 0xda,
	0x2f, 0x37, 0x72, 0xa1, 0xac, 0xda, 0xab, 0xb5, 0xe5, 0xb4, 0x6c, 0x54, 0x2e, 0x96, 0x8d, 0xb2,
	0x71, 0x91, 0xaa, 0x2c, 0xd7, 0x56, 0xe8, 0x13, 0x7d, 0xa0, 0xbf, 0x1c, 0x53, 0x23, 0x27, 0xca,
	0x86, 0x51, 0xd6, 0x70, 0x53, 0xca, 0xb2, 0xcd, 0x9a, 0x6c, 0xbb, 0xbd, 0xa7, 0x82, 0xbd, 0xb6,
	0x5a, 0xc1, 0x96, 0x2d, 0x55, 0xaa, 0xae, 0xc0, 0x58, 0x6b, 0xc4, 0x52, 0xcd, 0x5e, 0xc5, 0xba,
	0xad, 0xca, 0x92, 0xad, 0x1a, 0xba, 0x3f, 0xe6, 0x91, 0xd3, 0xad, 0x92, 0xb2, 0x56, 0xb3, 0x6c,
	0x6c, 0xb6, 0x88, 0x0c, 0xb7, 0x8a, 0xe8, 0xd8, 0x0b, 0xe3, 0x78, 0x6b, 0x87, 0x51, 0x25, 0xd6,
	0xad, 0xf6, 0x21, 0x58, 0xd8, 0x5c, 0x53, 0x65, 0x2c, 0x56, 0x0d, 0x4d, 0x95, 0x37, 0x5a, 0xec,
	0x1f, 0x6b, 0x95, 0xf4, 0x77, 0x9d, 0x08, 0xcc, 0xbc, 0xa4, 0xa9, 0x8a, 0x64, 0x63, 0xb7, 0x97,
	0x0b, 0xae, 0x0b, 0xbe, 0x2f, 0xb6, 0x06, 0x91, 0xd9, 0x7b, 0xe5, 0x44, 0x45, 0xb7, 0x44, 0x55,
	0x5f, 0x31, 0x2e, 0x1a, 0xcb, 0x77, 0xb1, 0x37, 0xb5, 0xa3, 0xbf, 0x04, 0x70, 0xe0, 0xba, 0xb4,
	0x26, 0x2d, 0xca, 0xa6, 0x5a, 0xb5, 0x67, 0x0c, 0x7d, 0x45, 0x2d, 0x2f, 0x6d, 0x54, 0x31, 0x3a,
	0x0d, 0x13, 0xb2, 0x24, 0xaf, 0x62, 0xb1, 0x6a, 0xe2, 0x15, 0x75, 0x9d, 0x05, 0x1c, 0x18, 0xeb,
	0x16, 0xe2, 0xb4, 0x6d, 0x81, 0x36, 0xa1, 0x1f, 0xc0, 0xa4, 0x45, 0xd5, 0x44, 0x99, 0xea, 0xb1,
	0x21, 0x0e, 0x8c, 0xc5, 0xb3, 0xc3, 0x69, 0x67, 0xb9, 0xd2, 0xde, 0x72, 0xa5, 0x17, 0xe9, 0x62,
	0x0a, 0x09, 0xcb, 0xe7, 0x04, 0x8d, 0xc3, 0x3e, 0xb9, 0x66, 0xd9, 0x46, 0x45, 0x74, 0x8d, 0xd4,
	0x4c, 0x8d, 0x0d, 0x53, 0x2f, 0xbd, 0x4e, 0x87, 0x13, 0xd3, 0x2d, 0x53, 0x1b, 0xfd, 0x22, 0x04,
	0x87, 0x8b, 0x1b, 0xba, 0x54, 0x51, 0x65, 0x01, 0xaf, 0x61, 0xd3, 0xc2, 0x0b, 0xa6, 0xb1, 0xbe,
	0x41, 0x03, 0xfd, 0x21, 0x3c, 0x61, 0x62, 0xcb, 0xd0, 0xd6, 0xb0, 0x88, 0x75, 0xa5, 0x6a, 0xa8,
	0xba, 0x2d, 0x2a, 0x8e, 0xac, 0xa4, 0x69, 0x1b, 0x34, 0xf0, 0x98, 0x30, 0xe2, 0xca, 0x94, 0x5c,
	0x91, 0x62, 0x53, 0x02, 0xdd, 0x81, 0xc3, 0xb4, 0xb7, 0x46, 0xa6, 0x52, 0xd4, 0xb1, 0x7d, 0xdf,
	0x30, 0xef, 0x89, 0x64, 0x5d, 0xe8, 0x88, 0x7a, 0xb2, 0xa7, 0xd3, 0xad, 0x3b, 0xfd, 0xb6, 0x33,
	0xaf, 0x37, 0x1c, 0x49, 0x12, 0x85, 0x30, 0xd8, 0xb4, 0xe0, 0x6b, 0x46, 0x22, 0x44, 0xbb, 0x4d,
	0xb3, 0x61, 0x2e, 0x3c, 0x16, 0xcf, 0x9e, 0x08, 0x58, 0xbd, 0x49, 0xd7, 0x45, 0xc0, 0x2b, 0x44,
	0xb3, 0x80, 0xb6, 0x36, 0x7b, 0xbd, 0xf5, 0x73, 0xf5, 0x84, 0xbe, 0x5d, 0x4e, 0xd0, 0x75, 0x88,
	0x64, 0x43, 0xd7, 0xb1, 0x4c, 0x1d, 0x90, 0x73, 0x61, 0xd4, 0x6c, 0x36, 0xca, 0x81, 0xb1, 0x64,
	0xe1, 0xf8, 0x76, 0x1d, 0x80, 0x7f, 0xa9, 0x83, 0x48, 0x36, 0x93, 0xc9, 0xfc, 0xfc, 0x11, 0xe8,
	0xf8, 0x9b, 0x2f, 0xb6, 0xc3, 0x9d, 0xe3, 0x11, 0x76, 0xfb, 0x1f, 0x9e, 0x13, 0xfa, 0x9a, 0x6a,
	0x4b, 0x8e, 0xd6, 0xf5, 0x48, 0x2c, 0xc2, 0x44, 0x47, 0xff, 0x2c, 0x04, 0x7b, 0x67, 0x8c, 0x4a,
	0xd5, 0xc4, 0x96, 0x45, 0x3a, 0xc9, 0x30, 0x32, 0xb0, 0x47, 0x36, 0x74, 0x1b, 0xeb, 0xb6, 0xa8,
	0x61, 0xbd, 0x6c, 0xaf, 0xd2, 0x59, 0x4d, 0x16, 0xba, 0x89, 0xc5, 0xc8, 0x78, 0x68, 0x2c, 0x25,
	0x24, 0x5d, 0x81, 0x79, 0xda, 0x8f, 0x96, 0x60, 0xc2, 0xd3, 0x70, 0x27, 0x32, 0x3c, 0xd6, 0x5d,
	0x98, 0x20, 0xf2, 0xf0, 0x7d, 0xd0, 0x35, 0x1a, 0x35, 0xc3, 0x63, 0x0f, 0x42, 0xe4, 0xb1, 0xfb,
	0x7d, 0xd0, 0x39, 0x1a, 0x31, 0x43, 0x1c, 0x20, 0x4f, 0xd1, 0xf7, 0x41, 0x88, 0xc9, 0x7a, 0xbf,
	0x58, 0x20, 0xc4, 0x5d, 0x33, 0x34, 0x8e, 0x1c, 0x1c, 0x52, 0x54, 0x4b, 0x5a, 0xd6, 0xb0, 0x68,
	0xe8, 0x22, 0xb6, 0xa5, 0xb2, 0xb8, 0x8a, 0x25, 0x05, 0x9b, 0x74, 0xe3, 0xc4, 0x84, 0x7e, 0xb7,
	0xf7, 0xa6, 0x5e, 0xb2, 0xa5, 0xf2, 0x2c, 0xed, 0x42, 0x79, 0x78, 0xd2, 0xc4, 0x15, 0x63, 0x0d,
	0x8b, 0x92, 0x2c, 0xe3, 0xaa, 0x2d, 0x62, 0x5d, 0x36, 0x14, 0x55, 0x6f, 0xe8, 0x46, 0xbc, 0x1d,
	0x42, 0x84, 0xf2, 0x54, 0xa6, 0xe4, 0x8a, 0x38, 0x26, 0x46, 0xff, 0x22, 0x04, 0x87, 0xc9, 0x29,
	0x71, 0x37, 0xf0, 0xaa, 0xa4, 0x91, 0x69, 0xc0, 0x34, 0xa6, 0xab, 0xb0, 0xf7, 0xae, 0xe5, 0xed,
	0x61, 0x05, 0x6b, 0xd2, 0x06, 0xdd, 0x35, 0xc9, 0x42, 0x8a, 0x4c, 0xfd, 0x54, 0x26, 0x93, 0xf9,
	0xaa, 0x0e, 0x3a, 0xbc, 0xe9, 0xef, 0x1e, 0xef, 0x62, 0x3f, 0xf9, 0x4d, 0x78, 0xec, 0xf3, 0x2e,
	0x21, 0x79, 0xd7, 0x72, 0x76, 0x78, 0x91, 0x28, 0xa1, 0x02, 0x4c, 0xca, 0x86, 0x71, 0x4f, 0xc5,
	0x22, 0x5e, 0xaf, 0xaa, 0xe6, 0x06, 0x1d, 0x52, 0xb2, 0x70, 0x92, 0x58, 0xc9, 0x5d, 0x6a, 0x58,
	0xa1, 0xb3, 0x14, 0x1b, 0xef, 0x64, 0x1f, 0xfc, 0x32, 0x3a, 0x06, 0x84, 0x84, 0xa3, 0x53, 0xa2,
	0x2a, 0xa8, 0x08, 0xe3, 0xee, 0x99, 0xaa, 0x4a, 0x65, 0x4c, 0x07, 0xd6, 0x5d, 0x38, 0xf3, 0x55,
	0x1d, 0x44, 0xfe, 0xf2, 0x11, 0x48, 0x4a, 0x96, 0xac, 0xaa, 0x3c, 0xb7, 0x2c, 0x59, 0xf8, 0xd2,
	0x24, 0x0d, 0xc6, 0xec, 0x62, 0x1f, 0x3c, 0x88, 0xbc, 0x07, 0x80, 0x00, 0x1d, 0xbd, 0x05, 0xa9,
	0x8c, 0x5f, 0x4a, 0x7f, 0x58, 0x07, 0xe3, 0x70, 0x0c, 0x9e, 0x6a, 0x0e, 0x99, 0x6b, 0x8c, 0x99,
	0x5b, 0x90, 0x4c, 0xa9, 0x82, 0x6d, 0x6c, 0x5a, 0x28, 0x9a, 0xe5, 0x73, 0xfc, 0xe4, 0xf5, 0x48,
	0x0c, 0x30, 0xa1, 0xd1, 0x7f, 0x04, 0x70, 0x60, 0x46, 0xaa, 0xda, 0xf2, 0xaa, 0xd4, 0x3a, 0x41,
	0xbb, 0x06, 0x16, 0x7a, 0xe6, 0x81, 0x85, 0x9f, 0x6e, 0x60, 0xcf, 0x7f, 0x58, 0x07, 0x67, 0xe1,
	0x19, 0x78, 0xc2, 0x8d, 0xb3, 0xfd, 0xa8, 0xc2, 0x59, 0x3e, 0xe7, 0x8e, 0xe9, 0x3d, 0x00, 0x8f,
	0x2d, 0xe1, 0x4a, 0xd5, 0x30, 0x25, 0x73, 0xe3, 0x96, 0x85, 0xcd, 0x82, 0x66, 0xc8, 0xf7, 0x54,
	0xdd, 0x49, 0x91, 0x81, 0xa0, 0xc0, 0xd3, 0x05, 0x75, 0xe1, 0xc3, 0x3a, 0x78, 0x1e, 0x9e, 0x87,
	0xa3, 0x0d, 0x47, 0x1c, 0xf1, 0xc4, 0x79, 0xae, 0xfc, 0xa1, 0x81, 0x89, 0xd1, 0x3f, 0x0e, 0x41,
	0x26, 0x5f, 0xb3, 0x8d, 0x19, 0x6c, 0xda, 0x73, 0xfa, 0x8a, 0x41, 0x23, 0xb9, 0x0d, 0x7b, 0xa5,
	0x9a, 0x6d, 0x88, 0x32, 0x36, 0x6d, 0xd1, 0xb2, 0x25, 0xdb, 0x89, 0xa6, 0x27, 0x9b, 0x4e, 0xef,
	0x7d, 0x47, 0xa7, 0x89, 0x09, 0x75, 0xc5, 0xbd, 0x25, 0x17, 0x89, 0x96, 0x90, 0x94, 0x5c, 0xd3,
	0xf4, 0x11, 0x15, 0x21, 0xd3, 0xb4, 0xeb, 0x5b, 0xbd, 0x78, 0x76, 0x64, 0x57, 0x92, 0x5f, 0xf2,
	0xee, 0x64, 0xa1, 0xc7, 0x33, 0xe2, 0x2e, 0xde, 0x38, 0xec, 0xf3, 0x45, 0x57, 0xa3, 0x69, 0xce,
	0xcb, 0xf4, 0x0d, 0x7f, 0x4e, 0x33, 0x1a, 0xf3, 0x7b, 0x54, 0x2d, 0xab, 0xe6, 0x9e, 0xcf, 0xee,
	0xa6, 0xd5, 0x39, 0xda, 0x3a, 0xfa, 0xab, 0x08, 0x1c, 0xcc, 0xb7, 0x5c, 0xf4, 0x45, 0x6c, 0x4b,
	0xaa, 0x66, 0xa1, 0x37, 0x61, 0x9c, 0x20, 0x00, 0xef, 0x56, 0x02, 0x07, 0xc8, 0xb6, 0xc7, 0xb7,
	0x36, 0x7b, 0x5a, 0x51, 0x43, 0x23, 0x19, 0x01, 0x01, 0x92, 0x1e, 0xf7, 0xd6, 0xfa, 0x11, 0x1c,
	0xaa, 0x59, 0x58, 0xa4, 0xf6, 0x9d, 0x8b, 0xd4, 0x73, 0x13, 0xa6, 0xf3, 0x32, 0x10, 0x70, 0x53,
	0xaa, 0x54, 0xed, 0x8d, 0xd9, 0x0e, 0xa1, 0xbf, 0x66, 0x61, 0x12, 0xad, 0xe3, 0xd6, 0x35, 0xf6,
	0xe3, 0xc6, 0xc9, 0xa8, 0x92, 0x35, 0xb6, 0xe8, 0x48, 0xe3, 0xd9, 0xf1, 0x80, 0x8d, 0xd6, 0xc0,
	0xd2, 0x33, 0x54, 0x85, 0xee, 0x0a, 0x6b, 0xb6, 0xc3, 0x3b, 0x28, 0xce, 0x33, 0xba, 0x0a, 0x13,
	0x26, 0x56, 0x54, 0x93, 0x04, 0x46, 0x2e, 0xd4, 0x4e, 0xba, 0x29, 0x4f, 0x7f, 0x55, 0x07, 0x34,
	0xd9, 0x46, 0xcd, 0x30, 0xfb, 0x80, 0x9e, 0xb4, 0x88, 0x19, 0x62, 0x80, 0xdb, 0xf4, 0x1e, 0x00,
	0xb3, 0x40, 0x88, 0x7b, 0x8a, 0xb7, 0x4c, 0x0d, 0xe5, 0x21, 0xd3, 0xb0, 0xe3, 0xde, 0xa6, 0x6c,
	0xd7, 0x3e, 0x23, 0x04, 0x42, 0xaf, 0x27, 0xef, 0x5e, 0xad, 0x6e, 0x1a, 0x19, 0x84, 0x3d, 0xad,
	0xab, 0x84, 0xc2, 0x13, 0x7c, 0x16, 0xf6, 0xc1, 0x84, 0xe0, 0xca, 0x73, 0xb7, 0x84, 0x79, 0x04,
	0xa6, 0x0a, 0xe7, 0xe1, 0x40, 0xcb, 0x6c, 0x88, 0xf2, 0xaa, 0xa1, 0xca, 0x18, 0xf5, 0x6e, 0xd7,
	0x41, 0xf8, 0x71, 0x1d, 0x84, 0x76, 0xea, 0x20, 0x9c, 0xe3, 0x27, 0x0b, 0xe7, 0x60, 0xbf, 0x7f,
	0x8c, 0x7e, 0xb9, 0xce, 0xc7, 0x75, 0x10, 0x25, 0x72, 0x97, 0xf8, 0x17, 0xaf, 0x47, 0x62, 0x21,
	0x26, 0x7c, 0x3d, 0x12, 0x8b, 0x32, 0x9d, 0xa3, 0xbf, 0x8f, 0xc2, 0x81, 0x05, 0x8a, 0xc5, 0x0a,
	0x92, 0x85, 0x95, 0xc6, 0xc1, 0x47, 0xff, 0x0f, 0x26, 0xee, 0x12, 0x57, 0xee, 0x33, 0x3d, 0x37,
	0xf1, 0x6c, 0x6e, 0xbf, 0x73, 0xb3, 0xc7, 0x4d, 0x50, 0x88, 0x3c, 0xae, 0x03, 0x20, 0xc4, 0xef,
	0x5a, 0x4d, 0xeb, 0x32, 0xec, 0x93, 0x9d, 0x5c, 0xe3, 0x73, 0xe1, 0x9c, 0xa0, 0xcc, 0xbe, 0x47,
	0xb3, 0x4d, 0x22, 0x75, 0xed, 0x33, 0x72, 0xa0, 0x0f, 0x59, 0x70, 0xd8, 0xf6, 0x72, 0x87, 0x58,
	0xb3, 0xb0, 0x29, 0x2e, 0xbb, 0xb9, 0xc3, 0xdd, 0x94, 0x53, 0xfb, 0xb9, 0xda, 0x33, 0xbf, 0xb9,
	0xfe, 0x06, 0xed, 0x76, 0x02, 0x68, 0x1a, 0x26, 0x74, 0xc3, 0x37, 0xa8, 0xe8, 0xbe, 0xdb, 0x3f,
	0xae, 0x1b, 0xcd, 0x78, 0x17, 0xe1, 0x88, 0xa4, 0xdd, 0x97, 0x36, 0x2c, 0x11, 0xeb, 0xf4, 0x2e,
	0x6f, 0x59, 0x80, 0xce, 0x7d, 0x0d, 0x0d, 0x3b, 0x9a, 0x25, 0xaa, 0x78, 0xdd, 0x37, 0xd3, 0x3f,
	0x85, 0xa7, 0x5a, 0x8d, 0xee, 0x9e, 0xf7, 0xae, 0x7d, 0x2d, 0x9f, 0xf0, 0x5b, 0x0e, 0xce, 0x3f,
	0xfa, 0x13, 0x00, 0x8f, 0x55, 0x24, 0x4d, 0x95, 0x55, 0xa3, 0x66, 0x39, 0x93, 0x5c, 0x51, 0x6d,
	0xb5, 0x4c, 0xb7, 0x34, 0x1b, 0x3b, 0x40, 0x8a, 0xb9, 0xb0, 0xb5, 0xb9, 0xb7, 0x85, 0x8f, 0x37,
	0xc1, 0xe7, 0x75, 0x00, 0x7c, 0x49, 0x67, 0xb8, 0x21, 0x4b, 0xa6, 0xfd, 0xb5, 0x86, 0x64, 0xe1,
	0x2c, 0x64, 0x1a, 0x43, 0xf2, 0xb6, 0x7e, 0xdf, 0x76, 0x1d, 0x44, 0x1f, 0xd7, 0x41, 0x64, 0xa7,
	0x0e, 0xa2, 0x53, 0xbc, 0xb3, 0xf9, 0x09, 0x98, 0xfb, 0xa7, 0xb3, 0xb0, 0xe7, 0x9a, 0x66, 0x2c,
	0x4b, 0xda, 0x62, 0x15, 0xcb, 0xf4, 0xae, 0xb8, 0x02, 0xbb, 0x14, 0xa3, 0x22, 0xa9, 0xba, 0xe5,
	0x82, 0xb2, 0x33, 0x7e, 0x50, 0xf6, 0xf3, 0x50, 0x33, 0x08, 0xc6, 0x07, 0xc3, 0x3c, 0x1d, 0x34,
	0x07, 0x3b, 0x4d, 0xa3, 0x66, 0x63, 0xeb, 0x40, 0x28, 0xb6, 0x7f, 0x6b, 0x33, 0x4a, 0xc5, 0x29,
	0xf4, 0x7c, 0x1f, 0x84, 0x99, 0x07, 0x21, 0xc1, 0x35, 0x80, 0xee, 0xc0, 0xde, 0xbb, 0x8d, 0xa3,
	0x44, 0xb9, 0x89, 0x9b, 0x00, 0x33, 0x4f, 0x3a, 0x7d, 0x41, 0xb6, 0x22, 0xf4, 0x34, 0x0d, 0x91,
	0x4b, 0x11, 0xbd, 0x05, 0x91, 0xa4, 0xac, 0x91, 0xfb, 0xcd, 0x72, 0x39, 0x98, 0x8a, 0x2d, 0x36,
	0x7a, 0xb0, 0x88, 0x99, 0x80, 0xea, 0x86, 0xd0, 0xd7, 0x68, 0x59, 0x70, 0x6d, 0xa1, 0x35, 0x38,
	0x64, 0xe2, 0xb7, 0x6b, 0xd8, 0xb2, 0x5d, 0x18, 0x69, 0x89, 0xb6, 0x21, 0x4a, 0x8a, 0xc2, 0x76,
	0x52, 0x2f, 0x2f, 0x04, 0xbc, 0x38, 0x48, 0xf2, 0x35, 0x49, 0x57, 0xab, 0x35, 0x8d, 0xae, 0xe4,
	0x4d, 0x4a, 0xdd, 0xa8, 0xd3, 0x81, 0xc6, 0x9c, 0xc7, 0x7c, 0x73, 0xde, 0xef, 0x3a, 0x70, 0x54,
	0xad, 0x25, 0x23, 0xaf, 0x28, 0x68, 0x9d, 0x92, 0x95, 0xaa, 0xa1, 0x5b, 0x38, 0xe8, 0xb8, 0xeb,
	0xb0, 0x1c, 0x0f, 0x78, 0x1e, 0x5a, 0x3c, 0xdf, 0x84, 0xc7, 0xda, 0x8c, 0xd8, 0x41, 0xcd, 0x6c,
	0x1f, 0xdd, 0x4a, 0xed, 0xcd, 0x0d, 0x05, 0xc7, 0x21, 0x50, 0x1d, 0xf4, 0x63, 0x38, 0xd2, 0x6e,
	0x28, 0xae, 0xc5, 0xd8, 0x3e, 0x16, 0x87, 0x77, 0x05, 0xe8, 0x9a, 0x7c, 0x0d, 0xf6, 0xd8, 0x9a,
	0xe5, 0x5c, 0x20, 0x14, 0x32, 0xb1, 0xdd, 0x74, 0x47, 0x9d, 0x0b, 0x4c, 0x4a, 0xd1, 0xb8, 0xaf,
	0x5b, 0xb6, 0x89, 0xa5, 0xca, 0x92, 0x66, 0x39, 0x57, 0x27, 0xdd, 0x47, 0x49, 0xdb, 0x7d, 0x74,
	0xf0, 0xd6, 0xab, 0x30, 0x42, 0xd9, 0x0b, 0xa4, 0x60, 0xea, 0x85, 0xfd, 0xb6, 0xa5, 0xcb, 0x09,
	0x67, 0x0d, 0x8b, 0x52, 0x15, 0x81, 0x2a, 0xa2, 0x22, 0x4c, 0x2e, 0xd7, 0x56, 0x56, 0xb0, 0xe9,
	0xee, 0x24, 0x36, 0x41, 0xc3, 0x39, 0x15, 0xb0, 0x54, 0xa0, 0x32, 0xbe, 0xfd, 0x9c, 0x70, 0xb4,
	0x9c, 0x1b, 0x0b, 0xbd, 0x04, 0xe3, 0xb2, 0x61, 0x5a, 0x9e, 0x8d, 0x24, 0xb5, 0x71, 0x2c, 0x60,
	0x63, 0xc6, 0x30, 0x2d, 0x47, 0x5e, 0x80, 0x72, 0xe3, 0x37, 0x7a, 0x19, 0x46, 0xab, 0x84, 0x2b,
	0xb3, 0xbd, 0x74, 0x0c, 0x67, 0xf7, 0x1b, 0x43, 0x83, 0x54, 0x0b, 0x8e, 0x0e, 0xba, 0x04, 0xc3,
	0x77, 0xef, 0xdb, 0x2c, 0x73, 0x80, 0x73, 0xd3, 0xb9, 0xb5, 0x49, 0x64, 0x05, 0xf2, 0x0f, 0x9a,
	0x80, 0xb1, 0xfb, 0xd2, 0x8a, 0xc3, 0xfc, 0x10, 0x8d, 0x76, 0x28, 0xa0, 0xfc, 0xba, 0x44, 0xd5,
	0x84, 0xae, 0xfb, 0xce, 0x0f, 0x54, 0x86, 0x83, 0x2e, 0xce, 0x10, 0x4d, 0x87, 0xe2, 0x8b, 0x4e,
	0xdc, 0xfd, 0x4f, 0xbe, 0x90, 0xf7, 0x28, 0x0d, 0x08, 0xfd, 0xca, 0xee, 0x0e, 0x74, 0x1a, 0x26,
	0x24, 0x45, 0x11, 0x35, 0xc3, 0x81, 0x23, 0xec, 0x00, 0x65, 0x7f, 0x71, 0x49, 0x51, 0xe6, 0xdd,
	0x26, 0xf4, 0x26, 0x21, 0xd5, 0x0d, 0x06, 0xec, 0x81, 0xb3, 0x41, 0x1a, 0xc8, 0xbe, 0x9b, 0x20,
	0xc0, 0x9b, 0x09, 0xc9, 0x6e, 0x34, 0xb8, 0x00, 0xed, 0x57, 0x11, 0x98, 0x74, 0x59, 0x03, 0x36,
	0x4d, 0xc3, 0xb4, 0xd8, 0x21, 0x3a, 0xbb, 0x3f, 0xd8, 0xcf, 0x6e, 0x6b, 0x0a, 0x4f, 0xcf, 0x50,
	0xfd, 0x12, 0x55, 0x2f, 0xe9, 0xb6, 0xb9, 0x51, 0xf8, 0x3b, 0x02, 0x90, 0x40, 0x5b, 0xda, 0x91,
	0xf8, 0x00, 0x74, 0x8f, 0x76, 0x8d, 0x47, 0xd9, 0x7f, 0x8e, 0x8c, 0x85, 0xe9, 0x19, 0xfa, 0xc0,
	0xcb, 0xed, 0x3d, 0x1f, 0x80, 0xf8, 0x78, 0x93, 0x96, 0xec, 0x7c, 0xf2, 0xeb, 0xf0, 0xaf, 0xc1,
	0xc3, 0x47, 0x60, 0x1b, 0xa0, 0xbf, 0x05, 0x5f, 0xd6, 0xc1, 0x5f, 0x83, 0xd9, 0xa5, 0xa5, 0x05,
	0x8e, 0x3a, 0xe2, 0x64, 0x43, 0xc1, 0xdc, 0x9a, 0xa4, 0xd5, 0x30, 0x97, 0xe3, 0x27, 0xf9, 0x29,
	0xce, 0x30, 0xb9, 0x65, 0x6c, 0xdf, 0xc7, 0x58, 0xe7, 0x72, 0x99, 0x0c, 0x27, 0xe9, 0x0a, 0x37,
	0x35, 0x3d, 0x9d, 0xe6, 0x4a, 0xe5, 0x34, 0x77, 0x9b, 0xca, 0x4d, 0x72, 0x57, 0xb8, 0xc9, 0xf5,
	0x75, 0x22, 0x29, 0x69, 0x1a, 0x37, 0x99, 0xc9, 0x5c, 0x98, 0x9c, 0x9e, 0xe6, 0x70, 0xc3, 0x9e,
	0xc5, 0x73, 0x53, 0xdc, 0x15, 0x6e, 0xaa, 0x29, 0x33, 0x95, 0xc9, 0x5c, 0x98, 0x6a, 0x95, 0x49,
	0x73, 0x77, 0x8c, 0x1a, 0x27, 0x4b, 0x3a, 0x27, 0x69, 0x96, 0xc1, 0x59, 0x55, 0x2c, 0xab, 0x2b,
	0x1b, 0x9c, 0xa4, 0x73, 0x78, 0x5d, 0x92, 0x6d, 0x9f, 0x28, 0xa7, 0xa9, 0xf7, 0x30, 0x37, 0x99,
	0x99, 0x4c, 0x93, 0xa1, 0x0c, 0x3c, 0x7c, 0x04, 0x18, 0xd4, 0xb3, 0x53, 0x07, 0xd0, 0x19, 0xc1,
	0x8c, 0xa1, 0x60, 0xd2, 0x01, 0x1f, 0x3e, 0x02, 0x9d, 0x28, 0xf2, 0x51, 0x1d, 0x74, 0x90, 0xc7,
	0xce, 0x87, 0x8f, 0x40, 0x28, 0x46, 0x47, 0x9f, 0x7f, 0xf8, 0x08, 0x5c, 0x19, 0x79, 0xf9, 0xcb,
	0x3a, 0x78, 0x71, 0xd1, 0x36, 0x09, 0xf9, 0x32, 0x31, 0x59, 0x3f, 0x82, 0x5e, 0xf5, 0xb2, 0xeb,
	0xc9, 0xcb, 0x3d, 0x3c, 0x57, 0xb3, 0x6a, 0x92, 0xa6, 0x6d, 0x70, 0x12, 0xb7, 0x6a, 0x57, 0x34,
	0x1a, 0x02, 0xb1, 0x72, 0xf2, 0xe1, 0x23, 0x70, 0x6c, 0x64, 0x78, 0xa7, 0x0e, 0xfa, 0x1d, 0xc7,
	0x82, 0xab, 0xc1, 0x15, 0x0c, 0x65, 0xa3, 0x11, 0xc1, 0x08, 0x89, 0x20, 0xe2, 0x7b, 0xdc, 0x26,
	0x70, 0x2b, 0x21, 0xfb, 0x16, 0x17, 0x5d, 0x81, 0xc7, 0xbd, 0x82, 0x87, 0x82, 0x57, 0xa4, 0x9a,
	0x66, 0x3b, 0xbb, 0x86, 0x32, 0x4e, 0x8b, 0x3d, 0x4d, 0xf7, 0x2e, 0xeb, 0x8a, 0x14, 0x1d, 0x09,
	0xaa, 0x4a, 0xa8, 0xa5, 0x85, 0x7e, 0x08, 0x87, 0x2b, 0xd2, 0xba, 0xd8, 0x9a, 0xb6, 0x45, 0x4b,
	0x7d, 0x07, 0xb3, 0xc3, 0x2d, 0x05, 0x1c, 0xf6, 0x2d, 0x61, 0xa0, 0x22, 0xad, 0x0b, 0xfe, 0x44,
	0xbd, 0xa8, 0xbe, 0x83, 0x77, 0xc1, 0xbc, 0x53, 0x07, 0x87, 0x79, 0x3f, 0x0b, 0x20, 0x6b, 0xf6,
	0x19, 0x91, 0x35, 0xb1, 0xef, 0xc7, 0xd6, 0xb8, 0x1d, 0xb6, 0x3e, 0xf9, 0x2c, 0xd8, 0x7a, 0xb6,
	0xa3, 0x0d, 0xba, 0x7e, 0x1b, 0x0e, 0x39, 0x79, 0x57, 0x24, 0x67, 0x4a, 0xf1, 0xf9, 0x7a, 0xfe,
	0xc9, 0xbe, 0xda, 0x51, 0x8e, 0x42, 0x97, 0x8b, 0xf6, 0x66, 0x3b, 0x84, 0x81, 0x6a, 0x3b, 0x4e,
	0x62, 0xc0, 0x7e, 0x8a, 0x0f, 0x55, 0x85, 0x6c, 0x3c, 0x8f, 0xa1, 0xb3, 0xc7, 0x0e, 0x90, 0x86,
	0xb9, 0xad, 0xcd, 0x76, 0xba, 0x3e, 0x60, 0x89, 0x48, 0xf7, 0x5c, 0x4b, 0x2f, 0x7a, 0x13, 0x26,
	0x4c, 0xc9, 0xc6, 0xa2, 0xa6, 0x56, 0x54, 0x1b, 0x9b, 0xec, 0xc8, 0x01, 0x3c, 0x1d, 0xdb, 0xda,
	0x6c, 0x51, 0xf2, 0xb9, 0x88, 0x93, 0xf6, 0x79, 0xa7, 0x19, 0xfd, 0x7f, 0x78, 0xd2, 0x2f, 0x26,
	0x4a, 0x9a, 0x66, 0xdc, 0xc7, 0x8a, 0x5b, 0x57, 0xc6, 0x16, 0x7b, 0xfc, 0x00, 0xce, 0x46, 0xb6,
	0x36, 0x93, 0x6a, 0xd5, 0xd5, 0x11, 0x2d, 0x6c, 0x37, 0xbc, 0x45, 0x84, 0x11, 0x9f, 0xb7, 0xbc,
	0x63, 0x7c, 0xc1, 0xb5, 0x8d, 0xae, 0x11, 0x3a, 0x6c, 0x9b, 0x1b, 0xde, 0xd5, 0x79, 0x82, 0x2e,
	0x59, 0x2a, 0xe0, 0x4b, 0x20, 0x22, 0xce, 0x52, 0xf9, 0x89, 0x9c, 0xd9, 0x6c, 0x46, 0x7f, 0xb4,
	0x37, 0xc7, 0x3a, 0xf3, 0x2c, 0x1c, 0x2b, 0xf9, 0xf1, 0x26, 0x20, 0xde, 0xc8, 0x7e, 0x60, 0xf7,
	0x24, 0x5b, 0xbf, 0xd8, 0x97, 0x7d, 0x3c, 0x77, 0x80, 0x09, 0xbc, 0xf8, 0x8d, 0xd8, 0x07, 0xbb,
	0x37, 0xff, 0x40, 0xd7, 0x20, 0x01, 0x49, 0xa2, 0xaa, 0xdb, 0xd8, 0x94, 0x71, 0xd5, 0x66, 0xcf,
	0xd2, 0xf1, 0x8f, 0x06, 0xdc, 0x2f, 0x69, 0xd6, 0x9c, 0x27, 0xe2, 0x5d, 0x87, 0x09, 0xdb, 0xd7,
	0x88, 0x66, 0x60, 0x9f, 0x6e, 0x88, 0xad, 0xc5, 0x0d, 0xf6, 0xfc, 0xbe, 0x35, 0x06, 0x46, 0x37,
	0x02, 0xc5, 0x04, 0x09, 0x06, 0xea, 0x36, 0xec, 0x18, 0xb5, 0x30, 0xb1, 0xdf, 0x72, 0xb4, 0x2d,
	0x1b, 0xb9, 0x29, 0x00, 0x08, 0x01, 0x83, 0xe8, 0x3c, 0x4c, 0xa8, 0x8a, 0x86, 0x1b, 0xc5, 0x75,
	0x8e, 0x66, 0xce, 0xc8, 0x57, 0x75, 0xd0, 0x21, 0xc4, 0x49, 0x8f, 0x5b, 0x3f, 0x47, 0x69, 0xd8,
	0xdf, 0x48, 0xd6, 0xba, 0x25, 0xba, 0x6f, 0x1c, 0xd8, 0x51, 0x9a, 0xa4, 0xfb, 0xbc, 0x24, 0xad,
	0x5b, 0x82, 0xd3, 0x81, 0x66, 0x60, 0x8f, 0x97, 0xd4, 0xdd, 0x4a, 0xf4, 0x0b, 0x7b, 0x8f, 0xbe,
	0x40, 0xaf, 0x87, 0xd9, 0x90, 0x90, 0x74, 0x75, 0xdc, 0xea, 0xf6, 0x04, 0x8c, 0x5b, 0xd8, 0x5c,
	0xc3, 0xa6, 0xa8, 0x4b, 0x15, 0xcc, 0xf2, 0xb4, 0xde, 0xd3, 0xb3, 0xed, 0x2d, 0xa7, 0x19, 0x66,
	0xff, 0xfc, 0xd5, 0xd9, 0x90, 0x00, 0x1d, 0xa1, 0x1b, 0x52, 0x05, 0xa3, 0x57, 0x20, 0x92, 0xaa,
	0x55, 0xac, 0x2b, 0xa2, 0x5f, 0xf3, 0xc2, 0x1e, 0x9a, 0x8c, 0x23, 0xbb, 0xd8, 0xd4, 0x7f, 0x15,
	0x26, 0xaa, 0x92, 0x65, 0x89, 0xf6, 0xaa, 0x69, 0xd4, 0xca, 0xab, 0x6c, 0xfa, 0x00, 0x51, 0xc7,
	0x89, 0xc6, 0x92, 0xa3, 0x80, 0x26, 0xe0, 0x00, 0x99, 0xa0, 0x35, 0x43, 0xb3, 0xb1, 0x69, 0x4a,
	0x62, 0x45, 0xd2, 0xa5, 0x32, 0x56, 0xd8, 0xcf, 0xbb, 0xe8, 0x54, 0x21, 0x45, 0xb7, 0x6e, 0xbb,
	0x7d, 0xaf, 0x39, 0x5d, 0xe8, 0x0d, 0x18, 0x27, 0x2a, 0x1e, 0x73, 0xfd, 0xa2, 0xeb, 0x00, 0x7b,
	0x9e, 0xdd, 0xda, 0x84, 0x4d, 0x25, 0x3f, 0x03, 0x25, 0xcd, 0x45, 0x97, 0xd0, 0x9e, 0x80, 0xdd,
	0x8d, 0x8a, 0x23, 0xfb, 0xa5, 0x13, 0x41, 0xcc, 0xab, 0x35, 0xa2, 0x19, 0x18, 0x75, 0xea, 0xa9,
	0xff, 0xd6, 0x45, 0xf1, 0x33, 0x7f, 0x40, 0x0e, 0xe0, 0x94, 0x53, 0x1d, 0x5d, 0xe2, 0x82, 0xbe,
	0x82, 0xa3, 0xf3, 0xfc, 0xef, 0x5d, 0xb4, 0x9c, 0x19, 0x23, 0x2d, 0x74, 0x3a, 0x67, 0x61, 0xcc,
	0x7b, 0x37, 0xc7, 0xfe, 0x87, 0x33, 0xae, 0xfd, 0xbc, 0x34, 0x5e, 0xe4, 0xa5, 0x8b, 0xba, 0x45,
	0xc8, 0xae, 0xd0, 0xa5, 0x38, 0x3f, 0xd0, 0x4f, 0x76, 0x97, 0x81, 0xff, 0xb3, 0xeb, 0x69, 0xea,
	0xc0, 0x05, 0x42, 0xb2, 0x02, 0xb5, 0xe0, 0x45, 0x7a, 0xd2, 0xbc, 0xca, 0x2c, 0x09, 0xf6, 0x77,
	0x4e, 0x41, 0x85, 0x7f, 0xc2, 0x51, 0x6b, 0x29, 0x55, 0x0b, 0x09, 0xc9, 0xd7, 0x82, 0xae, 0xc2,
	0x04, 0xcd, 0x45, 0xde, 0xba, 0xfe, 0x57, 0x17, 0x65, 0x7d, 0xa3, 0x7b, 0xbc, 0x18, 0xe2, 0xfc,
	0x2f, 0x86, 0x88, 0xa2, 0xb7, 0x88, 0x35, 0xd8, 0xdf, 0xfa, 0xc6, 0x95, 0xdc, 0x11, 0x16, 0xfb,
	0xfb, 0x83, 0x6c, 0x93, 0x73, 0x5b, 0x9b, 0x68, 0xb7, 0x72, 0x30, 0x27, 0x46, 0x84, 0x3e, 0x57,
	0xc8, 0xb9, 0x11, 0x16, 0xb1, 0x6d, 0xa1, 0x0a, 0x1c, 0xd2, 0x0c, 0x49, 0x59, 0x96, 0x34, 0x49,
	0x97, 0xe9, 0xdd, 0x56, 0x36, 0x4c, 0xd5, 0x5e, 0xad, 0xb0, 0xff, 0xdd, 0x7e, 0xbb, 0xb8, 0xef,
	0x9b, 0xd3, 0xf3, 0x3e, 0xad, 0xbc, 0xa7, 0xd4, 0x00, 0x06, 0xc2, 0xa0, 0xd6, 0xae, 0x1f, 0x3d,
	0x07, 0x93, 0x8d, 0x33, 0x43, 0xb7, 0xeb, 0xff, 0x38, 0xdb, 0x35, 0xe1, 0xb5, 0x92, 0x79, 0x1d,
	0x79, 0x15, 0xf6, 0xed, 0x22, 0x08, 0x88, 0x81, 0xe1, 0x7b, 0xd8, 0x79, 0x19, 0x9a, 0x14, 0xc8,
	0x4f, 0x34, 0x00, 0xa3, 0x14, 0xcd, 0xd3, 0x72, 0x64, 0xb7, 0xe0, 0x3c, 0xbc, 0x14, 0xba, 0x0c,
	0x0a, 0xe7, 0x60, 0x4f, 0xb3, 0xc2, 0x44, 0x69, 0xec, 0xc0, 0x76, 0x1d, 0x9c, 0x7a, 0x5c, 0x07,
	0xa9, 0x9d, 0x3a, 0x88, 0xe5, 0x26, 0xf8, 0xec, 0x24, 0x9f, 0x9d, 0x2e, 0x8c, 0xc3, 0xc1, 0xd6,
	0x54, 0xe9, 0x2f, 0x47, 0x9d, 0x7f, 0x5c, 0x07, 0xe7, 0x76, 0xea, 0x20, 0x9a, 0x9b, 0xe6, 0x27,
	0x33, 0x85, 0x1c, 0x1c, 0x70, 0x93, 0x8d, 0x0b, 0x42, 0x5d, 0xd1, 0xe3, 0xdb, 0x75, 0xf0, 0xc2,
	0x47, 0x75, 0x40, 0x2e, 0xc1, 0xf1, 0x9d, 0x3a, 0x88, 0x4f, 0xe6, 0xf8, 0xc9, 0x49, 0x7e, 0x72,
	0x8a, 0x9f, 0xbc, 0xe4, 0xbc, 0x84, 0xb9, 0x1e, 0x89, 0xa5, 0x98, 0x53, 0xd7, 0x23, 0xb1, 0x73,
	0xcc, 0xf9, 0xeb, 0x91, 0xd8, 0x38, 0xf3, 0xc2, 0xe8, 0x6f, 0x06, 0x61, 0xcf, 0x8c, 0x89, 0x25,
	0x1b, 0x37, 0xaa, 0x5a, 0x6c, 0xa0, 0xaa, 0xd5, 0x2c, 0x58, 0xbd, 0xf2, 0x8d, 0x0a, 0x56, 0x31,
	0xaf, 0x60, 0xd5, 0xa8, 0x52, 0x7d, 0xfb, 0xa5, 0xa4, 0xb7, 0x0e, 0xb1, 0x94, 0xd4, 0xbe, 0x68,
	0xb4, 0x7c, 0x98, 0x45, 0xa3, 0x3d, 0xca, 0x43, 0xd3, 0x4f, 0x2c, 0x0f, 0xed, 0x59, 0x08, 0x7a,
	0xf9, 0xc9, 0x85, 0xa0, 0xef, 0xac, 0xe4, 0xf3, 0x3d, 0xaf, 0xd8, 0x1c, 0x55, 0x5e, 0xf6, 0xac,
	0xbc, 0x48, 0x4f, 0x51, 0x78, 0x69, 0xcd, 0x32, 0xbb, 0x0b, 0x2f, 0x87, 0x4b, 0xd7, 0xa7, 0x9e,
	0x40, 0xd7, 0x0f, 0x9f, 0xa3, 0xbf, 0x71, 0x68, 0x1c, 0x3d, 0xc8, 0xce, 0xc5, 0x43, 0x64, 0xe7,
	0x6d, 0x79, 0x39, 0x7e, 0x7a, 0x92, 0x3c, 0xd4, 0x9e, 0x24, 0xb7, 0xa5, 0xc6, 0x0b, 0x4f, 0x41,
	0x8d, 0x7b, 0x03, 0xd4, 0xb8, 0x95, 0x10, 0xbf, 0x7d, 0x18, 0x84, 0x98, 0x09, 0x12, 0xe2, 0xef,
	0x86, 0x06, 0x9f, 0x6e, 0xc7, 0x85, 0x9e, 0x8d, 0x05, 0x55, 0xbe, 0x1d, 0x66, 0xbd, 0x17, 0x95,
	0x3e, 0x14, 0xd6, 0xf9, 0x93, 0x43, 0x63, 0x9d, 0x6d, 0xf8, 0xe6, 0x95, 0x6f, 0x42, 0x0b, 0x77,
	0x13, 0xc2, 0xd3, 0x6d, 0x08, 0x61, 0x80, 0x00, 0xa6, 0xf7, 0x26, 0x80, 0x6d, 0x09, 0xdf, 0xf4,
	0xc1, 0x09, 0x5f, 0x80, 0xea, 0x3d, 0x33, 0x18, 0x7d, 0xe9, 0xa7, 0x7f, 0xff, 0x4a, 0xe0, 0x0d,
	0xe6, 0xef, 0x5e, 0x99, 0x9b, 0x98, 0xe2, 0xb3, 0x7c, 0x8e, 0x9f, 0xe2, 0xa7, 0xf9, 0x89, 0xcb,
	0xfc, 0xc4, 0x34, 0x9f, 0xbb, 0xcc, 0x5f, 0xe2, 0x27, 0x5e, 0xe4, 0x5f, 0xe4, 0x2f, 0xf3, 0x13,
	0x59, 0x7e, 0x22, 0xc7, 0x67, 0x33, 0x7c, 0xf6, 0x32, 0x9f, 0x9d, 0xe0, 0xb3, 0x59, 0x3e, 0x97,
	0xe3, 0xb3, 0x39, 0x3e, 0x97, 0xe1, 0x73, 0x53, 0x7c, 0xf6, 0x12, 0x9f, 0x7d, 0x91, 0xcf, 0x4e,
	0xf1, 0xb9, 0x2c, 0x9f, 0x9b, 0x2c, 0x3c, 0xb7, 0x0b, 0xeb, 0xa2, 0x77, 0xbf, 0x06, 0x81, 0xb6,
	0x42, 0x76, 0x2f, 0xa4, 0x7b, 0xec, 0xdd, 0xaf, 0x41, 0xfb, 0xae, 0x42, 0x66, 0x0f, 0xc4, 0xcb,
	0xbe, 0xfb, 0x35, 0x68, 0xdb, 0x33, 0xba, 0x33, 0x08, 0x7b, 0x05, 0x5c, 0xd5, 0x24, 0xf9, 0x08,
	0xd7, 0x1e, 0xe1, 0xda, 0x23, 0x5c, 0x7b, 0x84, 0x6b, 0x0f, 0x84, 0x6b, 0x97, 0xdb, 0xe3, 0xda,
	0x2b, 0xfb, 0x99, 0x0d, 0xa4, 0x99, 0x23, 0x60, 0x7b, 0x04, 0x6c, 0xff, 0x6f, 0x03, 0xdb, 0x6f,
	0xad, 0xc8, 0x7f, 0x04, 0x6f, 0x03, 0xf0, 0xf6, 0x50, 0xde, 0x7a, 0x1c, 0x81, 0xdc, 0xef, 0x2b,
	0xc8, 0xfd, 0x57, 0x16, 0xc6, 0xaf, 0x61, 0xfb, 0x08, 0xe0, 0x1e, 0x01, 0xdc, 0xa3, 0x6f, 0xf5,
	0x8e, 0x10, 0xf2, 0x77, 0x82, 0x90, 0x7f, 0xd6, 0x1e, 0x21, 0x4f, 0xef, 0xfb, 0xc9, 0x5d, 0x33,
	0x47, 0x1d, 0xa1, 0xe3, 0x23, 0x74, 0xfc, 0xbd, 0x44, 0xc7, 0xf9, 0xa7, 0x41, 0xc7, 0xdf, 0xb8,
	0xe0, 0x7b, 0x84, 0x70, 0xff, 0x80, 0x0b, 0xb8, 0xdf, 0xaf, 0x0f, 0x60, 0x5e, 0x3f, 0xac, 0x0f,
	0x60, 0xbe, 0x93, 0x8f, 0x5f, 0xbe, 0x21, 0x95, 0x7c, 0x76, 0x9a, 0xf1, 0x56, 0x1b, 0x9a, 0x31,
	0x3f, 0x91, 0xe1, 0xff, 0x20, 0x99, 0xc6, 0xf8, 0xfb, 0x00, 0xf6, 0x06, 0x90, 0x1e, 0xea, 0x87,
	0xbd, 0xb7, 0xe7, 0x84, 0xa5, 0x5b, 0xf9, 0x79, 0x71, 0xb1, 0x24, 0xdc, 0x9e, 0x9b, 0x29, 0x31,
	0x1d, 0x68, 0x08, 0xa2, 0xd9, 0xa5, 0xa5, 0x05, 0x71, 0xfe, 0x66, 0xbe, 0x28, 0x16, 0xf2, 0xf3,
	0xf9, 0x1b, 0x33, 0x25, 0x81, 0x01, 0xa8, 0x17, 0xc6, 0xf3, 0x0b, 0x73, 0xe2, 0xb5, 0xfc, 0x52,
	0xe9, 0xf5, 0xfc, 0x1d, 0x26, 0x84, 0x06, 0x61, 0xdf, 0xd2, 0x4c, 0x50, 0x2e, 0x8c, 0xba, 0x61,
	0x74, 0x41, 0xb8, 0xf9, 0xc6, 0x1d, 0x26, 0x82, 0x4e, 0xc1, 0xc1, 0xf9, 0x9b, 0x33, 0xf9, 0x79,
	0xf1, 0x47, 0x97, 0x17, 0x45, 0xbf, 0x72, 0xd4, 0xf9, 0xbc, 0x7b, 0xfc, 0x17, 0x00, 0x76, 0x37,
	0xff, 0x76, 0xc1, 0x00, 0x84, 0xd4, 0xb3, 0xa3, 0xde, 0xe1, 0xc8, 0xa0, 0x7e, 0xd8, 0x4d, 0xdc,
	0x38, 0x8d, 0xc0, 0x6d, 0x3c, 0x01, 0x51, 0xa3, 0x51, 0x7c, 0x7d, 0x6e, 0x69, 0x56, 0x5c, 0xbc,
	0x31, 0xc7, 0x84, 0xdc, 0xde, 0x41, 0x18, 0x27, 0x86, 0x16, 0x5d, 0xa5, 0xb0, 0xdb, 0x9c, 0x84,
	0xdd, 0xb7, 0x8a, 0x9e, 0xa5, 0x08, 0x79, 0x5c, 0x7c, 0x2d, 0xef, 0x3e, 0x46, 0xc7, 0x3f, 0x07,
	0x90, 0x09, 0x9e, 0x58, 0x32, 0x19, 0xde, 0x0c, 0xcd, 0xde, 0x5c, 0x5c, 0x12, 0x85, 0x52, 0xbe,
	0x78, 0x87, 0xe9, 0x40, 0x67, 0xe1, 0xe9, 0x96, 0xf6, 0x85, 0xd2, 0x8d, 0xe2, 0xdc, 0x8d, 0x6b,
	0xe2, 0xed, 0x92, 0x30, 0x77, 0x75, 0x6e, 0x26, 0xbf, 0x34, 0x77, 0xf3, 0x06, 0x03, 0xd0, 0x73,
	0x90, 0x6b, 0x11, 0xf3, 0x77, 0x8b, 0x57, 0xf3, 0x73, 0xf3, 0xa5, 0x22, 0x13, 0x42, 0xe7, 0xe1,
	0x99, 0xb6, 0xc6, 0x8a, 0x37, 0x16, 0xc5, 0x62, 0x69, 0xbe, 0x74, 0xcd, 0x31, 0x17, 0x46, 0xa7,
	0xe1, 0xc9, 0xb6, 0x82, 0x79, 0x51, 0x28, 0xcd, 0xdc, 0x14, 0x8a, 0x4c, 0x04, 0x9d, 0x81, 0xa7,
	0x5a, 0x44, 0x88, 0x0d, 0xaf, 0x5b, 0xcc, 0x17, 0x8b, 0xa5, 0x22, 0x13, 0x1d, 0xaf, 0x87, 0x20,
	0xda, 0x7d, 0xca, 0xd1, 0x40, 0xf3, 0xff, 0x52, 0x17, 0x9d, 0xe3, 0xa6, 0x30, 0x1d, 0xe8, 0x18,
	0x1c, 0x2c, 0x7a, 0xdf, 0x07, 0xde, 0xc6, 0x66, 0x43, 0x87, 0x21, 0x4b, 0xd3, 0x9b, 0x6f, 0x26,
	0x06, 0xd3, 0xc6, 0x0a, 0x13, 0x42, 0x23, 0x70, 0xc8, 0x11, 0x6e, 0xa0, 0x94, 0x05, 0xac, 0x2b,
	0xaa, 0x5e, 0x66, 0xc2, 0xe8, 0x38, 0x1c, 0x0e, 0xf4, 0x39, 0x16, 0xb1, 0xc2, 0x44, 0xfc, 0xee,
	0xaf, 0xaa, 0xba, 0xa4, 0xa9, 0xef, 0x60, 0x26, 0x4a, 0x56, 0xa0, 0x19, 0x2a, 0x9e, 0xd3, 0xe9,
	0x5f, 0x01, 0x61, 0x3a, 0x89, 0xb4, 0xaf, 0xfd, 0x36, 0x6d, 0xed, 0x22, 0xc1, 0x7a, 0x36, 0x6e,
	0x18, 0x76, 0xbe, 0x5a, 0xd5, 0x54, 0x99, 0x0c, 0x84, 0x89, 0xa1, 0x61, 0xd8, 0xef, 0x75, 0x09,
	0x0d, 0x90, 0xa0, 0x30, 0xdd, 0x24, 0x28, 0xaf, 0xe3, 0x1a, 0xd6, 0xb1, 0xe9, 0xc0, 0x20, 0x72,
	0xeb, 0x33, 0x10, 0xf5, 0xc1, 0xa4, 0xd7, 0x49, 0xf3, 0x0c, 0x13, 0x2f, 0xfc, 0x29, 0x78, 0xfc,
	0x69, 0xaa, 0xe3, 0xe3, 0x4f, 0x53, 0x1d, 0xbf, 0xfd, 0x34, 0x05, 0x1e, 0xec, 0xa4, 0xc0, 0x5f,
	0xed, 0xa4, 0xc0, 0x47, 0x3b, 0x29, 0xf0, 0x78, 0x27, 0x05, 0x3e, 0xde, 0x49, 0x81, 0x4f, 0x76,
	0x52, 0xe0, 0xf3, 0x9d, 0x54, 0xc7, 0x6f, 0x77, 0x52, 0xe0, 0xbd, 0xcf, 0x52, 0x1d, 0xdb, 0x9f,
	0xa5, 0xc0, 0xe3, 0xcf, 0x52, 0x1d, 0x1f, 0x7f, 0x96, 0xea, 0x78, 0x73, 0xa1, 0x6c, 0x54, 0xef,
	0x95, 0xd3, 0xde, 0x47, 0x6a, 0xe9, 0x9a, 0x75, 0x91, 0xfe, 0x58, 0x31, 0xcc, 0xca, 0x85, 0xaa,
	0x69, 0xac, 0xa9, 0x0a, 0x36, 0x2f, 0x78, 0xdd, 0x17, 0xab, 0xcb, 0x65, 0xe3, 0x22, 0x5e, 0xb7,
	0xbd, 0xbf, 0xa4, 0xb2, 0xfb, 0x6f, 0x99, 0x2c, 0x77, 0xd2, 0xff, 0x75, 0x9e, 0xfb, 0xdf, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x6a, 0xc0, 0x58, 0x11, 0xaa, 0x46, 0x00, 0x00,
}

func (x VirtualHostType) String() string {
	s, ok := VirtualHostType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ProxyType) String() string {
	s, ok := ProxyType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x VirtualHostState) String() string {
	s, ok := VirtualHostState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CertificationState) String() string {
	s, ok := CertificationState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *JavaScriptConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JavaScriptConfigType)
	if !ok {
		that2, ok := that.(JavaScriptConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CachePrefix != that1.CachePrefix {
		return false
	}
	if !this.ScriptConfig.Equal(that1.ScriptConfig) {
		return false
	}
	if this.CustomScriptUrl != that1.CustomScriptUrl {
		return false
	}
	return true
}
func (this *DynamicReverseProxyType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DynamicReverseProxyType)
	if !ok {
		that2, ok := that.(DynamicReverseProxyType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResolveEndpointDynamically != that1.ResolveEndpointDynamically {
		return false
	}
	if this.ResolutionNetworkType != that1.ResolutionNetworkType {
		return false
	}
	if len(this.ResolutionNetwork) != len(that1.ResolutionNetwork) {
		return false
	}
	for i := range this.ResolutionNetwork {
		if !this.ResolutionNetwork[i].Equal(that1.ResolutionNetwork[i]) {
			return false
		}
	}
	if this.ConnectionTimeout != that1.ConnectionTimeout {
		return false
	}
	return true
}
func (this *CompressionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CompressionType)
	if !ok {
		that2, ok := that.(CompressionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ContentLength != that1.ContentLength {
		return false
	}
	if len(this.ContentType) != len(that1.ContentType) {
		return false
	}
	for i := range this.ContentType {
		if this.ContentType[i] != that1.ContentType[i] {
			return false
		}
	}
	if this.DisableOnEtagHeader != that1.DisableOnEtagHeader {
		return false
	}
	if this.RemoveAcceptEncodingHeader != that1.RemoveAcceptEncodingHeader {
		return false
	}
	return true
}
func (this *JavascriptChallengeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JavascriptChallengeType)
	if !ok {
		that2, ok := that.(JavascriptChallengeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.JsScriptDelay != that1.JsScriptDelay {
		return false
	}
	if this.CookieExpiry != that1.CookieExpiry {
		return false
	}
	if this.CustomPage != that1.CustomPage {
		return false
	}
	return true
}
func (this *CaptchaChallengeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CaptchaChallengeType)
	if !ok {
		that2, ok := that.(CaptchaChallengeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CookieExpiry != that1.CookieExpiry {
		return false
	}
	if this.CustomPage != that1.CustomPage {
		return false
	}
	return true
}
func (this *TemporaryUserBlockingType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TemporaryUserBlockingType)
	if !ok {
		that2, ok := that.(TemporaryUserBlockingType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CustomPage != that1.CustomPage {
		return false
	}
	return true
}
func (this *AutoCertInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AutoCertInfoType)
	if !ok {
		that2, ok := that.(AutoCertInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AutoCertState != that1.AutoCertState {
		return false
	}
	if !this.AutoCertExpiry.Equal(that1.AutoCertExpiry) {
		return false
	}
	if this.AutoCertSubject != that1.AutoCertSubject {
		return false
	}
	if this.AutoCertIssuer != that1.AutoCertIssuer {
		return false
	}
	return true
}
func (this *AuthenticationDetails) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthenticationDetails)
	if !ok {
		that2, ok := that.(AuthenticationDetails)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AuthConfig) != len(that1.AuthConfig) {
		return false
	}
	for i := range this.AuthConfig {
		if !this.AuthConfig[i].Equal(that1.AuthConfig[i]) {
			return false
		}
	}
	if that1.CookieParamsChoice == nil {
		if this.CookieParamsChoice != nil {
			return false
		}
	} else if this.CookieParamsChoice == nil {
		return false
	} else if !this.CookieParamsChoice.Equal(that1.CookieParamsChoice) {
		return false
	}
	if that1.RedirectUrlChoice == nil {
		if this.RedirectUrlChoice != nil {
			return false
		}
	} else if this.RedirectUrlChoice == nil {
		return false
	} else if !this.RedirectUrlChoice.Equal(that1.RedirectUrlChoice) {
		return false
	}
	return true
}
func (this *AuthenticationDetails_UseAuthObjectConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthenticationDetails_UseAuthObjectConfig)
	if !ok {
		that2, ok := that.(AuthenticationDetails_UseAuthObjectConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseAuthObjectConfig.Equal(that1.UseAuthObjectConfig) {
		return false
	}
	return true
}
func (this *AuthenticationDetails_CookieParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthenticationDetails_CookieParams)
	if !ok {
		that2, ok := that.(AuthenticationDetails_CookieParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CookieParams.Equal(that1.CookieParams) {
		return false
	}
	return true
}
func (this *AuthenticationDetails_RedirectUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthenticationDetails_RedirectUrl)
	if !ok {
		that2, ok := that.(AuthenticationDetails_RedirectUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RedirectUrl != that1.RedirectUrl {
		return false
	}
	return true
}
func (this *AuthenticationDetails_RedirectDynamic) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthenticationDetails_RedirectDynamic)
	if !ok {
		that2, ok := that.(AuthenticationDetails_RedirectDynamic)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RedirectDynamic.Equal(that1.RedirectDynamic) {
		return false
	}
	return true
}
func (this *PolicyBasedChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PolicyBasedChallenge)
	if !ok {
		that2, ok := that.(PolicyBasedChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.JsChallenge.Equal(that1.JsChallenge) {
		return false
	}
	if !this.CaptchaChallenge.Equal(that1.CaptchaChallenge) {
		return false
	}
	if !this.TemporaryUserBlocking.Equal(that1.TemporaryUserBlocking) {
		return false
	}
	if that1.ChallengeChoice == nil {
		if this.ChallengeChoice != nil {
			return false
		}
	} else if this.ChallengeChoice == nil {
		return false
	} else if !this.ChallengeChoice.Equal(that1.ChallengeChoice) {
		return false
	}
	if len(this.MaliciousUserMitigation) != len(that1.MaliciousUserMitigation) {
		return false
	}
	for i := range this.MaliciousUserMitigation {
		if !this.MaliciousUserMitigation[i].Equal(that1.MaliciousUserMitigation[i]) {
			return false
		}
	}
	return true
}
func (this *PolicyBasedChallenge_NoChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PolicyBasedChallenge_NoChallenge)
	if !ok {
		that2, ok := that.(PolicyBasedChallenge_NoChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoChallenge.Equal(that1.NoChallenge) {
		return false
	}
	return true
}
func (this *PolicyBasedChallenge_AlwaysEnableJsChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PolicyBasedChallenge_AlwaysEnableJsChallenge)
	if !ok {
		that2, ok := that.(PolicyBasedChallenge_AlwaysEnableJsChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AlwaysEnableJsChallenge.Equal(that1.AlwaysEnableJsChallenge) {
		return false
	}
	return true
}
func (this *PolicyBasedChallenge_AlwaysEnableCaptchaChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PolicyBasedChallenge_AlwaysEnableCaptchaChallenge)
	if !ok {
		that2, ok := that.(PolicyBasedChallenge_AlwaysEnableCaptchaChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AlwaysEnableCaptchaChallenge.Equal(that1.AlwaysEnableCaptchaChallenge) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	if !this.JavascriptInfo.Equal(that1.JavascriptInfo) {
		return false
	}
	if len(this.AdvertisePolicies) != len(that1.AdvertisePolicies) {
		return false
	}
	for i := range this.AdvertisePolicies {
		if !this.AdvertisePolicies[i].Equal(that1.AdvertisePolicies[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToAdd) != len(that1.RequestHeadersToAdd) {
		return false
	}
	for i := range this.RequestHeadersToAdd {
		if !this.RequestHeadersToAdd[i].Equal(that1.RequestHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.ResponseHeadersToAdd) != len(that1.ResponseHeadersToAdd) {
		return false
	}
	for i := range this.ResponseHeadersToAdd {
		if !this.ResponseHeadersToAdd[i].Equal(that1.ResponseHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToRemove) != len(that1.RequestHeadersToRemove) {
		return false
	}
	for i := range this.RequestHeadersToRemove {
		if this.RequestHeadersToRemove[i] != that1.RequestHeadersToRemove[i] {
			return false
		}
	}
	if len(this.ResponseHeadersToRemove) != len(that1.ResponseHeadersToRemove) {
		return false
	}
	for i := range this.ResponseHeadersToRemove {
		if this.ResponseHeadersToRemove[i] != that1.ResponseHeadersToRemove[i] {
			return false
		}
	}
	if !this.TlsParameters.Equal(that1.TlsParameters) {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.BufferPolicy.Equal(that1.BufferPolicy) {
		return false
	}
	if !this.CorsPolicy.Equal(that1.CorsPolicy) {
		return false
	}
	if this.Proxy != that1.Proxy {
		return false
	}
	if len(this.Jwt) != len(that1.Jwt) {
		return false
	}
	for i := range this.Jwt {
		if !this.Jwt[i].Equal(that1.Jwt[i]) {
			return false
		}
	}
	if !this.WafType.Equal(that1.WafType) {
		return false
	}
	if !this.DynamicReverseProxy.Equal(that1.DynamicReverseProxy) {
		return false
	}
	if this.AddLocation != that1.AddLocation {
		return false
	}
	if !this.CompressionParams.Equal(that1.CompressionParams) {
		return false
	}
	if len(this.CustomErrors) != len(that1.CustomErrors) {
		return false
	}
	for i := range this.CustomErrors {
		if this.CustomErrors[i] != that1.CustomErrors[i] {
			return false
		}
	}
	if this.DisableDefaultErrorPages != that1.DisableDefaultErrorPages {
		return false
	}
	if this.MaxRequestHeaderSize != that1.MaxRequestHeaderSize {
		return false
	}
	if that1.ChallengeType == nil {
		if this.ChallengeType != nil {
			return false
		}
	} else if this.ChallengeType == nil {
		return false
	} else if !this.ChallengeType.Equal(that1.ChallengeType) {
		return false
	}
	if len(this.UserIdentification) != len(that1.UserIdentification) {
		return false
	}
	for i := range this.UserIdentification {
		if !this.UserIdentification[i].Equal(that1.UserIdentification[i]) {
			return false
		}
	}
	if len(this.RateLimiter) != len(that1.RateLimiter) {
		return false
	}
	for i := range this.RateLimiter {
		if !this.RateLimiter[i].Equal(that1.RateLimiter[i]) {
			return false
		}
	}
	if len(this.RateLimiterAllowedPrefixes) != len(that1.RateLimiterAllowedPrefixes) {
		return false
	}
	for i := range this.RateLimiterAllowedPrefixes {
		if !this.RateLimiterAllowedPrefixes[i].Equal(that1.RateLimiterAllowedPrefixes[i]) {
			return false
		}
	}
	if !this.RetryPolicy.Equal(that1.RetryPolicy) {
		return false
	}
	if !this.TemporaryUserBlocking.Equal(that1.TemporaryUserBlocking) {
		return false
	}
	if len(this.MaliciousUserMitigation) != len(that1.MaliciousUserMitigation) {
		return false
	}
	for i := range this.MaliciousUserMitigation {
		if !this.MaliciousUserMitigation[i].Equal(that1.MaliciousUserMitigation[i]) {
			return false
		}
	}
	if !this.TlsIntercept.Equal(that1.TlsIntercept) {
		return false
	}
	if that1.AuthenticationChoice == nil {
		if this.AuthenticationChoice != nil {
			return false
		}
	} else if this.AuthenticationChoice == nil {
		return false
	} else if !this.AuthenticationChoice.Equal(that1.AuthenticationChoice) {
		return false
	}
	if this.IdleTimeout != that1.IdleTimeout {
		return false
	}
	if this.DisableDnsResolve != that1.DisableDnsResolve {
		return false
	}
	if that1.ServerHeaderChoice == nil {
		if this.ServerHeaderChoice != nil {
			return false
		}
	} else if this.ServerHeaderChoice == nil {
		return false
	} else if !this.ServerHeaderChoice.Equal(that1.ServerHeaderChoice) {
		return false
	}
	if this.DnsVolterraManaged != that1.DnsVolterraManaged {
		return false
	}
	if len(this.DnsDomains) != len(that1.DnsDomains) {
		return false
	}
	for i := range this.DnsDomains {
		if !this.DnsDomains[i].Equal(that1.DnsDomains[i]) {
			return false
		}
	}
	if this.AutoCert != that1.AutoCert {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.HostName != that1.HostName {
		return false
	}
	if len(this.DnsInfo) != len(that1.DnsInfo) {
		return false
	}
	for i := range this.DnsInfo {
		if !this.DnsInfo[i].Equal(that1.DnsInfo[i]) {
			return false
		}
	}
	if this.AutoCertState != that1.AutoCertState {
		return false
	}
	if !this.AutoCertInfo.Equal(that1.AutoCertInfo) {
		return false
	}
	if len(this.UserDomains) != len(that1.UserDomains) {
		return false
	}
	for i := range this.UserDomains {
		if this.UserDomains[i] != that1.UserDomains[i] {
			return false
		}
	}
	if len(this.ServicePolicySets) != len(that1.ServicePolicySets) {
		return false
	}
	for i := range this.ServicePolicySets {
		if !this.ServicePolicySets[i].Equal(that1.ServicePolicySets[i]) {
			return false
		}
	}
	if this.LoadbalancerAlgorithm != that1.LoadbalancerAlgorithm {
		return false
	}
	if this.VolterraCert != that1.VolterraCert {
		return false
	}
	return true
}
func (this *GlobalSpecType_NoChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_NoChallenge)
	if !ok {
		that2, ok := that.(GlobalSpecType_NoChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoChallenge.Equal(that1.NoChallenge) {
		return false
	}
	return true
}
func (this *GlobalSpecType_JsChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_JsChallenge)
	if !ok {
		that2, ok := that.(GlobalSpecType_JsChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.JsChallenge.Equal(that1.JsChallenge) {
		return false
	}
	return true
}
func (this *GlobalSpecType_CaptchaChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_CaptchaChallenge)
	if !ok {
		that2, ok := that.(GlobalSpecType_CaptchaChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CaptchaChallenge.Equal(that1.CaptchaChallenge) {
		return false
	}
	return true
}
func (this *GlobalSpecType_PolicyBasedChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_PolicyBasedChallenge)
	if !ok {
		that2, ok := that.(GlobalSpecType_PolicyBasedChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PolicyBasedChallenge.Equal(that1.PolicyBasedChallenge) {
		return false
	}
	return true
}
func (this *GlobalSpecType_NoAuthentication) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_NoAuthentication)
	if !ok {
		that2, ok := that.(GlobalSpecType_NoAuthentication)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoAuthentication.Equal(that1.NoAuthentication) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Authentication) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Authentication)
	if !ok {
		that2, ok := that.(GlobalSpecType_Authentication)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Authentication.Equal(that1.Authentication) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DefaultHeader) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DefaultHeader)
	if !ok {
		that2, ok := that.(GlobalSpecType_DefaultHeader)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultHeader.Equal(that1.DefaultHeader) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ServerName)
	if !ok {
		that2, ok := that.(GlobalSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *GlobalSpecType_AppendServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AppendServerName)
	if !ok {
		that2, ok := that.(GlobalSpecType_AppendServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AppendServerName != that1.AppendServerName {
		return false
	}
	return true
}
func (this *GlobalSpecType_PassThrough) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_PassThrough)
	if !ok {
		that2, ok := that.(GlobalSpecType_PassThrough)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PassThrough.Equal(that1.PassThrough) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	if len(this.AdvertisePolicies) != len(that1.AdvertisePolicies) {
		return false
	}
	for i := range this.AdvertisePolicies {
		if !this.AdvertisePolicies[i].Equal(that1.AdvertisePolicies[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToAdd) != len(that1.RequestHeadersToAdd) {
		return false
	}
	for i := range this.RequestHeadersToAdd {
		if !this.RequestHeadersToAdd[i].Equal(that1.RequestHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.ResponseHeadersToAdd) != len(that1.ResponseHeadersToAdd) {
		return false
	}
	for i := range this.ResponseHeadersToAdd {
		if !this.ResponseHeadersToAdd[i].Equal(that1.ResponseHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToRemove) != len(that1.RequestHeadersToRemove) {
		return false
	}
	for i := range this.RequestHeadersToRemove {
		if this.RequestHeadersToRemove[i] != that1.RequestHeadersToRemove[i] {
			return false
		}
	}
	if len(this.ResponseHeadersToRemove) != len(that1.ResponseHeadersToRemove) {
		return false
	}
	for i := range this.ResponseHeadersToRemove {
		if this.ResponseHeadersToRemove[i] != that1.ResponseHeadersToRemove[i] {
			return false
		}
	}
	if !this.TlsParameters.Equal(that1.TlsParameters) {
		return false
	}
	if !this.BufferPolicy.Equal(that1.BufferPolicy) {
		return false
	}
	if !this.CorsPolicy.Equal(that1.CorsPolicy) {
		return false
	}
	if this.Proxy != that1.Proxy {
		return false
	}
	if !this.WafType.Equal(that1.WafType) {
		return false
	}
	if !this.DynamicReverseProxy.Equal(that1.DynamicReverseProxy) {
		return false
	}
	if this.AddLocation != that1.AddLocation {
		return false
	}
	if !this.CompressionParams.Equal(that1.CompressionParams) {
		return false
	}
	if len(this.CustomErrors) != len(that1.CustomErrors) {
		return false
	}
	for i := range this.CustomErrors {
		if this.CustomErrors[i] != that1.CustomErrors[i] {
			return false
		}
	}
	if this.DisableDefaultErrorPages != that1.DisableDefaultErrorPages {
		return false
	}
	if this.MaxRequestHeaderSize != that1.MaxRequestHeaderSize {
		return false
	}
	if that1.ChallengeType == nil {
		if this.ChallengeType != nil {
			return false
		}
	} else if this.ChallengeType == nil {
		return false
	} else if !this.ChallengeType.Equal(that1.ChallengeType) {
		return false
	}
	if len(this.UserIdentification) != len(that1.UserIdentification) {
		return false
	}
	for i := range this.UserIdentification {
		if !this.UserIdentification[i].Equal(that1.UserIdentification[i]) {
			return false
		}
	}
	if len(this.RateLimiter) != len(that1.RateLimiter) {
		return false
	}
	for i := range this.RateLimiter {
		if !this.RateLimiter[i].Equal(that1.RateLimiter[i]) {
			return false
		}
	}
	if len(this.RateLimiterAllowedPrefixes) != len(that1.RateLimiterAllowedPrefixes) {
		return false
	}
	for i := range this.RateLimiterAllowedPrefixes {
		if !this.RateLimiterAllowedPrefixes[i].Equal(that1.RateLimiterAllowedPrefixes[i]) {
			return false
		}
	}
	if !this.RetryPolicy.Equal(that1.RetryPolicy) {
		return false
	}
	if this.IdleTimeout != that1.IdleTimeout {
		return false
	}
	if this.DisableDnsResolve != that1.DisableDnsResolve {
		return false
	}
	if !this.TemporaryUserBlocking.Equal(that1.TemporaryUserBlocking) {
		return false
	}
	if that1.AuthenticationChoice == nil {
		if this.AuthenticationChoice != nil {
			return false
		}
	} else if this.AuthenticationChoice == nil {
		return false
	} else if !this.AuthenticationChoice.Equal(that1.AuthenticationChoice) {
		return false
	}
	if that1.ServerHeaderChoice == nil {
		if this.ServerHeaderChoice != nil {
			return false
		}
	} else if this.ServerHeaderChoice == nil {
		return false
	} else if !this.ServerHeaderChoice.Equal(that1.ServerHeaderChoice) {
		return false
	}
	return true
}
func (this *CreateSpecType_NoChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_NoChallenge)
	if !ok {
		that2, ok := that.(CreateSpecType_NoChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoChallenge.Equal(that1.NoChallenge) {
		return false
	}
	return true
}
func (this *CreateSpecType_JsChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_JsChallenge)
	if !ok {
		that2, ok := that.(CreateSpecType_JsChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.JsChallenge.Equal(that1.JsChallenge) {
		return false
	}
	return true
}
func (this *CreateSpecType_CaptchaChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_CaptchaChallenge)
	if !ok {
		that2, ok := that.(CreateSpecType_CaptchaChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CaptchaChallenge.Equal(that1.CaptchaChallenge) {
		return false
	}
	return true
}
func (this *CreateSpecType_NoAuthentication) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_NoAuthentication)
	if !ok {
		that2, ok := that.(CreateSpecType_NoAuthentication)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoAuthentication.Equal(that1.NoAuthentication) {
		return false
	}
	return true
}
func (this *CreateSpecType_Authentication) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_Authentication)
	if !ok {
		that2, ok := that.(CreateSpecType_Authentication)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Authentication.Equal(that1.Authentication) {
		return false
	}
	return true
}
func (this *CreateSpecType_DefaultHeader) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DefaultHeader)
	if !ok {
		that2, ok := that.(CreateSpecType_DefaultHeader)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultHeader.Equal(that1.DefaultHeader) {
		return false
	}
	return true
}
func (this *CreateSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ServerName)
	if !ok {
		that2, ok := that.(CreateSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *CreateSpecType_AppendServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AppendServerName)
	if !ok {
		that2, ok := that.(CreateSpecType_AppendServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AppendServerName != that1.AppendServerName {
		return false
	}
	return true
}
func (this *CreateSpecType_PassThrough) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_PassThrough)
	if !ok {
		that2, ok := that.(CreateSpecType_PassThrough)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PassThrough.Equal(that1.PassThrough) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	if len(this.AdvertisePolicies) != len(that1.AdvertisePolicies) {
		return false
	}
	for i := range this.AdvertisePolicies {
		if !this.AdvertisePolicies[i].Equal(that1.AdvertisePolicies[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToAdd) != len(that1.RequestHeadersToAdd) {
		return false
	}
	for i := range this.RequestHeadersToAdd {
		if !this.RequestHeadersToAdd[i].Equal(that1.RequestHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.ResponseHeadersToAdd) != len(that1.ResponseHeadersToAdd) {
		return false
	}
	for i := range this.ResponseHeadersToAdd {
		if !this.ResponseHeadersToAdd[i].Equal(that1.ResponseHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToRemove) != len(that1.RequestHeadersToRemove) {
		return false
	}
	for i := range this.RequestHeadersToRemove {
		if this.RequestHeadersToRemove[i] != that1.RequestHeadersToRemove[i] {
			return false
		}
	}
	if len(this.ResponseHeadersToRemove) != len(that1.ResponseHeadersToRemove) {
		return false
	}
	for i := range this.ResponseHeadersToRemove {
		if this.ResponseHeadersToRemove[i] != that1.ResponseHeadersToRemove[i] {
			return false
		}
	}
	if !this.TlsParameters.Equal(that1.TlsParameters) {
		return false
	}
	if !this.BufferPolicy.Equal(that1.BufferPolicy) {
		return false
	}
	if !this.CorsPolicy.Equal(that1.CorsPolicy) {
		return false
	}
	if this.Proxy != that1.Proxy {
		return false
	}
	if !this.WafType.Equal(that1.WafType) {
		return false
	}
	if !this.DynamicReverseProxy.Equal(that1.DynamicReverseProxy) {
		return false
	}
	if this.AddLocation != that1.AddLocation {
		return false
	}
	if !this.CompressionParams.Equal(that1.CompressionParams) {
		return false
	}
	if len(this.CustomErrors) != len(that1.CustomErrors) {
		return false
	}
	for i := range this.CustomErrors {
		if this.CustomErrors[i] != that1.CustomErrors[i] {
			return false
		}
	}
	if this.DisableDefaultErrorPages != that1.DisableDefaultErrorPages {
		return false
	}
	if this.MaxRequestHeaderSize != that1.MaxRequestHeaderSize {
		return false
	}
	if that1.ChallengeType == nil {
		if this.ChallengeType != nil {
			return false
		}
	} else if this.ChallengeType == nil {
		return false
	} else if !this.ChallengeType.Equal(that1.ChallengeType) {
		return false
	}
	if len(this.UserIdentification) != len(that1.UserIdentification) {
		return false
	}
	for i := range this.UserIdentification {
		if !this.UserIdentification[i].Equal(that1.UserIdentification[i]) {
			return false
		}
	}
	if len(this.RateLimiter) != len(that1.RateLimiter) {
		return false
	}
	for i := range this.RateLimiter {
		if !this.RateLimiter[i].Equal(that1.RateLimiter[i]) {
			return false
		}
	}
	if len(this.RateLimiterAllowedPrefixes) != len(that1.RateLimiterAllowedPrefixes) {
		return false
	}
	for i := range this.RateLimiterAllowedPrefixes {
		if !this.RateLimiterAllowedPrefixes[i].Equal(that1.RateLimiterAllowedPrefixes[i]) {
			return false
		}
	}
	if !this.RetryPolicy.Equal(that1.RetryPolicy) {
		return false
	}
	if this.IdleTimeout != that1.IdleTimeout {
		return false
	}
	if this.DisableDnsResolve != that1.DisableDnsResolve {
		return false
	}
	if !this.TemporaryUserBlocking.Equal(that1.TemporaryUserBlocking) {
		return false
	}
	if that1.AuthenticationChoice == nil {
		if this.AuthenticationChoice != nil {
			return false
		}
	} else if this.AuthenticationChoice == nil {
		return false
	} else if !this.AuthenticationChoice.Equal(that1.AuthenticationChoice) {
		return false
	}
	if that1.ServerHeaderChoice == nil {
		if this.ServerHeaderChoice != nil {
			return false
		}
	} else if this.ServerHeaderChoice == nil {
		return false
	} else if !this.ServerHeaderChoice.Equal(that1.ServerHeaderChoice) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_NoChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_NoChallenge)
	if !ok {
		that2, ok := that.(ReplaceSpecType_NoChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoChallenge.Equal(that1.NoChallenge) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_JsChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_JsChallenge)
	if !ok {
		that2, ok := that.(ReplaceSpecType_JsChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.JsChallenge.Equal(that1.JsChallenge) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_CaptchaChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_CaptchaChallenge)
	if !ok {
		that2, ok := that.(ReplaceSpecType_CaptchaChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CaptchaChallenge.Equal(that1.CaptchaChallenge) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_NoAuthentication) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_NoAuthentication)
	if !ok {
		that2, ok := that.(ReplaceSpecType_NoAuthentication)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoAuthentication.Equal(that1.NoAuthentication) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_Authentication) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_Authentication)
	if !ok {
		that2, ok := that.(ReplaceSpecType_Authentication)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Authentication.Equal(that1.Authentication) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DefaultHeader) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DefaultHeader)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DefaultHeader)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultHeader.Equal(that1.DefaultHeader) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ServerName)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AppendServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AppendServerName)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AppendServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AppendServerName != that1.AppendServerName {
		return false
	}
	return true
}
func (this *ReplaceSpecType_PassThrough) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_PassThrough)
	if !ok {
		that2, ok := that.(ReplaceSpecType_PassThrough)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PassThrough.Equal(that1.PassThrough) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	if len(this.AdvertisePolicies) != len(that1.AdvertisePolicies) {
		return false
	}
	for i := range this.AdvertisePolicies {
		if !this.AdvertisePolicies[i].Equal(that1.AdvertisePolicies[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToAdd) != len(that1.RequestHeadersToAdd) {
		return false
	}
	for i := range this.RequestHeadersToAdd {
		if !this.RequestHeadersToAdd[i].Equal(that1.RequestHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.ResponseHeadersToAdd) != len(that1.ResponseHeadersToAdd) {
		return false
	}
	for i := range this.ResponseHeadersToAdd {
		if !this.ResponseHeadersToAdd[i].Equal(that1.ResponseHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToRemove) != len(that1.RequestHeadersToRemove) {
		return false
	}
	for i := range this.RequestHeadersToRemove {
		if this.RequestHeadersToRemove[i] != that1.RequestHeadersToRemove[i] {
			return false
		}
	}
	if len(this.ResponseHeadersToRemove) != len(that1.ResponseHeadersToRemove) {
		return false
	}
	for i := range this.ResponseHeadersToRemove {
		if this.ResponseHeadersToRemove[i] != that1.ResponseHeadersToRemove[i] {
			return false
		}
	}
	if !this.TlsParameters.Equal(that1.TlsParameters) {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.BufferPolicy.Equal(that1.BufferPolicy) {
		return false
	}
	if !this.CorsPolicy.Equal(that1.CorsPolicy) {
		return false
	}
	if this.Proxy != that1.Proxy {
		return false
	}
	if !this.WafType.Equal(that1.WafType) {
		return false
	}
	if !this.DynamicReverseProxy.Equal(that1.DynamicReverseProxy) {
		return false
	}
	if this.AddLocation != that1.AddLocation {
		return false
	}
	if !this.CompressionParams.Equal(that1.CompressionParams) {
		return false
	}
	if len(this.CustomErrors) != len(that1.CustomErrors) {
		return false
	}
	for i := range this.CustomErrors {
		if this.CustomErrors[i] != that1.CustomErrors[i] {
			return false
		}
	}
	if this.DisableDefaultErrorPages != that1.DisableDefaultErrorPages {
		return false
	}
	if this.MaxRequestHeaderSize != that1.MaxRequestHeaderSize {
		return false
	}
	if that1.ChallengeType == nil {
		if this.ChallengeType != nil {
			return false
		}
	} else if this.ChallengeType == nil {
		return false
	} else if !this.ChallengeType.Equal(that1.ChallengeType) {
		return false
	}
	if len(this.UserIdentification) != len(that1.UserIdentification) {
		return false
	}
	for i := range this.UserIdentification {
		if !this.UserIdentification[i].Equal(that1.UserIdentification[i]) {
			return false
		}
	}
	if len(this.RateLimiter) != len(that1.RateLimiter) {
		return false
	}
	for i := range this.RateLimiter {
		if !this.RateLimiter[i].Equal(that1.RateLimiter[i]) {
			return false
		}
	}
	if len(this.RateLimiterAllowedPrefixes) != len(that1.RateLimiterAllowedPrefixes) {
		return false
	}
	for i := range this.RateLimiterAllowedPrefixes {
		if !this.RateLimiterAllowedPrefixes[i].Equal(that1.RateLimiterAllowedPrefixes[i]) {
			return false
		}
	}
	if !this.RetryPolicy.Equal(that1.RetryPolicy) {
		return false
	}
	if this.IdleTimeout != that1.IdleTimeout {
		return false
	}
	if !this.TemporaryUserBlocking.Equal(that1.TemporaryUserBlocking) {
		return false
	}
	if that1.AuthenticationChoice == nil {
		if this.AuthenticationChoice != nil {
			return false
		}
	} else if this.AuthenticationChoice == nil {
		return false
	} else if !this.AuthenticationChoice.Equal(that1.AuthenticationChoice) {
		return false
	}
	if that1.ServerHeaderChoice == nil {
		if this.ServerHeaderChoice != nil {
			return false
		}
	} else if this.ServerHeaderChoice == nil {
		return false
	} else if !this.ServerHeaderChoice.Equal(that1.ServerHeaderChoice) {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.HostName != that1.HostName {
		return false
	}
	if len(this.DnsInfo) != len(that1.DnsInfo) {
		return false
	}
	for i := range this.DnsInfo {
		if !this.DnsInfo[i].Equal(that1.DnsInfo[i]) {
			return false
		}
	}
	if this.AutoCertState != that1.AutoCertState {
		return false
	}
	if !this.AutoCertInfo.Equal(that1.AutoCertInfo) {
		return false
	}
	if this.DisableDnsResolve != that1.DisableDnsResolve {
		return false
	}
	return true
}
func (this *GetSpecType_NoChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_NoChallenge)
	if !ok {
		that2, ok := that.(GetSpecType_NoChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoChallenge.Equal(that1.NoChallenge) {
		return false
	}
	return true
}
func (this *GetSpecType_JsChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_JsChallenge)
	if !ok {
		that2, ok := that.(GetSpecType_JsChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.JsChallenge.Equal(that1.JsChallenge) {
		return false
	}
	return true
}
func (this *GetSpecType_CaptchaChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_CaptchaChallenge)
	if !ok {
		that2, ok := that.(GetSpecType_CaptchaChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CaptchaChallenge.Equal(that1.CaptchaChallenge) {
		return false
	}
	return true
}
func (this *GetSpecType_NoAuthentication) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_NoAuthentication)
	if !ok {
		that2, ok := that.(GetSpecType_NoAuthentication)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoAuthentication.Equal(that1.NoAuthentication) {
		return false
	}
	return true
}
func (this *GetSpecType_Authentication) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_Authentication)
	if !ok {
		that2, ok := that.(GetSpecType_Authentication)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Authentication.Equal(that1.Authentication) {
		return false
	}
	return true
}
func (this *GetSpecType_DefaultHeader) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DefaultHeader)
	if !ok {
		that2, ok := that.(GetSpecType_DefaultHeader)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultHeader.Equal(that1.DefaultHeader) {
		return false
	}
	return true
}
func (this *GetSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ServerName)
	if !ok {
		that2, ok := that.(GetSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *GetSpecType_AppendServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AppendServerName)
	if !ok {
		that2, ok := that.(GetSpecType_AppendServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AppendServerName != that1.AppendServerName {
		return false
	}
	return true
}
func (this *GetSpecType_PassThrough) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_PassThrough)
	if !ok {
		that2, ok := that.(GetSpecType_PassThrough)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PassThrough.Equal(that1.PassThrough) {
		return false
	}
	return true
}
func (this *JavaScriptConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&virtual_host.JavaScriptConfigType{")
	s = append(s, "CachePrefix: "+fmt.Sprintf("%#v", this.CachePrefix)+",\n")
	if this.ScriptConfig != nil {
		s = append(s, "ScriptConfig: "+fmt.Sprintf("%#v", this.ScriptConfig)+",\n")
	}
	s = append(s, "CustomScriptUrl: "+fmt.Sprintf("%#v", this.CustomScriptUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DynamicReverseProxyType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&virtual_host.DynamicReverseProxyType{")
	s = append(s, "ResolveEndpointDynamically: "+fmt.Sprintf("%#v", this.ResolveEndpointDynamically)+",\n")
	s = append(s, "ResolutionNetworkType: "+fmt.Sprintf("%#v", this.ResolutionNetworkType)+",\n")
	if this.ResolutionNetwork != nil {
		s = append(s, "ResolutionNetwork: "+fmt.Sprintf("%#v", this.ResolutionNetwork)+",\n")
	}
	s = append(s, "ConnectionTimeout: "+fmt.Sprintf("%#v", this.ConnectionTimeout)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CompressionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&virtual_host.CompressionType{")
	s = append(s, "ContentLength: "+fmt.Sprintf("%#v", this.ContentLength)+",\n")
	s = append(s, "ContentType: "+fmt.Sprintf("%#v", this.ContentType)+",\n")
	s = append(s, "DisableOnEtagHeader: "+fmt.Sprintf("%#v", this.DisableOnEtagHeader)+",\n")
	s = append(s, "RemoveAcceptEncodingHeader: "+fmt.Sprintf("%#v", this.RemoveAcceptEncodingHeader)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *JavascriptChallengeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&virtual_host.JavascriptChallengeType{")
	s = append(s, "JsScriptDelay: "+fmt.Sprintf("%#v", this.JsScriptDelay)+",\n")
	s = append(s, "CookieExpiry: "+fmt.Sprintf("%#v", this.CookieExpiry)+",\n")
	s = append(s, "CustomPage: "+fmt.Sprintf("%#v", this.CustomPage)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CaptchaChallengeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&virtual_host.CaptchaChallengeType{")
	s = append(s, "CookieExpiry: "+fmt.Sprintf("%#v", this.CookieExpiry)+",\n")
	s = append(s, "CustomPage: "+fmt.Sprintf("%#v", this.CustomPage)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TemporaryUserBlockingType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&virtual_host.TemporaryUserBlockingType{")
	s = append(s, "CustomPage: "+fmt.Sprintf("%#v", this.CustomPage)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AutoCertInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&virtual_host.AutoCertInfoType{")
	s = append(s, "AutoCertState: "+fmt.Sprintf("%#v", this.AutoCertState)+",\n")
	if this.AutoCertExpiry != nil {
		s = append(s, "AutoCertExpiry: "+fmt.Sprintf("%#v", this.AutoCertExpiry)+",\n")
	}
	s = append(s, "AutoCertSubject: "+fmt.Sprintf("%#v", this.AutoCertSubject)+",\n")
	s = append(s, "AutoCertIssuer: "+fmt.Sprintf("%#v", this.AutoCertIssuer)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthenticationDetails) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&virtual_host.AuthenticationDetails{")
	if this.AuthConfig != nil {
		s = append(s, "AuthConfig: "+fmt.Sprintf("%#v", this.AuthConfig)+",\n")
	}
	if this.CookieParamsChoice != nil {
		s = append(s, "CookieParamsChoice: "+fmt.Sprintf("%#v", this.CookieParamsChoice)+",\n")
	}
	if this.RedirectUrlChoice != nil {
		s = append(s, "RedirectUrlChoice: "+fmt.Sprintf("%#v", this.RedirectUrlChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthenticationDetails_UseAuthObjectConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.AuthenticationDetails_UseAuthObjectConfig{` +
		`UseAuthObjectConfig:` + fmt.Sprintf("%#v", this.UseAuthObjectConfig) + `}`}, ", ")
	return s
}
func (this *AuthenticationDetails_CookieParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.AuthenticationDetails_CookieParams{` +
		`CookieParams:` + fmt.Sprintf("%#v", this.CookieParams) + `}`}, ", ")
	return s
}
func (this *AuthenticationDetails_RedirectUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.AuthenticationDetails_RedirectUrl{` +
		`RedirectUrl:` + fmt.Sprintf("%#v", this.RedirectUrl) + `}`}, ", ")
	return s
}
func (this *AuthenticationDetails_RedirectDynamic) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.AuthenticationDetails_RedirectDynamic{` +
		`RedirectDynamic:` + fmt.Sprintf("%#v", this.RedirectDynamic) + `}`}, ", ")
	return s
}
func (this *PolicyBasedChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&virtual_host.PolicyBasedChallenge{")
	if this.JsChallenge != nil {
		s = append(s, "JsChallenge: "+fmt.Sprintf("%#v", this.JsChallenge)+",\n")
	}
	if this.CaptchaChallenge != nil {
		s = append(s, "CaptchaChallenge: "+fmt.Sprintf("%#v", this.CaptchaChallenge)+",\n")
	}
	if this.TemporaryUserBlocking != nil {
		s = append(s, "TemporaryUserBlocking: "+fmt.Sprintf("%#v", this.TemporaryUserBlocking)+",\n")
	}
	if this.ChallengeChoice != nil {
		s = append(s, "ChallengeChoice: "+fmt.Sprintf("%#v", this.ChallengeChoice)+",\n")
	}
	if this.MaliciousUserMitigation != nil {
		s = append(s, "MaliciousUserMitigation: "+fmt.Sprintf("%#v", this.MaliciousUserMitigation)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PolicyBasedChallenge_NoChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.PolicyBasedChallenge_NoChallenge{` +
		`NoChallenge:` + fmt.Sprintf("%#v", this.NoChallenge) + `}`}, ", ")
	return s
}
func (this *PolicyBasedChallenge_AlwaysEnableJsChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.PolicyBasedChallenge_AlwaysEnableJsChallenge{` +
		`AlwaysEnableJsChallenge:` + fmt.Sprintf("%#v", this.AlwaysEnableJsChallenge) + `}`}, ", ")
	return s
}
func (this *PolicyBasedChallenge_AlwaysEnableCaptchaChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.PolicyBasedChallenge_AlwaysEnableCaptchaChallenge{` +
		`AlwaysEnableCaptchaChallenge:` + fmt.Sprintf("%#v", this.AlwaysEnableCaptchaChallenge) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 56)
	s = append(s, "&virtual_host.GlobalSpecType{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	if this.JavascriptInfo != nil {
		s = append(s, "JavascriptInfo: "+fmt.Sprintf("%#v", this.JavascriptInfo)+",\n")
	}
	if this.AdvertisePolicies != nil {
		s = append(s, "AdvertisePolicies: "+fmt.Sprintf("%#v", this.AdvertisePolicies)+",\n")
	}
	if this.RequestHeadersToAdd != nil {
		s = append(s, "RequestHeadersToAdd: "+fmt.Sprintf("%#v", this.RequestHeadersToAdd)+",\n")
	}
	if this.ResponseHeadersToAdd != nil {
		s = append(s, "ResponseHeadersToAdd: "+fmt.Sprintf("%#v", this.ResponseHeadersToAdd)+",\n")
	}
	s = append(s, "RequestHeadersToRemove: "+fmt.Sprintf("%#v", this.RequestHeadersToRemove)+",\n")
	s = append(s, "ResponseHeadersToRemove: "+fmt.Sprintf("%#v", this.ResponseHeadersToRemove)+",\n")
	if this.TlsParameters != nil {
		s = append(s, "TlsParameters: "+fmt.Sprintf("%#v", this.TlsParameters)+",\n")
	}
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.BufferPolicy != nil {
		s = append(s, "BufferPolicy: "+fmt.Sprintf("%#v", this.BufferPolicy)+",\n")
	}
	if this.CorsPolicy != nil {
		s = append(s, "CorsPolicy: "+fmt.Sprintf("%#v", this.CorsPolicy)+",\n")
	}
	s = append(s, "Proxy: "+fmt.Sprintf("%#v", this.Proxy)+",\n")
	if this.Jwt != nil {
		s = append(s, "Jwt: "+fmt.Sprintf("%#v", this.Jwt)+",\n")
	}
	if this.WafType != nil {
		s = append(s, "WafType: "+fmt.Sprintf("%#v", this.WafType)+",\n")
	}
	if this.DynamicReverseProxy != nil {
		s = append(s, "DynamicReverseProxy: "+fmt.Sprintf("%#v", this.DynamicReverseProxy)+",\n")
	}
	s = append(s, "AddLocation: "+fmt.Sprintf("%#v", this.AddLocation)+",\n")
	if this.CompressionParams != nil {
		s = append(s, "CompressionParams: "+fmt.Sprintf("%#v", this.CompressionParams)+",\n")
	}
	keysForCustomErrors := make([]uint32, 0, len(this.CustomErrors))
	for k, _ := range this.CustomErrors {
		keysForCustomErrors = append(keysForCustomErrors, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForCustomErrors)
	mapStringForCustomErrors := "map[uint32]string{"
	for _, k := range keysForCustomErrors {
		mapStringForCustomErrors += fmt.Sprintf("%#v: %#v,", k, this.CustomErrors[k])
	}
	mapStringForCustomErrors += "}"
	if this.CustomErrors != nil {
		s = append(s, "CustomErrors: "+mapStringForCustomErrors+",\n")
	}
	s = append(s, "DisableDefaultErrorPages: "+fmt.Sprintf("%#v", this.DisableDefaultErrorPages)+",\n")
	s = append(s, "MaxRequestHeaderSize: "+fmt.Sprintf("%#v", this.MaxRequestHeaderSize)+",\n")
	if this.ChallengeType != nil {
		s = append(s, "ChallengeType: "+fmt.Sprintf("%#v", this.ChallengeType)+",\n")
	}
	if this.UserIdentification != nil {
		s = append(s, "UserIdentification: "+fmt.Sprintf("%#v", this.UserIdentification)+",\n")
	}
	if this.RateLimiter != nil {
		s = append(s, "RateLimiter: "+fmt.Sprintf("%#v", this.RateLimiter)+",\n")
	}
	if this.RateLimiterAllowedPrefixes != nil {
		s = append(s, "RateLimiterAllowedPrefixes: "+fmt.Sprintf("%#v", this.RateLimiterAllowedPrefixes)+",\n")
	}
	if this.RetryPolicy != nil {
		s = append(s, "RetryPolicy: "+fmt.Sprintf("%#v", this.RetryPolicy)+",\n")
	}
	if this.TemporaryUserBlocking != nil {
		s = append(s, "TemporaryUserBlocking: "+fmt.Sprintf("%#v", this.TemporaryUserBlocking)+",\n")
	}
	if this.MaliciousUserMitigation != nil {
		s = append(s, "MaliciousUserMitigation: "+fmt.Sprintf("%#v", this.MaliciousUserMitigation)+",\n")
	}
	if this.TlsIntercept != nil {
		s = append(s, "TlsIntercept: "+fmt.Sprintf("%#v", this.TlsIntercept)+",\n")
	}
	if this.AuthenticationChoice != nil {
		s = append(s, "AuthenticationChoice: "+fmt.Sprintf("%#v", this.AuthenticationChoice)+",\n")
	}
	s = append(s, "IdleTimeout: "+fmt.Sprintf("%#v", this.IdleTimeout)+",\n")
	s = append(s, "DisableDnsResolve: "+fmt.Sprintf("%#v", this.DisableDnsResolve)+",\n")
	if this.ServerHeaderChoice != nil {
		s = append(s, "ServerHeaderChoice: "+fmt.Sprintf("%#v", this.ServerHeaderChoice)+",\n")
	}
	s = append(s, "DnsVolterraManaged: "+fmt.Sprintf("%#v", this.DnsVolterraManaged)+",\n")
	if this.DnsDomains != nil {
		s = append(s, "DnsDomains: "+fmt.Sprintf("%#v", this.DnsDomains)+",\n")
	}
	s = append(s, "AutoCert: "+fmt.Sprintf("%#v", this.AutoCert)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "HostName: "+fmt.Sprintf("%#v", this.HostName)+",\n")
	if this.DnsInfo != nil {
		s = append(s, "DnsInfo: "+fmt.Sprintf("%#v", this.DnsInfo)+",\n")
	}
	s = append(s, "AutoCertState: "+fmt.Sprintf("%#v", this.AutoCertState)+",\n")
	if this.AutoCertInfo != nil {
		s = append(s, "AutoCertInfo: "+fmt.Sprintf("%#v", this.AutoCertInfo)+",\n")
	}
	s = append(s, "UserDomains: "+fmt.Sprintf("%#v", this.UserDomains)+",\n")
	if this.ServicePolicySets != nil {
		s = append(s, "ServicePolicySets: "+fmt.Sprintf("%#v", this.ServicePolicySets)+",\n")
	}
	s = append(s, "LoadbalancerAlgorithm: "+fmt.Sprintf("%#v", this.LoadbalancerAlgorithm)+",\n")
	s = append(s, "VolterraCert: "+fmt.Sprintf("%#v", this.VolterraCert)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_NoChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GlobalSpecType_NoChallenge{` +
		`NoChallenge:` + fmt.Sprintf("%#v", this.NoChallenge) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_JsChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GlobalSpecType_JsChallenge{` +
		`JsChallenge:` + fmt.Sprintf("%#v", this.JsChallenge) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_CaptchaChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GlobalSpecType_CaptchaChallenge{` +
		`CaptchaChallenge:` + fmt.Sprintf("%#v", this.CaptchaChallenge) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_PolicyBasedChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GlobalSpecType_PolicyBasedChallenge{` +
		`PolicyBasedChallenge:` + fmt.Sprintf("%#v", this.PolicyBasedChallenge) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_NoAuthentication) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GlobalSpecType_NoAuthentication{` +
		`NoAuthentication:` + fmt.Sprintf("%#v", this.NoAuthentication) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Authentication) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GlobalSpecType_Authentication{` +
		`Authentication:` + fmt.Sprintf("%#v", this.Authentication) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DefaultHeader) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GlobalSpecType_DefaultHeader{` +
		`DefaultHeader:` + fmt.Sprintf("%#v", this.DefaultHeader) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GlobalSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AppendServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GlobalSpecType_AppendServerName{` +
		`AppendServerName:` + fmt.Sprintf("%#v", this.AppendServerName) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_PassThrough) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GlobalSpecType_PassThrough{` +
		`PassThrough:` + fmt.Sprintf("%#v", this.PassThrough) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 38)
	s = append(s, "&virtual_host.CreateSpecType{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	if this.AdvertisePolicies != nil {
		s = append(s, "AdvertisePolicies: "+fmt.Sprintf("%#v", this.AdvertisePolicies)+",\n")
	}
	if this.RequestHeadersToAdd != nil {
		s = append(s, "RequestHeadersToAdd: "+fmt.Sprintf("%#v", this.RequestHeadersToAdd)+",\n")
	}
	if this.ResponseHeadersToAdd != nil {
		s = append(s, "ResponseHeadersToAdd: "+fmt.Sprintf("%#v", this.ResponseHeadersToAdd)+",\n")
	}
	s = append(s, "RequestHeadersToRemove: "+fmt.Sprintf("%#v", this.RequestHeadersToRemove)+",\n")
	s = append(s, "ResponseHeadersToRemove: "+fmt.Sprintf("%#v", this.ResponseHeadersToRemove)+",\n")
	if this.TlsParameters != nil {
		s = append(s, "TlsParameters: "+fmt.Sprintf("%#v", this.TlsParameters)+",\n")
	}
	if this.BufferPolicy != nil {
		s = append(s, "BufferPolicy: "+fmt.Sprintf("%#v", this.BufferPolicy)+",\n")
	}
	if this.CorsPolicy != nil {
		s = append(s, "CorsPolicy: "+fmt.Sprintf("%#v", this.CorsPolicy)+",\n")
	}
	s = append(s, "Proxy: "+fmt.Sprintf("%#v", this.Proxy)+",\n")
	if this.WafType != nil {
		s = append(s, "WafType: "+fmt.Sprintf("%#v", this.WafType)+",\n")
	}
	if this.DynamicReverseProxy != nil {
		s = append(s, "DynamicReverseProxy: "+fmt.Sprintf("%#v", this.DynamicReverseProxy)+",\n")
	}
	s = append(s, "AddLocation: "+fmt.Sprintf("%#v", this.AddLocation)+",\n")
	if this.CompressionParams != nil {
		s = append(s, "CompressionParams: "+fmt.Sprintf("%#v", this.CompressionParams)+",\n")
	}
	keysForCustomErrors := make([]uint32, 0, len(this.CustomErrors))
	for k, _ := range this.CustomErrors {
		keysForCustomErrors = append(keysForCustomErrors, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForCustomErrors)
	mapStringForCustomErrors := "map[uint32]string{"
	for _, k := range keysForCustomErrors {
		mapStringForCustomErrors += fmt.Sprintf("%#v: %#v,", k, this.CustomErrors[k])
	}
	mapStringForCustomErrors += "}"
	if this.CustomErrors != nil {
		s = append(s, "CustomErrors: "+mapStringForCustomErrors+",\n")
	}
	s = append(s, "DisableDefaultErrorPages: "+fmt.Sprintf("%#v", this.DisableDefaultErrorPages)+",\n")
	s = append(s, "MaxRequestHeaderSize: "+fmt.Sprintf("%#v", this.MaxRequestHeaderSize)+",\n")
	if this.ChallengeType != nil {
		s = append(s, "ChallengeType: "+fmt.Sprintf("%#v", this.ChallengeType)+",\n")
	}
	if this.UserIdentification != nil {
		s = append(s, "UserIdentification: "+fmt.Sprintf("%#v", this.UserIdentification)+",\n")
	}
	if this.RateLimiter != nil {
		s = append(s, "RateLimiter: "+fmt.Sprintf("%#v", this.RateLimiter)+",\n")
	}
	if this.RateLimiterAllowedPrefixes != nil {
		s = append(s, "RateLimiterAllowedPrefixes: "+fmt.Sprintf("%#v", this.RateLimiterAllowedPrefixes)+",\n")
	}
	if this.RetryPolicy != nil {
		s = append(s, "RetryPolicy: "+fmt.Sprintf("%#v", this.RetryPolicy)+",\n")
	}
	s = append(s, "IdleTimeout: "+fmt.Sprintf("%#v", this.IdleTimeout)+",\n")
	s = append(s, "DisableDnsResolve: "+fmt.Sprintf("%#v", this.DisableDnsResolve)+",\n")
	if this.TemporaryUserBlocking != nil {
		s = append(s, "TemporaryUserBlocking: "+fmt.Sprintf("%#v", this.TemporaryUserBlocking)+",\n")
	}
	if this.AuthenticationChoice != nil {
		s = append(s, "AuthenticationChoice: "+fmt.Sprintf("%#v", this.AuthenticationChoice)+",\n")
	}
	if this.ServerHeaderChoice != nil {
		s = append(s, "ServerHeaderChoice: "+fmt.Sprintf("%#v", this.ServerHeaderChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_NoChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.CreateSpecType_NoChallenge{` +
		`NoChallenge:` + fmt.Sprintf("%#v", this.NoChallenge) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_JsChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.CreateSpecType_JsChallenge{` +
		`JsChallenge:` + fmt.Sprintf("%#v", this.JsChallenge) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_CaptchaChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.CreateSpecType_CaptchaChallenge{` +
		`CaptchaChallenge:` + fmt.Sprintf("%#v", this.CaptchaChallenge) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_NoAuthentication) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.CreateSpecType_NoAuthentication{` +
		`NoAuthentication:` + fmt.Sprintf("%#v", this.NoAuthentication) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_Authentication) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.CreateSpecType_Authentication{` +
		`Authentication:` + fmt.Sprintf("%#v", this.Authentication) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DefaultHeader) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.CreateSpecType_DefaultHeader{` +
		`DefaultHeader:` + fmt.Sprintf("%#v", this.DefaultHeader) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.CreateSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AppendServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.CreateSpecType_AppendServerName{` +
		`AppendServerName:` + fmt.Sprintf("%#v", this.AppendServerName) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_PassThrough) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.CreateSpecType_PassThrough{` +
		`PassThrough:` + fmt.Sprintf("%#v", this.PassThrough) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 38)
	s = append(s, "&virtual_host.ReplaceSpecType{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	if this.AdvertisePolicies != nil {
		s = append(s, "AdvertisePolicies: "+fmt.Sprintf("%#v", this.AdvertisePolicies)+",\n")
	}
	if this.RequestHeadersToAdd != nil {
		s = append(s, "RequestHeadersToAdd: "+fmt.Sprintf("%#v", this.RequestHeadersToAdd)+",\n")
	}
	if this.ResponseHeadersToAdd != nil {
		s = append(s, "ResponseHeadersToAdd: "+fmt.Sprintf("%#v", this.ResponseHeadersToAdd)+",\n")
	}
	s = append(s, "RequestHeadersToRemove: "+fmt.Sprintf("%#v", this.RequestHeadersToRemove)+",\n")
	s = append(s, "ResponseHeadersToRemove: "+fmt.Sprintf("%#v", this.ResponseHeadersToRemove)+",\n")
	if this.TlsParameters != nil {
		s = append(s, "TlsParameters: "+fmt.Sprintf("%#v", this.TlsParameters)+",\n")
	}
	if this.BufferPolicy != nil {
		s = append(s, "BufferPolicy: "+fmt.Sprintf("%#v", this.BufferPolicy)+",\n")
	}
	if this.CorsPolicy != nil {
		s = append(s, "CorsPolicy: "+fmt.Sprintf("%#v", this.CorsPolicy)+",\n")
	}
	s = append(s, "Proxy: "+fmt.Sprintf("%#v", this.Proxy)+",\n")
	if this.WafType != nil {
		s = append(s, "WafType: "+fmt.Sprintf("%#v", this.WafType)+",\n")
	}
	if this.DynamicReverseProxy != nil {
		s = append(s, "DynamicReverseProxy: "+fmt.Sprintf("%#v", this.DynamicReverseProxy)+",\n")
	}
	s = append(s, "AddLocation: "+fmt.Sprintf("%#v", this.AddLocation)+",\n")
	if this.CompressionParams != nil {
		s = append(s, "CompressionParams: "+fmt.Sprintf("%#v", this.CompressionParams)+",\n")
	}
	keysForCustomErrors := make([]uint32, 0, len(this.CustomErrors))
	for k, _ := range this.CustomErrors {
		keysForCustomErrors = append(keysForCustomErrors, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForCustomErrors)
	mapStringForCustomErrors := "map[uint32]string{"
	for _, k := range keysForCustomErrors {
		mapStringForCustomErrors += fmt.Sprintf("%#v: %#v,", k, this.CustomErrors[k])
	}
	mapStringForCustomErrors += "}"
	if this.CustomErrors != nil {
		s = append(s, "CustomErrors: "+mapStringForCustomErrors+",\n")
	}
	s = append(s, "DisableDefaultErrorPages: "+fmt.Sprintf("%#v", this.DisableDefaultErrorPages)+",\n")
	s = append(s, "MaxRequestHeaderSize: "+fmt.Sprintf("%#v", this.MaxRequestHeaderSize)+",\n")
	if this.ChallengeType != nil {
		s = append(s, "ChallengeType: "+fmt.Sprintf("%#v", this.ChallengeType)+",\n")
	}
	if this.UserIdentification != nil {
		s = append(s, "UserIdentification: "+fmt.Sprintf("%#v", this.UserIdentification)+",\n")
	}
	if this.RateLimiter != nil {
		s = append(s, "RateLimiter: "+fmt.Sprintf("%#v", this.RateLimiter)+",\n")
	}
	if this.RateLimiterAllowedPrefixes != nil {
		s = append(s, "RateLimiterAllowedPrefixes: "+fmt.Sprintf("%#v", this.RateLimiterAllowedPrefixes)+",\n")
	}
	if this.RetryPolicy != nil {
		s = append(s, "RetryPolicy: "+fmt.Sprintf("%#v", this.RetryPolicy)+",\n")
	}
	s = append(s, "IdleTimeout: "+fmt.Sprintf("%#v", this.IdleTimeout)+",\n")
	s = append(s, "DisableDnsResolve: "+fmt.Sprintf("%#v", this.DisableDnsResolve)+",\n")
	if this.TemporaryUserBlocking != nil {
		s = append(s, "TemporaryUserBlocking: "+fmt.Sprintf("%#v", this.TemporaryUserBlocking)+",\n")
	}
	if this.AuthenticationChoice != nil {
		s = append(s, "AuthenticationChoice: "+fmt.Sprintf("%#v", this.AuthenticationChoice)+",\n")
	}
	if this.ServerHeaderChoice != nil {
		s = append(s, "ServerHeaderChoice: "+fmt.Sprintf("%#v", this.ServerHeaderChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_NoChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.ReplaceSpecType_NoChallenge{` +
		`NoChallenge:` + fmt.Sprintf("%#v", this.NoChallenge) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_JsChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.ReplaceSpecType_JsChallenge{` +
		`JsChallenge:` + fmt.Sprintf("%#v", this.JsChallenge) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_CaptchaChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.ReplaceSpecType_CaptchaChallenge{` +
		`CaptchaChallenge:` + fmt.Sprintf("%#v", this.CaptchaChallenge) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_NoAuthentication) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.ReplaceSpecType_NoAuthentication{` +
		`NoAuthentication:` + fmt.Sprintf("%#v", this.NoAuthentication) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_Authentication) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.ReplaceSpecType_Authentication{` +
		`Authentication:` + fmt.Sprintf("%#v", this.Authentication) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DefaultHeader) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.ReplaceSpecType_DefaultHeader{` +
		`DefaultHeader:` + fmt.Sprintf("%#v", this.DefaultHeader) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.ReplaceSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AppendServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.ReplaceSpecType_AppendServerName{` +
		`AppendServerName:` + fmt.Sprintf("%#v", this.AppendServerName) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_PassThrough) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.ReplaceSpecType_PassThrough{` +
		`PassThrough:` + fmt.Sprintf("%#v", this.PassThrough) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 44)
	s = append(s, "&virtual_host.GetSpecType{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	if this.AdvertisePolicies != nil {
		s = append(s, "AdvertisePolicies: "+fmt.Sprintf("%#v", this.AdvertisePolicies)+",\n")
	}
	if this.RequestHeadersToAdd != nil {
		s = append(s, "RequestHeadersToAdd: "+fmt.Sprintf("%#v", this.RequestHeadersToAdd)+",\n")
	}
	if this.ResponseHeadersToAdd != nil {
		s = append(s, "ResponseHeadersToAdd: "+fmt.Sprintf("%#v", this.ResponseHeadersToAdd)+",\n")
	}
	s = append(s, "RequestHeadersToRemove: "+fmt.Sprintf("%#v", this.RequestHeadersToRemove)+",\n")
	s = append(s, "ResponseHeadersToRemove: "+fmt.Sprintf("%#v", this.ResponseHeadersToRemove)+",\n")
	if this.TlsParameters != nil {
		s = append(s, "TlsParameters: "+fmt.Sprintf("%#v", this.TlsParameters)+",\n")
	}
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.BufferPolicy != nil {
		s = append(s, "BufferPolicy: "+fmt.Sprintf("%#v", this.BufferPolicy)+",\n")
	}
	if this.CorsPolicy != nil {
		s = append(s, "CorsPolicy: "+fmt.Sprintf("%#v", this.CorsPolicy)+",\n")
	}
	s = append(s, "Proxy: "+fmt.Sprintf("%#v", this.Proxy)+",\n")
	if this.WafType != nil {
		s = append(s, "WafType: "+fmt.Sprintf("%#v", this.WafType)+",\n")
	}
	if this.DynamicReverseProxy != nil {
		s = append(s, "DynamicReverseProxy: "+fmt.Sprintf("%#v", this.DynamicReverseProxy)+",\n")
	}
	s = append(s, "AddLocation: "+fmt.Sprintf("%#v", this.AddLocation)+",\n")
	if this.CompressionParams != nil {
		s = append(s, "CompressionParams: "+fmt.Sprintf("%#v", this.CompressionParams)+",\n")
	}
	keysForCustomErrors := make([]uint32, 0, len(this.CustomErrors))
	for k, _ := range this.CustomErrors {
		keysForCustomErrors = append(keysForCustomErrors, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForCustomErrors)
	mapStringForCustomErrors := "map[uint32]string{"
	for _, k := range keysForCustomErrors {
		mapStringForCustomErrors += fmt.Sprintf("%#v: %#v,", k, this.CustomErrors[k])
	}
	mapStringForCustomErrors += "}"
	if this.CustomErrors != nil {
		s = append(s, "CustomErrors: "+mapStringForCustomErrors+",\n")
	}
	s = append(s, "DisableDefaultErrorPages: "+fmt.Sprintf("%#v", this.DisableDefaultErrorPages)+",\n")
	s = append(s, "MaxRequestHeaderSize: "+fmt.Sprintf("%#v", this.MaxRequestHeaderSize)+",\n")
	if this.ChallengeType != nil {
		s = append(s, "ChallengeType: "+fmt.Sprintf("%#v", this.ChallengeType)+",\n")
	}
	if this.UserIdentification != nil {
		s = append(s, "UserIdentification: "+fmt.Sprintf("%#v", this.UserIdentification)+",\n")
	}
	if this.RateLimiter != nil {
		s = append(s, "RateLimiter: "+fmt.Sprintf("%#v", this.RateLimiter)+",\n")
	}
	if this.RateLimiterAllowedPrefixes != nil {
		s = append(s, "RateLimiterAllowedPrefixes: "+fmt.Sprintf("%#v", this.RateLimiterAllowedPrefixes)+",\n")
	}
	if this.RetryPolicy != nil {
		s = append(s, "RetryPolicy: "+fmt.Sprintf("%#v", this.RetryPolicy)+",\n")
	}
	s = append(s, "IdleTimeout: "+fmt.Sprintf("%#v", this.IdleTimeout)+",\n")
	if this.TemporaryUserBlocking != nil {
		s = append(s, "TemporaryUserBlocking: "+fmt.Sprintf("%#v", this.TemporaryUserBlocking)+",\n")
	}
	if this.AuthenticationChoice != nil {
		s = append(s, "AuthenticationChoice: "+fmt.Sprintf("%#v", this.AuthenticationChoice)+",\n")
	}
	if this.ServerHeaderChoice != nil {
		s = append(s, "ServerHeaderChoice: "+fmt.Sprintf("%#v", this.ServerHeaderChoice)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "HostName: "+fmt.Sprintf("%#v", this.HostName)+",\n")
	if this.DnsInfo != nil {
		s = append(s, "DnsInfo: "+fmt.Sprintf("%#v", this.DnsInfo)+",\n")
	}
	s = append(s, "AutoCertState: "+fmt.Sprintf("%#v", this.AutoCertState)+",\n")
	if this.AutoCertInfo != nil {
		s = append(s, "AutoCertInfo: "+fmt.Sprintf("%#v", this.AutoCertInfo)+",\n")
	}
	s = append(s, "DisableDnsResolve: "+fmt.Sprintf("%#v", this.DisableDnsResolve)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_NoChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GetSpecType_NoChallenge{` +
		`NoChallenge:` + fmt.Sprintf("%#v", this.NoChallenge) + `}`}, ", ")
	return s
}
func (this *GetSpecType_JsChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GetSpecType_JsChallenge{` +
		`JsChallenge:` + fmt.Sprintf("%#v", this.JsChallenge) + `}`}, ", ")
	return s
}
func (this *GetSpecType_CaptchaChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GetSpecType_CaptchaChallenge{` +
		`CaptchaChallenge:` + fmt.Sprintf("%#v", this.CaptchaChallenge) + `}`}, ", ")
	return s
}
func (this *GetSpecType_NoAuthentication) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GetSpecType_NoAuthentication{` +
		`NoAuthentication:` + fmt.Sprintf("%#v", this.NoAuthentication) + `}`}, ", ")
	return s
}
func (this *GetSpecType_Authentication) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GetSpecType_Authentication{` +
		`Authentication:` + fmt.Sprintf("%#v", this.Authentication) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DefaultHeader) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GetSpecType_DefaultHeader{` +
		`DefaultHeader:` + fmt.Sprintf("%#v", this.DefaultHeader) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GetSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AppendServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GetSpecType_AppendServerName{` +
		`AppendServerName:` + fmt.Sprintf("%#v", this.AppendServerName) + `}`}, ", ")
	return s
}
func (this *GetSpecType_PassThrough) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&virtual_host.GetSpecType_PassThrough{` +
		`PassThrough:` + fmt.Sprintf("%#v", this.PassThrough) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *JavaScriptConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JavaScriptConfigType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JavaScriptConfigType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CustomScriptUrl) > 0 {
		i -= len(m.CustomScriptUrl)
		copy(dAtA[i:], m.CustomScriptUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CustomScriptUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ScriptConfig != nil {
		{
			size, err := m.ScriptConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.CachePrefix) > 0 {
		i -= len(m.CachePrefix)
		copy(dAtA[i:], m.CachePrefix)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CachePrefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DynamicReverseProxyType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicReverseProxyType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DynamicReverseProxyType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConnectionTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ConnectionTimeout))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ResolutionNetwork) > 0 {
		for iNdEx := len(m.ResolutionNetwork) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResolutionNetwork[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ResolutionNetworkType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ResolutionNetworkType))
		i--
		dAtA[i] = 0x10
	}
	if m.ResolveEndpointDynamically {
		i--
		if m.ResolveEndpointDynamically {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CompressionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompressionType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompressionType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RemoveAcceptEncodingHeader {
		i--
		if m.RemoveAcceptEncodingHeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.DisableOnEtagHeader {
		i--
		if m.DisableOnEtagHeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ContentType) > 0 {
		for iNdEx := len(m.ContentType) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ContentType[iNdEx])
			copy(dAtA[i:], m.ContentType[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ContentType[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ContentLength != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ContentLength))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *JavascriptChallengeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JavascriptChallengeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JavascriptChallengeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CustomPage) > 0 {
		i -= len(m.CustomPage)
		copy(dAtA[i:], m.CustomPage)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CustomPage)))
		i--
		dAtA[i] = 0x22
	}
	if m.CookieExpiry != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CookieExpiry))
		i--
		dAtA[i] = 0x18
	}
	if m.JsScriptDelay != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.JsScriptDelay))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *CaptchaChallengeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CaptchaChallengeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CaptchaChallengeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CustomPage) > 0 {
		i -= len(m.CustomPage)
		copy(dAtA[i:], m.CustomPage)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CustomPage)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CookieExpiry != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CookieExpiry))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *TemporaryUserBlockingType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TemporaryUserBlockingType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TemporaryUserBlockingType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CustomPage) > 0 {
		i -= len(m.CustomPage)
		copy(dAtA[i:], m.CustomPage)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CustomPage)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AutoCertInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoCertInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutoCertInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AutoCertIssuer) > 0 {
		i -= len(m.AutoCertIssuer)
		copy(dAtA[i:], m.AutoCertIssuer)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AutoCertIssuer)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AutoCertSubject) > 0 {
		i -= len(m.AutoCertSubject)
		copy(dAtA[i:], m.AutoCertSubject)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AutoCertSubject)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AutoCertExpiry != nil {
		{
			size, err := m.AutoCertExpiry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.AutoCertState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AutoCertState))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AuthenticationDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticationDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticationDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RedirectUrlChoice != nil {
		{
			size := m.RedirectUrlChoice.Size()
			i -= size
			if _, err := m.RedirectUrlChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.CookieParamsChoice != nil {
		{
			size := m.CookieParamsChoice.Size()
			i -= size
			if _, err := m.CookieParamsChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.AuthConfig) > 0 {
		for iNdEx := len(m.AuthConfig) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AuthConfig[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AuthenticationDetails_UseAuthObjectConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticationDetails_UseAuthObjectConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseAuthObjectConfig != nil {
		{
			size, err := m.UseAuthObjectConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AuthenticationDetails_CookieParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticationDetails_CookieParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CookieParams != nil {
		{
			size, err := m.CookieParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AuthenticationDetails_RedirectUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticationDetails_RedirectUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.RedirectUrl)
	copy(dAtA[i:], m.RedirectUrl)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.RedirectUrl)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *AuthenticationDetails_RedirectDynamic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticationDetails_RedirectDynamic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RedirectDynamic != nil {
		{
			size, err := m.RedirectDynamic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *PolicyBasedChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyBasedChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyBasedChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MaliciousUserMitigation) > 0 {
		for iNdEx := len(m.MaliciousUserMitigation) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MaliciousUserMitigation[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.ChallengeChoice != nil {
		{
			size := m.ChallengeChoice.Size()
			i -= size
			if _, err := m.ChallengeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TemporaryUserBlocking != nil {
		{
			size, err := m.TemporaryUserBlocking.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CaptchaChallenge != nil {
		{
			size, err := m.CaptchaChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.JsChallenge != nil {
		{
			size, err := m.JsChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PolicyBasedChallenge_NoChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyBasedChallenge_NoChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoChallenge != nil {
		{
			size, err := m.NoChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *PolicyBasedChallenge_AlwaysEnableJsChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyBasedChallenge_AlwaysEnableJsChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlwaysEnableJsChallenge != nil {
		{
			size, err := m.AlwaysEnableJsChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *PolicyBasedChallenge_AlwaysEnableCaptchaChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyBasedChallenge_AlwaysEnableCaptchaChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlwaysEnableCaptchaChallenge != nil {
		{
			size, err := m.AlwaysEnableCaptchaChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VolterraCert {
		i--
		if m.VolterraCert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3f
		i--
		dAtA[i] = 0xb0
	}
	if m.LoadbalancerAlgorithm != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LoadbalancerAlgorithm))
		i--
		dAtA[i] = 0x3f
		i--
		dAtA[i] = 0xa8
	}
	if len(m.ServicePolicySets) > 0 {
		for iNdEx := len(m.ServicePolicySets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ServicePolicySets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3f
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.UserDomains) > 0 {
		for iNdEx := len(m.UserDomains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UserDomains[iNdEx])
			copy(dAtA[i:], m.UserDomains[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.UserDomains[iNdEx])))
			i--
			dAtA[i] = 0x3f
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.AutoCertInfo != nil {
		{
			size, err := m.AutoCertInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3f
		i--
		dAtA[i] = 0x92
	}
	if m.AutoCertState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AutoCertState))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xf0
	}
	if len(m.DnsInfo) > 0 {
		for iNdEx := len(m.DnsInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DnsInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xe2
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xd8
	}
	if m.AutoCert {
		i--
		if m.AutoCert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xd0
	}
	if len(m.DnsDomains) > 0 {
		for iNdEx := len(m.DnsDomains) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DnsDomains[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xca
		}
	}
	if m.DnsVolterraManaged {
		i--
		if m.DnsVolterraManaged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc0
	}
	if m.ServerHeaderChoice != nil {
		{
			size := m.ServerHeaderChoice.Size()
			i -= size
			if _, err := m.ServerHeaderChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ChallengeType != nil {
		{
			size := m.ChallengeType.Size()
			i -= size
			if _, err := m.ChallengeType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AuthenticationChoice != nil {
		{
			size := m.AuthenticationChoice.Size()
			i -= size
			if _, err := m.AuthenticationChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TlsIntercept != nil {
		{
			size, err := m.TlsIntercept.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if len(m.MaliciousUserMitigation) > 0 {
		for iNdEx := len(m.MaliciousUserMitigation) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MaliciousUserMitigation[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.TemporaryUserBlocking != nil {
		{
			size, err := m.TemporaryUserBlocking.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.DisableDnsResolve {
		i--
		if m.DisableDnsResolve {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.DisableDefaultErrorPages {
		i--
		if m.DisableDefaultErrorPages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.IdleTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IdleTimeout))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.RetryPolicy != nil {
		{
			size, err := m.RetryPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.RateLimiterAllowedPrefixes) > 0 {
		for iNdEx := len(m.RateLimiterAllowedPrefixes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimiterAllowedPrefixes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.RateLimiter) > 0 {
		for iNdEx := len(m.RateLimiter) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimiter[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.UserIdentification) > 0 {
		for iNdEx := len(m.UserIdentification) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserIdentification[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if m.MaxRequestHeaderSize != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRequestHeaderSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.CustomErrors) > 0 {
		keysForCustomErrors := make([]uint32, 0, len(m.CustomErrors))
		for k := range m.CustomErrors {
			keysForCustomErrors = append(keysForCustomErrors, uint32(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint32s(keysForCustomErrors)
		for iNdEx := len(keysForCustomErrors) - 1; iNdEx >= 0; iNdEx-- {
			v := m.CustomErrors[uint32(keysForCustomErrors[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintTypes(dAtA, i, uint64(keysForCustomErrors[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.CompressionParams != nil {
		{
			size, err := m.CompressionParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.AddLocation {
		i--
		if m.AddLocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.DynamicReverseProxy != nil {
		{
			size, err := m.DynamicReverseProxy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.WafType != nil {
		{
			size, err := m.WafType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for iNdEx := len(m.RequestHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.RequestHeadersToRemove[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.Jwt) > 0 {
		for iNdEx := len(m.Jwt) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Jwt[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.Proxy != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Proxy))
		i--
		dAtA[i] = 0x78
	}
	if m.CorsPolicy != nil {
		{
			size, err := m.CorsPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.BufferPolicy != nil {
		{
			size, err := m.BufferPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x50
	}
	if m.TlsParameters != nil {
		{
			size, err := m.TlsParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for iNdEx := len(m.ResponseHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResponseHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.ResponseHeadersToRemove[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ResponseHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for iNdEx := len(m.ResponseHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResponseHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for iNdEx := len(m.RequestHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequestHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.AdvertisePolicies) > 0 {
		for iNdEx := len(m.AdvertisePolicies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AdvertisePolicies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.JavascriptInfo != nil {
		{
			size, err := m.JavascriptInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Domains) > 0 {
		for iNdEx := len(m.Domains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Domains[iNdEx])
			copy(dAtA[i:], m.Domains[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Domains[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_JsChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_JsChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JsChallenge != nil {
		{
			size, err := m.JsChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_CaptchaChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_CaptchaChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CaptchaChallenge != nil {
		{
			size, err := m.CaptchaChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_NoChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_NoChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoChallenge != nil {
		{
			size, err := m.NoChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_NoAuthentication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_NoAuthentication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoAuthentication != nil {
		{
			size, err := m.NoAuthentication.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_Authentication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Authentication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Authentication != nil {
		{
			size, err := m.Authentication.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_PolicyBasedChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_PolicyBasedChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PolicyBasedChallenge != nil {
		{
			size, err := m.PolicyBasedChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DefaultHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DefaultHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultHeader != nil {
		{
			size, err := m.DefaultHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServerName)
	copy(dAtA[i:], m.ServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xe2
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AppendServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AppendServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.AppendServerName)
	copy(dAtA[i:], m.AppendServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.AppendServerName)))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xea
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_PassThrough) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_PassThrough) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PassThrough != nil {
		{
			size, err := m.PassThrough.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ServerHeaderChoice != nil {
		{
			size := m.ServerHeaderChoice.Size()
			i -= size
			if _, err := m.ServerHeaderChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AuthenticationChoice != nil {
		{
			size := m.AuthenticationChoice.Size()
			i -= size
			if _, err := m.AuthenticationChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TemporaryUserBlocking != nil {
		{
			size, err := m.TemporaryUserBlocking.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.DisableDnsResolve {
		i--
		if m.DisableDnsResolve {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.DisableDefaultErrorPages {
		i--
		if m.DisableDefaultErrorPages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.IdleTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IdleTimeout))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.ChallengeType != nil {
		{
			size := m.ChallengeType.Size()
			i -= size
			if _, err := m.ChallengeType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.RetryPolicy != nil {
		{
			size, err := m.RetryPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.RateLimiterAllowedPrefixes) > 0 {
		for iNdEx := len(m.RateLimiterAllowedPrefixes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimiterAllowedPrefixes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.RateLimiter) > 0 {
		for iNdEx := len(m.RateLimiter) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimiter[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.UserIdentification) > 0 {
		for iNdEx := len(m.UserIdentification) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserIdentification[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if m.MaxRequestHeaderSize != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRequestHeaderSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.CustomErrors) > 0 {
		keysForCustomErrors := make([]uint32, 0, len(m.CustomErrors))
		for k := range m.CustomErrors {
			keysForCustomErrors = append(keysForCustomErrors, uint32(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint32s(keysForCustomErrors)
		for iNdEx := len(keysForCustomErrors) - 1; iNdEx >= 0; iNdEx-- {
			v := m.CustomErrors[uint32(keysForCustomErrors[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintTypes(dAtA, i, uint64(keysForCustomErrors[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.CompressionParams != nil {
		{
			size, err := m.CompressionParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.AddLocation {
		i--
		if m.AddLocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.DynamicReverseProxy != nil {
		{
			size, err := m.DynamicReverseProxy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.WafType != nil {
		{
			size, err := m.WafType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for iNdEx := len(m.RequestHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.RequestHeadersToRemove[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.Proxy != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Proxy))
		i--
		dAtA[i] = 0x78
	}
	if m.CorsPolicy != nil {
		{
			size, err := m.CorsPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.BufferPolicy != nil {
		{
			size, err := m.BufferPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.TlsParameters != nil {
		{
			size, err := m.TlsParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for iNdEx := len(m.ResponseHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResponseHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.ResponseHeadersToRemove[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ResponseHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for iNdEx := len(m.ResponseHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResponseHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for iNdEx := len(m.RequestHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequestHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.AdvertisePolicies) > 0 {
		for iNdEx := len(m.AdvertisePolicies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AdvertisePolicies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Domains) > 0 {
		for iNdEx := len(m.Domains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Domains[iNdEx])
			copy(dAtA[i:], m.Domains[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Domains[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_JsChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_JsChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JsChallenge != nil {
		{
			size, err := m.JsChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_CaptchaChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_CaptchaChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CaptchaChallenge != nil {
		{
			size, err := m.CaptchaChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_NoChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_NoChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoChallenge != nil {
		{
			size, err := m.NoChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_NoAuthentication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_NoAuthentication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoAuthentication != nil {
		{
			size, err := m.NoAuthentication.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_Authentication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_Authentication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Authentication != nil {
		{
			size, err := m.Authentication.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DefaultHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DefaultHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultHeader != nil {
		{
			size, err := m.DefaultHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServerName)
	copy(dAtA[i:], m.ServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xe2
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_AppendServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AppendServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.AppendServerName)
	copy(dAtA[i:], m.AppendServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.AppendServerName)))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xea
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_PassThrough) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_PassThrough) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PassThrough != nil {
		{
			size, err := m.PassThrough.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ServerHeaderChoice != nil {
		{
			size := m.ServerHeaderChoice.Size()
			i -= size
			if _, err := m.ServerHeaderChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AuthenticationChoice != nil {
		{
			size := m.AuthenticationChoice.Size()
			i -= size
			if _, err := m.AuthenticationChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TemporaryUserBlocking != nil {
		{
			size, err := m.TemporaryUserBlocking.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.DisableDnsResolve {
		i--
		if m.DisableDnsResolve {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.DisableDefaultErrorPages {
		i--
		if m.DisableDefaultErrorPages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.IdleTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IdleTimeout))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.ChallengeType != nil {
		{
			size := m.ChallengeType.Size()
			i -= size
			if _, err := m.ChallengeType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.RetryPolicy != nil {
		{
			size, err := m.RetryPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.RateLimiterAllowedPrefixes) > 0 {
		for iNdEx := len(m.RateLimiterAllowedPrefixes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimiterAllowedPrefixes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.RateLimiter) > 0 {
		for iNdEx := len(m.RateLimiter) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimiter[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.UserIdentification) > 0 {
		for iNdEx := len(m.UserIdentification) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserIdentification[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if m.MaxRequestHeaderSize != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRequestHeaderSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.CustomErrors) > 0 {
		keysForCustomErrors := make([]uint32, 0, len(m.CustomErrors))
		for k := range m.CustomErrors {
			keysForCustomErrors = append(keysForCustomErrors, uint32(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint32s(keysForCustomErrors)
		for iNdEx := len(keysForCustomErrors) - 1; iNdEx >= 0; iNdEx-- {
			v := m.CustomErrors[uint32(keysForCustomErrors[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintTypes(dAtA, i, uint64(keysForCustomErrors[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.CompressionParams != nil {
		{
			size, err := m.CompressionParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.AddLocation {
		i--
		if m.AddLocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.DynamicReverseProxy != nil {
		{
			size, err := m.DynamicReverseProxy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.WafType != nil {
		{
			size, err := m.WafType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for iNdEx := len(m.RequestHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.RequestHeadersToRemove[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.Proxy != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Proxy))
		i--
		dAtA[i] = 0x78
	}
	if m.CorsPolicy != nil {
		{
			size, err := m.CorsPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.BufferPolicy != nil {
		{
			size, err := m.BufferPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.TlsParameters != nil {
		{
			size, err := m.TlsParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for iNdEx := len(m.ResponseHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResponseHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.ResponseHeadersToRemove[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ResponseHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for iNdEx := len(m.ResponseHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResponseHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for iNdEx := len(m.RequestHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequestHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.AdvertisePolicies) > 0 {
		for iNdEx := len(m.AdvertisePolicies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AdvertisePolicies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Domains) > 0 {
		for iNdEx := len(m.Domains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Domains[iNdEx])
			copy(dAtA[i:], m.Domains[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Domains[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_JsChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_JsChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JsChallenge != nil {
		{
			size, err := m.JsChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_CaptchaChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_CaptchaChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CaptchaChallenge != nil {
		{
			size, err := m.CaptchaChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_NoChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_NoChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoChallenge != nil {
		{
			size, err := m.NoChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_NoAuthentication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_NoAuthentication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoAuthentication != nil {
		{
			size, err := m.NoAuthentication.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_Authentication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_Authentication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Authentication != nil {
		{
			size, err := m.Authentication.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DefaultHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DefaultHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultHeader != nil {
		{
			size, err := m.DefaultHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServerName)
	copy(dAtA[i:], m.ServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xe2
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_AppendServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AppendServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.AppendServerName)
	copy(dAtA[i:], m.AppendServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.AppendServerName)))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xea
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_PassThrough) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_PassThrough) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PassThrough != nil {
		{
			size, err := m.PassThrough.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AutoCertInfo != nil {
		{
			size, err := m.AutoCertInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3f
		i--
		dAtA[i] = 0x92
	}
	if m.AutoCertState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AutoCertState))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xf0
	}
	if len(m.DnsInfo) > 0 {
		for iNdEx := len(m.DnsInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DnsInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xe2
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xd8
	}
	if m.ServerHeaderChoice != nil {
		{
			size := m.ServerHeaderChoice.Size()
			i -= size
			if _, err := m.ServerHeaderChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AuthenticationChoice != nil {
		{
			size := m.AuthenticationChoice.Size()
			i -= size
			if _, err := m.AuthenticationChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TemporaryUserBlocking != nil {
		{
			size, err := m.TemporaryUserBlocking.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.DisableDnsResolve {
		i--
		if m.DisableDnsResolve {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.DisableDefaultErrorPages {
		i--
		if m.DisableDefaultErrorPages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.IdleTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IdleTimeout))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.ChallengeType != nil {
		{
			size := m.ChallengeType.Size()
			i -= size
			if _, err := m.ChallengeType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.RetryPolicy != nil {
		{
			size, err := m.RetryPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.RateLimiterAllowedPrefixes) > 0 {
		for iNdEx := len(m.RateLimiterAllowedPrefixes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimiterAllowedPrefixes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.RateLimiter) > 0 {
		for iNdEx := len(m.RateLimiter) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimiter[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.UserIdentification) > 0 {
		for iNdEx := len(m.UserIdentification) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserIdentification[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if m.MaxRequestHeaderSize != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRequestHeaderSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.CustomErrors) > 0 {
		keysForCustomErrors := make([]uint32, 0, len(m.CustomErrors))
		for k := range m.CustomErrors {
			keysForCustomErrors = append(keysForCustomErrors, uint32(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint32s(keysForCustomErrors)
		for iNdEx := len(keysForCustomErrors) - 1; iNdEx >= 0; iNdEx-- {
			v := m.CustomErrors[uint32(keysForCustomErrors[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintTypes(dAtA, i, uint64(keysForCustomErrors[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.CompressionParams != nil {
		{
			size, err := m.CompressionParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.AddLocation {
		i--
		if m.AddLocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.DynamicReverseProxy != nil {
		{
			size, err := m.DynamicReverseProxy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.WafType != nil {
		{
			size, err := m.WafType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for iNdEx := len(m.RequestHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.RequestHeadersToRemove[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.Proxy != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Proxy))
		i--
		dAtA[i] = 0x78
	}
	if m.CorsPolicy != nil {
		{
			size, err := m.CorsPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.BufferPolicy != nil {
		{
			size, err := m.BufferPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x50
	}
	if m.TlsParameters != nil {
		{
			size, err := m.TlsParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for iNdEx := len(m.ResponseHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResponseHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.ResponseHeadersToRemove[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ResponseHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for iNdEx := len(m.ResponseHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResponseHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for iNdEx := len(m.RequestHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequestHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.AdvertisePolicies) > 0 {
		for iNdEx := len(m.AdvertisePolicies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AdvertisePolicies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Domains) > 0 {
		for iNdEx := len(m.Domains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Domains[iNdEx])
			copy(dAtA[i:], m.Domains[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Domains[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_JsChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_JsChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JsChallenge != nil {
		{
			size, err := m.JsChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_CaptchaChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_CaptchaChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CaptchaChallenge != nil {
		{
			size, err := m.CaptchaChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_NoChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_NoChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoChallenge != nil {
		{
			size, err := m.NoChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_NoAuthentication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_NoAuthentication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoAuthentication != nil {
		{
			size, err := m.NoAuthentication.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_Authentication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_Authentication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Authentication != nil {
		{
			size, err := m.Authentication.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DefaultHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DefaultHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultHeader != nil {
		{
			size, err := m.DefaultHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServerName)
	copy(dAtA[i:], m.ServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xe2
	return len(dAtA) - i, nil
}
func (m *GetSpecType_AppendServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AppendServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.AppendServerName)
	copy(dAtA[i:], m.AppendServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.AppendServerName)))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xea
	return len(dAtA) - i, nil
}
func (m *GetSpecType_PassThrough) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_PassThrough) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PassThrough != nil {
		{
			size, err := m.PassThrough.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *JavaScriptConfigType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CachePrefix)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ScriptConfig != nil {
		l = m.ScriptConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CustomScriptUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *DynamicReverseProxyType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResolveEndpointDynamically {
		n += 2
	}
	if m.ResolutionNetworkType != 0 {
		n += 1 + sovTypes(uint64(m.ResolutionNetworkType))
	}
	if len(m.ResolutionNetwork) > 0 {
		for _, e := range m.ResolutionNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.ConnectionTimeout != 0 {
		n += 1 + sovTypes(uint64(m.ConnectionTimeout))
	}
	return n
}

func (m *CompressionType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContentLength != 0 {
		n += 1 + sovTypes(uint64(m.ContentLength))
	}
	if len(m.ContentType) > 0 {
		for _, s := range m.ContentType {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DisableOnEtagHeader {
		n += 2
	}
	if m.RemoveAcceptEncodingHeader {
		n += 2
	}
	return n
}

func (m *JavascriptChallengeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JsScriptDelay != 0 {
		n += 1 + sovTypes(uint64(m.JsScriptDelay))
	}
	if m.CookieExpiry != 0 {
		n += 1 + sovTypes(uint64(m.CookieExpiry))
	}
	l = len(m.CustomPage)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CaptchaChallengeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CookieExpiry != 0 {
		n += 1 + sovTypes(uint64(m.CookieExpiry))
	}
	l = len(m.CustomPage)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TemporaryUserBlockingType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CustomPage)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AutoCertInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutoCertState != 0 {
		n += 1 + sovTypes(uint64(m.AutoCertState))
	}
	if m.AutoCertExpiry != nil {
		l = m.AutoCertExpiry.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AutoCertSubject)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AutoCertIssuer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AuthenticationDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AuthConfig) > 0 {
		for _, e := range m.AuthConfig {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.CookieParamsChoice != nil {
		n += m.CookieParamsChoice.Size()
	}
	if m.RedirectUrlChoice != nil {
		n += m.RedirectUrlChoice.Size()
	}
	return n
}

func (m *AuthenticationDetails_UseAuthObjectConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseAuthObjectConfig != nil {
		l = m.UseAuthObjectConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AuthenticationDetails_CookieParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CookieParams != nil {
		l = m.CookieParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AuthenticationDetails_RedirectUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RedirectUrl)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *AuthenticationDetails_RedirectDynamic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RedirectDynamic != nil {
		l = m.RedirectDynamic.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PolicyBasedChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JsChallenge != nil {
		l = m.JsChallenge.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CaptchaChallenge != nil {
		l = m.CaptchaChallenge.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TemporaryUserBlocking != nil {
		l = m.TemporaryUserBlocking.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ChallengeChoice != nil {
		n += m.ChallengeChoice.Size()
	}
	if len(m.MaliciousUserMitigation) > 0 {
		for _, e := range m.MaliciousUserMitigation {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PolicyBasedChallenge_NoChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoChallenge != nil {
		l = m.NoChallenge.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PolicyBasedChallenge_AlwaysEnableJsChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlwaysEnableJsChallenge != nil {
		l = m.AlwaysEnableJsChallenge.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PolicyBasedChallenge_AlwaysEnableCaptchaChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlwaysEnableCaptchaChallenge != nil {
		l = m.AlwaysEnableCaptchaChallenge.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.JavascriptInfo != nil {
		l = m.JavascriptInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AdvertisePolicies) > 0 {
		for _, e := range m.AdvertisePolicies {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, e := range m.ResponseHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.TlsParameters != nil {
		l = m.TlsParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.BufferPolicy != nil {
		l = m.BufferPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CorsPolicy != nil {
		l = m.CorsPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Proxy != 0 {
		n += 1 + sovTypes(uint64(m.Proxy))
	}
	if len(m.Jwt) > 0 {
		for _, e := range m.Jwt {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.WafType != nil {
		l = m.WafType.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DynamicReverseProxy != nil {
		l = m.DynamicReverseProxy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AddLocation {
		n += 3
	}
	if m.CompressionParams != nil {
		l = m.CompressionParams.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.CustomErrors) > 0 {
		for k, v := range m.CustomErrors {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTypes(uint64(k)) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.MaxRequestHeaderSize != 0 {
		n += 2 + sovTypes(uint64(m.MaxRequestHeaderSize))
	}
	if m.ChallengeType != nil {
		n += m.ChallengeType.Size()
	}
	if len(m.UserIdentification) > 0 {
		for _, e := range m.UserIdentification {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RateLimiter) > 0 {
		for _, e := range m.RateLimiter {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RateLimiterAllowedPrefixes) > 0 {
		for _, e := range m.RateLimiterAllowedPrefixes {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.RetryPolicy != nil {
		l = m.RetryPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.IdleTimeout != 0 {
		n += 2 + sovTypes(uint64(m.IdleTimeout))
	}
	if m.DisableDefaultErrorPages {
		n += 3
	}
	if m.DisableDnsResolve {
		n += 3
	}
	if m.TemporaryUserBlocking != nil {
		l = m.TemporaryUserBlocking.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.MaliciousUserMitigation) > 0 {
		for _, e := range m.MaliciousUserMitigation {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.TlsIntercept != nil {
		l = m.TlsIntercept.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AuthenticationChoice != nil {
		n += m.AuthenticationChoice.Size()
	}
	if m.ServerHeaderChoice != nil {
		n += m.ServerHeaderChoice.Size()
	}
	if m.DnsVolterraManaged {
		n += 3
	}
	if len(m.DnsDomains) > 0 {
		for _, e := range m.DnsDomains {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.AutoCert {
		n += 3
	}
	if m.State != 0 {
		n += 2 + sovTypes(uint64(m.State))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.DnsInfo) > 0 {
		for _, e := range m.DnsInfo {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.AutoCertState != 0 {
		n += 2 + sovTypes(uint64(m.AutoCertState))
	}
	if m.AutoCertInfo != nil {
		l = m.AutoCertInfo.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.UserDomains) > 0 {
		for _, s := range m.UserDomains {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ServicePolicySets) > 0 {
		for _, e := range m.ServicePolicySets {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.LoadbalancerAlgorithm != 0 {
		n += 2 + sovTypes(uint64(m.LoadbalancerAlgorithm))
	}
	if m.VolterraCert {
		n += 3
	}
	return n
}

func (m *GlobalSpecType_JsChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JsChallenge != nil {
		l = m.JsChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_CaptchaChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CaptchaChallenge != nil {
		l = m.CaptchaChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_NoChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoChallenge != nil {
		l = m.NoChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_NoAuthentication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoAuthentication != nil {
		l = m.NoAuthentication.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Authentication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Authentication != nil {
		l = m.Authentication.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_PolicyBasedChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PolicyBasedChallenge != nil {
		l = m.PolicyBasedChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DefaultHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultHeader != nil {
		l = m.DefaultHeader.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_ServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	n += 2 + l + sovTypes(uint64(l))
	return n
}
func (m *GlobalSpecType_AppendServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppendServerName)
	n += 2 + l + sovTypes(uint64(l))
	return n
}
func (m *GlobalSpecType_PassThrough) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PassThrough != nil {
		l = m.PassThrough.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AdvertisePolicies) > 0 {
		for _, e := range m.AdvertisePolicies {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, e := range m.ResponseHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.TlsParameters != nil {
		l = m.TlsParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BufferPolicy != nil {
		l = m.BufferPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CorsPolicy != nil {
		l = m.CorsPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Proxy != 0 {
		n += 1 + sovTypes(uint64(m.Proxy))
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.WafType != nil {
		l = m.WafType.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DynamicReverseProxy != nil {
		l = m.DynamicReverseProxy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AddLocation {
		n += 3
	}
	if m.CompressionParams != nil {
		l = m.CompressionParams.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.CustomErrors) > 0 {
		for k, v := range m.CustomErrors {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTypes(uint64(k)) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.MaxRequestHeaderSize != 0 {
		n += 2 + sovTypes(uint64(m.MaxRequestHeaderSize))
	}
	if m.ChallengeType != nil {
		n += m.ChallengeType.Size()
	}
	if len(m.UserIdentification) > 0 {
		for _, e := range m.UserIdentification {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RateLimiter) > 0 {
		for _, e := range m.RateLimiter {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RateLimiterAllowedPrefixes) > 0 {
		for _, e := range m.RateLimiterAllowedPrefixes {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.RetryPolicy != nil {
		l = m.RetryPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.IdleTimeout != 0 {
		n += 2 + sovTypes(uint64(m.IdleTimeout))
	}
	if m.DisableDefaultErrorPages {
		n += 3
	}
	if m.DisableDnsResolve {
		n += 3
	}
	if m.TemporaryUserBlocking != nil {
		l = m.TemporaryUserBlocking.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AuthenticationChoice != nil {
		n += m.AuthenticationChoice.Size()
	}
	if m.ServerHeaderChoice != nil {
		n += m.ServerHeaderChoice.Size()
	}
	return n
}

func (m *CreateSpecType_JsChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JsChallenge != nil {
		l = m.JsChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_CaptchaChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CaptchaChallenge != nil {
		l = m.CaptchaChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_NoChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoChallenge != nil {
		l = m.NoChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_NoAuthentication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoAuthentication != nil {
		l = m.NoAuthentication.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_Authentication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Authentication != nil {
		l = m.Authentication.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DefaultHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultHeader != nil {
		l = m.DefaultHeader.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_ServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	n += 2 + l + sovTypes(uint64(l))
	return n
}
func (m *CreateSpecType_AppendServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppendServerName)
	n += 2 + l + sovTypes(uint64(l))
	return n
}
func (m *CreateSpecType_PassThrough) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PassThrough != nil {
		l = m.PassThrough.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AdvertisePolicies) > 0 {
		for _, e := range m.AdvertisePolicies {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, e := range m.ResponseHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.TlsParameters != nil {
		l = m.TlsParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BufferPolicy != nil {
		l = m.BufferPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CorsPolicy != nil {
		l = m.CorsPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Proxy != 0 {
		n += 1 + sovTypes(uint64(m.Proxy))
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.WafType != nil {
		l = m.WafType.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DynamicReverseProxy != nil {
		l = m.DynamicReverseProxy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AddLocation {
		n += 3
	}
	if m.CompressionParams != nil {
		l = m.CompressionParams.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.CustomErrors) > 0 {
		for k, v := range m.CustomErrors {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTypes(uint64(k)) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.MaxRequestHeaderSize != 0 {
		n += 2 + sovTypes(uint64(m.MaxRequestHeaderSize))
	}
	if m.ChallengeType != nil {
		n += m.ChallengeType.Size()
	}
	if len(m.UserIdentification) > 0 {
		for _, e := range m.UserIdentification {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RateLimiter) > 0 {
		for _, e := range m.RateLimiter {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RateLimiterAllowedPrefixes) > 0 {
		for _, e := range m.RateLimiterAllowedPrefixes {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.RetryPolicy != nil {
		l = m.RetryPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.IdleTimeout != 0 {
		n += 2 + sovTypes(uint64(m.IdleTimeout))
	}
	if m.DisableDefaultErrorPages {
		n += 3
	}
	if m.DisableDnsResolve {
		n += 3
	}
	if m.TemporaryUserBlocking != nil {
		l = m.TemporaryUserBlocking.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AuthenticationChoice != nil {
		n += m.AuthenticationChoice.Size()
	}
	if m.ServerHeaderChoice != nil {
		n += m.ServerHeaderChoice.Size()
	}
	return n
}

func (m *ReplaceSpecType_JsChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JsChallenge != nil {
		l = m.JsChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_CaptchaChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CaptchaChallenge != nil {
		l = m.CaptchaChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_NoChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoChallenge != nil {
		l = m.NoChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_NoAuthentication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoAuthentication != nil {
		l = m.NoAuthentication.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_Authentication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Authentication != nil {
		l = m.Authentication.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DefaultHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultHeader != nil {
		l = m.DefaultHeader.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_ServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	n += 2 + l + sovTypes(uint64(l))
	return n
}
func (m *ReplaceSpecType_AppendServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppendServerName)
	n += 2 + l + sovTypes(uint64(l))
	return n
}
func (m *ReplaceSpecType_PassThrough) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PassThrough != nil {
		l = m.PassThrough.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AdvertisePolicies) > 0 {
		for _, e := range m.AdvertisePolicies {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, e := range m.ResponseHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.TlsParameters != nil {
		l = m.TlsParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.BufferPolicy != nil {
		l = m.BufferPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CorsPolicy != nil {
		l = m.CorsPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Proxy != 0 {
		n += 1 + sovTypes(uint64(m.Proxy))
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.WafType != nil {
		l = m.WafType.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DynamicReverseProxy != nil {
		l = m.DynamicReverseProxy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AddLocation {
		n += 3
	}
	if m.CompressionParams != nil {
		l = m.CompressionParams.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.CustomErrors) > 0 {
		for k, v := range m.CustomErrors {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTypes(uint64(k)) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.MaxRequestHeaderSize != 0 {
		n += 2 + sovTypes(uint64(m.MaxRequestHeaderSize))
	}
	if m.ChallengeType != nil {
		n += m.ChallengeType.Size()
	}
	if len(m.UserIdentification) > 0 {
		for _, e := range m.UserIdentification {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RateLimiter) > 0 {
		for _, e := range m.RateLimiter {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RateLimiterAllowedPrefixes) > 0 {
		for _, e := range m.RateLimiterAllowedPrefixes {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.RetryPolicy != nil {
		l = m.RetryPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.IdleTimeout != 0 {
		n += 2 + sovTypes(uint64(m.IdleTimeout))
	}
	if m.DisableDefaultErrorPages {
		n += 3
	}
	if m.DisableDnsResolve {
		n += 3
	}
	if m.TemporaryUserBlocking != nil {
		l = m.TemporaryUserBlocking.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AuthenticationChoice != nil {
		n += m.AuthenticationChoice.Size()
	}
	if m.ServerHeaderChoice != nil {
		n += m.ServerHeaderChoice.Size()
	}
	if m.State != 0 {
		n += 2 + sovTypes(uint64(m.State))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.DnsInfo) > 0 {
		for _, e := range m.DnsInfo {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.AutoCertState != 0 {
		n += 2 + sovTypes(uint64(m.AutoCertState))
	}
	if m.AutoCertInfo != nil {
		l = m.AutoCertInfo.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType_JsChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JsChallenge != nil {
		l = m.JsChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_CaptchaChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CaptchaChallenge != nil {
		l = m.CaptchaChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_NoChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoChallenge != nil {
		l = m.NoChallenge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_NoAuthentication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoAuthentication != nil {
		l = m.NoAuthentication.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_Authentication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Authentication != nil {
		l = m.Authentication.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DefaultHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultHeader != nil {
		l = m.DefaultHeader.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_ServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	n += 2 + l + sovTypes(uint64(l))
	return n
}
func (m *GetSpecType_AppendServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppendServerName)
	n += 2 + l + sovTypes(uint64(l))
	return n
}
func (m *GetSpecType_PassThrough) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PassThrough != nil {
		l = m.PassThrough.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *JavaScriptConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JavaScriptConfigType{`,
		`CachePrefix:` + fmt.Sprintf("%v", this.CachePrefix) + `,`,
		`ScriptConfig:` + strings.Replace(fmt.Sprintf("%v", this.ScriptConfig), "Struct", "types.Struct", 1) + `,`,
		`CustomScriptUrl:` + fmt.Sprintf("%v", this.CustomScriptUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DynamicReverseProxyType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForResolutionNetwork := "[]*ObjectRefType{"
	for _, f := range this.ResolutionNetwork {
		repeatedStringForResolutionNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForResolutionNetwork += "}"
	s := strings.Join([]string{`&DynamicReverseProxyType{`,
		`ResolveEndpointDynamically:` + fmt.Sprintf("%v", this.ResolveEndpointDynamically) + `,`,
		`ResolutionNetworkType:` + fmt.Sprintf("%v", this.ResolutionNetworkType) + `,`,
		`ResolutionNetwork:` + repeatedStringForResolutionNetwork + `,`,
		`ConnectionTimeout:` + fmt.Sprintf("%v", this.ConnectionTimeout) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CompressionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CompressionType{`,
		`ContentLength:` + fmt.Sprintf("%v", this.ContentLength) + `,`,
		`ContentType:` + fmt.Sprintf("%v", this.ContentType) + `,`,
		`DisableOnEtagHeader:` + fmt.Sprintf("%v", this.DisableOnEtagHeader) + `,`,
		`RemoveAcceptEncodingHeader:` + fmt.Sprintf("%v", this.RemoveAcceptEncodingHeader) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JavascriptChallengeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JavascriptChallengeType{`,
		`JsScriptDelay:` + fmt.Sprintf("%v", this.JsScriptDelay) + `,`,
		`CookieExpiry:` + fmt.Sprintf("%v", this.CookieExpiry) + `,`,
		`CustomPage:` + fmt.Sprintf("%v", this.CustomPage) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CaptchaChallengeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CaptchaChallengeType{`,
		`CookieExpiry:` + fmt.Sprintf("%v", this.CookieExpiry) + `,`,
		`CustomPage:` + fmt.Sprintf("%v", this.CustomPage) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TemporaryUserBlockingType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TemporaryUserBlockingType{`,
		`CustomPage:` + fmt.Sprintf("%v", this.CustomPage) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AutoCertInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AutoCertInfoType{`,
		`AutoCertState:` + fmt.Sprintf("%v", this.AutoCertState) + `,`,
		`AutoCertExpiry:` + strings.Replace(fmt.Sprintf("%v", this.AutoCertExpiry), "Timestamp", "types.Timestamp", 1) + `,`,
		`AutoCertSubject:` + fmt.Sprintf("%v", this.AutoCertSubject) + `,`,
		`AutoCertIssuer:` + fmt.Sprintf("%v", this.AutoCertIssuer) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthenticationDetails) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAuthConfig := "[]*ObjectRefType{"
	for _, f := range this.AuthConfig {
		repeatedStringForAuthConfig += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForAuthConfig += "}"
	s := strings.Join([]string{`&AuthenticationDetails{`,
		`AuthConfig:` + repeatedStringForAuthConfig + `,`,
		`CookieParamsChoice:` + fmt.Sprintf("%v", this.CookieParamsChoice) + `,`,
		`RedirectUrlChoice:` + fmt.Sprintf("%v", this.RedirectUrlChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthenticationDetails_UseAuthObjectConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthenticationDetails_UseAuthObjectConfig{`,
		`UseAuthObjectConfig:` + strings.Replace(fmt.Sprintf("%v", this.UseAuthObjectConfig), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthenticationDetails_CookieParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthenticationDetails_CookieParams{`,
		`CookieParams:` + strings.Replace(fmt.Sprintf("%v", this.CookieParams), "CookieParams", "authentication.CookieParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthenticationDetails_RedirectUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthenticationDetails_RedirectUrl{`,
		`RedirectUrl:` + fmt.Sprintf("%v", this.RedirectUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthenticationDetails_RedirectDynamic) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthenticationDetails_RedirectDynamic{`,
		`RedirectDynamic:` + strings.Replace(fmt.Sprintf("%v", this.RedirectDynamic), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PolicyBasedChallenge) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMaliciousUserMitigation := "[]*ObjectRefType{"
	for _, f := range this.MaliciousUserMitigation {
		repeatedStringForMaliciousUserMitigation += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForMaliciousUserMitigation += "}"
	s := strings.Join([]string{`&PolicyBasedChallenge{`,
		`JsChallenge:` + strings.Replace(this.JsChallenge.String(), "JavascriptChallengeType", "JavascriptChallengeType", 1) + `,`,
		`CaptchaChallenge:` + strings.Replace(this.CaptchaChallenge.String(), "CaptchaChallengeType", "CaptchaChallengeType", 1) + `,`,
		`TemporaryUserBlocking:` + strings.Replace(this.TemporaryUserBlocking.String(), "TemporaryUserBlockingType", "TemporaryUserBlockingType", 1) + `,`,
		`ChallengeChoice:` + fmt.Sprintf("%v", this.ChallengeChoice) + `,`,
		`MaliciousUserMitigation:` + repeatedStringForMaliciousUserMitigation + `,`,
		`}`,
	}, "")
	return s
}
func (this *PolicyBasedChallenge_NoChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PolicyBasedChallenge_NoChallenge{`,
		`NoChallenge:` + strings.Replace(fmt.Sprintf("%v", this.NoChallenge), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PolicyBasedChallenge_AlwaysEnableJsChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PolicyBasedChallenge_AlwaysEnableJsChallenge{`,
		`AlwaysEnableJsChallenge:` + strings.Replace(fmt.Sprintf("%v", this.AlwaysEnableJsChallenge), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PolicyBasedChallenge_AlwaysEnableCaptchaChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PolicyBasedChallenge_AlwaysEnableCaptchaChallenge{`,
		`AlwaysEnableCaptchaChallenge:` + strings.Replace(fmt.Sprintf("%v", this.AlwaysEnableCaptchaChallenge), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRoutes := "[]*ObjectRefType{"
	for _, f := range this.Routes {
		repeatedStringForRoutes += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRoutes += "}"
	repeatedStringForAdvertisePolicies := "[]*ObjectRefType{"
	for _, f := range this.AdvertisePolicies {
		repeatedStringForAdvertisePolicies += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForAdvertisePolicies += "}"
	repeatedStringForRequestHeadersToAdd := "[]*HeaderManipulationOptionType{"
	for _, f := range this.RequestHeadersToAdd {
		repeatedStringForRequestHeadersToAdd += strings.Replace(fmt.Sprintf("%v", f), "HeaderManipulationOptionType", "schema.HeaderManipulationOptionType", 1) + ","
	}
	repeatedStringForRequestHeadersToAdd += "}"
	repeatedStringForResponseHeadersToAdd := "[]*HeaderManipulationOptionType{"
	for _, f := range this.ResponseHeadersToAdd {
		repeatedStringForResponseHeadersToAdd += strings.Replace(fmt.Sprintf("%v", f), "HeaderManipulationOptionType", "schema.HeaderManipulationOptionType", 1) + ","
	}
	repeatedStringForResponseHeadersToAdd += "}"
	repeatedStringForJwt := "[]*ObjectRefType{"
	for _, f := range this.Jwt {
		repeatedStringForJwt += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForJwt += "}"
	repeatedStringForUserIdentification := "[]*ObjectRefType{"
	for _, f := range this.UserIdentification {
		repeatedStringForUserIdentification += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForUserIdentification += "}"
	repeatedStringForRateLimiter := "[]*ObjectRefType{"
	for _, f := range this.RateLimiter {
		repeatedStringForRateLimiter += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRateLimiter += "}"
	repeatedStringForRateLimiterAllowedPrefixes := "[]*ObjectRefType{"
	for _, f := range this.RateLimiterAllowedPrefixes {
		repeatedStringForRateLimiterAllowedPrefixes += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRateLimiterAllowedPrefixes += "}"
	repeatedStringForMaliciousUserMitigation := "[]*ObjectRefType{"
	for _, f := range this.MaliciousUserMitigation {
		repeatedStringForMaliciousUserMitigation += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForMaliciousUserMitigation += "}"
	repeatedStringForDnsDomains := "[]*ObjectRefType{"
	for _, f := range this.DnsDomains {
		repeatedStringForDnsDomains += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForDnsDomains += "}"
	repeatedStringForDnsInfo := "[]*DnsInfo{"
	for _, f := range this.DnsInfo {
		repeatedStringForDnsInfo += strings.Replace(fmt.Sprintf("%v", f), "DnsInfo", "virtual_host_dns_info.DnsInfo", 1) + ","
	}
	repeatedStringForDnsInfo += "}"
	repeatedStringForServicePolicySets := "[]*ObjectRefType{"
	for _, f := range this.ServicePolicySets {
		repeatedStringForServicePolicySets += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForServicePolicySets += "}"
	keysForCustomErrors := make([]uint32, 0, len(this.CustomErrors))
	for k, _ := range this.CustomErrors {
		keysForCustomErrors = append(keysForCustomErrors, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForCustomErrors)
	mapStringForCustomErrors := "map[uint32]string{"
	for _, k := range keysForCustomErrors {
		mapStringForCustomErrors += fmt.Sprintf("%v: %v,", k, this.CustomErrors[k])
	}
	mapStringForCustomErrors += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`Routes:` + repeatedStringForRoutes + `,`,
		`JavascriptInfo:` + strings.Replace(this.JavascriptInfo.String(), "JavaScriptConfigType", "JavaScriptConfigType", 1) + `,`,
		`AdvertisePolicies:` + repeatedStringForAdvertisePolicies + `,`,
		`RequestHeadersToAdd:` + repeatedStringForRequestHeadersToAdd + `,`,
		`ResponseHeadersToAdd:` + repeatedStringForResponseHeadersToAdd + `,`,
		`ResponseHeadersToRemove:` + fmt.Sprintf("%v", this.ResponseHeadersToRemove) + `,`,
		`TlsParameters:` + strings.Replace(fmt.Sprintf("%v", this.TlsParameters), "DownstreamTlsParamsType", "schema.DownstreamTlsParamsType", 1) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`BufferPolicy:` + strings.Replace(fmt.Sprintf("%v", this.BufferPolicy), "BufferConfigType", "schema.BufferConfigType", 1) + `,`,
		`CorsPolicy:` + strings.Replace(fmt.Sprintf("%v", this.CorsPolicy), "CorsPolicy", "schema.CorsPolicy", 1) + `,`,
		`Proxy:` + fmt.Sprintf("%v", this.Proxy) + `,`,
		`Jwt:` + repeatedStringForJwt + `,`,
		`RequestHeadersToRemove:` + fmt.Sprintf("%v", this.RequestHeadersToRemove) + `,`,
		`WafType:` + strings.Replace(fmt.Sprintf("%v", this.WafType), "WafType", "schema.WafType", 1) + `,`,
		`DynamicReverseProxy:` + strings.Replace(this.DynamicReverseProxy.String(), "DynamicReverseProxyType", "DynamicReverseProxyType", 1) + `,`,
		`AddLocation:` + fmt.Sprintf("%v", this.AddLocation) + `,`,
		`CompressionParams:` + strings.Replace(this.CompressionParams.String(), "CompressionType", "CompressionType", 1) + `,`,
		`CustomErrors:` + mapStringForCustomErrors + `,`,
		`MaxRequestHeaderSize:` + fmt.Sprintf("%v", this.MaxRequestHeaderSize) + `,`,
		`ChallengeType:` + fmt.Sprintf("%v", this.ChallengeType) + `,`,
		`UserIdentification:` + repeatedStringForUserIdentification + `,`,
		`RateLimiter:` + repeatedStringForRateLimiter + `,`,
		`RateLimiterAllowedPrefixes:` + repeatedStringForRateLimiterAllowedPrefixes + `,`,
		`RetryPolicy:` + strings.Replace(fmt.Sprintf("%v", this.RetryPolicy), "RetryPolicyType", "schema.RetryPolicyType", 1) + `,`,
		`IdleTimeout:` + fmt.Sprintf("%v", this.IdleTimeout) + `,`,
		`DisableDefaultErrorPages:` + fmt.Sprintf("%v", this.DisableDefaultErrorPages) + `,`,
		`DisableDnsResolve:` + fmt.Sprintf("%v", this.DisableDnsResolve) + `,`,
		`TemporaryUserBlocking:` + strings.Replace(this.TemporaryUserBlocking.String(), "TemporaryUserBlockingType", "TemporaryUserBlockingType", 1) + `,`,
		`MaliciousUserMitigation:` + repeatedStringForMaliciousUserMitigation + `,`,
		`TlsIntercept:` + strings.Replace(fmt.Sprintf("%v", this.TlsIntercept), "TlsInterceptionType", "schema.TlsInterceptionType", 1) + `,`,
		`AuthenticationChoice:` + fmt.Sprintf("%v", this.AuthenticationChoice) + `,`,
		`ServerHeaderChoice:` + fmt.Sprintf("%v", this.ServerHeaderChoice) + `,`,
		`DnsVolterraManaged:` + fmt.Sprintf("%v", this.DnsVolterraManaged) + `,`,
		`DnsDomains:` + repeatedStringForDnsDomains + `,`,
		`AutoCert:` + fmt.Sprintf("%v", this.AutoCert) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`HostName:` + fmt.Sprintf("%v", this.HostName) + `,`,
		`DnsInfo:` + repeatedStringForDnsInfo + `,`,
		`AutoCertState:` + fmt.Sprintf("%v", this.AutoCertState) + `,`,
		`AutoCertInfo:` + strings.Replace(this.AutoCertInfo.String(), "AutoCertInfoType", "AutoCertInfoType", 1) + `,`,
		`UserDomains:` + fmt.Sprintf("%v", this.UserDomains) + `,`,
		`ServicePolicySets:` + repeatedStringForServicePolicySets + `,`,
		`LoadbalancerAlgorithm:` + fmt.Sprintf("%v", this.LoadbalancerAlgorithm) + `,`,
		`VolterraCert:` + fmt.Sprintf("%v", this.VolterraCert) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_JsChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_JsChallenge{`,
		`JsChallenge:` + strings.Replace(fmt.Sprintf("%v", this.JsChallenge), "JavascriptChallengeType", "JavascriptChallengeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_CaptchaChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_CaptchaChallenge{`,
		`CaptchaChallenge:` + strings.Replace(fmt.Sprintf("%v", this.CaptchaChallenge), "CaptchaChallengeType", "CaptchaChallengeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_NoChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_NoChallenge{`,
		`NoChallenge:` + strings.Replace(fmt.Sprintf("%v", this.NoChallenge), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_NoAuthentication) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_NoAuthentication{`,
		`NoAuthentication:` + strings.Replace(fmt.Sprintf("%v", this.NoAuthentication), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Authentication) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Authentication{`,
		`Authentication:` + strings.Replace(fmt.Sprintf("%v", this.Authentication), "AuthenticationDetails", "AuthenticationDetails", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_PolicyBasedChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_PolicyBasedChallenge{`,
		`PolicyBasedChallenge:` + strings.Replace(fmt.Sprintf("%v", this.PolicyBasedChallenge), "PolicyBasedChallenge", "PolicyBasedChallenge", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DefaultHeader) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DefaultHeader{`,
		`DefaultHeader:` + strings.Replace(fmt.Sprintf("%v", this.DefaultHeader), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AppendServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AppendServerName{`,
		`AppendServerName:` + fmt.Sprintf("%v", this.AppendServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_PassThrough) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_PassThrough{`,
		`PassThrough:` + strings.Replace(fmt.Sprintf("%v", this.PassThrough), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRoutes := "[]*ObjectRefType{"
	for _, f := range this.Routes {
		repeatedStringForRoutes += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRoutes += "}"
	repeatedStringForAdvertisePolicies := "[]*ObjectRefType{"
	for _, f := range this.AdvertisePolicies {
		repeatedStringForAdvertisePolicies += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForAdvertisePolicies += "}"
	repeatedStringForRequestHeadersToAdd := "[]*HeaderManipulationOptionType{"
	for _, f := range this.RequestHeadersToAdd {
		repeatedStringForRequestHeadersToAdd += strings.Replace(fmt.Sprintf("%v", f), "HeaderManipulationOptionType", "schema.HeaderManipulationOptionType", 1) + ","
	}
	repeatedStringForRequestHeadersToAdd += "}"
	repeatedStringForResponseHeadersToAdd := "[]*HeaderManipulationOptionType{"
	for _, f := range this.ResponseHeadersToAdd {
		repeatedStringForResponseHeadersToAdd += strings.Replace(fmt.Sprintf("%v", f), "HeaderManipulationOptionType", "schema.HeaderManipulationOptionType", 1) + ","
	}
	repeatedStringForResponseHeadersToAdd += "}"
	repeatedStringForUserIdentification := "[]*ObjectRefType{"
	for _, f := range this.UserIdentification {
		repeatedStringForUserIdentification += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForUserIdentification += "}"
	repeatedStringForRateLimiter := "[]*ObjectRefType{"
	for _, f := range this.RateLimiter {
		repeatedStringForRateLimiter += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRateLimiter += "}"
	repeatedStringForRateLimiterAllowedPrefixes := "[]*ObjectRefType{"
	for _, f := range this.RateLimiterAllowedPrefixes {
		repeatedStringForRateLimiterAllowedPrefixes += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRateLimiterAllowedPrefixes += "}"
	keysForCustomErrors := make([]uint32, 0, len(this.CustomErrors))
	for k, _ := range this.CustomErrors {
		keysForCustomErrors = append(keysForCustomErrors, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForCustomErrors)
	mapStringForCustomErrors := "map[uint32]string{"
	for _, k := range keysForCustomErrors {
		mapStringForCustomErrors += fmt.Sprintf("%v: %v,", k, this.CustomErrors[k])
	}
	mapStringForCustomErrors += "}"
	s := strings.Join([]string{`&CreateSpecType{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`Routes:` + repeatedStringForRoutes + `,`,
		`AdvertisePolicies:` + repeatedStringForAdvertisePolicies + `,`,
		`RequestHeadersToAdd:` + repeatedStringForRequestHeadersToAdd + `,`,
		`ResponseHeadersToAdd:` + repeatedStringForResponseHeadersToAdd + `,`,
		`ResponseHeadersToRemove:` + fmt.Sprintf("%v", this.ResponseHeadersToRemove) + `,`,
		`TlsParameters:` + strings.Replace(fmt.Sprintf("%v", this.TlsParameters), "DownstreamTlsParamsType", "schema.DownstreamTlsParamsType", 1) + `,`,
		`BufferPolicy:` + strings.Replace(fmt.Sprintf("%v", this.BufferPolicy), "BufferConfigType", "schema.BufferConfigType", 1) + `,`,
		`CorsPolicy:` + strings.Replace(fmt.Sprintf("%v", this.CorsPolicy), "CorsPolicy", "schema.CorsPolicy", 1) + `,`,
		`Proxy:` + fmt.Sprintf("%v", this.Proxy) + `,`,
		`RequestHeadersToRemove:` + fmt.Sprintf("%v", this.RequestHeadersToRemove) + `,`,
		`WafType:` + strings.Replace(fmt.Sprintf("%v", this.WafType), "WafType", "schema.WafType", 1) + `,`,
		`DynamicReverseProxy:` + strings.Replace(this.DynamicReverseProxy.String(), "DynamicReverseProxyType", "DynamicReverseProxyType", 1) + `,`,
		`AddLocation:` + fmt.Sprintf("%v", this.AddLocation) + `,`,
		`CompressionParams:` + strings.Replace(this.CompressionParams.String(), "CompressionType", "CompressionType", 1) + `,`,
		`CustomErrors:` + mapStringForCustomErrors + `,`,
		`MaxRequestHeaderSize:` + fmt.Sprintf("%v", this.MaxRequestHeaderSize) + `,`,
		`ChallengeType:` + fmt.Sprintf("%v", this.ChallengeType) + `,`,
		`UserIdentification:` + repeatedStringForUserIdentification + `,`,
		`RateLimiter:` + repeatedStringForRateLimiter + `,`,
		`RateLimiterAllowedPrefixes:` + repeatedStringForRateLimiterAllowedPrefixes + `,`,
		`RetryPolicy:` + strings.Replace(fmt.Sprintf("%v", this.RetryPolicy), "RetryPolicyType", "schema.RetryPolicyType", 1) + `,`,
		`IdleTimeout:` + fmt.Sprintf("%v", this.IdleTimeout) + `,`,
		`DisableDefaultErrorPages:` + fmt.Sprintf("%v", this.DisableDefaultErrorPages) + `,`,
		`DisableDnsResolve:` + fmt.Sprintf("%v", this.DisableDnsResolve) + `,`,
		`TemporaryUserBlocking:` + strings.Replace(this.TemporaryUserBlocking.String(), "TemporaryUserBlockingType", "TemporaryUserBlockingType", 1) + `,`,
		`AuthenticationChoice:` + fmt.Sprintf("%v", this.AuthenticationChoice) + `,`,
		`ServerHeaderChoice:` + fmt.Sprintf("%v", this.ServerHeaderChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_JsChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_JsChallenge{`,
		`JsChallenge:` + strings.Replace(fmt.Sprintf("%v", this.JsChallenge), "JavascriptChallengeType", "JavascriptChallengeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_CaptchaChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_CaptchaChallenge{`,
		`CaptchaChallenge:` + strings.Replace(fmt.Sprintf("%v", this.CaptchaChallenge), "CaptchaChallengeType", "CaptchaChallengeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_NoChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_NoChallenge{`,
		`NoChallenge:` + strings.Replace(fmt.Sprintf("%v", this.NoChallenge), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_NoAuthentication) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_NoAuthentication{`,
		`NoAuthentication:` + strings.Replace(fmt.Sprintf("%v", this.NoAuthentication), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_Authentication) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_Authentication{`,
		`Authentication:` + strings.Replace(fmt.Sprintf("%v", this.Authentication), "AuthenticationDetails", "AuthenticationDetails", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DefaultHeader) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DefaultHeader{`,
		`DefaultHeader:` + strings.Replace(fmt.Sprintf("%v", this.DefaultHeader), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AppendServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AppendServerName{`,
		`AppendServerName:` + fmt.Sprintf("%v", this.AppendServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_PassThrough) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_PassThrough{`,
		`PassThrough:` + strings.Replace(fmt.Sprintf("%v", this.PassThrough), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRoutes := "[]*ObjectRefType{"
	for _, f := range this.Routes {
		repeatedStringForRoutes += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRoutes += "}"
	repeatedStringForAdvertisePolicies := "[]*ObjectRefType{"
	for _, f := range this.AdvertisePolicies {
		repeatedStringForAdvertisePolicies += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForAdvertisePolicies += "}"
	repeatedStringForRequestHeadersToAdd := "[]*HeaderManipulationOptionType{"
	for _, f := range this.RequestHeadersToAdd {
		repeatedStringForRequestHeadersToAdd += strings.Replace(fmt.Sprintf("%v", f), "HeaderManipulationOptionType", "schema.HeaderManipulationOptionType", 1) + ","
	}
	repeatedStringForRequestHeadersToAdd += "}"
	repeatedStringForResponseHeadersToAdd := "[]*HeaderManipulationOptionType{"
	for _, f := range this.ResponseHeadersToAdd {
		repeatedStringForResponseHeadersToAdd += strings.Replace(fmt.Sprintf("%v", f), "HeaderManipulationOptionType", "schema.HeaderManipulationOptionType", 1) + ","
	}
	repeatedStringForResponseHeadersToAdd += "}"
	repeatedStringForUserIdentification := "[]*ObjectRefType{"
	for _, f := range this.UserIdentification {
		repeatedStringForUserIdentification += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForUserIdentification += "}"
	repeatedStringForRateLimiter := "[]*ObjectRefType{"
	for _, f := range this.RateLimiter {
		repeatedStringForRateLimiter += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRateLimiter += "}"
	repeatedStringForRateLimiterAllowedPrefixes := "[]*ObjectRefType{"
	for _, f := range this.RateLimiterAllowedPrefixes {
		repeatedStringForRateLimiterAllowedPrefixes += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRateLimiterAllowedPrefixes += "}"
	keysForCustomErrors := make([]uint32, 0, len(this.CustomErrors))
	for k, _ := range this.CustomErrors {
		keysForCustomErrors = append(keysForCustomErrors, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForCustomErrors)
	mapStringForCustomErrors := "map[uint32]string{"
	for _, k := range keysForCustomErrors {
		mapStringForCustomErrors += fmt.Sprintf("%v: %v,", k, this.CustomErrors[k])
	}
	mapStringForCustomErrors += "}"
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`Routes:` + repeatedStringForRoutes + `,`,
		`AdvertisePolicies:` + repeatedStringForAdvertisePolicies + `,`,
		`RequestHeadersToAdd:` + repeatedStringForRequestHeadersToAdd + `,`,
		`ResponseHeadersToAdd:` + repeatedStringForResponseHeadersToAdd + `,`,
		`ResponseHeadersToRemove:` + fmt.Sprintf("%v", this.ResponseHeadersToRemove) + `,`,
		`TlsParameters:` + strings.Replace(fmt.Sprintf("%v", this.TlsParameters), "DownstreamTlsParamsType", "schema.DownstreamTlsParamsType", 1) + `,`,
		`BufferPolicy:` + strings.Replace(fmt.Sprintf("%v", this.BufferPolicy), "BufferConfigType", "schema.BufferConfigType", 1) + `,`,
		`CorsPolicy:` + strings.Replace(fmt.Sprintf("%v", this.CorsPolicy), "CorsPolicy", "schema.CorsPolicy", 1) + `,`,
		`Proxy:` + fmt.Sprintf("%v", this.Proxy) + `,`,
		`RequestHeadersToRemove:` + fmt.Sprintf("%v", this.RequestHeadersToRemove) + `,`,
		`WafType:` + strings.Replace(fmt.Sprintf("%v", this.WafType), "WafType", "schema.WafType", 1) + `,`,
		`DynamicReverseProxy:` + strings.Replace(this.DynamicReverseProxy.String(), "DynamicReverseProxyType", "DynamicReverseProxyType", 1) + `,`,
		`AddLocation:` + fmt.Sprintf("%v", this.AddLocation) + `,`,
		`CompressionParams:` + strings.Replace(this.CompressionParams.String(), "CompressionType", "CompressionType", 1) + `,`,
		`CustomErrors:` + mapStringForCustomErrors + `,`,
		`MaxRequestHeaderSize:` + fmt.Sprintf("%v", this.MaxRequestHeaderSize) + `,`,
		`ChallengeType:` + fmt.Sprintf("%v", this.ChallengeType) + `,`,
		`UserIdentification:` + repeatedStringForUserIdentification + `,`,
		`RateLimiter:` + repeatedStringForRateLimiter + `,`,
		`RateLimiterAllowedPrefixes:` + repeatedStringForRateLimiterAllowedPrefixes + `,`,
		`RetryPolicy:` + strings.Replace(fmt.Sprintf("%v", this.RetryPolicy), "RetryPolicyType", "schema.RetryPolicyType", 1) + `,`,
		`IdleTimeout:` + fmt.Sprintf("%v", this.IdleTimeout) + `,`,
		`DisableDefaultErrorPages:` + fmt.Sprintf("%v", this.DisableDefaultErrorPages) + `,`,
		`DisableDnsResolve:` + fmt.Sprintf("%v", this.DisableDnsResolve) + `,`,
		`TemporaryUserBlocking:` + strings.Replace(this.TemporaryUserBlocking.String(), "TemporaryUserBlockingType", "TemporaryUserBlockingType", 1) + `,`,
		`AuthenticationChoice:` + fmt.Sprintf("%v", this.AuthenticationChoice) + `,`,
		`ServerHeaderChoice:` + fmt.Sprintf("%v", this.ServerHeaderChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_JsChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_JsChallenge{`,
		`JsChallenge:` + strings.Replace(fmt.Sprintf("%v", this.JsChallenge), "JavascriptChallengeType", "JavascriptChallengeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_CaptchaChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_CaptchaChallenge{`,
		`CaptchaChallenge:` + strings.Replace(fmt.Sprintf("%v", this.CaptchaChallenge), "CaptchaChallengeType", "CaptchaChallengeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_NoChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_NoChallenge{`,
		`NoChallenge:` + strings.Replace(fmt.Sprintf("%v", this.NoChallenge), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_NoAuthentication) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_NoAuthentication{`,
		`NoAuthentication:` + strings.Replace(fmt.Sprintf("%v", this.NoAuthentication), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_Authentication) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_Authentication{`,
		`Authentication:` + strings.Replace(fmt.Sprintf("%v", this.Authentication), "AuthenticationDetails", "AuthenticationDetails", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DefaultHeader) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DefaultHeader{`,
		`DefaultHeader:` + strings.Replace(fmt.Sprintf("%v", this.DefaultHeader), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AppendServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AppendServerName{`,
		`AppendServerName:` + fmt.Sprintf("%v", this.AppendServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_PassThrough) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_PassThrough{`,
		`PassThrough:` + strings.Replace(fmt.Sprintf("%v", this.PassThrough), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRoutes := "[]*ObjectRefType{"
	for _, f := range this.Routes {
		repeatedStringForRoutes += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRoutes += "}"
	repeatedStringForAdvertisePolicies := "[]*ObjectRefType{"
	for _, f := range this.AdvertisePolicies {
		repeatedStringForAdvertisePolicies += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForAdvertisePolicies += "}"
	repeatedStringForRequestHeadersToAdd := "[]*HeaderManipulationOptionType{"
	for _, f := range this.RequestHeadersToAdd {
		repeatedStringForRequestHeadersToAdd += strings.Replace(fmt.Sprintf("%v", f), "HeaderManipulationOptionType", "schema.HeaderManipulationOptionType", 1) + ","
	}
	repeatedStringForRequestHeadersToAdd += "}"
	repeatedStringForResponseHeadersToAdd := "[]*HeaderManipulationOptionType{"
	for _, f := range this.ResponseHeadersToAdd {
		repeatedStringForResponseHeadersToAdd += strings.Replace(fmt.Sprintf("%v", f), "HeaderManipulationOptionType", "schema.HeaderManipulationOptionType", 1) + ","
	}
	repeatedStringForResponseHeadersToAdd += "}"
	repeatedStringForUserIdentification := "[]*ObjectRefType{"
	for _, f := range this.UserIdentification {
		repeatedStringForUserIdentification += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForUserIdentification += "}"
	repeatedStringForRateLimiter := "[]*ObjectRefType{"
	for _, f := range this.RateLimiter {
		repeatedStringForRateLimiter += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRateLimiter += "}"
	repeatedStringForRateLimiterAllowedPrefixes := "[]*ObjectRefType{"
	for _, f := range this.RateLimiterAllowedPrefixes {
		repeatedStringForRateLimiterAllowedPrefixes += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRateLimiterAllowedPrefixes += "}"
	repeatedStringForDnsInfo := "[]*DnsInfo{"
	for _, f := range this.DnsInfo {
		repeatedStringForDnsInfo += strings.Replace(fmt.Sprintf("%v", f), "DnsInfo", "virtual_host_dns_info.DnsInfo", 1) + ","
	}
	repeatedStringForDnsInfo += "}"
	keysForCustomErrors := make([]uint32, 0, len(this.CustomErrors))
	for k, _ := range this.CustomErrors {
		keysForCustomErrors = append(keysForCustomErrors, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForCustomErrors)
	mapStringForCustomErrors := "map[uint32]string{"
	for _, k := range keysForCustomErrors {
		mapStringForCustomErrors += fmt.Sprintf("%v: %v,", k, this.CustomErrors[k])
	}
	mapStringForCustomErrors += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`Routes:` + repeatedStringForRoutes + `,`,
		`AdvertisePolicies:` + repeatedStringForAdvertisePolicies + `,`,
		`RequestHeadersToAdd:` + repeatedStringForRequestHeadersToAdd + `,`,
		`ResponseHeadersToAdd:` + repeatedStringForResponseHeadersToAdd + `,`,
		`ResponseHeadersToRemove:` + fmt.Sprintf("%v", this.ResponseHeadersToRemove) + `,`,
		`TlsParameters:` + strings.Replace(fmt.Sprintf("%v", this.TlsParameters), "DownstreamTlsParamsType", "schema.DownstreamTlsParamsType", 1) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`BufferPolicy:` + strings.Replace(fmt.Sprintf("%v", this.BufferPolicy), "BufferConfigType", "schema.BufferConfigType", 1) + `,`,
		`CorsPolicy:` + strings.Replace(fmt.Sprintf("%v", this.CorsPolicy), "CorsPolicy", "schema.CorsPolicy", 1) + `,`,
		`Proxy:` + fmt.Sprintf("%v", this.Proxy) + `,`,
		`RequestHeadersToRemove:` + fmt.Sprintf("%v", this.RequestHeadersToRemove) + `,`,
		`WafType:` + strings.Replace(fmt.Sprintf("%v", this.WafType), "WafType", "schema.WafType", 1) + `,`,
		`DynamicReverseProxy:` + strings.Replace(this.DynamicReverseProxy.String(), "DynamicReverseProxyType", "DynamicReverseProxyType", 1) + `,`,
		`AddLocation:` + fmt.Sprintf("%v", this.AddLocation) + `,`,
		`CompressionParams:` + strings.Replace(this.CompressionParams.String(), "CompressionType", "CompressionType", 1) + `,`,
		`CustomErrors:` + mapStringForCustomErrors + `,`,
		`MaxRequestHeaderSize:` + fmt.Sprintf("%v", this.MaxRequestHeaderSize) + `,`,
		`ChallengeType:` + fmt.Sprintf("%v", this.ChallengeType) + `,`,
		`UserIdentification:` + repeatedStringForUserIdentification + `,`,
		`RateLimiter:` + repeatedStringForRateLimiter + `,`,
		`RateLimiterAllowedPrefixes:` + repeatedStringForRateLimiterAllowedPrefixes + `,`,
		`RetryPolicy:` + strings.Replace(fmt.Sprintf("%v", this.RetryPolicy), "RetryPolicyType", "schema.RetryPolicyType", 1) + `,`,
		`IdleTimeout:` + fmt.Sprintf("%v", this.IdleTimeout) + `,`,
		`DisableDefaultErrorPages:` + fmt.Sprintf("%v", this.DisableDefaultErrorPages) + `,`,
		`DisableDnsResolve:` + fmt.Sprintf("%v", this.DisableDnsResolve) + `,`,
		`TemporaryUserBlocking:` + strings.Replace(this.TemporaryUserBlocking.String(), "TemporaryUserBlockingType", "TemporaryUserBlockingType", 1) + `,`,
		`AuthenticationChoice:` + fmt.Sprintf("%v", this.AuthenticationChoice) + `,`,
		`ServerHeaderChoice:` + fmt.Sprintf("%v", this.ServerHeaderChoice) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`HostName:` + fmt.Sprintf("%v", this.HostName) + `,`,
		`DnsInfo:` + repeatedStringForDnsInfo + `,`,
		`AutoCertState:` + fmt.Sprintf("%v", this.AutoCertState) + `,`,
		`AutoCertInfo:` + strings.Replace(this.AutoCertInfo.String(), "AutoCertInfoType", "AutoCertInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_JsChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_JsChallenge{`,
		`JsChallenge:` + strings.Replace(fmt.Sprintf("%v", this.JsChallenge), "JavascriptChallengeType", "JavascriptChallengeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_CaptchaChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_CaptchaChallenge{`,
		`CaptchaChallenge:` + strings.Replace(fmt.Sprintf("%v", this.CaptchaChallenge), "CaptchaChallengeType", "CaptchaChallengeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_NoChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_NoChallenge{`,
		`NoChallenge:` + strings.Replace(fmt.Sprintf("%v", this.NoChallenge), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_NoAuthentication) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_NoAuthentication{`,
		`NoAuthentication:` + strings.Replace(fmt.Sprintf("%v", this.NoAuthentication), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_Authentication) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_Authentication{`,
		`Authentication:` + strings.Replace(fmt.Sprintf("%v", this.Authentication), "AuthenticationDetails", "AuthenticationDetails", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DefaultHeader) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DefaultHeader{`,
		`DefaultHeader:` + strings.Replace(fmt.Sprintf("%v", this.DefaultHeader), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AppendServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AppendServerName{`,
		`AppendServerName:` + fmt.Sprintf("%v", this.AppendServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_PassThrough) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_PassThrough{`,
		`PassThrough:` + strings.Replace(fmt.Sprintf("%v", this.PassThrough), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *JavaScriptConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JavaScriptConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JavaScriptConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CachePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScriptConfig == nil {
				m.ScriptConfig = &types.Struct{}
			}
			if err := m.ScriptConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomScriptUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomScriptUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicReverseProxyType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicReverseProxyType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicReverseProxyType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveEndpointDynamically", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResolveEndpointDynamically = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolutionNetworkType", wireType)
			}
			m.ResolutionNetworkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolutionNetworkType |= schema.VirtualNetworkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolutionNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolutionNetwork = append(m.ResolutionNetwork, &schema.ObjectRefType{})
			if err := m.ResolutionNetwork[len(m.ResolutionNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionTimeout", wireType)
			}
			m.ConnectionTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompressionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompressionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompressionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentLength", wireType)
			}
			m.ContentLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentLength |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = append(m.ContentType, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableOnEtagHeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableOnEtagHeader = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveAcceptEncodingHeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoveAcceptEncodingHeader = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JavascriptChallengeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JavascriptChallengeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JavascriptChallengeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsScriptDelay", wireType)
			}
			m.JsScriptDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JsScriptDelay |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieExpiry", wireType)
			}
			m.CookieExpiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CookieExpiry |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomPage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomPage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CaptchaChallengeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CaptchaChallengeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CaptchaChallengeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieExpiry", wireType)
			}
			m.CookieExpiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CookieExpiry |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomPage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomPage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TemporaryUserBlockingType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TemporaryUserBlockingType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TemporaryUserBlockingType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomPage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomPage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoCertInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoCertInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoCertInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertState", wireType)
			}
			m.AutoCertState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoCertState |= CertificationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertExpiry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoCertExpiry == nil {
				m.AutoCertExpiry = &types.Timestamp{}
			}
			if err := m.AutoCertExpiry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertSubject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AutoCertSubject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertIssuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AutoCertIssuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticationDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticationDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticationDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthConfig = append(m.AuthConfig, &schema.ObjectRefType{})
			if err := m.AuthConfig[len(m.AuthConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseAuthObjectConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CookieParamsChoice = &AuthenticationDetails_UseAuthObjectConfig{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &authentication.CookieParams{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CookieParamsChoice = &AuthenticationDetails_CookieParams{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedirectUrlChoice = &AuthenticationDetails_RedirectUrl{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectDynamic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RedirectUrlChoice = &AuthenticationDetails_RedirectDynamic{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyBasedChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyBasedChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyBasedChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JsChallenge == nil {
				m.JsChallenge = &JavascriptChallengeType{}
			}
			if err := m.JsChallenge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptchaChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CaptchaChallenge == nil {
				m.CaptchaChallenge = &CaptchaChallengeType{}
			}
			if err := m.CaptchaChallenge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporaryUserBlocking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TemporaryUserBlocking == nil {
				m.TemporaryUserBlocking = &TemporaryUserBlockingType{}
			}
			if err := m.TemporaryUserBlocking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeChoice = &PolicyBasedChallenge_NoChallenge{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlwaysEnableJsChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeChoice = &PolicyBasedChallenge_AlwaysEnableJsChallenge{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlwaysEnableCaptchaChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeChoice = &PolicyBasedChallenge_AlwaysEnableCaptchaChallenge{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaliciousUserMitigation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaliciousUserMitigation = append(m.MaliciousUserMitigation, &schema.ObjectRefType{})
			if err := m.MaliciousUserMitigation[len(m.MaliciousUserMitigation)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &schema.ObjectRefType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavascriptInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JavascriptInfo == nil {
				m.JavascriptInfo = &JavaScriptConfigType{}
			}
			if err := m.JavascriptInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertisePolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdvertisePolicies = append(m.AdvertisePolicies, &schema.ObjectRefType{})
			if err := m.AdvertisePolicies[len(m.AdvertisePolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &schema.HeaderManipulationOptionType{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToAdd = append(m.ResponseHeadersToAdd, &schema.HeaderManipulationOptionType{})
			if err := m.ResponseHeadersToAdd[len(m.ResponseHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToRemove = append(m.ResponseHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsParameters == nil {
				m.TlsParameters = &schema.DownstreamTlsParamsType{}
			}
			if err := m.TlsParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= VirtualHostType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BufferPolicy == nil {
				m.BufferPolicy = &schema.BufferConfigType{}
			}
			if err := m.BufferPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorsPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CorsPolicy == nil {
				m.CorsPolicy = &schema.CorsPolicy{}
			}
			if err := m.CorsPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			m.Proxy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proxy |= ProxyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jwt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jwt = append(m.Jwt, &schema.ObjectRefType{})
			if err := m.Jwt[len(m.Jwt)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToRemove = append(m.RequestHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafType == nil {
				m.WafType = &schema.WafType{}
			}
			if err := m.WafType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicReverseProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DynamicReverseProxy == nil {
				m.DynamicReverseProxy = &DynamicReverseProxyType{}
			}
			if err := m.DynamicReverseProxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddLocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddLocation = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompressionParams == nil {
				m.CompressionParams = &CompressionType{}
			}
			if err := m.CompressionParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomErrors == nil {
				m.CustomErrors = make(map[uint32]string)
			}
			var mapkey uint32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CustomErrors[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestHeaderSize", wireType)
			}
			m.MaxRequestHeaderSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequestHeaderSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JavascriptChallengeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &GlobalSpecType_JsChallenge{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIdentification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserIdentification = append(m.UserIdentification, &schema.ObjectRefType{})
			if err := m.UserIdentification[len(m.UserIdentification)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiter = append(m.RateLimiter, &schema.ObjectRefType{})
			if err := m.RateLimiter[len(m.RateLimiter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiterAllowedPrefixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiterAllowedPrefixes = append(m.RateLimiterAllowedPrefixes, &schema.ObjectRefType{})
			if err := m.RateLimiterAllowedPrefixes[len(m.RateLimiterAllowedPrefixes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryPolicy == nil {
				m.RetryPolicy = &schema.RetryPolicyType{}
			}
			if err := m.RetryPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptchaChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CaptchaChallengeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &GlobalSpecType_CaptchaChallenge{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &GlobalSpecType_NoChallenge{v}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			m.IdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableDefaultErrorPages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableDefaultErrorPages = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableDnsResolve", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableDnsResolve = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporaryUserBlocking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TemporaryUserBlocking == nil {
				m.TemporaryUserBlocking = &TemporaryUserBlockingType{}
			}
			if err := m.TemporaryUserBlocking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaliciousUserMitigation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaliciousUserMitigation = append(m.MaliciousUserMitigation, &schema.ObjectRefType{})
			if err := m.MaliciousUserMitigation[len(m.MaliciousUserMitigation)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsIntercept", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsIntercept == nil {
				m.TlsIntercept = &schema.TlsInterceptionType{}
			}
			if err := m.TlsIntercept.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoAuthentication", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthenticationChoice = &GlobalSpecType_NoAuthentication{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authentication", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuthenticationDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthenticationChoice = &GlobalSpecType_Authentication{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyBasedChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PolicyBasedChallenge{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &GlobalSpecType_PolicyBasedChallenge{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerHeaderChoice = &GlobalSpecType_DefaultHeader{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerHeaderChoice = &GlobalSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppendServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerHeaderChoice = &GlobalSpecType_AppendServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassThrough", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerHeaderChoice = &GlobalSpecType_PassThrough{v}
			iNdEx = postIndex
		case 1000:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsVolterraManaged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DnsVolterraManaged = bool(v != 0)
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsDomains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsDomains = append(m.DnsDomains, &schema.ObjectRefType{})
			if err := m.DnsDomains[len(m.DnsDomains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1002:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoCert = bool(v != 0)
		case 1003:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= VirtualHostState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1004:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 1005:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsInfo = append(m.DnsInfo, &virtual_host_dns_info.DnsInfo{})
			if err := m.DnsInfo[len(m.DnsInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1006:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertState", wireType)
			}
			m.AutoCertState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoCertState |= CertificationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1010:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoCertInfo == nil {
				m.AutoCertInfo = &AutoCertInfoType{}
			}
			if err := m.AutoCertInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1011:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDomains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserDomains = append(m.UserDomains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 1012:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicePolicySets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServicePolicySets = append(m.ServicePolicySets, &schema.ObjectRefType{})
			if err := m.ServicePolicySets[len(m.ServicePolicySets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1013:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerAlgorithm", wireType)
			}
			m.LoadbalancerAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadbalancerAlgorithm |= cluster.LoadbalancerAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1014:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraCert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VolterraCert = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &schema.ObjectRefType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertisePolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdvertisePolicies = append(m.AdvertisePolicies, &schema.ObjectRefType{})
			if err := m.AdvertisePolicies[len(m.AdvertisePolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &schema.HeaderManipulationOptionType{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToAdd = append(m.ResponseHeadersToAdd, &schema.HeaderManipulationOptionType{})
			if err := m.ResponseHeadersToAdd[len(m.ResponseHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToRemove = append(m.ResponseHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsParameters == nil {
				m.TlsParameters = &schema.DownstreamTlsParamsType{}
			}
			if err := m.TlsParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BufferPolicy == nil {
				m.BufferPolicy = &schema.BufferConfigType{}
			}
			if err := m.BufferPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorsPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CorsPolicy == nil {
				m.CorsPolicy = &schema.CorsPolicy{}
			}
			if err := m.CorsPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			m.Proxy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proxy |= ProxyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToRemove = append(m.RequestHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafType == nil {
				m.WafType = &schema.WafType{}
			}
			if err := m.WafType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicReverseProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DynamicReverseProxy == nil {
				m.DynamicReverseProxy = &DynamicReverseProxyType{}
			}
			if err := m.DynamicReverseProxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddLocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddLocation = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompressionParams == nil {
				m.CompressionParams = &CompressionType{}
			}
			if err := m.CompressionParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomErrors == nil {
				m.CustomErrors = make(map[uint32]string)
			}
			var mapkey uint32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CustomErrors[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestHeaderSize", wireType)
			}
			m.MaxRequestHeaderSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequestHeaderSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JavascriptChallengeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &CreateSpecType_JsChallenge{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIdentification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserIdentification = append(m.UserIdentification, &schema.ObjectRefType{})
			if err := m.UserIdentification[len(m.UserIdentification)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiter = append(m.RateLimiter, &schema.ObjectRefType{})
			if err := m.RateLimiter[len(m.RateLimiter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiterAllowedPrefixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiterAllowedPrefixes = append(m.RateLimiterAllowedPrefixes, &schema.ObjectRefType{})
			if err := m.RateLimiterAllowedPrefixes[len(m.RateLimiterAllowedPrefixes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryPolicy == nil {
				m.RetryPolicy = &schema.RetryPolicyType{}
			}
			if err := m.RetryPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptchaChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CaptchaChallengeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &CreateSpecType_CaptchaChallenge{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &CreateSpecType_NoChallenge{v}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			m.IdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableDefaultErrorPages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableDefaultErrorPages = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableDnsResolve", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableDnsResolve = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporaryUserBlocking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TemporaryUserBlocking == nil {
				m.TemporaryUserBlocking = &TemporaryUserBlockingType{}
			}
			if err := m.TemporaryUserBlocking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoAuthentication", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthenticationChoice = &CreateSpecType_NoAuthentication{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authentication", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuthenticationDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthenticationChoice = &CreateSpecType_Authentication{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerHeaderChoice = &CreateSpecType_DefaultHeader{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerHeaderChoice = &CreateSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppendServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerHeaderChoice = &CreateSpecType_AppendServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassThrough", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerHeaderChoice = &CreateSpecType_PassThrough{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &schema.ObjectRefType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertisePolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdvertisePolicies = append(m.AdvertisePolicies, &schema.ObjectRefType{})
			if err := m.AdvertisePolicies[len(m.AdvertisePolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &schema.HeaderManipulationOptionType{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToAdd = append(m.ResponseHeadersToAdd, &schema.HeaderManipulationOptionType{})
			if err := m.ResponseHeadersToAdd[len(m.ResponseHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToRemove = append(m.ResponseHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsParameters == nil {
				m.TlsParameters = &schema.DownstreamTlsParamsType{}
			}
			if err := m.TlsParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BufferPolicy == nil {
				m.BufferPolicy = &schema.BufferConfigType{}
			}
			if err := m.BufferPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorsPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CorsPolicy == nil {
				m.CorsPolicy = &schema.CorsPolicy{}
			}
			if err := m.CorsPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			m.Proxy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proxy |= ProxyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToRemove = append(m.RequestHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafType == nil {
				m.WafType = &schema.WafType{}
			}
			if err := m.WafType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicReverseProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DynamicReverseProxy == nil {
				m.DynamicReverseProxy = &DynamicReverseProxyType{}
			}
			if err := m.DynamicReverseProxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddLocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddLocation = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompressionParams == nil {
				m.CompressionParams = &CompressionType{}
			}
			if err := m.CompressionParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomErrors == nil {
				m.CustomErrors = make(map[uint32]string)
			}
			var mapkey uint32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CustomErrors[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestHeaderSize", wireType)
			}
			m.MaxRequestHeaderSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequestHeaderSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JavascriptChallengeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &ReplaceSpecType_JsChallenge{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIdentification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserIdentification = append(m.UserIdentification, &schema.ObjectRefType{})
			if err := m.UserIdentification[len(m.UserIdentification)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiter = append(m.RateLimiter, &schema.ObjectRefType{})
			if err := m.RateLimiter[len(m.RateLimiter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiterAllowedPrefixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiterAllowedPrefixes = append(m.RateLimiterAllowedPrefixes, &schema.ObjectRefType{})
			if err := m.RateLimiterAllowedPrefixes[len(m.RateLimiterAllowedPrefixes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryPolicy == nil {
				m.RetryPolicy = &schema.RetryPolicyType{}
			}
			if err := m.RetryPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptchaChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CaptchaChallengeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &ReplaceSpecType_CaptchaChallenge{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &ReplaceSpecType_NoChallenge{v}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			m.IdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableDefaultErrorPages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableDefaultErrorPages = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableDnsResolve", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableDnsResolve = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporaryUserBlocking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TemporaryUserBlocking == nil {
				m.TemporaryUserBlocking = &TemporaryUserBlockingType{}
			}
			if err := m.TemporaryUserBlocking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoAuthentication", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthenticationChoice = &ReplaceSpecType_NoAuthentication{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authentication", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuthenticationDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthenticationChoice = &ReplaceSpecType_Authentication{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerHeaderChoice = &ReplaceSpecType_DefaultHeader{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerHeaderChoice = &ReplaceSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppendServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerHeaderChoice = &ReplaceSpecType_AppendServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassThrough", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerHeaderChoice = &ReplaceSpecType_PassThrough{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &schema.ObjectRefType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertisePolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdvertisePolicies = append(m.AdvertisePolicies, &schema.ObjectRefType{})
			if err := m.AdvertisePolicies[len(m.AdvertisePolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &schema.HeaderManipulationOptionType{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToAdd = append(m.ResponseHeadersToAdd, &schema.HeaderManipulationOptionType{})
			if err := m.ResponseHeadersToAdd[len(m.ResponseHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToRemove = append(m.ResponseHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsParameters == nil {
				m.TlsParameters = &schema.DownstreamTlsParamsType{}
			}
			if err := m.TlsParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= VirtualHostType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BufferPolicy == nil {
				m.BufferPolicy = &schema.BufferConfigType{}
			}
			if err := m.BufferPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorsPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CorsPolicy == nil {
				m.CorsPolicy = &schema.CorsPolicy{}
			}
			if err := m.CorsPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			m.Proxy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proxy |= ProxyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToRemove = append(m.RequestHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafType == nil {
				m.WafType = &schema.WafType{}
			}
			if err := m.WafType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicReverseProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DynamicReverseProxy == nil {
				m.DynamicReverseProxy = &DynamicReverseProxyType{}
			}
			if err := m.DynamicReverseProxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddLocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddLocation = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompressionParams == nil {
				m.CompressionParams = &CompressionType{}
			}
			if err := m.CompressionParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomErrors == nil {
				m.CustomErrors = make(map[uint32]string)
			}
			var mapkey uint32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CustomErrors[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestHeaderSize", wireType)
			}
			m.MaxRequestHeaderSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequestHeaderSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JavascriptChallengeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &GetSpecType_JsChallenge{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIdentification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserIdentification = append(m.UserIdentification, &schema.ObjectRefType{})
			if err := m.UserIdentification[len(m.UserIdentification)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiter = append(m.RateLimiter, &schema.ObjectRefType{})
			if err := m.RateLimiter[len(m.RateLimiter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiterAllowedPrefixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiterAllowedPrefixes = append(m.RateLimiterAllowedPrefixes, &schema.ObjectRefType{})
			if err := m.RateLimiterAllowedPrefixes[len(m.RateLimiterAllowedPrefixes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryPolicy == nil {
				m.RetryPolicy = &schema.RetryPolicyType{}
			}
			if err := m.RetryPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptchaChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CaptchaChallengeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &GetSpecType_CaptchaChallenge{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeType = &GetSpecType_NoChallenge{v}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			m.IdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableDefaultErrorPages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableDefaultErrorPages = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableDnsResolve", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableDnsResolve = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporaryUserBlocking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TemporaryUserBlocking == nil {
				m.TemporaryUserBlocking = &TemporaryUserBlockingType{}
			}
			if err := m.TemporaryUserBlocking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoAuthentication", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthenticationChoice = &GetSpecType_NoAuthentication{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authentication", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuthenticationDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthenticationChoice = &GetSpecType_Authentication{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerHeaderChoice = &GetSpecType_DefaultHeader{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerHeaderChoice = &GetSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppendServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerHeaderChoice = &GetSpecType_AppendServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassThrough", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerHeaderChoice = &GetSpecType_PassThrough{v}
			iNdEx = postIndex
		case 1003:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= VirtualHostState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1004:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 1005:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsInfo = append(m.DnsInfo, &virtual_host_dns_info.DnsInfo{})
			if err := m.DnsInfo[len(m.DnsInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1006:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertState", wireType)
			}
			m.AutoCertState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoCertState |= CertificationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1010:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoCertInfo == nil {
				m.AutoCertInfo = &AutoCertInfoType{}
			}
			if err := m.AutoCertInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
