// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package virtual_host

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_authentication "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/authentication"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	ves_io_schema_virtual_host_dns_info "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/virtual_host_dns_info"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *ApiSpec) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ApiSpec) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ApiSpec) DeepCopy() *ApiSpec {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ApiSpec{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ApiSpec) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ApiSpec) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ApiSpecValidator().Validate(ctx, m, opts...)
}

func (m *ApiSpec) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetApiDefinitionDRefInfo()

}

func (m *ApiSpec) GetApiDefinitionDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetApiDefinition()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("api_definition.Object")
	dri := db.DRefInfo{
		RefdType:   "api_definition.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "api_definition",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetApiDefinitionDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ApiSpec) GetApiDefinitionDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "api_definition.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: api_definition")
	}

	vref := m.GetApiDefinition()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "api_definition.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateApiSpec struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateApiSpec) OpenApiValidationChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for open_api_validation_choice")
	}
	return validatorFn, nil
}

func (v *ValidateApiSpec) ApiDefinitionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for api_definition")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateApiSpec) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ApiSpec)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ApiSpec got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_definition"]; exists {

		vOpts := append(opts, db.WithValidateField("api_definition"))
		if err := fv(ctx, m.GetApiDefinition(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["open_api_validation_choice"]; exists {
		val := m.GetOpenApiValidationChoice()
		vOpts := append(opts,
			db.WithValidateField("open_api_validation_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetOpenApiValidationChoice().(type) {
	case *ApiSpec_DisableOpenApiValidation:
		if fv, exists := v.FldValidators["open_api_validation_choice.disable_open_api_validation"]; exists {
			val := m.GetOpenApiValidationChoice().(*ApiSpec_DisableOpenApiValidation).DisableOpenApiValidation
			vOpts := append(opts,
				db.WithValidateField("open_api_validation_choice"),
				db.WithValidateField("disable_open_api_validation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ApiSpec_EnableOpenApiValidation:
		if fv, exists := v.FldValidators["open_api_validation_choice.enable_open_api_validation"]; exists {
			val := m.GetOpenApiValidationChoice().(*ApiSpec_EnableOpenApiValidation).EnableOpenApiValidation
			vOpts := append(opts,
				db.WithValidateField("open_api_validation_choice"),
				db.WithValidateField("enable_open_api_validation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultApiSpecValidator = func() *ValidateApiSpec {
	v := &ValidateApiSpec{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOpenApiValidationChoice := v.OpenApiValidationChoiceValidationRuleHandler
	rulesOpenApiValidationChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhOpenApiValidationChoice(rulesOpenApiValidationChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiSpec.open_api_validation_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["open_api_validation_choice"] = vFn

	vrhApiDefinition := v.ApiDefinitionValidationRuleHandler
	rulesApiDefinition := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhApiDefinition(rulesApiDefinition)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiSpec.api_definition: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_definition"] = vFn

	return v
}()

func ApiSpecValidator() db.Validator {
	return DefaultApiSpecValidator
}

// augmented methods on protoc/std generated struct

func (m *AuthenticationDetails) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AuthenticationDetails) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AuthenticationDetails) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetCookieParams().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AuthenticationDetails.cookie_params")
	}

	return nil
}

func (m *AuthenticationDetails) DeepCopy() *AuthenticationDetails {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AuthenticationDetails{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AuthenticationDetails) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AuthenticationDetails) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AuthenticationDetailsValidator().Validate(ctx, m, opts...)
}

func (m *AuthenticationDetails) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAuthConfigDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAuthConfigDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetCookieParamsChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetCookieParamsChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *AuthenticationDetails) GetAuthConfigDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAuthConfig()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("AuthenticationDetails.auth_config[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "authentication.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "auth_config",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAuthConfigDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *AuthenticationDetails) GetAuthConfigDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "authentication.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: authentication")
	}
	for _, ref := range m.GetAuthConfig() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *AuthenticationDetails) GetCookieParamsChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetCookieParamsChoice() == nil {
		return nil, nil
	}
	switch m.GetCookieParamsChoice().(type) {
	case *AuthenticationDetails_UseAuthObjectConfig:

		return nil, nil

	case *AuthenticationDetails_CookieParams:
		drInfos, err := m.GetCookieParams().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetCookieParams().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "cookie_params." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateAuthenticationDetails struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAuthenticationDetails) RedirectUrlChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for redirect_url_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAuthenticationDetails) RedirectUrlChoiceRedirectUrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_RedirectUrl, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for redirect_url")
	}
	return oValidatorFn_RedirectUrl, nil
}

func (v *ValidateAuthenticationDetails) AuthConfigValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for auth_config")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for auth_config")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated auth_config")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items auth_config")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAuthenticationDetails) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AuthenticationDetails)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AuthenticationDetails got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["auth_config"]; exists {
		vOpts := append(opts, db.WithValidateField("auth_config"))
		if err := fv(ctx, m.GetAuthConfig(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetCookieParamsChoice().(type) {
	case *AuthenticationDetails_UseAuthObjectConfig:
		if fv, exists := v.FldValidators["cookie_params_choice.use_auth_object_config"]; exists {
			val := m.GetCookieParamsChoice().(*AuthenticationDetails_UseAuthObjectConfig).UseAuthObjectConfig
			vOpts := append(opts,
				db.WithValidateField("cookie_params_choice"),
				db.WithValidateField("use_auth_object_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AuthenticationDetails_CookieParams:
		if fv, exists := v.FldValidators["cookie_params_choice.cookie_params"]; exists {
			val := m.GetCookieParamsChoice().(*AuthenticationDetails_CookieParams).CookieParams
			vOpts := append(opts,
				db.WithValidateField("cookie_params_choice"),
				db.WithValidateField("cookie_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["redirect_url_choice"]; exists {
		val := m.GetRedirectUrlChoice()
		vOpts := append(opts,
			db.WithValidateField("redirect_url_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetRedirectUrlChoice().(type) {
	case *AuthenticationDetails_RedirectUrl:
		if fv, exists := v.FldValidators["redirect_url_choice.redirect_url"]; exists {
			val := m.GetRedirectUrlChoice().(*AuthenticationDetails_RedirectUrl).RedirectUrl
			vOpts := append(opts,
				db.WithValidateField("redirect_url_choice"),
				db.WithValidateField("redirect_url"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AuthenticationDetails_RedirectDynamic:
		if fv, exists := v.FldValidators["redirect_url_choice.redirect_dynamic"]; exists {
			val := m.GetRedirectUrlChoice().(*AuthenticationDetails_RedirectDynamic).RedirectDynamic
			vOpts := append(opts,
				db.WithValidateField("redirect_url_choice"),
				db.WithValidateField("redirect_dynamic"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAuthenticationDetailsValidator = func() *ValidateAuthenticationDetails {
	v := &ValidateAuthenticationDetails{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRedirectUrlChoice := v.RedirectUrlChoiceValidationRuleHandler
	rulesRedirectUrlChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhRedirectUrlChoice(rulesRedirectUrlChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AuthenticationDetails.redirect_url_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["redirect_url_choice"] = vFn

	vrhRedirectUrlChoiceRedirectUrl := v.RedirectUrlChoiceRedirectUrlValidationRuleHandler
	rulesRedirectUrlChoiceRedirectUrl := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
		"ves.io.schema.rules.string.min_len": "1",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFnMap["redirect_url_choice.redirect_url"], err = vrhRedirectUrlChoiceRedirectUrl(rulesRedirectUrlChoiceRedirectUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AuthenticationDetails.redirect_url_choice_redirect_url: %s", err)
		panic(errMsg)
	}

	v.FldValidators["redirect_url_choice.redirect_url"] = vFnMap["redirect_url_choice.redirect_url"]

	vrhAuthConfig := v.AuthConfigValidationRuleHandler
	rulesAuthConfig := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhAuthConfig(rulesAuthConfig)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AuthenticationDetails.auth_config: %s", err)
		panic(errMsg)
	}
	v.FldValidators["auth_config"] = vFn

	v.FldValidators["cookie_params_choice.cookie_params"] = ves_io_schema_authentication.CookieParamsValidator().Validate

	return v
}()

func AuthenticationDetailsValidator() db.Validator {
	return DefaultAuthenticationDetailsValidator
}

// augmented methods on protoc/std generated struct

func (m *AutoCertInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AutoCertInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AutoCertInfoType) DeepCopy() *AutoCertInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AutoCertInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AutoCertInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AutoCertInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AutoCertInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAutoCertInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAutoCertInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AutoCertInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AutoCertInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["auto_cert_expiry"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_expiry"))
		if err := fv(ctx, m.GetAutoCertExpiry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_issuer"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_issuer"))
		if err := fv(ctx, m.GetAutoCertIssuer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_state"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_state"))
		if err := fv(ctx, m.GetAutoCertState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_subject"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_subject"))
		if err := fv(ctx, m.GetAutoCertSubject(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_records"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_records"))
		for idx, item := range m.GetDnsRecords() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["state_start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("state_start_time"))
		if err := fv(ctx, m.GetStateStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAutoCertInfoTypeValidator = func() *ValidateAutoCertInfoType {
	v := &ValidateAutoCertInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AutoCertInfoTypeValidator() db.Validator {
	return DefaultAutoCertInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CaptchaChallengeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CaptchaChallengeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CaptchaChallengeType) DeepCopy() *CaptchaChallengeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CaptchaChallengeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CaptchaChallengeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CaptchaChallengeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CaptchaChallengeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCaptchaChallengeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCaptchaChallengeType) CookieExpiryValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cookie_expiry")
	}

	return validatorFn, nil
}

func (v *ValidateCaptchaChallengeType) CustomPageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for custom_page")
	}

	return validatorFn, nil
}

func (v *ValidateCaptchaChallengeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CaptchaChallengeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CaptchaChallengeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cookie_expiry"]; exists {

		vOpts := append(opts, db.WithValidateField("cookie_expiry"))
		if err := fv(ctx, m.GetCookieExpiry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_page"]; exists {

		vOpts := append(opts, db.WithValidateField("custom_page"))
		if err := fv(ctx, m.GetCustomPage(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCaptchaChallengeTypeValidator = func() *ValidateCaptchaChallengeType {
	v := &ValidateCaptchaChallengeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCookieExpiry := v.CookieExpiryValidationRuleHandler
	rulesCookieExpiry := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "86400",
	}
	vFn, err = vrhCookieExpiry(rulesCookieExpiry)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CaptchaChallengeType.cookie_expiry: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookie_expiry"] = vFn

	vrhCustomPage := v.CustomPageValidationRuleHandler
	rulesCustomPage := map[string]string{
		"ves.io.schema.rules.string.max_len": "65536",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFn, err = vrhCustomPage(rulesCustomPage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CaptchaChallengeType.custom_page: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_page"] = vFn

	return v
}()

func CaptchaChallengeTypeValidator() db.Validator {
	return DefaultCaptchaChallengeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CdnServiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CdnServiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CdnServiceType) DeepCopy() *CdnServiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CdnServiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CdnServiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CdnServiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CdnServiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCdnServiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCdnServiceType) ContentChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for content_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCdnServiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CdnServiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CdnServiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_ttl"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_ttl"))
		if err := fv(ctx, m.GetCacheTtl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["content_choice"]; exists {
		val := m.GetContentChoice()
		vOpts := append(opts,
			db.WithValidateField("content_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetContentChoice().(type) {
	case *CdnServiceType_DownloadDelivery:
		if fv, exists := v.FldValidators["content_choice.download_delivery"]; exists {
			val := m.GetContentChoice().(*CdnServiceType_DownloadDelivery).DownloadDelivery
			vOpts := append(opts,
				db.WithValidateField("content_choice"),
				db.WithValidateField("download_delivery"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CdnServiceType_LiveStreaming:
		if fv, exists := v.FldValidators["content_choice.live_streaming"]; exists {
			val := m.GetContentChoice().(*CdnServiceType_LiveStreaming).LiveStreaming
			vOpts := append(opts,
				db.WithValidateField("content_choice"),
				db.WithValidateField("live_streaming"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service_domains"]; exists {

		vOpts := append(opts, db.WithValidateField("service_domains"))
		for idx, item := range m.GetServiceDomains() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCdnServiceTypeValidator = func() *ValidateCdnServiceType {
	v := &ValidateCdnServiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhContentChoice := v.ContentChoiceValidationRuleHandler
	rulesContentChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhContentChoice(rulesContentChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CdnServiceType.content_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["content_choice"] = vFn

	return v
}()

func CdnServiceTypeValidator() db.Validator {
	return DefaultCdnServiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ClientIPHeaders) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ClientIPHeaders) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ClientIPHeaders) DeepCopy() *ClientIPHeaders {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ClientIPHeaders{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ClientIPHeaders) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ClientIPHeaders) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ClientIPHeadersValidator().Validate(ctx, m, opts...)
}

type ValidateClientIPHeaders struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateClientIPHeaders) ClientIpHeadersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for client_ip_headers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for client_ip_headers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated client_ip_headers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items client_ip_headers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateClientIPHeaders) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ClientIPHeaders)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ClientIPHeaders got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["client_ip_headers"]; exists {
		vOpts := append(opts, db.WithValidateField("client_ip_headers"))
		if err := fv(ctx, m.GetClientIpHeaders(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultClientIPHeadersValidator = func() *ValidateClientIPHeaders {
	v := &ValidateClientIPHeaders{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhClientIpHeaders := v.ClientIpHeadersValidationRuleHandler
	rulesClientIpHeaders := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "5",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhClientIpHeaders(rulesClientIpHeaders)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ClientIPHeaders.client_ip_headers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["client_ip_headers"] = vFn

	return v
}()

func ClientIPHeadersValidator() db.Validator {
	return DefaultClientIPHeadersValidator
}

// augmented methods on protoc/std generated struct

func (m *CompressionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CompressionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CompressionType) DeepCopy() *CompressionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CompressionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CompressionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CompressionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CompressionTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCompressionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCompressionType) ContentLengthValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for content_length")
	}

	return validatorFn, nil
}

func (v *ValidateCompressionType) ContentTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for content_type")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for content_type")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated content_type")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items content_type")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCompressionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CompressionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CompressionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["content_length"]; exists {

		vOpts := append(opts, db.WithValidateField("content_length"))
		if err := fv(ctx, m.GetContentLength(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["content_type"]; exists {
		vOpts := append(opts, db.WithValidateField("content_type"))
		if err := fv(ctx, m.GetContentType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_on_etag_header"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_on_etag_header"))
		if err := fv(ctx, m.GetDisableOnEtagHeader(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["remove_accept_encoding_header"]; exists {

		vOpts := append(opts, db.WithValidateField("remove_accept_encoding_header"))
		if err := fv(ctx, m.GetRemoveAcceptEncodingHeader(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCompressionTypeValidator = func() *ValidateCompressionType {
	v := &ValidateCompressionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhContentLength := v.ContentLengthValidationRuleHandler
	rulesContentLength := map[string]string{
		"ves.io.schema.rules.uint32.gte": "30",
	}
	vFn, err = vrhContentLength(rulesContentLength)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CompressionType.content_length: %s", err)
		panic(errMsg)
	}
	v.FldValidators["content_length"] = vFn

	vrhContentType := v.ContentTypeValidationRuleHandler
	rulesContentType := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "50",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhContentType(rulesContentType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CompressionType.content_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["content_type"] = vFn

	return v
}()

func CompressionTypeValidator() db.Validator {
	return DefaultCompressionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CreateSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetRequestHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting CreateSpecType.request_headers_to_add idx %v", idx)
		}
	}

	for idx, e := range m.GetResponseHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting CreateSpecType.response_headers_to_add idx %v", idx)
		}
	}

	if err := m.GetTlsParameters().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.tls_parameters")
	}

	if err := m.GetAuthentication().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.authentication")
	}

	return nil
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAdvertisePoliciesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAdvertisePoliciesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetApiSpecDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetApiSpecDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetAuthenticationChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAuthenticationChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDnsProxyConfigurationDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDnsProxyConfigurationDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDynamicReverseProxyDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDynamicReverseProxyDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRateLimiterDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterAllowedPrefixesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRateLimiterAllowedPrefixesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRoutesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRoutesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTlsCertificatesChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTlsCertificatesChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetUserIdentificationDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetUserIdentificationDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWafTypeDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetWafTypeDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *CreateSpecType) GetAdvertisePoliciesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAdvertisePolicies()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.advertise_policies[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "advertise_policy.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "advertise_policies",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAdvertisePoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetAdvertisePoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "advertise_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: advertise_policy")
	}
	for _, ref := range m.GetAdvertisePolicies() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetApiSpecDRefInfo() ([]db.DRefInfo, error) {
	if m.GetApiSpec() == nil {
		return nil, nil
	}

	drInfos, err := m.GetApiSpec().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetApiSpec().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "api_spec." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetAuthenticationChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAuthenticationChoice() == nil {
		return nil, nil
	}
	switch m.GetAuthenticationChoice().(type) {
	case *CreateSpecType_NoAuthentication:

		return nil, nil

	case *CreateSpecType_Authentication:
		drInfos, err := m.GetAuthentication().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAuthentication().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "authentication." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetDnsProxyConfigurationDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDnsProxyConfiguration() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDnsProxyConfiguration().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDnsProxyConfiguration().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "dns_proxy_configuration." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetDynamicReverseProxyDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDynamicReverseProxy() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDynamicReverseProxy().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDynamicReverseProxy().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "dynamic_reverse_proxy." + dri.DRField
	}
	return drInfos, err

}

func (m *CreateSpecType) GetRateLimiterDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRateLimiter()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.rate_limiter[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "rate_limiter.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRateLimiterDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetRateLimiterDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "rate_limiter.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: rate_limiter")
	}
	for _, ref := range m.GetRateLimiter() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *CreateSpecType) GetRateLimiterAllowedPrefixesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRateLimiterAllowedPrefixes()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.rate_limiter_allowed_prefixes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "ip_prefix_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter_allowed_prefixes",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRateLimiterAllowedPrefixesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetRateLimiterAllowedPrefixesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "ip_prefix_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: ip_prefix_set")
	}
	for _, ref := range m.GetRateLimiterAllowedPrefixes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *CreateSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRoutes()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.routes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "route.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "routes",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRoutesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetRoutesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "route.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: route")
	}
	for _, ref := range m.GetRoutes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetTlsCertificatesChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTlsCertificatesChoice() == nil {
		return nil, nil
	}
	switch m.GetTlsCertificatesChoice().(type) {
	case *CreateSpecType_TlsParameters:
		drInfos, err := m.GetTlsParameters().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTlsParameters().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tls_parameters." + dri.DRField
		}
		return drInfos, err

	case *CreateSpecType_TlsCertParams:
		drInfos, err := m.GetTlsCertParams().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTlsCertParams().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tls_cert_params." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *CreateSpecType) GetUserIdentificationDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetUserIdentification()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.user_identification[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "user_identification.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "user_identification",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetUserIdentificationDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetUserIdentificationDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "user_identification.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: user_identification")
	}
	for _, ref := range m.GetUserIdentification() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetWafTypeDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWafType() == nil {
		return nil, nil
	}

	drInfos, err := m.GetWafType().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetWafType().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "waf_type." + dri.DRField
	}
	return drInfos, err

}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) ChallengeTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for challenge_type")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ServerHeaderChoiceServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_name")
	}
	return oValidatorFn_ServerName, nil
}
func (v *ValidateCreateSpecType) ServerHeaderChoiceAppendServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_AppendServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for append_server_name")
	}
	return oValidatorFn_AppendServerName, nil
}

func (v *ValidateCreateSpecType) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for routes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) RequestHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for request_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ResponseHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for response_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ResponseHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ProxyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ProxyType)
		return int32(i)
	}
	// ProxyType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ProxyType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for proxy")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) RequestHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) CustomErrorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapUint32KeyRules(rules)
	itemKeyFn, err := db.NewUint32ValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for custom_errors")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for custom_errors")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[uint32]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for custom_errors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[uint32]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ uint32 ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map custom_errors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items custom_errors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) MaxRequestHeaderSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_request_header_size")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) UserIdentificationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for user_identification")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for user_identification")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated user_identification")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items user_identification")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) RateLimiterValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rate_limiter")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) RateLimiterAllowedPrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter_allowed_prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter_allowed_prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) CookiesToModifyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cookies_to_modify")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.CookieManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.CookieManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cookies_to_modify")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.CookieManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.CookieManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cookies_to_modify")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cookies_to_modify")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ConnectionIdleTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_idle_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_location"]; exists {

		vOpts := append(opts, db.WithValidateField("add_location"))
		if err := fv(ctx, m.GetAddLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["advertise_policies"]; exists {

		vOpts := append(opts, db.WithValidateField("advertise_policies"))
		for idx, item := range m.GetAdvertisePolicies() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["api_spec"]; exists {

		vOpts := append(opts, db.WithValidateField("api_spec"))
		if err := fv(ctx, m.GetApiSpec(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetAuthenticationChoice().(type) {
	case *CreateSpecType_NoAuthentication:
		if fv, exists := v.FldValidators["authentication_choice.no_authentication"]; exists {
			val := m.GetAuthenticationChoice().(*CreateSpecType_NoAuthentication).NoAuthentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("no_authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Authentication:
		if fv, exists := v.FldValidators["authentication_choice.authentication"]; exists {
			val := m.GetAuthenticationChoice().(*CreateSpecType_Authentication).Authentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["buffer_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("buffer_policy"))
		if err := fv(ctx, m.GetBufferPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["challenge_type"]; exists {
		val := m.GetChallengeType()
		vOpts := append(opts,
			db.WithValidateField("challenge_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChallengeType().(type) {
	case *CreateSpecType_JsChallenge:
		if fv, exists := v.FldValidators["challenge_type.js_challenge"]; exists {
			val := m.GetChallengeType().(*CreateSpecType_JsChallenge).JsChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("js_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_CaptchaChallenge:
		if fv, exists := v.FldValidators["challenge_type.captcha_challenge"]; exists {
			val := m.GetChallengeType().(*CreateSpecType_CaptchaChallenge).CaptchaChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("captcha_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_NoChallenge:
		if fv, exists := v.FldValidators["challenge_type.no_challenge"]; exists {
			val := m.GetChallengeType().(*CreateSpecType_NoChallenge).NoChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("no_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["compression_params"]; exists {

		vOpts := append(opts, db.WithValidateField("compression_params"))
		if err := fv(ctx, m.GetCompressionParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connection_idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_idle_timeout"))
		if err := fv(ctx, m.GetConnectionIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cookies_to_modify"]; exists {
		vOpts := append(opts, db.WithValidateField("cookies_to_modify"))
		if err := fv(ctx, m.GetCookiesToModify(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cors_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("cors_policy"))
		if err := fv(ctx, m.GetCorsPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["csrf_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("csrf_policy"))
		if err := fv(ctx, m.GetCsrfPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_errors"]; exists {
		vOpts := append(opts, db.WithValidateField("custom_errors"))
		if err := fv(ctx, m.GetCustomErrors(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetDefaultLbChoice().(type) {
	case *CreateSpecType_NonDefaultLoadbalancer:
		if fv, exists := v.FldValidators["default_lb_choice.non_default_loadbalancer"]; exists {
			val := m.GetDefaultLbChoice().(*CreateSpecType_NonDefaultLoadbalancer).NonDefaultLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("default_lb_choice"),
				db.WithValidateField("non_default_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DefaultLoadbalancer:
		if fv, exists := v.FldValidators["default_lb_choice.default_loadbalancer"]; exists {
			val := m.GetDefaultLbChoice().(*CreateSpecType_DefaultLoadbalancer).DefaultLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("default_lb_choice"),
				db.WithValidateField("default_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["disable_default_error_pages"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_default_error_pages"))
		if err := fv(ctx, m.GetDisableDefaultErrorPages(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_dns_resolve"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_dns_resolve"))
		if err := fv(ctx, m.GetDisableDnsResolve(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_proxy_configuration"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_proxy_configuration"))
		if err := fv(ctx, m.GetDnsProxyConfiguration(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domain_cert_map"]; exists {

		vOpts := append(opts, db.WithValidateField("domain_cert_map"))
		for key, value := range m.GetDomainCertMap() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dynamic_reverse_proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("dynamic_reverse_proxy"))
		if err := fv(ctx, m.GetDynamicReverseProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header_transformation_type"]; exists {

		vOpts := append(opts, db.WithValidateField("header_transformation_type"))
		if err := fv(ctx, m.GetHeaderTransformationType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("idle_timeout"))
		if err := fv(ctx, m.GetIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_request_header_size"]; exists {

		vOpts := append(opts, db.WithValidateField("max_request_header_size"))
		if err := fv(ctx, m.GetMaxRequestHeaderSize(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetPathNormalizeChoice().(type) {
	case *CreateSpecType_EnablePathNormalize:
		if fv, exists := v.FldValidators["path_normalize_choice.enable_path_normalize"]; exists {
			val := m.GetPathNormalizeChoice().(*CreateSpecType_EnablePathNormalize).EnablePathNormalize
			vOpts := append(opts,
				db.WithValidateField("path_normalize_choice"),
				db.WithValidateField("enable_path_normalize"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DisablePathNormalize:
		if fv, exists := v.FldValidators["path_normalize_choice.disable_path_normalize"]; exists {
			val := m.GetPathNormalizeChoice().(*CreateSpecType_DisablePathNormalize).DisablePathNormalize
			vOpts := append(opts,
				db.WithValidateField("path_normalize_choice"),
				db.WithValidateField("disable_path_normalize"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("proxy"))
		if err := fv(ctx, m.GetProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter"))
		if err := fv(ctx, m.GetRateLimiter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter_allowed_prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter_allowed_prefixes"))
		if err := fv(ctx, m.GetRateLimiterAllowedPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_add"))
		if err := fv(ctx, m.GetRequestHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_remove"))
		if err := fv(ctx, m.GetRequestHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_add"))
		if err := fv(ctx, m.GetResponseHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_remove"))
		if err := fv(ctx, m.GetResponseHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["retry_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("retry_policy"))
		if err := fv(ctx, m.GetRetryPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetServerHeaderChoice().(type) {
	case *CreateSpecType_DefaultHeader:
		if fv, exists := v.FldValidators["server_header_choice.default_header"]; exists {
			val := m.GetServerHeaderChoice().(*CreateSpecType_DefaultHeader).DefaultHeader
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("default_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_ServerName:
		if fv, exists := v.FldValidators["server_header_choice.server_name"]; exists {
			val := m.GetServerHeaderChoice().(*CreateSpecType_ServerName).ServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_AppendServerName:
		if fv, exists := v.FldValidators["server_header_choice.append_server_name"]; exists {
			val := m.GetServerHeaderChoice().(*CreateSpecType_AppendServerName).AppendServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("append_server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_PassThrough:
		if fv, exists := v.FldValidators["server_header_choice.pass_through"]; exists {
			val := m.GetServerHeaderChoice().(*CreateSpecType_PassThrough).PassThrough
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("pass_through"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["slow_ddos_mitigation"]; exists {

		vOpts := append(opts, db.WithValidateField("slow_ddos_mitigation"))
		if err := fv(ctx, m.GetSlowDdosMitigation(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetStrictSniHostHeaderCheckChoice().(type) {
	case *CreateSpecType_EnableStrictSniHostHeaderCheck:
		if fv, exists := v.FldValidators["strict_sni_host_header_check_choice.enable_strict_sni_host_header_check"]; exists {
			val := m.GetStrictSniHostHeaderCheckChoice().(*CreateSpecType_EnableStrictSniHostHeaderCheck).EnableStrictSniHostHeaderCheck
			vOpts := append(opts,
				db.WithValidateField("strict_sni_host_header_check_choice"),
				db.WithValidateField("enable_strict_sni_host_header_check"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_AdditionalDomains:
		if fv, exists := v.FldValidators["strict_sni_host_header_check_choice.additional_domains"]; exists {
			val := m.GetStrictSniHostHeaderCheckChoice().(*CreateSpecType_AdditionalDomains).AdditionalDomains
			vOpts := append(opts,
				db.WithValidateField("strict_sni_host_header_check_choice"),
				db.WithValidateField("additional_domains"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["temporary_user_blocking"]; exists {

		vOpts := append(opts, db.WithValidateField("temporary_user_blocking"))
		if err := fv(ctx, m.GetTemporaryUserBlocking(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetTlsCertificatesChoice().(type) {
	case *CreateSpecType_TlsParameters:
		if fv, exists := v.FldValidators["tls_certificates_choice.tls_parameters"]; exists {
			val := m.GetTlsCertificatesChoice().(*CreateSpecType_TlsParameters).TlsParameters
			vOpts := append(opts,
				db.WithValidateField("tls_certificates_choice"),
				db.WithValidateField("tls_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_TlsCertParams:
		if fv, exists := v.FldValidators["tls_certificates_choice.tls_cert_params"]; exists {
			val := m.GetTlsCertificatesChoice().(*CreateSpecType_TlsCertParams).TlsCertParams
			vOpts := append(opts,
				db.WithValidateField("tls_certificates_choice"),
				db.WithValidateField("tls_cert_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["user_identification"]; exists {
		vOpts := append(opts, db.WithValidateField("user_identification"))
		if err := fv(ctx, m.GetUserIdentification(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["waf_type"]; exists {

		vOpts := append(opts, db.WithValidateField("waf_type"))
		if err := fv(ctx, m.GetWafType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChallengeType := v.ChallengeTypeValidationRuleHandler
	rulesChallengeType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChallengeType(rulesChallengeType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.challenge_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["challenge_type"] = vFn

	vrhServerHeaderChoiceServerName := v.ServerHeaderChoiceServerNameValidationRuleHandler
	rulesServerHeaderChoiceServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.server_name"], err = vrhServerHeaderChoiceServerName(rulesServerHeaderChoiceServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CreateSpecType.server_header_choice_server_name: %s", err)
		panic(errMsg)
	}
	vrhServerHeaderChoiceAppendServerName := v.ServerHeaderChoiceAppendServerNameValidationRuleHandler
	rulesServerHeaderChoiceAppendServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.append_server_name"], err = vrhServerHeaderChoiceAppendServerName(rulesServerHeaderChoiceAppendServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CreateSpecType.server_header_choice_append_server_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["server_header_choice.server_name"] = vFnMap["server_header_choice.server_name"]
	v.FldValidators["server_header_choice.append_server_name"] = vFnMap["server_header_choice.append_server_name"]

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.repeated.items.string.vh_domain": "true",
		"ves.io.schema.rules.repeated.max_items":              "33",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "256",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	vrhRequestHeadersToAdd := v.RequestHeadersToAddValidationRuleHandler
	rulesRequestHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToAdd(rulesRequestHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.request_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_add"] = vFn

	vrhResponseHeadersToAdd := v.ResponseHeadersToAddValidationRuleHandler
	rulesResponseHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToAdd(rulesResponseHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.response_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_add"] = vFn

	vrhResponseHeadersToRemove := v.ResponseHeadersToRemoveValidationRuleHandler
	rulesResponseHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToRemove(rulesResponseHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.response_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_remove"] = vFn

	vrhProxy := v.ProxyValidationRuleHandler
	rulesProxy := map[string]string{
		"ves.io.schema.rules.enum.in": "[4,5]",
	}
	vFn, err = vrhProxy(rulesProxy)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.proxy: %s", err)
		panic(errMsg)
	}
	v.FldValidators["proxy"] = vFn

	vrhRequestHeadersToRemove := v.RequestHeadersToRemoveValidationRuleHandler
	rulesRequestHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToRemove(rulesRequestHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.request_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_remove"] = vFn

	vrhCustomErrors := v.CustomErrorsValidationRuleHandler
	rulesCustomErrors := map[string]string{
		"ves.io.schema.rules.map.keys.uint32.gte":       "3",
		"ves.io.schema.rules.map.keys.uint32.lte":       "599",
		"ves.io.schema.rules.map.max_pairs":             "16",
		"ves.io.schema.rules.map.values.string.max_len": "65536",
		"ves.io.schema.rules.map.values.string.uri_ref": "true",
	}
	vFn, err = vrhCustomErrors(rulesCustomErrors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.custom_errors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_errors"] = vFn

	vrhMaxRequestHeaderSize := v.MaxRequestHeaderSizeValidationRuleHandler
	rulesMaxRequestHeaderSize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "96",
	}
	vFn, err = vrhMaxRequestHeaderSize(rulesMaxRequestHeaderSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.max_request_header_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_request_header_size"] = vFn

	vrhUserIdentification := v.UserIdentificationValidationRuleHandler
	rulesUserIdentification := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhUserIdentification(rulesUserIdentification)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.user_identification: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user_identification"] = vFn

	vrhRateLimiter := v.RateLimiterValidationRuleHandler
	rulesRateLimiter := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRateLimiter(rulesRateLimiter)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.rate_limiter: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter"] = vFn

	vrhRateLimiterAllowedPrefixes := v.RateLimiterAllowedPrefixesValidationRuleHandler
	rulesRateLimiterAllowedPrefixes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhRateLimiterAllowedPrefixes(rulesRateLimiterAllowedPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.rate_limiter_allowed_prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter_allowed_prefixes"] = vFn

	vrhCookiesToModify := v.CookiesToModifyValidationRuleHandler
	rulesCookiesToModify := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhCookiesToModify(rulesCookiesToModify)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.cookies_to_modify: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookies_to_modify"] = vFn

	vrhConnectionIdleTimeout := v.ConnectionIdleTimeoutValidationRuleHandler
	rulesConnectionIdleTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhConnectionIdleTimeout(rulesConnectionIdleTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.connection_idle_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_idle_timeout"] = vFn

	v.FldValidators["authentication_choice.authentication"] = AuthenticationDetailsValidator().Validate

	v.FldValidators["challenge_type.js_challenge"] = JavascriptChallengeTypeValidator().Validate
	v.FldValidators["challenge_type.captcha_challenge"] = CaptchaChallengeTypeValidator().Validate

	v.FldValidators["strict_sni_host_header_check_choice.additional_domains"] = ves_io_schema.DomainNameListValidator().Validate

	v.FldValidators["tls_certificates_choice.tls_parameters"] = ves_io_schema.DownstreamTlsParamsTypeValidator().Validate
	v.FldValidators["tls_certificates_choice.tls_cert_params"] = ves_io_schema.CertificateParamsTypeValidator().Validate

	v.FldValidators["buffer_policy"] = ves_io_schema.BufferConfigTypeValidator().Validate

	v.FldValidators["cors_policy"] = ves_io_schema.CorsPolicyValidator().Validate

	v.FldValidators["waf_type"] = ves_io_schema.WafTypeValidator().Validate

	v.FldValidators["dynamic_reverse_proxy"] = DynamicReverseProxyTypeValidator().Validate

	v.FldValidators["compression_params"] = CompressionTypeValidator().Validate

	v.FldValidators["retry_policy"] = ves_io_schema.RetryPolicyTypeValidator().Validate

	v.FldValidators["temporary_user_blocking"] = TemporaryUserBlockingTypeValidator().Validate

	v.FldValidators["header_transformation_type"] = ves_io_schema.HeaderTransformationTypeValidator().Validate

	v.FldValidators["csrf_policy"] = ves_io_schema.CsrfPolicyValidator().Validate

	v.FldValidators["slow_ddos_mitigation"] = SlowDDoSMitigationValidator().Validate

	v.FldValidators["api_spec"] = ApiSpecValidator().Validate

	v.FldValidators["domain_cert_map"] = DomainCertificatesValidator().Validate

	v.FldValidators["dns_proxy_configuration"] = DNSProxyConfigurationValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DNSCacheProfile) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DNSCacheProfile) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DNSCacheProfile) DeepCopy() *DNSCacheProfile {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DNSCacheProfile{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DNSCacheProfile) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DNSCacheProfile) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DNSCacheProfileValidator().Validate(ctx, m, opts...)
}

type ValidateDNSCacheProfile struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDNSCacheProfile) CacheProfileChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_profile_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDNSCacheProfile) CacheProfileChoiceCacheSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_CacheSize, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_size")
	}
	return oValidatorFn_CacheSize, nil
}

func (v *ValidateDNSCacheProfile) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DNSCacheProfile)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DNSCacheProfile got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_profile_choice"]; exists {
		val := m.GetCacheProfileChoice()
		vOpts := append(opts,
			db.WithValidateField("cache_profile_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCacheProfileChoice().(type) {
	case *DNSCacheProfile_DisableCacheProfile:
		if fv, exists := v.FldValidators["cache_profile_choice.disable_cache_profile"]; exists {
			val := m.GetCacheProfileChoice().(*DNSCacheProfile_DisableCacheProfile).DisableCacheProfile
			vOpts := append(opts,
				db.WithValidateField("cache_profile_choice"),
				db.WithValidateField("disable_cache_profile"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DNSCacheProfile_CacheSize:
		if fv, exists := v.FldValidators["cache_profile_choice.cache_size"]; exists {
			val := m.GetCacheProfileChoice().(*DNSCacheProfile_CacheSize).CacheSize
			vOpts := append(opts,
				db.WithValidateField("cache_profile_choice"),
				db.WithValidateField("cache_size"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDNSCacheProfileValidator = func() *ValidateDNSCacheProfile {
	v := &ValidateDNSCacheProfile{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCacheProfileChoice := v.CacheProfileChoiceValidationRuleHandler
	rulesCacheProfileChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCacheProfileChoice(rulesCacheProfileChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DNSCacheProfile.cache_profile_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cache_profile_choice"] = vFn

	vrhCacheProfileChoiceCacheSize := v.CacheProfileChoiceCacheSizeValidationRuleHandler
	rulesCacheProfileChoiceCacheSize := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "10240",
	}
	vFnMap["cache_profile_choice.cache_size"], err = vrhCacheProfileChoiceCacheSize(rulesCacheProfileChoiceCacheSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DNSCacheProfile.cache_profile_choice_cache_size: %s", err)
		panic(errMsg)
	}

	v.FldValidators["cache_profile_choice.cache_size"] = vFnMap["cache_profile_choice.cache_size"]

	return v
}()

func DNSCacheProfileValidator() db.Validator {
	return DefaultDNSCacheProfileValidator
}

// augmented methods on protoc/std generated struct

func (m *DNSDDoSProfile) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DNSDDoSProfile) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DNSDDoSProfile) DeepCopy() *DNSDDoSProfile {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DNSDDoSProfile{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DNSDDoSProfile) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DNSDDoSProfile) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DNSDDoSProfileValidator().Validate(ctx, m, opts...)
}

type ValidateDNSDDoSProfile struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDNSDDoSProfile) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DNSDDoSProfile)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DNSDDoSProfile got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetDdosMitigationChoice().(type) {
	case *DNSDDoSProfile_EnableDdosMitigation:
		if fv, exists := v.FldValidators["ddos_mitigation_choice.enable_ddos_mitigation"]; exists {
			val := m.GetDdosMitigationChoice().(*DNSDDoSProfile_EnableDdosMitigation).EnableDdosMitigation
			vOpts := append(opts,
				db.WithValidateField("ddos_mitigation_choice"),
				db.WithValidateField("enable_ddos_mitigation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DNSDDoSProfile_DisableDdosMitigation:
		if fv, exists := v.FldValidators["ddos_mitigation_choice.disable_ddos_mitigation"]; exists {
			val := m.GetDdosMitigationChoice().(*DNSDDoSProfile_DisableDdosMitigation).DisableDdosMitigation
			vOpts := append(opts,
				db.WithValidateField("ddos_mitigation_choice"),
				db.WithValidateField("disable_ddos_mitigation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDNSDDoSProfileValidator = func() *ValidateDNSDDoSProfile {
	v := &ValidateDNSDDoSProfile{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DNSDDoSProfileValidator() db.Validator {
	return DefaultDNSDDoSProfileValidator
}

// augmented methods on protoc/std generated struct

func (m *DNSProxyConfiguration) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DNSProxyConfiguration) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DNSProxyConfiguration) DeepCopy() *DNSProxyConfiguration {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DNSProxyConfiguration{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DNSProxyConfiguration) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DNSProxyConfiguration) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DNSProxyConfigurationValidator().Validate(ctx, m, opts...)
}

func (m *DNSProxyConfiguration) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetProtocolInspectionDRefInfo()

}

func (m *DNSProxyConfiguration) GetProtocolInspectionDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetProtocolInspection()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("protocol_inspection.Object")
	dri := db.DRefInfo{
		RefdType:   "protocol_inspection.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "protocol_inspection",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetProtocolInspectionDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *DNSProxyConfiguration) GetProtocolInspectionDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "protocol_inspection.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: protocol_inspection")
	}

	vref := m.GetProtocolInspection()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "protocol_inspection.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateDNSProxyConfiguration struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDNSProxyConfiguration) DdosProfileValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for ddos_profile")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDNSProxyConfiguration) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DNSProxyConfiguration)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DNSProxyConfiguration got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_profile"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_profile"))
		if err := fv(ctx, m.GetCacheProfile(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ddos_profile"]; exists {

		vOpts := append(opts, db.WithValidateField("ddos_profile"))
		if err := fv(ctx, m.GetDdosProfile(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["protocol_inspection"]; exists {

		vOpts := append(opts, db.WithValidateField("protocol_inspection"))
		if err := fv(ctx, m.GetProtocolInspection(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDNSProxyConfigurationValidator = func() *ValidateDNSProxyConfiguration {
	v := &ValidateDNSProxyConfiguration{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDdosProfile := v.DdosProfileValidationRuleHandler
	rulesDdosProfile := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDdosProfile(rulesDdosProfile)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DNSProxyConfiguration.ddos_profile: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ddos_profile"] = vFn

	v.FldValidators["cache_profile"] = DNSCacheProfileValidator().Validate

	v.FldValidators["protocol_inspection"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func DNSProxyConfigurationValidator() db.Validator {
	return DefaultDNSProxyConfigurationValidator
}

// augmented methods on protoc/std generated struct

func (m *DNSRecord) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DNSRecord) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DNSRecord) DeepCopy() *DNSRecord {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DNSRecord{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DNSRecord) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DNSRecord) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DNSRecordValidator().Validate(ctx, m, opts...)
}

type ValidateDNSRecord struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDNSRecord) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DNSRecord)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DNSRecord got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDNSRecordValidator = func() *ValidateDNSRecord {
	v := &ValidateDNSRecord{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DNSRecordValidator() db.Validator {
	return DefaultDNSRecordValidator
}

// augmented methods on protoc/std generated struct

func (m *DomainCertificates) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DomainCertificates) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DomainCertificates) DeepCopy() *DomainCertificates {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DomainCertificates{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DomainCertificates) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DomainCertificates) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DomainCertificatesValidator().Validate(ctx, m, opts...)
}

type ValidateDomainCertificates struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDomainCertificates) RsaCertificatesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rsa_certificates")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rsa_certificates")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rsa_certificates")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rsa_certificates")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDomainCertificates) EcdsaCertificatesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for ecdsa_certificates")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ecdsa_certificates")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ecdsa_certificates")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ecdsa_certificates")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDomainCertificates) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DomainCertificates)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DomainCertificates got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ecdsa_certificates"]; exists {
		vOpts := append(opts, db.WithValidateField("ecdsa_certificates"))
		if err := fv(ctx, m.GetEcdsaCertificates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rsa_certificates"]; exists {
		vOpts := append(opts, db.WithValidateField("rsa_certificates"))
		if err := fv(ctx, m.GetRsaCertificates(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDomainCertificatesValidator = func() *ValidateDomainCertificates {
	v := &ValidateDomainCertificates{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRsaCertificates := v.RsaCertificatesValidationRuleHandler
	rulesRsaCertificates := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRsaCertificates(rulesRsaCertificates)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DomainCertificates.rsa_certificates: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rsa_certificates"] = vFn

	vrhEcdsaCertificates := v.EcdsaCertificatesValidationRuleHandler
	rulesEcdsaCertificates := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhEcdsaCertificates(rulesEcdsaCertificates)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DomainCertificates.ecdsa_certificates: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ecdsa_certificates"] = vFn

	return v
}()

func DomainCertificatesValidator() db.Validator {
	return DefaultDomainCertificatesValidator
}

// augmented methods on protoc/std generated struct

func (m *DynamicReverseProxyType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DynamicReverseProxyType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DynamicReverseProxyType) DeepCopy() *DynamicReverseProxyType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DynamicReverseProxyType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DynamicReverseProxyType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DynamicReverseProxyType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DynamicReverseProxyTypeValidator().Validate(ctx, m, opts...)
}

func (m *DynamicReverseProxyType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetResolutionNetworkDRefInfo()

}

func (m *DynamicReverseProxyType) GetResolutionNetworkDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetResolutionNetwork()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("DynamicReverseProxyType.resolution_network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "resolution_network",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetResolutionNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *DynamicReverseProxyType) GetResolutionNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetResolutionNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateDynamicReverseProxyType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDynamicReverseProxyType) ConnectionTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateDynamicReverseProxyType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DynamicReverseProxyType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DynamicReverseProxyType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["connection_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_timeout"))
		if err := fv(ctx, m.GetConnectionTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["resolution_network"]; exists {

		vOpts := append(opts, db.WithValidateField("resolution_network"))
		for idx, item := range m.GetResolutionNetwork() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["resolution_network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("resolution_network_type"))
		if err := fv(ctx, m.GetResolutionNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["resolve_endpoint_dynamically"]; exists {

		vOpts := append(opts, db.WithValidateField("resolve_endpoint_dynamically"))
		if err := fv(ctx, m.GetResolveEndpointDynamically(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDynamicReverseProxyTypeValidator = func() *ValidateDynamicReverseProxyType {
	v := &ValidateDynamicReverseProxyType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhConnectionTimeout := v.ConnectionTimeoutValidationRuleHandler
	rulesConnectionTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhConnectionTimeout(rulesConnectionTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DynamicReverseProxyType.connection_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_timeout"] = vFn

	return v
}()

func DynamicReverseProxyTypeValidator() db.Validator {
	return DefaultDynamicReverseProxyTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GetSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetRequestHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting GetSpecType.request_headers_to_add idx %v", idx)
		}
	}

	for idx, e := range m.GetResponseHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting GetSpecType.response_headers_to_add idx %v", idx)
		}
	}

	if err := m.GetTlsParameters().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.tls_parameters")
	}

	if err := m.GetAuthentication().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.authentication")
	}

	return nil
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAdvertisePoliciesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAdvertisePoliciesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetApiSpecDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetApiSpecDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetAuthenticationChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAuthenticationChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDnsProxyConfigurationDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDnsProxyConfigurationDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDynamicReverseProxyDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDynamicReverseProxyDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRateLimiterDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterAllowedPrefixesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRateLimiterAllowedPrefixesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRoutesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRoutesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTlsCertificatesChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTlsCertificatesChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetUserIdentificationDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetUserIdentificationDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWafTypeDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetWafTypeDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GetSpecType) GetAdvertisePoliciesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAdvertisePolicies()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.advertise_policies[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "advertise_policy.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "advertise_policies",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAdvertisePoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetAdvertisePoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "advertise_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: advertise_policy")
	}
	for _, ref := range m.GetAdvertisePolicies() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetApiSpecDRefInfo() ([]db.DRefInfo, error) {
	if m.GetApiSpec() == nil {
		return nil, nil
	}

	drInfos, err := m.GetApiSpec().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetApiSpec().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "api_spec." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetAuthenticationChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAuthenticationChoice() == nil {
		return nil, nil
	}
	switch m.GetAuthenticationChoice().(type) {
	case *GetSpecType_NoAuthentication:

		return nil, nil

	case *GetSpecType_Authentication:
		drInfos, err := m.GetAuthentication().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAuthentication().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "authentication." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetDnsProxyConfigurationDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDnsProxyConfiguration() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDnsProxyConfiguration().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDnsProxyConfiguration().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "dns_proxy_configuration." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetDynamicReverseProxyDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDynamicReverseProxy() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDynamicReverseProxy().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDynamicReverseProxy().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "dynamic_reverse_proxy." + dri.DRField
	}
	return drInfos, err

}

func (m *GetSpecType) GetRateLimiterDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRateLimiter()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.rate_limiter[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "rate_limiter.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRateLimiterDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetRateLimiterDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "rate_limiter.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: rate_limiter")
	}
	for _, ref := range m.GetRateLimiter() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GetSpecType) GetRateLimiterAllowedPrefixesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRateLimiterAllowedPrefixes()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.rate_limiter_allowed_prefixes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "ip_prefix_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter_allowed_prefixes",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRateLimiterAllowedPrefixesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetRateLimiterAllowedPrefixesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "ip_prefix_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: ip_prefix_set")
	}
	for _, ref := range m.GetRateLimiterAllowedPrefixes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GetSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRoutes()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.routes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "route.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "routes",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRoutesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetRoutesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "route.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: route")
	}
	for _, ref := range m.GetRoutes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetTlsCertificatesChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTlsCertificatesChoice() == nil {
		return nil, nil
	}
	switch m.GetTlsCertificatesChoice().(type) {
	case *GetSpecType_TlsParameters:
		drInfos, err := m.GetTlsParameters().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTlsParameters().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tls_parameters." + dri.DRField
		}
		return drInfos, err

	case *GetSpecType_TlsCertParams:
		drInfos, err := m.GetTlsCertParams().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTlsCertParams().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tls_cert_params." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *GetSpecType) GetUserIdentificationDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetUserIdentification()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.user_identification[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "user_identification.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "user_identification",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetUserIdentificationDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetUserIdentificationDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "user_identification.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: user_identification")
	}
	for _, ref := range m.GetUserIdentification() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetWafTypeDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWafType() == nil {
		return nil, nil
	}

	drInfos, err := m.GetWafType().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetWafType().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "waf_type." + dri.DRField
	}
	return drInfos, err

}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) ChallengeTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for challenge_type")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) ServerHeaderChoiceServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_name")
	}
	return oValidatorFn_ServerName, nil
}
func (v *ValidateGetSpecType) ServerHeaderChoiceAppendServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_AppendServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for append_server_name")
	}
	return oValidatorFn_AppendServerName, nil
}

func (v *ValidateGetSpecType) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for routes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) RequestHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for request_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) ResponseHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for response_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) ResponseHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) RequestHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) CustomErrorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapUint32KeyRules(rules)
	itemKeyFn, err := db.NewUint32ValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for custom_errors")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for custom_errors")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[uint32]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for custom_errors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[uint32]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ uint32 ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map custom_errors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items custom_errors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) MaxRequestHeaderSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_request_header_size")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) UserIdentificationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for user_identification")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for user_identification")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated user_identification")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items user_identification")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) RateLimiterValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rate_limiter")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) RateLimiterAllowedPrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter_allowed_prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter_allowed_prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) CookiesToModifyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cookies_to_modify")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.CookieManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.CookieManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cookies_to_modify")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.CookieManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.CookieManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cookies_to_modify")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cookies_to_modify")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) ConnectionIdleTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_idle_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_location"]; exists {

		vOpts := append(opts, db.WithValidateField("add_location"))
		if err := fv(ctx, m.GetAddLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["advertise_policies"]; exists {

		vOpts := append(opts, db.WithValidateField("advertise_policies"))
		for idx, item := range m.GetAdvertisePolicies() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["api_spec"]; exists {

		vOpts := append(opts, db.WithValidateField("api_spec"))
		if err := fv(ctx, m.GetApiSpec(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetAuthenticationChoice().(type) {
	case *GetSpecType_NoAuthentication:
		if fv, exists := v.FldValidators["authentication_choice.no_authentication"]; exists {
			val := m.GetAuthenticationChoice().(*GetSpecType_NoAuthentication).NoAuthentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("no_authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Authentication:
		if fv, exists := v.FldValidators["authentication_choice.authentication"]; exists {
			val := m.GetAuthenticationChoice().(*GetSpecType_Authentication).Authentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["auto_cert_error_msg"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_error_msg"))
		if err := fv(ctx, m.GetAutoCertErrorMsg(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_info"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_info"))
		if err := fv(ctx, m.GetAutoCertInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["buffer_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("buffer_policy"))
		if err := fv(ctx, m.GetBufferPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cdn_service"]; exists {

		vOpts := append(opts, db.WithValidateField("cdn_service"))
		if err := fv(ctx, m.GetCdnService(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["challenge_type"]; exists {
		val := m.GetChallengeType()
		vOpts := append(opts,
			db.WithValidateField("challenge_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChallengeType().(type) {
	case *GetSpecType_JsChallenge:
		if fv, exists := v.FldValidators["challenge_type.js_challenge"]; exists {
			val := m.GetChallengeType().(*GetSpecType_JsChallenge).JsChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("js_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_CaptchaChallenge:
		if fv, exists := v.FldValidators["challenge_type.captcha_challenge"]; exists {
			val := m.GetChallengeType().(*GetSpecType_CaptchaChallenge).CaptchaChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("captcha_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_NoChallenge:
		if fv, exists := v.FldValidators["challenge_type.no_challenge"]; exists {
			val := m.GetChallengeType().(*GetSpecType_NoChallenge).NoChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("no_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["compression_params"]; exists {

		vOpts := append(opts, db.WithValidateField("compression_params"))
		if err := fv(ctx, m.GetCompressionParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connection_idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_idle_timeout"))
		if err := fv(ctx, m.GetConnectionIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cookies_to_modify"]; exists {
		vOpts := append(opts, db.WithValidateField("cookies_to_modify"))
		if err := fv(ctx, m.GetCookiesToModify(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cors_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("cors_policy"))
		if err := fv(ctx, m.GetCorsPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["csrf_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("csrf_policy"))
		if err := fv(ctx, m.GetCsrfPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_errors"]; exists {
		vOpts := append(opts, db.WithValidateField("custom_errors"))
		if err := fv(ctx, m.GetCustomErrors(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetDefaultLbChoice().(type) {
	case *GetSpecType_NonDefaultLoadbalancer:
		if fv, exists := v.FldValidators["default_lb_choice.non_default_loadbalancer"]; exists {
			val := m.GetDefaultLbChoice().(*GetSpecType_NonDefaultLoadbalancer).NonDefaultLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("default_lb_choice"),
				db.WithValidateField("non_default_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DefaultLoadbalancer:
		if fv, exists := v.FldValidators["default_lb_choice.default_loadbalancer"]; exists {
			val := m.GetDefaultLbChoice().(*GetSpecType_DefaultLoadbalancer).DefaultLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("default_lb_choice"),
				db.WithValidateField("default_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["disable_default_error_pages"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_default_error_pages"))
		if err := fv(ctx, m.GetDisableDefaultErrorPages(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_dns_resolve"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_dns_resolve"))
		if err := fv(ctx, m.GetDisableDnsResolve(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_info"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_info"))
		for idx, item := range m.GetDnsInfo() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["dns_proxy_configuration"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_proxy_configuration"))
		if err := fv(ctx, m.GetDnsProxyConfiguration(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetDnsZoneStateChoice().(type) {
	case *GetSpecType_NotReady:
		if fv, exists := v.FldValidators["dns_zone_state_choice.not_ready"]; exists {
			val := m.GetDnsZoneStateChoice().(*GetSpecType_NotReady).NotReady
			vOpts := append(opts,
				db.WithValidateField("dns_zone_state_choice"),
				db.WithValidateField("not_ready"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Ready:
		if fv, exists := v.FldValidators["dns_zone_state_choice.ready"]; exists {
			val := m.GetDnsZoneStateChoice().(*GetSpecType_Ready).Ready
			vOpts := append(opts,
				db.WithValidateField("dns_zone_state_choice"),
				db.WithValidateField("ready"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domain_cert_map"]; exists {

		vOpts := append(opts, db.WithValidateField("domain_cert_map"))
		for key, value := range m.GetDomainCertMap() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dynamic_reverse_proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("dynamic_reverse_proxy"))
		if err := fv(ctx, m.GetDynamicReverseProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header_transformation_type"]; exists {

		vOpts := append(opts, db.WithValidateField("header_transformation_type"))
		if err := fv(ctx, m.GetHeaderTransformationType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["host_name"]; exists {

		vOpts := append(opts, db.WithValidateField("host_name"))
		if err := fv(ctx, m.GetHostName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("idle_timeout"))
		if err := fv(ctx, m.GetIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_request_header_size"]; exists {

		vOpts := append(opts, db.WithValidateField("max_request_header_size"))
		if err := fv(ctx, m.GetMaxRequestHeaderSize(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetPathNormalizeChoice().(type) {
	case *GetSpecType_EnablePathNormalize:
		if fv, exists := v.FldValidators["path_normalize_choice.enable_path_normalize"]; exists {
			val := m.GetPathNormalizeChoice().(*GetSpecType_EnablePathNormalize).EnablePathNormalize
			vOpts := append(opts,
				db.WithValidateField("path_normalize_choice"),
				db.WithValidateField("enable_path_normalize"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DisablePathNormalize:
		if fv, exists := v.FldValidators["path_normalize_choice.disable_path_normalize"]; exists {
			val := m.GetPathNormalizeChoice().(*GetSpecType_DisablePathNormalize).DisablePathNormalize
			vOpts := append(opts,
				db.WithValidateField("path_normalize_choice"),
				db.WithValidateField("disable_path_normalize"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("proxy"))
		if err := fv(ctx, m.GetProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter"))
		if err := fv(ctx, m.GetRateLimiter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter_allowed_prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter_allowed_prefixes"))
		if err := fv(ctx, m.GetRateLimiterAllowedPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_add"))
		if err := fv(ctx, m.GetRequestHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_remove"))
		if err := fv(ctx, m.GetRequestHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_add"))
		if err := fv(ctx, m.GetResponseHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_remove"))
		if err := fv(ctx, m.GetResponseHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["retry_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("retry_policy"))
		if err := fv(ctx, m.GetRetryPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetServerHeaderChoice().(type) {
	case *GetSpecType_DefaultHeader:
		if fv, exists := v.FldValidators["server_header_choice.default_header"]; exists {
			val := m.GetServerHeaderChoice().(*GetSpecType_DefaultHeader).DefaultHeader
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("default_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_ServerName:
		if fv, exists := v.FldValidators["server_header_choice.server_name"]; exists {
			val := m.GetServerHeaderChoice().(*GetSpecType_ServerName).ServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_AppendServerName:
		if fv, exists := v.FldValidators["server_header_choice.append_server_name"]; exists {
			val := m.GetServerHeaderChoice().(*GetSpecType_AppendServerName).AppendServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("append_server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_PassThrough:
		if fv, exists := v.FldValidators["server_header_choice.pass_through"]; exists {
			val := m.GetServerHeaderChoice().(*GetSpecType_PassThrough).PassThrough
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("pass_through"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["slow_ddos_mitigation"]; exists {

		vOpts := append(opts, db.WithValidateField("slow_ddos_mitigation"))
		if err := fv(ctx, m.GetSlowDdosMitigation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetStrictSniHostHeaderCheckChoice().(type) {
	case *GetSpecType_EnableStrictSniHostHeaderCheck:
		if fv, exists := v.FldValidators["strict_sni_host_header_check_choice.enable_strict_sni_host_header_check"]; exists {
			val := m.GetStrictSniHostHeaderCheckChoice().(*GetSpecType_EnableStrictSniHostHeaderCheck).EnableStrictSniHostHeaderCheck
			vOpts := append(opts,
				db.WithValidateField("strict_sni_host_header_check_choice"),
				db.WithValidateField("enable_strict_sni_host_header_check"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_AdditionalDomains:
		if fv, exists := v.FldValidators["strict_sni_host_header_check_choice.additional_domains"]; exists {
			val := m.GetStrictSniHostHeaderCheckChoice().(*GetSpecType_AdditionalDomains).AdditionalDomains
			vOpts := append(opts,
				db.WithValidateField("strict_sni_host_header_check_choice"),
				db.WithValidateField("additional_domains"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["temporary_user_blocking"]; exists {

		vOpts := append(opts, db.WithValidateField("temporary_user_blocking"))
		if err := fv(ctx, m.GetTemporaryUserBlocking(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetTlsCertificatesChoice().(type) {
	case *GetSpecType_TlsParameters:
		if fv, exists := v.FldValidators["tls_certificates_choice.tls_parameters"]; exists {
			val := m.GetTlsCertificatesChoice().(*GetSpecType_TlsParameters).TlsParameters
			vOpts := append(opts,
				db.WithValidateField("tls_certificates_choice"),
				db.WithValidateField("tls_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_TlsCertParams:
		if fv, exists := v.FldValidators["tls_certificates_choice.tls_cert_params"]; exists {
			val := m.GetTlsCertificatesChoice().(*GetSpecType_TlsCertParams).TlsCertParams
			vOpts := append(opts,
				db.WithValidateField("tls_certificates_choice"),
				db.WithValidateField("tls_cert_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_identification"]; exists {
		vOpts := append(opts, db.WithValidateField("user_identification"))
		if err := fv(ctx, m.GetUserIdentification(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["waf_type"]; exists {

		vOpts := append(opts, db.WithValidateField("waf_type"))
		if err := fv(ctx, m.GetWafType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChallengeType := v.ChallengeTypeValidationRuleHandler
	rulesChallengeType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChallengeType(rulesChallengeType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.challenge_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["challenge_type"] = vFn

	vrhServerHeaderChoiceServerName := v.ServerHeaderChoiceServerNameValidationRuleHandler
	rulesServerHeaderChoiceServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.server_name"], err = vrhServerHeaderChoiceServerName(rulesServerHeaderChoiceServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GetSpecType.server_header_choice_server_name: %s", err)
		panic(errMsg)
	}
	vrhServerHeaderChoiceAppendServerName := v.ServerHeaderChoiceAppendServerNameValidationRuleHandler
	rulesServerHeaderChoiceAppendServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.append_server_name"], err = vrhServerHeaderChoiceAppendServerName(rulesServerHeaderChoiceAppendServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GetSpecType.server_header_choice_append_server_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["server_header_choice.server_name"] = vFnMap["server_header_choice.server_name"]
	v.FldValidators["server_header_choice.append_server_name"] = vFnMap["server_header_choice.append_server_name"]

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.repeated.items.string.vh_domain": "true",
		"ves.io.schema.rules.repeated.max_items":              "33",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "256",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	vrhRequestHeadersToAdd := v.RequestHeadersToAddValidationRuleHandler
	rulesRequestHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToAdd(rulesRequestHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.request_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_add"] = vFn

	vrhResponseHeadersToAdd := v.ResponseHeadersToAddValidationRuleHandler
	rulesResponseHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToAdd(rulesResponseHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.response_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_add"] = vFn

	vrhResponseHeadersToRemove := v.ResponseHeadersToRemoveValidationRuleHandler
	rulesResponseHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToRemove(rulesResponseHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.response_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_remove"] = vFn

	vrhRequestHeadersToRemove := v.RequestHeadersToRemoveValidationRuleHandler
	rulesRequestHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToRemove(rulesRequestHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.request_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_remove"] = vFn

	vrhCustomErrors := v.CustomErrorsValidationRuleHandler
	rulesCustomErrors := map[string]string{
		"ves.io.schema.rules.map.keys.uint32.gte":       "3",
		"ves.io.schema.rules.map.keys.uint32.lte":       "599",
		"ves.io.schema.rules.map.max_pairs":             "16",
		"ves.io.schema.rules.map.values.string.max_len": "65536",
		"ves.io.schema.rules.map.values.string.uri_ref": "true",
	}
	vFn, err = vrhCustomErrors(rulesCustomErrors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.custom_errors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_errors"] = vFn

	vrhMaxRequestHeaderSize := v.MaxRequestHeaderSizeValidationRuleHandler
	rulesMaxRequestHeaderSize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "96",
	}
	vFn, err = vrhMaxRequestHeaderSize(rulesMaxRequestHeaderSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.max_request_header_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_request_header_size"] = vFn

	vrhUserIdentification := v.UserIdentificationValidationRuleHandler
	rulesUserIdentification := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhUserIdentification(rulesUserIdentification)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.user_identification: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user_identification"] = vFn

	vrhRateLimiter := v.RateLimiterValidationRuleHandler
	rulesRateLimiter := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRateLimiter(rulesRateLimiter)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.rate_limiter: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter"] = vFn

	vrhRateLimiterAllowedPrefixes := v.RateLimiterAllowedPrefixesValidationRuleHandler
	rulesRateLimiterAllowedPrefixes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhRateLimiterAllowedPrefixes(rulesRateLimiterAllowedPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.rate_limiter_allowed_prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter_allowed_prefixes"] = vFn

	vrhCookiesToModify := v.CookiesToModifyValidationRuleHandler
	rulesCookiesToModify := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhCookiesToModify(rulesCookiesToModify)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.cookies_to_modify: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookies_to_modify"] = vFn

	vrhConnectionIdleTimeout := v.ConnectionIdleTimeoutValidationRuleHandler
	rulesConnectionIdleTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhConnectionIdleTimeout(rulesConnectionIdleTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.connection_idle_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_idle_timeout"] = vFn

	v.FldValidators["authentication_choice.authentication"] = AuthenticationDetailsValidator().Validate

	v.FldValidators["challenge_type.js_challenge"] = JavascriptChallengeTypeValidator().Validate
	v.FldValidators["challenge_type.captcha_challenge"] = CaptchaChallengeTypeValidator().Validate

	v.FldValidators["strict_sni_host_header_check_choice.additional_domains"] = ves_io_schema.DomainNameListValidator().Validate

	v.FldValidators["tls_certificates_choice.tls_parameters"] = ves_io_schema.DownstreamTlsParamsTypeValidator().Validate
	v.FldValidators["tls_certificates_choice.tls_cert_params"] = ves_io_schema.CertificateParamsTypeValidator().Validate

	v.FldValidators["buffer_policy"] = ves_io_schema.BufferConfigTypeValidator().Validate

	v.FldValidators["cors_policy"] = ves_io_schema.CorsPolicyValidator().Validate

	v.FldValidators["waf_type"] = ves_io_schema.WafTypeValidator().Validate

	v.FldValidators["dynamic_reverse_proxy"] = DynamicReverseProxyTypeValidator().Validate

	v.FldValidators["compression_params"] = CompressionTypeValidator().Validate

	v.FldValidators["retry_policy"] = ves_io_schema.RetryPolicyTypeValidator().Validate

	v.FldValidators["temporary_user_blocking"] = TemporaryUserBlockingTypeValidator().Validate

	v.FldValidators["cdn_service"] = CdnServiceTypeValidator().Validate

	v.FldValidators["header_transformation_type"] = ves_io_schema.HeaderTransformationTypeValidator().Validate

	v.FldValidators["csrf_policy"] = ves_io_schema.CsrfPolicyValidator().Validate

	v.FldValidators["slow_ddos_mitigation"] = SlowDDoSMitigationValidator().Validate

	v.FldValidators["api_spec"] = ApiSpecValidator().Validate

	v.FldValidators["domain_cert_map"] = DomainCertificatesValidator().Validate

	v.FldValidators["dns_info"] = ves_io_schema_virtual_host_dns_info.DnsInfoValidator().Validate

	v.FldValidators["dns_proxy_configuration"] = DNSProxyConfigurationValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GlobalSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetRequestHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting GlobalSpecType.request_headers_to_add idx %v", idx)
		}
	}

	for idx, e := range m.GetResponseHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting GlobalSpecType.response_headers_to_add idx %v", idx)
		}
	}

	if err := m.GetTlsParameters().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.tls_parameters")
	}

	if err := m.GetTlsIntercept().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.tls_intercept")
	}

	if err := m.GetAuthentication().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.authentication")
	}

	if err := m.GetBotDefense().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.bot_defense")
	}

	return nil
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAdvertisePoliciesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAdvertisePoliciesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetApiSpecDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetApiSpecDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetAuthenticationChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAuthenticationChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetBotDefenseChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetBotDefenseChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetChallengeTypeDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetChallengeTypeDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDnsDomainsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDnsDomainsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDnsProxyConfigurationDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDnsProxyConfigurationDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDnsZonesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDnsZonesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDynamicReverseProxyDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDynamicReverseProxyDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetFastAclDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetFastAclDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetJwtDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetJwtDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetL7AclDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetL7AclDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetMaliciousUserMitigationDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetMaliciousUserMitigationDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRateLimiterDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterAllowedPrefixesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRateLimiterAllowedPrefixesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRoutesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRoutesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetServicePolicySetsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetServicePolicySetsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTlsCertificatesChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTlsCertificatesChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetUserIdentificationDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetUserIdentificationDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWafTypeDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetWafTypeDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GlobalSpecType) GetAdvertisePoliciesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAdvertisePolicies()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.advertise_policies[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "advertise_policy.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "advertise_policies",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAdvertisePoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetAdvertisePoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "advertise_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: advertise_policy")
	}
	for _, ref := range m.GetAdvertisePolicies() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetApiSpecDRefInfo() ([]db.DRefInfo, error) {
	if m.GetApiSpec() == nil {
		return nil, nil
	}

	drInfos, err := m.GetApiSpec().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetApiSpec().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "api_spec." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetAuthenticationChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAuthenticationChoice() == nil {
		return nil, nil
	}
	switch m.GetAuthenticationChoice().(type) {
	case *GlobalSpecType_NoAuthentication:

		return nil, nil

	case *GlobalSpecType_Authentication:
		drInfos, err := m.GetAuthentication().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAuthentication().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "authentication." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetBotDefenseChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetBotDefenseChoice() == nil {
		return nil, nil
	}
	switch m.GetBotDefenseChoice().(type) {
	case *GlobalSpecType_DisableBotDefense:

		return nil, nil

	case *GlobalSpecType_BotDefense:
		drInfos, err := m.GetBotDefense().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetBotDefense().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "bot_defense." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetChallengeTypeDRefInfo() ([]db.DRefInfo, error) {
	if m.GetChallengeType() == nil {
		return nil, nil
	}
	switch m.GetChallengeType().(type) {
	case *GlobalSpecType_JsChallenge:

		return nil, nil

	case *GlobalSpecType_CaptchaChallenge:

		return nil, nil

	case *GlobalSpecType_NoChallenge:

		return nil, nil

	case *GlobalSpecType_PolicyBasedChallenge:
		drInfos, err := m.GetPolicyBasedChallenge().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetPolicyBasedChallenge().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "policy_based_challenge." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *GlobalSpecType) GetDnsDomainsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetDnsDomains()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.dns_domains[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "dns_domain.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "dns_domains",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetDnsDomainsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetDnsDomainsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "dns_domain.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: dns_domain")
	}
	for _, ref := range m.GetDnsDomains() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetDnsProxyConfigurationDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDnsProxyConfiguration() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDnsProxyConfiguration().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDnsProxyConfiguration().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "dns_proxy_configuration." + dri.DRField
	}
	return drInfos, err

}

func (m *GlobalSpecType) GetDnsZonesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetDnsZones()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.dns_zones[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "dns_zone.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "dns_zones",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetDnsZonesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetDnsZonesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "dns_zone.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: dns_zone")
	}
	for _, ref := range m.GetDnsZones() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetDynamicReverseProxyDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDynamicReverseProxy() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDynamicReverseProxy().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDynamicReverseProxy().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "dynamic_reverse_proxy." + dri.DRField
	}
	return drInfos, err

}

func (m *GlobalSpecType) GetFastAclDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetFastAcl()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.fast_acl[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "fast_acl.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "fast_acl",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetFastAclDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetFastAclDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "fast_acl.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: fast_acl")
	}
	for _, ref := range m.GetFastAcl() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetJwtDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetJwt()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.jwt[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "jwt.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "jwt",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetJwtDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetJwtDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "jwt.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: jwt")
	}
	for _, ref := range m.GetJwt() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetL7AclDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetL7Acl()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.l7_acl[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "l7_acl.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "l7_acl",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetL7AclDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetL7AclDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "l7_acl.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: l7_acl")
	}
	for _, ref := range m.GetL7Acl() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetMaliciousUserMitigationDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetMaliciousUserMitigation()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.malicious_user_mitigation[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "malicious_user_mitigation.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "malicious_user_mitigation",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetMaliciousUserMitigationDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetMaliciousUserMitigationDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "malicious_user_mitigation.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: malicious_user_mitigation")
	}
	for _, ref := range m.GetMaliciousUserMitigation() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetRateLimiterDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRateLimiter()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.rate_limiter[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "rate_limiter.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRateLimiterDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetRateLimiterDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "rate_limiter.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: rate_limiter")
	}
	for _, ref := range m.GetRateLimiter() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetRateLimiterAllowedPrefixesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRateLimiterAllowedPrefixes()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.rate_limiter_allowed_prefixes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "ip_prefix_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter_allowed_prefixes",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRateLimiterAllowedPrefixesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetRateLimiterAllowedPrefixesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "ip_prefix_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: ip_prefix_set")
	}
	for _, ref := range m.GetRateLimiterAllowedPrefixes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRoutes()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.routes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "route.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "routes",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRoutesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetRoutesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "route.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: route")
	}
	for _, ref := range m.GetRoutes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetServicePolicySetsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetServicePolicySets()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.service_policy_sets[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "service_policy_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "service_policy_sets",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetServicePolicySetsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetServicePolicySetsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "service_policy_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: service_policy_set")
	}
	for _, ref := range m.GetServicePolicySets() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetTlsCertificatesChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTlsCertificatesChoice() == nil {
		return nil, nil
	}
	switch m.GetTlsCertificatesChoice().(type) {
	case *GlobalSpecType_TlsParameters:
		drInfos, err := m.GetTlsParameters().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTlsParameters().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tls_parameters." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_TlsCertParams:
		drInfos, err := m.GetTlsCertParams().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTlsCertParams().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tls_cert_params." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *GlobalSpecType) GetUserIdentificationDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetUserIdentification()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.user_identification[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "user_identification.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "user_identification",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetUserIdentificationDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetUserIdentificationDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "user_identification.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: user_identification")
	}
	for _, ref := range m.GetUserIdentification() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetWafTypeDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWafType() == nil {
		return nil, nil
	}

	drInfos, err := m.GetWafType().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetWafType().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "waf_type." + dri.DRField
	}
	return drInfos, err

}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) ChallengeTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for challenge_type")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ServerHeaderChoiceServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_name")
	}
	return oValidatorFn_ServerName, nil
}
func (v *ValidateGlobalSpecType) ServerHeaderChoiceAppendServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_AppendServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for append_server_name")
	}
	return oValidatorFn_AppendServerName, nil
}

func (v *ValidateGlobalSpecType) TrustClientIpHeadersChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for trust_client_ip_headers_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for routes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) RequestHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for request_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ResponseHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for response_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ResponseHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) RequestHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) CustomErrorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapUint32KeyRules(rules)
	itemKeyFn, err := db.NewUint32ValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for custom_errors")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for custom_errors")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[uint32]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for custom_errors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[uint32]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ uint32 ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map custom_errors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items custom_errors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) MaxRequestHeaderSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_request_header_size")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) UserIdentificationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for user_identification")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for user_identification")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated user_identification")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items user_identification")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) RateLimiterValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rate_limiter")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) RateLimiterAllowedPrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter_allowed_prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter_allowed_prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) MaliciousUserMitigationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for malicious_user_mitigation")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for malicious_user_mitigation")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated malicious_user_mitigation")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items malicious_user_mitigation")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) CookiesToModifyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cookies_to_modify")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.CookieManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.CookieManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cookies_to_modify")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.CookieManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.CookieManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cookies_to_modify")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cookies_to_modify")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ConnectionIdleTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_idle_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DnsDomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for dns_domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for dns_domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated dns_domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items dns_domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) UserDomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for user_domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for user_domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated user_domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items user_domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ServicePolicySetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for service_policy_sets")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for service_policy_sets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated service_policy_sets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items service_policy_sets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) FastAclValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for fast_acl")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for fast_acl")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated fast_acl")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items fast_acl")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) L7AclValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for l7_acl")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for l7_acl")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated l7_acl")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items l7_acl")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DnsZonesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for dns_zones")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for dns_zones")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated dns_zones")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items dns_zones")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_location"]; exists {

		vOpts := append(opts, db.WithValidateField("add_location"))
		if err := fv(ctx, m.GetAddLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["advertise_policies"]; exists {

		vOpts := append(opts, db.WithValidateField("advertise_policies"))
		for idx, item := range m.GetAdvertisePolicies() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["api_spec"]; exists {

		vOpts := append(opts, db.WithValidateField("api_spec"))
		if err := fv(ctx, m.GetApiSpec(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetAuthenticationChoice().(type) {
	case *GlobalSpecType_NoAuthentication:
		if fv, exists := v.FldValidators["authentication_choice.no_authentication"]; exists {
			val := m.GetAuthenticationChoice().(*GlobalSpecType_NoAuthentication).NoAuthentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("no_authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Authentication:
		if fv, exists := v.FldValidators["authentication_choice.authentication"]; exists {
			val := m.GetAuthenticationChoice().(*GlobalSpecType_Authentication).Authentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["auto_cert"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert"))
		if err := fv(ctx, m.GetAutoCert(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_error_msg"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_error_msg"))
		if err := fv(ctx, m.GetAutoCertErrorMsg(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_info"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_info"))
		if err := fv(ctx, m.GetAutoCertInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_state"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_state"))
		if err := fv(ctx, m.GetAutoCertState(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetBotDefenseChoice().(type) {
	case *GlobalSpecType_DisableBotDefense:
		if fv, exists := v.FldValidators["bot_defense_choice.disable_bot_defense"]; exists {
			val := m.GetBotDefenseChoice().(*GlobalSpecType_DisableBotDefense).DisableBotDefense
			vOpts := append(opts,
				db.WithValidateField("bot_defense_choice"),
				db.WithValidateField("disable_bot_defense"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_BotDefense:
		if fv, exists := v.FldValidators["bot_defense_choice.bot_defense"]; exists {
			val := m.GetBotDefenseChoice().(*GlobalSpecType_BotDefense).BotDefense
			vOpts := append(opts,
				db.WithValidateField("bot_defense_choice"),
				db.WithValidateField("bot_defense"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["buffer_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("buffer_policy"))
		if err := fv(ctx, m.GetBufferPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cdn_service"]; exists {

		vOpts := append(opts, db.WithValidateField("cdn_service"))
		if err := fv(ctx, m.GetCdnService(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["challenge_type"]; exists {
		val := m.GetChallengeType()
		vOpts := append(opts,
			db.WithValidateField("challenge_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChallengeType().(type) {
	case *GlobalSpecType_JsChallenge:
		if fv, exists := v.FldValidators["challenge_type.js_challenge"]; exists {
			val := m.GetChallengeType().(*GlobalSpecType_JsChallenge).JsChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("js_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_CaptchaChallenge:
		if fv, exists := v.FldValidators["challenge_type.captcha_challenge"]; exists {
			val := m.GetChallengeType().(*GlobalSpecType_CaptchaChallenge).CaptchaChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("captcha_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_NoChallenge:
		if fv, exists := v.FldValidators["challenge_type.no_challenge"]; exists {
			val := m.GetChallengeType().(*GlobalSpecType_NoChallenge).NoChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("no_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_PolicyBasedChallenge:
		if fv, exists := v.FldValidators["challenge_type.policy_based_challenge"]; exists {
			val := m.GetChallengeType().(*GlobalSpecType_PolicyBasedChallenge).PolicyBasedChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("policy_based_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["check_ip_reputation"]; exists {

		vOpts := append(opts, db.WithValidateField("check_ip_reputation"))
		if err := fv(ctx, m.GetCheckIpReputation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["compression_params"]; exists {

		vOpts := append(opts, db.WithValidateField("compression_params"))
		if err := fv(ctx, m.GetCompressionParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connection_idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_idle_timeout"))
		if err := fv(ctx, m.GetConnectionIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cookies_to_modify"]; exists {
		vOpts := append(opts, db.WithValidateField("cookies_to_modify"))
		if err := fv(ctx, m.GetCookiesToModify(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cors_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("cors_policy"))
		if err := fv(ctx, m.GetCorsPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["csrf_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("csrf_policy"))
		if err := fv(ctx, m.GetCsrfPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_cert_expiry"]; exists {

		vOpts := append(opts, db.WithValidateField("custom_cert_expiry"))
		if err := fv(ctx, m.GetCustomCertExpiry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_errors"]; exists {
		vOpts := append(opts, db.WithValidateField("custom_errors"))
		if err := fv(ctx, m.GetCustomErrors(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetDefaultLbChoice().(type) {
	case *GlobalSpecType_NonDefaultLoadbalancer:
		if fv, exists := v.FldValidators["default_lb_choice.non_default_loadbalancer"]; exists {
			val := m.GetDefaultLbChoice().(*GlobalSpecType_NonDefaultLoadbalancer).NonDefaultLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("default_lb_choice"),
				db.WithValidateField("non_default_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DefaultLoadbalancer:
		if fv, exists := v.FldValidators["default_lb_choice.default_loadbalancer"]; exists {
			val := m.GetDefaultLbChoice().(*GlobalSpecType_DefaultLoadbalancer).DefaultLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("default_lb_choice"),
				db.WithValidateField("default_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["disable_default_error_pages"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_default_error_pages"))
		if err := fv(ctx, m.GetDisableDefaultErrorPages(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_dns_resolve"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_dns_resolve"))
		if err := fv(ctx, m.GetDisableDnsResolve(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_domains"]; exists {
		vOpts := append(opts, db.WithValidateField("dns_domains"))
		if err := fv(ctx, m.GetDnsDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_info"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_info"))
		for idx, item := range m.GetDnsInfo() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["dns_proxy_configuration"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_proxy_configuration"))
		if err := fv(ctx, m.GetDnsProxyConfiguration(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_volterra_managed"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_volterra_managed"))
		if err := fv(ctx, m.GetDnsVolterraManaged(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetDnsZoneStateChoice().(type) {
	case *GlobalSpecType_NotReady:
		if fv, exists := v.FldValidators["dns_zone_state_choice.not_ready"]; exists {
			val := m.GetDnsZoneStateChoice().(*GlobalSpecType_NotReady).NotReady
			vOpts := append(opts,
				db.WithValidateField("dns_zone_state_choice"),
				db.WithValidateField("not_ready"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Ready:
		if fv, exists := v.FldValidators["dns_zone_state_choice.ready"]; exists {
			val := m.GetDnsZoneStateChoice().(*GlobalSpecType_Ready).Ready
			vOpts := append(opts,
				db.WithValidateField("dns_zone_state_choice"),
				db.WithValidateField("ready"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["dns_zones"]; exists {
		vOpts := append(opts, db.WithValidateField("dns_zones"))
		if err := fv(ctx, m.GetDnsZones(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domain_cert_map"]; exists {

		vOpts := append(opts, db.WithValidateField("domain_cert_map"))
		for key, value := range m.GetDomainCertMap() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dynamic_reverse_proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("dynamic_reverse_proxy"))
		if err := fv(ctx, m.GetDynamicReverseProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fast_acl"]; exists {
		vOpts := append(opts, db.WithValidateField("fast_acl"))
		if err := fv(ctx, m.GetFastAcl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header_transformation_type"]; exists {

		vOpts := append(opts, db.WithValidateField("header_transformation_type"))
		if err := fv(ctx, m.GetHeaderTransformationType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["host_name"]; exists {

		vOpts := append(opts, db.WithValidateField("host_name"))
		if err := fv(ctx, m.GetHostName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_protocol_options"]; exists {

		vOpts := append(opts, db.WithValidateField("http_protocol_options"))
		if err := fv(ctx, m.GetHttpProtocolOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_redirect_options"]; exists {

		vOpts := append(opts, db.WithValidateField("http_redirect_options"))
		if err := fv(ctx, m.GetHttpRedirectOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("idle_timeout"))
		if err := fv(ctx, m.GetIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["javascript_info"]; exists {

		vOpts := append(opts, db.WithValidateField("javascript_info"))
		if err := fv(ctx, m.GetJavascriptInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["jwt"]; exists {

		vOpts := append(opts, db.WithValidateField("jwt"))
		for idx, item := range m.GetJwt() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["l7_acl"]; exists {
		vOpts := append(opts, db.WithValidateField("l7_acl"))
		if err := fv(ctx, m.GetL7Acl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["loadbalancer_algorithm"]; exists {

		vOpts := append(opts, db.WithValidateField("loadbalancer_algorithm"))
		if err := fv(ctx, m.GetLoadbalancerAlgorithm(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["malicious_user_mitigation"]; exists {
		vOpts := append(opts, db.WithValidateField("malicious_user_mitigation"))
		if err := fv(ctx, m.GetMaliciousUserMitigation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_request_header_size"]; exists {

		vOpts := append(opts, db.WithValidateField("max_request_header_size"))
		if err := fv(ctx, m.GetMaxRequestHeaderSize(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetPathNormalizeChoice().(type) {
	case *GlobalSpecType_EnablePathNormalize:
		if fv, exists := v.FldValidators["path_normalize_choice.enable_path_normalize"]; exists {
			val := m.GetPathNormalizeChoice().(*GlobalSpecType_EnablePathNormalize).EnablePathNormalize
			vOpts := append(opts,
				db.WithValidateField("path_normalize_choice"),
				db.WithValidateField("enable_path_normalize"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DisablePathNormalize:
		if fv, exists := v.FldValidators["path_normalize_choice.disable_path_normalize"]; exists {
			val := m.GetPathNormalizeChoice().(*GlobalSpecType_DisablePathNormalize).DisablePathNormalize
			vOpts := append(opts,
				db.WithValidateField("path_normalize_choice"),
				db.WithValidateField("disable_path_normalize"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("proxy"))
		if err := fv(ctx, m.GetProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter"))
		if err := fv(ctx, m.GetRateLimiter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter_allowed_prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter_allowed_prefixes"))
		if err := fv(ctx, m.GetRateLimiterAllowedPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_add"))
		if err := fv(ctx, m.GetRequestHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_remove"))
		if err := fv(ctx, m.GetRequestHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_add"))
		if err := fv(ctx, m.GetResponseHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_remove"))
		if err := fv(ctx, m.GetResponseHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["retry_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("retry_policy"))
		if err := fv(ctx, m.GetRetryPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetServerHeaderChoice().(type) {
	case *GlobalSpecType_DefaultHeader:
		if fv, exists := v.FldValidators["server_header_choice.default_header"]; exists {
			val := m.GetServerHeaderChoice().(*GlobalSpecType_DefaultHeader).DefaultHeader
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("default_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_ServerName:
		if fv, exists := v.FldValidators["server_header_choice.server_name"]; exists {
			val := m.GetServerHeaderChoice().(*GlobalSpecType_ServerName).ServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_AppendServerName:
		if fv, exists := v.FldValidators["server_header_choice.append_server_name"]; exists {
			val := m.GetServerHeaderChoice().(*GlobalSpecType_AppendServerName).AppendServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("append_server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_PassThrough:
		if fv, exists := v.FldValidators["server_header_choice.pass_through"]; exists {
			val := m.GetServerHeaderChoice().(*GlobalSpecType_PassThrough).PassThrough
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("pass_through"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service_policy_sets"]; exists {
		vOpts := append(opts, db.WithValidateField("service_policy_sets"))
		if err := fv(ctx, m.GetServicePolicySets(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["slow_ddos_mitigation"]; exists {

		vOpts := append(opts, db.WithValidateField("slow_ddos_mitigation"))
		if err := fv(ctx, m.GetSlowDdosMitigation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetStrictSniHostHeaderCheckChoice().(type) {
	case *GlobalSpecType_EnableStrictSniHostHeaderCheck:
		if fv, exists := v.FldValidators["strict_sni_host_header_check_choice.enable_strict_sni_host_header_check"]; exists {
			val := m.GetStrictSniHostHeaderCheckChoice().(*GlobalSpecType_EnableStrictSniHostHeaderCheck).EnableStrictSniHostHeaderCheck
			vOpts := append(opts,
				db.WithValidateField("strict_sni_host_header_check_choice"),
				db.WithValidateField("enable_strict_sni_host_header_check"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_AdditionalDomains:
		if fv, exists := v.FldValidators["strict_sni_host_header_check_choice.additional_domains"]; exists {
			val := m.GetStrictSniHostHeaderCheckChoice().(*GlobalSpecType_AdditionalDomains).AdditionalDomains
			vOpts := append(opts,
				db.WithValidateField("strict_sni_host_header_check_choice"),
				db.WithValidateField("additional_domains"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["temporary_user_blocking"]; exists {

		vOpts := append(opts, db.WithValidateField("temporary_user_blocking"))
		if err := fv(ctx, m.GetTemporaryUserBlocking(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetTlsCertificatesChoice().(type) {
	case *GlobalSpecType_TlsParameters:
		if fv, exists := v.FldValidators["tls_certificates_choice.tls_parameters"]; exists {
			val := m.GetTlsCertificatesChoice().(*GlobalSpecType_TlsParameters).TlsParameters
			vOpts := append(opts,
				db.WithValidateField("tls_certificates_choice"),
				db.WithValidateField("tls_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_TlsCertParams:
		if fv, exists := v.FldValidators["tls_certificates_choice.tls_cert_params"]; exists {
			val := m.GetTlsCertificatesChoice().(*GlobalSpecType_TlsCertParams).TlsCertParams
			vOpts := append(opts,
				db.WithValidateField("tls_certificates_choice"),
				db.WithValidateField("tls_cert_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tls_intercept"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_intercept"))
		if err := fv(ctx, m.GetTlsIntercept(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["trust_client_ip_headers_choice"]; exists {
		val := m.GetTrustClientIpHeadersChoice()
		vOpts := append(opts,
			db.WithValidateField("trust_client_ip_headers_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTrustClientIpHeadersChoice().(type) {
	case *GlobalSpecType_DisableTrustClientIpHeaders:
		if fv, exists := v.FldValidators["trust_client_ip_headers_choice.disable_trust_client_ip_headers"]; exists {
			val := m.GetTrustClientIpHeadersChoice().(*GlobalSpecType_DisableTrustClientIpHeaders).DisableTrustClientIpHeaders
			vOpts := append(opts,
				db.WithValidateField("trust_client_ip_headers_choice"),
				db.WithValidateField("disable_trust_client_ip_headers"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_EnableTrustClientIpHeaders:
		if fv, exists := v.FldValidators["trust_client_ip_headers_choice.enable_trust_client_ip_headers"]; exists {
			val := m.GetTrustClientIpHeadersChoice().(*GlobalSpecType_EnableTrustClientIpHeaders).EnableTrustClientIpHeaders
			vOpts := append(opts,
				db.WithValidateField("trust_client_ip_headers_choice"),
				db.WithValidateField("enable_trust_client_ip_headers"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_domains"]; exists {
		vOpts := append(opts, db.WithValidateField("user_domains"))
		if err := fv(ctx, m.GetUserDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_identification"]; exists {
		vOpts := append(opts, db.WithValidateField("user_identification"))
		if err := fv(ctx, m.GetUserIdentification(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_cert"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_cert"))
		if err := fv(ctx, m.GetVolterraCert(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["waf_type"]; exists {

		vOpts := append(opts, db.WithValidateField("waf_type"))
		if err := fv(ctx, m.GetWafType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChallengeType := v.ChallengeTypeValidationRuleHandler
	rulesChallengeType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChallengeType(rulesChallengeType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.challenge_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["challenge_type"] = vFn

	vrhServerHeaderChoiceServerName := v.ServerHeaderChoiceServerNameValidationRuleHandler
	rulesServerHeaderChoiceServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.server_name"], err = vrhServerHeaderChoiceServerName(rulesServerHeaderChoiceServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GlobalSpecType.server_header_choice_server_name: %s", err)
		panic(errMsg)
	}
	vrhServerHeaderChoiceAppendServerName := v.ServerHeaderChoiceAppendServerNameValidationRuleHandler
	rulesServerHeaderChoiceAppendServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.append_server_name"], err = vrhServerHeaderChoiceAppendServerName(rulesServerHeaderChoiceAppendServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GlobalSpecType.server_header_choice_append_server_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["server_header_choice.server_name"] = vFnMap["server_header_choice.server_name"]
	v.FldValidators["server_header_choice.append_server_name"] = vFnMap["server_header_choice.append_server_name"]

	vrhTrustClientIpHeadersChoice := v.TrustClientIpHeadersChoiceValidationRuleHandler
	rulesTrustClientIpHeadersChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhTrustClientIpHeadersChoice(rulesTrustClientIpHeadersChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.trust_client_ip_headers_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["trust_client_ip_headers_choice"] = vFn

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.repeated.items.string.vh_domain": "true",
		"ves.io.schema.rules.repeated.max_items":              "33",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "256",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	vrhRequestHeadersToAdd := v.RequestHeadersToAddValidationRuleHandler
	rulesRequestHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToAdd(rulesRequestHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.request_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_add"] = vFn

	vrhResponseHeadersToAdd := v.ResponseHeadersToAddValidationRuleHandler
	rulesResponseHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToAdd(rulesResponseHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.response_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_add"] = vFn

	vrhResponseHeadersToRemove := v.ResponseHeadersToRemoveValidationRuleHandler
	rulesResponseHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToRemove(rulesResponseHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.response_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_remove"] = vFn

	vrhRequestHeadersToRemove := v.RequestHeadersToRemoveValidationRuleHandler
	rulesRequestHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToRemove(rulesRequestHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.request_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_remove"] = vFn

	vrhCustomErrors := v.CustomErrorsValidationRuleHandler
	rulesCustomErrors := map[string]string{
		"ves.io.schema.rules.map.keys.uint32.gte":       "3",
		"ves.io.schema.rules.map.keys.uint32.lte":       "599",
		"ves.io.schema.rules.map.max_pairs":             "16",
		"ves.io.schema.rules.map.values.string.max_len": "65536",
		"ves.io.schema.rules.map.values.string.uri_ref": "true",
	}
	vFn, err = vrhCustomErrors(rulesCustomErrors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.custom_errors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_errors"] = vFn

	vrhMaxRequestHeaderSize := v.MaxRequestHeaderSizeValidationRuleHandler
	rulesMaxRequestHeaderSize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "96",
	}
	vFn, err = vrhMaxRequestHeaderSize(rulesMaxRequestHeaderSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.max_request_header_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_request_header_size"] = vFn

	vrhUserIdentification := v.UserIdentificationValidationRuleHandler
	rulesUserIdentification := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhUserIdentification(rulesUserIdentification)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.user_identification: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user_identification"] = vFn

	vrhRateLimiter := v.RateLimiterValidationRuleHandler
	rulesRateLimiter := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRateLimiter(rulesRateLimiter)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.rate_limiter: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter"] = vFn

	vrhRateLimiterAllowedPrefixes := v.RateLimiterAllowedPrefixesValidationRuleHandler
	rulesRateLimiterAllowedPrefixes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhRateLimiterAllowedPrefixes(rulesRateLimiterAllowedPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.rate_limiter_allowed_prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter_allowed_prefixes"] = vFn

	vrhMaliciousUserMitigation := v.MaliciousUserMitigationValidationRuleHandler
	rulesMaliciousUserMitigation := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhMaliciousUserMitigation(rulesMaliciousUserMitigation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.malicious_user_mitigation: %s", err)
		panic(errMsg)
	}
	v.FldValidators["malicious_user_mitigation"] = vFn

	vrhCookiesToModify := v.CookiesToModifyValidationRuleHandler
	rulesCookiesToModify := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhCookiesToModify(rulesCookiesToModify)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.cookies_to_modify: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookies_to_modify"] = vFn

	vrhConnectionIdleTimeout := v.ConnectionIdleTimeoutValidationRuleHandler
	rulesConnectionIdleTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhConnectionIdleTimeout(rulesConnectionIdleTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.connection_idle_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_idle_timeout"] = vFn

	vrhDnsDomains := v.DnsDomainsValidationRuleHandler
	rulesDnsDomains := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "256",
	}
	vFn, err = vrhDnsDomains(rulesDnsDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.dns_domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_domains"] = vFn

	vrhUserDomains := v.UserDomainsValidationRuleHandler
	rulesUserDomains := map[string]string{
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhUserDomains(rulesUserDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.user_domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user_domains"] = vFn

	vrhServicePolicySets := v.ServicePolicySetsValidationRuleHandler
	rulesServicePolicySets := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "5",
	}
	vFn, err = vrhServicePolicySets(rulesServicePolicySets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.service_policy_sets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_policy_sets"] = vFn

	vrhFastAcl := v.FastAclValidationRuleHandler
	rulesFastAcl := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhFastAcl(rulesFastAcl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.fast_acl: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fast_acl"] = vFn

	vrhL7Acl := v.L7AclValidationRuleHandler
	rulesL7Acl := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhL7Acl(rulesL7Acl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.l7_acl: %s", err)
		panic(errMsg)
	}
	v.FldValidators["l7_acl"] = vFn

	vrhDnsZones := v.DnsZonesValidationRuleHandler
	rulesDnsZones := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "256",
	}
	vFn, err = vrhDnsZones(rulesDnsZones)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.dns_zones: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_zones"] = vFn

	v.FldValidators["authentication_choice.authentication"] = AuthenticationDetailsValidator().Validate

	v.FldValidators["bot_defense_choice.bot_defense"] = ShapeBotDefenseConfigTypeValidator().Validate

	v.FldValidators["challenge_type.js_challenge"] = JavascriptChallengeTypeValidator().Validate
	v.FldValidators["challenge_type.captcha_challenge"] = CaptchaChallengeTypeValidator().Validate
	v.FldValidators["challenge_type.policy_based_challenge"] = PolicyBasedChallengeValidator().Validate

	v.FldValidators["strict_sni_host_header_check_choice.additional_domains"] = ves_io_schema.DomainNameListValidator().Validate

	v.FldValidators["tls_certificates_choice.tls_parameters"] = ves_io_schema.DownstreamTlsParamsTypeValidator().Validate
	v.FldValidators["tls_certificates_choice.tls_cert_params"] = ves_io_schema.CertificateParamsTypeValidator().Validate

	v.FldValidators["trust_client_ip_headers_choice.enable_trust_client_ip_headers"] = ClientIPHeadersValidator().Validate

	v.FldValidators["buffer_policy"] = ves_io_schema.BufferConfigTypeValidator().Validate

	v.FldValidators["cors_policy"] = ves_io_schema.CorsPolicyValidator().Validate

	v.FldValidators["waf_type"] = ves_io_schema.WafTypeValidator().Validate

	v.FldValidators["dynamic_reverse_proxy"] = DynamicReverseProxyTypeValidator().Validate

	v.FldValidators["compression_params"] = CompressionTypeValidator().Validate

	v.FldValidators["retry_policy"] = ves_io_schema.RetryPolicyTypeValidator().Validate

	v.FldValidators["temporary_user_blocking"] = TemporaryUserBlockingTypeValidator().Validate

	v.FldValidators["tls_intercept"] = ves_io_schema.TlsInterceptionTypeValidator().Validate

	v.FldValidators["cdn_service"] = CdnServiceTypeValidator().Validate

	v.FldValidators["header_transformation_type"] = ves_io_schema.HeaderTransformationTypeValidator().Validate

	v.FldValidators["csrf_policy"] = ves_io_schema.CsrfPolicyValidator().Validate

	v.FldValidators["slow_ddos_mitigation"] = SlowDDoSMitigationValidator().Validate

	v.FldValidators["api_spec"] = ApiSpecValidator().Validate

	v.FldValidators["domain_cert_map"] = DomainCertificatesValidator().Validate

	v.FldValidators["http_protocol_options"] = HttpProtocolOptionsValidator().Validate

	v.FldValidators["dns_info"] = ves_io_schema_virtual_host_dns_info.DnsInfoValidator().Validate

	v.FldValidators["dns_proxy_configuration"] = DNSProxyConfigurationValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HttpProtocolOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HttpProtocolOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HttpProtocolOptions) DeepCopy() *HttpProtocolOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HttpProtocolOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HttpProtocolOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HttpProtocolOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HttpProtocolOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateHttpProtocolOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHttpProtocolOptions) HttpProtocolChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for http_protocol_choice")
	}
	return validatorFn, nil
}

func (v *ValidateHttpProtocolOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HttpProtocolOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HttpProtocolOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["http_protocol_choice"]; exists {
		val := m.GetHttpProtocolChoice()
		vOpts := append(opts,
			db.WithValidateField("http_protocol_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetHttpProtocolChoice().(type) {
	case *HttpProtocolOptions_HttpProtocolEnableV1Only:
		if fv, exists := v.FldValidators["http_protocol_choice.http_protocol_enable_v1_only"]; exists {
			val := m.GetHttpProtocolChoice().(*HttpProtocolOptions_HttpProtocolEnableV1Only).HttpProtocolEnableV1Only
			vOpts := append(opts,
				db.WithValidateField("http_protocol_choice"),
				db.WithValidateField("http_protocol_enable_v1_only"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HttpProtocolOptions_HttpProtocolEnableV2Only:
		if fv, exists := v.FldValidators["http_protocol_choice.http_protocol_enable_v2_only"]; exists {
			val := m.GetHttpProtocolChoice().(*HttpProtocolOptions_HttpProtocolEnableV2Only).HttpProtocolEnableV2Only
			vOpts := append(opts,
				db.WithValidateField("http_protocol_choice"),
				db.WithValidateField("http_protocol_enable_v2_only"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HttpProtocolOptions_HttpProtocolEnableV1V2:
		if fv, exists := v.FldValidators["http_protocol_choice.http_protocol_enable_v1_v2"]; exists {
			val := m.GetHttpProtocolChoice().(*HttpProtocolOptions_HttpProtocolEnableV1V2).HttpProtocolEnableV1V2
			vOpts := append(opts,
				db.WithValidateField("http_protocol_choice"),
				db.WithValidateField("http_protocol_enable_v1_v2"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHttpProtocolOptionsValidator = func() *ValidateHttpProtocolOptions {
	v := &ValidateHttpProtocolOptions{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHttpProtocolChoice := v.HttpProtocolChoiceValidationRuleHandler
	rulesHttpProtocolChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhHttpProtocolChoice(rulesHttpProtocolChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HttpProtocolOptions.http_protocol_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_protocol_choice"] = vFn

	return v
}()

func HttpProtocolOptionsValidator() db.Validator {
	return DefaultHttpProtocolOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *HttpRedirectOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HttpRedirectOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HttpRedirectOptions) DeepCopy() *HttpRedirectOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HttpRedirectOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HttpRedirectOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HttpRedirectOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HttpRedirectOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateHttpRedirectOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHttpRedirectOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HttpRedirectOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HttpRedirectOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHttpRedirectOptionsValidator = func() *ValidateHttpRedirectOptions {
	v := &ValidateHttpRedirectOptions{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func HttpRedirectOptionsValidator() db.Validator {
	return DefaultHttpRedirectOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *JavaScriptConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JavaScriptConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JavaScriptConfigType) DeepCopy() *JavaScriptConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JavaScriptConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JavaScriptConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JavaScriptConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JavaScriptConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateJavaScriptConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJavaScriptConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JavaScriptConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JavaScriptConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_prefix"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_prefix"))
		if err := fv(ctx, m.GetCachePrefix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_script_url"]; exists {

		vOpts := append(opts, db.WithValidateField("custom_script_url"))
		if err := fv(ctx, m.GetCustomScriptUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["script_config"]; exists {

		vOpts := append(opts, db.WithValidateField("script_config"))
		if err := fv(ctx, m.GetScriptConfig(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJavaScriptConfigTypeValidator = func() *ValidateJavaScriptConfigType {
	v := &ValidateJavaScriptConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func JavaScriptConfigTypeValidator() db.Validator {
	return DefaultJavaScriptConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *JavascriptChallengeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JavascriptChallengeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JavascriptChallengeType) DeepCopy() *JavascriptChallengeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JavascriptChallengeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JavascriptChallengeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JavascriptChallengeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JavascriptChallengeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateJavascriptChallengeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJavascriptChallengeType) JsScriptDelayValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for js_script_delay")
	}

	return validatorFn, nil
}

func (v *ValidateJavascriptChallengeType) CookieExpiryValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cookie_expiry")
	}

	return validatorFn, nil
}

func (v *ValidateJavascriptChallengeType) CustomPageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for custom_page")
	}

	return validatorFn, nil
}

func (v *ValidateJavascriptChallengeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JavascriptChallengeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JavascriptChallengeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cookie_expiry"]; exists {

		vOpts := append(opts, db.WithValidateField("cookie_expiry"))
		if err := fv(ctx, m.GetCookieExpiry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_page"]; exists {

		vOpts := append(opts, db.WithValidateField("custom_page"))
		if err := fv(ctx, m.GetCustomPage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["js_script_delay"]; exists {

		vOpts := append(opts, db.WithValidateField("js_script_delay"))
		if err := fv(ctx, m.GetJsScriptDelay(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJavascriptChallengeTypeValidator = func() *ValidateJavascriptChallengeType {
	v := &ValidateJavascriptChallengeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhJsScriptDelay := v.JsScriptDelayValidationRuleHandler
	rulesJsScriptDelay := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1000",
		"ves.io.schema.rules.uint32.lte": "60000",
	}
	vFn, err = vrhJsScriptDelay(rulesJsScriptDelay)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavascriptChallengeType.js_script_delay: %s", err)
		panic(errMsg)
	}
	v.FldValidators["js_script_delay"] = vFn

	vrhCookieExpiry := v.CookieExpiryValidationRuleHandler
	rulesCookieExpiry := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "86400",
	}
	vFn, err = vrhCookieExpiry(rulesCookieExpiry)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavascriptChallengeType.cookie_expiry: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookie_expiry"] = vFn

	vrhCustomPage := v.CustomPageValidationRuleHandler
	rulesCustomPage := map[string]string{
		"ves.io.schema.rules.string.max_len": "65536",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFn, err = vrhCustomPage(rulesCustomPage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavascriptChallengeType.custom_page: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_page"] = vFn

	return v
}()

func JavascriptChallengeTypeValidator() db.Validator {
	return DefaultJavascriptChallengeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *OpenApiValidationSettings) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OpenApiValidationSettings) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OpenApiValidationSettings) DeepCopy() *OpenApiValidationSettings {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OpenApiValidationSettings{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OpenApiValidationSettings) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OpenApiValidationSettings) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OpenApiValidationSettingsValidator().Validate(ctx, m, opts...)
}

type ValidateOpenApiValidationSettings struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOpenApiValidationSettings) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OpenApiValidationSettings)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OpenApiValidationSettings got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["allow_only_specified_headers"]; exists {

		vOpts := append(opts, db.WithValidateField("allow_only_specified_headers"))
		if err := fv(ctx, m.GetAllowOnlySpecifiedHeaders(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["allow_only_specified_query_params"]; exists {

		vOpts := append(opts, db.WithValidateField("allow_only_specified_query_params"))
		if err := fv(ctx, m.GetAllowOnlySpecifiedQueryParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fail_oversized_body_validation"]; exists {

		vOpts := append(opts, db.WithValidateField("fail_oversized_body_validation"))
		if err := fv(ctx, m.GetFailOversizedBodyValidation(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOpenApiValidationSettingsValidator = func() *ValidateOpenApiValidationSettings {
	v := &ValidateOpenApiValidationSettings{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func OpenApiValidationSettingsValidator() db.Validator {
	return DefaultOpenApiValidationSettingsValidator
}

// augmented methods on protoc/std generated struct

func (m *PolicyBasedChallenge) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PolicyBasedChallenge) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PolicyBasedChallenge) DeepCopy() *PolicyBasedChallenge {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PolicyBasedChallenge{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PolicyBasedChallenge) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PolicyBasedChallenge) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PolicyBasedChallengeValidator().Validate(ctx, m, opts...)
}

func (m *PolicyBasedChallenge) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetMaliciousUserMitigationDRefInfo()

}

func (m *PolicyBasedChallenge) GetMaliciousUserMitigationDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetMaliciousUserMitigation()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("PolicyBasedChallenge.malicious_user_mitigation[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "malicious_user_mitigation.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "malicious_user_mitigation",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetMaliciousUserMitigationDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *PolicyBasedChallenge) GetMaliciousUserMitigationDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "malicious_user_mitigation.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: malicious_user_mitigation")
	}
	for _, ref := range m.GetMaliciousUserMitigation() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidatePolicyBasedChallenge struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePolicyBasedChallenge) ChallengeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for challenge_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePolicyBasedChallenge) MaliciousUserMitigationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for malicious_user_mitigation")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for malicious_user_mitigation")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated malicious_user_mitigation")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items malicious_user_mitigation")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePolicyBasedChallenge) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PolicyBasedChallenge)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PolicyBasedChallenge got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["captcha_challenge"]; exists {

		vOpts := append(opts, db.WithValidateField("captcha_challenge"))
		if err := fv(ctx, m.GetCaptchaChallenge(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["challenge_choice"]; exists {
		val := m.GetChallengeChoice()
		vOpts := append(opts,
			db.WithValidateField("challenge_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChallengeChoice().(type) {
	case *PolicyBasedChallenge_NoChallenge:
		if fv, exists := v.FldValidators["challenge_choice.no_challenge"]; exists {
			val := m.GetChallengeChoice().(*PolicyBasedChallenge_NoChallenge).NoChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_choice"),
				db.WithValidateField("no_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PolicyBasedChallenge_AlwaysEnableJsChallenge:
		if fv, exists := v.FldValidators["challenge_choice.always_enable_js_challenge"]; exists {
			val := m.GetChallengeChoice().(*PolicyBasedChallenge_AlwaysEnableJsChallenge).AlwaysEnableJsChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_choice"),
				db.WithValidateField("always_enable_js_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PolicyBasedChallenge_AlwaysEnableCaptchaChallenge:
		if fv, exists := v.FldValidators["challenge_choice.always_enable_captcha_challenge"]; exists {
			val := m.GetChallengeChoice().(*PolicyBasedChallenge_AlwaysEnableCaptchaChallenge).AlwaysEnableCaptchaChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_choice"),
				db.WithValidateField("always_enable_captcha_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["js_challenge"]; exists {

		vOpts := append(opts, db.WithValidateField("js_challenge"))
		if err := fv(ctx, m.GetJsChallenge(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["malicious_user_mitigation"]; exists {
		vOpts := append(opts, db.WithValidateField("malicious_user_mitigation"))
		if err := fv(ctx, m.GetMaliciousUserMitigation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["temporary_user_blocking"]; exists {

		vOpts := append(opts, db.WithValidateField("temporary_user_blocking"))
		if err := fv(ctx, m.GetTemporaryUserBlocking(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPolicyBasedChallengeValidator = func() *ValidatePolicyBasedChallenge {
	v := &ValidatePolicyBasedChallenge{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChallengeChoice := v.ChallengeChoiceValidationRuleHandler
	rulesChallengeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChallengeChoice(rulesChallengeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PolicyBasedChallenge.challenge_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["challenge_choice"] = vFn

	vrhMaliciousUserMitigation := v.MaliciousUserMitigationValidationRuleHandler
	rulesMaliciousUserMitigation := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhMaliciousUserMitigation(rulesMaliciousUserMitigation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PolicyBasedChallenge.malicious_user_mitigation: %s", err)
		panic(errMsg)
	}
	v.FldValidators["malicious_user_mitigation"] = vFn

	v.FldValidators["js_challenge"] = JavascriptChallengeTypeValidator().Validate

	v.FldValidators["captcha_challenge"] = CaptchaChallengeTypeValidator().Validate

	v.FldValidators["temporary_user_blocking"] = TemporaryUserBlockingTypeValidator().Validate

	return v
}()

func PolicyBasedChallengeValidator() db.Validator {
	return DefaultPolicyBasedChallengeValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ReplaceSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetRequestHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting ReplaceSpecType.request_headers_to_add idx %v", idx)
		}
	}

	for idx, e := range m.GetResponseHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting ReplaceSpecType.response_headers_to_add idx %v", idx)
		}
	}

	if err := m.GetTlsParameters().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.tls_parameters")
	}

	if err := m.GetAuthentication().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.authentication")
	}

	return nil
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAdvertisePoliciesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAdvertisePoliciesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetApiSpecDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetApiSpecDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetAuthenticationChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAuthenticationChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDnsProxyConfigurationDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDnsProxyConfigurationDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDynamicReverseProxyDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDynamicReverseProxyDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRateLimiterDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterAllowedPrefixesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRateLimiterAllowedPrefixesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRoutesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRoutesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTlsCertificatesChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTlsCertificatesChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetUserIdentificationDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetUserIdentificationDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWafTypeDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetWafTypeDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *ReplaceSpecType) GetAdvertisePoliciesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAdvertisePolicies()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.advertise_policies[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "advertise_policy.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "advertise_policies",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAdvertisePoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetAdvertisePoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "advertise_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: advertise_policy")
	}
	for _, ref := range m.GetAdvertisePolicies() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetApiSpecDRefInfo() ([]db.DRefInfo, error) {
	if m.GetApiSpec() == nil {
		return nil, nil
	}

	drInfos, err := m.GetApiSpec().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetApiSpec().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "api_spec." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetAuthenticationChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAuthenticationChoice() == nil {
		return nil, nil
	}
	switch m.GetAuthenticationChoice().(type) {
	case *ReplaceSpecType_NoAuthentication:

		return nil, nil

	case *ReplaceSpecType_Authentication:
		drInfos, err := m.GetAuthentication().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAuthentication().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "authentication." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetDnsProxyConfigurationDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDnsProxyConfiguration() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDnsProxyConfiguration().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDnsProxyConfiguration().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "dns_proxy_configuration." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetDynamicReverseProxyDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDynamicReverseProxy() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDynamicReverseProxy().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDynamicReverseProxy().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "dynamic_reverse_proxy." + dri.DRField
	}
	return drInfos, err

}

func (m *ReplaceSpecType) GetRateLimiterDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRateLimiter()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.rate_limiter[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "rate_limiter.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRateLimiterDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetRateLimiterDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "rate_limiter.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: rate_limiter")
	}
	for _, ref := range m.GetRateLimiter() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *ReplaceSpecType) GetRateLimiterAllowedPrefixesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRateLimiterAllowedPrefixes()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.rate_limiter_allowed_prefixes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "ip_prefix_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter_allowed_prefixes",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRateLimiterAllowedPrefixesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetRateLimiterAllowedPrefixesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "ip_prefix_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: ip_prefix_set")
	}
	for _, ref := range m.GetRateLimiterAllowedPrefixes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *ReplaceSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRoutes()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.routes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "route.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "routes",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRoutesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetRoutesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "route.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: route")
	}
	for _, ref := range m.GetRoutes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetTlsCertificatesChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTlsCertificatesChoice() == nil {
		return nil, nil
	}
	switch m.GetTlsCertificatesChoice().(type) {
	case *ReplaceSpecType_TlsParameters:
		drInfos, err := m.GetTlsParameters().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTlsParameters().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tls_parameters." + dri.DRField
		}
		return drInfos, err

	case *ReplaceSpecType_TlsCertParams:
		drInfos, err := m.GetTlsCertParams().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTlsCertParams().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tls_cert_params." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *ReplaceSpecType) GetUserIdentificationDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetUserIdentification()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.user_identification[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "user_identification.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "user_identification",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetUserIdentificationDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetUserIdentificationDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "user_identification.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: user_identification")
	}
	for _, ref := range m.GetUserIdentification() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetWafTypeDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWafType() == nil {
		return nil, nil
	}

	drInfos, err := m.GetWafType().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetWafType().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "waf_type." + dri.DRField
	}
	return drInfos, err

}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) ChallengeTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for challenge_type")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ServerHeaderChoiceServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_name")
	}
	return oValidatorFn_ServerName, nil
}
func (v *ValidateReplaceSpecType) ServerHeaderChoiceAppendServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_AppendServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for append_server_name")
	}
	return oValidatorFn_AppendServerName, nil
}

func (v *ValidateReplaceSpecType) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for routes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) RequestHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for request_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ResponseHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for response_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ResponseHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ProxyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ProxyType)
		return int32(i)
	}
	// ProxyType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ProxyType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for proxy")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) RequestHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) CustomErrorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapUint32KeyRules(rules)
	itemKeyFn, err := db.NewUint32ValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for custom_errors")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for custom_errors")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[uint32]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for custom_errors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[uint32]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ uint32 ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map custom_errors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items custom_errors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) MaxRequestHeaderSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_request_header_size")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) UserIdentificationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for user_identification")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for user_identification")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated user_identification")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items user_identification")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) RateLimiterValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rate_limiter")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) RateLimiterAllowedPrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter_allowed_prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter_allowed_prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) CookiesToModifyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cookies_to_modify")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.CookieManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.CookieManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cookies_to_modify")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.CookieManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.CookieManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cookies_to_modify")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cookies_to_modify")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ConnectionIdleTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_idle_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_location"]; exists {

		vOpts := append(opts, db.WithValidateField("add_location"))
		if err := fv(ctx, m.GetAddLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["advertise_policies"]; exists {

		vOpts := append(opts, db.WithValidateField("advertise_policies"))
		for idx, item := range m.GetAdvertisePolicies() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["api_spec"]; exists {

		vOpts := append(opts, db.WithValidateField("api_spec"))
		if err := fv(ctx, m.GetApiSpec(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetAuthenticationChoice().(type) {
	case *ReplaceSpecType_NoAuthentication:
		if fv, exists := v.FldValidators["authentication_choice.no_authentication"]; exists {
			val := m.GetAuthenticationChoice().(*ReplaceSpecType_NoAuthentication).NoAuthentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("no_authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Authentication:
		if fv, exists := v.FldValidators["authentication_choice.authentication"]; exists {
			val := m.GetAuthenticationChoice().(*ReplaceSpecType_Authentication).Authentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["buffer_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("buffer_policy"))
		if err := fv(ctx, m.GetBufferPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["challenge_type"]; exists {
		val := m.GetChallengeType()
		vOpts := append(opts,
			db.WithValidateField("challenge_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChallengeType().(type) {
	case *ReplaceSpecType_JsChallenge:
		if fv, exists := v.FldValidators["challenge_type.js_challenge"]; exists {
			val := m.GetChallengeType().(*ReplaceSpecType_JsChallenge).JsChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("js_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_CaptchaChallenge:
		if fv, exists := v.FldValidators["challenge_type.captcha_challenge"]; exists {
			val := m.GetChallengeType().(*ReplaceSpecType_CaptchaChallenge).CaptchaChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("captcha_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_NoChallenge:
		if fv, exists := v.FldValidators["challenge_type.no_challenge"]; exists {
			val := m.GetChallengeType().(*ReplaceSpecType_NoChallenge).NoChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("no_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["compression_params"]; exists {

		vOpts := append(opts, db.WithValidateField("compression_params"))
		if err := fv(ctx, m.GetCompressionParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connection_idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_idle_timeout"))
		if err := fv(ctx, m.GetConnectionIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cookies_to_modify"]; exists {
		vOpts := append(opts, db.WithValidateField("cookies_to_modify"))
		if err := fv(ctx, m.GetCookiesToModify(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cors_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("cors_policy"))
		if err := fv(ctx, m.GetCorsPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["csrf_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("csrf_policy"))
		if err := fv(ctx, m.GetCsrfPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_errors"]; exists {
		vOpts := append(opts, db.WithValidateField("custom_errors"))
		if err := fv(ctx, m.GetCustomErrors(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetDefaultLbChoice().(type) {
	case *ReplaceSpecType_NonDefaultLoadbalancer:
		if fv, exists := v.FldValidators["default_lb_choice.non_default_loadbalancer"]; exists {
			val := m.GetDefaultLbChoice().(*ReplaceSpecType_NonDefaultLoadbalancer).NonDefaultLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("default_lb_choice"),
				db.WithValidateField("non_default_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DefaultLoadbalancer:
		if fv, exists := v.FldValidators["default_lb_choice.default_loadbalancer"]; exists {
			val := m.GetDefaultLbChoice().(*ReplaceSpecType_DefaultLoadbalancer).DefaultLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("default_lb_choice"),
				db.WithValidateField("default_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["disable_default_error_pages"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_default_error_pages"))
		if err := fv(ctx, m.GetDisableDefaultErrorPages(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_dns_resolve"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_dns_resolve"))
		if err := fv(ctx, m.GetDisableDnsResolve(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_proxy_configuration"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_proxy_configuration"))
		if err := fv(ctx, m.GetDnsProxyConfiguration(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domain_cert_map"]; exists {

		vOpts := append(opts, db.WithValidateField("domain_cert_map"))
		for key, value := range m.GetDomainCertMap() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dynamic_reverse_proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("dynamic_reverse_proxy"))
		if err := fv(ctx, m.GetDynamicReverseProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header_transformation_type"]; exists {

		vOpts := append(opts, db.WithValidateField("header_transformation_type"))
		if err := fv(ctx, m.GetHeaderTransformationType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("idle_timeout"))
		if err := fv(ctx, m.GetIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_request_header_size"]; exists {

		vOpts := append(opts, db.WithValidateField("max_request_header_size"))
		if err := fv(ctx, m.GetMaxRequestHeaderSize(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetPathNormalizeChoice().(type) {
	case *ReplaceSpecType_EnablePathNormalize:
		if fv, exists := v.FldValidators["path_normalize_choice.enable_path_normalize"]; exists {
			val := m.GetPathNormalizeChoice().(*ReplaceSpecType_EnablePathNormalize).EnablePathNormalize
			vOpts := append(opts,
				db.WithValidateField("path_normalize_choice"),
				db.WithValidateField("enable_path_normalize"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DisablePathNormalize:
		if fv, exists := v.FldValidators["path_normalize_choice.disable_path_normalize"]; exists {
			val := m.GetPathNormalizeChoice().(*ReplaceSpecType_DisablePathNormalize).DisablePathNormalize
			vOpts := append(opts,
				db.WithValidateField("path_normalize_choice"),
				db.WithValidateField("disable_path_normalize"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("proxy"))
		if err := fv(ctx, m.GetProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter"))
		if err := fv(ctx, m.GetRateLimiter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter_allowed_prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter_allowed_prefixes"))
		if err := fv(ctx, m.GetRateLimiterAllowedPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_add"))
		if err := fv(ctx, m.GetRequestHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_remove"))
		if err := fv(ctx, m.GetRequestHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_add"))
		if err := fv(ctx, m.GetResponseHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_remove"))
		if err := fv(ctx, m.GetResponseHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["retry_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("retry_policy"))
		if err := fv(ctx, m.GetRetryPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetServerHeaderChoice().(type) {
	case *ReplaceSpecType_DefaultHeader:
		if fv, exists := v.FldValidators["server_header_choice.default_header"]; exists {
			val := m.GetServerHeaderChoice().(*ReplaceSpecType_DefaultHeader).DefaultHeader
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("default_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_ServerName:
		if fv, exists := v.FldValidators["server_header_choice.server_name"]; exists {
			val := m.GetServerHeaderChoice().(*ReplaceSpecType_ServerName).ServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_AppendServerName:
		if fv, exists := v.FldValidators["server_header_choice.append_server_name"]; exists {
			val := m.GetServerHeaderChoice().(*ReplaceSpecType_AppendServerName).AppendServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("append_server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_PassThrough:
		if fv, exists := v.FldValidators["server_header_choice.pass_through"]; exists {
			val := m.GetServerHeaderChoice().(*ReplaceSpecType_PassThrough).PassThrough
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("pass_through"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["slow_ddos_mitigation"]; exists {

		vOpts := append(opts, db.WithValidateField("slow_ddos_mitigation"))
		if err := fv(ctx, m.GetSlowDdosMitigation(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetStrictSniHostHeaderCheckChoice().(type) {
	case *ReplaceSpecType_EnableStrictSniHostHeaderCheck:
		if fv, exists := v.FldValidators["strict_sni_host_header_check_choice.enable_strict_sni_host_header_check"]; exists {
			val := m.GetStrictSniHostHeaderCheckChoice().(*ReplaceSpecType_EnableStrictSniHostHeaderCheck).EnableStrictSniHostHeaderCheck
			vOpts := append(opts,
				db.WithValidateField("strict_sni_host_header_check_choice"),
				db.WithValidateField("enable_strict_sni_host_header_check"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_AdditionalDomains:
		if fv, exists := v.FldValidators["strict_sni_host_header_check_choice.additional_domains"]; exists {
			val := m.GetStrictSniHostHeaderCheckChoice().(*ReplaceSpecType_AdditionalDomains).AdditionalDomains
			vOpts := append(opts,
				db.WithValidateField("strict_sni_host_header_check_choice"),
				db.WithValidateField("additional_domains"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["temporary_user_blocking"]; exists {

		vOpts := append(opts, db.WithValidateField("temporary_user_blocking"))
		if err := fv(ctx, m.GetTemporaryUserBlocking(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetTlsCertificatesChoice().(type) {
	case *ReplaceSpecType_TlsParameters:
		if fv, exists := v.FldValidators["tls_certificates_choice.tls_parameters"]; exists {
			val := m.GetTlsCertificatesChoice().(*ReplaceSpecType_TlsParameters).TlsParameters
			vOpts := append(opts,
				db.WithValidateField("tls_certificates_choice"),
				db.WithValidateField("tls_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_TlsCertParams:
		if fv, exists := v.FldValidators["tls_certificates_choice.tls_cert_params"]; exists {
			val := m.GetTlsCertificatesChoice().(*ReplaceSpecType_TlsCertParams).TlsCertParams
			vOpts := append(opts,
				db.WithValidateField("tls_certificates_choice"),
				db.WithValidateField("tls_cert_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["user_identification"]; exists {
		vOpts := append(opts, db.WithValidateField("user_identification"))
		if err := fv(ctx, m.GetUserIdentification(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["waf_type"]; exists {

		vOpts := append(opts, db.WithValidateField("waf_type"))
		if err := fv(ctx, m.GetWafType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChallengeType := v.ChallengeTypeValidationRuleHandler
	rulesChallengeType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChallengeType(rulesChallengeType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.challenge_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["challenge_type"] = vFn

	vrhServerHeaderChoiceServerName := v.ServerHeaderChoiceServerNameValidationRuleHandler
	rulesServerHeaderChoiceServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.server_name"], err = vrhServerHeaderChoiceServerName(rulesServerHeaderChoiceServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ReplaceSpecType.server_header_choice_server_name: %s", err)
		panic(errMsg)
	}
	vrhServerHeaderChoiceAppendServerName := v.ServerHeaderChoiceAppendServerNameValidationRuleHandler
	rulesServerHeaderChoiceAppendServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.append_server_name"], err = vrhServerHeaderChoiceAppendServerName(rulesServerHeaderChoiceAppendServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ReplaceSpecType.server_header_choice_append_server_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["server_header_choice.server_name"] = vFnMap["server_header_choice.server_name"]
	v.FldValidators["server_header_choice.append_server_name"] = vFnMap["server_header_choice.append_server_name"]

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.repeated.items.string.vh_domain": "true",
		"ves.io.schema.rules.repeated.max_items":              "33",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "256",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	vrhRequestHeadersToAdd := v.RequestHeadersToAddValidationRuleHandler
	rulesRequestHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToAdd(rulesRequestHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.request_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_add"] = vFn

	vrhResponseHeadersToAdd := v.ResponseHeadersToAddValidationRuleHandler
	rulesResponseHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToAdd(rulesResponseHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.response_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_add"] = vFn

	vrhResponseHeadersToRemove := v.ResponseHeadersToRemoveValidationRuleHandler
	rulesResponseHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToRemove(rulesResponseHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.response_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_remove"] = vFn

	vrhProxy := v.ProxyValidationRuleHandler
	rulesProxy := map[string]string{
		"ves.io.schema.rules.enum.in": "[4,5]",
	}
	vFn, err = vrhProxy(rulesProxy)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.proxy: %s", err)
		panic(errMsg)
	}
	v.FldValidators["proxy"] = vFn

	vrhRequestHeadersToRemove := v.RequestHeadersToRemoveValidationRuleHandler
	rulesRequestHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToRemove(rulesRequestHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.request_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_remove"] = vFn

	vrhCustomErrors := v.CustomErrorsValidationRuleHandler
	rulesCustomErrors := map[string]string{
		"ves.io.schema.rules.map.keys.uint32.gte":       "3",
		"ves.io.schema.rules.map.keys.uint32.lte":       "599",
		"ves.io.schema.rules.map.max_pairs":             "16",
		"ves.io.schema.rules.map.values.string.max_len": "65536",
		"ves.io.schema.rules.map.values.string.uri_ref": "true",
	}
	vFn, err = vrhCustomErrors(rulesCustomErrors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.custom_errors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_errors"] = vFn

	vrhMaxRequestHeaderSize := v.MaxRequestHeaderSizeValidationRuleHandler
	rulesMaxRequestHeaderSize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "96",
	}
	vFn, err = vrhMaxRequestHeaderSize(rulesMaxRequestHeaderSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.max_request_header_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_request_header_size"] = vFn

	vrhUserIdentification := v.UserIdentificationValidationRuleHandler
	rulesUserIdentification := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhUserIdentification(rulesUserIdentification)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.user_identification: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user_identification"] = vFn

	vrhRateLimiter := v.RateLimiterValidationRuleHandler
	rulesRateLimiter := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRateLimiter(rulesRateLimiter)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.rate_limiter: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter"] = vFn

	vrhRateLimiterAllowedPrefixes := v.RateLimiterAllowedPrefixesValidationRuleHandler
	rulesRateLimiterAllowedPrefixes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhRateLimiterAllowedPrefixes(rulesRateLimiterAllowedPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.rate_limiter_allowed_prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter_allowed_prefixes"] = vFn

	vrhCookiesToModify := v.CookiesToModifyValidationRuleHandler
	rulesCookiesToModify := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhCookiesToModify(rulesCookiesToModify)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.cookies_to_modify: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookies_to_modify"] = vFn

	vrhConnectionIdleTimeout := v.ConnectionIdleTimeoutValidationRuleHandler
	rulesConnectionIdleTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhConnectionIdleTimeout(rulesConnectionIdleTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.connection_idle_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_idle_timeout"] = vFn

	v.FldValidators["authentication_choice.authentication"] = AuthenticationDetailsValidator().Validate

	v.FldValidators["challenge_type.js_challenge"] = JavascriptChallengeTypeValidator().Validate
	v.FldValidators["challenge_type.captcha_challenge"] = CaptchaChallengeTypeValidator().Validate

	v.FldValidators["strict_sni_host_header_check_choice.additional_domains"] = ves_io_schema.DomainNameListValidator().Validate

	v.FldValidators["tls_certificates_choice.tls_parameters"] = ves_io_schema.DownstreamTlsParamsTypeValidator().Validate
	v.FldValidators["tls_certificates_choice.tls_cert_params"] = ves_io_schema.CertificateParamsTypeValidator().Validate

	v.FldValidators["buffer_policy"] = ves_io_schema.BufferConfigTypeValidator().Validate

	v.FldValidators["cors_policy"] = ves_io_schema.CorsPolicyValidator().Validate

	v.FldValidators["waf_type"] = ves_io_schema.WafTypeValidator().Validate

	v.FldValidators["dynamic_reverse_proxy"] = DynamicReverseProxyTypeValidator().Validate

	v.FldValidators["compression_params"] = CompressionTypeValidator().Validate

	v.FldValidators["retry_policy"] = ves_io_schema.RetryPolicyTypeValidator().Validate

	v.FldValidators["temporary_user_blocking"] = TemporaryUserBlockingTypeValidator().Validate

	v.FldValidators["header_transformation_type"] = ves_io_schema.HeaderTransformationTypeValidator().Validate

	v.FldValidators["csrf_policy"] = ves_io_schema.CsrfPolicyValidator().Validate

	v.FldValidators["slow_ddos_mitigation"] = SlowDDoSMitigationValidator().Validate

	v.FldValidators["api_spec"] = ApiSpecValidator().Validate

	v.FldValidators["domain_cert_map"] = DomainCertificatesValidator().Validate

	v.FldValidators["dns_proxy_configuration"] = DNSProxyConfigurationValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ServiceDomain) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ServiceDomain) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ServiceDomain) DeepCopy() *ServiceDomain {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ServiceDomain{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ServiceDomain) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ServiceDomain) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ServiceDomainValidator().Validate(ctx, m, opts...)
}

type ValidateServiceDomain struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateServiceDomain) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ServiceDomain)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ServiceDomain got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain"]; exists {

		vOpts := append(opts, db.WithValidateField("domain"))
		if err := fv(ctx, m.GetDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["internal_service_domain"]; exists {

		vOpts := append(opts, db.WithValidateField("internal_service_domain"))
		if err := fv(ctx, m.GetInternalServiceDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_domain"]; exists {

		vOpts := append(opts, db.WithValidateField("service_domain"))
		if err := fv(ctx, m.GetServiceDomain(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultServiceDomainValidator = func() *ValidateServiceDomain {
	v := &ValidateServiceDomain{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ServiceDomainValidator() db.Validator {
	return DefaultServiceDomainValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeBotDefenseConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeBotDefenseConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ShapeBotDefenseConfigType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetApiAuthKey().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ShapeBotDefenseConfigType.api_auth_key")
	}

	return nil
}

func (m *ShapeBotDefenseConfigType) DeepCopy() *ShapeBotDefenseConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeBotDefenseConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeBotDefenseConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeBotDefenseConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeBotDefenseConfigTypeValidator().Validate(ctx, m, opts...)
}

func (m *ShapeBotDefenseConfigType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetInstanceDRefInfo()

}

func (m *ShapeBotDefenseConfigType) GetInstanceDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetInstance()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("ShapeBotDefenseConfigType.instance[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "shape_bot_defense_instance.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "instance",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetInstanceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ShapeBotDefenseConfigType) GetInstanceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "shape_bot_defense_instance.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: shape_bot_defense_instance")
	}
	for _, ref := range m.GetInstance() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateShapeBotDefenseConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeBotDefenseConfigType) ApplicationIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for application_id")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotDefenseConfigType) TimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for timeout")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotDefenseConfigType) BlockingPagesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for blocking_pages")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for blocking_pages")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for blocking_pages")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map blocking_pages")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items blocking_pages")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotDefenseConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeBotDefenseConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeBotDefenseConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_auth_key"]; exists {

		vOpts := append(opts, db.WithValidateField("api_auth_key"))
		if err := fv(ctx, m.GetApiAuthKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["application_id"]; exists {

		vOpts := append(opts, db.WithValidateField("application_id"))
		if err := fv(ctx, m.GetApplicationId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["blocking_pages"]; exists {
		vOpts := append(opts, db.WithValidateField("blocking_pages"))
		if err := fv(ctx, m.GetBlockingPages(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["instance"]; exists {

		vOpts := append(opts, db.WithValidateField("instance"))
		for idx, item := range m.GetInstance() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["js_path"]; exists {

		vOpts := append(opts, db.WithValidateField("js_path"))
		if err := fv(ctx, m.GetJsPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mode"]; exists {

		vOpts := append(opts, db.WithValidateField("mode"))
		if err := fv(ctx, m.GetMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["reload_header_name"]; exists {

		vOpts := append(opts, db.WithValidateField("reload_header_name"))
		if err := fv(ctx, m.GetReloadHeaderName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("timeout"))
		if err := fv(ctx, m.GetTimeout(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeBotDefenseConfigTypeValidator = func() *ValidateShapeBotDefenseConfigType {
	v := &ValidateShapeBotDefenseConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhApplicationId := v.ApplicationIdValidationRuleHandler
	rulesApplicationId := map[string]string{
		"ves.io.schema.rules.string.max_len": "32",
		"ves.io.schema.rules.string.min_len": "32",
	}
	vFn, err = vrhApplicationId(rulesApplicationId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotDefenseConfigType.application_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["application_id"] = vFn

	vrhTimeout := v.TimeoutValidationRuleHandler
	rulesTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "60000",
	}
	vFn, err = vrhTimeout(rulesTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotDefenseConfigType.timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["timeout"] = vFn

	vrhBlockingPages := v.BlockingPagesValidationRuleHandler
	rulesBlockingPages := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "32",
		"ves.io.schema.rules.map.keys.string.min_len":   "32",
		"ves.io.schema.rules.map.max_pairs":             "128",
		"ves.io.schema.rules.map.values.string.max_len": "4096",
	}
	vFn, err = vrhBlockingPages(rulesBlockingPages)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotDefenseConfigType.blocking_pages: %s", err)
		panic(errMsg)
	}
	v.FldValidators["blocking_pages"] = vFn

	v.FldValidators["api_auth_key"] = ves_io_schema.SecretTypeValidator().Validate

	return v
}()

func ShapeBotDefenseConfigTypeValidator() db.Validator {
	return DefaultShapeBotDefenseConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SlowDDoSMitigation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SlowDDoSMitigation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SlowDDoSMitigation) DeepCopy() *SlowDDoSMitigation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SlowDDoSMitigation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SlowDDoSMitigation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SlowDDoSMitigation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SlowDDoSMitigationValidator().Validate(ctx, m, opts...)
}

type ValidateSlowDDoSMitigation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSlowDDoSMitigation) RequestTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for request_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateSlowDDoSMitigation) RequestHeadersTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for request_headers_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateSlowDDoSMitigation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SlowDDoSMitigation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SlowDDoSMitigation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["request_headers_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("request_headers_timeout"))
		if err := fv(ctx, m.GetRequestHeadersTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("request_timeout"))
		if err := fv(ctx, m.GetRequestTimeout(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSlowDDoSMitigationValidator = func() *ValidateSlowDDoSMitigation {
	v := &ValidateSlowDDoSMitigation{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRequestTimeout := v.RequestTimeoutValidationRuleHandler
	rulesRequestTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "2000",
		"ves.io.schema.rules.uint32.lte": "300000",
	}
	vFn, err = vrhRequestTimeout(rulesRequestTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SlowDDoSMitigation.request_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_timeout"] = vFn

	vrhRequestHeadersTimeout := v.RequestHeadersTimeoutValidationRuleHandler
	rulesRequestHeadersTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "2000",
		"ves.io.schema.rules.uint32.lte": "30000",
	}
	vFn, err = vrhRequestHeadersTimeout(rulesRequestHeadersTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SlowDDoSMitigation.request_headers_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_timeout"] = vFn

	return v
}()

func SlowDDoSMitigationValidator() db.Validator {
	return DefaultSlowDDoSMitigationValidator
}

// augmented methods on protoc/std generated struct

func (m *TemporaryUserBlockingType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TemporaryUserBlockingType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TemporaryUserBlockingType) DeepCopy() *TemporaryUserBlockingType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TemporaryUserBlockingType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TemporaryUserBlockingType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TemporaryUserBlockingType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TemporaryUserBlockingTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTemporaryUserBlockingType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTemporaryUserBlockingType) CustomPageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for custom_page")
	}

	return validatorFn, nil
}

func (v *ValidateTemporaryUserBlockingType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TemporaryUserBlockingType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TemporaryUserBlockingType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["custom_page"]; exists {

		vOpts := append(opts, db.WithValidateField("custom_page"))
		if err := fv(ctx, m.GetCustomPage(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTemporaryUserBlockingTypeValidator = func() *ValidateTemporaryUserBlockingType {
	v := &ValidateTemporaryUserBlockingType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCustomPage := v.CustomPageValidationRuleHandler
	rulesCustomPage := map[string]string{
		"ves.io.schema.rules.string.max_len": "65536",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFn, err = vrhCustomPage(rulesCustomPage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TemporaryUserBlockingType.custom_page: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_page"] = vFn

	return v
}()

func TemporaryUserBlockingTypeValidator() db.Validator {
	return DefaultTemporaryUserBlockingTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VerStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VerStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VerStatusType) DeepCopy() *VerStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VerStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VerStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VerStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VerStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVerStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVerStatusType) CoalescedVirtualHostsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for coalesced_virtual_hosts")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*VirtualHostID, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := VirtualHostIDValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for coalesced_virtual_hosts")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*VirtualHostID)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*VirtualHostID, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated coalesced_virtual_hosts")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items coalesced_virtual_hosts")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateVerStatusType) NonCoalescedVirtualHostsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for non_coalesced_virtual_hosts")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*VirtualHostID, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := VirtualHostIDValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for non_coalesced_virtual_hosts")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*VirtualHostID)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*VirtualHostID, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated non_coalesced_virtual_hosts")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items non_coalesced_virtual_hosts")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateVerStatusType) CoalescedVhostsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for coalesced_vhosts")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for coalesced_vhosts")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated coalesced_vhosts")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items coalesced_vhosts")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateVerStatusType) NonCoalescedVhostsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for non_coalesced_vhosts")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for non_coalesced_vhosts")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated non_coalesced_vhosts")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items non_coalesced_vhosts")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateVerStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VerStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VerStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("advertise_policy"))
		if err := fv(ctx, m.GetAdvertisePolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coalesced_vhosts"]; exists {
		vOpts := append(opts, db.WithValidateField("coalesced_vhosts"))
		if err := fv(ctx, m.GetCoalescedVhosts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coalesced_virtual_hosts"]; exists {
		vOpts := append(opts, db.WithValidateField("coalesced_virtual_hosts"))
		if err := fv(ctx, m.GetCoalescedVirtualHosts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["non_coalesced_vhosts"]; exists {
		vOpts := append(opts, db.WithValidateField("non_coalesced_vhosts"))
		if err := fv(ctx, m.GetNonCoalescedVhosts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["non_coalesced_virtual_hosts"]; exists {
		vOpts := append(opts, db.WithValidateField("non_coalesced_virtual_hosts"))
		if err := fv(ctx, m.GetNonCoalescedVirtualHosts(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVerStatusTypeValidator = func() *ValidateVerStatusType {
	v := &ValidateVerStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCoalescedVirtualHosts := v.CoalescedVirtualHostsValidationRuleHandler
	rulesCoalescedVirtualHosts := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhCoalescedVirtualHosts(rulesCoalescedVirtualHosts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VerStatusType.coalesced_virtual_hosts: %s", err)
		panic(errMsg)
	}
	v.FldValidators["coalesced_virtual_hosts"] = vFn

	vrhNonCoalescedVirtualHosts := v.NonCoalescedVirtualHostsValidationRuleHandler
	rulesNonCoalescedVirtualHosts := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhNonCoalescedVirtualHosts(rulesNonCoalescedVirtualHosts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VerStatusType.non_coalesced_virtual_hosts: %s", err)
		panic(errMsg)
	}
	v.FldValidators["non_coalesced_virtual_hosts"] = vFn

	vrhCoalescedVhosts := v.CoalescedVhostsValidationRuleHandler
	rulesCoalescedVhosts := map[string]string{
		"ves.io.schema.rules.repeated.unique": "true",
	}
	vFn, err = vrhCoalescedVhosts(rulesCoalescedVhosts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VerStatusType.coalesced_vhosts: %s", err)
		panic(errMsg)
	}
	v.FldValidators["coalesced_vhosts"] = vFn

	vrhNonCoalescedVhosts := v.NonCoalescedVhostsValidationRuleHandler
	rulesNonCoalescedVhosts := map[string]string{
		"ves.io.schema.rules.repeated.unique": "true",
	}
	vFn, err = vrhNonCoalescedVhosts(rulesNonCoalescedVhosts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VerStatusType.non_coalesced_vhosts: %s", err)
		panic(errMsg)
	}
	v.FldValidators["non_coalesced_vhosts"] = vFn

	v.FldValidators["advertise_policy"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func VerStatusTypeValidator() db.Validator {
	return DefaultVerStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VirtualHostID) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VirtualHostID) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VirtualHostID) DeepCopy() *VirtualHostID {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VirtualHostID{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VirtualHostID) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VirtualHostID) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VirtualHostIDValidator().Validate(ctx, m, opts...)
}

type ValidateVirtualHostID struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVirtualHostID) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VirtualHostID)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VirtualHostID got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVirtualHostIDValidator = func() *ValidateVirtualHostID {
	v := &ValidateVirtualHostID{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func VirtualHostIDValidator() db.Validator {
	return DefaultVirtualHostIDValidator
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetAuthenticationChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.AuthenticationChoice.(type) {
	case nil:
		o.AuthenticationChoice = nil

	case *CreateSpecType_Authentication:
		o.AuthenticationChoice = &GlobalSpecType_Authentication{Authentication: of.Authentication}

	case *CreateSpecType_NoAuthentication:
		o.AuthenticationChoice = &GlobalSpecType_NoAuthentication{NoAuthentication: of.NoAuthentication}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetAuthenticationChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.AuthenticationChoice.(type) {
	case nil:
		r.AuthenticationChoice = nil

	case *GlobalSpecType_Authentication:
		r.AuthenticationChoice = &CreateSpecType_Authentication{Authentication: of.Authentication}

	case *GlobalSpecType_NoAuthentication:
		r.AuthenticationChoice = &CreateSpecType_NoAuthentication{NoAuthentication: of.NoAuthentication}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetChallengeTypeToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ChallengeType.(type) {
	case nil:
		o.ChallengeType = nil

	case *CreateSpecType_CaptchaChallenge:
		o.ChallengeType = &GlobalSpecType_CaptchaChallenge{CaptchaChallenge: of.CaptchaChallenge}

	case *CreateSpecType_JsChallenge:
		o.ChallengeType = &GlobalSpecType_JsChallenge{JsChallenge: of.JsChallenge}

	case *CreateSpecType_NoChallenge:
		o.ChallengeType = &GlobalSpecType_NoChallenge{NoChallenge: of.NoChallenge}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetChallengeTypeFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ChallengeType.(type) {
	case nil:
		r.ChallengeType = nil

	case *GlobalSpecType_CaptchaChallenge:
		r.ChallengeType = &CreateSpecType_CaptchaChallenge{CaptchaChallenge: of.CaptchaChallenge}

	case *GlobalSpecType_JsChallenge:
		r.ChallengeType = &CreateSpecType_JsChallenge{JsChallenge: of.JsChallenge}

	case *GlobalSpecType_NoChallenge:
		r.ChallengeType = &CreateSpecType_NoChallenge{NoChallenge: of.NoChallenge}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetDefaultLbChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DefaultLbChoice.(type) {
	case nil:
		o.DefaultLbChoice = nil

	case *CreateSpecType_DefaultLoadbalancer:
		o.DefaultLbChoice = &GlobalSpecType_DefaultLoadbalancer{DefaultLoadbalancer: of.DefaultLoadbalancer}

	case *CreateSpecType_NonDefaultLoadbalancer:
		o.DefaultLbChoice = &GlobalSpecType_NonDefaultLoadbalancer{NonDefaultLoadbalancer: of.NonDefaultLoadbalancer}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetDefaultLbChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DefaultLbChoice.(type) {
	case nil:
		r.DefaultLbChoice = nil

	case *GlobalSpecType_DefaultLoadbalancer:
		r.DefaultLbChoice = &CreateSpecType_DefaultLoadbalancer{DefaultLoadbalancer: of.DefaultLoadbalancer}

	case *GlobalSpecType_NonDefaultLoadbalancer:
		r.DefaultLbChoice = &CreateSpecType_NonDefaultLoadbalancer{NonDefaultLoadbalancer: of.NonDefaultLoadbalancer}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetPathNormalizeChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.PathNormalizeChoice.(type) {
	case nil:
		o.PathNormalizeChoice = nil

	case *CreateSpecType_DisablePathNormalize:
		o.PathNormalizeChoice = &GlobalSpecType_DisablePathNormalize{DisablePathNormalize: of.DisablePathNormalize}

	case *CreateSpecType_EnablePathNormalize:
		o.PathNormalizeChoice = &GlobalSpecType_EnablePathNormalize{EnablePathNormalize: of.EnablePathNormalize}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetPathNormalizeChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.PathNormalizeChoice.(type) {
	case nil:
		r.PathNormalizeChoice = nil

	case *GlobalSpecType_DisablePathNormalize:
		r.PathNormalizeChoice = &CreateSpecType_DisablePathNormalize{DisablePathNormalize: of.DisablePathNormalize}

	case *GlobalSpecType_EnablePathNormalize:
		r.PathNormalizeChoice = &CreateSpecType_EnablePathNormalize{EnablePathNormalize: of.EnablePathNormalize}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetServerHeaderChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ServerHeaderChoice.(type) {
	case nil:
		o.ServerHeaderChoice = nil

	case *CreateSpecType_AppendServerName:
		o.ServerHeaderChoice = &GlobalSpecType_AppendServerName{AppendServerName: of.AppendServerName}

	case *CreateSpecType_DefaultHeader:
		o.ServerHeaderChoice = &GlobalSpecType_DefaultHeader{DefaultHeader: of.DefaultHeader}

	case *CreateSpecType_PassThrough:
		o.ServerHeaderChoice = &GlobalSpecType_PassThrough{PassThrough: of.PassThrough}

	case *CreateSpecType_ServerName:
		o.ServerHeaderChoice = &GlobalSpecType_ServerName{ServerName: of.ServerName}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetServerHeaderChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ServerHeaderChoice.(type) {
	case nil:
		r.ServerHeaderChoice = nil

	case *GlobalSpecType_AppendServerName:
		r.ServerHeaderChoice = &CreateSpecType_AppendServerName{AppendServerName: of.AppendServerName}

	case *GlobalSpecType_DefaultHeader:
		r.ServerHeaderChoice = &CreateSpecType_DefaultHeader{DefaultHeader: of.DefaultHeader}

	case *GlobalSpecType_PassThrough:
		r.ServerHeaderChoice = &CreateSpecType_PassThrough{PassThrough: of.PassThrough}

	case *GlobalSpecType_ServerName:
		r.ServerHeaderChoice = &CreateSpecType_ServerName{ServerName: of.ServerName}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetStrictSniHostHeaderCheckChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.StrictSniHostHeaderCheckChoice.(type) {
	case nil:
		o.StrictSniHostHeaderCheckChoice = nil

	case *CreateSpecType_AdditionalDomains:
		o.StrictSniHostHeaderCheckChoice = &GlobalSpecType_AdditionalDomains{AdditionalDomains: of.AdditionalDomains}

	case *CreateSpecType_EnableStrictSniHostHeaderCheck:
		o.StrictSniHostHeaderCheckChoice = &GlobalSpecType_EnableStrictSniHostHeaderCheck{EnableStrictSniHostHeaderCheck: of.EnableStrictSniHostHeaderCheck}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetStrictSniHostHeaderCheckChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.StrictSniHostHeaderCheckChoice.(type) {
	case nil:
		r.StrictSniHostHeaderCheckChoice = nil

	case *GlobalSpecType_AdditionalDomains:
		r.StrictSniHostHeaderCheckChoice = &CreateSpecType_AdditionalDomains{AdditionalDomains: of.AdditionalDomains}

	case *GlobalSpecType_EnableStrictSniHostHeaderCheck:
		r.StrictSniHostHeaderCheckChoice = &CreateSpecType_EnableStrictSniHostHeaderCheck{EnableStrictSniHostHeaderCheck: of.EnableStrictSniHostHeaderCheck}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetTlsCertificatesChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.TlsCertificatesChoice.(type) {
	case nil:
		o.TlsCertificatesChoice = nil

	case *CreateSpecType_TlsCertParams:
		o.TlsCertificatesChoice = &GlobalSpecType_TlsCertParams{TlsCertParams: of.TlsCertParams}

	case *CreateSpecType_TlsParameters:
		o.TlsCertificatesChoice = &GlobalSpecType_TlsParameters{TlsParameters: of.TlsParameters}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetTlsCertificatesChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.TlsCertificatesChoice.(type) {
	case nil:
		r.TlsCertificatesChoice = nil

	case *GlobalSpecType_TlsCertParams:
		r.TlsCertificatesChoice = &CreateSpecType_TlsCertParams{TlsCertParams: of.TlsCertParams}

	case *GlobalSpecType_TlsParameters:
		r.TlsCertificatesChoice = &CreateSpecType_TlsParameters{TlsParameters: of.TlsParameters}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.AddLocation = f.GetAddLocation()
	m.AdvertisePolicies = f.GetAdvertisePolicies()
	m.ApiSpec = f.GetApiSpec()
	m.GetAuthenticationChoiceFromGlobalSpecType(f)
	m.BufferPolicy = f.GetBufferPolicy()
	m.GetChallengeTypeFromGlobalSpecType(f)
	m.CompressionParams = f.GetCompressionParams()
	m.ConnectionIdleTimeout = f.GetConnectionIdleTimeout()
	m.CookiesToModify = f.GetCookiesToModify()
	m.CorsPolicy = f.GetCorsPolicy()
	m.CsrfPolicy = f.GetCsrfPolicy()
	m.CustomErrors = f.GetCustomErrors()
	m.GetDefaultLbChoiceFromGlobalSpecType(f)
	m.DisableDefaultErrorPages = f.GetDisableDefaultErrorPages()
	m.DisableDnsResolve = f.GetDisableDnsResolve()
	m.DnsProxyConfiguration = f.GetDnsProxyConfiguration()
	m.DomainCertMap = f.GetDomainCertMap()
	m.Domains = f.GetDomains()
	m.DynamicReverseProxy = f.GetDynamicReverseProxy()
	m.HeaderTransformationType = f.GetHeaderTransformationType()
	m.IdleTimeout = f.GetIdleTimeout()
	m.MaxRequestHeaderSize = f.GetMaxRequestHeaderSize()
	m.GetPathNormalizeChoiceFromGlobalSpecType(f)
	m.Proxy = f.GetProxy()
	m.RateLimiter = f.GetRateLimiter()
	m.RateLimiterAllowedPrefixes = f.GetRateLimiterAllowedPrefixes()
	m.RequestHeadersToAdd = f.GetRequestHeadersToAdd()
	m.RequestHeadersToRemove = f.GetRequestHeadersToRemove()
	m.ResponseHeadersToAdd = f.GetResponseHeadersToAdd()
	m.ResponseHeadersToRemove = f.GetResponseHeadersToRemove()
	m.RetryPolicy = f.GetRetryPolicy()
	m.Routes = f.GetRoutes()
	m.GetServerHeaderChoiceFromGlobalSpecType(f)
	m.SlowDdosMitigation = f.GetSlowDdosMitigation()
	m.GetStrictSniHostHeaderCheckChoiceFromGlobalSpecType(f)
	m.TemporaryUserBlocking = f.GetTemporaryUserBlocking()
	m.GetTlsCertificatesChoiceFromGlobalSpecType(f)
	m.UserIdentification = f.GetUserIdentification()
	m.WafType = f.GetWafType()
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.AddLocation = m1.AddLocation
	f.AdvertisePolicies = m1.AdvertisePolicies
	f.ApiSpec = m1.ApiSpec
	m1.SetAuthenticationChoiceToGlobalSpecType(f)
	f.BufferPolicy = m1.BufferPolicy
	m1.SetChallengeTypeToGlobalSpecType(f)
	f.CompressionParams = m1.CompressionParams
	f.ConnectionIdleTimeout = m1.ConnectionIdleTimeout
	f.CookiesToModify = m1.CookiesToModify
	f.CorsPolicy = m1.CorsPolicy
	f.CsrfPolicy = m1.CsrfPolicy
	f.CustomErrors = m1.CustomErrors
	m1.SetDefaultLbChoiceToGlobalSpecType(f)
	f.DisableDefaultErrorPages = m1.DisableDefaultErrorPages
	f.DisableDnsResolve = m1.DisableDnsResolve
	f.DnsProxyConfiguration = m1.DnsProxyConfiguration
	f.DomainCertMap = m1.DomainCertMap
	f.Domains = m1.Domains
	f.DynamicReverseProxy = m1.DynamicReverseProxy
	f.HeaderTransformationType = m1.HeaderTransformationType
	f.IdleTimeout = m1.IdleTimeout
	f.MaxRequestHeaderSize = m1.MaxRequestHeaderSize
	m1.SetPathNormalizeChoiceToGlobalSpecType(f)
	f.Proxy = m1.Proxy
	f.RateLimiter = m1.RateLimiter
	f.RateLimiterAllowedPrefixes = m1.RateLimiterAllowedPrefixes
	f.RequestHeadersToAdd = m1.RequestHeadersToAdd
	f.RequestHeadersToRemove = m1.RequestHeadersToRemove
	f.ResponseHeadersToAdd = m1.ResponseHeadersToAdd
	f.ResponseHeadersToRemove = m1.ResponseHeadersToRemove
	f.RetryPolicy = m1.RetryPolicy
	f.Routes = m1.Routes
	m1.SetServerHeaderChoiceToGlobalSpecType(f)
	f.SlowDdosMitigation = m1.SlowDdosMitigation
	m1.SetStrictSniHostHeaderCheckChoiceToGlobalSpecType(f)
	f.TemporaryUserBlocking = m1.TemporaryUserBlocking
	m1.SetTlsCertificatesChoiceToGlobalSpecType(f)
	f.UserIdentification = m1.UserIdentification
	f.WafType = m1.WafType
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetAuthenticationChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.AuthenticationChoice.(type) {
	case nil:
		o.AuthenticationChoice = nil

	case *GetSpecType_Authentication:
		o.AuthenticationChoice = &GlobalSpecType_Authentication{Authentication: of.Authentication}

	case *GetSpecType_NoAuthentication:
		o.AuthenticationChoice = &GlobalSpecType_NoAuthentication{NoAuthentication: of.NoAuthentication}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetAuthenticationChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.AuthenticationChoice.(type) {
	case nil:
		r.AuthenticationChoice = nil

	case *GlobalSpecType_Authentication:
		r.AuthenticationChoice = &GetSpecType_Authentication{Authentication: of.Authentication}

	case *GlobalSpecType_NoAuthentication:
		r.AuthenticationChoice = &GetSpecType_NoAuthentication{NoAuthentication: of.NoAuthentication}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetChallengeTypeToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ChallengeType.(type) {
	case nil:
		o.ChallengeType = nil

	case *GetSpecType_CaptchaChallenge:
		o.ChallengeType = &GlobalSpecType_CaptchaChallenge{CaptchaChallenge: of.CaptchaChallenge}

	case *GetSpecType_JsChallenge:
		o.ChallengeType = &GlobalSpecType_JsChallenge{JsChallenge: of.JsChallenge}

	case *GetSpecType_NoChallenge:
		o.ChallengeType = &GlobalSpecType_NoChallenge{NoChallenge: of.NoChallenge}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetChallengeTypeFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ChallengeType.(type) {
	case nil:
		r.ChallengeType = nil

	case *GlobalSpecType_CaptchaChallenge:
		r.ChallengeType = &GetSpecType_CaptchaChallenge{CaptchaChallenge: of.CaptchaChallenge}

	case *GlobalSpecType_JsChallenge:
		r.ChallengeType = &GetSpecType_JsChallenge{JsChallenge: of.JsChallenge}

	case *GlobalSpecType_NoChallenge:
		r.ChallengeType = &GetSpecType_NoChallenge{NoChallenge: of.NoChallenge}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetDefaultLbChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DefaultLbChoice.(type) {
	case nil:
		o.DefaultLbChoice = nil

	case *GetSpecType_DefaultLoadbalancer:
		o.DefaultLbChoice = &GlobalSpecType_DefaultLoadbalancer{DefaultLoadbalancer: of.DefaultLoadbalancer}

	case *GetSpecType_NonDefaultLoadbalancer:
		o.DefaultLbChoice = &GlobalSpecType_NonDefaultLoadbalancer{NonDefaultLoadbalancer: of.NonDefaultLoadbalancer}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetDefaultLbChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DefaultLbChoice.(type) {
	case nil:
		r.DefaultLbChoice = nil

	case *GlobalSpecType_DefaultLoadbalancer:
		r.DefaultLbChoice = &GetSpecType_DefaultLoadbalancer{DefaultLoadbalancer: of.DefaultLoadbalancer}

	case *GlobalSpecType_NonDefaultLoadbalancer:
		r.DefaultLbChoice = &GetSpecType_NonDefaultLoadbalancer{NonDefaultLoadbalancer: of.NonDefaultLoadbalancer}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetDnsZoneStateChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DnsZoneStateChoice.(type) {
	case nil:
		o.DnsZoneStateChoice = nil

	case *GetSpecType_NotReady:
		o.DnsZoneStateChoice = &GlobalSpecType_NotReady{NotReady: of.NotReady}

	case *GetSpecType_Ready:
		o.DnsZoneStateChoice = &GlobalSpecType_Ready{Ready: of.Ready}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetDnsZoneStateChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DnsZoneStateChoice.(type) {
	case nil:
		r.DnsZoneStateChoice = nil

	case *GlobalSpecType_NotReady:
		r.DnsZoneStateChoice = &GetSpecType_NotReady{NotReady: of.NotReady}

	case *GlobalSpecType_Ready:
		r.DnsZoneStateChoice = &GetSpecType_Ready{Ready: of.Ready}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetPathNormalizeChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.PathNormalizeChoice.(type) {
	case nil:
		o.PathNormalizeChoice = nil

	case *GetSpecType_DisablePathNormalize:
		o.PathNormalizeChoice = &GlobalSpecType_DisablePathNormalize{DisablePathNormalize: of.DisablePathNormalize}

	case *GetSpecType_EnablePathNormalize:
		o.PathNormalizeChoice = &GlobalSpecType_EnablePathNormalize{EnablePathNormalize: of.EnablePathNormalize}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetPathNormalizeChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.PathNormalizeChoice.(type) {
	case nil:
		r.PathNormalizeChoice = nil

	case *GlobalSpecType_DisablePathNormalize:
		r.PathNormalizeChoice = &GetSpecType_DisablePathNormalize{DisablePathNormalize: of.DisablePathNormalize}

	case *GlobalSpecType_EnablePathNormalize:
		r.PathNormalizeChoice = &GetSpecType_EnablePathNormalize{EnablePathNormalize: of.EnablePathNormalize}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetServerHeaderChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ServerHeaderChoice.(type) {
	case nil:
		o.ServerHeaderChoice = nil

	case *GetSpecType_AppendServerName:
		o.ServerHeaderChoice = &GlobalSpecType_AppendServerName{AppendServerName: of.AppendServerName}

	case *GetSpecType_DefaultHeader:
		o.ServerHeaderChoice = &GlobalSpecType_DefaultHeader{DefaultHeader: of.DefaultHeader}

	case *GetSpecType_PassThrough:
		o.ServerHeaderChoice = &GlobalSpecType_PassThrough{PassThrough: of.PassThrough}

	case *GetSpecType_ServerName:
		o.ServerHeaderChoice = &GlobalSpecType_ServerName{ServerName: of.ServerName}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetServerHeaderChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ServerHeaderChoice.(type) {
	case nil:
		r.ServerHeaderChoice = nil

	case *GlobalSpecType_AppendServerName:
		r.ServerHeaderChoice = &GetSpecType_AppendServerName{AppendServerName: of.AppendServerName}

	case *GlobalSpecType_DefaultHeader:
		r.ServerHeaderChoice = &GetSpecType_DefaultHeader{DefaultHeader: of.DefaultHeader}

	case *GlobalSpecType_PassThrough:
		r.ServerHeaderChoice = &GetSpecType_PassThrough{PassThrough: of.PassThrough}

	case *GlobalSpecType_ServerName:
		r.ServerHeaderChoice = &GetSpecType_ServerName{ServerName: of.ServerName}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetStrictSniHostHeaderCheckChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.StrictSniHostHeaderCheckChoice.(type) {
	case nil:
		o.StrictSniHostHeaderCheckChoice = nil

	case *GetSpecType_AdditionalDomains:
		o.StrictSniHostHeaderCheckChoice = &GlobalSpecType_AdditionalDomains{AdditionalDomains: of.AdditionalDomains}

	case *GetSpecType_EnableStrictSniHostHeaderCheck:
		o.StrictSniHostHeaderCheckChoice = &GlobalSpecType_EnableStrictSniHostHeaderCheck{EnableStrictSniHostHeaderCheck: of.EnableStrictSniHostHeaderCheck}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetStrictSniHostHeaderCheckChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.StrictSniHostHeaderCheckChoice.(type) {
	case nil:
		r.StrictSniHostHeaderCheckChoice = nil

	case *GlobalSpecType_AdditionalDomains:
		r.StrictSniHostHeaderCheckChoice = &GetSpecType_AdditionalDomains{AdditionalDomains: of.AdditionalDomains}

	case *GlobalSpecType_EnableStrictSniHostHeaderCheck:
		r.StrictSniHostHeaderCheckChoice = &GetSpecType_EnableStrictSniHostHeaderCheck{EnableStrictSniHostHeaderCheck: of.EnableStrictSniHostHeaderCheck}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetTlsCertificatesChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.TlsCertificatesChoice.(type) {
	case nil:
		o.TlsCertificatesChoice = nil

	case *GetSpecType_TlsCertParams:
		o.TlsCertificatesChoice = &GlobalSpecType_TlsCertParams{TlsCertParams: of.TlsCertParams}

	case *GetSpecType_TlsParameters:
		o.TlsCertificatesChoice = &GlobalSpecType_TlsParameters{TlsParameters: of.TlsParameters}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetTlsCertificatesChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.TlsCertificatesChoice.(type) {
	case nil:
		r.TlsCertificatesChoice = nil

	case *GlobalSpecType_TlsCertParams:
		r.TlsCertificatesChoice = &GetSpecType_TlsCertParams{TlsCertParams: of.TlsCertParams}

	case *GlobalSpecType_TlsParameters:
		r.TlsCertificatesChoice = &GetSpecType_TlsParameters{TlsParameters: of.TlsParameters}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.AddLocation = f.GetAddLocation()
	m.AdvertisePolicies = f.GetAdvertisePolicies()
	m.ApiSpec = f.GetApiSpec()
	m.GetAuthenticationChoiceFromGlobalSpecType(f)
	m.AutoCertErrorMsg = f.GetAutoCertErrorMsg()
	m.AutoCertInfo = f.GetAutoCertInfo()
	m.BufferPolicy = f.GetBufferPolicy()
	m.CdnService = f.GetCdnService()
	m.GetChallengeTypeFromGlobalSpecType(f)
	m.CompressionParams = f.GetCompressionParams()
	m.ConnectionIdleTimeout = f.GetConnectionIdleTimeout()
	m.CookiesToModify = f.GetCookiesToModify()
	m.CorsPolicy = f.GetCorsPolicy()
	m.CsrfPolicy = f.GetCsrfPolicy()
	m.CustomErrors = f.GetCustomErrors()
	m.GetDefaultLbChoiceFromGlobalSpecType(f)
	m.DisableDefaultErrorPages = f.GetDisableDefaultErrorPages()
	m.DisableDnsResolve = f.GetDisableDnsResolve()
	m.DnsInfo = f.GetDnsInfo()
	m.DnsProxyConfiguration = f.GetDnsProxyConfiguration()
	m.GetDnsZoneStateChoiceFromGlobalSpecType(f)
	m.DomainCertMap = f.GetDomainCertMap()
	m.Domains = f.GetDomains()
	m.DynamicReverseProxy = f.GetDynamicReverseProxy()
	m.HeaderTransformationType = f.GetHeaderTransformationType()
	m.HostName = f.GetHostName()
	m.IdleTimeout = f.GetIdleTimeout()
	m.MaxRequestHeaderSize = f.GetMaxRequestHeaderSize()
	m.GetPathNormalizeChoiceFromGlobalSpecType(f)
	m.Proxy = f.GetProxy()
	m.RateLimiter = f.GetRateLimiter()
	m.RateLimiterAllowedPrefixes = f.GetRateLimiterAllowedPrefixes()
	m.RequestHeadersToAdd = f.GetRequestHeadersToAdd()
	m.RequestHeadersToRemove = f.GetRequestHeadersToRemove()
	m.ResponseHeadersToAdd = f.GetResponseHeadersToAdd()
	m.ResponseHeadersToRemove = f.GetResponseHeadersToRemove()
	m.RetryPolicy = f.GetRetryPolicy()
	m.Routes = f.GetRoutes()
	m.GetServerHeaderChoiceFromGlobalSpecType(f)
	m.SlowDdosMitigation = f.GetSlowDdosMitigation()
	m.State = f.GetState()
	m.GetStrictSniHostHeaderCheckChoiceFromGlobalSpecType(f)
	m.TemporaryUserBlocking = f.GetTemporaryUserBlocking()
	m.GetTlsCertificatesChoiceFromGlobalSpecType(f)
	m.Type = f.GetType()
	m.UserIdentification = f.GetUserIdentification()
	m.WafType = f.GetWafType()
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.AddLocation = m1.AddLocation
	f.AdvertisePolicies = m1.AdvertisePolicies
	f.ApiSpec = m1.ApiSpec
	m1.SetAuthenticationChoiceToGlobalSpecType(f)
	f.AutoCertErrorMsg = m1.AutoCertErrorMsg
	f.AutoCertInfo = m1.AutoCertInfo
	f.BufferPolicy = m1.BufferPolicy
	f.CdnService = m1.CdnService
	m1.SetChallengeTypeToGlobalSpecType(f)
	f.CompressionParams = m1.CompressionParams
	f.ConnectionIdleTimeout = m1.ConnectionIdleTimeout
	f.CookiesToModify = m1.CookiesToModify
	f.CorsPolicy = m1.CorsPolicy
	f.CsrfPolicy = m1.CsrfPolicy
	f.CustomErrors = m1.CustomErrors
	m1.SetDefaultLbChoiceToGlobalSpecType(f)
	f.DisableDefaultErrorPages = m1.DisableDefaultErrorPages
	f.DisableDnsResolve = m1.DisableDnsResolve
	f.DnsInfo = m1.DnsInfo
	f.DnsProxyConfiguration = m1.DnsProxyConfiguration
	m1.SetDnsZoneStateChoiceToGlobalSpecType(f)
	f.DomainCertMap = m1.DomainCertMap
	f.Domains = m1.Domains
	f.DynamicReverseProxy = m1.DynamicReverseProxy
	f.HeaderTransformationType = m1.HeaderTransformationType
	f.HostName = m1.HostName
	f.IdleTimeout = m1.IdleTimeout
	f.MaxRequestHeaderSize = m1.MaxRequestHeaderSize
	m1.SetPathNormalizeChoiceToGlobalSpecType(f)
	f.Proxy = m1.Proxy
	f.RateLimiter = m1.RateLimiter
	f.RateLimiterAllowedPrefixes = m1.RateLimiterAllowedPrefixes
	f.RequestHeadersToAdd = m1.RequestHeadersToAdd
	f.RequestHeadersToRemove = m1.RequestHeadersToRemove
	f.ResponseHeadersToAdd = m1.ResponseHeadersToAdd
	f.ResponseHeadersToRemove = m1.ResponseHeadersToRemove
	f.RetryPolicy = m1.RetryPolicy
	f.Routes = m1.Routes
	m1.SetServerHeaderChoiceToGlobalSpecType(f)
	f.SlowDdosMitigation = m1.SlowDdosMitigation
	f.State = m1.State
	m1.SetStrictSniHostHeaderCheckChoiceToGlobalSpecType(f)
	f.TemporaryUserBlocking = m1.TemporaryUserBlocking
	m1.SetTlsCertificatesChoiceToGlobalSpecType(f)
	f.Type = m1.Type
	f.UserIdentification = m1.UserIdentification
	f.WafType = m1.WafType
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetAuthenticationChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.AuthenticationChoice.(type) {
	case nil:
		o.AuthenticationChoice = nil

	case *ReplaceSpecType_Authentication:
		o.AuthenticationChoice = &GlobalSpecType_Authentication{Authentication: of.Authentication}

	case *ReplaceSpecType_NoAuthentication:
		o.AuthenticationChoice = &GlobalSpecType_NoAuthentication{NoAuthentication: of.NoAuthentication}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetAuthenticationChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.AuthenticationChoice.(type) {
	case nil:
		r.AuthenticationChoice = nil

	case *GlobalSpecType_Authentication:
		r.AuthenticationChoice = &ReplaceSpecType_Authentication{Authentication: of.Authentication}

	case *GlobalSpecType_NoAuthentication:
		r.AuthenticationChoice = &ReplaceSpecType_NoAuthentication{NoAuthentication: of.NoAuthentication}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetChallengeTypeToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ChallengeType.(type) {
	case nil:
		o.ChallengeType = nil

	case *ReplaceSpecType_CaptchaChallenge:
		o.ChallengeType = &GlobalSpecType_CaptchaChallenge{CaptchaChallenge: of.CaptchaChallenge}

	case *ReplaceSpecType_JsChallenge:
		o.ChallengeType = &GlobalSpecType_JsChallenge{JsChallenge: of.JsChallenge}

	case *ReplaceSpecType_NoChallenge:
		o.ChallengeType = &GlobalSpecType_NoChallenge{NoChallenge: of.NoChallenge}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetChallengeTypeFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ChallengeType.(type) {
	case nil:
		r.ChallengeType = nil

	case *GlobalSpecType_CaptchaChallenge:
		r.ChallengeType = &ReplaceSpecType_CaptchaChallenge{CaptchaChallenge: of.CaptchaChallenge}

	case *GlobalSpecType_JsChallenge:
		r.ChallengeType = &ReplaceSpecType_JsChallenge{JsChallenge: of.JsChallenge}

	case *GlobalSpecType_NoChallenge:
		r.ChallengeType = &ReplaceSpecType_NoChallenge{NoChallenge: of.NoChallenge}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetDefaultLbChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DefaultLbChoice.(type) {
	case nil:
		o.DefaultLbChoice = nil

	case *ReplaceSpecType_DefaultLoadbalancer:
		o.DefaultLbChoice = &GlobalSpecType_DefaultLoadbalancer{DefaultLoadbalancer: of.DefaultLoadbalancer}

	case *ReplaceSpecType_NonDefaultLoadbalancer:
		o.DefaultLbChoice = &GlobalSpecType_NonDefaultLoadbalancer{NonDefaultLoadbalancer: of.NonDefaultLoadbalancer}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetDefaultLbChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DefaultLbChoice.(type) {
	case nil:
		r.DefaultLbChoice = nil

	case *GlobalSpecType_DefaultLoadbalancer:
		r.DefaultLbChoice = &ReplaceSpecType_DefaultLoadbalancer{DefaultLoadbalancer: of.DefaultLoadbalancer}

	case *GlobalSpecType_NonDefaultLoadbalancer:
		r.DefaultLbChoice = &ReplaceSpecType_NonDefaultLoadbalancer{NonDefaultLoadbalancer: of.NonDefaultLoadbalancer}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetPathNormalizeChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.PathNormalizeChoice.(type) {
	case nil:
		o.PathNormalizeChoice = nil

	case *ReplaceSpecType_DisablePathNormalize:
		o.PathNormalizeChoice = &GlobalSpecType_DisablePathNormalize{DisablePathNormalize: of.DisablePathNormalize}

	case *ReplaceSpecType_EnablePathNormalize:
		o.PathNormalizeChoice = &GlobalSpecType_EnablePathNormalize{EnablePathNormalize: of.EnablePathNormalize}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetPathNormalizeChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.PathNormalizeChoice.(type) {
	case nil:
		r.PathNormalizeChoice = nil

	case *GlobalSpecType_DisablePathNormalize:
		r.PathNormalizeChoice = &ReplaceSpecType_DisablePathNormalize{DisablePathNormalize: of.DisablePathNormalize}

	case *GlobalSpecType_EnablePathNormalize:
		r.PathNormalizeChoice = &ReplaceSpecType_EnablePathNormalize{EnablePathNormalize: of.EnablePathNormalize}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetServerHeaderChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ServerHeaderChoice.(type) {
	case nil:
		o.ServerHeaderChoice = nil

	case *ReplaceSpecType_AppendServerName:
		o.ServerHeaderChoice = &GlobalSpecType_AppendServerName{AppendServerName: of.AppendServerName}

	case *ReplaceSpecType_DefaultHeader:
		o.ServerHeaderChoice = &GlobalSpecType_DefaultHeader{DefaultHeader: of.DefaultHeader}

	case *ReplaceSpecType_PassThrough:
		o.ServerHeaderChoice = &GlobalSpecType_PassThrough{PassThrough: of.PassThrough}

	case *ReplaceSpecType_ServerName:
		o.ServerHeaderChoice = &GlobalSpecType_ServerName{ServerName: of.ServerName}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetServerHeaderChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ServerHeaderChoice.(type) {
	case nil:
		r.ServerHeaderChoice = nil

	case *GlobalSpecType_AppendServerName:
		r.ServerHeaderChoice = &ReplaceSpecType_AppendServerName{AppendServerName: of.AppendServerName}

	case *GlobalSpecType_DefaultHeader:
		r.ServerHeaderChoice = &ReplaceSpecType_DefaultHeader{DefaultHeader: of.DefaultHeader}

	case *GlobalSpecType_PassThrough:
		r.ServerHeaderChoice = &ReplaceSpecType_PassThrough{PassThrough: of.PassThrough}

	case *GlobalSpecType_ServerName:
		r.ServerHeaderChoice = &ReplaceSpecType_ServerName{ServerName: of.ServerName}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetStrictSniHostHeaderCheckChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.StrictSniHostHeaderCheckChoice.(type) {
	case nil:
		o.StrictSniHostHeaderCheckChoice = nil

	case *ReplaceSpecType_AdditionalDomains:
		o.StrictSniHostHeaderCheckChoice = &GlobalSpecType_AdditionalDomains{AdditionalDomains: of.AdditionalDomains}

	case *ReplaceSpecType_EnableStrictSniHostHeaderCheck:
		o.StrictSniHostHeaderCheckChoice = &GlobalSpecType_EnableStrictSniHostHeaderCheck{EnableStrictSniHostHeaderCheck: of.EnableStrictSniHostHeaderCheck}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetStrictSniHostHeaderCheckChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.StrictSniHostHeaderCheckChoice.(type) {
	case nil:
		r.StrictSniHostHeaderCheckChoice = nil

	case *GlobalSpecType_AdditionalDomains:
		r.StrictSniHostHeaderCheckChoice = &ReplaceSpecType_AdditionalDomains{AdditionalDomains: of.AdditionalDomains}

	case *GlobalSpecType_EnableStrictSniHostHeaderCheck:
		r.StrictSniHostHeaderCheckChoice = &ReplaceSpecType_EnableStrictSniHostHeaderCheck{EnableStrictSniHostHeaderCheck: of.EnableStrictSniHostHeaderCheck}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetTlsCertificatesChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.TlsCertificatesChoice.(type) {
	case nil:
		o.TlsCertificatesChoice = nil

	case *ReplaceSpecType_TlsCertParams:
		o.TlsCertificatesChoice = &GlobalSpecType_TlsCertParams{TlsCertParams: of.TlsCertParams}

	case *ReplaceSpecType_TlsParameters:
		o.TlsCertificatesChoice = &GlobalSpecType_TlsParameters{TlsParameters: of.TlsParameters}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetTlsCertificatesChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.TlsCertificatesChoice.(type) {
	case nil:
		r.TlsCertificatesChoice = nil

	case *GlobalSpecType_TlsCertParams:
		r.TlsCertificatesChoice = &ReplaceSpecType_TlsCertParams{TlsCertParams: of.TlsCertParams}

	case *GlobalSpecType_TlsParameters:
		r.TlsCertificatesChoice = &ReplaceSpecType_TlsParameters{TlsParameters: of.TlsParameters}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.AddLocation = f.GetAddLocation()
	m.AdvertisePolicies = f.GetAdvertisePolicies()
	m.ApiSpec = f.GetApiSpec()
	m.GetAuthenticationChoiceFromGlobalSpecType(f)
	m.BufferPolicy = f.GetBufferPolicy()
	m.GetChallengeTypeFromGlobalSpecType(f)
	m.CompressionParams = f.GetCompressionParams()
	m.ConnectionIdleTimeout = f.GetConnectionIdleTimeout()
	m.CookiesToModify = f.GetCookiesToModify()
	m.CorsPolicy = f.GetCorsPolicy()
	m.CsrfPolicy = f.GetCsrfPolicy()
	m.CustomErrors = f.GetCustomErrors()
	m.GetDefaultLbChoiceFromGlobalSpecType(f)
	m.DisableDefaultErrorPages = f.GetDisableDefaultErrorPages()
	m.DisableDnsResolve = f.GetDisableDnsResolve()
	m.DnsProxyConfiguration = f.GetDnsProxyConfiguration()
	m.DomainCertMap = f.GetDomainCertMap()
	m.Domains = f.GetDomains()
	m.DynamicReverseProxy = f.GetDynamicReverseProxy()
	m.HeaderTransformationType = f.GetHeaderTransformationType()
	m.IdleTimeout = f.GetIdleTimeout()
	m.MaxRequestHeaderSize = f.GetMaxRequestHeaderSize()
	m.GetPathNormalizeChoiceFromGlobalSpecType(f)
	m.Proxy = f.GetProxy()
	m.RateLimiter = f.GetRateLimiter()
	m.RateLimiterAllowedPrefixes = f.GetRateLimiterAllowedPrefixes()
	m.RequestHeadersToAdd = f.GetRequestHeadersToAdd()
	m.RequestHeadersToRemove = f.GetRequestHeadersToRemove()
	m.ResponseHeadersToAdd = f.GetResponseHeadersToAdd()
	m.ResponseHeadersToRemove = f.GetResponseHeadersToRemove()
	m.RetryPolicy = f.GetRetryPolicy()
	m.Routes = f.GetRoutes()
	m.GetServerHeaderChoiceFromGlobalSpecType(f)
	m.SlowDdosMitigation = f.GetSlowDdosMitigation()
	m.GetStrictSniHostHeaderCheckChoiceFromGlobalSpecType(f)
	m.TemporaryUserBlocking = f.GetTemporaryUserBlocking()
	m.GetTlsCertificatesChoiceFromGlobalSpecType(f)
	m.UserIdentification = f.GetUserIdentification()
	m.WafType = f.GetWafType()
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.AddLocation = m1.AddLocation
	f.AdvertisePolicies = m1.AdvertisePolicies
	f.ApiSpec = m1.ApiSpec
	m1.SetAuthenticationChoiceToGlobalSpecType(f)
	f.BufferPolicy = m1.BufferPolicy
	m1.SetChallengeTypeToGlobalSpecType(f)
	f.CompressionParams = m1.CompressionParams
	f.ConnectionIdleTimeout = m1.ConnectionIdleTimeout
	f.CookiesToModify = m1.CookiesToModify
	f.CorsPolicy = m1.CorsPolicy
	f.CsrfPolicy = m1.CsrfPolicy
	f.CustomErrors = m1.CustomErrors
	m1.SetDefaultLbChoiceToGlobalSpecType(f)
	f.DisableDefaultErrorPages = m1.DisableDefaultErrorPages
	f.DisableDnsResolve = m1.DisableDnsResolve
	f.DnsProxyConfiguration = m1.DnsProxyConfiguration
	f.DomainCertMap = m1.DomainCertMap
	f.Domains = m1.Domains
	f.DynamicReverseProxy = m1.DynamicReverseProxy
	f.HeaderTransformationType = m1.HeaderTransformationType
	f.IdleTimeout = m1.IdleTimeout
	f.MaxRequestHeaderSize = m1.MaxRequestHeaderSize
	m1.SetPathNormalizeChoiceToGlobalSpecType(f)
	f.Proxy = m1.Proxy
	f.RateLimiter = m1.RateLimiter
	f.RateLimiterAllowedPrefixes = m1.RateLimiterAllowedPrefixes
	f.RequestHeadersToAdd = m1.RequestHeadersToAdd
	f.RequestHeadersToRemove = m1.RequestHeadersToRemove
	f.ResponseHeadersToAdd = m1.ResponseHeadersToAdd
	f.ResponseHeadersToRemove = m1.ResponseHeadersToRemove
	f.RetryPolicy = m1.RetryPolicy
	f.Routes = m1.Routes
	m1.SetServerHeaderChoiceToGlobalSpecType(f)
	f.SlowDdosMitigation = m1.SlowDdosMitigation
	m1.SetStrictSniHostHeaderCheckChoiceToGlobalSpecType(f)
	f.TemporaryUserBlocking = m1.TemporaryUserBlocking
	m1.SetTlsCertificatesChoiceToGlobalSpecType(f)
	f.UserIdentification = m1.UserIdentification
	f.WafType = m1.WafType
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
