//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package virtual_host

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_authentication "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/authentication"
	ves_io_schema_virtual_host_dns_info "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/virtual_host_dns_info"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AuthenticationDetails) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AuthenticationDetails) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AuthenticationDetails) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetCookieParams().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AuthenticationDetails.cookie_params")
	}

	return nil
}

func (m *AuthenticationDetails) DeepCopy() *AuthenticationDetails {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AuthenticationDetails{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AuthenticationDetails) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AuthenticationDetails) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AuthenticationDetailsValidator().Validate(ctx, m, opts...)
}

func (m *AuthenticationDetails) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAuthConfigDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetCookieParamsChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *AuthenticationDetails) GetAuthConfigDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetAuthConfig() {
		if ref == nil {
			return nil, fmt.Errorf("AuthenticationDetails.auth_config[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "authentication.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "auth_config",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetAuthConfigDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *AuthenticationDetails) GetAuthConfigDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "authentication.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: authentication")
	}
	for _, ref := range m.GetAuthConfig() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *AuthenticationDetails) GetCookieParamsChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetCookieParamsChoice() == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetCookieParamsChoice().(type) {
	case *AuthenticationDetails_UseAuthObjectConfig:

	case *AuthenticationDetails_CookieParams:
		odrInfos, err = m.GetCookieParams().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "cookie_params." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

type ValidateAuthenticationDetails struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAuthenticationDetails) RedirectUrlChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for redirect_url_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAuthenticationDetails) RedirectUrlChoiceRedirectUrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_RedirectUrl, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for redirect_url")
	}
	return oValidatorFn_RedirectUrl, nil
}

func (v *ValidateAuthenticationDetails) AuthConfigValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for auth_config")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated auth_config")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items auth_config")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAuthenticationDetails) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AuthenticationDetails)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AuthenticationDetails got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["auth_config"]; exists {
		vOpts := append(opts, db.WithValidateField("auth_config"))
		if err := fv(ctx, m.GetAuthConfig(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetCookieParamsChoice().(type) {
	case *AuthenticationDetails_UseAuthObjectConfig:
		if fv, exists := v.FldValidators["cookie_params_choice.use_auth_object_config"]; exists {
			val := m.GetCookieParamsChoice().(*AuthenticationDetails_UseAuthObjectConfig).UseAuthObjectConfig
			vOpts := append(opts,
				db.WithValidateField("cookie_params_choice"),
				db.WithValidateField("use_auth_object_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AuthenticationDetails_CookieParams:
		if fv, exists := v.FldValidators["cookie_params_choice.cookie_params"]; exists {
			val := m.GetCookieParamsChoice().(*AuthenticationDetails_CookieParams).CookieParams
			vOpts := append(opts,
				db.WithValidateField("cookie_params_choice"),
				db.WithValidateField("cookie_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["redirect_url_choice"]; exists {
		val := m.GetRedirectUrlChoice()
		vOpts := append(opts,
			db.WithValidateField("redirect_url_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetRedirectUrlChoice().(type) {
	case *AuthenticationDetails_RedirectUrl:
		if fv, exists := v.FldValidators["redirect_url_choice.redirect_url"]; exists {
			val := m.GetRedirectUrlChoice().(*AuthenticationDetails_RedirectUrl).RedirectUrl
			vOpts := append(opts,
				db.WithValidateField("redirect_url_choice"),
				db.WithValidateField("redirect_url"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AuthenticationDetails_RedirectDynamic:
		if fv, exists := v.FldValidators["redirect_url_choice.redirect_dynamic"]; exists {
			val := m.GetRedirectUrlChoice().(*AuthenticationDetails_RedirectDynamic).RedirectDynamic
			vOpts := append(opts,
				db.WithValidateField("redirect_url_choice"),
				db.WithValidateField("redirect_dynamic"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAuthenticationDetailsValidator = func() *ValidateAuthenticationDetails {
	v := &ValidateAuthenticationDetails{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRedirectUrlChoice := v.RedirectUrlChoiceValidationRuleHandler
	rulesRedirectUrlChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhRedirectUrlChoice(rulesRedirectUrlChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AuthenticationDetails.redirect_url_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["redirect_url_choice"] = vFn

	vrhRedirectUrlChoiceRedirectUrl := v.RedirectUrlChoiceRedirectUrlValidationRuleHandler
	rulesRedirectUrlChoiceRedirectUrl := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
		"ves.io.schema.rules.string.min_len": "1",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFnMap["redirect_url_choice.redirect_url"], err = vrhRedirectUrlChoiceRedirectUrl(rulesRedirectUrlChoiceRedirectUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AuthenticationDetails.redirect_url_choice_redirect_url: %s", err)
		panic(errMsg)
	}

	v.FldValidators["redirect_url_choice.redirect_url"] = vFnMap["redirect_url_choice.redirect_url"]

	vrhAuthConfig := v.AuthConfigValidationRuleHandler
	rulesAuthConfig := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhAuthConfig(rulesAuthConfig)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AuthenticationDetails.auth_config: %s", err)
		panic(errMsg)
	}
	v.FldValidators["auth_config"] = vFn

	v.FldValidators["cookie_params_choice.cookie_params"] = ves_io_schema_authentication.CookieParamsValidator().Validate

	return v
}()

func AuthenticationDetailsValidator() db.Validator {
	return DefaultAuthenticationDetailsValidator
}

// augmented methods on protoc/std generated struct

func (m *AutoCertInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AutoCertInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AutoCertInfoType) DeepCopy() *AutoCertInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AutoCertInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AutoCertInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AutoCertInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AutoCertInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAutoCertInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAutoCertInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AutoCertInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AutoCertInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["auto_cert_expiry"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_expiry"))
		if err := fv(ctx, m.GetAutoCertExpiry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_issuer"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_issuer"))
		if err := fv(ctx, m.GetAutoCertIssuer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_state"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_state"))
		if err := fv(ctx, m.GetAutoCertState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_subject"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_subject"))
		if err := fv(ctx, m.GetAutoCertSubject(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAutoCertInfoTypeValidator = func() *ValidateAutoCertInfoType {
	v := &ValidateAutoCertInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AutoCertInfoTypeValidator() db.Validator {
	return DefaultAutoCertInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CaptchaChallengeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CaptchaChallengeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CaptchaChallengeType) DeepCopy() *CaptchaChallengeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CaptchaChallengeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CaptchaChallengeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CaptchaChallengeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CaptchaChallengeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCaptchaChallengeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCaptchaChallengeType) CookieExpiryValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cookie_expiry")
	}

	return validatorFn, nil
}

func (v *ValidateCaptchaChallengeType) CustomPageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for custom_page")
	}

	return validatorFn, nil
}

func (v *ValidateCaptchaChallengeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CaptchaChallengeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CaptchaChallengeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cookie_expiry"]; exists {

		vOpts := append(opts, db.WithValidateField("cookie_expiry"))
		if err := fv(ctx, m.GetCookieExpiry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_page"]; exists {

		vOpts := append(opts, db.WithValidateField("custom_page"))
		if err := fv(ctx, m.GetCustomPage(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCaptchaChallengeTypeValidator = func() *ValidateCaptchaChallengeType {
	v := &ValidateCaptchaChallengeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCookieExpiry := v.CookieExpiryValidationRuleHandler
	rulesCookieExpiry := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "86400",
	}
	vFn, err = vrhCookieExpiry(rulesCookieExpiry)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CaptchaChallengeType.cookie_expiry: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookie_expiry"] = vFn

	vrhCustomPage := v.CustomPageValidationRuleHandler
	rulesCustomPage := map[string]string{
		"ves.io.schema.rules.string.max_len": "16384",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFn, err = vrhCustomPage(rulesCustomPage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CaptchaChallengeType.custom_page: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_page"] = vFn

	return v
}()

func CaptchaChallengeTypeValidator() db.Validator {
	return DefaultCaptchaChallengeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CompressionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CompressionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CompressionType) DeepCopy() *CompressionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CompressionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CompressionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CompressionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CompressionTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCompressionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCompressionType) ContentLengthValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for content_length")
	}

	return validatorFn, nil
}

func (v *ValidateCompressionType) ContentTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for content_type")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for content_type")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated content_type")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items content_type")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCompressionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CompressionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CompressionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["content_length"]; exists {

		vOpts := append(opts, db.WithValidateField("content_length"))
		if err := fv(ctx, m.GetContentLength(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["content_type"]; exists {
		vOpts := append(opts, db.WithValidateField("content_type"))
		if err := fv(ctx, m.GetContentType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_on_etag_header"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_on_etag_header"))
		if err := fv(ctx, m.GetDisableOnEtagHeader(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["remove_accept_encoding_header"]; exists {

		vOpts := append(opts, db.WithValidateField("remove_accept_encoding_header"))
		if err := fv(ctx, m.GetRemoveAcceptEncodingHeader(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCompressionTypeValidator = func() *ValidateCompressionType {
	v := &ValidateCompressionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhContentLength := v.ContentLengthValidationRuleHandler
	rulesContentLength := map[string]string{
		"ves.io.schema.rules.uint32.gte": "30",
	}
	vFn, err = vrhContentLength(rulesContentLength)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CompressionType.content_length: %s", err)
		panic(errMsg)
	}
	v.FldValidators["content_length"] = vFn

	vrhContentType := v.ContentTypeValidationRuleHandler
	rulesContentType := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "50",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhContentType(rulesContentType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CompressionType.content_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["content_type"] = vFn

	return v
}()

func CompressionTypeValidator() db.Validator {
	return DefaultCompressionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CreateSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetTlsParameters().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.tls_parameters")
	}

	if err := m.GetAuthentication().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.authentication")
	}

	return nil
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAdvertisePoliciesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetAuthenticationChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDynamicReverseProxyDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterAllowedPrefixesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRoutesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetUserIdentificationDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWafTypeDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *CreateSpecType) GetAdvertisePoliciesDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetAdvertisePolicies() {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.advertise_policies[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "advertise_policy.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "advertise_policies",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetAdvertisePoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetAdvertisePoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "advertise_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: advertise_policy")
	}
	for _, ref := range m.GetAdvertisePolicies() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetAuthenticationChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetAuthenticationChoice() == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetAuthenticationChoice().(type) {
	case *CreateSpecType_NoAuthentication:

	case *CreateSpecType_Authentication:
		odrInfos, err = m.GetAuthentication().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "authentication." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetDynamicReverseProxyDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetDynamicReverseProxy() == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.GetDynamicReverseProxy().GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "dynamic_reverse_proxy." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

func (m *CreateSpecType) GetRateLimiterDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetRateLimiter() {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.rate_limiter[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "rate_limiter.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetRateLimiterDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetRateLimiterDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "rate_limiter.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: rate_limiter")
	}
	for _, ref := range m.GetRateLimiter() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *CreateSpecType) GetRateLimiterAllowedPrefixesDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetRateLimiterAllowedPrefixes() {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.rate_limiter_allowed_prefixes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "ip_prefix_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter_allowed_prefixes",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetRateLimiterAllowedPrefixesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetRateLimiterAllowedPrefixesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "ip_prefix_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: ip_prefix_set")
	}
	for _, ref := range m.GetRateLimiterAllowedPrefixes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *CreateSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetRoutes() {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.routes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "route.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "routes",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetRoutesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetRoutesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "route.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: route")
	}
	for _, ref := range m.GetRoutes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *CreateSpecType) GetUserIdentificationDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetUserIdentification() {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.user_identification[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "user_identification.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "user_identification",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetUserIdentificationDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetUserIdentificationDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "user_identification.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: user_identification")
	}
	for _, ref := range m.GetUserIdentification() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetWafTypeDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetWafType() == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.GetWafType().GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "waf_type." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) ChallengeTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for challenge_type")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ServerHeaderChoiceServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_name")
	}
	return oValidatorFn_ServerName, nil
}
func (v *ValidateCreateSpecType) ServerHeaderChoiceAppendServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_AppendServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for append_server_name")
	}
	return oValidatorFn_AppendServerName, nil
}

func (v *ValidateCreateSpecType) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) RequestHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ResponseHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ResponseHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) RequestHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) CustomErrorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapUint32KeyRules(rules)
	itemKeyFn, err := db.NewUint32ValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for custom_errors")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for custom_errors")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[uint32]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for custom_errors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[uint32]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ uint32 ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map custom_errors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items custom_errors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) MaxRequestHeaderSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_request_header_size")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) UserIdentificationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for user_identification")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated user_identification")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items user_identification")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) RateLimiterValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) RateLimiterAllowedPrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter_allowed_prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter_allowed_prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_location"]; exists {

		vOpts := append(opts, db.WithValidateField("add_location"))
		if err := fv(ctx, m.GetAddLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["advertise_policies"]; exists {

		vOpts := append(opts, db.WithValidateField("advertise_policies"))
		for idx, item := range m.GetAdvertisePolicies() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetAuthenticationChoice().(type) {
	case *CreateSpecType_NoAuthentication:
		if fv, exists := v.FldValidators["authentication_choice.no_authentication"]; exists {
			val := m.GetAuthenticationChoice().(*CreateSpecType_NoAuthentication).NoAuthentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("no_authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Authentication:
		if fv, exists := v.FldValidators["authentication_choice.authentication"]; exists {
			val := m.GetAuthenticationChoice().(*CreateSpecType_Authentication).Authentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["buffer_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("buffer_policy"))
		if err := fv(ctx, m.GetBufferPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["challenge_type"]; exists {
		val := m.GetChallengeType()
		vOpts := append(opts,
			db.WithValidateField("challenge_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChallengeType().(type) {
	case *CreateSpecType_JsChallenge:
		if fv, exists := v.FldValidators["challenge_type.js_challenge"]; exists {
			val := m.GetChallengeType().(*CreateSpecType_JsChallenge).JsChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("js_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_CaptchaChallenge:
		if fv, exists := v.FldValidators["challenge_type.captcha_challenge"]; exists {
			val := m.GetChallengeType().(*CreateSpecType_CaptchaChallenge).CaptchaChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("captcha_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_NoChallenge:
		if fv, exists := v.FldValidators["challenge_type.no_challenge"]; exists {
			val := m.GetChallengeType().(*CreateSpecType_NoChallenge).NoChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("no_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["compression_params"]; exists {

		vOpts := append(opts, db.WithValidateField("compression_params"))
		if err := fv(ctx, m.GetCompressionParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cors_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("cors_policy"))
		if err := fv(ctx, m.GetCorsPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_errors"]; exists {
		vOpts := append(opts, db.WithValidateField("custom_errors"))
		if err := fv(ctx, m.GetCustomErrors(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_default_error_pages"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_default_error_pages"))
		if err := fv(ctx, m.GetDisableDefaultErrorPages(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_dns_resolve"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_dns_resolve"))
		if err := fv(ctx, m.GetDisableDnsResolve(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dynamic_reverse_proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("dynamic_reverse_proxy"))
		if err := fv(ctx, m.GetDynamicReverseProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("idle_timeout"))
		if err := fv(ctx, m.GetIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_request_header_size"]; exists {

		vOpts := append(opts, db.WithValidateField("max_request_header_size"))
		if err := fv(ctx, m.GetMaxRequestHeaderSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("proxy"))
		if err := fv(ctx, m.GetProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter"))
		if err := fv(ctx, m.GetRateLimiter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter_allowed_prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter_allowed_prefixes"))
		if err := fv(ctx, m.GetRateLimiterAllowedPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_add"))
		if err := fv(ctx, m.GetRequestHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_remove"))
		if err := fv(ctx, m.GetRequestHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_add"))
		if err := fv(ctx, m.GetResponseHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_remove"))
		if err := fv(ctx, m.GetResponseHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["retry_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("retry_policy"))
		if err := fv(ctx, m.GetRetryPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetServerHeaderChoice().(type) {
	case *CreateSpecType_DefaultHeader:
		if fv, exists := v.FldValidators["server_header_choice.default_header"]; exists {
			val := m.GetServerHeaderChoice().(*CreateSpecType_DefaultHeader).DefaultHeader
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("default_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_ServerName:
		if fv, exists := v.FldValidators["server_header_choice.server_name"]; exists {
			val := m.GetServerHeaderChoice().(*CreateSpecType_ServerName).ServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_AppendServerName:
		if fv, exists := v.FldValidators["server_header_choice.append_server_name"]; exists {
			val := m.GetServerHeaderChoice().(*CreateSpecType_AppendServerName).AppendServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("append_server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_PassThrough:
		if fv, exists := v.FldValidators["server_header_choice.pass_through"]; exists {
			val := m.GetServerHeaderChoice().(*CreateSpecType_PassThrough).PassThrough
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("pass_through"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["temporary_user_blocking"]; exists {

		vOpts := append(opts, db.WithValidateField("temporary_user_blocking"))
		if err := fv(ctx, m.GetTemporaryUserBlocking(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_parameters"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_parameters"))
		if err := fv(ctx, m.GetTlsParameters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_identification"]; exists {
		vOpts := append(opts, db.WithValidateField("user_identification"))
		if err := fv(ctx, m.GetUserIdentification(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["waf_type"]; exists {

		vOpts := append(opts, db.WithValidateField("waf_type"))
		if err := fv(ctx, m.GetWafType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChallengeType := v.ChallengeTypeValidationRuleHandler
	rulesChallengeType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChallengeType(rulesChallengeType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.challenge_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["challenge_type"] = vFn

	vrhServerHeaderChoiceServerName := v.ServerHeaderChoiceServerNameValidationRuleHandler
	rulesServerHeaderChoiceServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.server_name"], err = vrhServerHeaderChoiceServerName(rulesServerHeaderChoiceServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CreateSpecType.server_header_choice_server_name: %s", err)
		panic(errMsg)
	}
	vrhServerHeaderChoiceAppendServerName := v.ServerHeaderChoiceAppendServerNameValidationRuleHandler
	rulesServerHeaderChoiceAppendServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.append_server_name"], err = vrhServerHeaderChoiceAppendServerName(rulesServerHeaderChoiceAppendServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CreateSpecType.server_header_choice_append_server_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["server_header_choice.server_name"] = vFnMap["server_header_choice.server_name"]
	v.FldValidators["server_header_choice.append_server_name"] = vFnMap["server_header_choice.append_server_name"]

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.repeated.items.string.vh_domain": "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "128",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	vrhRequestHeadersToAdd := v.RequestHeadersToAddValidationRuleHandler
	rulesRequestHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToAdd(rulesRequestHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.request_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_add"] = vFn

	vrhResponseHeadersToAdd := v.ResponseHeadersToAddValidationRuleHandler
	rulesResponseHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToAdd(rulesResponseHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.response_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_add"] = vFn

	vrhResponseHeadersToRemove := v.ResponseHeadersToRemoveValidationRuleHandler
	rulesResponseHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToRemove(rulesResponseHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.response_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_remove"] = vFn

	vrhRequestHeadersToRemove := v.RequestHeadersToRemoveValidationRuleHandler
	rulesRequestHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToRemove(rulesRequestHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.request_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_remove"] = vFn

	vrhCustomErrors := v.CustomErrorsValidationRuleHandler
	rulesCustomErrors := map[string]string{
		"ves.io.schema.rules.map.keys.uint32.gte":       "3",
		"ves.io.schema.rules.map.keys.uint32.lte":       "599",
		"ves.io.schema.rules.map.max_pairs":             "16",
		"ves.io.schema.rules.map.values.string.max_len": "16384",
		"ves.io.schema.rules.map.values.string.uri_ref": "true",
	}
	vFn, err = vrhCustomErrors(rulesCustomErrors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.custom_errors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_errors"] = vFn

	vrhMaxRequestHeaderSize := v.MaxRequestHeaderSizeValidationRuleHandler
	rulesMaxRequestHeaderSize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "96",
	}
	vFn, err = vrhMaxRequestHeaderSize(rulesMaxRequestHeaderSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.max_request_header_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_request_header_size"] = vFn

	vrhUserIdentification := v.UserIdentificationValidationRuleHandler
	rulesUserIdentification := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhUserIdentification(rulesUserIdentification)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.user_identification: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user_identification"] = vFn

	vrhRateLimiter := v.RateLimiterValidationRuleHandler
	rulesRateLimiter := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRateLimiter(rulesRateLimiter)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.rate_limiter: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter"] = vFn

	vrhRateLimiterAllowedPrefixes := v.RateLimiterAllowedPrefixesValidationRuleHandler
	rulesRateLimiterAllowedPrefixes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhRateLimiterAllowedPrefixes(rulesRateLimiterAllowedPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.rate_limiter_allowed_prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter_allowed_prefixes"] = vFn

	v.FldValidators["authentication_choice.authentication"] = AuthenticationDetailsValidator().Validate

	v.FldValidators["challenge_type.js_challenge"] = JavascriptChallengeTypeValidator().Validate
	v.FldValidators["challenge_type.captcha_challenge"] = CaptchaChallengeTypeValidator().Validate

	v.FldValidators["tls_parameters"] = ves_io_schema.DownstreamTlsParamsTypeValidator().Validate

	v.FldValidators["buffer_policy"] = ves_io_schema.BufferConfigTypeValidator().Validate

	v.FldValidators["cors_policy"] = ves_io_schema.CorsPolicyValidator().Validate

	v.FldValidators["waf_type"] = ves_io_schema.WafTypeValidator().Validate

	v.FldValidators["dynamic_reverse_proxy"] = DynamicReverseProxyTypeValidator().Validate

	v.FldValidators["compression_params"] = CompressionTypeValidator().Validate

	v.FldValidators["retry_policy"] = ves_io_schema.RetryPolicyTypeValidator().Validate

	v.FldValidators["temporary_user_blocking"] = TemporaryUserBlockingTypeValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DynamicReverseProxyType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DynamicReverseProxyType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DynamicReverseProxyType) DeepCopy() *DynamicReverseProxyType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DynamicReverseProxyType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DynamicReverseProxyType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DynamicReverseProxyType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DynamicReverseProxyTypeValidator().Validate(ctx, m, opts...)
}

func (m *DynamicReverseProxyType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetResolutionNetworkDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *DynamicReverseProxyType) GetResolutionNetworkDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetResolutionNetwork() {
		if ref == nil {
			return nil, fmt.Errorf("DynamicReverseProxyType.resolution_network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "resolution_network",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetResolutionNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *DynamicReverseProxyType) GetResolutionNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetResolutionNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateDynamicReverseProxyType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDynamicReverseProxyType) ConnectionTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateDynamicReverseProxyType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DynamicReverseProxyType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DynamicReverseProxyType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["connection_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_timeout"))
		if err := fv(ctx, m.GetConnectionTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["resolution_network"]; exists {

		vOpts := append(opts, db.WithValidateField("resolution_network"))
		for idx, item := range m.GetResolutionNetwork() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["resolution_network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("resolution_network_type"))
		if err := fv(ctx, m.GetResolutionNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["resolve_endpoint_dynamically"]; exists {

		vOpts := append(opts, db.WithValidateField("resolve_endpoint_dynamically"))
		if err := fv(ctx, m.GetResolveEndpointDynamically(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDynamicReverseProxyTypeValidator = func() *ValidateDynamicReverseProxyType {
	v := &ValidateDynamicReverseProxyType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhConnectionTimeout := v.ConnectionTimeoutValidationRuleHandler
	rulesConnectionTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhConnectionTimeout(rulesConnectionTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DynamicReverseProxyType.connection_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_timeout"] = vFn

	return v
}()

func DynamicReverseProxyTypeValidator() db.Validator {
	return DefaultDynamicReverseProxyTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GetSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetTlsParameters().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.tls_parameters")
	}

	if err := m.GetAuthentication().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.authentication")
	}

	return nil
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAdvertisePoliciesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetAuthenticationChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDynamicReverseProxyDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterAllowedPrefixesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRoutesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetUserIdentificationDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWafTypeDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *GetSpecType) GetAdvertisePoliciesDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetAdvertisePolicies() {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.advertise_policies[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "advertise_policy.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "advertise_policies",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetAdvertisePoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetAdvertisePoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "advertise_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: advertise_policy")
	}
	for _, ref := range m.GetAdvertisePolicies() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetAuthenticationChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetAuthenticationChoice() == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetAuthenticationChoice().(type) {
	case *GetSpecType_NoAuthentication:

	case *GetSpecType_Authentication:
		odrInfos, err = m.GetAuthentication().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "authentication." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetDynamicReverseProxyDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetDynamicReverseProxy() == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.GetDynamicReverseProxy().GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "dynamic_reverse_proxy." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

func (m *GetSpecType) GetRateLimiterDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetRateLimiter() {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.rate_limiter[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "rate_limiter.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetRateLimiterDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetRateLimiterDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "rate_limiter.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: rate_limiter")
	}
	for _, ref := range m.GetRateLimiter() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GetSpecType) GetRateLimiterAllowedPrefixesDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetRateLimiterAllowedPrefixes() {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.rate_limiter_allowed_prefixes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "ip_prefix_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter_allowed_prefixes",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetRateLimiterAllowedPrefixesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetRateLimiterAllowedPrefixesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "ip_prefix_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: ip_prefix_set")
	}
	for _, ref := range m.GetRateLimiterAllowedPrefixes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GetSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetRoutes() {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.routes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "route.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "routes",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetRoutesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetRoutesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "route.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: route")
	}
	for _, ref := range m.GetRoutes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GetSpecType) GetUserIdentificationDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetUserIdentification() {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.user_identification[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "user_identification.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "user_identification",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetUserIdentificationDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetUserIdentificationDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "user_identification.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: user_identification")
	}
	for _, ref := range m.GetUserIdentification() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetWafTypeDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetWafType() == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.GetWafType().GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "waf_type." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) ChallengeTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for challenge_type")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) ServerHeaderChoiceServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_name")
	}
	return oValidatorFn_ServerName, nil
}
func (v *ValidateGetSpecType) ServerHeaderChoiceAppendServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_AppendServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for append_server_name")
	}
	return oValidatorFn_AppendServerName, nil
}

func (v *ValidateGetSpecType) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) RequestHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) ResponseHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) ResponseHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) RequestHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) CustomErrorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapUint32KeyRules(rules)
	itemKeyFn, err := db.NewUint32ValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for custom_errors")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for custom_errors")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[uint32]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for custom_errors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[uint32]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ uint32 ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map custom_errors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items custom_errors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) MaxRequestHeaderSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_request_header_size")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) UserIdentificationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for user_identification")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated user_identification")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items user_identification")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) RateLimiterValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) RateLimiterAllowedPrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter_allowed_prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter_allowed_prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_location"]; exists {

		vOpts := append(opts, db.WithValidateField("add_location"))
		if err := fv(ctx, m.GetAddLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["advertise_policies"]; exists {

		vOpts := append(opts, db.WithValidateField("advertise_policies"))
		for idx, item := range m.GetAdvertisePolicies() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetAuthenticationChoice().(type) {
	case *GetSpecType_NoAuthentication:
		if fv, exists := v.FldValidators["authentication_choice.no_authentication"]; exists {
			val := m.GetAuthenticationChoice().(*GetSpecType_NoAuthentication).NoAuthentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("no_authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Authentication:
		if fv, exists := v.FldValidators["authentication_choice.authentication"]; exists {
			val := m.GetAuthenticationChoice().(*GetSpecType_Authentication).Authentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["auto_cert_info"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_info"))
		if err := fv(ctx, m.GetAutoCertInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_state"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_state"))
		if err := fv(ctx, m.GetAutoCertState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["buffer_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("buffer_policy"))
		if err := fv(ctx, m.GetBufferPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["challenge_type"]; exists {
		val := m.GetChallengeType()
		vOpts := append(opts,
			db.WithValidateField("challenge_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChallengeType().(type) {
	case *GetSpecType_JsChallenge:
		if fv, exists := v.FldValidators["challenge_type.js_challenge"]; exists {
			val := m.GetChallengeType().(*GetSpecType_JsChallenge).JsChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("js_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_CaptchaChallenge:
		if fv, exists := v.FldValidators["challenge_type.captcha_challenge"]; exists {
			val := m.GetChallengeType().(*GetSpecType_CaptchaChallenge).CaptchaChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("captcha_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_NoChallenge:
		if fv, exists := v.FldValidators["challenge_type.no_challenge"]; exists {
			val := m.GetChallengeType().(*GetSpecType_NoChallenge).NoChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("no_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["compression_params"]; exists {

		vOpts := append(opts, db.WithValidateField("compression_params"))
		if err := fv(ctx, m.GetCompressionParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cors_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("cors_policy"))
		if err := fv(ctx, m.GetCorsPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_errors"]; exists {
		vOpts := append(opts, db.WithValidateField("custom_errors"))
		if err := fv(ctx, m.GetCustomErrors(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_default_error_pages"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_default_error_pages"))
		if err := fv(ctx, m.GetDisableDefaultErrorPages(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_dns_resolve"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_dns_resolve"))
		if err := fv(ctx, m.GetDisableDnsResolve(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_info"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_info"))
		for idx, item := range m.GetDnsInfo() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dynamic_reverse_proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("dynamic_reverse_proxy"))
		if err := fv(ctx, m.GetDynamicReverseProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["host_name"]; exists {

		vOpts := append(opts, db.WithValidateField("host_name"))
		if err := fv(ctx, m.GetHostName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("idle_timeout"))
		if err := fv(ctx, m.GetIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_request_header_size"]; exists {

		vOpts := append(opts, db.WithValidateField("max_request_header_size"))
		if err := fv(ctx, m.GetMaxRequestHeaderSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("proxy"))
		if err := fv(ctx, m.GetProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter"))
		if err := fv(ctx, m.GetRateLimiter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter_allowed_prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter_allowed_prefixes"))
		if err := fv(ctx, m.GetRateLimiterAllowedPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_add"))
		if err := fv(ctx, m.GetRequestHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_remove"))
		if err := fv(ctx, m.GetRequestHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_add"))
		if err := fv(ctx, m.GetResponseHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_remove"))
		if err := fv(ctx, m.GetResponseHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["retry_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("retry_policy"))
		if err := fv(ctx, m.GetRetryPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetServerHeaderChoice().(type) {
	case *GetSpecType_DefaultHeader:
		if fv, exists := v.FldValidators["server_header_choice.default_header"]; exists {
			val := m.GetServerHeaderChoice().(*GetSpecType_DefaultHeader).DefaultHeader
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("default_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_ServerName:
		if fv, exists := v.FldValidators["server_header_choice.server_name"]; exists {
			val := m.GetServerHeaderChoice().(*GetSpecType_ServerName).ServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_AppendServerName:
		if fv, exists := v.FldValidators["server_header_choice.append_server_name"]; exists {
			val := m.GetServerHeaderChoice().(*GetSpecType_AppendServerName).AppendServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("append_server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_PassThrough:
		if fv, exists := v.FldValidators["server_header_choice.pass_through"]; exists {
			val := m.GetServerHeaderChoice().(*GetSpecType_PassThrough).PassThrough
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("pass_through"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["temporary_user_blocking"]; exists {

		vOpts := append(opts, db.WithValidateField("temporary_user_blocking"))
		if err := fv(ctx, m.GetTemporaryUserBlocking(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_parameters"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_parameters"))
		if err := fv(ctx, m.GetTlsParameters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_identification"]; exists {
		vOpts := append(opts, db.WithValidateField("user_identification"))
		if err := fv(ctx, m.GetUserIdentification(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["waf_type"]; exists {

		vOpts := append(opts, db.WithValidateField("waf_type"))
		if err := fv(ctx, m.GetWafType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChallengeType := v.ChallengeTypeValidationRuleHandler
	rulesChallengeType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChallengeType(rulesChallengeType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.challenge_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["challenge_type"] = vFn

	vrhServerHeaderChoiceServerName := v.ServerHeaderChoiceServerNameValidationRuleHandler
	rulesServerHeaderChoiceServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.server_name"], err = vrhServerHeaderChoiceServerName(rulesServerHeaderChoiceServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GetSpecType.server_header_choice_server_name: %s", err)
		panic(errMsg)
	}
	vrhServerHeaderChoiceAppendServerName := v.ServerHeaderChoiceAppendServerNameValidationRuleHandler
	rulesServerHeaderChoiceAppendServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.append_server_name"], err = vrhServerHeaderChoiceAppendServerName(rulesServerHeaderChoiceAppendServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GetSpecType.server_header_choice_append_server_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["server_header_choice.server_name"] = vFnMap["server_header_choice.server_name"]
	v.FldValidators["server_header_choice.append_server_name"] = vFnMap["server_header_choice.append_server_name"]

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.repeated.items.string.vh_domain": "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "128",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	vrhRequestHeadersToAdd := v.RequestHeadersToAddValidationRuleHandler
	rulesRequestHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToAdd(rulesRequestHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.request_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_add"] = vFn

	vrhResponseHeadersToAdd := v.ResponseHeadersToAddValidationRuleHandler
	rulesResponseHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToAdd(rulesResponseHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.response_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_add"] = vFn

	vrhResponseHeadersToRemove := v.ResponseHeadersToRemoveValidationRuleHandler
	rulesResponseHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToRemove(rulesResponseHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.response_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_remove"] = vFn

	vrhRequestHeadersToRemove := v.RequestHeadersToRemoveValidationRuleHandler
	rulesRequestHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToRemove(rulesRequestHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.request_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_remove"] = vFn

	vrhCustomErrors := v.CustomErrorsValidationRuleHandler
	rulesCustomErrors := map[string]string{
		"ves.io.schema.rules.map.keys.uint32.gte":       "3",
		"ves.io.schema.rules.map.keys.uint32.lte":       "599",
		"ves.io.schema.rules.map.max_pairs":             "16",
		"ves.io.schema.rules.map.values.string.max_len": "16384",
		"ves.io.schema.rules.map.values.string.uri_ref": "true",
	}
	vFn, err = vrhCustomErrors(rulesCustomErrors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.custom_errors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_errors"] = vFn

	vrhMaxRequestHeaderSize := v.MaxRequestHeaderSizeValidationRuleHandler
	rulesMaxRequestHeaderSize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "96",
	}
	vFn, err = vrhMaxRequestHeaderSize(rulesMaxRequestHeaderSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.max_request_header_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_request_header_size"] = vFn

	vrhUserIdentification := v.UserIdentificationValidationRuleHandler
	rulesUserIdentification := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhUserIdentification(rulesUserIdentification)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.user_identification: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user_identification"] = vFn

	vrhRateLimiter := v.RateLimiterValidationRuleHandler
	rulesRateLimiter := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRateLimiter(rulesRateLimiter)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.rate_limiter: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter"] = vFn

	vrhRateLimiterAllowedPrefixes := v.RateLimiterAllowedPrefixesValidationRuleHandler
	rulesRateLimiterAllowedPrefixes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhRateLimiterAllowedPrefixes(rulesRateLimiterAllowedPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.rate_limiter_allowed_prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter_allowed_prefixes"] = vFn

	v.FldValidators["authentication_choice.authentication"] = AuthenticationDetailsValidator().Validate

	v.FldValidators["challenge_type.js_challenge"] = JavascriptChallengeTypeValidator().Validate
	v.FldValidators["challenge_type.captcha_challenge"] = CaptchaChallengeTypeValidator().Validate

	v.FldValidators["tls_parameters"] = ves_io_schema.DownstreamTlsParamsTypeValidator().Validate

	v.FldValidators["buffer_policy"] = ves_io_schema.BufferConfigTypeValidator().Validate

	v.FldValidators["cors_policy"] = ves_io_schema.CorsPolicyValidator().Validate

	v.FldValidators["waf_type"] = ves_io_schema.WafTypeValidator().Validate

	v.FldValidators["dynamic_reverse_proxy"] = DynamicReverseProxyTypeValidator().Validate

	v.FldValidators["compression_params"] = CompressionTypeValidator().Validate

	v.FldValidators["retry_policy"] = ves_io_schema.RetryPolicyTypeValidator().Validate

	v.FldValidators["temporary_user_blocking"] = TemporaryUserBlockingTypeValidator().Validate

	v.FldValidators["dns_info"] = ves_io_schema_virtual_host_dns_info.DnsInfoValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GlobalSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetTlsParameters().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.tls_parameters")
	}

	if err := m.GetTlsIntercept().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.tls_intercept")
	}

	if err := m.GetAuthentication().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.authentication")
	}

	return nil
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAdvertisePoliciesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetAuthenticationChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetChallengeTypeDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDnsDomainsDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDynamicReverseProxyDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetJwtDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetMaliciousUserMitigationDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterAllowedPrefixesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRoutesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetServicePolicySetsDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetUserIdentificationDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWafTypeDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *GlobalSpecType) GetAdvertisePoliciesDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetAdvertisePolicies() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.advertise_policies[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "advertise_policy.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "advertise_policies",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetAdvertisePoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetAdvertisePoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "advertise_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: advertise_policy")
	}
	for _, ref := range m.GetAdvertisePolicies() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetAuthenticationChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetAuthenticationChoice() == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetAuthenticationChoice().(type) {
	case *GlobalSpecType_NoAuthentication:

	case *GlobalSpecType_Authentication:
		odrInfos, err = m.GetAuthentication().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "authentication." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetChallengeTypeDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetChallengeType() == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetChallengeType().(type) {
	case *GlobalSpecType_JsChallenge:

	case *GlobalSpecType_CaptchaChallenge:

	case *GlobalSpecType_NoChallenge:

	case *GlobalSpecType_PolicyBasedChallenge:
		odrInfos, err = m.GetPolicyBasedChallenge().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "policy_based_challenge." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

func (m *GlobalSpecType) GetDnsDomainsDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetDnsDomains() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.dns_domains[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "dns_domain.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "dns_domains",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetDnsDomainsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetDnsDomainsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "dns_domain.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: dns_domain")
	}
	for _, ref := range m.GetDnsDomains() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetDynamicReverseProxyDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetDynamicReverseProxy() == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.GetDynamicReverseProxy().GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "dynamic_reverse_proxy." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

func (m *GlobalSpecType) GetJwtDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetJwt() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.jwt[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "jwt.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "jwt",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetJwtDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetJwtDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "jwt.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: jwt")
	}
	for _, ref := range m.GetJwt() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetMaliciousUserMitigationDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetMaliciousUserMitigation() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.malicious_user_mitigation[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "malicious_user_mitigation.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "malicious_user_mitigation",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetMaliciousUserMitigationDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetMaliciousUserMitigationDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "malicious_user_mitigation.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: malicious_user_mitigation")
	}
	for _, ref := range m.GetMaliciousUserMitigation() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetRateLimiterDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetRateLimiter() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.rate_limiter[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "rate_limiter.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetRateLimiterDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetRateLimiterDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "rate_limiter.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: rate_limiter")
	}
	for _, ref := range m.GetRateLimiter() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetRateLimiterAllowedPrefixesDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetRateLimiterAllowedPrefixes() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.rate_limiter_allowed_prefixes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "ip_prefix_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter_allowed_prefixes",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetRateLimiterAllowedPrefixesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetRateLimiterAllowedPrefixesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "ip_prefix_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: ip_prefix_set")
	}
	for _, ref := range m.GetRateLimiterAllowedPrefixes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetRoutes() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.routes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "route.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "routes",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetRoutesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetRoutesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "route.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: route")
	}
	for _, ref := range m.GetRoutes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetServicePolicySetsDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetServicePolicySets() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.service_policy_sets[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "service_policy_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "service_policy_sets",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetServicePolicySetsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetServicePolicySetsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "service_policy_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: service_policy_set")
	}
	for _, ref := range m.GetServicePolicySets() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetUserIdentificationDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetUserIdentification() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.user_identification[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "user_identification.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "user_identification",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetUserIdentificationDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetUserIdentificationDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "user_identification.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: user_identification")
	}
	for _, ref := range m.GetUserIdentification() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetWafTypeDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetWafType() == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.GetWafType().GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "waf_type." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) ChallengeTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for challenge_type")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ServerHeaderChoiceServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_name")
	}
	return oValidatorFn_ServerName, nil
}
func (v *ValidateGlobalSpecType) ServerHeaderChoiceAppendServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_AppendServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for append_server_name")
	}
	return oValidatorFn_AppendServerName, nil
}

func (v *ValidateGlobalSpecType) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) RequestHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ResponseHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ResponseHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) RequestHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) CustomErrorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapUint32KeyRules(rules)
	itemKeyFn, err := db.NewUint32ValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for custom_errors")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for custom_errors")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[uint32]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for custom_errors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[uint32]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ uint32 ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map custom_errors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items custom_errors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) MaxRequestHeaderSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_request_header_size")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) UserIdentificationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for user_identification")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated user_identification")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items user_identification")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) RateLimiterValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) RateLimiterAllowedPrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter_allowed_prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter_allowed_prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) MaliciousUserMitigationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for malicious_user_mitigation")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated malicious_user_mitigation")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items malicious_user_mitigation")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DnsDomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for dns_domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated dns_domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items dns_domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) UserDomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for user_domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for user_domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated user_domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items user_domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ServicePolicySetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for service_policy_sets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated service_policy_sets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items service_policy_sets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_location"]; exists {

		vOpts := append(opts, db.WithValidateField("add_location"))
		if err := fv(ctx, m.GetAddLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["advertise_policies"]; exists {

		vOpts := append(opts, db.WithValidateField("advertise_policies"))
		for idx, item := range m.GetAdvertisePolicies() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetAuthenticationChoice().(type) {
	case *GlobalSpecType_NoAuthentication:
		if fv, exists := v.FldValidators["authentication_choice.no_authentication"]; exists {
			val := m.GetAuthenticationChoice().(*GlobalSpecType_NoAuthentication).NoAuthentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("no_authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Authentication:
		if fv, exists := v.FldValidators["authentication_choice.authentication"]; exists {
			val := m.GetAuthenticationChoice().(*GlobalSpecType_Authentication).Authentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["auto_cert"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert"))
		if err := fv(ctx, m.GetAutoCert(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_info"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_info"))
		if err := fv(ctx, m.GetAutoCertInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_state"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_state"))
		if err := fv(ctx, m.GetAutoCertState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["buffer_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("buffer_policy"))
		if err := fv(ctx, m.GetBufferPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["challenge_type"]; exists {
		val := m.GetChallengeType()
		vOpts := append(opts,
			db.WithValidateField("challenge_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChallengeType().(type) {
	case *GlobalSpecType_JsChallenge:
		if fv, exists := v.FldValidators["challenge_type.js_challenge"]; exists {
			val := m.GetChallengeType().(*GlobalSpecType_JsChallenge).JsChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("js_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_CaptchaChallenge:
		if fv, exists := v.FldValidators["challenge_type.captcha_challenge"]; exists {
			val := m.GetChallengeType().(*GlobalSpecType_CaptchaChallenge).CaptchaChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("captcha_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_NoChallenge:
		if fv, exists := v.FldValidators["challenge_type.no_challenge"]; exists {
			val := m.GetChallengeType().(*GlobalSpecType_NoChallenge).NoChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("no_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_PolicyBasedChallenge:
		if fv, exists := v.FldValidators["challenge_type.policy_based_challenge"]; exists {
			val := m.GetChallengeType().(*GlobalSpecType_PolicyBasedChallenge).PolicyBasedChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("policy_based_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["compression_params"]; exists {

		vOpts := append(opts, db.WithValidateField("compression_params"))
		if err := fv(ctx, m.GetCompressionParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cors_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("cors_policy"))
		if err := fv(ctx, m.GetCorsPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_errors"]; exists {
		vOpts := append(opts, db.WithValidateField("custom_errors"))
		if err := fv(ctx, m.GetCustomErrors(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_default_error_pages"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_default_error_pages"))
		if err := fv(ctx, m.GetDisableDefaultErrorPages(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_dns_resolve"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_dns_resolve"))
		if err := fv(ctx, m.GetDisableDnsResolve(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_domains"]; exists {
		vOpts := append(opts, db.WithValidateField("dns_domains"))
		if err := fv(ctx, m.GetDnsDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_info"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_info"))
		for idx, item := range m.GetDnsInfo() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["dns_volterra_managed"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_volterra_managed"))
		if err := fv(ctx, m.GetDnsVolterraManaged(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dynamic_reverse_proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("dynamic_reverse_proxy"))
		if err := fv(ctx, m.GetDynamicReverseProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["host_name"]; exists {

		vOpts := append(opts, db.WithValidateField("host_name"))
		if err := fv(ctx, m.GetHostName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("idle_timeout"))
		if err := fv(ctx, m.GetIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["javascript_info"]; exists {

		vOpts := append(opts, db.WithValidateField("javascript_info"))
		if err := fv(ctx, m.GetJavascriptInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["jwt"]; exists {

		vOpts := append(opts, db.WithValidateField("jwt"))
		for idx, item := range m.GetJwt() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["loadbalancer_algorithm"]; exists {

		vOpts := append(opts, db.WithValidateField("loadbalancer_algorithm"))
		if err := fv(ctx, m.GetLoadbalancerAlgorithm(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["malicious_user_mitigation"]; exists {
		vOpts := append(opts, db.WithValidateField("malicious_user_mitigation"))
		if err := fv(ctx, m.GetMaliciousUserMitigation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_request_header_size"]; exists {

		vOpts := append(opts, db.WithValidateField("max_request_header_size"))
		if err := fv(ctx, m.GetMaxRequestHeaderSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("proxy"))
		if err := fv(ctx, m.GetProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter"))
		if err := fv(ctx, m.GetRateLimiter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter_allowed_prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter_allowed_prefixes"))
		if err := fv(ctx, m.GetRateLimiterAllowedPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_add"))
		if err := fv(ctx, m.GetRequestHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_remove"))
		if err := fv(ctx, m.GetRequestHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_add"))
		if err := fv(ctx, m.GetResponseHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_remove"))
		if err := fv(ctx, m.GetResponseHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["retry_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("retry_policy"))
		if err := fv(ctx, m.GetRetryPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetServerHeaderChoice().(type) {
	case *GlobalSpecType_DefaultHeader:
		if fv, exists := v.FldValidators["server_header_choice.default_header"]; exists {
			val := m.GetServerHeaderChoice().(*GlobalSpecType_DefaultHeader).DefaultHeader
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("default_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_ServerName:
		if fv, exists := v.FldValidators["server_header_choice.server_name"]; exists {
			val := m.GetServerHeaderChoice().(*GlobalSpecType_ServerName).ServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_AppendServerName:
		if fv, exists := v.FldValidators["server_header_choice.append_server_name"]; exists {
			val := m.GetServerHeaderChoice().(*GlobalSpecType_AppendServerName).AppendServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("append_server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_PassThrough:
		if fv, exists := v.FldValidators["server_header_choice.pass_through"]; exists {
			val := m.GetServerHeaderChoice().(*GlobalSpecType_PassThrough).PassThrough
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("pass_through"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service_policy_sets"]; exists {
		vOpts := append(opts, db.WithValidateField("service_policy_sets"))
		if err := fv(ctx, m.GetServicePolicySets(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["temporary_user_blocking"]; exists {

		vOpts := append(opts, db.WithValidateField("temporary_user_blocking"))
		if err := fv(ctx, m.GetTemporaryUserBlocking(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_intercept"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_intercept"))
		if err := fv(ctx, m.GetTlsIntercept(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_parameters"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_parameters"))
		if err := fv(ctx, m.GetTlsParameters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_domains"]; exists {
		vOpts := append(opts, db.WithValidateField("user_domains"))
		if err := fv(ctx, m.GetUserDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_identification"]; exists {
		vOpts := append(opts, db.WithValidateField("user_identification"))
		if err := fv(ctx, m.GetUserIdentification(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_cert"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_cert"))
		if err := fv(ctx, m.GetVolterraCert(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["waf_type"]; exists {

		vOpts := append(opts, db.WithValidateField("waf_type"))
		if err := fv(ctx, m.GetWafType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChallengeType := v.ChallengeTypeValidationRuleHandler
	rulesChallengeType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChallengeType(rulesChallengeType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.challenge_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["challenge_type"] = vFn

	vrhServerHeaderChoiceServerName := v.ServerHeaderChoiceServerNameValidationRuleHandler
	rulesServerHeaderChoiceServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.server_name"], err = vrhServerHeaderChoiceServerName(rulesServerHeaderChoiceServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GlobalSpecType.server_header_choice_server_name: %s", err)
		panic(errMsg)
	}
	vrhServerHeaderChoiceAppendServerName := v.ServerHeaderChoiceAppendServerNameValidationRuleHandler
	rulesServerHeaderChoiceAppendServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.append_server_name"], err = vrhServerHeaderChoiceAppendServerName(rulesServerHeaderChoiceAppendServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GlobalSpecType.server_header_choice_append_server_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["server_header_choice.server_name"] = vFnMap["server_header_choice.server_name"]
	v.FldValidators["server_header_choice.append_server_name"] = vFnMap["server_header_choice.append_server_name"]

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.repeated.items.string.vh_domain": "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "128",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	vrhRequestHeadersToAdd := v.RequestHeadersToAddValidationRuleHandler
	rulesRequestHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToAdd(rulesRequestHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.request_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_add"] = vFn

	vrhResponseHeadersToAdd := v.ResponseHeadersToAddValidationRuleHandler
	rulesResponseHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToAdd(rulesResponseHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.response_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_add"] = vFn

	vrhResponseHeadersToRemove := v.ResponseHeadersToRemoveValidationRuleHandler
	rulesResponseHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToRemove(rulesResponseHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.response_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_remove"] = vFn

	vrhRequestHeadersToRemove := v.RequestHeadersToRemoveValidationRuleHandler
	rulesRequestHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToRemove(rulesRequestHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.request_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_remove"] = vFn

	vrhCustomErrors := v.CustomErrorsValidationRuleHandler
	rulesCustomErrors := map[string]string{
		"ves.io.schema.rules.map.keys.uint32.gte":       "3",
		"ves.io.schema.rules.map.keys.uint32.lte":       "599",
		"ves.io.schema.rules.map.max_pairs":             "16",
		"ves.io.schema.rules.map.values.string.max_len": "16384",
		"ves.io.schema.rules.map.values.string.uri_ref": "true",
	}
	vFn, err = vrhCustomErrors(rulesCustomErrors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.custom_errors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_errors"] = vFn

	vrhMaxRequestHeaderSize := v.MaxRequestHeaderSizeValidationRuleHandler
	rulesMaxRequestHeaderSize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "96",
	}
	vFn, err = vrhMaxRequestHeaderSize(rulesMaxRequestHeaderSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.max_request_header_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_request_header_size"] = vFn

	vrhUserIdentification := v.UserIdentificationValidationRuleHandler
	rulesUserIdentification := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhUserIdentification(rulesUserIdentification)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.user_identification: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user_identification"] = vFn

	vrhRateLimiter := v.RateLimiterValidationRuleHandler
	rulesRateLimiter := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRateLimiter(rulesRateLimiter)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.rate_limiter: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter"] = vFn

	vrhRateLimiterAllowedPrefixes := v.RateLimiterAllowedPrefixesValidationRuleHandler
	rulesRateLimiterAllowedPrefixes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhRateLimiterAllowedPrefixes(rulesRateLimiterAllowedPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.rate_limiter_allowed_prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter_allowed_prefixes"] = vFn

	vrhMaliciousUserMitigation := v.MaliciousUserMitigationValidationRuleHandler
	rulesMaliciousUserMitigation := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhMaliciousUserMitigation(rulesMaliciousUserMitigation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.malicious_user_mitigation: %s", err)
		panic(errMsg)
	}
	v.FldValidators["malicious_user_mitigation"] = vFn

	vrhDnsDomains := v.DnsDomainsValidationRuleHandler
	rulesDnsDomains := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "256",
	}
	vFn, err = vrhDnsDomains(rulesDnsDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.dns_domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_domains"] = vFn

	vrhUserDomains := v.UserDomainsValidationRuleHandler
	rulesUserDomains := map[string]string{
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhUserDomains(rulesUserDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.user_domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user_domains"] = vFn

	vrhServicePolicySets := v.ServicePolicySetsValidationRuleHandler
	rulesServicePolicySets := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhServicePolicySets(rulesServicePolicySets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.service_policy_sets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_policy_sets"] = vFn

	v.FldValidators["authentication_choice.authentication"] = AuthenticationDetailsValidator().Validate

	v.FldValidators["challenge_type.js_challenge"] = JavascriptChallengeTypeValidator().Validate
	v.FldValidators["challenge_type.captcha_challenge"] = CaptchaChallengeTypeValidator().Validate
	v.FldValidators["challenge_type.policy_based_challenge"] = PolicyBasedChallengeValidator().Validate

	v.FldValidators["tls_parameters"] = ves_io_schema.DownstreamTlsParamsTypeValidator().Validate

	v.FldValidators["buffer_policy"] = ves_io_schema.BufferConfigTypeValidator().Validate

	v.FldValidators["cors_policy"] = ves_io_schema.CorsPolicyValidator().Validate

	v.FldValidators["waf_type"] = ves_io_schema.WafTypeValidator().Validate

	v.FldValidators["dynamic_reverse_proxy"] = DynamicReverseProxyTypeValidator().Validate

	v.FldValidators["compression_params"] = CompressionTypeValidator().Validate

	v.FldValidators["retry_policy"] = ves_io_schema.RetryPolicyTypeValidator().Validate

	v.FldValidators["temporary_user_blocking"] = TemporaryUserBlockingTypeValidator().Validate

	v.FldValidators["tls_intercept"] = ves_io_schema.TlsInterceptionTypeValidator().Validate

	v.FldValidators["dns_info"] = ves_io_schema_virtual_host_dns_info.DnsInfoValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *JavaScriptConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JavaScriptConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JavaScriptConfigType) DeepCopy() *JavaScriptConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JavaScriptConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JavaScriptConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JavaScriptConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JavaScriptConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateJavaScriptConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJavaScriptConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JavaScriptConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JavaScriptConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_prefix"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_prefix"))
		if err := fv(ctx, m.GetCachePrefix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_script_url"]; exists {

		vOpts := append(opts, db.WithValidateField("custom_script_url"))
		if err := fv(ctx, m.GetCustomScriptUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["script_config"]; exists {

		vOpts := append(opts, db.WithValidateField("script_config"))
		if err := fv(ctx, m.GetScriptConfig(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJavaScriptConfigTypeValidator = func() *ValidateJavaScriptConfigType {
	v := &ValidateJavaScriptConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func JavaScriptConfigTypeValidator() db.Validator {
	return DefaultJavaScriptConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *JavascriptChallengeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JavascriptChallengeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JavascriptChallengeType) DeepCopy() *JavascriptChallengeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JavascriptChallengeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JavascriptChallengeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JavascriptChallengeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JavascriptChallengeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateJavascriptChallengeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJavascriptChallengeType) JsScriptDelayValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for js_script_delay")
	}

	return validatorFn, nil
}

func (v *ValidateJavascriptChallengeType) CookieExpiryValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cookie_expiry")
	}

	return validatorFn, nil
}

func (v *ValidateJavascriptChallengeType) CustomPageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for custom_page")
	}

	return validatorFn, nil
}

func (v *ValidateJavascriptChallengeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JavascriptChallengeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JavascriptChallengeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cookie_expiry"]; exists {

		vOpts := append(opts, db.WithValidateField("cookie_expiry"))
		if err := fv(ctx, m.GetCookieExpiry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_page"]; exists {

		vOpts := append(opts, db.WithValidateField("custom_page"))
		if err := fv(ctx, m.GetCustomPage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["js_script_delay"]; exists {

		vOpts := append(opts, db.WithValidateField("js_script_delay"))
		if err := fv(ctx, m.GetJsScriptDelay(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJavascriptChallengeTypeValidator = func() *ValidateJavascriptChallengeType {
	v := &ValidateJavascriptChallengeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhJsScriptDelay := v.JsScriptDelayValidationRuleHandler
	rulesJsScriptDelay := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1000",
		"ves.io.schema.rules.uint32.lte": "60000",
	}
	vFn, err = vrhJsScriptDelay(rulesJsScriptDelay)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavascriptChallengeType.js_script_delay: %s", err)
		panic(errMsg)
	}
	v.FldValidators["js_script_delay"] = vFn

	vrhCookieExpiry := v.CookieExpiryValidationRuleHandler
	rulesCookieExpiry := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "86400",
	}
	vFn, err = vrhCookieExpiry(rulesCookieExpiry)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavascriptChallengeType.cookie_expiry: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookie_expiry"] = vFn

	vrhCustomPage := v.CustomPageValidationRuleHandler
	rulesCustomPage := map[string]string{
		"ves.io.schema.rules.string.max_len": "16384",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFn, err = vrhCustomPage(rulesCustomPage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavascriptChallengeType.custom_page: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_page"] = vFn

	return v
}()

func JavascriptChallengeTypeValidator() db.Validator {
	return DefaultJavascriptChallengeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PolicyBasedChallenge) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PolicyBasedChallenge) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PolicyBasedChallenge) DeepCopy() *PolicyBasedChallenge {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PolicyBasedChallenge{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PolicyBasedChallenge) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PolicyBasedChallenge) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PolicyBasedChallengeValidator().Validate(ctx, m, opts...)
}

func (m *PolicyBasedChallenge) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetMaliciousUserMitigationDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *PolicyBasedChallenge) GetMaliciousUserMitigationDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetMaliciousUserMitigation() {
		if ref == nil {
			return nil, fmt.Errorf("PolicyBasedChallenge.malicious_user_mitigation[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "malicious_user_mitigation.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "malicious_user_mitigation",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetMaliciousUserMitigationDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *PolicyBasedChallenge) GetMaliciousUserMitigationDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "malicious_user_mitigation.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: malicious_user_mitigation")
	}
	for _, ref := range m.GetMaliciousUserMitigation() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidatePolicyBasedChallenge struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePolicyBasedChallenge) ChallengeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for challenge_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePolicyBasedChallenge) MaliciousUserMitigationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for malicious_user_mitigation")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated malicious_user_mitigation")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items malicious_user_mitigation")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePolicyBasedChallenge) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PolicyBasedChallenge)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PolicyBasedChallenge got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["captcha_challenge"]; exists {

		vOpts := append(opts, db.WithValidateField("captcha_challenge"))
		if err := fv(ctx, m.GetCaptchaChallenge(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["challenge_choice"]; exists {
		val := m.GetChallengeChoice()
		vOpts := append(opts,
			db.WithValidateField("challenge_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChallengeChoice().(type) {
	case *PolicyBasedChallenge_NoChallenge:
		if fv, exists := v.FldValidators["challenge_choice.no_challenge"]; exists {
			val := m.GetChallengeChoice().(*PolicyBasedChallenge_NoChallenge).NoChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_choice"),
				db.WithValidateField("no_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PolicyBasedChallenge_AlwaysEnableJsChallenge:
		if fv, exists := v.FldValidators["challenge_choice.always_enable_js_challenge"]; exists {
			val := m.GetChallengeChoice().(*PolicyBasedChallenge_AlwaysEnableJsChallenge).AlwaysEnableJsChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_choice"),
				db.WithValidateField("always_enable_js_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PolicyBasedChallenge_AlwaysEnableCaptchaChallenge:
		if fv, exists := v.FldValidators["challenge_choice.always_enable_captcha_challenge"]; exists {
			val := m.GetChallengeChoice().(*PolicyBasedChallenge_AlwaysEnableCaptchaChallenge).AlwaysEnableCaptchaChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_choice"),
				db.WithValidateField("always_enable_captcha_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["js_challenge"]; exists {

		vOpts := append(opts, db.WithValidateField("js_challenge"))
		if err := fv(ctx, m.GetJsChallenge(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["malicious_user_mitigation"]; exists {
		vOpts := append(opts, db.WithValidateField("malicious_user_mitigation"))
		if err := fv(ctx, m.GetMaliciousUserMitigation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["temporary_user_blocking"]; exists {

		vOpts := append(opts, db.WithValidateField("temporary_user_blocking"))
		if err := fv(ctx, m.GetTemporaryUserBlocking(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPolicyBasedChallengeValidator = func() *ValidatePolicyBasedChallenge {
	v := &ValidatePolicyBasedChallenge{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChallengeChoice := v.ChallengeChoiceValidationRuleHandler
	rulesChallengeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChallengeChoice(rulesChallengeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PolicyBasedChallenge.challenge_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["challenge_choice"] = vFn

	vrhMaliciousUserMitigation := v.MaliciousUserMitigationValidationRuleHandler
	rulesMaliciousUserMitigation := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhMaliciousUserMitigation(rulesMaliciousUserMitigation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PolicyBasedChallenge.malicious_user_mitigation: %s", err)
		panic(errMsg)
	}
	v.FldValidators["malicious_user_mitigation"] = vFn

	v.FldValidators["js_challenge"] = JavascriptChallengeTypeValidator().Validate

	v.FldValidators["captcha_challenge"] = CaptchaChallengeTypeValidator().Validate

	v.FldValidators["temporary_user_blocking"] = TemporaryUserBlockingTypeValidator().Validate

	return v
}()

func PolicyBasedChallengeValidator() db.Validator {
	return DefaultPolicyBasedChallengeValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ReplaceSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetTlsParameters().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.tls_parameters")
	}

	if err := m.GetAuthentication().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.authentication")
	}

	return nil
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAdvertisePoliciesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetAuthenticationChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDynamicReverseProxyDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterAllowedPrefixesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRoutesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetUserIdentificationDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWafTypeDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *ReplaceSpecType) GetAdvertisePoliciesDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetAdvertisePolicies() {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.advertise_policies[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "advertise_policy.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "advertise_policies",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetAdvertisePoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetAdvertisePoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "advertise_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: advertise_policy")
	}
	for _, ref := range m.GetAdvertisePolicies() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetAuthenticationChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetAuthenticationChoice() == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetAuthenticationChoice().(type) {
	case *ReplaceSpecType_NoAuthentication:

	case *ReplaceSpecType_Authentication:
		odrInfos, err = m.GetAuthentication().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "authentication." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetDynamicReverseProxyDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetDynamicReverseProxy() == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.GetDynamicReverseProxy().GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "dynamic_reverse_proxy." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

func (m *ReplaceSpecType) GetRateLimiterDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetRateLimiter() {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.rate_limiter[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "rate_limiter.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetRateLimiterDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetRateLimiterDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "rate_limiter.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: rate_limiter")
	}
	for _, ref := range m.GetRateLimiter() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *ReplaceSpecType) GetRateLimiterAllowedPrefixesDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetRateLimiterAllowedPrefixes() {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.rate_limiter_allowed_prefixes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "ip_prefix_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter_allowed_prefixes",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetRateLimiterAllowedPrefixesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetRateLimiterAllowedPrefixesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "ip_prefix_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: ip_prefix_set")
	}
	for _, ref := range m.GetRateLimiterAllowedPrefixes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *ReplaceSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetRoutes() {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.routes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "route.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "routes",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetRoutesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetRoutesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "route.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: route")
	}
	for _, ref := range m.GetRoutes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *ReplaceSpecType) GetUserIdentificationDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetUserIdentification() {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.user_identification[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "user_identification.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "user_identification",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetUserIdentificationDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetUserIdentificationDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "user_identification.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: user_identification")
	}
	for _, ref := range m.GetUserIdentification() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetWafTypeDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetWafType() == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.GetWafType().GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "waf_type." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) ChallengeTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for challenge_type")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ServerHeaderChoiceServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_name")
	}
	return oValidatorFn_ServerName, nil
}
func (v *ValidateReplaceSpecType) ServerHeaderChoiceAppendServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_AppendServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for append_server_name")
	}
	return oValidatorFn_AppendServerName, nil
}

func (v *ValidateReplaceSpecType) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) RequestHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ResponseHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ResponseHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) RequestHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) CustomErrorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapUint32KeyRules(rules)
	itemKeyFn, err := db.NewUint32ValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for custom_errors")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for custom_errors")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[uint32]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for custom_errors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[uint32]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ uint32 ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map custom_errors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items custom_errors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) MaxRequestHeaderSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_request_header_size")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) UserIdentificationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for user_identification")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated user_identification")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items user_identification")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) RateLimiterValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) RateLimiterAllowedPrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter_allowed_prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter_allowed_prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_location"]; exists {

		vOpts := append(opts, db.WithValidateField("add_location"))
		if err := fv(ctx, m.GetAddLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["advertise_policies"]; exists {

		vOpts := append(opts, db.WithValidateField("advertise_policies"))
		for idx, item := range m.GetAdvertisePolicies() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetAuthenticationChoice().(type) {
	case *ReplaceSpecType_NoAuthentication:
		if fv, exists := v.FldValidators["authentication_choice.no_authentication"]; exists {
			val := m.GetAuthenticationChoice().(*ReplaceSpecType_NoAuthentication).NoAuthentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("no_authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Authentication:
		if fv, exists := v.FldValidators["authentication_choice.authentication"]; exists {
			val := m.GetAuthenticationChoice().(*ReplaceSpecType_Authentication).Authentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["buffer_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("buffer_policy"))
		if err := fv(ctx, m.GetBufferPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["challenge_type"]; exists {
		val := m.GetChallengeType()
		vOpts := append(opts,
			db.WithValidateField("challenge_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChallengeType().(type) {
	case *ReplaceSpecType_JsChallenge:
		if fv, exists := v.FldValidators["challenge_type.js_challenge"]; exists {
			val := m.GetChallengeType().(*ReplaceSpecType_JsChallenge).JsChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("js_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_CaptchaChallenge:
		if fv, exists := v.FldValidators["challenge_type.captcha_challenge"]; exists {
			val := m.GetChallengeType().(*ReplaceSpecType_CaptchaChallenge).CaptchaChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("captcha_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_NoChallenge:
		if fv, exists := v.FldValidators["challenge_type.no_challenge"]; exists {
			val := m.GetChallengeType().(*ReplaceSpecType_NoChallenge).NoChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("no_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["compression_params"]; exists {

		vOpts := append(opts, db.WithValidateField("compression_params"))
		if err := fv(ctx, m.GetCompressionParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cors_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("cors_policy"))
		if err := fv(ctx, m.GetCorsPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_errors"]; exists {
		vOpts := append(opts, db.WithValidateField("custom_errors"))
		if err := fv(ctx, m.GetCustomErrors(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_default_error_pages"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_default_error_pages"))
		if err := fv(ctx, m.GetDisableDefaultErrorPages(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_dns_resolve"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_dns_resolve"))
		if err := fv(ctx, m.GetDisableDnsResolve(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dynamic_reverse_proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("dynamic_reverse_proxy"))
		if err := fv(ctx, m.GetDynamicReverseProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("idle_timeout"))
		if err := fv(ctx, m.GetIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_request_header_size"]; exists {

		vOpts := append(opts, db.WithValidateField("max_request_header_size"))
		if err := fv(ctx, m.GetMaxRequestHeaderSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("proxy"))
		if err := fv(ctx, m.GetProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter"))
		if err := fv(ctx, m.GetRateLimiter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter_allowed_prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter_allowed_prefixes"))
		if err := fv(ctx, m.GetRateLimiterAllowedPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_add"))
		if err := fv(ctx, m.GetRequestHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_remove"))
		if err := fv(ctx, m.GetRequestHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_add"))
		if err := fv(ctx, m.GetResponseHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_remove"))
		if err := fv(ctx, m.GetResponseHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["retry_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("retry_policy"))
		if err := fv(ctx, m.GetRetryPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetServerHeaderChoice().(type) {
	case *ReplaceSpecType_DefaultHeader:
		if fv, exists := v.FldValidators["server_header_choice.default_header"]; exists {
			val := m.GetServerHeaderChoice().(*ReplaceSpecType_DefaultHeader).DefaultHeader
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("default_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_ServerName:
		if fv, exists := v.FldValidators["server_header_choice.server_name"]; exists {
			val := m.GetServerHeaderChoice().(*ReplaceSpecType_ServerName).ServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_AppendServerName:
		if fv, exists := v.FldValidators["server_header_choice.append_server_name"]; exists {
			val := m.GetServerHeaderChoice().(*ReplaceSpecType_AppendServerName).AppendServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("append_server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_PassThrough:
		if fv, exists := v.FldValidators["server_header_choice.pass_through"]; exists {
			val := m.GetServerHeaderChoice().(*ReplaceSpecType_PassThrough).PassThrough
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("pass_through"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["temporary_user_blocking"]; exists {

		vOpts := append(opts, db.WithValidateField("temporary_user_blocking"))
		if err := fv(ctx, m.GetTemporaryUserBlocking(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_parameters"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_parameters"))
		if err := fv(ctx, m.GetTlsParameters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_identification"]; exists {
		vOpts := append(opts, db.WithValidateField("user_identification"))
		if err := fv(ctx, m.GetUserIdentification(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["waf_type"]; exists {

		vOpts := append(opts, db.WithValidateField("waf_type"))
		if err := fv(ctx, m.GetWafType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChallengeType := v.ChallengeTypeValidationRuleHandler
	rulesChallengeType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChallengeType(rulesChallengeType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.challenge_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["challenge_type"] = vFn

	vrhServerHeaderChoiceServerName := v.ServerHeaderChoiceServerNameValidationRuleHandler
	rulesServerHeaderChoiceServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.server_name"], err = vrhServerHeaderChoiceServerName(rulesServerHeaderChoiceServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ReplaceSpecType.server_header_choice_server_name: %s", err)
		panic(errMsg)
	}
	vrhServerHeaderChoiceAppendServerName := v.ServerHeaderChoiceAppendServerNameValidationRuleHandler
	rulesServerHeaderChoiceAppendServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.append_server_name"], err = vrhServerHeaderChoiceAppendServerName(rulesServerHeaderChoiceAppendServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ReplaceSpecType.server_header_choice_append_server_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["server_header_choice.server_name"] = vFnMap["server_header_choice.server_name"]
	v.FldValidators["server_header_choice.append_server_name"] = vFnMap["server_header_choice.append_server_name"]

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.repeated.items.string.vh_domain": "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "128",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	vrhRequestHeadersToAdd := v.RequestHeadersToAddValidationRuleHandler
	rulesRequestHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToAdd(rulesRequestHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.request_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_add"] = vFn

	vrhResponseHeadersToAdd := v.ResponseHeadersToAddValidationRuleHandler
	rulesResponseHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToAdd(rulesResponseHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.response_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_add"] = vFn

	vrhResponseHeadersToRemove := v.ResponseHeadersToRemoveValidationRuleHandler
	rulesResponseHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToRemove(rulesResponseHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.response_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_remove"] = vFn

	vrhRequestHeadersToRemove := v.RequestHeadersToRemoveValidationRuleHandler
	rulesRequestHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToRemove(rulesRequestHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.request_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_remove"] = vFn

	vrhCustomErrors := v.CustomErrorsValidationRuleHandler
	rulesCustomErrors := map[string]string{
		"ves.io.schema.rules.map.keys.uint32.gte":       "3",
		"ves.io.schema.rules.map.keys.uint32.lte":       "599",
		"ves.io.schema.rules.map.max_pairs":             "16",
		"ves.io.schema.rules.map.values.string.max_len": "16384",
		"ves.io.schema.rules.map.values.string.uri_ref": "true",
	}
	vFn, err = vrhCustomErrors(rulesCustomErrors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.custom_errors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_errors"] = vFn

	vrhMaxRequestHeaderSize := v.MaxRequestHeaderSizeValidationRuleHandler
	rulesMaxRequestHeaderSize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "96",
	}
	vFn, err = vrhMaxRequestHeaderSize(rulesMaxRequestHeaderSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.max_request_header_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_request_header_size"] = vFn

	vrhUserIdentification := v.UserIdentificationValidationRuleHandler
	rulesUserIdentification := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhUserIdentification(rulesUserIdentification)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.user_identification: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user_identification"] = vFn

	vrhRateLimiter := v.RateLimiterValidationRuleHandler
	rulesRateLimiter := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRateLimiter(rulesRateLimiter)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.rate_limiter: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter"] = vFn

	vrhRateLimiterAllowedPrefixes := v.RateLimiterAllowedPrefixesValidationRuleHandler
	rulesRateLimiterAllowedPrefixes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhRateLimiterAllowedPrefixes(rulesRateLimiterAllowedPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.rate_limiter_allowed_prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter_allowed_prefixes"] = vFn

	v.FldValidators["authentication_choice.authentication"] = AuthenticationDetailsValidator().Validate

	v.FldValidators["challenge_type.js_challenge"] = JavascriptChallengeTypeValidator().Validate
	v.FldValidators["challenge_type.captcha_challenge"] = CaptchaChallengeTypeValidator().Validate

	v.FldValidators["tls_parameters"] = ves_io_schema.DownstreamTlsParamsTypeValidator().Validate

	v.FldValidators["buffer_policy"] = ves_io_schema.BufferConfigTypeValidator().Validate

	v.FldValidators["cors_policy"] = ves_io_schema.CorsPolicyValidator().Validate

	v.FldValidators["waf_type"] = ves_io_schema.WafTypeValidator().Validate

	v.FldValidators["dynamic_reverse_proxy"] = DynamicReverseProxyTypeValidator().Validate

	v.FldValidators["compression_params"] = CompressionTypeValidator().Validate

	v.FldValidators["retry_policy"] = ves_io_schema.RetryPolicyTypeValidator().Validate

	v.FldValidators["temporary_user_blocking"] = TemporaryUserBlockingTypeValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TemporaryUserBlockingType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TemporaryUserBlockingType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TemporaryUserBlockingType) DeepCopy() *TemporaryUserBlockingType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TemporaryUserBlockingType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TemporaryUserBlockingType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TemporaryUserBlockingType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TemporaryUserBlockingTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTemporaryUserBlockingType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTemporaryUserBlockingType) CustomPageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for custom_page")
	}

	return validatorFn, nil
}

func (v *ValidateTemporaryUserBlockingType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TemporaryUserBlockingType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TemporaryUserBlockingType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["custom_page"]; exists {

		vOpts := append(opts, db.WithValidateField("custom_page"))
		if err := fv(ctx, m.GetCustomPage(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTemporaryUserBlockingTypeValidator = func() *ValidateTemporaryUserBlockingType {
	v := &ValidateTemporaryUserBlockingType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCustomPage := v.CustomPageValidationRuleHandler
	rulesCustomPage := map[string]string{
		"ves.io.schema.rules.string.max_len": "16384",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFn, err = vrhCustomPage(rulesCustomPage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TemporaryUserBlockingType.custom_page: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_page"] = vFn

	return v
}()

func TemporaryUserBlockingTypeValidator() db.Validator {
	return DefaultTemporaryUserBlockingTypeValidator
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetAuthenticationChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.AuthenticationChoice.(type) {
	case nil:
		o.AuthenticationChoice = nil

	case *CreateSpecType_Authentication:
		o.AuthenticationChoice = &GlobalSpecType_Authentication{Authentication: of.Authentication}

	case *CreateSpecType_NoAuthentication:
		o.AuthenticationChoice = &GlobalSpecType_NoAuthentication{NoAuthentication: of.NoAuthentication}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetAuthenticationChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.AuthenticationChoice.(type) {
	case nil:
		r.AuthenticationChoice = nil

	case *GlobalSpecType_Authentication:
		r.AuthenticationChoice = &CreateSpecType_Authentication{Authentication: of.Authentication}

	case *GlobalSpecType_NoAuthentication:
		r.AuthenticationChoice = &CreateSpecType_NoAuthentication{NoAuthentication: of.NoAuthentication}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetChallengeTypeToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ChallengeType.(type) {
	case nil:
		o.ChallengeType = nil

	case *CreateSpecType_CaptchaChallenge:
		o.ChallengeType = &GlobalSpecType_CaptchaChallenge{CaptchaChallenge: of.CaptchaChallenge}

	case *CreateSpecType_JsChallenge:
		o.ChallengeType = &GlobalSpecType_JsChallenge{JsChallenge: of.JsChallenge}

	case *CreateSpecType_NoChallenge:
		o.ChallengeType = &GlobalSpecType_NoChallenge{NoChallenge: of.NoChallenge}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetChallengeTypeFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ChallengeType.(type) {
	case nil:
		r.ChallengeType = nil

	case *GlobalSpecType_CaptchaChallenge:
		r.ChallengeType = &CreateSpecType_CaptchaChallenge{CaptchaChallenge: of.CaptchaChallenge}

	case *GlobalSpecType_JsChallenge:
		r.ChallengeType = &CreateSpecType_JsChallenge{JsChallenge: of.JsChallenge}

	case *GlobalSpecType_NoChallenge:
		r.ChallengeType = &CreateSpecType_NoChallenge{NoChallenge: of.NoChallenge}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetServerHeaderChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ServerHeaderChoice.(type) {
	case nil:
		o.ServerHeaderChoice = nil

	case *CreateSpecType_AppendServerName:
		o.ServerHeaderChoice = &GlobalSpecType_AppendServerName{AppendServerName: of.AppendServerName}

	case *CreateSpecType_DefaultHeader:
		o.ServerHeaderChoice = &GlobalSpecType_DefaultHeader{DefaultHeader: of.DefaultHeader}

	case *CreateSpecType_PassThrough:
		o.ServerHeaderChoice = &GlobalSpecType_PassThrough{PassThrough: of.PassThrough}

	case *CreateSpecType_ServerName:
		o.ServerHeaderChoice = &GlobalSpecType_ServerName{ServerName: of.ServerName}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetServerHeaderChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ServerHeaderChoice.(type) {
	case nil:
		r.ServerHeaderChoice = nil

	case *GlobalSpecType_AppendServerName:
		r.ServerHeaderChoice = &CreateSpecType_AppendServerName{AppendServerName: of.AppendServerName}

	case *GlobalSpecType_DefaultHeader:
		r.ServerHeaderChoice = &CreateSpecType_DefaultHeader{DefaultHeader: of.DefaultHeader}

	case *GlobalSpecType_PassThrough:
		r.ServerHeaderChoice = &CreateSpecType_PassThrough{PassThrough: of.PassThrough}

	case *GlobalSpecType_ServerName:
		r.ServerHeaderChoice = &CreateSpecType_ServerName{ServerName: of.ServerName}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.AddLocation = f.GetAddLocation()
	m.AdvertisePolicies = f.GetAdvertisePolicies()
	m.GetAuthenticationChoiceFromGlobalSpecType(f)
	m.BufferPolicy = f.GetBufferPolicy()
	m.GetChallengeTypeFromGlobalSpecType(f)
	m.CompressionParams = f.GetCompressionParams()
	m.CorsPolicy = f.GetCorsPolicy()
	m.CustomErrors = f.GetCustomErrors()
	m.DisableDefaultErrorPages = f.GetDisableDefaultErrorPages()
	m.DisableDnsResolve = f.GetDisableDnsResolve()
	m.Domains = f.GetDomains()
	m.DynamicReverseProxy = f.GetDynamicReverseProxy()
	m.IdleTimeout = f.GetIdleTimeout()
	m.MaxRequestHeaderSize = f.GetMaxRequestHeaderSize()
	m.Proxy = f.GetProxy()
	m.RateLimiter = f.GetRateLimiter()
	m.RateLimiterAllowedPrefixes = f.GetRateLimiterAllowedPrefixes()
	m.RequestHeadersToAdd = f.GetRequestHeadersToAdd()
	m.RequestHeadersToRemove = f.GetRequestHeadersToRemove()
	m.ResponseHeadersToAdd = f.GetResponseHeadersToAdd()
	m.ResponseHeadersToRemove = f.GetResponseHeadersToRemove()
	m.RetryPolicy = f.GetRetryPolicy()
	m.Routes = f.GetRoutes()
	m.GetServerHeaderChoiceFromGlobalSpecType(f)
	m.TemporaryUserBlocking = f.GetTemporaryUserBlocking()
	m.TlsParameters = f.GetTlsParameters()
	m.UserIdentification = f.GetUserIdentification()
	m.WafType = f.GetWafType()
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	f.AddLocation = m1.AddLocation
	f.AdvertisePolicies = m1.AdvertisePolicies
	m1.SetAuthenticationChoiceToGlobalSpecType(f)
	f.BufferPolicy = m1.BufferPolicy
	m1.SetChallengeTypeToGlobalSpecType(f)
	f.CompressionParams = m1.CompressionParams
	f.CorsPolicy = m1.CorsPolicy
	f.CustomErrors = m1.CustomErrors
	f.DisableDefaultErrorPages = m1.DisableDefaultErrorPages
	f.DisableDnsResolve = m1.DisableDnsResolve
	f.Domains = m1.Domains
	f.DynamicReverseProxy = m1.DynamicReverseProxy
	f.IdleTimeout = m1.IdleTimeout
	f.MaxRequestHeaderSize = m1.MaxRequestHeaderSize
	f.Proxy = m1.Proxy
	f.RateLimiter = m1.RateLimiter
	f.RateLimiterAllowedPrefixes = m1.RateLimiterAllowedPrefixes
	f.RequestHeadersToAdd = m1.RequestHeadersToAdd
	f.RequestHeadersToRemove = m1.RequestHeadersToRemove
	f.ResponseHeadersToAdd = m1.ResponseHeadersToAdd
	f.ResponseHeadersToRemove = m1.ResponseHeadersToRemove
	f.RetryPolicy = m1.RetryPolicy
	f.Routes = m1.Routes
	m1.SetServerHeaderChoiceToGlobalSpecType(f)
	f.TemporaryUserBlocking = m1.TemporaryUserBlocking
	f.TlsParameters = m1.TlsParameters
	f.UserIdentification = m1.UserIdentification
	f.WafType = m1.WafType
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetAuthenticationChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.AuthenticationChoice.(type) {
	case nil:
		o.AuthenticationChoice = nil

	case *GetSpecType_Authentication:
		o.AuthenticationChoice = &GlobalSpecType_Authentication{Authentication: of.Authentication}

	case *GetSpecType_NoAuthentication:
		o.AuthenticationChoice = &GlobalSpecType_NoAuthentication{NoAuthentication: of.NoAuthentication}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetAuthenticationChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.AuthenticationChoice.(type) {
	case nil:
		r.AuthenticationChoice = nil

	case *GlobalSpecType_Authentication:
		r.AuthenticationChoice = &GetSpecType_Authentication{Authentication: of.Authentication}

	case *GlobalSpecType_NoAuthentication:
		r.AuthenticationChoice = &GetSpecType_NoAuthentication{NoAuthentication: of.NoAuthentication}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetChallengeTypeToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ChallengeType.(type) {
	case nil:
		o.ChallengeType = nil

	case *GetSpecType_CaptchaChallenge:
		o.ChallengeType = &GlobalSpecType_CaptchaChallenge{CaptchaChallenge: of.CaptchaChallenge}

	case *GetSpecType_JsChallenge:
		o.ChallengeType = &GlobalSpecType_JsChallenge{JsChallenge: of.JsChallenge}

	case *GetSpecType_NoChallenge:
		o.ChallengeType = &GlobalSpecType_NoChallenge{NoChallenge: of.NoChallenge}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetChallengeTypeFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ChallengeType.(type) {
	case nil:
		r.ChallengeType = nil

	case *GlobalSpecType_CaptchaChallenge:
		r.ChallengeType = &GetSpecType_CaptchaChallenge{CaptchaChallenge: of.CaptchaChallenge}

	case *GlobalSpecType_JsChallenge:
		r.ChallengeType = &GetSpecType_JsChallenge{JsChallenge: of.JsChallenge}

	case *GlobalSpecType_NoChallenge:
		r.ChallengeType = &GetSpecType_NoChallenge{NoChallenge: of.NoChallenge}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetServerHeaderChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ServerHeaderChoice.(type) {
	case nil:
		o.ServerHeaderChoice = nil

	case *GetSpecType_AppendServerName:
		o.ServerHeaderChoice = &GlobalSpecType_AppendServerName{AppendServerName: of.AppendServerName}

	case *GetSpecType_DefaultHeader:
		o.ServerHeaderChoice = &GlobalSpecType_DefaultHeader{DefaultHeader: of.DefaultHeader}

	case *GetSpecType_PassThrough:
		o.ServerHeaderChoice = &GlobalSpecType_PassThrough{PassThrough: of.PassThrough}

	case *GetSpecType_ServerName:
		o.ServerHeaderChoice = &GlobalSpecType_ServerName{ServerName: of.ServerName}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetServerHeaderChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ServerHeaderChoice.(type) {
	case nil:
		r.ServerHeaderChoice = nil

	case *GlobalSpecType_AppendServerName:
		r.ServerHeaderChoice = &GetSpecType_AppendServerName{AppendServerName: of.AppendServerName}

	case *GlobalSpecType_DefaultHeader:
		r.ServerHeaderChoice = &GetSpecType_DefaultHeader{DefaultHeader: of.DefaultHeader}

	case *GlobalSpecType_PassThrough:
		r.ServerHeaderChoice = &GetSpecType_PassThrough{PassThrough: of.PassThrough}

	case *GlobalSpecType_ServerName:
		r.ServerHeaderChoice = &GetSpecType_ServerName{ServerName: of.ServerName}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.AddLocation = f.GetAddLocation()
	m.AdvertisePolicies = f.GetAdvertisePolicies()
	m.GetAuthenticationChoiceFromGlobalSpecType(f)
	m.AutoCertInfo = f.GetAutoCertInfo()
	m.AutoCertState = f.GetAutoCertState()
	m.BufferPolicy = f.GetBufferPolicy()
	m.GetChallengeTypeFromGlobalSpecType(f)
	m.CompressionParams = f.GetCompressionParams()
	m.CorsPolicy = f.GetCorsPolicy()
	m.CustomErrors = f.GetCustomErrors()
	m.DisableDefaultErrorPages = f.GetDisableDefaultErrorPages()
	m.DisableDnsResolve = f.GetDisableDnsResolve()
	m.DnsInfo = f.GetDnsInfo()
	m.Domains = f.GetDomains()
	m.DynamicReverseProxy = f.GetDynamicReverseProxy()
	m.HostName = f.GetHostName()
	m.IdleTimeout = f.GetIdleTimeout()
	m.MaxRequestHeaderSize = f.GetMaxRequestHeaderSize()
	m.Proxy = f.GetProxy()
	m.RateLimiter = f.GetRateLimiter()
	m.RateLimiterAllowedPrefixes = f.GetRateLimiterAllowedPrefixes()
	m.RequestHeadersToAdd = f.GetRequestHeadersToAdd()
	m.RequestHeadersToRemove = f.GetRequestHeadersToRemove()
	m.ResponseHeadersToAdd = f.GetResponseHeadersToAdd()
	m.ResponseHeadersToRemove = f.GetResponseHeadersToRemove()
	m.RetryPolicy = f.GetRetryPolicy()
	m.Routes = f.GetRoutes()
	m.GetServerHeaderChoiceFromGlobalSpecType(f)
	m.State = f.GetState()
	m.TemporaryUserBlocking = f.GetTemporaryUserBlocking()
	m.TlsParameters = f.GetTlsParameters()
	m.Type = f.GetType()
	m.UserIdentification = f.GetUserIdentification()
	m.WafType = f.GetWafType()
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	f.AddLocation = m1.AddLocation
	f.AdvertisePolicies = m1.AdvertisePolicies
	m1.SetAuthenticationChoiceToGlobalSpecType(f)
	f.AutoCertInfo = m1.AutoCertInfo
	f.AutoCertState = m1.AutoCertState
	f.BufferPolicy = m1.BufferPolicy
	m1.SetChallengeTypeToGlobalSpecType(f)
	f.CompressionParams = m1.CompressionParams
	f.CorsPolicy = m1.CorsPolicy
	f.CustomErrors = m1.CustomErrors
	f.DisableDefaultErrorPages = m1.DisableDefaultErrorPages
	f.DisableDnsResolve = m1.DisableDnsResolve
	f.DnsInfo = m1.DnsInfo
	f.Domains = m1.Domains
	f.DynamicReverseProxy = m1.DynamicReverseProxy
	f.HostName = m1.HostName
	f.IdleTimeout = m1.IdleTimeout
	f.MaxRequestHeaderSize = m1.MaxRequestHeaderSize
	f.Proxy = m1.Proxy
	f.RateLimiter = m1.RateLimiter
	f.RateLimiterAllowedPrefixes = m1.RateLimiterAllowedPrefixes
	f.RequestHeadersToAdd = m1.RequestHeadersToAdd
	f.RequestHeadersToRemove = m1.RequestHeadersToRemove
	f.ResponseHeadersToAdd = m1.ResponseHeadersToAdd
	f.ResponseHeadersToRemove = m1.ResponseHeadersToRemove
	f.RetryPolicy = m1.RetryPolicy
	f.Routes = m1.Routes
	m1.SetServerHeaderChoiceToGlobalSpecType(f)
	f.State = m1.State
	f.TemporaryUserBlocking = m1.TemporaryUserBlocking
	f.TlsParameters = m1.TlsParameters
	f.Type = m1.Type
	f.UserIdentification = m1.UserIdentification
	f.WafType = m1.WafType
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetAuthenticationChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.AuthenticationChoice.(type) {
	case nil:
		o.AuthenticationChoice = nil

	case *ReplaceSpecType_Authentication:
		o.AuthenticationChoice = &GlobalSpecType_Authentication{Authentication: of.Authentication}

	case *ReplaceSpecType_NoAuthentication:
		o.AuthenticationChoice = &GlobalSpecType_NoAuthentication{NoAuthentication: of.NoAuthentication}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetAuthenticationChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.AuthenticationChoice.(type) {
	case nil:
		r.AuthenticationChoice = nil

	case *GlobalSpecType_Authentication:
		r.AuthenticationChoice = &ReplaceSpecType_Authentication{Authentication: of.Authentication}

	case *GlobalSpecType_NoAuthentication:
		r.AuthenticationChoice = &ReplaceSpecType_NoAuthentication{NoAuthentication: of.NoAuthentication}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetChallengeTypeToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ChallengeType.(type) {
	case nil:
		o.ChallengeType = nil

	case *ReplaceSpecType_CaptchaChallenge:
		o.ChallengeType = &GlobalSpecType_CaptchaChallenge{CaptchaChallenge: of.CaptchaChallenge}

	case *ReplaceSpecType_JsChallenge:
		o.ChallengeType = &GlobalSpecType_JsChallenge{JsChallenge: of.JsChallenge}

	case *ReplaceSpecType_NoChallenge:
		o.ChallengeType = &GlobalSpecType_NoChallenge{NoChallenge: of.NoChallenge}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetChallengeTypeFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ChallengeType.(type) {
	case nil:
		r.ChallengeType = nil

	case *GlobalSpecType_CaptchaChallenge:
		r.ChallengeType = &ReplaceSpecType_CaptchaChallenge{CaptchaChallenge: of.CaptchaChallenge}

	case *GlobalSpecType_JsChallenge:
		r.ChallengeType = &ReplaceSpecType_JsChallenge{JsChallenge: of.JsChallenge}

	case *GlobalSpecType_NoChallenge:
		r.ChallengeType = &ReplaceSpecType_NoChallenge{NoChallenge: of.NoChallenge}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetServerHeaderChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ServerHeaderChoice.(type) {
	case nil:
		o.ServerHeaderChoice = nil

	case *ReplaceSpecType_AppendServerName:
		o.ServerHeaderChoice = &GlobalSpecType_AppendServerName{AppendServerName: of.AppendServerName}

	case *ReplaceSpecType_DefaultHeader:
		o.ServerHeaderChoice = &GlobalSpecType_DefaultHeader{DefaultHeader: of.DefaultHeader}

	case *ReplaceSpecType_PassThrough:
		o.ServerHeaderChoice = &GlobalSpecType_PassThrough{PassThrough: of.PassThrough}

	case *ReplaceSpecType_ServerName:
		o.ServerHeaderChoice = &GlobalSpecType_ServerName{ServerName: of.ServerName}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetServerHeaderChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ServerHeaderChoice.(type) {
	case nil:
		r.ServerHeaderChoice = nil

	case *GlobalSpecType_AppendServerName:
		r.ServerHeaderChoice = &ReplaceSpecType_AppendServerName{AppendServerName: of.AppendServerName}

	case *GlobalSpecType_DefaultHeader:
		r.ServerHeaderChoice = &ReplaceSpecType_DefaultHeader{DefaultHeader: of.DefaultHeader}

	case *GlobalSpecType_PassThrough:
		r.ServerHeaderChoice = &ReplaceSpecType_PassThrough{PassThrough: of.PassThrough}

	case *GlobalSpecType_ServerName:
		r.ServerHeaderChoice = &ReplaceSpecType_ServerName{ServerName: of.ServerName}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.AddLocation = f.GetAddLocation()
	m.AdvertisePolicies = f.GetAdvertisePolicies()
	m.GetAuthenticationChoiceFromGlobalSpecType(f)
	m.BufferPolicy = f.GetBufferPolicy()
	m.GetChallengeTypeFromGlobalSpecType(f)
	m.CompressionParams = f.GetCompressionParams()
	m.CorsPolicy = f.GetCorsPolicy()
	m.CustomErrors = f.GetCustomErrors()
	m.DisableDefaultErrorPages = f.GetDisableDefaultErrorPages()
	m.DisableDnsResolve = f.GetDisableDnsResolve()
	m.Domains = f.GetDomains()
	m.DynamicReverseProxy = f.GetDynamicReverseProxy()
	m.IdleTimeout = f.GetIdleTimeout()
	m.MaxRequestHeaderSize = f.GetMaxRequestHeaderSize()
	m.Proxy = f.GetProxy()
	m.RateLimiter = f.GetRateLimiter()
	m.RateLimiterAllowedPrefixes = f.GetRateLimiterAllowedPrefixes()
	m.RequestHeadersToAdd = f.GetRequestHeadersToAdd()
	m.RequestHeadersToRemove = f.GetRequestHeadersToRemove()
	m.ResponseHeadersToAdd = f.GetResponseHeadersToAdd()
	m.ResponseHeadersToRemove = f.GetResponseHeadersToRemove()
	m.RetryPolicy = f.GetRetryPolicy()
	m.Routes = f.GetRoutes()
	m.GetServerHeaderChoiceFromGlobalSpecType(f)
	m.TemporaryUserBlocking = f.GetTemporaryUserBlocking()
	m.TlsParameters = f.GetTlsParameters()
	m.UserIdentification = f.GetUserIdentification()
	m.WafType = f.GetWafType()
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	f.AddLocation = m1.AddLocation
	f.AdvertisePolicies = m1.AdvertisePolicies
	m1.SetAuthenticationChoiceToGlobalSpecType(f)
	f.BufferPolicy = m1.BufferPolicy
	m1.SetChallengeTypeToGlobalSpecType(f)
	f.CompressionParams = m1.CompressionParams
	f.CorsPolicy = m1.CorsPolicy
	f.CustomErrors = m1.CustomErrors
	f.DisableDefaultErrorPages = m1.DisableDefaultErrorPages
	f.DisableDnsResolve = m1.DisableDnsResolve
	f.Domains = m1.Domains
	f.DynamicReverseProxy = m1.DynamicReverseProxy
	f.IdleTimeout = m1.IdleTimeout
	f.MaxRequestHeaderSize = m1.MaxRequestHeaderSize
	f.Proxy = m1.Proxy
	f.RateLimiter = m1.RateLimiter
	f.RateLimiterAllowedPrefixes = m1.RateLimiterAllowedPrefixes
	f.RequestHeadersToAdd = m1.RequestHeadersToAdd
	f.RequestHeadersToRemove = m1.RequestHeadersToRemove
	f.ResponseHeadersToAdd = m1.ResponseHeadersToAdd
	f.ResponseHeadersToRemove = m1.ResponseHeadersToRemove
	f.RetryPolicy = m1.RetryPolicy
	f.Routes = m1.Routes
	m1.SetServerHeaderChoiceToGlobalSpecType(f)
	f.TemporaryUserBlocking = m1.TemporaryUserBlocking
	f.TlsParameters = m1.TlsParameters
	f.UserIdentification = m1.UserIdentification
	f.WafType = m1.WafType
}
