// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package virtual_host

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_authentication "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/authentication"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	ves_io_schema_virtual_host_dns_info "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/virtual_host_dns_info"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *ApiSpec) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ApiSpec) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ApiSpec) DeepCopy() *ApiSpec {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ApiSpec{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ApiSpec) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ApiSpec) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ApiSpecValidator().Validate(ctx, m, opts...)
}

func (m *ApiSpec) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetApiDefinitionDRefInfo()

}

func (m *ApiSpec) GetApiDefinitionDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetApiDefinition()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("api_definition.Object")
	dri := db.DRefInfo{
		RefdType:   "api_definition.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "api_definition",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetApiDefinitionDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ApiSpec) GetApiDefinitionDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "api_definition.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: api_definition")
	}

	vref := m.GetApiDefinition()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "api_definition.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateApiSpec struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateApiSpec) OpenApiValidationChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for open_api_validation_choice")
	}
	return validatorFn, nil
}

func (v *ValidateApiSpec) ApiDefinitionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for api_definition")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateApiSpec) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ApiSpec)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ApiSpec got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_definition"]; exists {

		vOpts := append(opts, db.WithValidateField("api_definition"))
		if err := fv(ctx, m.GetApiDefinition(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["open_api_validation_choice"]; exists {
		val := m.GetOpenApiValidationChoice()
		vOpts := append(opts,
			db.WithValidateField("open_api_validation_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetOpenApiValidationChoice().(type) {
	case *ApiSpec_DisableOpenApiValidation:
		if fv, exists := v.FldValidators["open_api_validation_choice.disable_open_api_validation"]; exists {
			val := m.GetOpenApiValidationChoice().(*ApiSpec_DisableOpenApiValidation).DisableOpenApiValidation
			vOpts := append(opts,
				db.WithValidateField("open_api_validation_choice"),
				db.WithValidateField("disable_open_api_validation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ApiSpec_EnableOpenApiValidation:
		if fv, exists := v.FldValidators["open_api_validation_choice.enable_open_api_validation"]; exists {
			val := m.GetOpenApiValidationChoice().(*ApiSpec_EnableOpenApiValidation).EnableOpenApiValidation
			vOpts := append(opts,
				db.WithValidateField("open_api_validation_choice"),
				db.WithValidateField("enable_open_api_validation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultApiSpecValidator = func() *ValidateApiSpec {
	v := &ValidateApiSpec{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOpenApiValidationChoice := v.OpenApiValidationChoiceValidationRuleHandler
	rulesOpenApiValidationChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhOpenApiValidationChoice(rulesOpenApiValidationChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiSpec.open_api_validation_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["open_api_validation_choice"] = vFn

	vrhApiDefinition := v.ApiDefinitionValidationRuleHandler
	rulesApiDefinition := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhApiDefinition(rulesApiDefinition)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiSpec.api_definition: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_definition"] = vFn

	return v
}()

func ApiSpecValidator() db.Validator {
	return DefaultApiSpecValidator
}

// augmented methods on protoc/std generated struct

func (m *AuthenticationDetails) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AuthenticationDetails) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AuthenticationDetails) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetCookieParams().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AuthenticationDetails.cookie_params")
	}

	return nil
}

func (m *AuthenticationDetails) DeepCopy() *AuthenticationDetails {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AuthenticationDetails{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AuthenticationDetails) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AuthenticationDetails) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AuthenticationDetailsValidator().Validate(ctx, m, opts...)
}

func (m *AuthenticationDetails) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAuthConfigDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAuthConfigDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetCookieParamsChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetCookieParamsChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *AuthenticationDetails) GetAuthConfigDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAuthConfig()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("AuthenticationDetails.auth_config[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "authentication.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "auth_config",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAuthConfigDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *AuthenticationDetails) GetAuthConfigDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "authentication.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: authentication")
	}
	for _, ref := range m.GetAuthConfig() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *AuthenticationDetails) GetCookieParamsChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetCookieParamsChoice() == nil {
		return nil, nil
	}
	switch m.GetCookieParamsChoice().(type) {
	case *AuthenticationDetails_UseAuthObjectConfig:

		return nil, nil

	case *AuthenticationDetails_CookieParams:

		drInfos, err := m.GetCookieParams().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetCookieParams().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "cookie_params." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateAuthenticationDetails struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAuthenticationDetails) RedirectUrlChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for redirect_url_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAuthenticationDetails) RedirectUrlChoiceRedirectUrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_RedirectUrl, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for redirect_url")
	}
	return oValidatorFn_RedirectUrl, nil
}

func (v *ValidateAuthenticationDetails) AuthConfigValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for auth_config")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for auth_config")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated auth_config")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items auth_config")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAuthenticationDetails) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AuthenticationDetails)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AuthenticationDetails got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["auth_config"]; exists {
		vOpts := append(opts, db.WithValidateField("auth_config"))
		if err := fv(ctx, m.GetAuthConfig(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetCookieParamsChoice().(type) {
	case *AuthenticationDetails_UseAuthObjectConfig:
		if fv, exists := v.FldValidators["cookie_params_choice.use_auth_object_config"]; exists {
			val := m.GetCookieParamsChoice().(*AuthenticationDetails_UseAuthObjectConfig).UseAuthObjectConfig
			vOpts := append(opts,
				db.WithValidateField("cookie_params_choice"),
				db.WithValidateField("use_auth_object_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AuthenticationDetails_CookieParams:
		if fv, exists := v.FldValidators["cookie_params_choice.cookie_params"]; exists {
			val := m.GetCookieParamsChoice().(*AuthenticationDetails_CookieParams).CookieParams
			vOpts := append(opts,
				db.WithValidateField("cookie_params_choice"),
				db.WithValidateField("cookie_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["redirect_url_choice"]; exists {
		val := m.GetRedirectUrlChoice()
		vOpts := append(opts,
			db.WithValidateField("redirect_url_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetRedirectUrlChoice().(type) {
	case *AuthenticationDetails_RedirectUrl:
		if fv, exists := v.FldValidators["redirect_url_choice.redirect_url"]; exists {
			val := m.GetRedirectUrlChoice().(*AuthenticationDetails_RedirectUrl).RedirectUrl
			vOpts := append(opts,
				db.WithValidateField("redirect_url_choice"),
				db.WithValidateField("redirect_url"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AuthenticationDetails_RedirectDynamic:
		if fv, exists := v.FldValidators["redirect_url_choice.redirect_dynamic"]; exists {
			val := m.GetRedirectUrlChoice().(*AuthenticationDetails_RedirectDynamic).RedirectDynamic
			vOpts := append(opts,
				db.WithValidateField("redirect_url_choice"),
				db.WithValidateField("redirect_dynamic"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAuthenticationDetailsValidator = func() *ValidateAuthenticationDetails {
	v := &ValidateAuthenticationDetails{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRedirectUrlChoice := v.RedirectUrlChoiceValidationRuleHandler
	rulesRedirectUrlChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhRedirectUrlChoice(rulesRedirectUrlChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AuthenticationDetails.redirect_url_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["redirect_url_choice"] = vFn

	vrhRedirectUrlChoiceRedirectUrl := v.RedirectUrlChoiceRedirectUrlValidationRuleHandler
	rulesRedirectUrlChoiceRedirectUrl := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
		"ves.io.schema.rules.string.min_len": "1",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFnMap["redirect_url_choice.redirect_url"], err = vrhRedirectUrlChoiceRedirectUrl(rulesRedirectUrlChoiceRedirectUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AuthenticationDetails.redirect_url_choice_redirect_url: %s", err)
		panic(errMsg)
	}

	v.FldValidators["redirect_url_choice.redirect_url"] = vFnMap["redirect_url_choice.redirect_url"]

	vrhAuthConfig := v.AuthConfigValidationRuleHandler
	rulesAuthConfig := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhAuthConfig(rulesAuthConfig)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AuthenticationDetails.auth_config: %s", err)
		panic(errMsg)
	}
	v.FldValidators["auth_config"] = vFn

	v.FldValidators["cookie_params_choice.cookie_params"] = ves_io_schema_authentication.CookieParamsValidator().Validate

	return v
}()

func AuthenticationDetailsValidator() db.Validator {
	return DefaultAuthenticationDetailsValidator
}

// augmented methods on protoc/std generated struct

func (m *AutoCertInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AutoCertInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AutoCertInfoType) DeepCopy() *AutoCertInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AutoCertInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AutoCertInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AutoCertInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AutoCertInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAutoCertInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAutoCertInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AutoCertInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AutoCertInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["auto_cert_expiry"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_expiry"))
		if err := fv(ctx, m.GetAutoCertExpiry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_issuer"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_issuer"))
		if err := fv(ctx, m.GetAutoCertIssuer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_state"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_state"))
		if err := fv(ctx, m.GetAutoCertState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_subject"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_subject"))
		if err := fv(ctx, m.GetAutoCertSubject(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_records"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_records"))
		for idx, item := range m.GetDnsRecords() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["state_start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("state_start_time"))
		if err := fv(ctx, m.GetStateStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAutoCertInfoTypeValidator = func() *ValidateAutoCertInfoType {
	v := &ValidateAutoCertInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AutoCertInfoTypeValidator() db.Validator {
	return DefaultAutoCertInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNOriginServerPublicIP) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNOriginServerPublicIP) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNOriginServerPublicIP) DeepCopy() *CDNOriginServerPublicIP {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNOriginServerPublicIP{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNOriginServerPublicIP) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNOriginServerPublicIP) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNOriginServerPublicIPValidator().Validate(ctx, m, opts...)
}

type ValidateCDNOriginServerPublicIP struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNOriginServerPublicIP) PublicIpChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for public_ip_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCDNOriginServerPublicIP) PublicIpChoiceIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Ip, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip")
	}
	return oValidatorFn_Ip, nil
}
func (v *ValidateCDNOriginServerPublicIP) PublicIpChoiceIpv6ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Ipv6, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ipv6")
	}
	return oValidatorFn_Ipv6, nil
}

func (v *ValidateCDNOriginServerPublicIP) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNOriginServerPublicIP)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNOriginServerPublicIP got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["public_ip_choice"]; exists {
		val := m.GetPublicIpChoice()
		vOpts := append(opts,
			db.WithValidateField("public_ip_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPublicIpChoice().(type) {
	case *CDNOriginServerPublicIP_Ip:
		if fv, exists := v.FldValidators["public_ip_choice.ip"]; exists {
			val := m.GetPublicIpChoice().(*CDNOriginServerPublicIP_Ip).Ip
			vOpts := append(opts,
				db.WithValidateField("public_ip_choice"),
				db.WithValidateField("ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CDNOriginServerPublicIP_Ipv6:
		if fv, exists := v.FldValidators["public_ip_choice.ipv6"]; exists {
			val := m.GetPublicIpChoice().(*CDNOriginServerPublicIP_Ipv6).Ipv6
			vOpts := append(opts,
				db.WithValidateField("public_ip_choice"),
				db.WithValidateField("ipv6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNOriginServerPublicIPValidator = func() *ValidateCDNOriginServerPublicIP {
	v := &ValidateCDNOriginServerPublicIP{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPublicIpChoice := v.PublicIpChoiceValidationRuleHandler
	rulesPublicIpChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPublicIpChoice(rulesPublicIpChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNOriginServerPublicIP.public_ip_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["public_ip_choice"] = vFn

	vrhPublicIpChoiceIp := v.PublicIpChoiceIpValidationRuleHandler
	rulesPublicIpChoiceIp := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFnMap["public_ip_choice.ip"], err = vrhPublicIpChoiceIp(rulesPublicIpChoiceIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CDNOriginServerPublicIP.public_ip_choice_ip: %s", err)
		panic(errMsg)
	}
	vrhPublicIpChoiceIpv6 := v.PublicIpChoiceIpv6ValidationRuleHandler
	rulesPublicIpChoiceIpv6 := map[string]string{
		"ves.io.schema.rules.string.ipv6": "true",
	}
	vFnMap["public_ip_choice.ipv6"], err = vrhPublicIpChoiceIpv6(rulesPublicIpChoiceIpv6)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CDNOriginServerPublicIP.public_ip_choice_ipv6: %s", err)
		panic(errMsg)
	}

	v.FldValidators["public_ip_choice.ip"] = vFnMap["public_ip_choice.ip"]
	v.FldValidators["public_ip_choice.ipv6"] = vFnMap["public_ip_choice.ipv6"]

	return v
}()

func CDNOriginServerPublicIPValidator() db.Validator {
	return DefaultCDNOriginServerPublicIPValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNOriginServerPublicName) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNOriginServerPublicName) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNOriginServerPublicName) DeepCopy() *CDNOriginServerPublicName {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNOriginServerPublicName{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNOriginServerPublicName) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNOriginServerPublicName) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNOriginServerPublicNameValidator().Validate(ctx, m, opts...)
}

type ValidateCDNOriginServerPublicName struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNOriginServerPublicName) DnsNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_name")
	}

	return validatorFn, nil
}

func (v *ValidateCDNOriginServerPublicName) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNOriginServerPublicName)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNOriginServerPublicName got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dns_name"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_name"))
		if err := fv(ctx, m.GetDnsName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNOriginServerPublicNameValidator = func() *ValidateCDNOriginServerPublicName {
	v := &ValidateCDNOriginServerPublicName{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDnsName := v.DnsNameValidationRuleHandler
	rulesDnsName := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
	}
	vFn, err = vrhDnsName(rulesDnsName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNOriginServerPublicName.dns_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_name"] = vFn

	return v
}()

func CDNOriginServerPublicNameValidator() db.Validator {
	return DefaultCDNOriginServerPublicNameValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNOriginServerType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNOriginServerType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNOriginServerType) DeepCopy() *CDNOriginServerType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNOriginServerType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNOriginServerType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNOriginServerType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNOriginServerTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCDNOriginServerType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNOriginServerType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateCDNOriginServerType) PortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port")
	}

	return validatorFn, nil
}

func (v *ValidateCDNOriginServerType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNOriginServerType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNOriginServerType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *CDNOriginServerType_PublicIp:
		if fv, exists := v.FldValidators["choice.public_ip"]; exists {
			val := m.GetChoice().(*CDNOriginServerType_PublicIp).PublicIp
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("public_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CDNOriginServerType_PublicName:
		if fv, exists := v.FldValidators["choice.public_name"]; exists {
			val := m.GetChoice().(*CDNOriginServerType_PublicName).PublicName
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("public_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["port"]; exists {

		vOpts := append(opts, db.WithValidateField("port"))
		if err := fv(ctx, m.GetPort(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNOriginServerTypeValidator = func() *ValidateCDNOriginServerType {
	v := &ValidateCDNOriginServerType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNOriginServerType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	vrhPort := v.PortValidationRuleHandler
	rulesPort := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFn, err = vrhPort(rulesPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNOriginServerType.port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port"] = vFn

	v.FldValidators["choice.public_ip"] = CDNOriginServerPublicIPValidator().Validate
	v.FldValidators["choice.public_name"] = CDNOriginServerPublicNameValidator().Validate

	return v
}()

func CDNOriginServerTypeValidator() db.Validator {
	return DefaultCDNOriginServerTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNUpstreamTlsParameters) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNUpstreamTlsParameters) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNUpstreamTlsParameters) DeepCopy() *CDNUpstreamTlsParameters {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNUpstreamTlsParameters{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNUpstreamTlsParameters) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNUpstreamTlsParameters) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNUpstreamTlsParametersValidator().Validate(ctx, m, opts...)
}

type ValidateCDNUpstreamTlsParameters struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNUpstreamTlsParameters) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNUpstreamTlsParameters)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNUpstreamTlsParameters got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNUpstreamTlsParametersValidator = func() *ValidateCDNUpstreamTlsParameters {
	v := &ValidateCDNUpstreamTlsParameters{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CDNUpstreamTlsParametersValidator() db.Validator {
	return DefaultCDNUpstreamTlsParametersValidator
}

// augmented methods on protoc/std generated struct

func (m *CaptchaChallengeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CaptchaChallengeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CaptchaChallengeType) DeepCopy() *CaptchaChallengeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CaptchaChallengeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CaptchaChallengeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CaptchaChallengeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CaptchaChallengeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCaptchaChallengeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCaptchaChallengeType) CookieExpiryValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cookie_expiry")
	}

	return validatorFn, nil
}

func (v *ValidateCaptchaChallengeType) CustomPageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for custom_page")
	}

	return validatorFn, nil
}

func (v *ValidateCaptchaChallengeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CaptchaChallengeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CaptchaChallengeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cookie_expiry"]; exists {

		vOpts := append(opts, db.WithValidateField("cookie_expiry"))
		if err := fv(ctx, m.GetCookieExpiry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_page"]; exists {

		vOpts := append(opts, db.WithValidateField("custom_page"))
		if err := fv(ctx, m.GetCustomPage(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCaptchaChallengeTypeValidator = func() *ValidateCaptchaChallengeType {
	v := &ValidateCaptchaChallengeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCookieExpiry := v.CookieExpiryValidationRuleHandler
	rulesCookieExpiry := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "86400",
	}
	vFn, err = vrhCookieExpiry(rulesCookieExpiry)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CaptchaChallengeType.cookie_expiry: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookie_expiry"] = vFn

	vrhCustomPage := v.CustomPageValidationRuleHandler
	rulesCustomPage := map[string]string{
		"ves.io.schema.rules.string.max_len": "65536",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFn, err = vrhCustomPage(rulesCustomPage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CaptchaChallengeType.custom_page: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_page"] = vFn

	return v
}()

func CaptchaChallengeTypeValidator() db.Validator {
	return DefaultCaptchaChallengeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CdnOriginPoolType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CdnOriginPoolType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CdnOriginPoolType) DeepCopy() *CdnOriginPoolType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CdnOriginPoolType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CdnOriginPoolType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CdnOriginPoolType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CdnOriginPoolTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCdnOriginPoolType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCdnOriginPoolType) TlsChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tls_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCdnOriginPoolType) OriginServersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for origin_servers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CDNOriginServerType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CDNOriginServerTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for origin_servers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CDNOriginServerType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CDNOriginServerType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated origin_servers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items origin_servers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCdnOriginPoolType) OriginRequestTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for origin_request_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateCdnOriginPoolType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CdnOriginPoolType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CdnOriginPoolType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["follow_origin_redirect"]; exists {

		vOpts := append(opts, db.WithValidateField("follow_origin_redirect"))
		if err := fv(ctx, m.GetFollowOriginRedirect(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["more_origin_options"]; exists {

		vOpts := append(opts, db.WithValidateField("more_origin_options"))
		if err := fv(ctx, m.GetMoreOriginOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["origin_request_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("origin_request_timeout"))
		if err := fv(ctx, m.GetOriginRequestTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["origin_servers"]; exists {
		vOpts := append(opts, db.WithValidateField("origin_servers"))
		if err := fv(ctx, m.GetOriginServers(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_name"]; exists {

		vOpts := append(opts, db.WithValidateField("public_name"))
		if err := fv(ctx, m.GetPublicName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_choice"]; exists {
		val := m.GetTlsChoice()
		vOpts := append(opts,
			db.WithValidateField("tls_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTlsChoice().(type) {
	case *CdnOriginPoolType_NoTls:
		if fv, exists := v.FldValidators["tls_choice.no_tls"]; exists {
			val := m.GetTlsChoice().(*CdnOriginPoolType_NoTls).NoTls
			vOpts := append(opts,
				db.WithValidateField("tls_choice"),
				db.WithValidateField("no_tls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CdnOriginPoolType_UseTls:
		if fv, exists := v.FldValidators["tls_choice.use_tls"]; exists {
			val := m.GetTlsChoice().(*CdnOriginPoolType_UseTls).UseTls
			vOpts := append(opts,
				db.WithValidateField("tls_choice"),
				db.WithValidateField("use_tls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCdnOriginPoolTypeValidator = func() *ValidateCdnOriginPoolType {
	v := &ValidateCdnOriginPoolType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTlsChoice := v.TlsChoiceValidationRuleHandler
	rulesTlsChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhTlsChoice(rulesTlsChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CdnOriginPoolType.tls_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tls_choice"] = vFn

	vrhOriginServers := v.OriginServersValidationRuleHandler
	rulesOriginServers := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhOriginServers(rulesOriginServers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CdnOriginPoolType.origin_servers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["origin_servers"] = vFn

	vrhOriginRequestTimeout := v.OriginRequestTimeoutValidationRuleHandler
	rulesOriginRequestTimeout := map[string]string{
		"ves.io.schema.rules.string.max_time_interval": "10m",
		"ves.io.schema.rules.string.min_time_interval": "10s",
		"ves.io.schema.rules.string.time_interval":     "true",
	}
	vFn, err = vrhOriginRequestTimeout(rulesOriginRequestTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CdnOriginPoolType.origin_request_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["origin_request_timeout"] = vFn

	v.FldValidators["public_name"] = CDNOriginServerPublicNameValidator().Validate

	return v
}()

func CdnOriginPoolTypeValidator() db.Validator {
	return DefaultCdnOriginPoolTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CdnServiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CdnServiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CdnServiceType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetOtherSettings().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CdnServiceType.other_settings")
	}

	return nil
}

func (m *CdnServiceType) DeepCopy() *CdnServiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CdnServiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CdnServiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CdnServiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CdnServiceTypeValidator().Validate(ctx, m, opts...)
}

func (m *CdnServiceType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetCdnCacheRuleDRefInfo()

}

func (m *CdnServiceType) GetCdnCacheRuleDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetCdnCacheRule()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("CdnServiceType.cdn_cache_rule[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("cdn_cache_rule.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "cdn_cache_rule.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "cdn_cache_rule",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetCdnCacheRuleDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CdnServiceType) GetCdnCacheRuleDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "cdn_cache_rule.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: cdn_cache_rule")
	}
	for i, vref := range m.GetCdnCacheRule() {
		if vref == nil {
			return nil, fmt.Errorf("CdnServiceType.cdn_cache_rule[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "cdn_cache_rule.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateCdnServiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCdnServiceType) ContentChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for content_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCdnServiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CdnServiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CdnServiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_ttl"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_ttl"))
		if err := fv(ctx, m.GetCacheTtl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cdn_cache_rule"]; exists {

		vOpts := append(opts, db.WithValidateField("cdn_cache_rule"))
		for idx, item := range m.GetCdnCacheRule() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["cdn_origin_pool"]; exists {

		vOpts := append(opts, db.WithValidateField("cdn_origin_pool"))
		if err := fv(ctx, m.GetCdnOriginPool(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["content_choice"]; exists {
		val := m.GetContentChoice()
		vOpts := append(opts,
			db.WithValidateField("content_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetContentChoice().(type) {
	case *CdnServiceType_DownloadDelivery:
		if fv, exists := v.FldValidators["content_choice.download_delivery"]; exists {
			val := m.GetContentChoice().(*CdnServiceType_DownloadDelivery).DownloadDelivery
			vOpts := append(opts,
				db.WithValidateField("content_choice"),
				db.WithValidateField("download_delivery"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CdnServiceType_LiveStreaming:
		if fv, exists := v.FldValidators["content_choice.live_streaming"]; exists {
			val := m.GetContentChoice().(*CdnServiceType_LiveStreaming).LiveStreaming
			vOpts := append(opts,
				db.WithValidateField("content_choice"),
				db.WithValidateField("live_streaming"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["default_cache_action"]; exists {

		vOpts := append(opts, db.WithValidateField("default_cache_action"))
		if err := fv(ctx, m.GetDefaultCacheAction(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["other_settings"]; exists {

		vOpts := append(opts, db.WithValidateField("other_settings"))
		if err := fv(ctx, m.GetOtherSettings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_domains"]; exists {

		vOpts := append(opts, db.WithValidateField("service_domains"))
		for idx, item := range m.GetServiceDomains() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service_policy_option"]; exists {

		vOpts := append(opts, db.WithValidateField("service_policy_option"))
		if err := fv(ctx, m.GetServicePolicyOption(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCdnServiceTypeValidator = func() *ValidateCdnServiceType {
	v := &ValidateCdnServiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhContentChoice := v.ContentChoiceValidationRuleHandler
	rulesContentChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhContentChoice(rulesContentChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CdnServiceType.content_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["content_choice"] = vFn

	v.FldValidators["cdn_origin_pool"] = CdnOriginPoolTypeValidator().Validate

	v.FldValidators["cdn_cache_rule"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["other_settings"] = OtherSettingsValidator().Validate

	v.FldValidators["default_cache_action"] = DefaultCacheActionValidator().Validate

	return v
}()

func CdnServiceTypeValidator() db.Validator {
	return DefaultCdnServiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ClientIPHeaders) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ClientIPHeaders) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ClientIPHeaders) DeepCopy() *ClientIPHeaders {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ClientIPHeaders{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ClientIPHeaders) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ClientIPHeaders) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ClientIPHeadersValidator().Validate(ctx, m, opts...)
}

type ValidateClientIPHeaders struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateClientIPHeaders) ClientIpHeadersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for client_ip_headers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for client_ip_headers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated client_ip_headers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items client_ip_headers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateClientIPHeaders) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ClientIPHeaders)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ClientIPHeaders got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["client_ip_headers"]; exists {
		vOpts := append(opts, db.WithValidateField("client_ip_headers"))
		if err := fv(ctx, m.GetClientIpHeaders(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultClientIPHeadersValidator = func() *ValidateClientIPHeaders {
	v := &ValidateClientIPHeaders{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhClientIpHeaders := v.ClientIpHeadersValidationRuleHandler
	rulesClientIpHeaders := map[string]string{
		"ves.io.schema.rules.message.required":                "true",
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "5",
		"ves.io.schema.rules.repeated.min_items":              "1",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhClientIpHeaders(rulesClientIpHeaders)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ClientIPHeaders.client_ip_headers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["client_ip_headers"] = vFn

	return v
}()

func ClientIPHeadersValidator() db.Validator {
	return DefaultClientIPHeadersValidator
}

// augmented methods on protoc/std generated struct

func (m *CompressionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CompressionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CompressionType) DeepCopy() *CompressionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CompressionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CompressionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CompressionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CompressionTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCompressionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCompressionType) ContentLengthValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for content_length")
	}

	return validatorFn, nil
}

func (v *ValidateCompressionType) ContentTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for content_type")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for content_type")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated content_type")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items content_type")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCompressionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CompressionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CompressionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["content_length"]; exists {

		vOpts := append(opts, db.WithValidateField("content_length"))
		if err := fv(ctx, m.GetContentLength(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["content_type"]; exists {
		vOpts := append(opts, db.WithValidateField("content_type"))
		if err := fv(ctx, m.GetContentType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_on_etag_header"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_on_etag_header"))
		if err := fv(ctx, m.GetDisableOnEtagHeader(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["remove_accept_encoding_header"]; exists {

		vOpts := append(opts, db.WithValidateField("remove_accept_encoding_header"))
		if err := fv(ctx, m.GetRemoveAcceptEncodingHeader(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCompressionTypeValidator = func() *ValidateCompressionType {
	v := &ValidateCompressionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhContentLength := v.ContentLengthValidationRuleHandler
	rulesContentLength := map[string]string{
		"ves.io.schema.rules.uint32.gte": "30",
	}
	vFn, err = vrhContentLength(rulesContentLength)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CompressionType.content_length: %s", err)
		panic(errMsg)
	}
	v.FldValidators["content_length"] = vFn

	vrhContentType := v.ContentTypeValidationRuleHandler
	rulesContentType := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "50",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhContentType(rulesContentType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CompressionType.content_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["content_type"] = vFn

	return v
}()

func CompressionTypeValidator() db.Validator {
	return DefaultCompressionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CreateSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetRequestHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting CreateSpecType.request_headers_to_add idx %v", idx)
		}
	}

	for idx, e := range m.GetResponseHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting CreateSpecType.response_headers_to_add idx %v", idx)
		}
	}

	if err := m.GetTlsParameters().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.tls_parameters")
	}

	if err := m.GetAuthentication().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.authentication")
	}

	for idx, e := range m.GetRequestCookiesToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting CreateSpecType.request_cookies_to_add idx %v", idx)
		}
	}

	for idx, e := range m.GetResponseCookiesToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting CreateSpecType.response_cookies_to_add idx %v", idx)
		}
	}

	return nil
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAdvertisePoliciesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAdvertisePoliciesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetApiSpecDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetApiSpecDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetAuthenticationChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAuthenticationChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDnsProxyConfigurationDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDnsProxyConfigurationDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDynamicReverseProxyDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDynamicReverseProxyDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterAllowedPrefixesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRateLimiterAllowedPrefixesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRoutesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRoutesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetSensitiveDataPolicyDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSensitiveDataPolicyDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTlsCertificatesChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTlsCertificatesChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetUserIdentificationDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetUserIdentificationDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWafTypeDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetWafTypeDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetZtnaProxyConfigurationsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetZtnaProxyConfigurationsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *CreateSpecType) GetAdvertisePoliciesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAdvertisePolicies()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.advertise_policies[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "advertise_policy.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "advertise_policies",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAdvertisePoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetAdvertisePoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "advertise_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: advertise_policy")
	}
	for _, ref := range m.GetAdvertisePolicies() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetApiSpecDRefInfo() ([]db.DRefInfo, error) {
	if m.GetApiSpec() == nil {
		return nil, nil
	}

	drInfos, err := m.GetApiSpec().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetApiSpec().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "api_spec." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetAuthenticationChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAuthenticationChoice() == nil {
		return nil, nil
	}
	switch m.GetAuthenticationChoice().(type) {
	case *CreateSpecType_NoAuthentication:

		return nil, nil

	case *CreateSpecType_Authentication:

		drInfos, err := m.GetAuthentication().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAuthentication().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "authentication." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetDnsProxyConfigurationDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDnsProxyConfiguration() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDnsProxyConfiguration().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDnsProxyConfiguration().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "dns_proxy_configuration." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetDynamicReverseProxyDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDynamicReverseProxy() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDynamicReverseProxy().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDynamicReverseProxy().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "dynamic_reverse_proxy." + dri.DRField
	}
	return drInfos, err

}

func (m *CreateSpecType) GetRateLimiterAllowedPrefixesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRateLimiterAllowedPrefixes()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.rate_limiter_allowed_prefixes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "ip_prefix_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter_allowed_prefixes",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRateLimiterAllowedPrefixesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetRateLimiterAllowedPrefixesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "ip_prefix_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: ip_prefix_set")
	}
	for _, ref := range m.GetRateLimiterAllowedPrefixes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *CreateSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRoutes()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.routes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "route.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "routes",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRoutesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetRoutesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "route.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: route")
	}
	for _, ref := range m.GetRoutes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *CreateSpecType) GetSensitiveDataPolicyDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetSensitiveDataPolicy()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.sensitive_data_policy[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "sensitive_data_policy.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "sensitive_data_policy",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetSensitiveDataPolicyDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetSensitiveDataPolicyDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "sensitive_data_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: sensitive_data_policy")
	}
	for _, ref := range m.GetSensitiveDataPolicy() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetTlsCertificatesChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTlsCertificatesChoice() == nil {
		return nil, nil
	}
	switch m.GetTlsCertificatesChoice().(type) {
	case *CreateSpecType_TlsParameters:

		drInfos, err := m.GetTlsParameters().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTlsParameters().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tls_parameters." + dri.DRField
		}
		return drInfos, err

	case *CreateSpecType_TlsCertParams:

		drInfos, err := m.GetTlsCertParams().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTlsCertParams().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tls_cert_params." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *CreateSpecType) GetUserIdentificationDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetUserIdentification()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.user_identification[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "user_identification.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "user_identification",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetUserIdentificationDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetUserIdentificationDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "user_identification.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: user_identification")
	}
	for _, ref := range m.GetUserIdentification() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetWafTypeDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWafType() == nil {
		return nil, nil
	}

	drInfos, err := m.GetWafType().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetWafType().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "waf_type." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetZtnaProxyConfigurationsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetZtnaProxyConfigurations() == nil {
		return nil, nil
	}

	drInfos, err := m.GetZtnaProxyConfigurations().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetZtnaProxyConfigurations().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "ztna_proxy_configurations." + dri.DRField
	}
	return drInfos, err

}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) ChallengeTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for challenge_type")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ServerHeaderChoiceServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_name")
	}
	return oValidatorFn_ServerName, nil
}
func (v *ValidateCreateSpecType) ServerHeaderChoiceAppendServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_AppendServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for append_server_name")
	}
	return oValidatorFn_AppendServerName, nil
}

func (v *ValidateCreateSpecType) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for routes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) RequestHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for request_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ResponseHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for response_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ResponseHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ProxyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ProxyType)
		return int32(i)
	}
	// ProxyType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ProxyType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for proxy")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) RequestHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) CustomErrorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapUint32KeyRules(rules)
	itemKeyFn, err := db.NewUint32ValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for custom_errors")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for custom_errors")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[uint32]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for custom_errors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[uint32]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ uint32 ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map custom_errors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items custom_errors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) MaxRequestHeaderSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_request_header_size")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) UserIdentificationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for user_identification")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for user_identification")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated user_identification")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items user_identification")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) RateLimiterAllowedPrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter_allowed_prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter_allowed_prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) CookiesToModifyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cookies_to_modify")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.CookieManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.CookieManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cookies_to_modify")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.CookieManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.CookieManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cookies_to_modify")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cookies_to_modify")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ConnectionIdleTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_idle_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) RequestCookiesToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for request_cookies_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.CookieValueOption, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.CookieValueOptionValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_cookies_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.CookieValueOption)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.CookieValueOption, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_cookies_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_cookies_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) RequestCookiesToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_cookies_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_cookies_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_cookies_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_cookies_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ResponseCookiesToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for response_cookies_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.SetCookieValueOption, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.SetCookieValueOptionValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_cookies_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.SetCookieValueOption)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.SetCookieValueOption, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_cookies_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_cookies_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ResponseCookiesToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_cookies_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_cookies_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_cookies_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_cookies_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) MaxDirectResponseBodySizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_direct_response_body_size")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_location"]; exists {

		vOpts := append(opts, db.WithValidateField("add_location"))
		if err := fv(ctx, m.GetAddLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["advertise_policies"]; exists {

		vOpts := append(opts, db.WithValidateField("advertise_policies"))
		for idx, item := range m.GetAdvertisePolicies() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["api_spec"]; exists {

		vOpts := append(opts, db.WithValidateField("api_spec"))
		if err := fv(ctx, m.GetApiSpec(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetAuthenticationChoice().(type) {
	case *CreateSpecType_NoAuthentication:
		if fv, exists := v.FldValidators["authentication_choice.no_authentication"]; exists {
			val := m.GetAuthenticationChoice().(*CreateSpecType_NoAuthentication).NoAuthentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("no_authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Authentication:
		if fv, exists := v.FldValidators["authentication_choice.authentication"]; exists {
			val := m.GetAuthenticationChoice().(*CreateSpecType_Authentication).Authentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["buffer_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("buffer_policy"))
		if err := fv(ctx, m.GetBufferPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["challenge_type"]; exists {
		val := m.GetChallengeType()
		vOpts := append(opts,
			db.WithValidateField("challenge_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChallengeType().(type) {
	case *CreateSpecType_JsChallenge:
		if fv, exists := v.FldValidators["challenge_type.js_challenge"]; exists {
			val := m.GetChallengeType().(*CreateSpecType_JsChallenge).JsChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("js_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_CaptchaChallenge:
		if fv, exists := v.FldValidators["challenge_type.captcha_challenge"]; exists {
			val := m.GetChallengeType().(*CreateSpecType_CaptchaChallenge).CaptchaChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("captcha_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_NoChallenge:
		if fv, exists := v.FldValidators["challenge_type.no_challenge"]; exists {
			val := m.GetChallengeType().(*CreateSpecType_NoChallenge).NoChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("no_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["coalescing_options"]; exists {

		vOpts := append(opts, db.WithValidateField("coalescing_options"))
		if err := fv(ctx, m.GetCoalescingOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["compression_params"]; exists {

		vOpts := append(opts, db.WithValidateField("compression_params"))
		if err := fv(ctx, m.GetCompressionParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connection_idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_idle_timeout"))
		if err := fv(ctx, m.GetConnectionIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cookies_to_modify"]; exists {
		vOpts := append(opts, db.WithValidateField("cookies_to_modify"))
		if err := fv(ctx, m.GetCookiesToModify(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cors_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("cors_policy"))
		if err := fv(ctx, m.GetCorsPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["csrf_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("csrf_policy"))
		if err := fv(ctx, m.GetCsrfPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_errors"]; exists {
		vOpts := append(opts, db.WithValidateField("custom_errors"))
		if err := fv(ctx, m.GetCustomErrors(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetDefaultLbChoice().(type) {
	case *CreateSpecType_NonDefaultLoadbalancer:
		if fv, exists := v.FldValidators["default_lb_choice.non_default_loadbalancer"]; exists {
			val := m.GetDefaultLbChoice().(*CreateSpecType_NonDefaultLoadbalancer).NonDefaultLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("default_lb_choice"),
				db.WithValidateField("non_default_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DefaultLoadbalancer:
		if fv, exists := v.FldValidators["default_lb_choice.default_loadbalancer"]; exists {
			val := m.GetDefaultLbChoice().(*CreateSpecType_DefaultLoadbalancer).DefaultLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("default_lb_choice"),
				db.WithValidateField("default_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["disable_default_error_pages"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_default_error_pages"))
		if err := fv(ctx, m.GetDisableDefaultErrorPages(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_dns_resolve"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_dns_resolve"))
		if err := fv(ctx, m.GetDisableDnsResolve(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_proxy_configuration"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_proxy_configuration"))
		if err := fv(ctx, m.GetDnsProxyConfiguration(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domain_cert_map"]; exists {

		vOpts := append(opts, db.WithValidateField("domain_cert_map"))
		for key, value := range m.GetDomainCertMap() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dynamic_reverse_proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("dynamic_reverse_proxy"))
		if err := fv(ctx, m.GetDynamicReverseProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header_transformation_type"]; exists {

		vOpts := append(opts, db.WithValidateField("header_transformation_type"))
		if err := fv(ctx, m.GetHeaderTransformationType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_protocol_options"]; exists {

		vOpts := append(opts, db.WithValidateField("http_protocol_options"))
		if err := fv(ctx, m.GetHttpProtocolOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("idle_timeout"))
		if err := fv(ctx, m.GetIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["masking_config"]; exists {

		vOpts := append(opts, db.WithValidateField("masking_config"))
		if err := fv(ctx, m.GetMaskingConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_direct_response_body_size"]; exists {

		vOpts := append(opts, db.WithValidateField("max_direct_response_body_size"))
		if err := fv(ctx, m.GetMaxDirectResponseBodySize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_request_header_size"]; exists {

		vOpts := append(opts, db.WithValidateField("max_request_header_size"))
		if err := fv(ctx, m.GetMaxRequestHeaderSize(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetPathNormalizeChoice().(type) {
	case *CreateSpecType_EnablePathNormalize:
		if fv, exists := v.FldValidators["path_normalize_choice.enable_path_normalize"]; exists {
			val := m.GetPathNormalizeChoice().(*CreateSpecType_EnablePathNormalize).EnablePathNormalize
			vOpts := append(opts,
				db.WithValidateField("path_normalize_choice"),
				db.WithValidateField("enable_path_normalize"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DisablePathNormalize:
		if fv, exists := v.FldValidators["path_normalize_choice.disable_path_normalize"]; exists {
			val := m.GetPathNormalizeChoice().(*CreateSpecType_DisablePathNormalize).DisablePathNormalize
			vOpts := append(opts,
				db.WithValidateField("path_normalize_choice"),
				db.WithValidateField("disable_path_normalize"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("proxy"))
		if err := fv(ctx, m.GetProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter_allowed_prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter_allowed_prefixes"))
		if err := fv(ctx, m.GetRateLimiterAllowedPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_cookies_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_cookies_to_add"))
		if err := fv(ctx, m.GetRequestCookiesToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_cookies_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_cookies_to_remove"))
		if err := fv(ctx, m.GetRequestCookiesToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_add"))
		if err := fv(ctx, m.GetRequestHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_remove"))
		if err := fv(ctx, m.GetRequestHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_cookies_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_cookies_to_add"))
		if err := fv(ctx, m.GetResponseCookiesToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_cookies_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_cookies_to_remove"))
		if err := fv(ctx, m.GetResponseCookiesToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_add"))
		if err := fv(ctx, m.GetResponseHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_remove"))
		if err := fv(ctx, m.GetResponseHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["retry_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("retry_policy"))
		if err := fv(ctx, m.GetRetryPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sensitive_data_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("sensitive_data_policy"))
		for idx, item := range m.GetSensitiveDataPolicy() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetServerHeaderChoice().(type) {
	case *CreateSpecType_DefaultHeader:
		if fv, exists := v.FldValidators["server_header_choice.default_header"]; exists {
			val := m.GetServerHeaderChoice().(*CreateSpecType_DefaultHeader).DefaultHeader
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("default_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_ServerName:
		if fv, exists := v.FldValidators["server_header_choice.server_name"]; exists {
			val := m.GetServerHeaderChoice().(*CreateSpecType_ServerName).ServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_AppendServerName:
		if fv, exists := v.FldValidators["server_header_choice.append_server_name"]; exists {
			val := m.GetServerHeaderChoice().(*CreateSpecType_AppendServerName).AppendServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("append_server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_PassThrough:
		if fv, exists := v.FldValidators["server_header_choice.pass_through"]; exists {
			val := m.GetServerHeaderChoice().(*CreateSpecType_PassThrough).PassThrough
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("pass_through"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["slow_ddos_mitigation"]; exists {

		vOpts := append(opts, db.WithValidateField("slow_ddos_mitigation"))
		if err := fv(ctx, m.GetSlowDdosMitigation(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetStrictSniHostHeaderCheckChoice().(type) {
	case *CreateSpecType_EnableStrictSniHostHeaderCheck:
		if fv, exists := v.FldValidators["strict_sni_host_header_check_choice.enable_strict_sni_host_header_check"]; exists {
			val := m.GetStrictSniHostHeaderCheckChoice().(*CreateSpecType_EnableStrictSniHostHeaderCheck).EnableStrictSniHostHeaderCheck
			vOpts := append(opts,
				db.WithValidateField("strict_sni_host_header_check_choice"),
				db.WithValidateField("enable_strict_sni_host_header_check"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_AdditionalDomains:
		if fv, exists := v.FldValidators["strict_sni_host_header_check_choice.additional_domains"]; exists {
			val := m.GetStrictSniHostHeaderCheckChoice().(*CreateSpecType_AdditionalDomains).AdditionalDomains
			vOpts := append(opts,
				db.WithValidateField("strict_sni_host_header_check_choice"),
				db.WithValidateField("additional_domains"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["temporary_user_blocking"]; exists {

		vOpts := append(opts, db.WithValidateField("temporary_user_blocking"))
		if err := fv(ctx, m.GetTemporaryUserBlocking(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetTlsCertificatesChoice().(type) {
	case *CreateSpecType_TlsParameters:
		if fv, exists := v.FldValidators["tls_certificates_choice.tls_parameters"]; exists {
			val := m.GetTlsCertificatesChoice().(*CreateSpecType_TlsParameters).TlsParameters
			vOpts := append(opts,
				db.WithValidateField("tls_certificates_choice"),
				db.WithValidateField("tls_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_TlsCertParams:
		if fv, exists := v.FldValidators["tls_certificates_choice.tls_cert_params"]; exists {
			val := m.GetTlsCertificatesChoice().(*CreateSpecType_TlsCertParams).TlsCertParams
			vOpts := append(opts,
				db.WithValidateField("tls_certificates_choice"),
				db.WithValidateField("tls_cert_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["user_identification"]; exists {
		vOpts := append(opts, db.WithValidateField("user_identification"))
		if err := fv(ctx, m.GetUserIdentification(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["waf_type"]; exists {

		vOpts := append(opts, db.WithValidateField("waf_type"))
		if err := fv(ctx, m.GetWafType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ztna_proxy_configurations"]; exists {

		vOpts := append(opts, db.WithValidateField("ztna_proxy_configurations"))
		if err := fv(ctx, m.GetZtnaProxyConfigurations(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChallengeType := v.ChallengeTypeValidationRuleHandler
	rulesChallengeType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChallengeType(rulesChallengeType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.challenge_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["challenge_type"] = vFn

	vrhServerHeaderChoiceServerName := v.ServerHeaderChoiceServerNameValidationRuleHandler
	rulesServerHeaderChoiceServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.server_name"], err = vrhServerHeaderChoiceServerName(rulesServerHeaderChoiceServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CreateSpecType.server_header_choice_server_name: %s", err)
		panic(errMsg)
	}
	vrhServerHeaderChoiceAppendServerName := v.ServerHeaderChoiceAppendServerNameValidationRuleHandler
	rulesServerHeaderChoiceAppendServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.append_server_name"], err = vrhServerHeaderChoiceAppendServerName(rulesServerHeaderChoiceAppendServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CreateSpecType.server_header_choice_append_server_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["server_header_choice.server_name"] = vFnMap["server_header_choice.server_name"]
	v.FldValidators["server_header_choice.append_server_name"] = vFnMap["server_header_choice.append_server_name"]

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.repeated.items.string.vh_domain": "true",
		"ves.io.schema.rules.repeated.max_items":              "33",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "256",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	vrhRequestHeadersToAdd := v.RequestHeadersToAddValidationRuleHandler
	rulesRequestHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToAdd(rulesRequestHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.request_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_add"] = vFn

	vrhResponseHeadersToAdd := v.ResponseHeadersToAddValidationRuleHandler
	rulesResponseHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToAdd(rulesResponseHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.response_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_add"] = vFn

	vrhResponseHeadersToRemove := v.ResponseHeadersToRemoveValidationRuleHandler
	rulesResponseHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToRemove(rulesResponseHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.response_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_remove"] = vFn

	vrhProxy := v.ProxyValidationRuleHandler
	rulesProxy := map[string]string{
		"ves.io.schema.rules.enum.in": "[4,5]",
	}
	vFn, err = vrhProxy(rulesProxy)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.proxy: %s", err)
		panic(errMsg)
	}
	v.FldValidators["proxy"] = vFn

	vrhRequestHeadersToRemove := v.RequestHeadersToRemoveValidationRuleHandler
	rulesRequestHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToRemove(rulesRequestHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.request_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_remove"] = vFn

	vrhCustomErrors := v.CustomErrorsValidationRuleHandler
	rulesCustomErrors := map[string]string{
		"ves.io.schema.rules.map.keys.uint32.gte":       "3",
		"ves.io.schema.rules.map.keys.uint32.lte":       "599",
		"ves.io.schema.rules.map.max_pairs":             "16",
		"ves.io.schema.rules.map.values.string.max_len": "65536",
		"ves.io.schema.rules.map.values.string.uri_ref": "true",
	}
	vFn, err = vrhCustomErrors(rulesCustomErrors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.custom_errors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_errors"] = vFn

	vrhMaxRequestHeaderSize := v.MaxRequestHeaderSizeValidationRuleHandler
	rulesMaxRequestHeaderSize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "96",
	}
	vFn, err = vrhMaxRequestHeaderSize(rulesMaxRequestHeaderSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.max_request_header_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_request_header_size"] = vFn

	vrhUserIdentification := v.UserIdentificationValidationRuleHandler
	rulesUserIdentification := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhUserIdentification(rulesUserIdentification)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.user_identification: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user_identification"] = vFn

	vrhRateLimiterAllowedPrefixes := v.RateLimiterAllowedPrefixesValidationRuleHandler
	rulesRateLimiterAllowedPrefixes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhRateLimiterAllowedPrefixes(rulesRateLimiterAllowedPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.rate_limiter_allowed_prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter_allowed_prefixes"] = vFn

	vrhCookiesToModify := v.CookiesToModifyValidationRuleHandler
	rulesCookiesToModify := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhCookiesToModify(rulesCookiesToModify)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.cookies_to_modify: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookies_to_modify"] = vFn

	vrhConnectionIdleTimeout := v.ConnectionIdleTimeoutValidationRuleHandler
	rulesConnectionIdleTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhConnectionIdleTimeout(rulesConnectionIdleTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.connection_idle_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_idle_timeout"] = vFn

	vrhRequestCookiesToAdd := v.RequestCookiesToAddValidationRuleHandler
	rulesRequestCookiesToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestCookiesToAdd(rulesRequestCookiesToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.request_cookies_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_cookies_to_add"] = vFn

	vrhRequestCookiesToRemove := v.RequestCookiesToRemoveValidationRuleHandler
	rulesRequestCookiesToRemove := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhRequestCookiesToRemove(rulesRequestCookiesToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.request_cookies_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_cookies_to_remove"] = vFn

	vrhResponseCookiesToAdd := v.ResponseCookiesToAddValidationRuleHandler
	rulesResponseCookiesToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseCookiesToAdd(rulesResponseCookiesToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.response_cookies_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_cookies_to_add"] = vFn

	vrhResponseCookiesToRemove := v.ResponseCookiesToRemoveValidationRuleHandler
	rulesResponseCookiesToRemove := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhResponseCookiesToRemove(rulesResponseCookiesToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.response_cookies_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_cookies_to_remove"] = vFn

	vrhMaxDirectResponseBodySize := v.MaxDirectResponseBodySizeValidationRuleHandler
	rulesMaxDirectResponseBodySize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "65536",
	}
	vFn, err = vrhMaxDirectResponseBodySize(rulesMaxDirectResponseBodySize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.max_direct_response_body_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_direct_response_body_size"] = vFn

	v.FldValidators["authentication_choice.authentication"] = AuthenticationDetailsValidator().Validate

	v.FldValidators["challenge_type.js_challenge"] = JavascriptChallengeTypeValidator().Validate
	v.FldValidators["challenge_type.captcha_challenge"] = CaptchaChallengeTypeValidator().Validate

	v.FldValidators["strict_sni_host_header_check_choice.additional_domains"] = ves_io_schema.DomainNameListValidator().Validate

	v.FldValidators["tls_certificates_choice.tls_parameters"] = ves_io_schema.DownstreamTlsParamsTypeValidator().Validate
	v.FldValidators["tls_certificates_choice.tls_cert_params"] = ves_io_schema.CertificateParamsTypeValidator().Validate

	v.FldValidators["buffer_policy"] = ves_io_schema.BufferConfigTypeValidator().Validate

	v.FldValidators["cors_policy"] = ves_io_schema.CorsPolicyValidator().Validate

	v.FldValidators["waf_type"] = ves_io_schema.WafTypeValidator().Validate

	v.FldValidators["dynamic_reverse_proxy"] = DynamicReverseProxyTypeValidator().Validate

	v.FldValidators["compression_params"] = CompressionTypeValidator().Validate

	v.FldValidators["retry_policy"] = ves_io_schema.RetryPolicyTypeValidator().Validate

	v.FldValidators["temporary_user_blocking"] = TemporaryUserBlockingTypeValidator().Validate

	v.FldValidators["header_transformation_type"] = ves_io_schema.HeaderTransformationTypeValidator().Validate

	v.FldValidators["csrf_policy"] = ves_io_schema.CsrfPolicyValidator().Validate

	v.FldValidators["slow_ddos_mitigation"] = SlowDDoSMitigationValidator().Validate

	v.FldValidators["api_spec"] = ApiSpecValidator().Validate

	v.FldValidators["domain_cert_map"] = DomainCertificatesValidator().Validate

	v.FldValidators["http_protocol_options"] = HttpProtocolOptionsValidator().Validate

	v.FldValidators["coalescing_options"] = ves_io_schema.TLSCoalescingOptionsValidator().Validate

	v.FldValidators["ztna_proxy_configurations"] = ZtnaProxyConfigurationValidator().Validate

	v.FldValidators["dns_proxy_configuration"] = DNSProxyConfigurationValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DNSCacheProfile) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DNSCacheProfile) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DNSCacheProfile) DeepCopy() *DNSCacheProfile {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DNSCacheProfile{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DNSCacheProfile) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DNSCacheProfile) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DNSCacheProfileValidator().Validate(ctx, m, opts...)
}

type ValidateDNSCacheProfile struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDNSCacheProfile) CacheProfileChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_profile_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDNSCacheProfile) CacheProfileChoiceCacheSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_CacheSize, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_size")
	}
	return oValidatorFn_CacheSize, nil
}

func (v *ValidateDNSCacheProfile) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DNSCacheProfile)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DNSCacheProfile got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_profile_choice"]; exists {
		val := m.GetCacheProfileChoice()
		vOpts := append(opts,
			db.WithValidateField("cache_profile_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCacheProfileChoice().(type) {
	case *DNSCacheProfile_DisableCacheProfile:
		if fv, exists := v.FldValidators["cache_profile_choice.disable_cache_profile"]; exists {
			val := m.GetCacheProfileChoice().(*DNSCacheProfile_DisableCacheProfile).DisableCacheProfile
			vOpts := append(opts,
				db.WithValidateField("cache_profile_choice"),
				db.WithValidateField("disable_cache_profile"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DNSCacheProfile_CacheSize:
		if fv, exists := v.FldValidators["cache_profile_choice.cache_size"]; exists {
			val := m.GetCacheProfileChoice().(*DNSCacheProfile_CacheSize).CacheSize
			vOpts := append(opts,
				db.WithValidateField("cache_profile_choice"),
				db.WithValidateField("cache_size"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDNSCacheProfileValidator = func() *ValidateDNSCacheProfile {
	v := &ValidateDNSCacheProfile{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCacheProfileChoice := v.CacheProfileChoiceValidationRuleHandler
	rulesCacheProfileChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCacheProfileChoice(rulesCacheProfileChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DNSCacheProfile.cache_profile_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cache_profile_choice"] = vFn

	vrhCacheProfileChoiceCacheSize := v.CacheProfileChoiceCacheSizeValidationRuleHandler
	rulesCacheProfileChoiceCacheSize := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "10240",
	}
	vFnMap["cache_profile_choice.cache_size"], err = vrhCacheProfileChoiceCacheSize(rulesCacheProfileChoiceCacheSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DNSCacheProfile.cache_profile_choice_cache_size: %s", err)
		panic(errMsg)
	}

	v.FldValidators["cache_profile_choice.cache_size"] = vFnMap["cache_profile_choice.cache_size"]

	return v
}()

func DNSCacheProfileValidator() db.Validator {
	return DefaultDNSCacheProfileValidator
}

// augmented methods on protoc/std generated struct

func (m *DNSDDoSProfile) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DNSDDoSProfile) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DNSDDoSProfile) DeepCopy() *DNSDDoSProfile {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DNSDDoSProfile{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DNSDDoSProfile) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DNSDDoSProfile) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DNSDDoSProfileValidator().Validate(ctx, m, opts...)
}

type ValidateDNSDDoSProfile struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDNSDDoSProfile) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DNSDDoSProfile)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DNSDDoSProfile got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetDdosMitigationChoice().(type) {
	case *DNSDDoSProfile_EnableDdosMitigation:
		if fv, exists := v.FldValidators["ddos_mitigation_choice.enable_ddos_mitigation"]; exists {
			val := m.GetDdosMitigationChoice().(*DNSDDoSProfile_EnableDdosMitigation).EnableDdosMitigation
			vOpts := append(opts,
				db.WithValidateField("ddos_mitigation_choice"),
				db.WithValidateField("enable_ddos_mitigation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DNSDDoSProfile_DisableDdosMitigation:
		if fv, exists := v.FldValidators["ddos_mitigation_choice.disable_ddos_mitigation"]; exists {
			val := m.GetDdosMitigationChoice().(*DNSDDoSProfile_DisableDdosMitigation).DisableDdosMitigation
			vOpts := append(opts,
				db.WithValidateField("ddos_mitigation_choice"),
				db.WithValidateField("disable_ddos_mitigation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDNSDDoSProfileValidator = func() *ValidateDNSDDoSProfile {
	v := &ValidateDNSDDoSProfile{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DNSDDoSProfileValidator() db.Validator {
	return DefaultDNSDDoSProfileValidator
}

// augmented methods on protoc/std generated struct

func (m *DNSProxyConfiguration) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DNSProxyConfiguration) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DNSProxyConfiguration) DeepCopy() *DNSProxyConfiguration {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DNSProxyConfiguration{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DNSProxyConfiguration) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DNSProxyConfiguration) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DNSProxyConfigurationValidator().Validate(ctx, m, opts...)
}

func (m *DNSProxyConfiguration) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetIrulesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetIrulesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetProtocolInspectionDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetProtocolInspectionDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *DNSProxyConfiguration) GetIrulesDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetIrules()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("DNSProxyConfiguration.irules[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("irule.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "irule.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "irules",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetIrulesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *DNSProxyConfiguration) GetIrulesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "irule.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: irule")
	}
	for i, vref := range m.GetIrules() {
		if vref == nil {
			return nil, fmt.Errorf("DNSProxyConfiguration.irules[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "irule.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *DNSProxyConfiguration) GetProtocolInspectionDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetProtocolInspection()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("protocol_inspection.Object")
	dri := db.DRefInfo{
		RefdType:   "protocol_inspection.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "protocol_inspection",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetProtocolInspectionDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *DNSProxyConfiguration) GetProtocolInspectionDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "protocol_inspection.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: protocol_inspection")
	}

	vref := m.GetProtocolInspection()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "protocol_inspection.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateDNSProxyConfiguration struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDNSProxyConfiguration) DdosProfileValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for ddos_profile")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDNSProxyConfiguration) IrulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for irules")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for irules")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated irules")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items irules")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDNSProxyConfiguration) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DNSProxyConfiguration)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DNSProxyConfiguration got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_profile"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_profile"))
		if err := fv(ctx, m.GetCacheProfile(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ddos_profile"]; exists {

		vOpts := append(opts, db.WithValidateField("ddos_profile"))
		if err := fv(ctx, m.GetDdosProfile(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["irules"]; exists {
		vOpts := append(opts, db.WithValidateField("irules"))
		if err := fv(ctx, m.GetIrules(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["protocol_inspection"]; exists {

		vOpts := append(opts, db.WithValidateField("protocol_inspection"))
		if err := fv(ctx, m.GetProtocolInspection(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDNSProxyConfigurationValidator = func() *ValidateDNSProxyConfiguration {
	v := &ValidateDNSProxyConfiguration{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDdosProfile := v.DdosProfileValidationRuleHandler
	rulesDdosProfile := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDdosProfile(rulesDdosProfile)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DNSProxyConfiguration.ddos_profile: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ddos_profile"] = vFn

	vrhIrules := v.IrulesValidationRuleHandler
	rulesIrules := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhIrules(rulesIrules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DNSProxyConfiguration.irules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["irules"] = vFn

	v.FldValidators["cache_profile"] = DNSCacheProfileValidator().Validate

	v.FldValidators["protocol_inspection"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func DNSProxyConfigurationValidator() db.Validator {
	return DefaultDNSProxyConfigurationValidator
}

// augmented methods on protoc/std generated struct

func (m *DNSRecord) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DNSRecord) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DNSRecord) DeepCopy() *DNSRecord {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DNSRecord{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DNSRecord) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DNSRecord) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DNSRecordValidator().Validate(ctx, m, opts...)
}

type ValidateDNSRecord struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDNSRecord) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DNSRecord)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DNSRecord got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDNSRecordValidator = func() *ValidateDNSRecord {
	v := &ValidateDNSRecord{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DNSRecordValidator() db.Validator {
	return DefaultDNSRecordValidator
}

// augmented methods on protoc/std generated struct

func (m *DNSVHostStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DNSVHostStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DNSVHostStatusType) DeepCopy() *DNSVHostStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DNSVHostStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DNSVHostStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DNSVHostStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DNSVHostStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDNSVHostStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDNSVHostStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DNSVHostStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DNSVHostStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["error_description"]; exists {

		vOpts := append(opts, db.WithValidateField("error_description"))
		if err := fv(ctx, m.GetErrorDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["existing_certificate_state"]; exists {

		vOpts := append(opts, db.WithValidateField("existing_certificate_state"))
		if err := fv(ctx, m.GetExistingCertificateState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["renew_certificate_state"]; exists {

		vOpts := append(opts, db.WithValidateField("renew_certificate_state"))
		if err := fv(ctx, m.GetRenewCertificateState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["suggested_action"]; exists {

		vOpts := append(opts, db.WithValidateField("suggested_action"))
		if err := fv(ctx, m.GetSuggestedAction(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDNSVHostStatusTypeValidator = func() *ValidateDNSVHostStatusType {
	v := &ValidateDNSVHostStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DNSVHostStatusTypeValidator() db.Validator {
	return DefaultDNSVHostStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DefaultCacheAction) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DefaultCacheAction) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DefaultCacheAction) DeepCopy() *DefaultCacheAction {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DefaultCacheAction{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DefaultCacheAction) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DefaultCacheAction) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DefaultCacheActionValidator().Validate(ctx, m, opts...)
}

type ValidateDefaultCacheAction struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDefaultCacheAction) CacheActionsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_actions")
	}
	return validatorFn, nil
}

func (v *ValidateDefaultCacheAction) CacheActionsCacheTtlDefaultValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_CacheTtlDefault, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_ttl_default")
	}
	return oValidatorFn_CacheTtlDefault, nil
}
func (v *ValidateDefaultCacheAction) CacheActionsCacheTtlOverrideValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_CacheTtlOverride, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_ttl_override")
	}
	return oValidatorFn_CacheTtlOverride, nil
}

func (v *ValidateDefaultCacheAction) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DefaultCacheAction)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DefaultCacheAction got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_actions"]; exists {
		val := m.GetCacheActions()
		vOpts := append(opts,
			db.WithValidateField("cache_actions"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCacheActions().(type) {
	case *DefaultCacheAction_CacheTtlDefault:
		if fv, exists := v.FldValidators["cache_actions.cache_ttl_default"]; exists {
			val := m.GetCacheActions().(*DefaultCacheAction_CacheTtlDefault).CacheTtlDefault
			vOpts := append(opts,
				db.WithValidateField("cache_actions"),
				db.WithValidateField("cache_ttl_default"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DefaultCacheAction_CacheTtlOverride:
		if fv, exists := v.FldValidators["cache_actions.cache_ttl_override"]; exists {
			val := m.GetCacheActions().(*DefaultCacheAction_CacheTtlOverride).CacheTtlOverride
			vOpts := append(opts,
				db.WithValidateField("cache_actions"),
				db.WithValidateField("cache_ttl_override"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DefaultCacheAction_CacheDisabled:
		if fv, exists := v.FldValidators["cache_actions.cache_disabled"]; exists {
			val := m.GetCacheActions().(*DefaultCacheAction_CacheDisabled).CacheDisabled
			vOpts := append(opts,
				db.WithValidateField("cache_actions"),
				db.WithValidateField("cache_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDefaultCacheActionValidator = func() *ValidateDefaultCacheAction {
	v := &ValidateDefaultCacheAction{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCacheActions := v.CacheActionsValidationRuleHandler
	rulesCacheActions := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCacheActions(rulesCacheActions)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DefaultCacheAction.cache_actions: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cache_actions"] = vFn

	vrhCacheActionsCacheTtlDefault := v.CacheActionsCacheTtlDefaultValidationRuleHandler
	rulesCacheActionsCacheTtlDefault := map[string]string{
		"ves.io.schema.rules.string.time_interval": "true",
	}
	vFnMap["cache_actions.cache_ttl_default"], err = vrhCacheActionsCacheTtlDefault(rulesCacheActionsCacheTtlDefault)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DefaultCacheAction.cache_actions_cache_ttl_default: %s", err)
		panic(errMsg)
	}
	vrhCacheActionsCacheTtlOverride := v.CacheActionsCacheTtlOverrideValidationRuleHandler
	rulesCacheActionsCacheTtlOverride := map[string]string{
		"ves.io.schema.rules.string.time_interval": "true",
	}
	vFnMap["cache_actions.cache_ttl_override"], err = vrhCacheActionsCacheTtlOverride(rulesCacheActionsCacheTtlOverride)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DefaultCacheAction.cache_actions_cache_ttl_override: %s", err)
		panic(errMsg)
	}

	v.FldValidators["cache_actions.cache_ttl_default"] = vFnMap["cache_actions.cache_ttl_default"]
	v.FldValidators["cache_actions.cache_ttl_override"] = vFnMap["cache_actions.cache_ttl_override"]

	return v
}()

func DefaultCacheActionValidator() db.Validator {
	return DefaultDefaultCacheActionValidator
}

// augmented methods on protoc/std generated struct

func (m *DelegationLocationSelection) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DelegationLocationSelection) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DelegationLocationSelection) DeepCopy() *DelegationLocationSelection {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DelegationLocationSelection{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DelegationLocationSelection) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DelegationLocationSelection) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DelegationLocationSelectionValidator().Validate(ctx, m, opts...)
}

type ValidateDelegationLocationSelection struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDelegationLocationSelection) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DelegationLocationSelection)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DelegationLocationSelection got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["direct_response_route"]; exists {

		vOpts := append(opts, db.WithValidateField("direct_response_route"))
		if err := fv(ctx, m.GetDirectResponseRoute(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["l7ddos"]; exists {

		vOpts := append(opts, db.WithValidateField("l7ddos"))
		if err := fv(ctx, m.GetL7Ddos(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["redirect_route"]; exists {

		vOpts := append(opts, db.WithValidateField("redirect_route"))
		if err := fv(ctx, m.GetRedirectRoute(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_header_manipulation"]; exists {

		vOpts := append(opts, db.WithValidateField("request_header_manipulation"))
		if err := fv(ctx, m.GetRequestHeaderManipulation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_rewrite"]; exists {

		vOpts := append(opts, db.WithValidateField("request_rewrite"))
		if err := fv(ctx, m.GetRequestRewrite(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_header_manipulation"]; exists {

		vOpts := append(opts, db.WithValidateField("response_header_manipulation"))
		if err := fv(ctx, m.GetResponseHeaderManipulation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["simple_route"]; exists {

		vOpts := append(opts, db.WithValidateField("simple_route"))
		if err := fv(ctx, m.GetSimpleRoute(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["waap"]; exists {

		vOpts := append(opts, db.WithValidateField("waap"))
		if err := fv(ctx, m.GetWaap(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDelegationLocationSelectionValidator = func() *ValidateDelegationLocationSelection {
	v := &ValidateDelegationLocationSelection{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DelegationLocationSelectionValidator() db.Validator {
	return DefaultDelegationLocationSelectionValidator
}

// augmented methods on protoc/std generated struct

func (m *DomainCertificates) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DomainCertificates) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DomainCertificates) DeepCopy() *DomainCertificates {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DomainCertificates{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DomainCertificates) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DomainCertificates) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DomainCertificatesValidator().Validate(ctx, m, opts...)
}

type ValidateDomainCertificates struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDomainCertificates) RsaCertificatesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rsa_certificates")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rsa_certificates")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rsa_certificates")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rsa_certificates")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDomainCertificates) EcdsaCertificatesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for ecdsa_certificates")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ecdsa_certificates")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ecdsa_certificates")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ecdsa_certificates")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDomainCertificates) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DomainCertificates)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DomainCertificates got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ecdsa_certificates"]; exists {
		vOpts := append(opts, db.WithValidateField("ecdsa_certificates"))
		if err := fv(ctx, m.GetEcdsaCertificates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rsa_certificates"]; exists {
		vOpts := append(opts, db.WithValidateField("rsa_certificates"))
		if err := fv(ctx, m.GetRsaCertificates(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDomainCertificatesValidator = func() *ValidateDomainCertificates {
	v := &ValidateDomainCertificates{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRsaCertificates := v.RsaCertificatesValidationRuleHandler
	rulesRsaCertificates := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRsaCertificates(rulesRsaCertificates)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DomainCertificates.rsa_certificates: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rsa_certificates"] = vFn

	vrhEcdsaCertificates := v.EcdsaCertificatesValidationRuleHandler
	rulesEcdsaCertificates := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhEcdsaCertificates(rulesEcdsaCertificates)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DomainCertificates.ecdsa_certificates: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ecdsa_certificates"] = vFn

	return v
}()

func DomainCertificatesValidator() db.Validator {
	return DefaultDomainCertificatesValidator
}

// augmented methods on protoc/std generated struct

func (m *DynamicReverseProxyType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DynamicReverseProxyType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DynamicReverseProxyType) DeepCopy() *DynamicReverseProxyType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DynamicReverseProxyType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DynamicReverseProxyType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DynamicReverseProxyType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DynamicReverseProxyTypeValidator().Validate(ctx, m, opts...)
}

func (m *DynamicReverseProxyType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetResolutionNetworkDRefInfo()

}

func (m *DynamicReverseProxyType) GetResolutionNetworkDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetResolutionNetwork()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("DynamicReverseProxyType.resolution_network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "resolution_network",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetResolutionNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *DynamicReverseProxyType) GetResolutionNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetResolutionNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateDynamicReverseProxyType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDynamicReverseProxyType) ConnectionTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateDynamicReverseProxyType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DynamicReverseProxyType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DynamicReverseProxyType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["connection_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_timeout"))
		if err := fv(ctx, m.GetConnectionTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["resolution_network"]; exists {

		vOpts := append(opts, db.WithValidateField("resolution_network"))
		for idx, item := range m.GetResolutionNetwork() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["resolution_network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("resolution_network_type"))
		if err := fv(ctx, m.GetResolutionNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["resolve_endpoint_dynamically"]; exists {

		vOpts := append(opts, db.WithValidateField("resolve_endpoint_dynamically"))
		if err := fv(ctx, m.GetResolveEndpointDynamically(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDynamicReverseProxyTypeValidator = func() *ValidateDynamicReverseProxyType {
	v := &ValidateDynamicReverseProxyType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhConnectionTimeout := v.ConnectionTimeoutValidationRuleHandler
	rulesConnectionTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhConnectionTimeout(rulesConnectionTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DynamicReverseProxyType.connection_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_timeout"] = vFn

	return v
}()

func DynamicReverseProxyTypeValidator() db.Validator {
	return DefaultDynamicReverseProxyTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GetSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetRequestHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting GetSpecType.request_headers_to_add idx %v", idx)
		}
	}

	for idx, e := range m.GetResponseHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting GetSpecType.response_headers_to_add idx %v", idx)
		}
	}

	if err := m.GetTlsParameters().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.tls_parameters")
	}

	if err := m.GetAuthentication().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.authentication")
	}

	if err := m.GetCdnService().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.cdn_service")
	}

	for idx, e := range m.GetRequestCookiesToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting GetSpecType.request_cookies_to_add idx %v", idx)
		}
	}

	for idx, e := range m.GetResponseCookiesToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting GetSpecType.response_cookies_to_add idx %v", idx)
		}
	}

	return nil
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAdvertisePoliciesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAdvertisePoliciesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetApiSpecDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetApiSpecDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetAuthenticationChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAuthenticationChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetCdnServiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetCdnServiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDnsProxyConfigurationDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDnsProxyConfigurationDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDynamicReverseProxyDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDynamicReverseProxyDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterAllowedPrefixesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRateLimiterAllowedPrefixesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRoutesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRoutesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetSensitiveDataPolicyDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSensitiveDataPolicyDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTlsCertificatesChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTlsCertificatesChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetUserIdentificationDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetUserIdentificationDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWafTypeDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetWafTypeDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetZtnaProxyConfigurationsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetZtnaProxyConfigurationsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GetSpecType) GetAdvertisePoliciesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAdvertisePolicies()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.advertise_policies[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "advertise_policy.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "advertise_policies",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAdvertisePoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetAdvertisePoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "advertise_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: advertise_policy")
	}
	for _, ref := range m.GetAdvertisePolicies() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetApiSpecDRefInfo() ([]db.DRefInfo, error) {
	if m.GetApiSpec() == nil {
		return nil, nil
	}

	drInfos, err := m.GetApiSpec().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetApiSpec().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "api_spec." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetAuthenticationChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAuthenticationChoice() == nil {
		return nil, nil
	}
	switch m.GetAuthenticationChoice().(type) {
	case *GetSpecType_NoAuthentication:

		return nil, nil

	case *GetSpecType_Authentication:

		drInfos, err := m.GetAuthentication().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAuthentication().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "authentication." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetCdnServiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetCdnService() == nil {
		return nil, nil
	}

	drInfos, err := m.GetCdnService().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetCdnService().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "cdn_service." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetDnsProxyConfigurationDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDnsProxyConfiguration() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDnsProxyConfiguration().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDnsProxyConfiguration().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "dns_proxy_configuration." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetDynamicReverseProxyDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDynamicReverseProxy() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDynamicReverseProxy().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDynamicReverseProxy().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "dynamic_reverse_proxy." + dri.DRField
	}
	return drInfos, err

}

func (m *GetSpecType) GetRateLimiterAllowedPrefixesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRateLimiterAllowedPrefixes()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.rate_limiter_allowed_prefixes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "ip_prefix_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter_allowed_prefixes",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRateLimiterAllowedPrefixesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetRateLimiterAllowedPrefixesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "ip_prefix_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: ip_prefix_set")
	}
	for _, ref := range m.GetRateLimiterAllowedPrefixes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GetSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRoutes()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.routes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "route.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "routes",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRoutesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetRoutesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "route.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: route")
	}
	for _, ref := range m.GetRoutes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GetSpecType) GetSensitiveDataPolicyDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetSensitiveDataPolicy()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.sensitive_data_policy[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "sensitive_data_policy.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "sensitive_data_policy",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetSensitiveDataPolicyDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetSensitiveDataPolicyDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "sensitive_data_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: sensitive_data_policy")
	}
	for _, ref := range m.GetSensitiveDataPolicy() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetTlsCertificatesChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTlsCertificatesChoice() == nil {
		return nil, nil
	}
	switch m.GetTlsCertificatesChoice().(type) {
	case *GetSpecType_TlsParameters:

		drInfos, err := m.GetTlsParameters().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTlsParameters().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tls_parameters." + dri.DRField
		}
		return drInfos, err

	case *GetSpecType_TlsCertParams:

		drInfos, err := m.GetTlsCertParams().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTlsCertParams().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tls_cert_params." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *GetSpecType) GetUserIdentificationDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetUserIdentification()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.user_identification[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "user_identification.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "user_identification",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetUserIdentificationDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetUserIdentificationDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "user_identification.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: user_identification")
	}
	for _, ref := range m.GetUserIdentification() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetWafTypeDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWafType() == nil {
		return nil, nil
	}

	drInfos, err := m.GetWafType().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetWafType().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "waf_type." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetZtnaProxyConfigurationsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetZtnaProxyConfigurations() == nil {
		return nil, nil
	}

	drInfos, err := m.GetZtnaProxyConfigurations().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetZtnaProxyConfigurations().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "ztna_proxy_configurations." + dri.DRField
	}
	return drInfos, err

}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) ChallengeTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for challenge_type")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) ServerHeaderChoiceServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_name")
	}
	return oValidatorFn_ServerName, nil
}
func (v *ValidateGetSpecType) ServerHeaderChoiceAppendServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_AppendServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for append_server_name")
	}
	return oValidatorFn_AppendServerName, nil
}

func (v *ValidateGetSpecType) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for routes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) RequestHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for request_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) ResponseHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for response_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) ResponseHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) RequestHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) CustomErrorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapUint32KeyRules(rules)
	itemKeyFn, err := db.NewUint32ValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for custom_errors")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for custom_errors")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[uint32]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for custom_errors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[uint32]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ uint32 ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map custom_errors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items custom_errors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) MaxRequestHeaderSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_request_header_size")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) UserIdentificationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for user_identification")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for user_identification")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated user_identification")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items user_identification")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) RateLimiterAllowedPrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter_allowed_prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter_allowed_prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) CookiesToModifyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cookies_to_modify")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.CookieManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.CookieManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cookies_to_modify")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.CookieManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.CookieManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cookies_to_modify")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cookies_to_modify")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) ConnectionIdleTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_idle_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) RequestCookiesToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for request_cookies_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.CookieValueOption, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.CookieValueOptionValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_cookies_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.CookieValueOption)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.CookieValueOption, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_cookies_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_cookies_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) RequestCookiesToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_cookies_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_cookies_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_cookies_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_cookies_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) ResponseCookiesToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for response_cookies_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.SetCookieValueOption, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.SetCookieValueOptionValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_cookies_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.SetCookieValueOption)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.SetCookieValueOption, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_cookies_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_cookies_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) ResponseCookiesToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_cookies_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_cookies_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_cookies_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_cookies_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) MaxDirectResponseBodySizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_direct_response_body_size")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_location"]; exists {

		vOpts := append(opts, db.WithValidateField("add_location"))
		if err := fv(ctx, m.GetAddLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["advertise_policies"]; exists {

		vOpts := append(opts, db.WithValidateField("advertise_policies"))
		for idx, item := range m.GetAdvertisePolicies() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["api_spec"]; exists {

		vOpts := append(opts, db.WithValidateField("api_spec"))
		if err := fv(ctx, m.GetApiSpec(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetAuthenticationChoice().(type) {
	case *GetSpecType_NoAuthentication:
		if fv, exists := v.FldValidators["authentication_choice.no_authentication"]; exists {
			val := m.GetAuthenticationChoice().(*GetSpecType_NoAuthentication).NoAuthentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("no_authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Authentication:
		if fv, exists := v.FldValidators["authentication_choice.authentication"]; exists {
			val := m.GetAuthenticationChoice().(*GetSpecType_Authentication).Authentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["auto_cert_error_msg"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_error_msg"))
		if err := fv(ctx, m.GetAutoCertErrorMsg(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_info"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_info"))
		if err := fv(ctx, m.GetAutoCertInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["buffer_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("buffer_policy"))
		if err := fv(ctx, m.GetBufferPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cdn_service"]; exists {

		vOpts := append(opts, db.WithValidateField("cdn_service"))
		if err := fv(ctx, m.GetCdnService(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["challenge_type"]; exists {
		val := m.GetChallengeType()
		vOpts := append(opts,
			db.WithValidateField("challenge_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChallengeType().(type) {
	case *GetSpecType_JsChallenge:
		if fv, exists := v.FldValidators["challenge_type.js_challenge"]; exists {
			val := m.GetChallengeType().(*GetSpecType_JsChallenge).JsChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("js_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_CaptchaChallenge:
		if fv, exists := v.FldValidators["challenge_type.captcha_challenge"]; exists {
			val := m.GetChallengeType().(*GetSpecType_CaptchaChallenge).CaptchaChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("captcha_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_NoChallenge:
		if fv, exists := v.FldValidators["challenge_type.no_challenge"]; exists {
			val := m.GetChallengeType().(*GetSpecType_NoChallenge).NoChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("no_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["coalescing_options"]; exists {

		vOpts := append(opts, db.WithValidateField("coalescing_options"))
		if err := fv(ctx, m.GetCoalescingOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["compression_params"]; exists {

		vOpts := append(opts, db.WithValidateField("compression_params"))
		if err := fv(ctx, m.GetCompressionParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connection_idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_idle_timeout"))
		if err := fv(ctx, m.GetConnectionIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cookies_to_modify"]; exists {
		vOpts := append(opts, db.WithValidateField("cookies_to_modify"))
		if err := fv(ctx, m.GetCookiesToModify(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cors_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("cors_policy"))
		if err := fv(ctx, m.GetCorsPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["csrf_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("csrf_policy"))
		if err := fv(ctx, m.GetCsrfPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_errors"]; exists {
		vOpts := append(opts, db.WithValidateField("custom_errors"))
		if err := fv(ctx, m.GetCustomErrors(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetDdosAutoMitigationAction().(type) {
	case *GetSpecType_Block:
		if fv, exists := v.FldValidators["ddos_auto_mitigation_action.block"]; exists {
			val := m.GetDdosAutoMitigationAction().(*GetSpecType_Block).Block
			vOpts := append(opts,
				db.WithValidateField("ddos_auto_mitigation_action"),
				db.WithValidateField("block"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DdosJsChallenge:
		if fv, exists := v.FldValidators["ddos_auto_mitigation_action.ddos_js_challenge"]; exists {
			val := m.GetDdosAutoMitigationAction().(*GetSpecType_DdosJsChallenge).DdosJsChallenge
			vOpts := append(opts,
				db.WithValidateField("ddos_auto_mitigation_action"),
				db.WithValidateField("ddos_js_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_L7DdosActionDefault:
		if fv, exists := v.FldValidators["ddos_auto_mitigation_action.l7_ddos_action_default"]; exists {
			val := m.GetDdosAutoMitigationAction().(*GetSpecType_L7DdosActionDefault).L7DdosActionDefault
			vOpts := append(opts,
				db.WithValidateField("ddos_auto_mitigation_action"),
				db.WithValidateField("l7_ddos_action_default"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_L7DdosActionNone:
		if fv, exists := v.FldValidators["ddos_auto_mitigation_action.l7_ddos_action_none"]; exists {
			val := m.GetDdosAutoMitigationAction().(*GetSpecType_L7DdosActionNone).L7DdosActionNone
			vOpts := append(opts,
				db.WithValidateField("ddos_auto_mitigation_action"),
				db.WithValidateField("l7_ddos_action_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetDefaultLbChoice().(type) {
	case *GetSpecType_NonDefaultLoadbalancer:
		if fv, exists := v.FldValidators["default_lb_choice.non_default_loadbalancer"]; exists {
			val := m.GetDefaultLbChoice().(*GetSpecType_NonDefaultLoadbalancer).NonDefaultLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("default_lb_choice"),
				db.WithValidateField("non_default_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DefaultLoadbalancer:
		if fv, exists := v.FldValidators["default_lb_choice.default_loadbalancer"]; exists {
			val := m.GetDefaultLbChoice().(*GetSpecType_DefaultLoadbalancer).DefaultLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("default_lb_choice"),
				db.WithValidateField("default_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["disable_default_error_pages"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_default_error_pages"))
		if err := fv(ctx, m.GetDisableDefaultErrorPages(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_dns_resolve"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_dns_resolve"))
		if err := fv(ctx, m.GetDisableDnsResolve(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_info"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_info"))
		for idx, item := range m.GetDnsInfo() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["dns_proxy_configuration"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_proxy_configuration"))
		if err := fv(ctx, m.GetDnsProxyConfiguration(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetDnsZoneStateChoice().(type) {
	case *GetSpecType_NotReady:
		if fv, exists := v.FldValidators["dns_zone_state_choice.not_ready"]; exists {
			val := m.GetDnsZoneStateChoice().(*GetSpecType_NotReady).NotReady
			vOpts := append(opts,
				db.WithValidateField("dns_zone_state_choice"),
				db.WithValidateField("not_ready"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Ready:
		if fv, exists := v.FldValidators["dns_zone_state_choice.ready"]; exists {
			val := m.GetDnsZoneStateChoice().(*GetSpecType_Ready).Ready
			vOpts := append(opts,
				db.WithValidateField("dns_zone_state_choice"),
				db.WithValidateField("ready"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domain_cert_map"]; exists {

		vOpts := append(opts, db.WithValidateField("domain_cert_map"))
		for key, value := range m.GetDomainCertMap() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dynamic_reverse_proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("dynamic_reverse_proxy"))
		if err := fv(ctx, m.GetDynamicReverseProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header_transformation_type"]; exists {

		vOpts := append(opts, db.WithValidateField("header_transformation_type"))
		if err := fv(ctx, m.GetHeaderTransformationType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["host_name"]; exists {

		vOpts := append(opts, db.WithValidateField("host_name"))
		if err := fv(ctx, m.GetHostName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_protocol_options"]; exists {

		vOpts := append(opts, db.WithValidateField("http_protocol_options"))
		if err := fv(ctx, m.GetHttpProtocolOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("idle_timeout"))
		if err := fv(ctx, m.GetIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["l7_ddos_rps_threshold"]; exists {

		vOpts := append(opts, db.WithValidateField("l7_ddos_rps_threshold"))
		if err := fv(ctx, m.GetL7DdosRpsThreshold(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["masking_config"]; exists {

		vOpts := append(opts, db.WithValidateField("masking_config"))
		if err := fv(ctx, m.GetMaskingConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_direct_response_body_size"]; exists {

		vOpts := append(opts, db.WithValidateField("max_direct_response_body_size"))
		if err := fv(ctx, m.GetMaxDirectResponseBodySize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_request_header_size"]; exists {

		vOpts := append(opts, db.WithValidateField("max_request_header_size"))
		if err := fv(ctx, m.GetMaxRequestHeaderSize(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetPathNormalizeChoice().(type) {
	case *GetSpecType_EnablePathNormalize:
		if fv, exists := v.FldValidators["path_normalize_choice.enable_path_normalize"]; exists {
			val := m.GetPathNormalizeChoice().(*GetSpecType_EnablePathNormalize).EnablePathNormalize
			vOpts := append(opts,
				db.WithValidateField("path_normalize_choice"),
				db.WithValidateField("enable_path_normalize"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DisablePathNormalize:
		if fv, exists := v.FldValidators["path_normalize_choice.disable_path_normalize"]; exists {
			val := m.GetPathNormalizeChoice().(*GetSpecType_DisablePathNormalize).DisablePathNormalize
			vOpts := append(opts,
				db.WithValidateField("path_normalize_choice"),
				db.WithValidateField("disable_path_normalize"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("proxy"))
		if err := fv(ctx, m.GetProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter_allowed_prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter_allowed_prefixes"))
		if err := fv(ctx, m.GetRateLimiterAllowedPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_cookies_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_cookies_to_add"))
		if err := fv(ctx, m.GetRequestCookiesToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_cookies_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_cookies_to_remove"))
		if err := fv(ctx, m.GetRequestCookiesToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_add"))
		if err := fv(ctx, m.GetRequestHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_remove"))
		if err := fv(ctx, m.GetRequestHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_cookies_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_cookies_to_add"))
		if err := fv(ctx, m.GetResponseCookiesToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_cookies_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_cookies_to_remove"))
		if err := fv(ctx, m.GetResponseCookiesToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_add"))
		if err := fv(ctx, m.GetResponseHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_remove"))
		if err := fv(ctx, m.GetResponseHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["retry_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("retry_policy"))
		if err := fv(ctx, m.GetRetryPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sensitive_data_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("sensitive_data_policy"))
		for idx, item := range m.GetSensitiveDataPolicy() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetServerHeaderChoice().(type) {
	case *GetSpecType_DefaultHeader:
		if fv, exists := v.FldValidators["server_header_choice.default_header"]; exists {
			val := m.GetServerHeaderChoice().(*GetSpecType_DefaultHeader).DefaultHeader
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("default_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_ServerName:
		if fv, exists := v.FldValidators["server_header_choice.server_name"]; exists {
			val := m.GetServerHeaderChoice().(*GetSpecType_ServerName).ServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_AppendServerName:
		if fv, exists := v.FldValidators["server_header_choice.append_server_name"]; exists {
			val := m.GetServerHeaderChoice().(*GetSpecType_AppendServerName).AppendServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("append_server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_PassThrough:
		if fv, exists := v.FldValidators["server_header_choice.pass_through"]; exists {
			val := m.GetServerHeaderChoice().(*GetSpecType_PassThrough).PassThrough
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("pass_through"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["slow_ddos_mitigation"]; exists {

		vOpts := append(opts, db.WithValidateField("slow_ddos_mitigation"))
		if err := fv(ctx, m.GetSlowDdosMitigation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetStrictSniHostHeaderCheckChoice().(type) {
	case *GetSpecType_EnableStrictSniHostHeaderCheck:
		if fv, exists := v.FldValidators["strict_sni_host_header_check_choice.enable_strict_sni_host_header_check"]; exists {
			val := m.GetStrictSniHostHeaderCheckChoice().(*GetSpecType_EnableStrictSniHostHeaderCheck).EnableStrictSniHostHeaderCheck
			vOpts := append(opts,
				db.WithValidateField("strict_sni_host_header_check_choice"),
				db.WithValidateField("enable_strict_sni_host_header_check"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_AdditionalDomains:
		if fv, exists := v.FldValidators["strict_sni_host_header_check_choice.additional_domains"]; exists {
			val := m.GetStrictSniHostHeaderCheckChoice().(*GetSpecType_AdditionalDomains).AdditionalDomains
			vOpts := append(opts,
				db.WithValidateField("strict_sni_host_header_check_choice"),
				db.WithValidateField("additional_domains"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["temporary_user_blocking"]; exists {

		vOpts := append(opts, db.WithValidateField("temporary_user_blocking"))
		if err := fv(ctx, m.GetTemporaryUserBlocking(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetTlsCertificatesChoice().(type) {
	case *GetSpecType_TlsParameters:
		if fv, exists := v.FldValidators["tls_certificates_choice.tls_parameters"]; exists {
			val := m.GetTlsCertificatesChoice().(*GetSpecType_TlsParameters).TlsParameters
			vOpts := append(opts,
				db.WithValidateField("tls_certificates_choice"),
				db.WithValidateField("tls_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_TlsCertParams:
		if fv, exists := v.FldValidators["tls_certificates_choice.tls_cert_params"]; exists {
			val := m.GetTlsCertificatesChoice().(*GetSpecType_TlsCertParams).TlsCertParams
			vOpts := append(opts,
				db.WithValidateField("tls_certificates_choice"),
				db.WithValidateField("tls_cert_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_identification"]; exists {
		vOpts := append(opts, db.WithValidateField("user_identification"))
		if err := fv(ctx, m.GetUserIdentification(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["waf_type"]; exists {

		vOpts := append(opts, db.WithValidateField("waf_type"))
		if err := fv(ctx, m.GetWafType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ztna_proxy_configurations"]; exists {

		vOpts := append(opts, db.WithValidateField("ztna_proxy_configurations"))
		if err := fv(ctx, m.GetZtnaProxyConfigurations(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChallengeType := v.ChallengeTypeValidationRuleHandler
	rulesChallengeType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChallengeType(rulesChallengeType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.challenge_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["challenge_type"] = vFn

	vrhServerHeaderChoiceServerName := v.ServerHeaderChoiceServerNameValidationRuleHandler
	rulesServerHeaderChoiceServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.server_name"], err = vrhServerHeaderChoiceServerName(rulesServerHeaderChoiceServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GetSpecType.server_header_choice_server_name: %s", err)
		panic(errMsg)
	}
	vrhServerHeaderChoiceAppendServerName := v.ServerHeaderChoiceAppendServerNameValidationRuleHandler
	rulesServerHeaderChoiceAppendServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.append_server_name"], err = vrhServerHeaderChoiceAppendServerName(rulesServerHeaderChoiceAppendServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GetSpecType.server_header_choice_append_server_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["server_header_choice.server_name"] = vFnMap["server_header_choice.server_name"]
	v.FldValidators["server_header_choice.append_server_name"] = vFnMap["server_header_choice.append_server_name"]

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.repeated.items.string.vh_domain": "true",
		"ves.io.schema.rules.repeated.max_items":              "33",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "256",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	vrhRequestHeadersToAdd := v.RequestHeadersToAddValidationRuleHandler
	rulesRequestHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToAdd(rulesRequestHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.request_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_add"] = vFn

	vrhResponseHeadersToAdd := v.ResponseHeadersToAddValidationRuleHandler
	rulesResponseHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToAdd(rulesResponseHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.response_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_add"] = vFn

	vrhResponseHeadersToRemove := v.ResponseHeadersToRemoveValidationRuleHandler
	rulesResponseHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToRemove(rulesResponseHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.response_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_remove"] = vFn

	vrhRequestHeadersToRemove := v.RequestHeadersToRemoveValidationRuleHandler
	rulesRequestHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToRemove(rulesRequestHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.request_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_remove"] = vFn

	vrhCustomErrors := v.CustomErrorsValidationRuleHandler
	rulesCustomErrors := map[string]string{
		"ves.io.schema.rules.map.keys.uint32.gte":       "3",
		"ves.io.schema.rules.map.keys.uint32.lte":       "599",
		"ves.io.schema.rules.map.max_pairs":             "16",
		"ves.io.schema.rules.map.values.string.max_len": "65536",
		"ves.io.schema.rules.map.values.string.uri_ref": "true",
	}
	vFn, err = vrhCustomErrors(rulesCustomErrors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.custom_errors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_errors"] = vFn

	vrhMaxRequestHeaderSize := v.MaxRequestHeaderSizeValidationRuleHandler
	rulesMaxRequestHeaderSize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "96",
	}
	vFn, err = vrhMaxRequestHeaderSize(rulesMaxRequestHeaderSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.max_request_header_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_request_header_size"] = vFn

	vrhUserIdentification := v.UserIdentificationValidationRuleHandler
	rulesUserIdentification := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhUserIdentification(rulesUserIdentification)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.user_identification: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user_identification"] = vFn

	vrhRateLimiterAllowedPrefixes := v.RateLimiterAllowedPrefixesValidationRuleHandler
	rulesRateLimiterAllowedPrefixes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhRateLimiterAllowedPrefixes(rulesRateLimiterAllowedPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.rate_limiter_allowed_prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter_allowed_prefixes"] = vFn

	vrhCookiesToModify := v.CookiesToModifyValidationRuleHandler
	rulesCookiesToModify := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhCookiesToModify(rulesCookiesToModify)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.cookies_to_modify: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookies_to_modify"] = vFn

	vrhConnectionIdleTimeout := v.ConnectionIdleTimeoutValidationRuleHandler
	rulesConnectionIdleTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhConnectionIdleTimeout(rulesConnectionIdleTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.connection_idle_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_idle_timeout"] = vFn

	vrhRequestCookiesToAdd := v.RequestCookiesToAddValidationRuleHandler
	rulesRequestCookiesToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestCookiesToAdd(rulesRequestCookiesToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.request_cookies_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_cookies_to_add"] = vFn

	vrhRequestCookiesToRemove := v.RequestCookiesToRemoveValidationRuleHandler
	rulesRequestCookiesToRemove := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhRequestCookiesToRemove(rulesRequestCookiesToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.request_cookies_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_cookies_to_remove"] = vFn

	vrhResponseCookiesToAdd := v.ResponseCookiesToAddValidationRuleHandler
	rulesResponseCookiesToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseCookiesToAdd(rulesResponseCookiesToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.response_cookies_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_cookies_to_add"] = vFn

	vrhResponseCookiesToRemove := v.ResponseCookiesToRemoveValidationRuleHandler
	rulesResponseCookiesToRemove := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhResponseCookiesToRemove(rulesResponseCookiesToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.response_cookies_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_cookies_to_remove"] = vFn

	vrhMaxDirectResponseBodySize := v.MaxDirectResponseBodySizeValidationRuleHandler
	rulesMaxDirectResponseBodySize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "65536",
	}
	vFn, err = vrhMaxDirectResponseBodySize(rulesMaxDirectResponseBodySize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.max_direct_response_body_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_direct_response_body_size"] = vFn

	v.FldValidators["authentication_choice.authentication"] = AuthenticationDetailsValidator().Validate

	v.FldValidators["challenge_type.js_challenge"] = JavascriptChallengeTypeValidator().Validate
	v.FldValidators["challenge_type.captcha_challenge"] = CaptchaChallengeTypeValidator().Validate

	v.FldValidators["ddos_auto_mitigation_action.ddos_js_challenge"] = JavascriptChallengeTypeValidator().Validate

	v.FldValidators["strict_sni_host_header_check_choice.additional_domains"] = ves_io_schema.DomainNameListValidator().Validate

	v.FldValidators["tls_certificates_choice.tls_parameters"] = ves_io_schema.DownstreamTlsParamsTypeValidator().Validate
	v.FldValidators["tls_certificates_choice.tls_cert_params"] = ves_io_schema.CertificateParamsTypeValidator().Validate

	v.FldValidators["buffer_policy"] = ves_io_schema.BufferConfigTypeValidator().Validate

	v.FldValidators["cors_policy"] = ves_io_schema.CorsPolicyValidator().Validate

	v.FldValidators["waf_type"] = ves_io_schema.WafTypeValidator().Validate

	v.FldValidators["dynamic_reverse_proxy"] = DynamicReverseProxyTypeValidator().Validate

	v.FldValidators["compression_params"] = CompressionTypeValidator().Validate

	v.FldValidators["retry_policy"] = ves_io_schema.RetryPolicyTypeValidator().Validate

	v.FldValidators["temporary_user_blocking"] = TemporaryUserBlockingTypeValidator().Validate

	v.FldValidators["cdn_service"] = CdnServiceTypeValidator().Validate

	v.FldValidators["header_transformation_type"] = ves_io_schema.HeaderTransformationTypeValidator().Validate

	v.FldValidators["csrf_policy"] = ves_io_schema.CsrfPolicyValidator().Validate

	v.FldValidators["slow_ddos_mitigation"] = SlowDDoSMitigationValidator().Validate

	v.FldValidators["api_spec"] = ApiSpecValidator().Validate

	v.FldValidators["domain_cert_map"] = DomainCertificatesValidator().Validate

	v.FldValidators["http_protocol_options"] = HttpProtocolOptionsValidator().Validate

	v.FldValidators["coalescing_options"] = ves_io_schema.TLSCoalescingOptionsValidator().Validate

	v.FldValidators["dns_info"] = ves_io_schema_virtual_host_dns_info.DnsInfoValidator().Validate

	v.FldValidators["ztna_proxy_configurations"] = ZtnaProxyConfigurationValidator().Validate

	v.FldValidators["dns_proxy_configuration"] = DNSProxyConfigurationValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GlobalSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetRequestHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting GlobalSpecType.request_headers_to_add idx %v", idx)
		}
	}

	for idx, e := range m.GetResponseHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting GlobalSpecType.response_headers_to_add idx %v", idx)
		}
	}

	if err := m.GetTlsParameters().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.tls_parameters")
	}

	if err := m.GetTlsIntercept().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.tls_intercept")
	}

	if err := m.GetAuthentication().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.authentication")
	}

	if err := m.GetCdnService().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.cdn_service")
	}

	for idx, e := range m.GetRequestCookiesToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting GlobalSpecType.request_cookies_to_add idx %v", idx)
		}
	}

	for idx, e := range m.GetResponseCookiesToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting GlobalSpecType.response_cookies_to_add idx %v", idx)
		}
	}

	if err := m.GetBotDefense().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.bot_defense")
	}

	return nil
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAdvertisePoliciesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAdvertisePoliciesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetApiSpecDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetApiSpecDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetAuthenticationChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAuthenticationChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetBotDefenseChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetBotDefenseChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetCdnServiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetCdnServiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetChallengeTypeDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetChallengeTypeDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDnsDomainsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDnsDomainsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDnsProxyConfigurationDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDnsProxyConfigurationDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDnsZonesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDnsZonesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDownstreamCosDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDownstreamCosDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDynamicReverseProxyDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDynamicReverseProxyDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetFastAclDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetFastAclDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetJwtDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetJwtDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetL7AclDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetL7AclDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetMaliciousUserMitigationDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetMaliciousUserMitigationDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRateLimiterDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterAllowedPrefixesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRateLimiterAllowedPrefixesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRoutesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRoutesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetSensitiveDataPolicyDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSensitiveDataPolicyDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetServicePolicySetsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetServicePolicySetsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTlsCertificatesChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTlsCertificatesChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetUserIdentificationDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetUserIdentificationDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWafExclusionPolicyDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetWafExclusionPolicyDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWafTypeDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetWafTypeDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetZtnaProxyConfigurationsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetZtnaProxyConfigurationsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GlobalSpecType) GetAdvertisePoliciesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAdvertisePolicies()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.advertise_policies[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "advertise_policy.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "advertise_policies",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAdvertisePoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetAdvertisePoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "advertise_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: advertise_policy")
	}
	for _, ref := range m.GetAdvertisePolicies() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetApiSpecDRefInfo() ([]db.DRefInfo, error) {
	if m.GetApiSpec() == nil {
		return nil, nil
	}

	drInfos, err := m.GetApiSpec().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetApiSpec().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "api_spec." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetAuthenticationChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAuthenticationChoice() == nil {
		return nil, nil
	}
	switch m.GetAuthenticationChoice().(type) {
	case *GlobalSpecType_NoAuthentication:

		return nil, nil

	case *GlobalSpecType_Authentication:

		drInfos, err := m.GetAuthentication().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAuthentication().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "authentication." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetBotDefenseChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetBotDefenseChoice() == nil {
		return nil, nil
	}
	switch m.GetBotDefenseChoice().(type) {
	case *GlobalSpecType_DisableBotDefense:

		return nil, nil

	case *GlobalSpecType_BotDefense:

		drInfos, err := m.GetBotDefense().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetBotDefense().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "bot_defense." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetCdnServiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetCdnService() == nil {
		return nil, nil
	}

	drInfos, err := m.GetCdnService().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetCdnService().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "cdn_service." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetChallengeTypeDRefInfo() ([]db.DRefInfo, error) {
	if m.GetChallengeType() == nil {
		return nil, nil
	}
	switch m.GetChallengeType().(type) {
	case *GlobalSpecType_JsChallenge:

		return nil, nil

	case *GlobalSpecType_CaptchaChallenge:

		return nil, nil

	case *GlobalSpecType_NoChallenge:

		return nil, nil

	case *GlobalSpecType_PolicyBasedChallenge:

		drInfos, err := m.GetPolicyBasedChallenge().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetPolicyBasedChallenge().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "policy_based_challenge." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *GlobalSpecType) GetDnsDomainsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetDnsDomains()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.dns_domains[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "dns_domain.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "dns_domains",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetDnsDomainsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetDnsDomainsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "dns_domain.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: dns_domain")
	}
	for _, ref := range m.GetDnsDomains() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetDnsProxyConfigurationDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDnsProxyConfiguration() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDnsProxyConfiguration().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDnsProxyConfiguration().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "dns_proxy_configuration." + dri.DRField
	}
	return drInfos, err

}

func (m *GlobalSpecType) GetDnsZonesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetDnsZones()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.dns_zones[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "dns_zone.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "dns_zones",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetDnsZonesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetDnsZonesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "dns_zone.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: dns_zone")
	}
	for _, ref := range m.GetDnsZones() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetDownstreamCosDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetDownstreamCos()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.downstream_cos[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "downstream_cos.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "downstream_cos",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetDownstreamCosDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetDownstreamCosDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "downstream_cos.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: downstream_cos")
	}
	for _, ref := range m.GetDownstreamCos() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetDynamicReverseProxyDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDynamicReverseProxy() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDynamicReverseProxy().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDynamicReverseProxy().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "dynamic_reverse_proxy." + dri.DRField
	}
	return drInfos, err

}

func (m *GlobalSpecType) GetFastAclDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetFastAcl()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.fast_acl[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "fast_acl.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "fast_acl",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetFastAclDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetFastAclDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "fast_acl.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: fast_acl")
	}
	for _, ref := range m.GetFastAcl() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetJwtDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetJwt()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.jwt[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "jwt.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "jwt",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetJwtDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetJwtDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "jwt.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: jwt")
	}
	for _, ref := range m.GetJwt() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetL7AclDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetL7Acl()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.l7_acl[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "l7_acl.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "l7_acl",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetL7AclDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetL7AclDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "l7_acl.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: l7_acl")
	}
	for _, ref := range m.GetL7Acl() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetMaliciousUserMitigationDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetMaliciousUserMitigation()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.malicious_user_mitigation[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "malicious_user_mitigation.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "malicious_user_mitigation",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetMaliciousUserMitigationDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetMaliciousUserMitigationDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "malicious_user_mitigation.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: malicious_user_mitigation")
	}
	for _, ref := range m.GetMaliciousUserMitigation() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetRateLimiterDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRateLimiter()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.rate_limiter[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "rate_limiter.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRateLimiterDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetRateLimiterDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "rate_limiter.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: rate_limiter")
	}
	for _, ref := range m.GetRateLimiter() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetRateLimiterAllowedPrefixesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRateLimiterAllowedPrefixes()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.rate_limiter_allowed_prefixes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "ip_prefix_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter_allowed_prefixes",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRateLimiterAllowedPrefixesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetRateLimiterAllowedPrefixesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "ip_prefix_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: ip_prefix_set")
	}
	for _, ref := range m.GetRateLimiterAllowedPrefixes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRoutes()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.routes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "route.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "routes",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRoutesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetRoutesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "route.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: route")
	}
	for _, ref := range m.GetRoutes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetSensitiveDataPolicyDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetSensitiveDataPolicy()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.sensitive_data_policy[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "sensitive_data_policy.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "sensitive_data_policy",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetSensitiveDataPolicyDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetSensitiveDataPolicyDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "sensitive_data_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: sensitive_data_policy")
	}
	for _, ref := range m.GetSensitiveDataPolicy() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetServicePolicySetsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetServicePolicySets()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.service_policy_sets[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "service_policy_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "service_policy_sets",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetServicePolicySetsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetServicePolicySetsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "service_policy_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: service_policy_set")
	}
	for _, ref := range m.GetServicePolicySets() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetTlsCertificatesChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTlsCertificatesChoice() == nil {
		return nil, nil
	}
	switch m.GetTlsCertificatesChoice().(type) {
	case *GlobalSpecType_TlsParameters:

		drInfos, err := m.GetTlsParameters().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTlsParameters().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tls_parameters." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_TlsCertParams:

		drInfos, err := m.GetTlsCertParams().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTlsCertParams().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tls_cert_params." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *GlobalSpecType) GetUserIdentificationDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetUserIdentification()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.user_identification[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "user_identification.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "user_identification",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetUserIdentificationDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetUserIdentificationDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "user_identification.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: user_identification")
	}
	for _, ref := range m.GetUserIdentification() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetWafExclusionPolicyDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetWafExclusionPolicy()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.waf_exclusion_policy[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "waf_exclusion_policy.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "waf_exclusion_policy",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetWafExclusionPolicyDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetWafExclusionPolicyDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "waf_exclusion_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: waf_exclusion_policy")
	}
	for _, ref := range m.GetWafExclusionPolicy() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetWafTypeDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWafType() == nil {
		return nil, nil
	}

	drInfos, err := m.GetWafType().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetWafType().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "waf_type." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetZtnaProxyConfigurationsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetZtnaProxyConfigurations() == nil {
		return nil, nil
	}

	drInfos, err := m.GetZtnaProxyConfigurations().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetZtnaProxyConfigurations().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "ztna_proxy_configurations." + dri.DRField
	}
	return drInfos, err

}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) ChallengeTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for challenge_type")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ServerHeaderChoiceServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_name")
	}
	return oValidatorFn_ServerName, nil
}
func (v *ValidateGlobalSpecType) ServerHeaderChoiceAppendServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_AppendServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for append_server_name")
	}
	return oValidatorFn_AppendServerName, nil
}

func (v *ValidateGlobalSpecType) TrustClientIpHeadersChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for trust_client_ip_headers_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for routes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) RequestHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for request_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ResponseHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for response_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ResponseHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) RequestHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) CustomErrorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapUint32KeyRules(rules)
	itemKeyFn, err := db.NewUint32ValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for custom_errors")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for custom_errors")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[uint32]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for custom_errors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[uint32]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ uint32 ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map custom_errors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items custom_errors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) MaxRequestHeaderSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_request_header_size")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) UserIdentificationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for user_identification")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for user_identification")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated user_identification")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items user_identification")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) RateLimiterValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rate_limiter")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) RateLimiterAllowedPrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter_allowed_prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter_allowed_prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) MaliciousUserMitigationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for malicious_user_mitigation")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for malicious_user_mitigation")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated malicious_user_mitigation")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items malicious_user_mitigation")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) CookiesToModifyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cookies_to_modify")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.CookieManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.CookieManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cookies_to_modify")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.CookieManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.CookieManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cookies_to_modify")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cookies_to_modify")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ConnectionIdleTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_idle_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DownstreamCosValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for downstream_cos")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for downstream_cos")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated downstream_cos")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items downstream_cos")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) RequestCookiesToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for request_cookies_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.CookieValueOption, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.CookieValueOptionValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_cookies_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.CookieValueOption)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.CookieValueOption, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_cookies_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_cookies_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) RequestCookiesToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_cookies_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_cookies_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_cookies_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_cookies_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ResponseCookiesToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for response_cookies_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.SetCookieValueOption, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.SetCookieValueOptionValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_cookies_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.SetCookieValueOption)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.SetCookieValueOption, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_cookies_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_cookies_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ResponseCookiesToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_cookies_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_cookies_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_cookies_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_cookies_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) WafExclusionPolicyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for waf_exclusion_policy")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for waf_exclusion_policy")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated waf_exclusion_policy")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items waf_exclusion_policy")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DnsDomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for dns_domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for dns_domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated dns_domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items dns_domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) UserDomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for user_domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for user_domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated user_domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items user_domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ServicePolicySetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for service_policy_sets")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for service_policy_sets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated service_policy_sets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items service_policy_sets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) FastAclValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for fast_acl")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for fast_acl")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated fast_acl")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items fast_acl")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) L7AclValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for l7_acl")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for l7_acl")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated l7_acl")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items l7_acl")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DnsZonesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for dns_zones")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for dns_zones")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated dns_zones")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items dns_zones")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) MaxDirectResponseBodySizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_direct_response_body_size")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_location"]; exists {

		vOpts := append(opts, db.WithValidateField("add_location"))
		if err := fv(ctx, m.GetAddLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["advertise_on_public"]; exists {

		vOpts := append(opts, db.WithValidateField("advertise_on_public"))
		if err := fv(ctx, m.GetAdvertiseOnPublic(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["advertise_policies"]; exists {

		vOpts := append(opts, db.WithValidateField("advertise_policies"))
		for idx, item := range m.GetAdvertisePolicies() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["api_spec"]; exists {

		vOpts := append(opts, db.WithValidateField("api_spec"))
		if err := fv(ctx, m.GetApiSpec(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetAuthenticationChoice().(type) {
	case *GlobalSpecType_NoAuthentication:
		if fv, exists := v.FldValidators["authentication_choice.no_authentication"]; exists {
			val := m.GetAuthenticationChoice().(*GlobalSpecType_NoAuthentication).NoAuthentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("no_authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Authentication:
		if fv, exists := v.FldValidators["authentication_choice.authentication"]; exists {
			val := m.GetAuthenticationChoice().(*GlobalSpecType_Authentication).Authentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["auto_cert"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert"))
		if err := fv(ctx, m.GetAutoCert(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_error_msg"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_error_msg"))
		if err := fv(ctx, m.GetAutoCertErrorMsg(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_info"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_info"))
		if err := fv(ctx, m.GetAutoCertInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_state"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_state"))
		if err := fv(ctx, m.GetAutoCertState(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetBotDefenseChoice().(type) {
	case *GlobalSpecType_DisableBotDefense:
		if fv, exists := v.FldValidators["bot_defense_choice.disable_bot_defense"]; exists {
			val := m.GetBotDefenseChoice().(*GlobalSpecType_DisableBotDefense).DisableBotDefense
			vOpts := append(opts,
				db.WithValidateField("bot_defense_choice"),
				db.WithValidateField("disable_bot_defense"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_BotDefense:
		if fv, exists := v.FldValidators["bot_defense_choice.bot_defense"]; exists {
			val := m.GetBotDefenseChoice().(*GlobalSpecType_BotDefense).BotDefense
			vOpts := append(opts,
				db.WithValidateField("bot_defense_choice"),
				db.WithValidateField("bot_defense"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["buffer_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("buffer_policy"))
		if err := fv(ctx, m.GetBufferPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cdn_service"]; exists {

		vOpts := append(opts, db.WithValidateField("cdn_service"))
		if err := fv(ctx, m.GetCdnService(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["challenge_type"]; exists {
		val := m.GetChallengeType()
		vOpts := append(opts,
			db.WithValidateField("challenge_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChallengeType().(type) {
	case *GlobalSpecType_JsChallenge:
		if fv, exists := v.FldValidators["challenge_type.js_challenge"]; exists {
			val := m.GetChallengeType().(*GlobalSpecType_JsChallenge).JsChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("js_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_CaptchaChallenge:
		if fv, exists := v.FldValidators["challenge_type.captcha_challenge"]; exists {
			val := m.GetChallengeType().(*GlobalSpecType_CaptchaChallenge).CaptchaChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("captcha_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_NoChallenge:
		if fv, exists := v.FldValidators["challenge_type.no_challenge"]; exists {
			val := m.GetChallengeType().(*GlobalSpecType_NoChallenge).NoChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("no_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_PolicyBasedChallenge:
		if fv, exists := v.FldValidators["challenge_type.policy_based_challenge"]; exists {
			val := m.GetChallengeType().(*GlobalSpecType_PolicyBasedChallenge).PolicyBasedChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("policy_based_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["check_ip_reputation"]; exists {

		vOpts := append(opts, db.WithValidateField("check_ip_reputation"))
		if err := fv(ctx, m.GetCheckIpReputation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coalescing_options"]; exists {

		vOpts := append(opts, db.WithValidateField("coalescing_options"))
		if err := fv(ctx, m.GetCoalescingOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["compression_params"]; exists {

		vOpts := append(opts, db.WithValidateField("compression_params"))
		if err := fv(ctx, m.GetCompressionParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connection_idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_idle_timeout"))
		if err := fv(ctx, m.GetConnectionIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cookies_to_modify"]; exists {
		vOpts := append(opts, db.WithValidateField("cookies_to_modify"))
		if err := fv(ctx, m.GetCookiesToModify(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cors_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("cors_policy"))
		if err := fv(ctx, m.GetCorsPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["csrf_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("csrf_policy"))
		if err := fv(ctx, m.GetCsrfPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_cert_expiry"]; exists {

		vOpts := append(opts, db.WithValidateField("custom_cert_expiry"))
		if err := fv(ctx, m.GetCustomCertExpiry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_errors"]; exists {
		vOpts := append(opts, db.WithValidateField("custom_errors"))
		if err := fv(ctx, m.GetCustomErrors(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetDdosAutoMitigationAction().(type) {
	case *GlobalSpecType_Block:
		if fv, exists := v.FldValidators["ddos_auto_mitigation_action.block"]; exists {
			val := m.GetDdosAutoMitigationAction().(*GlobalSpecType_Block).Block
			vOpts := append(opts,
				db.WithValidateField("ddos_auto_mitigation_action"),
				db.WithValidateField("block"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DdosJsChallenge:
		if fv, exists := v.FldValidators["ddos_auto_mitigation_action.ddos_js_challenge"]; exists {
			val := m.GetDdosAutoMitigationAction().(*GlobalSpecType_DdosJsChallenge).DdosJsChallenge
			vOpts := append(opts,
				db.WithValidateField("ddos_auto_mitigation_action"),
				db.WithValidateField("ddos_js_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_L7DdosActionDefault:
		if fv, exists := v.FldValidators["ddos_auto_mitigation_action.l7_ddos_action_default"]; exists {
			val := m.GetDdosAutoMitigationAction().(*GlobalSpecType_L7DdosActionDefault).L7DdosActionDefault
			vOpts := append(opts,
				db.WithValidateField("ddos_auto_mitigation_action"),
				db.WithValidateField("l7_ddos_action_default"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_L7DdosActionNone:
		if fv, exists := v.FldValidators["ddos_auto_mitigation_action.l7_ddos_action_none"]; exists {
			val := m.GetDdosAutoMitigationAction().(*GlobalSpecType_L7DdosActionNone).L7DdosActionNone
			vOpts := append(opts,
				db.WithValidateField("ddos_auto_mitigation_action"),
				db.WithValidateField("l7_ddos_action_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetDefaultLbChoice().(type) {
	case *GlobalSpecType_NonDefaultLoadbalancer:
		if fv, exists := v.FldValidators["default_lb_choice.non_default_loadbalancer"]; exists {
			val := m.GetDefaultLbChoice().(*GlobalSpecType_NonDefaultLoadbalancer).NonDefaultLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("default_lb_choice"),
				db.WithValidateField("non_default_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DefaultLoadbalancer:
		if fv, exists := v.FldValidators["default_lb_choice.default_loadbalancer"]; exists {
			val := m.GetDefaultLbChoice().(*GlobalSpecType_DefaultLoadbalancer).DefaultLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("default_lb_choice"),
				db.WithValidateField("default_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["disable_default_error_pages"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_default_error_pages"))
		if err := fv(ctx, m.GetDisableDefaultErrorPages(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_dns_resolve"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_dns_resolve"))
		if err := fv(ctx, m.GetDisableDnsResolve(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_domains"]; exists {
		vOpts := append(opts, db.WithValidateField("dns_domains"))
		if err := fv(ctx, m.GetDnsDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_info"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_info"))
		for idx, item := range m.GetDnsInfo() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["dns_proxy_configuration"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_proxy_configuration"))
		if err := fv(ctx, m.GetDnsProxyConfiguration(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_volterra_managed"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_volterra_managed"))
		if err := fv(ctx, m.GetDnsVolterraManaged(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetDnsZoneStateChoice().(type) {
	case *GlobalSpecType_NotReady:
		if fv, exists := v.FldValidators["dns_zone_state_choice.not_ready"]; exists {
			val := m.GetDnsZoneStateChoice().(*GlobalSpecType_NotReady).NotReady
			vOpts := append(opts,
				db.WithValidateField("dns_zone_state_choice"),
				db.WithValidateField("not_ready"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Ready:
		if fv, exists := v.FldValidators["dns_zone_state_choice.ready"]; exists {
			val := m.GetDnsZoneStateChoice().(*GlobalSpecType_Ready).Ready
			vOpts := append(opts,
				db.WithValidateField("dns_zone_state_choice"),
				db.WithValidateField("ready"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["dns_zones"]; exists {
		vOpts := append(opts, db.WithValidateField("dns_zones"))
		if err := fv(ctx, m.GetDnsZones(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domain_cert_map"]; exists {

		vOpts := append(opts, db.WithValidateField("domain_cert_map"))
		for key, value := range m.GetDomainCertMap() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["downstream_cos"]; exists {
		vOpts := append(opts, db.WithValidateField("downstream_cos"))
		if err := fv(ctx, m.GetDownstreamCos(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dynamic_reverse_proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("dynamic_reverse_proxy"))
		if err := fv(ctx, m.GetDynamicReverseProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["enable_malware_protection"]; exists {

		vOpts := append(opts, db.WithValidateField("enable_malware_protection"))
		if err := fv(ctx, m.GetEnableMalwareProtection(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["enable_per_packet_load_balancing"]; exists {

		vOpts := append(opts, db.WithValidateField("enable_per_packet_load_balancing"))
		if err := fv(ctx, m.GetEnablePerPacketLoadBalancing(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fast_acl"]; exists {
		vOpts := append(opts, db.WithValidateField("fast_acl"))
		if err := fv(ctx, m.GetFastAcl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header_transformation_type"]; exists {

		vOpts := append(opts, db.WithValidateField("header_transformation_type"))
		if err := fv(ctx, m.GetHeaderTransformationType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["host_name"]; exists {

		vOpts := append(opts, db.WithValidateField("host_name"))
		if err := fv(ctx, m.GetHostName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_protocol_options"]; exists {

		vOpts := append(opts, db.WithValidateField("http_protocol_options"))
		if err := fv(ctx, m.GetHttpProtocolOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_redirect_options"]; exists {

		vOpts := append(opts, db.WithValidateField("http_redirect_options"))
		if err := fv(ctx, m.GetHttpRedirectOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("idle_timeout"))
		if err := fv(ctx, m.GetIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["javascript_info"]; exists {

		vOpts := append(opts, db.WithValidateField("javascript_info"))
		if err := fv(ctx, m.GetJavascriptInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["jwt"]; exists {

		vOpts := append(opts, db.WithValidateField("jwt"))
		for idx, item := range m.GetJwt() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["l7_acl"]; exists {
		vOpts := append(opts, db.WithValidateField("l7_acl"))
		if err := fv(ctx, m.GetL7Acl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["l7_ddos_rps_threshold"]; exists {

		vOpts := append(opts, db.WithValidateField("l7_ddos_rps_threshold"))
		if err := fv(ctx, m.GetL7DdosRpsThreshold(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["loadbalancer_algorithm"]; exists {

		vOpts := append(opts, db.WithValidateField("loadbalancer_algorithm"))
		if err := fv(ctx, m.GetLoadbalancerAlgorithm(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["malicious_user_mitigation"]; exists {
		vOpts := append(opts, db.WithValidateField("malicious_user_mitigation"))
		if err := fv(ctx, m.GetMaliciousUserMitigation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["masking_config"]; exists {

		vOpts := append(opts, db.WithValidateField("masking_config"))
		if err := fv(ctx, m.GetMaskingConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_direct_response_body_size"]; exists {

		vOpts := append(opts, db.WithValidateField("max_direct_response_body_size"))
		if err := fv(ctx, m.GetMaxDirectResponseBodySize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_request_header_size"]; exists {

		vOpts := append(opts, db.WithValidateField("max_request_header_size"))
		if err := fv(ctx, m.GetMaxRequestHeaderSize(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetPathNormalizeChoice().(type) {
	case *GlobalSpecType_EnablePathNormalize:
		if fv, exists := v.FldValidators["path_normalize_choice.enable_path_normalize"]; exists {
			val := m.GetPathNormalizeChoice().(*GlobalSpecType_EnablePathNormalize).EnablePathNormalize
			vOpts := append(opts,
				db.WithValidateField("path_normalize_choice"),
				db.WithValidateField("enable_path_normalize"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DisablePathNormalize:
		if fv, exists := v.FldValidators["path_normalize_choice.disable_path_normalize"]; exists {
			val := m.GetPathNormalizeChoice().(*GlobalSpecType_DisablePathNormalize).DisablePathNormalize
			vOpts := append(opts,
				db.WithValidateField("path_normalize_choice"),
				db.WithValidateField("disable_path_normalize"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("proxy"))
		if err := fv(ctx, m.GetProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter"))
		if err := fv(ctx, m.GetRateLimiter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter_allowed_prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter_allowed_prefixes"))
		if err := fv(ctx, m.GetRateLimiterAllowedPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_cookies_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_cookies_to_add"))
		if err := fv(ctx, m.GetRequestCookiesToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_cookies_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_cookies_to_remove"))
		if err := fv(ctx, m.GetRequestCookiesToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_add"))
		if err := fv(ctx, m.GetRequestHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_remove"))
		if err := fv(ctx, m.GetRequestHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_cookies_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_cookies_to_add"))
		if err := fv(ctx, m.GetResponseCookiesToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_cookies_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_cookies_to_remove"))
		if err := fv(ctx, m.GetResponseCookiesToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_add"))
		if err := fv(ctx, m.GetResponseHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_remove"))
		if err := fv(ctx, m.GetResponseHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["retry_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("retry_policy"))
		if err := fv(ctx, m.GetRetryPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sensitive_data_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("sensitive_data_policy"))
		for idx, item := range m.GetSensitiveDataPolicy() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetServerHeaderChoice().(type) {
	case *GlobalSpecType_DefaultHeader:
		if fv, exists := v.FldValidators["server_header_choice.default_header"]; exists {
			val := m.GetServerHeaderChoice().(*GlobalSpecType_DefaultHeader).DefaultHeader
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("default_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_ServerName:
		if fv, exists := v.FldValidators["server_header_choice.server_name"]; exists {
			val := m.GetServerHeaderChoice().(*GlobalSpecType_ServerName).ServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_AppendServerName:
		if fv, exists := v.FldValidators["server_header_choice.append_server_name"]; exists {
			val := m.GetServerHeaderChoice().(*GlobalSpecType_AppendServerName).AppendServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("append_server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_PassThrough:
		if fv, exists := v.FldValidators["server_header_choice.pass_through"]; exists {
			val := m.GetServerHeaderChoice().(*GlobalSpecType_PassThrough).PassThrough
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("pass_through"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetServiceActionDelegation().(type) {
	case *GlobalSpecType_Selected:
		if fv, exists := v.FldValidators["service_action_delegation.selected"]; exists {
			val := m.GetServiceActionDelegation().(*GlobalSpecType_Selected).Selected
			vOpts := append(opts,
				db.WithValidateField("service_action_delegation"),
				db.WithValidateField("selected"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_All:
		if fv, exists := v.FldValidators["service_action_delegation.all"]; exists {
			val := m.GetServiceActionDelegation().(*GlobalSpecType_All).All
			vOpts := append(opts,
				db.WithValidateField("service_action_delegation"),
				db.WithValidateField("all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service_policy_sets"]; exists {
		vOpts := append(opts, db.WithValidateField("service_policy_sets"))
		if err := fv(ctx, m.GetServicePolicySets(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["slow_ddos_mitigation"]; exists {

		vOpts := append(opts, db.WithValidateField("slow_ddos_mitigation"))
		if err := fv(ctx, m.GetSlowDdosMitigation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetStrictSniHostHeaderCheckChoice().(type) {
	case *GlobalSpecType_EnableStrictSniHostHeaderCheck:
		if fv, exists := v.FldValidators["strict_sni_host_header_check_choice.enable_strict_sni_host_header_check"]; exists {
			val := m.GetStrictSniHostHeaderCheckChoice().(*GlobalSpecType_EnableStrictSniHostHeaderCheck).EnableStrictSniHostHeaderCheck
			vOpts := append(opts,
				db.WithValidateField("strict_sni_host_header_check_choice"),
				db.WithValidateField("enable_strict_sni_host_header_check"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_AdditionalDomains:
		if fv, exists := v.FldValidators["strict_sni_host_header_check_choice.additional_domains"]; exists {
			val := m.GetStrictSniHostHeaderCheckChoice().(*GlobalSpecType_AdditionalDomains).AdditionalDomains
			vOpts := append(opts,
				db.WithValidateField("strict_sni_host_header_check_choice"),
				db.WithValidateField("additional_domains"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["temporary_user_blocking"]; exists {

		vOpts := append(opts, db.WithValidateField("temporary_user_blocking"))
		if err := fv(ctx, m.GetTemporaryUserBlocking(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetTlsCertificatesChoice().(type) {
	case *GlobalSpecType_TlsParameters:
		if fv, exists := v.FldValidators["tls_certificates_choice.tls_parameters"]; exists {
			val := m.GetTlsCertificatesChoice().(*GlobalSpecType_TlsParameters).TlsParameters
			vOpts := append(opts,
				db.WithValidateField("tls_certificates_choice"),
				db.WithValidateField("tls_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_TlsCertParams:
		if fv, exists := v.FldValidators["tls_certificates_choice.tls_cert_params"]; exists {
			val := m.GetTlsCertificatesChoice().(*GlobalSpecType_TlsCertParams).TlsCertParams
			vOpts := append(opts,
				db.WithValidateField("tls_certificates_choice"),
				db.WithValidateField("tls_cert_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tls_intercept"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_intercept"))
		if err := fv(ctx, m.GetTlsIntercept(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["trust_client_ip_headers_choice"]; exists {
		val := m.GetTrustClientIpHeadersChoice()
		vOpts := append(opts,
			db.WithValidateField("trust_client_ip_headers_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTrustClientIpHeadersChoice().(type) {
	case *GlobalSpecType_DisableTrustClientIpHeaders:
		if fv, exists := v.FldValidators["trust_client_ip_headers_choice.disable_trust_client_ip_headers"]; exists {
			val := m.GetTrustClientIpHeadersChoice().(*GlobalSpecType_DisableTrustClientIpHeaders).DisableTrustClientIpHeaders
			vOpts := append(opts,
				db.WithValidateField("trust_client_ip_headers_choice"),
				db.WithValidateField("disable_trust_client_ip_headers"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_EnableTrustClientIpHeaders:
		if fv, exists := v.FldValidators["trust_client_ip_headers_choice.enable_trust_client_ip_headers"]; exists {
			val := m.GetTrustClientIpHeadersChoice().(*GlobalSpecType_EnableTrustClientIpHeaders).EnableTrustClientIpHeaders
			vOpts := append(opts,
				db.WithValidateField("trust_client_ip_headers_choice"),
				db.WithValidateField("enable_trust_client_ip_headers"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["use_threat_mesh"]; exists {

		vOpts := append(opts, db.WithValidateField("use_threat_mesh"))
		if err := fv(ctx, m.GetUseThreatMesh(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_domains"]; exists {
		vOpts := append(opts, db.WithValidateField("user_domains"))
		if err := fv(ctx, m.GetUserDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_identification"]; exists {
		vOpts := append(opts, db.WithValidateField("user_identification"))
		if err := fv(ctx, m.GetUserIdentification(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_cert"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_cert"))
		if err := fv(ctx, m.GetVolterraCert(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["waf_exclusion_policy"]; exists {
		vOpts := append(opts, db.WithValidateField("waf_exclusion_policy"))
		if err := fv(ctx, m.GetWafExclusionPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["waf_type"]; exists {

		vOpts := append(opts, db.WithValidateField("waf_type"))
		if err := fv(ctx, m.GetWafType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ztna_proxy_configurations"]; exists {

		vOpts := append(opts, db.WithValidateField("ztna_proxy_configurations"))
		if err := fv(ctx, m.GetZtnaProxyConfigurations(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChallengeType := v.ChallengeTypeValidationRuleHandler
	rulesChallengeType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChallengeType(rulesChallengeType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.challenge_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["challenge_type"] = vFn

	vrhServerHeaderChoiceServerName := v.ServerHeaderChoiceServerNameValidationRuleHandler
	rulesServerHeaderChoiceServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.server_name"], err = vrhServerHeaderChoiceServerName(rulesServerHeaderChoiceServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GlobalSpecType.server_header_choice_server_name: %s", err)
		panic(errMsg)
	}
	vrhServerHeaderChoiceAppendServerName := v.ServerHeaderChoiceAppendServerNameValidationRuleHandler
	rulesServerHeaderChoiceAppendServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.append_server_name"], err = vrhServerHeaderChoiceAppendServerName(rulesServerHeaderChoiceAppendServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GlobalSpecType.server_header_choice_append_server_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["server_header_choice.server_name"] = vFnMap["server_header_choice.server_name"]
	v.FldValidators["server_header_choice.append_server_name"] = vFnMap["server_header_choice.append_server_name"]

	vrhTrustClientIpHeadersChoice := v.TrustClientIpHeadersChoiceValidationRuleHandler
	rulesTrustClientIpHeadersChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhTrustClientIpHeadersChoice(rulesTrustClientIpHeadersChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.trust_client_ip_headers_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["trust_client_ip_headers_choice"] = vFn

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.repeated.items.string.vh_domain": "true",
		"ves.io.schema.rules.repeated.max_items":              "33",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "256",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	vrhRequestHeadersToAdd := v.RequestHeadersToAddValidationRuleHandler
	rulesRequestHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToAdd(rulesRequestHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.request_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_add"] = vFn

	vrhResponseHeadersToAdd := v.ResponseHeadersToAddValidationRuleHandler
	rulesResponseHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToAdd(rulesResponseHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.response_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_add"] = vFn

	vrhResponseHeadersToRemove := v.ResponseHeadersToRemoveValidationRuleHandler
	rulesResponseHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToRemove(rulesResponseHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.response_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_remove"] = vFn

	vrhRequestHeadersToRemove := v.RequestHeadersToRemoveValidationRuleHandler
	rulesRequestHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToRemove(rulesRequestHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.request_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_remove"] = vFn

	vrhCustomErrors := v.CustomErrorsValidationRuleHandler
	rulesCustomErrors := map[string]string{
		"ves.io.schema.rules.map.keys.uint32.gte":       "3",
		"ves.io.schema.rules.map.keys.uint32.lte":       "599",
		"ves.io.schema.rules.map.max_pairs":             "16",
		"ves.io.schema.rules.map.values.string.max_len": "65536",
		"ves.io.schema.rules.map.values.string.uri_ref": "true",
	}
	vFn, err = vrhCustomErrors(rulesCustomErrors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.custom_errors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_errors"] = vFn

	vrhMaxRequestHeaderSize := v.MaxRequestHeaderSizeValidationRuleHandler
	rulesMaxRequestHeaderSize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "96",
	}
	vFn, err = vrhMaxRequestHeaderSize(rulesMaxRequestHeaderSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.max_request_header_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_request_header_size"] = vFn

	vrhUserIdentification := v.UserIdentificationValidationRuleHandler
	rulesUserIdentification := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhUserIdentification(rulesUserIdentification)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.user_identification: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user_identification"] = vFn

	vrhRateLimiter := v.RateLimiterValidationRuleHandler
	rulesRateLimiter := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRateLimiter(rulesRateLimiter)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.rate_limiter: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter"] = vFn

	vrhRateLimiterAllowedPrefixes := v.RateLimiterAllowedPrefixesValidationRuleHandler
	rulesRateLimiterAllowedPrefixes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhRateLimiterAllowedPrefixes(rulesRateLimiterAllowedPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.rate_limiter_allowed_prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter_allowed_prefixes"] = vFn

	vrhMaliciousUserMitigation := v.MaliciousUserMitigationValidationRuleHandler
	rulesMaliciousUserMitigation := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhMaliciousUserMitigation(rulesMaliciousUserMitigation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.malicious_user_mitigation: %s", err)
		panic(errMsg)
	}
	v.FldValidators["malicious_user_mitigation"] = vFn

	vrhCookiesToModify := v.CookiesToModifyValidationRuleHandler
	rulesCookiesToModify := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhCookiesToModify(rulesCookiesToModify)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.cookies_to_modify: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookies_to_modify"] = vFn

	vrhConnectionIdleTimeout := v.ConnectionIdleTimeoutValidationRuleHandler
	rulesConnectionIdleTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhConnectionIdleTimeout(rulesConnectionIdleTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.connection_idle_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_idle_timeout"] = vFn

	vrhDownstreamCos := v.DownstreamCosValidationRuleHandler
	rulesDownstreamCos := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhDownstreamCos(rulesDownstreamCos)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.downstream_cos: %s", err)
		panic(errMsg)
	}
	v.FldValidators["downstream_cos"] = vFn

	vrhRequestCookiesToAdd := v.RequestCookiesToAddValidationRuleHandler
	rulesRequestCookiesToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestCookiesToAdd(rulesRequestCookiesToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.request_cookies_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_cookies_to_add"] = vFn

	vrhRequestCookiesToRemove := v.RequestCookiesToRemoveValidationRuleHandler
	rulesRequestCookiesToRemove := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhRequestCookiesToRemove(rulesRequestCookiesToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.request_cookies_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_cookies_to_remove"] = vFn

	vrhResponseCookiesToAdd := v.ResponseCookiesToAddValidationRuleHandler
	rulesResponseCookiesToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseCookiesToAdd(rulesResponseCookiesToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.response_cookies_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_cookies_to_add"] = vFn

	vrhResponseCookiesToRemove := v.ResponseCookiesToRemoveValidationRuleHandler
	rulesResponseCookiesToRemove := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhResponseCookiesToRemove(rulesResponseCookiesToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.response_cookies_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_cookies_to_remove"] = vFn

	vrhWafExclusionPolicy := v.WafExclusionPolicyValidationRuleHandler
	rulesWafExclusionPolicy := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhWafExclusionPolicy(rulesWafExclusionPolicy)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.waf_exclusion_policy: %s", err)
		panic(errMsg)
	}
	v.FldValidators["waf_exclusion_policy"] = vFn

	vrhDnsDomains := v.DnsDomainsValidationRuleHandler
	rulesDnsDomains := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "256",
	}
	vFn, err = vrhDnsDomains(rulesDnsDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.dns_domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_domains"] = vFn

	vrhUserDomains := v.UserDomainsValidationRuleHandler
	rulesUserDomains := map[string]string{
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhUserDomains(rulesUserDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.user_domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user_domains"] = vFn

	vrhServicePolicySets := v.ServicePolicySetsValidationRuleHandler
	rulesServicePolicySets := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "5",
	}
	vFn, err = vrhServicePolicySets(rulesServicePolicySets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.service_policy_sets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_policy_sets"] = vFn

	vrhFastAcl := v.FastAclValidationRuleHandler
	rulesFastAcl := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhFastAcl(rulesFastAcl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.fast_acl: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fast_acl"] = vFn

	vrhL7Acl := v.L7AclValidationRuleHandler
	rulesL7Acl := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhL7Acl(rulesL7Acl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.l7_acl: %s", err)
		panic(errMsg)
	}
	v.FldValidators["l7_acl"] = vFn

	vrhDnsZones := v.DnsZonesValidationRuleHandler
	rulesDnsZones := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "256",
	}
	vFn, err = vrhDnsZones(rulesDnsZones)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.dns_zones: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_zones"] = vFn

	vrhMaxDirectResponseBodySize := v.MaxDirectResponseBodySizeValidationRuleHandler
	rulesMaxDirectResponseBodySize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "65536",
	}
	vFn, err = vrhMaxDirectResponseBodySize(rulesMaxDirectResponseBodySize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.max_direct_response_body_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_direct_response_body_size"] = vFn

	v.FldValidators["authentication_choice.authentication"] = AuthenticationDetailsValidator().Validate

	v.FldValidators["bot_defense_choice.bot_defense"] = ShapeBotDefenseConfigTypeValidator().Validate

	v.FldValidators["challenge_type.js_challenge"] = JavascriptChallengeTypeValidator().Validate
	v.FldValidators["challenge_type.captcha_challenge"] = CaptchaChallengeTypeValidator().Validate
	v.FldValidators["challenge_type.policy_based_challenge"] = PolicyBasedChallengeValidator().Validate

	v.FldValidators["ddos_auto_mitigation_action.ddos_js_challenge"] = JavascriptChallengeTypeValidator().Validate

	v.FldValidators["strict_sni_host_header_check_choice.additional_domains"] = ves_io_schema.DomainNameListValidator().Validate

	v.FldValidators["tls_certificates_choice.tls_parameters"] = ves_io_schema.DownstreamTlsParamsTypeValidator().Validate
	v.FldValidators["tls_certificates_choice.tls_cert_params"] = ves_io_schema.CertificateParamsTypeValidator().Validate

	v.FldValidators["trust_client_ip_headers_choice.enable_trust_client_ip_headers"] = ClientIPHeadersValidator().Validate

	v.FldValidators["buffer_policy"] = ves_io_schema.BufferConfigTypeValidator().Validate

	v.FldValidators["cors_policy"] = ves_io_schema.CorsPolicyValidator().Validate

	v.FldValidators["waf_type"] = ves_io_schema.WafTypeValidator().Validate

	v.FldValidators["dynamic_reverse_proxy"] = DynamicReverseProxyTypeValidator().Validate

	v.FldValidators["compression_params"] = CompressionTypeValidator().Validate

	v.FldValidators["retry_policy"] = ves_io_schema.RetryPolicyTypeValidator().Validate

	v.FldValidators["temporary_user_blocking"] = TemporaryUserBlockingTypeValidator().Validate

	v.FldValidators["tls_intercept"] = ves_io_schema.TlsInterceptionTypeValidator().Validate

	v.FldValidators["cdn_service"] = CdnServiceTypeValidator().Validate

	v.FldValidators["header_transformation_type"] = ves_io_schema.HeaderTransformationTypeValidator().Validate

	v.FldValidators["csrf_policy"] = ves_io_schema.CsrfPolicyValidator().Validate

	v.FldValidators["slow_ddos_mitigation"] = SlowDDoSMitigationValidator().Validate

	v.FldValidators["api_spec"] = ApiSpecValidator().Validate

	v.FldValidators["domain_cert_map"] = DomainCertificatesValidator().Validate

	v.FldValidators["http_protocol_options"] = HttpProtocolOptionsValidator().Validate

	v.FldValidators["coalescing_options"] = ves_io_schema.TLSCoalescingOptionsValidator().Validate

	v.FldValidators["dns_info"] = ves_io_schema_virtual_host_dns_info.DnsInfoValidator().Validate

	v.FldValidators["ztna_proxy_configurations"] = ZtnaProxyConfigurationValidator().Validate

	v.FldValidators["dns_proxy_configuration"] = DNSProxyConfigurationValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HeaderControlType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HeaderControlType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *HeaderControlType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetRequestHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting HeaderControlType.request_headers_to_add idx %v", idx)
		}
	}

	for idx, e := range m.GetResponseHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting HeaderControlType.response_headers_to_add idx %v", idx)
		}
	}

	return nil
}

func (m *HeaderControlType) DeepCopy() *HeaderControlType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HeaderControlType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HeaderControlType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HeaderControlType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HeaderControlTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHeaderControlType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHeaderControlType) RequestHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for request_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHeaderControlType) RequestHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHeaderControlType) ResponseHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for response_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHeaderControlType) ResponseHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHeaderControlType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HeaderControlType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HeaderControlType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["request_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_add"))
		if err := fv(ctx, m.GetRequestHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_remove"))
		if err := fv(ctx, m.GetRequestHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_add"))
		if err := fv(ctx, m.GetResponseHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_remove"))
		if err := fv(ctx, m.GetResponseHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHeaderControlTypeValidator = func() *ValidateHeaderControlType {
	v := &ValidateHeaderControlType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRequestHeadersToAdd := v.RequestHeadersToAddValidationRuleHandler
	rulesRequestHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToAdd(rulesRequestHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderControlType.request_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_add"] = vFn

	vrhRequestHeadersToRemove := v.RequestHeadersToRemoveValidationRuleHandler
	rulesRequestHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.items.string.pattern":   "^[0-9A-Za-z_\\-\\.]+$",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhRequestHeadersToRemove(rulesRequestHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderControlType.request_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_remove"] = vFn

	vrhResponseHeadersToAdd := v.ResponseHeadersToAddValidationRuleHandler
	rulesResponseHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToAdd(rulesResponseHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderControlType.response_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_add"] = vFn

	vrhResponseHeadersToRemove := v.ResponseHeadersToRemoveValidationRuleHandler
	rulesResponseHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.items.string.pattern": "^[0-9A-Za-z_\\-\\.]+$",
		"ves.io.schema.rules.repeated.max_items":            "32",
		"ves.io.schema.rules.repeated.unique":               "true",
	}
	vFn, err = vrhResponseHeadersToRemove(rulesResponseHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderControlType.response_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_remove"] = vFn

	return v
}()

func HeaderControlTypeValidator() db.Validator {
	return DefaultHeaderControlTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *Http1ProtocolOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Http1ProtocolOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Http1ProtocolOptions) DeepCopy() *Http1ProtocolOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Http1ProtocolOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Http1ProtocolOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Http1ProtocolOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return Http1ProtocolOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateHttp1ProtocolOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHttp1ProtocolOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Http1ProtocolOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Http1ProtocolOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["header_transformation"]; exists {

		vOpts := append(opts, db.WithValidateField("header_transformation"))
		if err := fv(ctx, m.GetHeaderTransformation(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHttp1ProtocolOptionsValidator = func() *ValidateHttp1ProtocolOptions {
	v := &ValidateHttp1ProtocolOptions{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["header_transformation"] = ves_io_schema.HeaderTransformationTypeValidator().Validate

	return v
}()

func Http1ProtocolOptionsValidator() db.Validator {
	return DefaultHttp1ProtocolOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *HttpProtocolOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HttpProtocolOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HttpProtocolOptions) DeepCopy() *HttpProtocolOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HttpProtocolOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HttpProtocolOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HttpProtocolOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HttpProtocolOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateHttpProtocolOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHttpProtocolOptions) HttpProtocolChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for http_protocol_choice")
	}
	return validatorFn, nil
}

func (v *ValidateHttpProtocolOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HttpProtocolOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HttpProtocolOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["http_protocol_choice"]; exists {
		val := m.GetHttpProtocolChoice()
		vOpts := append(opts,
			db.WithValidateField("http_protocol_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetHttpProtocolChoice().(type) {
	case *HttpProtocolOptions_HttpProtocolEnableV1Only:
		if fv, exists := v.FldValidators["http_protocol_choice.http_protocol_enable_v1_only"]; exists {
			val := m.GetHttpProtocolChoice().(*HttpProtocolOptions_HttpProtocolEnableV1Only).HttpProtocolEnableV1Only
			vOpts := append(opts,
				db.WithValidateField("http_protocol_choice"),
				db.WithValidateField("http_protocol_enable_v1_only"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HttpProtocolOptions_HttpProtocolEnableV2Only:
		if fv, exists := v.FldValidators["http_protocol_choice.http_protocol_enable_v2_only"]; exists {
			val := m.GetHttpProtocolChoice().(*HttpProtocolOptions_HttpProtocolEnableV2Only).HttpProtocolEnableV2Only
			vOpts := append(opts,
				db.WithValidateField("http_protocol_choice"),
				db.WithValidateField("http_protocol_enable_v2_only"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HttpProtocolOptions_HttpProtocolEnableV1V2:
		if fv, exists := v.FldValidators["http_protocol_choice.http_protocol_enable_v1_v2"]; exists {
			val := m.GetHttpProtocolChoice().(*HttpProtocolOptions_HttpProtocolEnableV1V2).HttpProtocolEnableV1V2
			vOpts := append(opts,
				db.WithValidateField("http_protocol_choice"),
				db.WithValidateField("http_protocol_enable_v1_v2"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHttpProtocolOptionsValidator = func() *ValidateHttpProtocolOptions {
	v := &ValidateHttpProtocolOptions{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHttpProtocolChoice := v.HttpProtocolChoiceValidationRuleHandler
	rulesHttpProtocolChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhHttpProtocolChoice(rulesHttpProtocolChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HttpProtocolOptions.http_protocol_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_protocol_choice"] = vFn

	v.FldValidators["http_protocol_choice.http_protocol_enable_v1_only"] = Http1ProtocolOptionsValidator().Validate

	return v
}()

func HttpProtocolOptionsValidator() db.Validator {
	return DefaultHttpProtocolOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *HttpRedirectOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HttpRedirectOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HttpRedirectOptions) DeepCopy() *HttpRedirectOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HttpRedirectOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HttpRedirectOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HttpRedirectOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HttpRedirectOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateHttpRedirectOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHttpRedirectOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HttpRedirectOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HttpRedirectOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHttpRedirectOptionsValidator = func() *ValidateHttpRedirectOptions {
	v := &ValidateHttpRedirectOptions{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func HttpRedirectOptionsValidator() db.Validator {
	return DefaultHttpRedirectOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *JavaScriptConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JavaScriptConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JavaScriptConfigType) DeepCopy() *JavaScriptConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JavaScriptConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JavaScriptConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JavaScriptConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JavaScriptConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateJavaScriptConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJavaScriptConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JavaScriptConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JavaScriptConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_prefix"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_prefix"))
		if err := fv(ctx, m.GetCachePrefix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_script_url"]; exists {

		vOpts := append(opts, db.WithValidateField("custom_script_url"))
		if err := fv(ctx, m.GetCustomScriptUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["script_config"]; exists {

		vOpts := append(opts, db.WithValidateField("script_config"))
		if err := fv(ctx, m.GetScriptConfig(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJavaScriptConfigTypeValidator = func() *ValidateJavaScriptConfigType {
	v := &ValidateJavaScriptConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func JavaScriptConfigTypeValidator() db.Validator {
	return DefaultJavaScriptConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *JavascriptChallengeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JavascriptChallengeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JavascriptChallengeType) DeepCopy() *JavascriptChallengeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JavascriptChallengeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JavascriptChallengeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JavascriptChallengeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JavascriptChallengeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateJavascriptChallengeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJavascriptChallengeType) JsScriptDelayValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for js_script_delay")
	}

	return validatorFn, nil
}

func (v *ValidateJavascriptChallengeType) CookieExpiryValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cookie_expiry")
	}

	return validatorFn, nil
}

func (v *ValidateJavascriptChallengeType) CustomPageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for custom_page")
	}

	return validatorFn, nil
}

func (v *ValidateJavascriptChallengeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JavascriptChallengeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JavascriptChallengeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cookie_expiry"]; exists {

		vOpts := append(opts, db.WithValidateField("cookie_expiry"))
		if err := fv(ctx, m.GetCookieExpiry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_page"]; exists {

		vOpts := append(opts, db.WithValidateField("custom_page"))
		if err := fv(ctx, m.GetCustomPage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["js_script_delay"]; exists {

		vOpts := append(opts, db.WithValidateField("js_script_delay"))
		if err := fv(ctx, m.GetJsScriptDelay(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJavascriptChallengeTypeValidator = func() *ValidateJavascriptChallengeType {
	v := &ValidateJavascriptChallengeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhJsScriptDelay := v.JsScriptDelayValidationRuleHandler
	rulesJsScriptDelay := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1000",
		"ves.io.schema.rules.uint32.lte": "60000",
	}
	vFn, err = vrhJsScriptDelay(rulesJsScriptDelay)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavascriptChallengeType.js_script_delay: %s", err)
		panic(errMsg)
	}
	v.FldValidators["js_script_delay"] = vFn

	vrhCookieExpiry := v.CookieExpiryValidationRuleHandler
	rulesCookieExpiry := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "86400",
	}
	vFn, err = vrhCookieExpiry(rulesCookieExpiry)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavascriptChallengeType.cookie_expiry: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookie_expiry"] = vFn

	vrhCustomPage := v.CustomPageValidationRuleHandler
	rulesCustomPage := map[string]string{
		"ves.io.schema.rules.string.max_len": "65536",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFn, err = vrhCustomPage(rulesCustomPage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavascriptChallengeType.custom_page: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_page"] = vFn

	return v
}()

func JavascriptChallengeTypeValidator() db.Validator {
	return DefaultJavascriptChallengeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *LogHeaderOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LogHeaderOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LogHeaderOptions) DeepCopy() *LogHeaderOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LogHeaderOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LogHeaderOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LogHeaderOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LogHeaderOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateLogHeaderOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLogHeaderOptions) HeaderListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for header_list")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for header_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated header_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items header_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateLogHeaderOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LogHeaderOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LogHeaderOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["header_list"]; exists {
		vOpts := append(opts, db.WithValidateField("header_list"))
		if err := fv(ctx, m.GetHeaderList(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLogHeaderOptionsValidator = func() *ValidateLogHeaderOptions {
	v := &ValidateLogHeaderOptions{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHeaderList := v.HeaderListValidationRuleHandler
	rulesHeaderList := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhHeaderList(rulesHeaderList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LogHeaderOptions.header_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["header_list"] = vFn

	return v
}()

func LogHeaderOptionsValidator() db.Validator {
	return DefaultLogHeaderOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *LoggingOptionsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LoggingOptionsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LoggingOptionsType) DeepCopy() *LoggingOptionsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LoggingOptionsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LoggingOptionsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LoggingOptionsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LoggingOptionsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateLoggingOptionsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLoggingOptionsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LoggingOptionsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LoggingOptionsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["client_log_options"]; exists {

		vOpts := append(opts, db.WithValidateField("client_log_options"))
		if err := fv(ctx, m.GetClientLogOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["origin_log_options"]; exists {

		vOpts := append(opts, db.WithValidateField("origin_log_options"))
		if err := fv(ctx, m.GetOriginLogOptions(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLoggingOptionsTypeValidator = func() *ValidateLoggingOptionsType {
	v := &ValidateLoggingOptionsType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["client_log_options"] = LogHeaderOptionsValidator().Validate

	v.FldValidators["origin_log_options"] = LogHeaderOptionsValidator().Validate

	return v
}()

func LoggingOptionsTypeValidator() db.Validator {
	return DefaultLoggingOptionsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *MaskingConfiguration) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MaskingConfiguration) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MaskingConfiguration) DeepCopy() *MaskingConfiguration {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MaskingConfiguration{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MaskingConfiguration) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MaskingConfiguration) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MaskingConfigurationValidator().Validate(ctx, m, opts...)
}

type ValidateMaskingConfiguration struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMaskingConfiguration) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MaskingConfiguration)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MaskingConfiguration got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetMaskingChoice().(type) {
	case *MaskingConfiguration_DisableMasking:
		if fv, exists := v.FldValidators["masking_choice.disable_masking"]; exists {
			val := m.GetMaskingChoice().(*MaskingConfiguration_DisableMasking).DisableMasking
			vOpts := append(opts,
				db.WithValidateField("masking_choice"),
				db.WithValidateField("disable_masking"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *MaskingConfiguration_EnableMasking:
		if fv, exists := v.FldValidators["masking_choice.enable_masking"]; exists {
			val := m.GetMaskingChoice().(*MaskingConfiguration_EnableMasking).EnableMasking
			vOpts := append(opts,
				db.WithValidateField("masking_choice"),
				db.WithValidateField("enable_masking"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMaskingConfigurationValidator = func() *ValidateMaskingConfiguration {
	v := &ValidateMaskingConfiguration{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MaskingConfigurationValidator() db.Validator {
	return DefaultMaskingConfigurationValidator
}

// augmented methods on protoc/std generated struct

func (m *OpenApiValidationSettings) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OpenApiValidationSettings) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OpenApiValidationSettings) DeepCopy() *OpenApiValidationSettings {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OpenApiValidationSettings{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OpenApiValidationSettings) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OpenApiValidationSettings) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OpenApiValidationSettingsValidator().Validate(ctx, m, opts...)
}

type ValidateOpenApiValidationSettings struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOpenApiValidationSettings) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OpenApiValidationSettings)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OpenApiValidationSettings got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["allow_only_specified_headers"]; exists {

		vOpts := append(opts, db.WithValidateField("allow_only_specified_headers"))
		if err := fv(ctx, m.GetAllowOnlySpecifiedHeaders(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["allow_only_specified_query_params"]; exists {

		vOpts := append(opts, db.WithValidateField("allow_only_specified_query_params"))
		if err := fv(ctx, m.GetAllowOnlySpecifiedQueryParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fail_close"]; exists {

		vOpts := append(opts, db.WithValidateField("fail_close"))
		if err := fv(ctx, m.GetFailClose(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fail_oversized_body_validation"]; exists {

		vOpts := append(opts, db.WithValidateField("fail_oversized_body_validation"))
		if err := fv(ctx, m.GetFailOversizedBodyValidation(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOpenApiValidationSettingsValidator = func() *ValidateOpenApiValidationSettings {
	v := &ValidateOpenApiValidationSettings{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func OpenApiValidationSettingsValidator() db.Validator {
	return DefaultOpenApiValidationSettingsValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginAdvancedConfiguration) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginAdvancedConfiguration) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginAdvancedConfiguration) DeepCopy() *OriginAdvancedConfiguration {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginAdvancedConfiguration{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginAdvancedConfiguration) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginAdvancedConfiguration) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginAdvancedConfigurationValidator().Validate(ctx, m, opts...)
}

type ValidateOriginAdvancedConfiguration struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginAdvancedConfiguration) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginAdvancedConfiguration)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginAdvancedConfiguration got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["disable_byte_range_request"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_byte_range_request"))
		if err := fv(ctx, m.GetDisableByteRangeRequest(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["websocket_proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("websocket_proxy"))
		if err := fv(ctx, m.GetWebsocketProxy(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginAdvancedConfigurationValidator = func() *ValidateOriginAdvancedConfiguration {
	v := &ValidateOriginAdvancedConfiguration{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func OriginAdvancedConfigurationValidator() db.Validator {
	return DefaultOriginAdvancedConfigurationValidator
}

// augmented methods on protoc/std generated struct

func (m *OtherSettings) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OtherSettings) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *OtherSettings) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetHeaderOptions().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting OtherSettings.header_options")
	}

	return nil
}

func (m *OtherSettings) DeepCopy() *OtherSettings {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OtherSettings{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OtherSettings) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OtherSettings) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OtherSettingsValidator().Validate(ctx, m, opts...)
}

type ValidateOtherSettings struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOtherSettings) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OtherSettings)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OtherSettings got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_location"]; exists {

		vOpts := append(opts, db.WithValidateField("add_location"))
		if err := fv(ctx, m.GetAddLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header_options"]; exists {

		vOpts := append(opts, db.WithValidateField("header_options"))
		if err := fv(ctx, m.GetHeaderOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["logging_options"]; exists {

		vOpts := append(opts, db.WithValidateField("logging_options"))
		if err := fv(ctx, m.GetLoggingOptions(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOtherSettingsValidator = func() *ValidateOtherSettings {
	v := &ValidateOtherSettings{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["logging_options"] = LoggingOptionsTypeValidator().Validate

	v.FldValidators["header_options"] = HeaderControlTypeValidator().Validate

	return v
}()

func OtherSettingsValidator() db.Validator {
	return DefaultOtherSettingsValidator
}

// augmented methods on protoc/std generated struct

func (m *PolicyBasedChallenge) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PolicyBasedChallenge) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PolicyBasedChallenge) DeepCopy() *PolicyBasedChallenge {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PolicyBasedChallenge{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PolicyBasedChallenge) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PolicyBasedChallenge) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PolicyBasedChallengeValidator().Validate(ctx, m, opts...)
}

func (m *PolicyBasedChallenge) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetMaliciousUserMitigationDRefInfo()

}

func (m *PolicyBasedChallenge) GetMaliciousUserMitigationDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetMaliciousUserMitigation()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("PolicyBasedChallenge.malicious_user_mitigation[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "malicious_user_mitigation.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "malicious_user_mitigation",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetMaliciousUserMitigationDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *PolicyBasedChallenge) GetMaliciousUserMitigationDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "malicious_user_mitigation.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: malicious_user_mitigation")
	}
	for _, ref := range m.GetMaliciousUserMitigation() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidatePolicyBasedChallenge struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePolicyBasedChallenge) ChallengeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for challenge_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePolicyBasedChallenge) MaliciousUserMitigationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for malicious_user_mitigation")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for malicious_user_mitigation")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated malicious_user_mitigation")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items malicious_user_mitigation")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePolicyBasedChallenge) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PolicyBasedChallenge)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PolicyBasedChallenge got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["captcha_challenge"]; exists {

		vOpts := append(opts, db.WithValidateField("captcha_challenge"))
		if err := fv(ctx, m.GetCaptchaChallenge(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["challenge_choice"]; exists {
		val := m.GetChallengeChoice()
		vOpts := append(opts,
			db.WithValidateField("challenge_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChallengeChoice().(type) {
	case *PolicyBasedChallenge_NoChallenge:
		if fv, exists := v.FldValidators["challenge_choice.no_challenge"]; exists {
			val := m.GetChallengeChoice().(*PolicyBasedChallenge_NoChallenge).NoChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_choice"),
				db.WithValidateField("no_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PolicyBasedChallenge_AlwaysEnableJsChallenge:
		if fv, exists := v.FldValidators["challenge_choice.always_enable_js_challenge"]; exists {
			val := m.GetChallengeChoice().(*PolicyBasedChallenge_AlwaysEnableJsChallenge).AlwaysEnableJsChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_choice"),
				db.WithValidateField("always_enable_js_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PolicyBasedChallenge_AlwaysEnableCaptchaChallenge:
		if fv, exists := v.FldValidators["challenge_choice.always_enable_captcha_challenge"]; exists {
			val := m.GetChallengeChoice().(*PolicyBasedChallenge_AlwaysEnableCaptchaChallenge).AlwaysEnableCaptchaChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_choice"),
				db.WithValidateField("always_enable_captcha_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["js_challenge"]; exists {

		vOpts := append(opts, db.WithValidateField("js_challenge"))
		if err := fv(ctx, m.GetJsChallenge(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["malicious_user_mitigation"]; exists {
		vOpts := append(opts, db.WithValidateField("malicious_user_mitigation"))
		if err := fv(ctx, m.GetMaliciousUserMitigation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["temporary_user_blocking"]; exists {

		vOpts := append(opts, db.WithValidateField("temporary_user_blocking"))
		if err := fv(ctx, m.GetTemporaryUserBlocking(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPolicyBasedChallengeValidator = func() *ValidatePolicyBasedChallenge {
	v := &ValidatePolicyBasedChallenge{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChallengeChoice := v.ChallengeChoiceValidationRuleHandler
	rulesChallengeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChallengeChoice(rulesChallengeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PolicyBasedChallenge.challenge_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["challenge_choice"] = vFn

	vrhMaliciousUserMitigation := v.MaliciousUserMitigationValidationRuleHandler
	rulesMaliciousUserMitigation := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhMaliciousUserMitigation(rulesMaliciousUserMitigation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PolicyBasedChallenge.malicious_user_mitigation: %s", err)
		panic(errMsg)
	}
	v.FldValidators["malicious_user_mitigation"] = vFn

	v.FldValidators["js_challenge"] = JavascriptChallengeTypeValidator().Validate

	v.FldValidators["captcha_challenge"] = CaptchaChallengeTypeValidator().Validate

	v.FldValidators["temporary_user_blocking"] = TemporaryUserBlockingTypeValidator().Validate

	return v
}()

func PolicyBasedChallengeValidator() db.Validator {
	return DefaultPolicyBasedChallengeValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ReplaceSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetRequestHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting ReplaceSpecType.request_headers_to_add idx %v", idx)
		}
	}

	for idx, e := range m.GetResponseHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting ReplaceSpecType.response_headers_to_add idx %v", idx)
		}
	}

	if err := m.GetTlsParameters().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.tls_parameters")
	}

	if err := m.GetAuthentication().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.authentication")
	}

	for idx, e := range m.GetRequestCookiesToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting ReplaceSpecType.request_cookies_to_add idx %v", idx)
		}
	}

	for idx, e := range m.GetResponseCookiesToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting ReplaceSpecType.response_cookies_to_add idx %v", idx)
		}
	}

	return nil
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAdvertisePoliciesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAdvertisePoliciesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetApiSpecDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetApiSpecDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetAuthenticationChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAuthenticationChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDnsProxyConfigurationDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDnsProxyConfigurationDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDynamicReverseProxyDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDynamicReverseProxyDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterAllowedPrefixesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRateLimiterAllowedPrefixesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRoutesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRoutesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetSensitiveDataPolicyDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSensitiveDataPolicyDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTlsCertificatesChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTlsCertificatesChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetUserIdentificationDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetUserIdentificationDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWafTypeDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetWafTypeDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetZtnaProxyConfigurationsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetZtnaProxyConfigurationsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *ReplaceSpecType) GetAdvertisePoliciesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAdvertisePolicies()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.advertise_policies[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "advertise_policy.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "advertise_policies",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAdvertisePoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetAdvertisePoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "advertise_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: advertise_policy")
	}
	for _, ref := range m.GetAdvertisePolicies() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetApiSpecDRefInfo() ([]db.DRefInfo, error) {
	if m.GetApiSpec() == nil {
		return nil, nil
	}

	drInfos, err := m.GetApiSpec().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetApiSpec().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "api_spec." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetAuthenticationChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAuthenticationChoice() == nil {
		return nil, nil
	}
	switch m.GetAuthenticationChoice().(type) {
	case *ReplaceSpecType_NoAuthentication:

		return nil, nil

	case *ReplaceSpecType_Authentication:

		drInfos, err := m.GetAuthentication().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAuthentication().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "authentication." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetDnsProxyConfigurationDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDnsProxyConfiguration() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDnsProxyConfiguration().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDnsProxyConfiguration().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "dns_proxy_configuration." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetDynamicReverseProxyDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDynamicReverseProxy() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDynamicReverseProxy().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDynamicReverseProxy().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "dynamic_reverse_proxy." + dri.DRField
	}
	return drInfos, err

}

func (m *ReplaceSpecType) GetRateLimiterAllowedPrefixesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRateLimiterAllowedPrefixes()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.rate_limiter_allowed_prefixes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "ip_prefix_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "rate_limiter_allowed_prefixes",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRateLimiterAllowedPrefixesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetRateLimiterAllowedPrefixesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "ip_prefix_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: ip_prefix_set")
	}
	for _, ref := range m.GetRateLimiterAllowedPrefixes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *ReplaceSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRoutes()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.routes[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "route.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "routes",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRoutesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetRoutesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "route.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: route")
	}
	for _, ref := range m.GetRoutes() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *ReplaceSpecType) GetSensitiveDataPolicyDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetSensitiveDataPolicy()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.sensitive_data_policy[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "sensitive_data_policy.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "sensitive_data_policy",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetSensitiveDataPolicyDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetSensitiveDataPolicyDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "sensitive_data_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: sensitive_data_policy")
	}
	for _, ref := range m.GetSensitiveDataPolicy() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetTlsCertificatesChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTlsCertificatesChoice() == nil {
		return nil, nil
	}
	switch m.GetTlsCertificatesChoice().(type) {
	case *ReplaceSpecType_TlsParameters:

		drInfos, err := m.GetTlsParameters().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTlsParameters().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tls_parameters." + dri.DRField
		}
		return drInfos, err

	case *ReplaceSpecType_TlsCertParams:

		drInfos, err := m.GetTlsCertParams().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTlsCertParams().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tls_cert_params." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *ReplaceSpecType) GetUserIdentificationDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetUserIdentification()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.user_identification[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "user_identification.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "user_identification",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetUserIdentificationDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetUserIdentificationDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "user_identification.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: user_identification")
	}
	for _, ref := range m.GetUserIdentification() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetWafTypeDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWafType() == nil {
		return nil, nil
	}

	drInfos, err := m.GetWafType().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetWafType().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "waf_type." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetZtnaProxyConfigurationsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetZtnaProxyConfigurations() == nil {
		return nil, nil
	}

	drInfos, err := m.GetZtnaProxyConfigurations().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetZtnaProxyConfigurations().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "ztna_proxy_configurations." + dri.DRField
	}
	return drInfos, err

}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) ChallengeTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for challenge_type")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ServerHeaderChoiceServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_name")
	}
	return oValidatorFn_ServerName, nil
}
func (v *ValidateReplaceSpecType) ServerHeaderChoiceAppendServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_AppendServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for append_server_name")
	}
	return oValidatorFn_AppendServerName, nil
}

func (v *ValidateReplaceSpecType) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for routes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) RequestHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for request_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ResponseHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for response_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ResponseHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ProxyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ProxyType)
		return int32(i)
	}
	// ProxyType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ProxyType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for proxy")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) RequestHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) CustomErrorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapUint32KeyRules(rules)
	itemKeyFn, err := db.NewUint32ValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for custom_errors")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for custom_errors")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[uint32]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for custom_errors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[uint32]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ uint32 ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map custom_errors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items custom_errors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) MaxRequestHeaderSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_request_header_size")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) UserIdentificationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for user_identification")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for user_identification")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated user_identification")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items user_identification")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) RateLimiterAllowedPrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter_allowed_prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter_allowed_prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) CookiesToModifyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cookies_to_modify")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.CookieManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.CookieManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cookies_to_modify")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.CookieManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.CookieManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cookies_to_modify")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cookies_to_modify")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ConnectionIdleTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_idle_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) RequestCookiesToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for request_cookies_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.CookieValueOption, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.CookieValueOptionValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_cookies_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.CookieValueOption)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.CookieValueOption, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_cookies_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_cookies_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) RequestCookiesToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_cookies_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_cookies_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_cookies_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_cookies_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ResponseCookiesToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for response_cookies_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.SetCookieValueOption, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.SetCookieValueOptionValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_cookies_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.SetCookieValueOption)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.SetCookieValueOption, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_cookies_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_cookies_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ResponseCookiesToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_cookies_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_cookies_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_cookies_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_cookies_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) MaxDirectResponseBodySizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_direct_response_body_size")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_location"]; exists {

		vOpts := append(opts, db.WithValidateField("add_location"))
		if err := fv(ctx, m.GetAddLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["advertise_policies"]; exists {

		vOpts := append(opts, db.WithValidateField("advertise_policies"))
		for idx, item := range m.GetAdvertisePolicies() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["api_spec"]; exists {

		vOpts := append(opts, db.WithValidateField("api_spec"))
		if err := fv(ctx, m.GetApiSpec(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetAuthenticationChoice().(type) {
	case *ReplaceSpecType_NoAuthentication:
		if fv, exists := v.FldValidators["authentication_choice.no_authentication"]; exists {
			val := m.GetAuthenticationChoice().(*ReplaceSpecType_NoAuthentication).NoAuthentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("no_authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Authentication:
		if fv, exists := v.FldValidators["authentication_choice.authentication"]; exists {
			val := m.GetAuthenticationChoice().(*ReplaceSpecType_Authentication).Authentication
			vOpts := append(opts,
				db.WithValidateField("authentication_choice"),
				db.WithValidateField("authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["buffer_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("buffer_policy"))
		if err := fv(ctx, m.GetBufferPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["challenge_type"]; exists {
		val := m.GetChallengeType()
		vOpts := append(opts,
			db.WithValidateField("challenge_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChallengeType().(type) {
	case *ReplaceSpecType_JsChallenge:
		if fv, exists := v.FldValidators["challenge_type.js_challenge"]; exists {
			val := m.GetChallengeType().(*ReplaceSpecType_JsChallenge).JsChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("js_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_CaptchaChallenge:
		if fv, exists := v.FldValidators["challenge_type.captcha_challenge"]; exists {
			val := m.GetChallengeType().(*ReplaceSpecType_CaptchaChallenge).CaptchaChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("captcha_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_NoChallenge:
		if fv, exists := v.FldValidators["challenge_type.no_challenge"]; exists {
			val := m.GetChallengeType().(*ReplaceSpecType_NoChallenge).NoChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_type"),
				db.WithValidateField("no_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["coalescing_options"]; exists {

		vOpts := append(opts, db.WithValidateField("coalescing_options"))
		if err := fv(ctx, m.GetCoalescingOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["compression_params"]; exists {

		vOpts := append(opts, db.WithValidateField("compression_params"))
		if err := fv(ctx, m.GetCompressionParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connection_idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_idle_timeout"))
		if err := fv(ctx, m.GetConnectionIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cookies_to_modify"]; exists {
		vOpts := append(opts, db.WithValidateField("cookies_to_modify"))
		if err := fv(ctx, m.GetCookiesToModify(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cors_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("cors_policy"))
		if err := fv(ctx, m.GetCorsPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["csrf_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("csrf_policy"))
		if err := fv(ctx, m.GetCsrfPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_errors"]; exists {
		vOpts := append(opts, db.WithValidateField("custom_errors"))
		if err := fv(ctx, m.GetCustomErrors(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetDefaultLbChoice().(type) {
	case *ReplaceSpecType_NonDefaultLoadbalancer:
		if fv, exists := v.FldValidators["default_lb_choice.non_default_loadbalancer"]; exists {
			val := m.GetDefaultLbChoice().(*ReplaceSpecType_NonDefaultLoadbalancer).NonDefaultLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("default_lb_choice"),
				db.WithValidateField("non_default_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DefaultLoadbalancer:
		if fv, exists := v.FldValidators["default_lb_choice.default_loadbalancer"]; exists {
			val := m.GetDefaultLbChoice().(*ReplaceSpecType_DefaultLoadbalancer).DefaultLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("default_lb_choice"),
				db.WithValidateField("default_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["disable_default_error_pages"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_default_error_pages"))
		if err := fv(ctx, m.GetDisableDefaultErrorPages(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_dns_resolve"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_dns_resolve"))
		if err := fv(ctx, m.GetDisableDnsResolve(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_proxy_configuration"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_proxy_configuration"))
		if err := fv(ctx, m.GetDnsProxyConfiguration(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domain_cert_map"]; exists {

		vOpts := append(opts, db.WithValidateField("domain_cert_map"))
		for key, value := range m.GetDomainCertMap() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dynamic_reverse_proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("dynamic_reverse_proxy"))
		if err := fv(ctx, m.GetDynamicReverseProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header_transformation_type"]; exists {

		vOpts := append(opts, db.WithValidateField("header_transformation_type"))
		if err := fv(ctx, m.GetHeaderTransformationType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_protocol_options"]; exists {

		vOpts := append(opts, db.WithValidateField("http_protocol_options"))
		if err := fv(ctx, m.GetHttpProtocolOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("idle_timeout"))
		if err := fv(ctx, m.GetIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["masking_config"]; exists {

		vOpts := append(opts, db.WithValidateField("masking_config"))
		if err := fv(ctx, m.GetMaskingConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_direct_response_body_size"]; exists {

		vOpts := append(opts, db.WithValidateField("max_direct_response_body_size"))
		if err := fv(ctx, m.GetMaxDirectResponseBodySize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_request_header_size"]; exists {

		vOpts := append(opts, db.WithValidateField("max_request_header_size"))
		if err := fv(ctx, m.GetMaxRequestHeaderSize(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetPathNormalizeChoice().(type) {
	case *ReplaceSpecType_EnablePathNormalize:
		if fv, exists := v.FldValidators["path_normalize_choice.enable_path_normalize"]; exists {
			val := m.GetPathNormalizeChoice().(*ReplaceSpecType_EnablePathNormalize).EnablePathNormalize
			vOpts := append(opts,
				db.WithValidateField("path_normalize_choice"),
				db.WithValidateField("enable_path_normalize"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DisablePathNormalize:
		if fv, exists := v.FldValidators["path_normalize_choice.disable_path_normalize"]; exists {
			val := m.GetPathNormalizeChoice().(*ReplaceSpecType_DisablePathNormalize).DisablePathNormalize
			vOpts := append(opts,
				db.WithValidateField("path_normalize_choice"),
				db.WithValidateField("disable_path_normalize"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("proxy"))
		if err := fv(ctx, m.GetProxy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limiter_allowed_prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter_allowed_prefixes"))
		if err := fv(ctx, m.GetRateLimiterAllowedPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_cookies_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_cookies_to_add"))
		if err := fv(ctx, m.GetRequestCookiesToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_cookies_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_cookies_to_remove"))
		if err := fv(ctx, m.GetRequestCookiesToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_add"))
		if err := fv(ctx, m.GetRequestHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_remove"))
		if err := fv(ctx, m.GetRequestHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_cookies_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_cookies_to_add"))
		if err := fv(ctx, m.GetResponseCookiesToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_cookies_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_cookies_to_remove"))
		if err := fv(ctx, m.GetResponseCookiesToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_add"))
		if err := fv(ctx, m.GetResponseHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_remove"))
		if err := fv(ctx, m.GetResponseHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["retry_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("retry_policy"))
		if err := fv(ctx, m.GetRetryPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sensitive_data_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("sensitive_data_policy"))
		for idx, item := range m.GetSensitiveDataPolicy() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetServerHeaderChoice().(type) {
	case *ReplaceSpecType_DefaultHeader:
		if fv, exists := v.FldValidators["server_header_choice.default_header"]; exists {
			val := m.GetServerHeaderChoice().(*ReplaceSpecType_DefaultHeader).DefaultHeader
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("default_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_ServerName:
		if fv, exists := v.FldValidators["server_header_choice.server_name"]; exists {
			val := m.GetServerHeaderChoice().(*ReplaceSpecType_ServerName).ServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_AppendServerName:
		if fv, exists := v.FldValidators["server_header_choice.append_server_name"]; exists {
			val := m.GetServerHeaderChoice().(*ReplaceSpecType_AppendServerName).AppendServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("append_server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_PassThrough:
		if fv, exists := v.FldValidators["server_header_choice.pass_through"]; exists {
			val := m.GetServerHeaderChoice().(*ReplaceSpecType_PassThrough).PassThrough
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("pass_through"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["slow_ddos_mitigation"]; exists {

		vOpts := append(opts, db.WithValidateField("slow_ddos_mitigation"))
		if err := fv(ctx, m.GetSlowDdosMitigation(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetStrictSniHostHeaderCheckChoice().(type) {
	case *ReplaceSpecType_EnableStrictSniHostHeaderCheck:
		if fv, exists := v.FldValidators["strict_sni_host_header_check_choice.enable_strict_sni_host_header_check"]; exists {
			val := m.GetStrictSniHostHeaderCheckChoice().(*ReplaceSpecType_EnableStrictSniHostHeaderCheck).EnableStrictSniHostHeaderCheck
			vOpts := append(opts,
				db.WithValidateField("strict_sni_host_header_check_choice"),
				db.WithValidateField("enable_strict_sni_host_header_check"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_AdditionalDomains:
		if fv, exists := v.FldValidators["strict_sni_host_header_check_choice.additional_domains"]; exists {
			val := m.GetStrictSniHostHeaderCheckChoice().(*ReplaceSpecType_AdditionalDomains).AdditionalDomains
			vOpts := append(opts,
				db.WithValidateField("strict_sni_host_header_check_choice"),
				db.WithValidateField("additional_domains"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["temporary_user_blocking"]; exists {

		vOpts := append(opts, db.WithValidateField("temporary_user_blocking"))
		if err := fv(ctx, m.GetTemporaryUserBlocking(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetTlsCertificatesChoice().(type) {
	case *ReplaceSpecType_TlsParameters:
		if fv, exists := v.FldValidators["tls_certificates_choice.tls_parameters"]; exists {
			val := m.GetTlsCertificatesChoice().(*ReplaceSpecType_TlsParameters).TlsParameters
			vOpts := append(opts,
				db.WithValidateField("tls_certificates_choice"),
				db.WithValidateField("tls_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_TlsCertParams:
		if fv, exists := v.FldValidators["tls_certificates_choice.tls_cert_params"]; exists {
			val := m.GetTlsCertificatesChoice().(*ReplaceSpecType_TlsCertParams).TlsCertParams
			vOpts := append(opts,
				db.WithValidateField("tls_certificates_choice"),
				db.WithValidateField("tls_cert_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["user_identification"]; exists {
		vOpts := append(opts, db.WithValidateField("user_identification"))
		if err := fv(ctx, m.GetUserIdentification(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["waf_type"]; exists {

		vOpts := append(opts, db.WithValidateField("waf_type"))
		if err := fv(ctx, m.GetWafType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ztna_proxy_configurations"]; exists {

		vOpts := append(opts, db.WithValidateField("ztna_proxy_configurations"))
		if err := fv(ctx, m.GetZtnaProxyConfigurations(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChallengeType := v.ChallengeTypeValidationRuleHandler
	rulesChallengeType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChallengeType(rulesChallengeType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.challenge_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["challenge_type"] = vFn

	vrhServerHeaderChoiceServerName := v.ServerHeaderChoiceServerNameValidationRuleHandler
	rulesServerHeaderChoiceServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.server_name"], err = vrhServerHeaderChoiceServerName(rulesServerHeaderChoiceServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ReplaceSpecType.server_header_choice_server_name: %s", err)
		panic(errMsg)
	}
	vrhServerHeaderChoiceAppendServerName := v.ServerHeaderChoiceAppendServerNameValidationRuleHandler
	rulesServerHeaderChoiceAppendServerName := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["server_header_choice.append_server_name"], err = vrhServerHeaderChoiceAppendServerName(rulesServerHeaderChoiceAppendServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ReplaceSpecType.server_header_choice_append_server_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["server_header_choice.server_name"] = vFnMap["server_header_choice.server_name"]
	v.FldValidators["server_header_choice.append_server_name"] = vFnMap["server_header_choice.append_server_name"]

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.repeated.items.string.vh_domain": "true",
		"ves.io.schema.rules.repeated.max_items":              "33",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "256",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	vrhRequestHeadersToAdd := v.RequestHeadersToAddValidationRuleHandler
	rulesRequestHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToAdd(rulesRequestHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.request_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_add"] = vFn

	vrhResponseHeadersToAdd := v.ResponseHeadersToAddValidationRuleHandler
	rulesResponseHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToAdd(rulesResponseHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.response_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_add"] = vFn

	vrhResponseHeadersToRemove := v.ResponseHeadersToRemoveValidationRuleHandler
	rulesResponseHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToRemove(rulesResponseHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.response_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_remove"] = vFn

	vrhProxy := v.ProxyValidationRuleHandler
	rulesProxy := map[string]string{
		"ves.io.schema.rules.enum.in": "[4,5]",
	}
	vFn, err = vrhProxy(rulesProxy)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.proxy: %s", err)
		panic(errMsg)
	}
	v.FldValidators["proxy"] = vFn

	vrhRequestHeadersToRemove := v.RequestHeadersToRemoveValidationRuleHandler
	rulesRequestHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToRemove(rulesRequestHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.request_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_remove"] = vFn

	vrhCustomErrors := v.CustomErrorsValidationRuleHandler
	rulesCustomErrors := map[string]string{
		"ves.io.schema.rules.map.keys.uint32.gte":       "3",
		"ves.io.schema.rules.map.keys.uint32.lte":       "599",
		"ves.io.schema.rules.map.max_pairs":             "16",
		"ves.io.schema.rules.map.values.string.max_len": "65536",
		"ves.io.schema.rules.map.values.string.uri_ref": "true",
	}
	vFn, err = vrhCustomErrors(rulesCustomErrors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.custom_errors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_errors"] = vFn

	vrhMaxRequestHeaderSize := v.MaxRequestHeaderSizeValidationRuleHandler
	rulesMaxRequestHeaderSize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "96",
	}
	vFn, err = vrhMaxRequestHeaderSize(rulesMaxRequestHeaderSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.max_request_header_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_request_header_size"] = vFn

	vrhUserIdentification := v.UserIdentificationValidationRuleHandler
	rulesUserIdentification := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhUserIdentification(rulesUserIdentification)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.user_identification: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user_identification"] = vFn

	vrhRateLimiterAllowedPrefixes := v.RateLimiterAllowedPrefixesValidationRuleHandler
	rulesRateLimiterAllowedPrefixes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhRateLimiterAllowedPrefixes(rulesRateLimiterAllowedPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.rate_limiter_allowed_prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter_allowed_prefixes"] = vFn

	vrhCookiesToModify := v.CookiesToModifyValidationRuleHandler
	rulesCookiesToModify := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhCookiesToModify(rulesCookiesToModify)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.cookies_to_modify: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookies_to_modify"] = vFn

	vrhConnectionIdleTimeout := v.ConnectionIdleTimeoutValidationRuleHandler
	rulesConnectionIdleTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhConnectionIdleTimeout(rulesConnectionIdleTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.connection_idle_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_idle_timeout"] = vFn

	vrhRequestCookiesToAdd := v.RequestCookiesToAddValidationRuleHandler
	rulesRequestCookiesToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestCookiesToAdd(rulesRequestCookiesToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.request_cookies_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_cookies_to_add"] = vFn

	vrhRequestCookiesToRemove := v.RequestCookiesToRemoveValidationRuleHandler
	rulesRequestCookiesToRemove := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhRequestCookiesToRemove(rulesRequestCookiesToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.request_cookies_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_cookies_to_remove"] = vFn

	vrhResponseCookiesToAdd := v.ResponseCookiesToAddValidationRuleHandler
	rulesResponseCookiesToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseCookiesToAdd(rulesResponseCookiesToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.response_cookies_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_cookies_to_add"] = vFn

	vrhResponseCookiesToRemove := v.ResponseCookiesToRemoveValidationRuleHandler
	rulesResponseCookiesToRemove := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhResponseCookiesToRemove(rulesResponseCookiesToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.response_cookies_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_cookies_to_remove"] = vFn

	vrhMaxDirectResponseBodySize := v.MaxDirectResponseBodySizeValidationRuleHandler
	rulesMaxDirectResponseBodySize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "65536",
	}
	vFn, err = vrhMaxDirectResponseBodySize(rulesMaxDirectResponseBodySize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.max_direct_response_body_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_direct_response_body_size"] = vFn

	v.FldValidators["authentication_choice.authentication"] = AuthenticationDetailsValidator().Validate

	v.FldValidators["challenge_type.js_challenge"] = JavascriptChallengeTypeValidator().Validate
	v.FldValidators["challenge_type.captcha_challenge"] = CaptchaChallengeTypeValidator().Validate

	v.FldValidators["strict_sni_host_header_check_choice.additional_domains"] = ves_io_schema.DomainNameListValidator().Validate

	v.FldValidators["tls_certificates_choice.tls_parameters"] = ves_io_schema.DownstreamTlsParamsTypeValidator().Validate
	v.FldValidators["tls_certificates_choice.tls_cert_params"] = ves_io_schema.CertificateParamsTypeValidator().Validate

	v.FldValidators["buffer_policy"] = ves_io_schema.BufferConfigTypeValidator().Validate

	v.FldValidators["cors_policy"] = ves_io_schema.CorsPolicyValidator().Validate

	v.FldValidators["waf_type"] = ves_io_schema.WafTypeValidator().Validate

	v.FldValidators["dynamic_reverse_proxy"] = DynamicReverseProxyTypeValidator().Validate

	v.FldValidators["compression_params"] = CompressionTypeValidator().Validate

	v.FldValidators["retry_policy"] = ves_io_schema.RetryPolicyTypeValidator().Validate

	v.FldValidators["temporary_user_blocking"] = TemporaryUserBlockingTypeValidator().Validate

	v.FldValidators["header_transformation_type"] = ves_io_schema.HeaderTransformationTypeValidator().Validate

	v.FldValidators["csrf_policy"] = ves_io_schema.CsrfPolicyValidator().Validate

	v.FldValidators["slow_ddos_mitigation"] = SlowDDoSMitigationValidator().Validate

	v.FldValidators["api_spec"] = ApiSpecValidator().Validate

	v.FldValidators["domain_cert_map"] = DomainCertificatesValidator().Validate

	v.FldValidators["http_protocol_options"] = HttpProtocolOptionsValidator().Validate

	v.FldValidators["coalescing_options"] = ves_io_schema.TLSCoalescingOptionsValidator().Validate

	v.FldValidators["ztna_proxy_configurations"] = ZtnaProxyConfigurationValidator().Validate

	v.FldValidators["dns_proxy_configuration"] = DNSProxyConfigurationValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ServiceDomain) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ServiceDomain) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ServiceDomain) DeepCopy() *ServiceDomain {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ServiceDomain{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ServiceDomain) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ServiceDomain) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ServiceDomainValidator().Validate(ctx, m, opts...)
}

type ValidateServiceDomain struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateServiceDomain) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ServiceDomain)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ServiceDomain got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain"]; exists {

		vOpts := append(opts, db.WithValidateField("domain"))
		if err := fv(ctx, m.GetDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["internal_service_domain"]; exists {

		vOpts := append(opts, db.WithValidateField("internal_service_domain"))
		if err := fv(ctx, m.GetInternalServiceDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_domain"]; exists {

		vOpts := append(opts, db.WithValidateField("service_domain"))
		if err := fv(ctx, m.GetServiceDomain(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultServiceDomainValidator = func() *ValidateServiceDomain {
	v := &ValidateServiceDomain{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ServiceDomainValidator() db.Validator {
	return DefaultServiceDomainValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeBotDefenseConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeBotDefenseConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ShapeBotDefenseConfigType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetApiAuthKey().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ShapeBotDefenseConfigType.api_auth_key")
	}

	return nil
}

func (m *ShapeBotDefenseConfigType) DeepCopy() *ShapeBotDefenseConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeBotDefenseConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeBotDefenseConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeBotDefenseConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeBotDefenseConfigTypeValidator().Validate(ctx, m, opts...)
}

func (m *ShapeBotDefenseConfigType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetInstanceDRefInfo()

}

func (m *ShapeBotDefenseConfigType) GetInstanceDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetInstance()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("ShapeBotDefenseConfigType.instance[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "shape_bot_defense_instance.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "instance",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetInstanceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ShapeBotDefenseConfigType) GetInstanceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "shape_bot_defense_instance.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: shape_bot_defense_instance")
	}
	for _, ref := range m.GetInstance() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateShapeBotDefenseConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeBotDefenseConfigType) ApplicationIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for application_id")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotDefenseConfigType) TimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for timeout")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotDefenseConfigType) BlockingPagesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for blocking_pages")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for blocking_pages")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for blocking_pages")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map blocking_pages")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items blocking_pages")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotDefenseConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeBotDefenseConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeBotDefenseConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_auth_key"]; exists {

		vOpts := append(opts, db.WithValidateField("api_auth_key"))
		if err := fv(ctx, m.GetApiAuthKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["application_id"]; exists {

		vOpts := append(opts, db.WithValidateField("application_id"))
		if err := fv(ctx, m.GetApplicationId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["blocking_pages"]; exists {
		vOpts := append(opts, db.WithValidateField("blocking_pages"))
		if err := fv(ctx, m.GetBlockingPages(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["instance"]; exists {

		vOpts := append(opts, db.WithValidateField("instance"))
		for idx, item := range m.GetInstance() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["js_path"]; exists {

		vOpts := append(opts, db.WithValidateField("js_path"))
		if err := fv(ctx, m.GetJsPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mode"]; exists {

		vOpts := append(opts, db.WithValidateField("mode"))
		if err := fv(ctx, m.GetMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["reload_header_name"]; exists {

		vOpts := append(opts, db.WithValidateField("reload_header_name"))
		if err := fv(ctx, m.GetReloadHeaderName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("timeout"))
		if err := fv(ctx, m.GetTimeout(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeBotDefenseConfigTypeValidator = func() *ValidateShapeBotDefenseConfigType {
	v := &ValidateShapeBotDefenseConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhApplicationId := v.ApplicationIdValidationRuleHandler
	rulesApplicationId := map[string]string{
		"ves.io.schema.rules.string.max_len": "32",
	}
	vFn, err = vrhApplicationId(rulesApplicationId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotDefenseConfigType.application_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["application_id"] = vFn

	vrhTimeout := v.TimeoutValidationRuleHandler
	rulesTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "60000",
	}
	vFn, err = vrhTimeout(rulesTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotDefenseConfigType.timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["timeout"] = vFn

	vrhBlockingPages := v.BlockingPagesValidationRuleHandler
	rulesBlockingPages := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "32",
		"ves.io.schema.rules.map.keys.string.min_len":   "32",
		"ves.io.schema.rules.map.max_pairs":             "128",
		"ves.io.schema.rules.map.values.string.max_len": "4096",
	}
	vFn, err = vrhBlockingPages(rulesBlockingPages)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotDefenseConfigType.blocking_pages: %s", err)
		panic(errMsg)
	}
	v.FldValidators["blocking_pages"] = vFn

	v.FldValidators["api_auth_key"] = ves_io_schema.SecretTypeValidator().Validate

	return v
}()

func ShapeBotDefenseConfigTypeValidator() db.Validator {
	return DefaultShapeBotDefenseConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SlowDDoSMitigation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SlowDDoSMitigation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SlowDDoSMitigation) DeepCopy() *SlowDDoSMitigation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SlowDDoSMitigation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SlowDDoSMitigation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SlowDDoSMitigation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SlowDDoSMitigationValidator().Validate(ctx, m, opts...)
}

type ValidateSlowDDoSMitigation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSlowDDoSMitigation) RequestTimeoutChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for request_timeout_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSlowDDoSMitigation) RequestTimeoutChoiceRequestTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_RequestTimeout, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for request_timeout")
	}
	return oValidatorFn_RequestTimeout, nil
}

func (v *ValidateSlowDDoSMitigation) RequestHeadersTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for request_headers_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateSlowDDoSMitigation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SlowDDoSMitigation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SlowDDoSMitigation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["request_headers_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("request_headers_timeout"))
		if err := fv(ctx, m.GetRequestHeadersTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_timeout_choice"]; exists {
		val := m.GetRequestTimeoutChoice()
		vOpts := append(opts,
			db.WithValidateField("request_timeout_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetRequestTimeoutChoice().(type) {
	case *SlowDDoSMitigation_RequestTimeout:
		if fv, exists := v.FldValidators["request_timeout_choice.request_timeout"]; exists {
			val := m.GetRequestTimeoutChoice().(*SlowDDoSMitigation_RequestTimeout).RequestTimeout
			vOpts := append(opts,
				db.WithValidateField("request_timeout_choice"),
				db.WithValidateField("request_timeout"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SlowDDoSMitigation_DisableRequestTimeout:
		if fv, exists := v.FldValidators["request_timeout_choice.disable_request_timeout"]; exists {
			val := m.GetRequestTimeoutChoice().(*SlowDDoSMitigation_DisableRequestTimeout).DisableRequestTimeout
			vOpts := append(opts,
				db.WithValidateField("request_timeout_choice"),
				db.WithValidateField("disable_request_timeout"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSlowDDoSMitigationValidator = func() *ValidateSlowDDoSMitigation {
	v := &ValidateSlowDDoSMitigation{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRequestTimeoutChoice := v.RequestTimeoutChoiceValidationRuleHandler
	rulesRequestTimeoutChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhRequestTimeoutChoice(rulesRequestTimeoutChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SlowDDoSMitigation.request_timeout_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_timeout_choice"] = vFn

	vrhRequestTimeoutChoiceRequestTimeout := v.RequestTimeoutChoiceRequestTimeoutValidationRuleHandler
	rulesRequestTimeoutChoiceRequestTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "2000",
		"ves.io.schema.rules.uint32.lte": "300000",
	}
	vFnMap["request_timeout_choice.request_timeout"], err = vrhRequestTimeoutChoiceRequestTimeout(rulesRequestTimeoutChoiceRequestTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SlowDDoSMitigation.request_timeout_choice_request_timeout: %s", err)
		panic(errMsg)
	}

	v.FldValidators["request_timeout_choice.request_timeout"] = vFnMap["request_timeout_choice.request_timeout"]

	vrhRequestHeadersTimeout := v.RequestHeadersTimeoutValidationRuleHandler
	rulesRequestHeadersTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "2000",
		"ves.io.schema.rules.uint32.lte": "30000",
	}
	vFn, err = vrhRequestHeadersTimeout(rulesRequestHeadersTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SlowDDoSMitigation.request_headers_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_timeout"] = vFn

	return v
}()

func SlowDDoSMitigationValidator() db.Validator {
	return DefaultSlowDDoSMitigationValidator
}

// augmented methods on protoc/std generated struct

func (m *TemporaryUserBlockingType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TemporaryUserBlockingType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TemporaryUserBlockingType) DeepCopy() *TemporaryUserBlockingType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TemporaryUserBlockingType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TemporaryUserBlockingType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TemporaryUserBlockingType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TemporaryUserBlockingTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTemporaryUserBlockingType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTemporaryUserBlockingType) CustomPageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for custom_page")
	}

	return validatorFn, nil
}

func (v *ValidateTemporaryUserBlockingType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TemporaryUserBlockingType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TemporaryUserBlockingType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["custom_page"]; exists {

		vOpts := append(opts, db.WithValidateField("custom_page"))
		if err := fv(ctx, m.GetCustomPage(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTemporaryUserBlockingTypeValidator = func() *ValidateTemporaryUserBlockingType {
	v := &ValidateTemporaryUserBlockingType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCustomPage := v.CustomPageValidationRuleHandler
	rulesCustomPage := map[string]string{
		"ves.io.schema.rules.string.max_len": "65536",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFn, err = vrhCustomPage(rulesCustomPage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TemporaryUserBlockingType.custom_page: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_page"] = vFn

	return v
}()

func TemporaryUserBlockingTypeValidator() db.Validator {
	return DefaultTemporaryUserBlockingTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VerStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VerStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VerStatusType) DeepCopy() *VerStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VerStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VerStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VerStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VerStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVerStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVerStatusType) CoalescedVirtualHostsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for coalesced_virtual_hosts")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*VirtualHostID, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := VirtualHostIDValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for coalesced_virtual_hosts")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*VirtualHostID)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*VirtualHostID, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated coalesced_virtual_hosts")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items coalesced_virtual_hosts")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateVerStatusType) NonCoalescedVirtualHostsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for non_coalesced_virtual_hosts")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*VirtualHostID, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := VirtualHostIDValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for non_coalesced_virtual_hosts")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*VirtualHostID)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*VirtualHostID, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated non_coalesced_virtual_hosts")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items non_coalesced_virtual_hosts")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateVerStatusType) CoalescedVhostsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for coalesced_vhosts")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for coalesced_vhosts")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated coalesced_vhosts")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items coalesced_vhosts")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateVerStatusType) NonCoalescedVhostsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for non_coalesced_vhosts")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for non_coalesced_vhosts")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated non_coalesced_vhosts")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items non_coalesced_vhosts")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateVerStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VerStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VerStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("advertise_policy"))
		if err := fv(ctx, m.GetAdvertisePolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coalesced_vhosts"]; exists {
		vOpts := append(opts, db.WithValidateField("coalesced_vhosts"))
		if err := fv(ctx, m.GetCoalescedVhosts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coalesced_virtual_hosts"]; exists {
		vOpts := append(opts, db.WithValidateField("coalesced_virtual_hosts"))
		if err := fv(ctx, m.GetCoalescedVirtualHosts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["non_coalesced_vhosts"]; exists {
		vOpts := append(opts, db.WithValidateField("non_coalesced_vhosts"))
		if err := fv(ctx, m.GetNonCoalescedVhosts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["non_coalesced_virtual_hosts"]; exists {
		vOpts := append(opts, db.WithValidateField("non_coalesced_virtual_hosts"))
		if err := fv(ctx, m.GetNonCoalescedVirtualHosts(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVerStatusTypeValidator = func() *ValidateVerStatusType {
	v := &ValidateVerStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCoalescedVirtualHosts := v.CoalescedVirtualHostsValidationRuleHandler
	rulesCoalescedVirtualHosts := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhCoalescedVirtualHosts(rulesCoalescedVirtualHosts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VerStatusType.coalesced_virtual_hosts: %s", err)
		panic(errMsg)
	}
	v.FldValidators["coalesced_virtual_hosts"] = vFn

	vrhNonCoalescedVirtualHosts := v.NonCoalescedVirtualHostsValidationRuleHandler
	rulesNonCoalescedVirtualHosts := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhNonCoalescedVirtualHosts(rulesNonCoalescedVirtualHosts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VerStatusType.non_coalesced_virtual_hosts: %s", err)
		panic(errMsg)
	}
	v.FldValidators["non_coalesced_virtual_hosts"] = vFn

	vrhCoalescedVhosts := v.CoalescedVhostsValidationRuleHandler
	rulesCoalescedVhosts := map[string]string{
		"ves.io.schema.rules.repeated.unique": "true",
	}
	vFn, err = vrhCoalescedVhosts(rulesCoalescedVhosts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VerStatusType.coalesced_vhosts: %s", err)
		panic(errMsg)
	}
	v.FldValidators["coalesced_vhosts"] = vFn

	vrhNonCoalescedVhosts := v.NonCoalescedVhostsValidationRuleHandler
	rulesNonCoalescedVhosts := map[string]string{
		"ves.io.schema.rules.repeated.unique": "true",
	}
	vFn, err = vrhNonCoalescedVhosts(rulesNonCoalescedVhosts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VerStatusType.non_coalesced_vhosts: %s", err)
		panic(errMsg)
	}
	v.FldValidators["non_coalesced_vhosts"] = vFn

	v.FldValidators["advertise_policy"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func VerStatusTypeValidator() db.Validator {
	return DefaultVerStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VirtualHostID) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VirtualHostID) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VirtualHostID) DeepCopy() *VirtualHostID {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VirtualHostID{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VirtualHostID) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VirtualHostID) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VirtualHostIDValidator().Validate(ctx, m, opts...)
}

type ValidateVirtualHostID struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVirtualHostID) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VirtualHostID)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VirtualHostID got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVirtualHostIDValidator = func() *ValidateVirtualHostID {
	v := &ValidateVirtualHostID{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func VirtualHostIDValidator() db.Validator {
	return DefaultVirtualHostIDValidator
}

// augmented methods on protoc/std generated struct

func (m *ZtnaProxyConfiguration) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ZtnaProxyConfiguration) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ZtnaProxyConfiguration) DeepCopy() *ZtnaProxyConfiguration {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ZtnaProxyConfiguration{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ZtnaProxyConfiguration) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ZtnaProxyConfiguration) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ZtnaProxyConfigurationValidator().Validate(ctx, m, opts...)
}

func (m *ZtnaProxyConfiguration) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetZtnaApplicationConfigDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetZtnaApplicationConfigDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetZtnaPolicyConfigDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetZtnaPolicyConfigDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *ZtnaProxyConfiguration) GetZtnaApplicationConfigDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetZtnaApplicationConfig()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("ZtnaProxyConfiguration.ztna_application_config[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "ztna_application.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "ztna_application_config",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetZtnaApplicationConfigDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ZtnaProxyConfiguration) GetZtnaApplicationConfigDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "ztna_application.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: ztna_application")
	}
	for _, ref := range m.GetZtnaApplicationConfig() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *ZtnaProxyConfiguration) GetZtnaPolicyConfigDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetZtnaPolicyConfig()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("ZtnaProxyConfiguration.ztna_policy_config[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "ztna.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "ztna_policy_config",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetZtnaPolicyConfigDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ZtnaProxyConfiguration) GetZtnaPolicyConfigDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "ztna.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: ztna")
	}
	for _, ref := range m.GetZtnaPolicyConfig() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateZtnaProxyConfiguration struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateZtnaProxyConfiguration) ZtnaPolicyConfigValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for ztna_policy_config")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ztna_policy_config")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ztna_policy_config")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ztna_policy_config")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateZtnaProxyConfiguration) ZtnaApplicationConfigValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for ztna_application_config")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ztna_application_config")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ztna_application_config")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ztna_application_config")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateZtnaProxyConfiguration) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ZtnaProxyConfiguration)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ZtnaProxyConfiguration got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ztna_application_config"]; exists {
		vOpts := append(opts, db.WithValidateField("ztna_application_config"))
		if err := fv(ctx, m.GetZtnaApplicationConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ztna_policy_config"]; exists {
		vOpts := append(opts, db.WithValidateField("ztna_policy_config"))
		if err := fv(ctx, m.GetZtnaPolicyConfig(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultZtnaProxyConfigurationValidator = func() *ValidateZtnaProxyConfiguration {
	v := &ValidateZtnaProxyConfiguration{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhZtnaPolicyConfig := v.ZtnaPolicyConfigValidationRuleHandler
	rulesZtnaPolicyConfig := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "50",
	}
	vFn, err = vrhZtnaPolicyConfig(rulesZtnaPolicyConfig)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ZtnaProxyConfiguration.ztna_policy_config: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ztna_policy_config"] = vFn

	vrhZtnaApplicationConfig := v.ZtnaApplicationConfigValidationRuleHandler
	rulesZtnaApplicationConfig := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhZtnaApplicationConfig(rulesZtnaApplicationConfig)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ZtnaProxyConfiguration.ztna_application_config: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ztna_application_config"] = vFn

	return v
}()

func ZtnaProxyConfigurationValidator() db.Validator {
	return DefaultZtnaProxyConfigurationValidator
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetAuthenticationChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.AuthenticationChoice.(type) {
	case nil:
		o.AuthenticationChoice = nil

	case *CreateSpecType_Authentication:
		o.AuthenticationChoice = &GlobalSpecType_Authentication{Authentication: of.Authentication}

	case *CreateSpecType_NoAuthentication:
		o.AuthenticationChoice = &GlobalSpecType_NoAuthentication{NoAuthentication: of.NoAuthentication}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetAuthenticationChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.AuthenticationChoice.(type) {
	case nil:
		r.AuthenticationChoice = nil

	case *GlobalSpecType_Authentication:
		r.AuthenticationChoice = &CreateSpecType_Authentication{Authentication: of.Authentication}

	case *GlobalSpecType_NoAuthentication:
		r.AuthenticationChoice = &CreateSpecType_NoAuthentication{NoAuthentication: of.NoAuthentication}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetChallengeTypeToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ChallengeType.(type) {
	case nil:
		o.ChallengeType = nil

	case *CreateSpecType_CaptchaChallenge:
		o.ChallengeType = &GlobalSpecType_CaptchaChallenge{CaptchaChallenge: of.CaptchaChallenge}

	case *CreateSpecType_JsChallenge:
		o.ChallengeType = &GlobalSpecType_JsChallenge{JsChallenge: of.JsChallenge}

	case *CreateSpecType_NoChallenge:
		o.ChallengeType = &GlobalSpecType_NoChallenge{NoChallenge: of.NoChallenge}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetChallengeTypeFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ChallengeType.(type) {
	case nil:
		r.ChallengeType = nil

	case *GlobalSpecType_CaptchaChallenge:
		r.ChallengeType = &CreateSpecType_CaptchaChallenge{CaptchaChallenge: of.CaptchaChallenge}

	case *GlobalSpecType_JsChallenge:
		r.ChallengeType = &CreateSpecType_JsChallenge{JsChallenge: of.JsChallenge}

	case *GlobalSpecType_NoChallenge:
		r.ChallengeType = &CreateSpecType_NoChallenge{NoChallenge: of.NoChallenge}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetDefaultLbChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DefaultLbChoice.(type) {
	case nil:
		o.DefaultLbChoice = nil

	case *CreateSpecType_DefaultLoadbalancer:
		o.DefaultLbChoice = &GlobalSpecType_DefaultLoadbalancer{DefaultLoadbalancer: of.DefaultLoadbalancer}

	case *CreateSpecType_NonDefaultLoadbalancer:
		o.DefaultLbChoice = &GlobalSpecType_NonDefaultLoadbalancer{NonDefaultLoadbalancer: of.NonDefaultLoadbalancer}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetDefaultLbChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DefaultLbChoice.(type) {
	case nil:
		r.DefaultLbChoice = nil

	case *GlobalSpecType_DefaultLoadbalancer:
		r.DefaultLbChoice = &CreateSpecType_DefaultLoadbalancer{DefaultLoadbalancer: of.DefaultLoadbalancer}

	case *GlobalSpecType_NonDefaultLoadbalancer:
		r.DefaultLbChoice = &CreateSpecType_NonDefaultLoadbalancer{NonDefaultLoadbalancer: of.NonDefaultLoadbalancer}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetPathNormalizeChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.PathNormalizeChoice.(type) {
	case nil:
		o.PathNormalizeChoice = nil

	case *CreateSpecType_DisablePathNormalize:
		o.PathNormalizeChoice = &GlobalSpecType_DisablePathNormalize{DisablePathNormalize: of.DisablePathNormalize}

	case *CreateSpecType_EnablePathNormalize:
		o.PathNormalizeChoice = &GlobalSpecType_EnablePathNormalize{EnablePathNormalize: of.EnablePathNormalize}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetPathNormalizeChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.PathNormalizeChoice.(type) {
	case nil:
		r.PathNormalizeChoice = nil

	case *GlobalSpecType_DisablePathNormalize:
		r.PathNormalizeChoice = &CreateSpecType_DisablePathNormalize{DisablePathNormalize: of.DisablePathNormalize}

	case *GlobalSpecType_EnablePathNormalize:
		r.PathNormalizeChoice = &CreateSpecType_EnablePathNormalize{EnablePathNormalize: of.EnablePathNormalize}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetServerHeaderChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ServerHeaderChoice.(type) {
	case nil:
		o.ServerHeaderChoice = nil

	case *CreateSpecType_AppendServerName:
		o.ServerHeaderChoice = &GlobalSpecType_AppendServerName{AppendServerName: of.AppendServerName}

	case *CreateSpecType_DefaultHeader:
		o.ServerHeaderChoice = &GlobalSpecType_DefaultHeader{DefaultHeader: of.DefaultHeader}

	case *CreateSpecType_PassThrough:
		o.ServerHeaderChoice = &GlobalSpecType_PassThrough{PassThrough: of.PassThrough}

	case *CreateSpecType_ServerName:
		o.ServerHeaderChoice = &GlobalSpecType_ServerName{ServerName: of.ServerName}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetServerHeaderChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ServerHeaderChoice.(type) {
	case nil:
		r.ServerHeaderChoice = nil

	case *GlobalSpecType_AppendServerName:
		r.ServerHeaderChoice = &CreateSpecType_AppendServerName{AppendServerName: of.AppendServerName}

	case *GlobalSpecType_DefaultHeader:
		r.ServerHeaderChoice = &CreateSpecType_DefaultHeader{DefaultHeader: of.DefaultHeader}

	case *GlobalSpecType_PassThrough:
		r.ServerHeaderChoice = &CreateSpecType_PassThrough{PassThrough: of.PassThrough}

	case *GlobalSpecType_ServerName:
		r.ServerHeaderChoice = &CreateSpecType_ServerName{ServerName: of.ServerName}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetStrictSniHostHeaderCheckChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.StrictSniHostHeaderCheckChoice.(type) {
	case nil:
		o.StrictSniHostHeaderCheckChoice = nil

	case *CreateSpecType_AdditionalDomains:
		o.StrictSniHostHeaderCheckChoice = &GlobalSpecType_AdditionalDomains{AdditionalDomains: of.AdditionalDomains}

	case *CreateSpecType_EnableStrictSniHostHeaderCheck:
		o.StrictSniHostHeaderCheckChoice = &GlobalSpecType_EnableStrictSniHostHeaderCheck{EnableStrictSniHostHeaderCheck: of.EnableStrictSniHostHeaderCheck}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetStrictSniHostHeaderCheckChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.StrictSniHostHeaderCheckChoice.(type) {
	case nil:
		r.StrictSniHostHeaderCheckChoice = nil

	case *GlobalSpecType_AdditionalDomains:
		r.StrictSniHostHeaderCheckChoice = &CreateSpecType_AdditionalDomains{AdditionalDomains: of.AdditionalDomains}

	case *GlobalSpecType_EnableStrictSniHostHeaderCheck:
		r.StrictSniHostHeaderCheckChoice = &CreateSpecType_EnableStrictSniHostHeaderCheck{EnableStrictSniHostHeaderCheck: of.EnableStrictSniHostHeaderCheck}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetTlsCertificatesChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.TlsCertificatesChoice.(type) {
	case nil:
		o.TlsCertificatesChoice = nil

	case *CreateSpecType_TlsCertParams:
		o.TlsCertificatesChoice = &GlobalSpecType_TlsCertParams{TlsCertParams: of.TlsCertParams}

	case *CreateSpecType_TlsParameters:
		o.TlsCertificatesChoice = &GlobalSpecType_TlsParameters{TlsParameters: of.TlsParameters}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetTlsCertificatesChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.TlsCertificatesChoice.(type) {
	case nil:
		r.TlsCertificatesChoice = nil

	case *GlobalSpecType_TlsCertParams:
		r.TlsCertificatesChoice = &CreateSpecType_TlsCertParams{TlsCertParams: of.TlsCertParams}

	case *GlobalSpecType_TlsParameters:
		r.TlsCertificatesChoice = &CreateSpecType_TlsParameters{TlsParameters: of.TlsParameters}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.AddLocation = f.GetAddLocation()
	m.AdvertisePolicies = f.GetAdvertisePolicies()
	m.ApiSpec = f.GetApiSpec()
	m.GetAuthenticationChoiceFromGlobalSpecType(f)
	m.BufferPolicy = f.GetBufferPolicy()
	m.GetChallengeTypeFromGlobalSpecType(f)
	m.CoalescingOptions = f.GetCoalescingOptions()
	m.CompressionParams = f.GetCompressionParams()
	m.ConnectionIdleTimeout = f.GetConnectionIdleTimeout()
	m.CookiesToModify = f.GetCookiesToModify()
	m.CorsPolicy = f.GetCorsPolicy()
	m.CsrfPolicy = f.GetCsrfPolicy()
	m.CustomErrors = f.GetCustomErrors()
	m.GetDefaultLbChoiceFromGlobalSpecType(f)
	m.DisableDefaultErrorPages = f.GetDisableDefaultErrorPages()
	m.DisableDnsResolve = f.GetDisableDnsResolve()
	m.DnsProxyConfiguration = f.GetDnsProxyConfiguration()
	m.DomainCertMap = f.GetDomainCertMap()
	m.Domains = f.GetDomains()
	m.DynamicReverseProxy = f.GetDynamicReverseProxy()
	m.HeaderTransformationType = f.GetHeaderTransformationType()
	m.HttpProtocolOptions = f.GetHttpProtocolOptions()
	m.IdleTimeout = f.GetIdleTimeout()
	m.MaskingConfig = f.GetMaskingConfig()
	m.MaxDirectResponseBodySize = f.GetMaxDirectResponseBodySize()
	m.MaxRequestHeaderSize = f.GetMaxRequestHeaderSize()
	m.GetPathNormalizeChoiceFromGlobalSpecType(f)
	m.Proxy = f.GetProxy()
	m.RateLimiterAllowedPrefixes = f.GetRateLimiterAllowedPrefixes()
	m.RequestCookiesToAdd = f.GetRequestCookiesToAdd()
	m.RequestCookiesToRemove = f.GetRequestCookiesToRemove()
	m.RequestHeadersToAdd = f.GetRequestHeadersToAdd()
	m.RequestHeadersToRemove = f.GetRequestHeadersToRemove()
	m.ResponseCookiesToAdd = f.GetResponseCookiesToAdd()
	m.ResponseCookiesToRemove = f.GetResponseCookiesToRemove()
	m.ResponseHeadersToAdd = f.GetResponseHeadersToAdd()
	m.ResponseHeadersToRemove = f.GetResponseHeadersToRemove()
	m.RetryPolicy = f.GetRetryPolicy()
	m.Routes = f.GetRoutes()
	m.SensitiveDataPolicy = f.GetSensitiveDataPolicy()
	m.GetServerHeaderChoiceFromGlobalSpecType(f)
	m.SlowDdosMitigation = f.GetSlowDdosMitigation()
	m.GetStrictSniHostHeaderCheckChoiceFromGlobalSpecType(f)
	m.TemporaryUserBlocking = f.GetTemporaryUserBlocking()
	m.GetTlsCertificatesChoiceFromGlobalSpecType(f)
	m.UserIdentification = f.GetUserIdentification()
	m.WafType = f.GetWafType()
	m.ZtnaProxyConfigurations = f.GetZtnaProxyConfigurations()
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.AddLocation = m1.AddLocation
	f.AdvertisePolicies = m1.AdvertisePolicies
	f.ApiSpec = m1.ApiSpec
	m1.SetAuthenticationChoiceToGlobalSpecType(f)
	f.BufferPolicy = m1.BufferPolicy
	m1.SetChallengeTypeToGlobalSpecType(f)
	f.CoalescingOptions = m1.CoalescingOptions
	f.CompressionParams = m1.CompressionParams
	f.ConnectionIdleTimeout = m1.ConnectionIdleTimeout
	f.CookiesToModify = m1.CookiesToModify
	f.CorsPolicy = m1.CorsPolicy
	f.CsrfPolicy = m1.CsrfPolicy
	f.CustomErrors = m1.CustomErrors
	m1.SetDefaultLbChoiceToGlobalSpecType(f)
	f.DisableDefaultErrorPages = m1.DisableDefaultErrorPages
	f.DisableDnsResolve = m1.DisableDnsResolve
	f.DnsProxyConfiguration = m1.DnsProxyConfiguration
	f.DomainCertMap = m1.DomainCertMap
	f.Domains = m1.Domains
	f.DynamicReverseProxy = m1.DynamicReverseProxy
	f.HeaderTransformationType = m1.HeaderTransformationType
	f.HttpProtocolOptions = m1.HttpProtocolOptions
	f.IdleTimeout = m1.IdleTimeout
	f.MaskingConfig = m1.MaskingConfig
	f.MaxDirectResponseBodySize = m1.MaxDirectResponseBodySize
	f.MaxRequestHeaderSize = m1.MaxRequestHeaderSize
	m1.SetPathNormalizeChoiceToGlobalSpecType(f)
	f.Proxy = m1.Proxy
	f.RateLimiterAllowedPrefixes = m1.RateLimiterAllowedPrefixes
	f.RequestCookiesToAdd = m1.RequestCookiesToAdd
	f.RequestCookiesToRemove = m1.RequestCookiesToRemove
	f.RequestHeadersToAdd = m1.RequestHeadersToAdd
	f.RequestHeadersToRemove = m1.RequestHeadersToRemove
	f.ResponseCookiesToAdd = m1.ResponseCookiesToAdd
	f.ResponseCookiesToRemove = m1.ResponseCookiesToRemove
	f.ResponseHeadersToAdd = m1.ResponseHeadersToAdd
	f.ResponseHeadersToRemove = m1.ResponseHeadersToRemove
	f.RetryPolicy = m1.RetryPolicy
	f.Routes = m1.Routes
	f.SensitiveDataPolicy = m1.SensitiveDataPolicy
	m1.SetServerHeaderChoiceToGlobalSpecType(f)
	f.SlowDdosMitigation = m1.SlowDdosMitigation
	m1.SetStrictSniHostHeaderCheckChoiceToGlobalSpecType(f)
	f.TemporaryUserBlocking = m1.TemporaryUserBlocking
	m1.SetTlsCertificatesChoiceToGlobalSpecType(f)
	f.UserIdentification = m1.UserIdentification
	f.WafType = m1.WafType
	f.ZtnaProxyConfigurations = m1.ZtnaProxyConfigurations
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetAuthenticationChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.AuthenticationChoice.(type) {
	case nil:
		o.AuthenticationChoice = nil

	case *GetSpecType_Authentication:
		o.AuthenticationChoice = &GlobalSpecType_Authentication{Authentication: of.Authentication}

	case *GetSpecType_NoAuthentication:
		o.AuthenticationChoice = &GlobalSpecType_NoAuthentication{NoAuthentication: of.NoAuthentication}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetAuthenticationChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.AuthenticationChoice.(type) {
	case nil:
		r.AuthenticationChoice = nil

	case *GlobalSpecType_Authentication:
		r.AuthenticationChoice = &GetSpecType_Authentication{Authentication: of.Authentication}

	case *GlobalSpecType_NoAuthentication:
		r.AuthenticationChoice = &GetSpecType_NoAuthentication{NoAuthentication: of.NoAuthentication}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetChallengeTypeToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ChallengeType.(type) {
	case nil:
		o.ChallengeType = nil

	case *GetSpecType_CaptchaChallenge:
		o.ChallengeType = &GlobalSpecType_CaptchaChallenge{CaptchaChallenge: of.CaptchaChallenge}

	case *GetSpecType_JsChallenge:
		o.ChallengeType = &GlobalSpecType_JsChallenge{JsChallenge: of.JsChallenge}

	case *GetSpecType_NoChallenge:
		o.ChallengeType = &GlobalSpecType_NoChallenge{NoChallenge: of.NoChallenge}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetChallengeTypeFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ChallengeType.(type) {
	case nil:
		r.ChallengeType = nil

	case *GlobalSpecType_CaptchaChallenge:
		r.ChallengeType = &GetSpecType_CaptchaChallenge{CaptchaChallenge: of.CaptchaChallenge}

	case *GlobalSpecType_JsChallenge:
		r.ChallengeType = &GetSpecType_JsChallenge{JsChallenge: of.JsChallenge}

	case *GlobalSpecType_NoChallenge:
		r.ChallengeType = &GetSpecType_NoChallenge{NoChallenge: of.NoChallenge}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetDdosAutoMitigationActionToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DdosAutoMitigationAction.(type) {
	case nil:
		o.DdosAutoMitigationAction = nil

	case *GetSpecType_Block:
		o.DdosAutoMitigationAction = &GlobalSpecType_Block{Block: of.Block}

	case *GetSpecType_DdosJsChallenge:
		o.DdosAutoMitigationAction = &GlobalSpecType_DdosJsChallenge{DdosJsChallenge: of.DdosJsChallenge}

	case *GetSpecType_L7DdosActionDefault:
		o.DdosAutoMitigationAction = &GlobalSpecType_L7DdosActionDefault{L7DdosActionDefault: of.L7DdosActionDefault}

	case *GetSpecType_L7DdosActionNone:
		o.DdosAutoMitigationAction = &GlobalSpecType_L7DdosActionNone{L7DdosActionNone: of.L7DdosActionNone}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetDdosAutoMitigationActionFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DdosAutoMitigationAction.(type) {
	case nil:
		r.DdosAutoMitigationAction = nil

	case *GlobalSpecType_Block:
		r.DdosAutoMitigationAction = &GetSpecType_Block{Block: of.Block}

	case *GlobalSpecType_DdosJsChallenge:
		r.DdosAutoMitigationAction = &GetSpecType_DdosJsChallenge{DdosJsChallenge: of.DdosJsChallenge}

	case *GlobalSpecType_L7DdosActionDefault:
		r.DdosAutoMitigationAction = &GetSpecType_L7DdosActionDefault{L7DdosActionDefault: of.L7DdosActionDefault}

	case *GlobalSpecType_L7DdosActionNone:
		r.DdosAutoMitigationAction = &GetSpecType_L7DdosActionNone{L7DdosActionNone: of.L7DdosActionNone}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetDefaultLbChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DefaultLbChoice.(type) {
	case nil:
		o.DefaultLbChoice = nil

	case *GetSpecType_DefaultLoadbalancer:
		o.DefaultLbChoice = &GlobalSpecType_DefaultLoadbalancer{DefaultLoadbalancer: of.DefaultLoadbalancer}

	case *GetSpecType_NonDefaultLoadbalancer:
		o.DefaultLbChoice = &GlobalSpecType_NonDefaultLoadbalancer{NonDefaultLoadbalancer: of.NonDefaultLoadbalancer}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetDefaultLbChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DefaultLbChoice.(type) {
	case nil:
		r.DefaultLbChoice = nil

	case *GlobalSpecType_DefaultLoadbalancer:
		r.DefaultLbChoice = &GetSpecType_DefaultLoadbalancer{DefaultLoadbalancer: of.DefaultLoadbalancer}

	case *GlobalSpecType_NonDefaultLoadbalancer:
		r.DefaultLbChoice = &GetSpecType_NonDefaultLoadbalancer{NonDefaultLoadbalancer: of.NonDefaultLoadbalancer}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetDnsZoneStateChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DnsZoneStateChoice.(type) {
	case nil:
		o.DnsZoneStateChoice = nil

	case *GetSpecType_NotReady:
		o.DnsZoneStateChoice = &GlobalSpecType_NotReady{NotReady: of.NotReady}

	case *GetSpecType_Ready:
		o.DnsZoneStateChoice = &GlobalSpecType_Ready{Ready: of.Ready}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetDnsZoneStateChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DnsZoneStateChoice.(type) {
	case nil:
		r.DnsZoneStateChoice = nil

	case *GlobalSpecType_NotReady:
		r.DnsZoneStateChoice = &GetSpecType_NotReady{NotReady: of.NotReady}

	case *GlobalSpecType_Ready:
		r.DnsZoneStateChoice = &GetSpecType_Ready{Ready: of.Ready}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetPathNormalizeChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.PathNormalizeChoice.(type) {
	case nil:
		o.PathNormalizeChoice = nil

	case *GetSpecType_DisablePathNormalize:
		o.PathNormalizeChoice = &GlobalSpecType_DisablePathNormalize{DisablePathNormalize: of.DisablePathNormalize}

	case *GetSpecType_EnablePathNormalize:
		o.PathNormalizeChoice = &GlobalSpecType_EnablePathNormalize{EnablePathNormalize: of.EnablePathNormalize}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetPathNormalizeChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.PathNormalizeChoice.(type) {
	case nil:
		r.PathNormalizeChoice = nil

	case *GlobalSpecType_DisablePathNormalize:
		r.PathNormalizeChoice = &GetSpecType_DisablePathNormalize{DisablePathNormalize: of.DisablePathNormalize}

	case *GlobalSpecType_EnablePathNormalize:
		r.PathNormalizeChoice = &GetSpecType_EnablePathNormalize{EnablePathNormalize: of.EnablePathNormalize}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetServerHeaderChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ServerHeaderChoice.(type) {
	case nil:
		o.ServerHeaderChoice = nil

	case *GetSpecType_AppendServerName:
		o.ServerHeaderChoice = &GlobalSpecType_AppendServerName{AppendServerName: of.AppendServerName}

	case *GetSpecType_DefaultHeader:
		o.ServerHeaderChoice = &GlobalSpecType_DefaultHeader{DefaultHeader: of.DefaultHeader}

	case *GetSpecType_PassThrough:
		o.ServerHeaderChoice = &GlobalSpecType_PassThrough{PassThrough: of.PassThrough}

	case *GetSpecType_ServerName:
		o.ServerHeaderChoice = &GlobalSpecType_ServerName{ServerName: of.ServerName}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetServerHeaderChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ServerHeaderChoice.(type) {
	case nil:
		r.ServerHeaderChoice = nil

	case *GlobalSpecType_AppendServerName:
		r.ServerHeaderChoice = &GetSpecType_AppendServerName{AppendServerName: of.AppendServerName}

	case *GlobalSpecType_DefaultHeader:
		r.ServerHeaderChoice = &GetSpecType_DefaultHeader{DefaultHeader: of.DefaultHeader}

	case *GlobalSpecType_PassThrough:
		r.ServerHeaderChoice = &GetSpecType_PassThrough{PassThrough: of.PassThrough}

	case *GlobalSpecType_ServerName:
		r.ServerHeaderChoice = &GetSpecType_ServerName{ServerName: of.ServerName}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetStrictSniHostHeaderCheckChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.StrictSniHostHeaderCheckChoice.(type) {
	case nil:
		o.StrictSniHostHeaderCheckChoice = nil

	case *GetSpecType_AdditionalDomains:
		o.StrictSniHostHeaderCheckChoice = &GlobalSpecType_AdditionalDomains{AdditionalDomains: of.AdditionalDomains}

	case *GetSpecType_EnableStrictSniHostHeaderCheck:
		o.StrictSniHostHeaderCheckChoice = &GlobalSpecType_EnableStrictSniHostHeaderCheck{EnableStrictSniHostHeaderCheck: of.EnableStrictSniHostHeaderCheck}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetStrictSniHostHeaderCheckChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.StrictSniHostHeaderCheckChoice.(type) {
	case nil:
		r.StrictSniHostHeaderCheckChoice = nil

	case *GlobalSpecType_AdditionalDomains:
		r.StrictSniHostHeaderCheckChoice = &GetSpecType_AdditionalDomains{AdditionalDomains: of.AdditionalDomains}

	case *GlobalSpecType_EnableStrictSniHostHeaderCheck:
		r.StrictSniHostHeaderCheckChoice = &GetSpecType_EnableStrictSniHostHeaderCheck{EnableStrictSniHostHeaderCheck: of.EnableStrictSniHostHeaderCheck}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetTlsCertificatesChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.TlsCertificatesChoice.(type) {
	case nil:
		o.TlsCertificatesChoice = nil

	case *GetSpecType_TlsCertParams:
		o.TlsCertificatesChoice = &GlobalSpecType_TlsCertParams{TlsCertParams: of.TlsCertParams}

	case *GetSpecType_TlsParameters:
		o.TlsCertificatesChoice = &GlobalSpecType_TlsParameters{TlsParameters: of.TlsParameters}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetTlsCertificatesChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.TlsCertificatesChoice.(type) {
	case nil:
		r.TlsCertificatesChoice = nil

	case *GlobalSpecType_TlsCertParams:
		r.TlsCertificatesChoice = &GetSpecType_TlsCertParams{TlsCertParams: of.TlsCertParams}

	case *GlobalSpecType_TlsParameters:
		r.TlsCertificatesChoice = &GetSpecType_TlsParameters{TlsParameters: of.TlsParameters}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.AddLocation = f.GetAddLocation()
	m.AdvertisePolicies = f.GetAdvertisePolicies()
	m.ApiSpec = f.GetApiSpec()
	m.GetAuthenticationChoiceFromGlobalSpecType(f)
	m.AutoCertErrorMsg = f.GetAutoCertErrorMsg()
	m.AutoCertInfo = f.GetAutoCertInfo()
	m.BufferPolicy = f.GetBufferPolicy()
	m.CdnService = f.GetCdnService()
	m.GetChallengeTypeFromGlobalSpecType(f)
	m.CoalescingOptions = f.GetCoalescingOptions()
	m.CompressionParams = f.GetCompressionParams()
	m.ConnectionIdleTimeout = f.GetConnectionIdleTimeout()
	m.CookiesToModify = f.GetCookiesToModify()
	m.CorsPolicy = f.GetCorsPolicy()
	m.CsrfPolicy = f.GetCsrfPolicy()
	m.CustomErrors = f.GetCustomErrors()
	m.GetDdosAutoMitigationActionFromGlobalSpecType(f)
	m.GetDefaultLbChoiceFromGlobalSpecType(f)
	m.DisableDefaultErrorPages = f.GetDisableDefaultErrorPages()
	m.DisableDnsResolve = f.GetDisableDnsResolve()
	m.DnsInfo = f.GetDnsInfo()
	m.DnsProxyConfiguration = f.GetDnsProxyConfiguration()
	m.GetDnsZoneStateChoiceFromGlobalSpecType(f)
	m.DomainCertMap = f.GetDomainCertMap()
	m.Domains = f.GetDomains()
	m.DynamicReverseProxy = f.GetDynamicReverseProxy()
	m.HeaderTransformationType = f.GetHeaderTransformationType()
	m.HostName = f.GetHostName()
	m.HttpProtocolOptions = f.GetHttpProtocolOptions()
	m.IdleTimeout = f.GetIdleTimeout()
	m.L7DdosRpsThreshold = f.GetL7DdosRpsThreshold()
	m.MaskingConfig = f.GetMaskingConfig()
	m.MaxDirectResponseBodySize = f.GetMaxDirectResponseBodySize()
	m.MaxRequestHeaderSize = f.GetMaxRequestHeaderSize()
	m.GetPathNormalizeChoiceFromGlobalSpecType(f)
	m.Proxy = f.GetProxy()
	m.RateLimiterAllowedPrefixes = f.GetRateLimiterAllowedPrefixes()
	m.RequestCookiesToAdd = f.GetRequestCookiesToAdd()
	m.RequestCookiesToRemove = f.GetRequestCookiesToRemove()
	m.RequestHeadersToAdd = f.GetRequestHeadersToAdd()
	m.RequestHeadersToRemove = f.GetRequestHeadersToRemove()
	m.ResponseCookiesToAdd = f.GetResponseCookiesToAdd()
	m.ResponseCookiesToRemove = f.GetResponseCookiesToRemove()
	m.ResponseHeadersToAdd = f.GetResponseHeadersToAdd()
	m.ResponseHeadersToRemove = f.GetResponseHeadersToRemove()
	m.RetryPolicy = f.GetRetryPolicy()
	m.Routes = f.GetRoutes()
	m.SensitiveDataPolicy = f.GetSensitiveDataPolicy()
	m.GetServerHeaderChoiceFromGlobalSpecType(f)
	m.SlowDdosMitigation = f.GetSlowDdosMitigation()
	m.State = f.GetState()
	m.GetStrictSniHostHeaderCheckChoiceFromGlobalSpecType(f)
	m.TemporaryUserBlocking = f.GetTemporaryUserBlocking()
	m.GetTlsCertificatesChoiceFromGlobalSpecType(f)
	m.Type = f.GetType()
	m.UserIdentification = f.GetUserIdentification()
	m.WafType = f.GetWafType()
	m.ZtnaProxyConfigurations = f.GetZtnaProxyConfigurations()
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.AddLocation = m1.AddLocation
	f.AdvertisePolicies = m1.AdvertisePolicies
	f.ApiSpec = m1.ApiSpec
	m1.SetAuthenticationChoiceToGlobalSpecType(f)
	f.AutoCertErrorMsg = m1.AutoCertErrorMsg
	f.AutoCertInfo = m1.AutoCertInfo
	f.BufferPolicy = m1.BufferPolicy
	f.CdnService = m1.CdnService
	m1.SetChallengeTypeToGlobalSpecType(f)
	f.CoalescingOptions = m1.CoalescingOptions
	f.CompressionParams = m1.CompressionParams
	f.ConnectionIdleTimeout = m1.ConnectionIdleTimeout
	f.CookiesToModify = m1.CookiesToModify
	f.CorsPolicy = m1.CorsPolicy
	f.CsrfPolicy = m1.CsrfPolicy
	f.CustomErrors = m1.CustomErrors
	m1.SetDdosAutoMitigationActionToGlobalSpecType(f)
	m1.SetDefaultLbChoiceToGlobalSpecType(f)
	f.DisableDefaultErrorPages = m1.DisableDefaultErrorPages
	f.DisableDnsResolve = m1.DisableDnsResolve
	f.DnsInfo = m1.DnsInfo
	f.DnsProxyConfiguration = m1.DnsProxyConfiguration
	m1.SetDnsZoneStateChoiceToGlobalSpecType(f)
	f.DomainCertMap = m1.DomainCertMap
	f.Domains = m1.Domains
	f.DynamicReverseProxy = m1.DynamicReverseProxy
	f.HeaderTransformationType = m1.HeaderTransformationType
	f.HostName = m1.HostName
	f.HttpProtocolOptions = m1.HttpProtocolOptions
	f.IdleTimeout = m1.IdleTimeout
	f.L7DdosRpsThreshold = m1.L7DdosRpsThreshold
	f.MaskingConfig = m1.MaskingConfig
	f.MaxDirectResponseBodySize = m1.MaxDirectResponseBodySize
	f.MaxRequestHeaderSize = m1.MaxRequestHeaderSize
	m1.SetPathNormalizeChoiceToGlobalSpecType(f)
	f.Proxy = m1.Proxy
	f.RateLimiterAllowedPrefixes = m1.RateLimiterAllowedPrefixes
	f.RequestCookiesToAdd = m1.RequestCookiesToAdd
	f.RequestCookiesToRemove = m1.RequestCookiesToRemove
	f.RequestHeadersToAdd = m1.RequestHeadersToAdd
	f.RequestHeadersToRemove = m1.RequestHeadersToRemove
	f.ResponseCookiesToAdd = m1.ResponseCookiesToAdd
	f.ResponseCookiesToRemove = m1.ResponseCookiesToRemove
	f.ResponseHeadersToAdd = m1.ResponseHeadersToAdd
	f.ResponseHeadersToRemove = m1.ResponseHeadersToRemove
	f.RetryPolicy = m1.RetryPolicy
	f.Routes = m1.Routes
	f.SensitiveDataPolicy = m1.SensitiveDataPolicy
	m1.SetServerHeaderChoiceToGlobalSpecType(f)
	f.SlowDdosMitigation = m1.SlowDdosMitigation
	f.State = m1.State
	m1.SetStrictSniHostHeaderCheckChoiceToGlobalSpecType(f)
	f.TemporaryUserBlocking = m1.TemporaryUserBlocking
	m1.SetTlsCertificatesChoiceToGlobalSpecType(f)
	f.Type = m1.Type
	f.UserIdentification = m1.UserIdentification
	f.WafType = m1.WafType
	f.ZtnaProxyConfigurations = m1.ZtnaProxyConfigurations
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetAuthenticationChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.AuthenticationChoice.(type) {
	case nil:
		o.AuthenticationChoice = nil

	case *ReplaceSpecType_Authentication:
		o.AuthenticationChoice = &GlobalSpecType_Authentication{Authentication: of.Authentication}

	case *ReplaceSpecType_NoAuthentication:
		o.AuthenticationChoice = &GlobalSpecType_NoAuthentication{NoAuthentication: of.NoAuthentication}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetAuthenticationChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.AuthenticationChoice.(type) {
	case nil:
		r.AuthenticationChoice = nil

	case *GlobalSpecType_Authentication:
		r.AuthenticationChoice = &ReplaceSpecType_Authentication{Authentication: of.Authentication}

	case *GlobalSpecType_NoAuthentication:
		r.AuthenticationChoice = &ReplaceSpecType_NoAuthentication{NoAuthentication: of.NoAuthentication}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetChallengeTypeToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ChallengeType.(type) {
	case nil:
		o.ChallengeType = nil

	case *ReplaceSpecType_CaptchaChallenge:
		o.ChallengeType = &GlobalSpecType_CaptchaChallenge{CaptchaChallenge: of.CaptchaChallenge}

	case *ReplaceSpecType_JsChallenge:
		o.ChallengeType = &GlobalSpecType_JsChallenge{JsChallenge: of.JsChallenge}

	case *ReplaceSpecType_NoChallenge:
		o.ChallengeType = &GlobalSpecType_NoChallenge{NoChallenge: of.NoChallenge}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetChallengeTypeFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ChallengeType.(type) {
	case nil:
		r.ChallengeType = nil

	case *GlobalSpecType_CaptchaChallenge:
		r.ChallengeType = &ReplaceSpecType_CaptchaChallenge{CaptchaChallenge: of.CaptchaChallenge}

	case *GlobalSpecType_JsChallenge:
		r.ChallengeType = &ReplaceSpecType_JsChallenge{JsChallenge: of.JsChallenge}

	case *GlobalSpecType_NoChallenge:
		r.ChallengeType = &ReplaceSpecType_NoChallenge{NoChallenge: of.NoChallenge}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetDefaultLbChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DefaultLbChoice.(type) {
	case nil:
		o.DefaultLbChoice = nil

	case *ReplaceSpecType_DefaultLoadbalancer:
		o.DefaultLbChoice = &GlobalSpecType_DefaultLoadbalancer{DefaultLoadbalancer: of.DefaultLoadbalancer}

	case *ReplaceSpecType_NonDefaultLoadbalancer:
		o.DefaultLbChoice = &GlobalSpecType_NonDefaultLoadbalancer{NonDefaultLoadbalancer: of.NonDefaultLoadbalancer}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetDefaultLbChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DefaultLbChoice.(type) {
	case nil:
		r.DefaultLbChoice = nil

	case *GlobalSpecType_DefaultLoadbalancer:
		r.DefaultLbChoice = &ReplaceSpecType_DefaultLoadbalancer{DefaultLoadbalancer: of.DefaultLoadbalancer}

	case *GlobalSpecType_NonDefaultLoadbalancer:
		r.DefaultLbChoice = &ReplaceSpecType_NonDefaultLoadbalancer{NonDefaultLoadbalancer: of.NonDefaultLoadbalancer}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetPathNormalizeChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.PathNormalizeChoice.(type) {
	case nil:
		o.PathNormalizeChoice = nil

	case *ReplaceSpecType_DisablePathNormalize:
		o.PathNormalizeChoice = &GlobalSpecType_DisablePathNormalize{DisablePathNormalize: of.DisablePathNormalize}

	case *ReplaceSpecType_EnablePathNormalize:
		o.PathNormalizeChoice = &GlobalSpecType_EnablePathNormalize{EnablePathNormalize: of.EnablePathNormalize}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetPathNormalizeChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.PathNormalizeChoice.(type) {
	case nil:
		r.PathNormalizeChoice = nil

	case *GlobalSpecType_DisablePathNormalize:
		r.PathNormalizeChoice = &ReplaceSpecType_DisablePathNormalize{DisablePathNormalize: of.DisablePathNormalize}

	case *GlobalSpecType_EnablePathNormalize:
		r.PathNormalizeChoice = &ReplaceSpecType_EnablePathNormalize{EnablePathNormalize: of.EnablePathNormalize}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetServerHeaderChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ServerHeaderChoice.(type) {
	case nil:
		o.ServerHeaderChoice = nil

	case *ReplaceSpecType_AppendServerName:
		o.ServerHeaderChoice = &GlobalSpecType_AppendServerName{AppendServerName: of.AppendServerName}

	case *ReplaceSpecType_DefaultHeader:
		o.ServerHeaderChoice = &GlobalSpecType_DefaultHeader{DefaultHeader: of.DefaultHeader}

	case *ReplaceSpecType_PassThrough:
		o.ServerHeaderChoice = &GlobalSpecType_PassThrough{PassThrough: of.PassThrough}

	case *ReplaceSpecType_ServerName:
		o.ServerHeaderChoice = &GlobalSpecType_ServerName{ServerName: of.ServerName}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetServerHeaderChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ServerHeaderChoice.(type) {
	case nil:
		r.ServerHeaderChoice = nil

	case *GlobalSpecType_AppendServerName:
		r.ServerHeaderChoice = &ReplaceSpecType_AppendServerName{AppendServerName: of.AppendServerName}

	case *GlobalSpecType_DefaultHeader:
		r.ServerHeaderChoice = &ReplaceSpecType_DefaultHeader{DefaultHeader: of.DefaultHeader}

	case *GlobalSpecType_PassThrough:
		r.ServerHeaderChoice = &ReplaceSpecType_PassThrough{PassThrough: of.PassThrough}

	case *GlobalSpecType_ServerName:
		r.ServerHeaderChoice = &ReplaceSpecType_ServerName{ServerName: of.ServerName}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetStrictSniHostHeaderCheckChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.StrictSniHostHeaderCheckChoice.(type) {
	case nil:
		o.StrictSniHostHeaderCheckChoice = nil

	case *ReplaceSpecType_AdditionalDomains:
		o.StrictSniHostHeaderCheckChoice = &GlobalSpecType_AdditionalDomains{AdditionalDomains: of.AdditionalDomains}

	case *ReplaceSpecType_EnableStrictSniHostHeaderCheck:
		o.StrictSniHostHeaderCheckChoice = &GlobalSpecType_EnableStrictSniHostHeaderCheck{EnableStrictSniHostHeaderCheck: of.EnableStrictSniHostHeaderCheck}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetStrictSniHostHeaderCheckChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.StrictSniHostHeaderCheckChoice.(type) {
	case nil:
		r.StrictSniHostHeaderCheckChoice = nil

	case *GlobalSpecType_AdditionalDomains:
		r.StrictSniHostHeaderCheckChoice = &ReplaceSpecType_AdditionalDomains{AdditionalDomains: of.AdditionalDomains}

	case *GlobalSpecType_EnableStrictSniHostHeaderCheck:
		r.StrictSniHostHeaderCheckChoice = &ReplaceSpecType_EnableStrictSniHostHeaderCheck{EnableStrictSniHostHeaderCheck: of.EnableStrictSniHostHeaderCheck}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetTlsCertificatesChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.TlsCertificatesChoice.(type) {
	case nil:
		o.TlsCertificatesChoice = nil

	case *ReplaceSpecType_TlsCertParams:
		o.TlsCertificatesChoice = &GlobalSpecType_TlsCertParams{TlsCertParams: of.TlsCertParams}

	case *ReplaceSpecType_TlsParameters:
		o.TlsCertificatesChoice = &GlobalSpecType_TlsParameters{TlsParameters: of.TlsParameters}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetTlsCertificatesChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.TlsCertificatesChoice.(type) {
	case nil:
		r.TlsCertificatesChoice = nil

	case *GlobalSpecType_TlsCertParams:
		r.TlsCertificatesChoice = &ReplaceSpecType_TlsCertParams{TlsCertParams: of.TlsCertParams}

	case *GlobalSpecType_TlsParameters:
		r.TlsCertificatesChoice = &ReplaceSpecType_TlsParameters{TlsParameters: of.TlsParameters}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.AddLocation = f.GetAddLocation()
	m.AdvertisePolicies = f.GetAdvertisePolicies()
	m.ApiSpec = f.GetApiSpec()
	m.GetAuthenticationChoiceFromGlobalSpecType(f)
	m.BufferPolicy = f.GetBufferPolicy()
	m.GetChallengeTypeFromGlobalSpecType(f)
	m.CoalescingOptions = f.GetCoalescingOptions()
	m.CompressionParams = f.GetCompressionParams()
	m.ConnectionIdleTimeout = f.GetConnectionIdleTimeout()
	m.CookiesToModify = f.GetCookiesToModify()
	m.CorsPolicy = f.GetCorsPolicy()
	m.CsrfPolicy = f.GetCsrfPolicy()
	m.CustomErrors = f.GetCustomErrors()
	m.GetDefaultLbChoiceFromGlobalSpecType(f)
	m.DisableDefaultErrorPages = f.GetDisableDefaultErrorPages()
	m.DisableDnsResolve = f.GetDisableDnsResolve()
	m.DnsProxyConfiguration = f.GetDnsProxyConfiguration()
	m.DomainCertMap = f.GetDomainCertMap()
	m.Domains = f.GetDomains()
	m.DynamicReverseProxy = f.GetDynamicReverseProxy()
	m.HeaderTransformationType = f.GetHeaderTransformationType()
	m.HttpProtocolOptions = f.GetHttpProtocolOptions()
	m.IdleTimeout = f.GetIdleTimeout()
	m.MaskingConfig = f.GetMaskingConfig()
	m.MaxDirectResponseBodySize = f.GetMaxDirectResponseBodySize()
	m.MaxRequestHeaderSize = f.GetMaxRequestHeaderSize()
	m.GetPathNormalizeChoiceFromGlobalSpecType(f)
	m.Proxy = f.GetProxy()
	m.RateLimiterAllowedPrefixes = f.GetRateLimiterAllowedPrefixes()
	m.RequestCookiesToAdd = f.GetRequestCookiesToAdd()
	m.RequestCookiesToRemove = f.GetRequestCookiesToRemove()
	m.RequestHeadersToAdd = f.GetRequestHeadersToAdd()
	m.RequestHeadersToRemove = f.GetRequestHeadersToRemove()
	m.ResponseCookiesToAdd = f.GetResponseCookiesToAdd()
	m.ResponseCookiesToRemove = f.GetResponseCookiesToRemove()
	m.ResponseHeadersToAdd = f.GetResponseHeadersToAdd()
	m.ResponseHeadersToRemove = f.GetResponseHeadersToRemove()
	m.RetryPolicy = f.GetRetryPolicy()
	m.Routes = f.GetRoutes()
	m.SensitiveDataPolicy = f.GetSensitiveDataPolicy()
	m.GetServerHeaderChoiceFromGlobalSpecType(f)
	m.SlowDdosMitigation = f.GetSlowDdosMitigation()
	m.GetStrictSniHostHeaderCheckChoiceFromGlobalSpecType(f)
	m.TemporaryUserBlocking = f.GetTemporaryUserBlocking()
	m.GetTlsCertificatesChoiceFromGlobalSpecType(f)
	m.UserIdentification = f.GetUserIdentification()
	m.WafType = f.GetWafType()
	m.ZtnaProxyConfigurations = f.GetZtnaProxyConfigurations()
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.AddLocation = m1.AddLocation
	f.AdvertisePolicies = m1.AdvertisePolicies
	f.ApiSpec = m1.ApiSpec
	m1.SetAuthenticationChoiceToGlobalSpecType(f)
	f.BufferPolicy = m1.BufferPolicy
	m1.SetChallengeTypeToGlobalSpecType(f)
	f.CoalescingOptions = m1.CoalescingOptions
	f.CompressionParams = m1.CompressionParams
	f.ConnectionIdleTimeout = m1.ConnectionIdleTimeout
	f.CookiesToModify = m1.CookiesToModify
	f.CorsPolicy = m1.CorsPolicy
	f.CsrfPolicy = m1.CsrfPolicy
	f.CustomErrors = m1.CustomErrors
	m1.SetDefaultLbChoiceToGlobalSpecType(f)
	f.DisableDefaultErrorPages = m1.DisableDefaultErrorPages
	f.DisableDnsResolve = m1.DisableDnsResolve
	f.DnsProxyConfiguration = m1.DnsProxyConfiguration
	f.DomainCertMap = m1.DomainCertMap
	f.Domains = m1.Domains
	f.DynamicReverseProxy = m1.DynamicReverseProxy
	f.HeaderTransformationType = m1.HeaderTransformationType
	f.HttpProtocolOptions = m1.HttpProtocolOptions
	f.IdleTimeout = m1.IdleTimeout
	f.MaskingConfig = m1.MaskingConfig
	f.MaxDirectResponseBodySize = m1.MaxDirectResponseBodySize
	f.MaxRequestHeaderSize = m1.MaxRequestHeaderSize
	m1.SetPathNormalizeChoiceToGlobalSpecType(f)
	f.Proxy = m1.Proxy
	f.RateLimiterAllowedPrefixes = m1.RateLimiterAllowedPrefixes
	f.RequestCookiesToAdd = m1.RequestCookiesToAdd
	f.RequestCookiesToRemove = m1.RequestCookiesToRemove
	f.RequestHeadersToAdd = m1.RequestHeadersToAdd
	f.RequestHeadersToRemove = m1.RequestHeadersToRemove
	f.ResponseCookiesToAdd = m1.ResponseCookiesToAdd
	f.ResponseCookiesToRemove = m1.ResponseCookiesToRemove
	f.ResponseHeadersToAdd = m1.ResponseHeadersToAdd
	f.ResponseHeadersToRemove = m1.ResponseHeadersToRemove
	f.RetryPolicy = m1.RetryPolicy
	f.Routes = m1.Routes
	f.SensitiveDataPolicy = m1.SensitiveDataPolicy
	m1.SetServerHeaderChoiceToGlobalSpecType(f)
	f.SlowDdosMitigation = m1.SlowDdosMitigation
	m1.SetStrictSniHostHeaderCheckChoiceToGlobalSpecType(f)
	f.TemporaryUserBlocking = m1.TemporaryUserBlocking
	m1.SetTlsCertificatesChoiceToGlobalSpecType(f)
	f.UserIdentification = m1.UserIdentification
	f.WafType = m1.WafType
	f.ZtnaProxyConfigurations = m1.ZtnaProxyConfigurations
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
