// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package global_config

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AllowRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AllowRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AllowRule) DeepCopy() *AllowRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AllowRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AllowRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AllowRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AllowRuleValidator().Validate(ctx, m, opts...)
}

type ValidateAllowRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAllowRule) ProtocolTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ProtocolType)
		return int32(i)
	}
	// ProtocolType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ProtocolType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for protocol_type")
	}

	return validatorFn, nil
}

func (v *ValidateAllowRule) MatchTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for match_type")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := MatchRuleTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAllowRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AllowRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AllowRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["enable_status"]; exists {

		vOpts := append(opts, db.WithValidateField("enable_status"))
		if err := fv(ctx, m.GetEnableStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match_type"]; exists {

		vOpts := append(opts, db.WithValidateField("match_type"))
		if err := fv(ctx, m.GetMatchType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["protocol_type"]; exists {

		vOpts := append(opts, db.WithValidateField("protocol_type"))
		if err := fv(ctx, m.GetProtocolType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAllowRuleValidator = func() *ValidateAllowRule {
	v := &ValidateAllowRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhProtocolType := v.ProtocolTypeValidationRuleHandler
	rulesProtocolType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhProtocolType(rulesProtocolType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AllowRule.protocol_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["protocol_type"] = vFn

	vrhMatchType := v.MatchTypeValidationRuleHandler
	rulesMatchType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMatchType(rulesMatchType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AllowRule.match_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match_type"] = vFn

	return v
}()

func AllowRuleValidator() db.Validator {
	return DefaultAllowRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *AttackedDestinationVolumetricThresholds) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AttackedDestinationVolumetricThresholds) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AttackedDestinationVolumetricThresholds) DeepCopy() *AttackedDestinationVolumetricThresholds {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AttackedDestinationVolumetricThresholds{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AttackedDestinationVolumetricThresholds) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AttackedDestinationVolumetricThresholds) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AttackedDestinationVolumetricThresholdsValidator().Validate(ctx, m, opts...)
}

type ValidateAttackedDestinationVolumetricThresholds struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAttackedDestinationVolumetricThresholds) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AttackedDestinationVolumetricThresholds)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AttackedDestinationVolumetricThresholds got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["per_dst_ip_detection_eps"]; exists {

		vOpts := append(opts, db.WithValidateField("per_dst_ip_detection_eps"))
		if err := fv(ctx, m.GetPerDstIpDetectionEps(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["per_dst_ip_limit_eps"]; exists {

		vOpts := append(opts, db.WithValidateField("per_dst_ip_limit_eps"))
		if err := fv(ctx, m.GetPerDstIpLimitEps(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAttackedDestinationVolumetricThresholdsValidator = func() *ValidateAttackedDestinationVolumetricThresholds {
	v := &ValidateAttackedDestinationVolumetricThresholds{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["per_dst_ip_detection_eps"] = ThresholdEPSValidator().Validate

	v.FldValidators["per_dst_ip_limit_eps"] = ThresholdEPSValidator().Validate

	return v
}()

func AttackedDestinationVolumetricThresholdsValidator() db.Validator {
	return DefaultAttackedDestinationVolumetricThresholdsValidator
}

// augmented methods on protoc/std generated struct

func (m *BadActorsVolumetricThresholds) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BadActorsVolumetricThresholds) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BadActorsVolumetricThresholds) DeepCopy() *BadActorsVolumetricThresholds {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BadActorsVolumetricThresholds{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BadActorsVolumetricThresholds) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BadActorsVolumetricThresholds) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BadActorsVolumetricThresholdsValidator().Validate(ctx, m, opts...)
}

type ValidateBadActorsVolumetricThresholds struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBadActorsVolumetricThresholds) PerSourceIpDetectionEpsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for per_source_ip_detection_eps")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ThresholdEPSValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateBadActorsVolumetricThresholds) PerSourceIpLimitEpsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for per_source_ip_limit_eps")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ThresholdEPSValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateBadActorsVolumetricThresholds) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BadActorsVolumetricThresholds)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BadActorsVolumetricThresholds got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["per_source_ip_detection_eps"]; exists {

		vOpts := append(opts, db.WithValidateField("per_source_ip_detection_eps"))
		if err := fv(ctx, m.GetPerSourceIpDetectionEps(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["per_source_ip_limit_eps"]; exists {

		vOpts := append(opts, db.WithValidateField("per_source_ip_limit_eps"))
		if err := fv(ctx, m.GetPerSourceIpLimitEps(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBadActorsVolumetricThresholdsValidator = func() *ValidateBadActorsVolumetricThresholds {
	v := &ValidateBadActorsVolumetricThresholds{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPerSourceIpDetectionEps := v.PerSourceIpDetectionEpsValidationRuleHandler
	rulesPerSourceIpDetectionEps := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPerSourceIpDetectionEps(rulesPerSourceIpDetectionEps)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BadActorsVolumetricThresholds.per_source_ip_detection_eps: %s", err)
		panic(errMsg)
	}
	v.FldValidators["per_source_ip_detection_eps"] = vFn

	vrhPerSourceIpLimitEps := v.PerSourceIpLimitEpsValidationRuleHandler
	rulesPerSourceIpLimitEps := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPerSourceIpLimitEps(rulesPerSourceIpLimitEps)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BadActorsVolumetricThresholds.per_source_ip_limit_eps: %s", err)
		panic(errMsg)
	}
	v.FldValidators["per_source_ip_limit_eps"] = vFn

	return v
}()

func BadActorsVolumetricThresholdsValidator() db.Validator {
	return DefaultBadActorsVolumetricThresholdsValidator
}

// augmented methods on protoc/std generated struct

func (m *DDoSProfile) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DDoSProfile) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DDoSProfile) DeepCopy() *DDoSProfile {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DDoSProfile{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DDoSProfile) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DDoSProfile) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DDoSProfileValidator().Validate(ctx, m, opts...)
}

type ValidateDDoSProfile struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDDoSProfile) DnsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for dns")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := DNSDDoSVectorsValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDDoSProfile) AllowRulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for allow_rules")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*AllowRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := AllowRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for allow_rules")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AllowRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AllowRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated allow_rules")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items allow_rules")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDDoSProfile) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DDoSProfile)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DDoSProfile got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["allow_rules"]; exists {
		vOpts := append(opts, db.WithValidateField("allow_rules"))
		if err := fv(ctx, m.GetAllowRules(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns"]; exists {

		vOpts := append(opts, db.WithValidateField("dns"))
		if err := fv(ctx, m.GetDns(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDDoSProfileValidator = func() *ValidateDDoSProfile {
	v := &ValidateDDoSProfile{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDns := v.DnsValidationRuleHandler
	rulesDns := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDns(rulesDns)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DDoSProfile.dns: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns"] = vFn

	vrhAllowRules := v.AllowRulesValidationRuleHandler
	rulesAllowRules := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhAllowRules(rulesAllowRules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DDoSProfile.allow_rules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["allow_rules"] = vFn

	return v
}()

func DDoSProfileValidator() db.Validator {
	return DefaultDDoSProfileValidator
}

// augmented methods on protoc/std generated struct

func (m *DNSDDoSVectors) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DNSDDoSVectors) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DNSDDoSVectors) DeepCopy() *DNSDDoSVectors {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DNSDDoSVectors{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DNSDDoSVectors) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DNSDDoSVectors) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DNSDDoSVectorsValidator().Validate(ctx, m, opts...)
}

type ValidateDNSDDoSVectors struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDNSDDoSVectors) DnsFloodVectorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for dns_flood_vectors")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*DNSFloodVector, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := DNSFloodVectorValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for dns_flood_vectors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*DNSFloodVector)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*DNSFloodVector, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated dns_flood_vectors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items dns_flood_vectors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDNSDDoSVectors) DnsErrorVectorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for dns_error_vectors")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*DNSErrorVector, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := DNSErrorVectorValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for dns_error_vectors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*DNSErrorVector)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*DNSErrorVector, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated dns_error_vectors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items dns_error_vectors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDNSDDoSVectors) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DNSDDoSVectors)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DNSDDoSVectors got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dns_error_vectors"]; exists {
		vOpts := append(opts, db.WithValidateField("dns_error_vectors"))
		if err := fv(ctx, m.GetDnsErrorVectors(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_flood_vectors"]; exists {
		vOpts := append(opts, db.WithValidateField("dns_flood_vectors"))
		if err := fv(ctx, m.GetDnsFloodVectors(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["nx_domain_profile"]; exists {

		vOpts := append(opts, db.WithValidateField("nx_domain_profile"))
		if err := fv(ctx, m.GetNxDomainProfile(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["oversized_dns_profile"]; exists {

		vOpts := append(opts, db.WithValidateField("oversized_dns_profile"))
		if err := fv(ctx, m.GetOversizedDnsProfile(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDNSDDoSVectorsValidator = func() *ValidateDNSDDoSVectors {
	v := &ValidateDNSDDoSVectors{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDnsFloodVectors := v.DnsFloodVectorsValidationRuleHandler
	rulesDnsFloodVectors := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "14",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhDnsFloodVectors(rulesDnsFloodVectors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DNSDDoSVectors.dns_flood_vectors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_flood_vectors"] = vFn

	vrhDnsErrorVectors := v.DnsErrorVectorsValidationRuleHandler
	rulesDnsErrorVectors := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "3",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhDnsErrorVectors(rulesDnsErrorVectors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DNSDDoSVectors.dns_error_vectors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_error_vectors"] = vFn

	v.FldValidators["nx_domain_profile"] = NxDomainVectorsValidator().Validate

	v.FldValidators["oversized_dns_profile"] = OversizedDNSVectorsValidator().Validate

	return v
}()

func DNSDDoSVectorsValidator() db.Validator {
	return DefaultDNSDDoSVectorsValidator
}

// augmented methods on protoc/std generated struct

func (m *DNSErrorVector) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DNSErrorVector) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DNSErrorVector) DeepCopy() *DNSErrorVector {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DNSErrorVector{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DNSErrorVector) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DNSErrorVector) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DNSErrorVectorValidator().Validate(ctx, m, opts...)
}

type ValidateDNSErrorVector struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDNSErrorVector) DnsErrorTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(DNSErrorType)
		return int32(i)
	}
	// DNSErrorType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, DNSErrorType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_error_type")
	}

	return validatorFn, nil
}

func (v *ValidateDNSErrorVector) DetectionThresholdPercentageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for detection_threshold_percentage")
	}

	return validatorFn, nil
}

func (v *ValidateDNSErrorVector) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DNSErrorVector)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DNSErrorVector got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["detection_threshold_eps"]; exists {

		vOpts := append(opts, db.WithValidateField("detection_threshold_eps"))
		if err := fv(ctx, m.GetDetectionThresholdEps(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["detection_threshold_percentage"]; exists {

		vOpts := append(opts, db.WithValidateField("detection_threshold_percentage"))
		if err := fv(ctx, m.GetDetectionThresholdPercentage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_error_type"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_error_type"))
		if err := fv(ctx, m.GetDnsErrorType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDNSErrorVectorValidator = func() *ValidateDNSErrorVector {
	v := &ValidateDNSErrorVector{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDnsErrorType := v.DnsErrorTypeValidationRuleHandler
	rulesDnsErrorType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDnsErrorType(rulesDnsErrorType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DNSErrorVector.dns_error_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_error_type"] = vFn

	vrhDetectionThresholdPercentage := v.DetectionThresholdPercentageValidationRuleHandler
	rulesDetectionThresholdPercentage := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1",
		"ves.io.schema.rules.uint32.lte":       "4294967295",
	}
	vFn, err = vrhDetectionThresholdPercentage(rulesDetectionThresholdPercentage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DNSErrorVector.detection_threshold_percentage: %s", err)
		panic(errMsg)
	}
	v.FldValidators["detection_threshold_percentage"] = vFn

	v.FldValidators["detection_threshold_eps"] = ThresholdEPSValidator().Validate

	return v
}()

func DNSErrorVectorValidator() db.Validator {
	return DefaultDNSErrorVectorValidator
}

// augmented methods on protoc/std generated struct

func (m *DNSFloodVector) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DNSFloodVector) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DNSFloodVector) DeepCopy() *DNSFloodVector {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DNSFloodVector{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DNSFloodVector) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DNSFloodVector) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DNSFloodVectorValidator().Validate(ctx, m, opts...)
}

type ValidateDNSFloodVector struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDNSFloodVector) QueryTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(DNSQueryType)
		return int32(i)
	}
	// DNSQueryType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, DNSQueryType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for query_type")
	}

	return validatorFn, nil
}

func (v *ValidateDNSFloodVector) StateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(State)
		return int32(i)
	}
	// State_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, State_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for state")
	}

	return validatorFn, nil
}

func (v *ValidateDNSFloodVector) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DNSFloodVector)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DNSFloodVector got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["attacked_destination_volumetric_thresholds"]; exists {

		vOpts := append(opts, db.WithValidateField("attacked_destination_volumetric_thresholds"))
		if err := fv(ctx, m.GetAttackedDestinationVolumetricThresholds(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bad_actors_volumetric_thresholds"]; exists {

		vOpts := append(opts, db.WithValidateField("bad_actors_volumetric_thresholds"))
		if err := fv(ctx, m.GetBadActorsVolumetricThresholds(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query_type"]; exists {

		vOpts := append(opts, db.WithValidateField("query_type"))
		if err := fv(ctx, m.GetQueryType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volumetric_thresholds"]; exists {

		vOpts := append(opts, db.WithValidateField("volumetric_thresholds"))
		if err := fv(ctx, m.GetVolumetricThresholds(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDNSFloodVectorValidator = func() *ValidateDNSFloodVector {
	v := &ValidateDNSFloodVector{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhQueryType := v.QueryTypeValidationRuleHandler
	rulesQueryType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhQueryType(rulesQueryType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DNSFloodVector.query_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["query_type"] = vFn

	vrhState := v.StateValidationRuleHandler
	rulesState := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhState(rulesState)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DNSFloodVector.state: %s", err)
		panic(errMsg)
	}
	v.FldValidators["state"] = vFn

	v.FldValidators["volumetric_thresholds"] = VolumetricThresholdsValidator().Validate

	v.FldValidators["bad_actors_volumetric_thresholds"] = BadActorsVolumetricThresholdsValidator().Validate

	v.FldValidators["attacked_destination_volumetric_thresholds"] = AttackedDestinationVolumetricThresholdsValidator().Validate

	return v
}()

func DNSFloodVectorValidator() db.Validator {
	return DefaultDNSFloodVectorValidator
}

// augmented methods on protoc/std generated struct

func (m *DestinationPort) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DestinationPort) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DestinationPort) DeepCopy() *DestinationPort {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DestinationPort{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DestinationPort) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DestinationPort) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DestinationPortValidator().Validate(ctx, m, opts...)
}

type ValidateDestinationPort struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDestinationPort) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateDestinationPort) ChoicePortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Port, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port")
	}
	return oValidatorFn_Port, nil
}

func (v *ValidateDestinationPort) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DestinationPort)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DestinationPort got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *DestinationPort_Any:
		if fv, exists := v.FldValidators["choice.any"]; exists {
			val := m.GetChoice().(*DestinationPort_Any).Any
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("any"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DestinationPort_Port:
		if fv, exists := v.FldValidators["choice.port"]; exists {
			val := m.GetChoice().(*DestinationPort_Port).Port
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDestinationPortValidator = func() *ValidateDestinationPort {
	v := &ValidateDestinationPort{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DestinationPort.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	vrhChoicePort := v.ChoicePortValidationRuleHandler
	rulesChoicePort := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["choice.port"], err = vrhChoicePort(rulesChoicePort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DestinationPort.choice_port: %s", err)
		panic(errMsg)
	}

	v.FldValidators["choice.port"] = vFnMap["choice.port"]

	return v
}()

func DestinationPortValidator() db.Validator {
	return DefaultDestinationPortValidator
}

// augmented methods on protoc/std generated struct

func (m *MatchIPAddressWithPort) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MatchIPAddressWithPort) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MatchIPAddressWithPort) DeepCopy() *MatchIPAddressWithPort {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MatchIPAddressWithPort{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MatchIPAddressWithPort) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MatchIPAddressWithPort) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MatchIPAddressWithPortValidator().Validate(ctx, m, opts...)
}

type ValidateMatchIPAddressWithPort struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMatchIPAddressWithPort) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateMatchIPAddressWithPort) ChoiceAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Address, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}
	return oValidatorFn_Address, nil
}

func (v *ValidateMatchIPAddressWithPort) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MatchIPAddressWithPort)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MatchIPAddressWithPort got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *MatchIPAddressWithPort_Any:
		if fv, exists := v.FldValidators["choice.any"]; exists {
			val := m.GetChoice().(*MatchIPAddressWithPort_Any).Any
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("any"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *MatchIPAddressWithPort_Address:
		if fv, exists := v.FldValidators["choice.address"]; exists {
			val := m.GetChoice().(*MatchIPAddressWithPort_Address).Address
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["destination_port"]; exists {

		vOpts := append(opts, db.WithValidateField("destination_port"))
		if err := fv(ctx, m.GetDestinationPort(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMatchIPAddressWithPortValidator = func() *ValidateMatchIPAddressWithPort {
	v := &ValidateMatchIPAddressWithPort{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatchIPAddressWithPort.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	vrhChoiceAddress := v.ChoiceAddressValidationRuleHandler
	rulesChoiceAddress := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFnMap["choice.address"], err = vrhChoiceAddress(rulesChoiceAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field MatchIPAddressWithPort.choice_address: %s", err)
		panic(errMsg)
	}

	v.FldValidators["choice.address"] = vFnMap["choice.address"]

	v.FldValidators["destination_port"] = DestinationPortValidator().Validate

	return v
}()

func MatchIPAddressWithPortValidator() db.Validator {
	return DefaultMatchIPAddressWithPortValidator
}

// augmented methods on protoc/std generated struct

func (m *MatchRuleType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MatchRuleType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MatchRuleType) DeepCopy() *MatchRuleType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MatchRuleType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MatchRuleType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MatchRuleType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MatchRuleTypeValidator().Validate(ctx, m, opts...)
}

type ValidateMatchRuleType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMatchRuleType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateMatchRuleType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MatchRuleType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MatchRuleType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *MatchRuleType_DestinationMatch:
		if fv, exists := v.FldValidators["choice.destination_match"]; exists {
			val := m.GetChoice().(*MatchRuleType_DestinationMatch).DestinationMatch
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("destination_match"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *MatchRuleType_SourceMatch:
		if fv, exists := v.FldValidators["choice.source_match"]; exists {
			val := m.GetChoice().(*MatchRuleType_SourceMatch).SourceMatch
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("source_match"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *MatchRuleType_AnyV4:
		if fv, exists := v.FldValidators["choice.any_v4"]; exists {
			val := m.GetChoice().(*MatchRuleType_AnyV4).AnyV4
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("any_v4"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *MatchRuleType_AnyV6:
		if fv, exists := v.FldValidators["choice.any_v6"]; exists {
			val := m.GetChoice().(*MatchRuleType_AnyV6).AnyV6
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("any_v6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *MatchRuleType_AnyIp:
		if fv, exists := v.FldValidators["choice.any_ip"]; exists {
			val := m.GetChoice().(*MatchRuleType_AnyIp).AnyIp
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("any_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMatchRuleTypeValidator = func() *ValidateMatchRuleType {
	v := &ValidateMatchRuleType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatchRuleType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	v.FldValidators["choice.destination_match"] = MatchIPAddressWithPortValidator().Validate
	v.FldValidators["choice.source_match"] = MatchIPAddressWithPortValidator().Validate
	v.FldValidators["choice.any_v4"] = DestinationPortValidator().Validate
	v.FldValidators["choice.any_v6"] = DestinationPortValidator().Validate
	v.FldValidators["choice.any_ip"] = DestinationPortValidator().Validate

	return v
}()

func MatchRuleTypeValidator() db.Validator {
	return DefaultMatchRuleTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *NxDomainLearningParams) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NxDomainLearningParams) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NxDomainLearningParams) DeepCopy() *NxDomainLearningParams {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NxDomainLearningParams{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NxDomainLearningParams) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NxDomainLearningParams) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NxDomainLearningParamsValidator().Validate(ctx, m, opts...)
}

type ValidateNxDomainLearningParams struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNxDomainLearningParams) DnsNxDomainLearnPeriodValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_nx_domain_learn_period")
	}

	return validatorFn, nil
}

func (v *ValidateNxDomainLearningParams) DnsNxDomainRelearnPeriodValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_nx_domain_relearn_period")
	}

	return validatorFn, nil
}

func (v *ValidateNxDomainLearningParams) DnsNxDomainTrackerSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_nx_domain_tracker_size")
	}

	return validatorFn, nil
}

func (v *ValidateNxDomainLearningParams) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NxDomainLearningParams)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NxDomainLearningParams got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dns_nx_domain_learn_period"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_nx_domain_learn_period"))
		if err := fv(ctx, m.GetDnsNxDomainLearnPeriod(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_nx_domain_relearn_period"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_nx_domain_relearn_period"))
		if err := fv(ctx, m.GetDnsNxDomainRelearnPeriod(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_nx_domain_tracker_size"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_nx_domain_tracker_size"))
		if err := fv(ctx, m.GetDnsNxDomainTrackerSize(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNxDomainLearningParamsValidator = func() *ValidateNxDomainLearningParams {
	v := &ValidateNxDomainLearningParams{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDnsNxDomainLearnPeriod := v.DnsNxDomainLearnPeriodValidationRuleHandler
	rulesDnsNxDomainLearnPeriod := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "2147483647",
	}
	vFn, err = vrhDnsNxDomainLearnPeriod(rulesDnsNxDomainLearnPeriod)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NxDomainLearningParams.dns_nx_domain_learn_period: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_nx_domain_learn_period"] = vFn

	vrhDnsNxDomainRelearnPeriod := v.DnsNxDomainRelearnPeriodValidationRuleHandler
	rulesDnsNxDomainRelearnPeriod := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "2147483647",
	}
	vFn, err = vrhDnsNxDomainRelearnPeriod(rulesDnsNxDomainRelearnPeriod)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NxDomainLearningParams.dns_nx_domain_relearn_period: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_nx_domain_relearn_period"] = vFn

	vrhDnsNxDomainTrackerSize := v.DnsNxDomainTrackerSizeValidationRuleHandler
	rulesDnsNxDomainTrackerSize := map[string]string{
		"ves.io.schema.rules.uint32.gte": "64",
		"ves.io.schema.rules.uint32.lte": "8000",
	}
	vFn, err = vrhDnsNxDomainTrackerSize(rulesDnsNxDomainTrackerSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NxDomainLearningParams.dns_nx_domain_tracker_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_nx_domain_tracker_size"] = vFn

	return v
}()

func NxDomainLearningParamsValidator() db.Validator {
	return DefaultNxDomainLearningParamsValidator
}

// augmented methods on protoc/std generated struct

func (m *NxDomainVectors) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NxDomainVectors) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NxDomainVectors) DeepCopy() *NxDomainVectors {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NxDomainVectors{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NxDomainVectors) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NxDomainVectors) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NxDomainVectorsValidator().Validate(ctx, m, opts...)
}

type ValidateNxDomainVectors struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNxDomainVectors) StateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(State)
		return int32(i)
	}
	// State_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, State_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for state")
	}

	return validatorFn, nil
}

func (v *ValidateNxDomainVectors) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NxDomainVectors)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NxDomainVectors got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["attacked_destination_volumetric_thresholds"]; exists {

		vOpts := append(opts, db.WithValidateField("attacked_destination_volumetric_thresholds"))
		if err := fv(ctx, m.GetAttackedDestinationVolumetricThresholds(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bad_actors_volumetric_thresholds"]; exists {

		vOpts := append(opts, db.WithValidateField("bad_actors_volumetric_thresholds"))
		if err := fv(ctx, m.GetBadActorsVolumetricThresholds(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["learning_params"]; exists {

		vOpts := append(opts, db.WithValidateField("learning_params"))
		if err := fv(ctx, m.GetLearningParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["valid_domains"]; exists {

		vOpts := append(opts, db.WithValidateField("valid_domains"))
		if err := fv(ctx, m.GetValidDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volumetric_thresholds"]; exists {

		vOpts := append(opts, db.WithValidateField("volumetric_thresholds"))
		if err := fv(ctx, m.GetVolumetricThresholds(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNxDomainVectorsValidator = func() *ValidateNxDomainVectors {
	v := &ValidateNxDomainVectors{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhState := v.StateValidationRuleHandler
	rulesState := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhState(rulesState)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NxDomainVectors.state: %s", err)
		panic(errMsg)
	}
	v.FldValidators["state"] = vFn

	v.FldValidators["volumetric_thresholds"] = VolumetricThresholdsValidator().Validate

	v.FldValidators["learning_params"] = NxDomainLearningParamsValidator().Validate

	v.FldValidators["bad_actors_volumetric_thresholds"] = BadActorsVolumetricThresholdsValidator().Validate

	v.FldValidators["attacked_destination_volumetric_thresholds"] = AttackedDestinationVolumetricThresholdsValidator().Validate

	v.FldValidators["valid_domains"] = ValidDomainsListConfigValidator().Validate

	return v
}()

func NxDomainVectorsValidator() db.Validator {
	return DefaultNxDomainVectorsValidator
}

// augmented methods on protoc/std generated struct

func (m *OversizedDNSVectors) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OversizedDNSVectors) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OversizedDNSVectors) DeepCopy() *OversizedDNSVectors {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OversizedDNSVectors{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OversizedDNSVectors) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OversizedDNSVectors) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OversizedDNSVectorsValidator().Validate(ctx, m, opts...)
}

type ValidateOversizedDNSVectors struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOversizedDNSVectors) StateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(State)
		return int32(i)
	}
	// State_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, State_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for state")
	}

	return validatorFn, nil
}

func (v *ValidateOversizedDNSVectors) MaxDnsSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_dns_size")
	}

	return validatorFn, nil
}

func (v *ValidateOversizedDNSVectors) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OversizedDNSVectors)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OversizedDNSVectors got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["attacked_destination_volumetric_thresholds"]; exists {

		vOpts := append(opts, db.WithValidateField("attacked_destination_volumetric_thresholds"))
		if err := fv(ctx, m.GetAttackedDestinationVolumetricThresholds(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bad_actors_volumetric_thresholds"]; exists {

		vOpts := append(opts, db.WithValidateField("bad_actors_volumetric_thresholds"))
		if err := fv(ctx, m.GetBadActorsVolumetricThresholds(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_dns_size"]; exists {

		vOpts := append(opts, db.WithValidateField("max_dns_size"))
		if err := fv(ctx, m.GetMaxDnsSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volumetric_thresholds"]; exists {

		vOpts := append(opts, db.WithValidateField("volumetric_thresholds"))
		if err := fv(ctx, m.GetVolumetricThresholds(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOversizedDNSVectorsValidator = func() *ValidateOversizedDNSVectors {
	v := &ValidateOversizedDNSVectors{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhState := v.StateValidationRuleHandler
	rulesState := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhState(rulesState)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OversizedDNSVectors.state: %s", err)
		panic(errMsg)
	}
	v.FldValidators["state"] = vFn

	vrhMaxDnsSize := v.MaxDnsSizeValidationRuleHandler
	rulesMaxDnsSize := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1",
		"ves.io.schema.rules.uint32.lte":       "4294967295",
	}
	vFn, err = vrhMaxDnsSize(rulesMaxDnsSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OversizedDNSVectors.max_dns_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_dns_size"] = vFn

	v.FldValidators["volumetric_thresholds"] = VolumetricThresholdsValidator().Validate

	v.FldValidators["bad_actors_volumetric_thresholds"] = BadActorsVolumetricThresholdsValidator().Validate

	v.FldValidators["attacked_destination_volumetric_thresholds"] = AttackedDestinationVolumetricThresholdsValidator().Validate

	return v
}()

func OversizedDNSVectorsValidator() db.Validator {
	return DefaultOversizedDNSVectorsValidator
}

// augmented methods on protoc/std generated struct

func (m *ThresholdEPS) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ThresholdEPS) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ThresholdEPS) DeepCopy() *ThresholdEPS {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ThresholdEPS{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ThresholdEPS) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ThresholdEPS) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ThresholdEPSValidator().Validate(ctx, m, opts...)
}

type ValidateThresholdEPS struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateThresholdEPS) ChoiceValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Value, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for value")
	}
	return oValidatorFn_Value, nil
}

func (v *ValidateThresholdEPS) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ThresholdEPS)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ThresholdEPS got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetChoice().(type) {
	case *ThresholdEPS_Disable:
		if fv, exists := v.FldValidators["choice.disable"]; exists {
			val := m.GetChoice().(*ThresholdEPS_Disable).Disable
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("disable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ThresholdEPS_Value:
		if fv, exists := v.FldValidators["choice.value"]; exists {
			val := m.GetChoice().(*ThresholdEPS_Value).Value
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultThresholdEPSValidator = func() *ValidateThresholdEPS {
	v := &ValidateThresholdEPS{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoiceValue := v.ChoiceValueValidationRuleHandler
	rulesChoiceValue := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "4294967295",
	}
	vFnMap["choice.value"], err = vrhChoiceValue(rulesChoiceValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ThresholdEPS.choice_value: %s", err)
		panic(errMsg)
	}

	v.FldValidators["choice.value"] = vFnMap["choice.value"]

	return v
}()

func ThresholdEPSValidator() db.Validator {
	return DefaultThresholdEPSValidator
}

// augmented methods on protoc/std generated struct

func (m *ValidDomainsListConfig) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ValidDomainsListConfig) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ValidDomainsListConfig) DeepCopy() *ValidDomainsListConfig {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ValidDomainsListConfig{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ValidDomainsListConfig) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ValidDomainsListConfig) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ValidDomainsListConfigValidator().Validate(ctx, m, opts...)
}

type ValidateValidDomainsListConfig struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateValidDomainsListConfig) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateValidDomainsListConfig) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ValidDomainsListConfig)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ValidDomainsListConfig got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultValidDomainsListConfigValidator = func() *ValidateValidDomainsListConfig {
	v := &ValidateValidDomainsListConfig{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "10240",
		"ves.io.schema.rules.repeated.unique":    "true",
		"ves.io.schema.rules.string.hostname":    "true",
		"ves.io.schema.rules.string.max_len":     "256",
		"ves.io.schema.rules.string.min_len":     "1",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ValidDomainsListConfig.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	return v
}()

func ValidDomainsListConfigValidator() db.Validator {
	return DefaultValidDomainsListConfigValidator
}

// augmented methods on protoc/std generated struct

func (m *VolumetricThresholds) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VolumetricThresholds) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VolumetricThresholds) DeepCopy() *VolumetricThresholds {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VolumetricThresholds{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VolumetricThresholds) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VolumetricThresholds) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VolumetricThresholdsValidator().Validate(ctx, m, opts...)
}

type ValidateVolumetricThresholds struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVolumetricThresholds) DetectionThresholdPercentageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for detection_threshold_percentage")
	}

	return validatorFn, nil
}

func (v *ValidateVolumetricThresholds) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VolumetricThresholds)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VolumetricThresholds got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["detection_threshold_eps"]; exists {

		vOpts := append(opts, db.WithValidateField("detection_threshold_eps"))
		if err := fv(ctx, m.GetDetectionThresholdEps(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["detection_threshold_percentage"]; exists {

		vOpts := append(opts, db.WithValidateField("detection_threshold_percentage"))
		if err := fv(ctx, m.GetDetectionThresholdPercentage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mitigation_threshold_eps"]; exists {

		vOpts := append(opts, db.WithValidateField("mitigation_threshold_eps"))
		if err := fv(ctx, m.GetMitigationThresholdEps(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVolumetricThresholdsValidator = func() *ValidateVolumetricThresholds {
	v := &ValidateVolumetricThresholds{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDetectionThresholdPercentage := v.DetectionThresholdPercentageValidationRuleHandler
	rulesDetectionThresholdPercentage := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "4294967295",
	}
	vFn, err = vrhDetectionThresholdPercentage(rulesDetectionThresholdPercentage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VolumetricThresholds.detection_threshold_percentage: %s", err)
		panic(errMsg)
	}
	v.FldValidators["detection_threshold_percentage"] = vFn

	v.FldValidators["detection_threshold_eps"] = ThresholdEPSValidator().Validate

	v.FldValidators["mitigation_threshold_eps"] = ThresholdEPSValidator().Validate

	return v
}()

func VolumetricThresholdsValidator() db.Validator {
	return DefaultVolumetricThresholdsValidator
}
