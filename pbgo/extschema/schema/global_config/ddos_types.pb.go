// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/global_config/ddos_types.proto

package global_config

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Enable Status
//
// x-displayName: "Enable Status"
// Options to use for enabling and disabling a Rule
type EnableStatus int32

const (
	// STATUS_ENABLE
	//
	// x-displayName: "enable"
	// enable
	STATUS_ENABLE EnableStatus = 0
	// STATUS_DISABLE
	//
	// x-displayName: "Disable"
	// Disable
	STATUS_DISABLE EnableStatus = 3
)

var EnableStatus_name = map[int32]string{
	0: "STATUS_ENABLE",
	3: "STATUS_DISABLE",
}

var EnableStatus_value = map[string]int32{
	"STATUS_ENABLE":  0,
	"STATUS_DISABLE": 3,
}

func (EnableStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{0}
}

// Traffic Type
//
// x-displayName: "Traffic Type"
// Traffic Type
type ProtocolType int32

const (
	// Any Protocol
	//
	// x-displayName: "Any Protocol"
	ANY_PROTOCOL ProtocolType = 0
	// TCP
	//
	// x-displayName: "TCP"
	TCP ProtocolType = 1
	// UDP
	//
	// x-displayName: "UDP"
	UDP ProtocolType = 2
)

var ProtocolType_name = map[int32]string{
	0: "ANY_PROTOCOL",
	1: "TCP",
	2: "UDP",
}

var ProtocolType_value = map[string]int32{
	"ANY_PROTOCOL": 0,
	"TCP":          1,
	"UDP":          2,
}

func (ProtocolType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{1}
}

// State
//
// x-displayName: "State"
// State Type for a given DDoS Vector
type State int32

const (
	// detection only
	//
	// x-displayName: "Detection Only"
	DETECT State = 0
	// Mitigation
	//
	// x-displayName: "Mitigation"
	MITIGATE State = 1
	// Disable
	//
	// x-displayName: "Disable"
	DISABLE State = 2
)

var State_name = map[int32]string{
	0: "DETECT",
	1: "MITIGATE",
	2: "DISABLE",
}

var State_value = map[string]int32{
	"DETECT":   0,
	"MITIGATE": 1,
	"DISABLE":  2,
}

func (State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{2}
}

// DNS Query Type
//
// x-displayName: "DNS Query Type"
// DNS Query Type
type DNSQueryType int32

const (
	// A
	//
	// x-displayName: "A"
	A DNSQueryType = 0
	// AAAA
	//
	// x-displayName: "AAAA"
	AAAA DNSQueryType = 1
	// PTR
	//
	// x-displayName: "PTR"
	PTR DNSQueryType = 2
	// AXFR
	//
	// x-displayName: "AXFR"
	AXFR DNSQueryType = 3
	// IXFR
	//
	// x-displayName: "IXFR"
	IXFR DNSQueryType = 4
	// CNAME
	//
	// x-displayName: "CNAME"
	CNAME DNSQueryType = 5
	// MX
	//
	// x-displayName: "MX"
	MX DNSQueryType = 6
	// NS
	//
	// x-displayName: "NS"
	NS DNSQueryType = 7
	// SOA
	//
	// x-displayName: "SOA"
	SOA DNSQueryType = 8
	// SRV
	//
	// x-displayName: "SRV"
	SRV DNSQueryType = 9
	// TXT
	//
	// x-displayName: "TXT"
	TXT DNSQueryType = 10
	// ANY
	//
	// x-displayName: "ANY"
	ANY DNSQueryType = 11
	// OTHER
	//
	// x-displayName: "OTHER"
	OTHER DNSQueryType = 12
)

var DNSQueryType_name = map[int32]string{
	0:  "A",
	1:  "AAAA",
	2:  "PTR",
	3:  "AXFR",
	4:  "IXFR",
	5:  "CNAME",
	6:  "MX",
	7:  "NS",
	8:  "SOA",
	9:  "SRV",
	10: "TXT",
	11: "ANY",
	12: "OTHER",
}

var DNSQueryType_value = map[string]int32{
	"A":     0,
	"AAAA":  1,
	"PTR":   2,
	"AXFR":  3,
	"IXFR":  4,
	"CNAME": 5,
	"MX":    6,
	"NS":    7,
	"SOA":   8,
	"SRV":   9,
	"TXT":   10,
	"ANY":   11,
	"OTHER": 12,
}

func (DNSQueryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{3}
}

// DNS Error Type
//
// x-displayName: "DNS Error Type"
// DNS Error Type
type DNSErrorType int32

const (
	// Malformed Request
	//
	// x-displayName: "Malformed Request"
	DNS_MALFORMED DNSErrorType = 0
	// DNS QDCOUNT Count
	//
	// x-displayName: "DNS QDCOUNT Count"
	DNS_QDCOUNT_LIMIT DNSErrorType = 1
	// unsolicited dns response
	//
	// x-displayName: "Unsolicited Response"
	UNSOLICITED_DNS_RESPONSE DNSErrorType = 2
)

var DNSErrorType_name = map[int32]string{
	0: "DNS_MALFORMED",
	1: "DNS_QDCOUNT_LIMIT",
	2: "UNSOLICITED_DNS_RESPONSE",
}

var DNSErrorType_value = map[string]int32{
	"DNS_MALFORMED":            0,
	"DNS_QDCOUNT_LIMIT":        1,
	"UNSOLICITED_DNS_RESPONSE": 2,
}

func (DNSErrorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{4}
}

// DDoS Global Profile
//
// x-displayName: "DDoS Global Profile"
// DDoS Attack detection and mitigation profile
type DDoSProfile struct {
	// DNS Attack Vectors
	//
	// x-required
	// x-displayName: "DNS Attack Vectors"
	// DNS Attack Vectors
	Dns *DNSDDoSVectors `protobuf:"bytes,1,opt,name=dns,proto3" json:"dns,omitempty"`
	// Allow Rules List
	//
	// x-displayName: "Allow Rules List"
	// Specify the rules for traffic that need to be excluded from DDoS detection/mitigation
	AllowRules []*AllowRule `protobuf:"bytes,2,rep,name=allow_rules,json=allowRules,proto3" json:"allow_rules,omitempty"`
}

func (m *DDoSProfile) Reset()      { *m = DDoSProfile{} }
func (*DDoSProfile) ProtoMessage() {}
func (*DDoSProfile) Descriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{0}
}
func (m *DDoSProfile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DDoSProfile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DDoSProfile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DDoSProfile.Merge(m, src)
}
func (m *DDoSProfile) XXX_Size() int {
	return m.Size()
}
func (m *DDoSProfile) XXX_DiscardUnknown() {
	xxx_messageInfo_DDoSProfile.DiscardUnknown(m)
}

var xxx_messageInfo_DDoSProfile proto.InternalMessageInfo

func (m *DDoSProfile) GetDns() *DNSDDoSVectors {
	if m != nil {
		return m.Dns
	}
	return nil
}

func (m *DDoSProfile) GetAllowRules() []*AllowRule {
	if m != nil {
		return m.AllowRules
	}
	return nil
}

// DNS DDoS Vectors
//
// x-displayName: "DNS DDoS Vectors"
// DNS DDoS Vectors
type DNSDDoSVectors struct {
	// Nxdomain
	//
	// x-displayName: "Nxdomain"
	// Nxdomain
	NxDomainProfile *NxDomainVectors `protobuf:"bytes,1,opt,name=nx_domain_profile,json=nxDomainProfile,proto3" json:"nx_domain_profile,omitempty"`
	// Oversized DNS
	//
	// x-displayName: "Oversized DNS"
	// Oversized DNS
	OversizedDnsProfile *OversizedDNSVectors `protobuf:"bytes,2,opt,name=oversized_dns_profile,json=oversizedDnsProfile,proto3" json:"oversized_dns_profile,omitempty"`
	// List Of DNS Flood Vector Config
	//
	// x-displayName: "List Of DNS Flood Vector Config"
	// x-required
	// List Of DNS Flood Vector Config
	DnsFloodVectors []*DNSFloodVector `protobuf:"bytes,3,rep,name=dns_flood_vectors,json=dnsFloodVectors,proto3" json:"dns_flood_vectors,omitempty"`
	// List Of DNS Error vectors
	//
	// x-displayName: "List Of DNS Error vectors"
	// x-required
	// x-example: "10"
	// List Of DNS Error vectors
	DnsErrorVectors []*DNSErrorVector `protobuf:"bytes,4,rep,name=dns_error_vectors,json=dnsErrorVectors,proto3" json:"dns_error_vectors,omitempty"`
}

func (m *DNSDDoSVectors) Reset()      { *m = DNSDDoSVectors{} }
func (*DNSDDoSVectors) ProtoMessage() {}
func (*DNSDDoSVectors) Descriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{1}
}
func (m *DNSDDoSVectors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNSDDoSVectors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DNSDDoSVectors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNSDDoSVectors.Merge(m, src)
}
func (m *DNSDDoSVectors) XXX_Size() int {
	return m.Size()
}
func (m *DNSDDoSVectors) XXX_DiscardUnknown() {
	xxx_messageInfo_DNSDDoSVectors.DiscardUnknown(m)
}

var xxx_messageInfo_DNSDDoSVectors proto.InternalMessageInfo

func (m *DNSDDoSVectors) GetNxDomainProfile() *NxDomainVectors {
	if m != nil {
		return m.NxDomainProfile
	}
	return nil
}

func (m *DNSDDoSVectors) GetOversizedDnsProfile() *OversizedDNSVectors {
	if m != nil {
		return m.OversizedDnsProfile
	}
	return nil
}

func (m *DNSDDoSVectors) GetDnsFloodVectors() []*DNSFloodVector {
	if m != nil {
		return m.DnsFloodVectors
	}
	return nil
}

func (m *DNSDDoSVectors) GetDnsErrorVectors() []*DNSErrorVector {
	if m != nil {
		return m.DnsErrorVectors
	}
	return nil
}

// Nxdomain Attack Vectors
//
// x-displayName: "Nxdomain Attack Vectors"
// Nxdomain Attack Vector Config
// DDoS Protections Profile for NXDOMAIN Attack Vectors
type NxDomainVectors struct {
	// State
	//
	// x-displayName: "Choose an enforcement option"
	// x-required
	// x-example: "DETECTION"
	// Choose an enforcement option for Nxdomain Attack
	State State `protobuf:"varint,1,opt,name=state,proto3,enum=ves.io.schema.global_config.State" json:"state,omitempty"`
	// Volumetric Thresholds
	//
	// x-displayName: "Volumetric Thresholds"
	// Volumetric Thresholds for Nxdomain Attack
	VolumetricThresholds *VolumetricThresholds `protobuf:"bytes,2,opt,name=volumetric_thresholds,json=volumetricThresholds,proto3" json:"volumetric_thresholds,omitempty"`
	// NxDomain Learning Config
	//
	// x-displayName: "NxDomain Learning Config"
	// NxDomain Learning Config
	LearningParams *NxDomainLearningParams `protobuf:"bytes,3,opt,name=learning_params,json=learningParams,proto3" json:"learning_params,omitempty"`
	// Bad Actor Volumetric Thresholds
	//
	// x-displayName: "Bad Actor Volumetric Thresholds"
	// Bad Actor Volumetric Thresholds for Nxdomain Attack
	BadActorsVolumetricThresholds *BadActorsVolumetricThresholds `protobuf:"bytes,4,opt,name=bad_actors_volumetric_thresholds,json=badActorsVolumetricThresholds,proto3" json:"bad_actors_volumetric_thresholds,omitempty"`
	// Attacked Destination Volumetric Thresholds
	//
	// x-displayName: "Attacked Destination Volumetric Thresholds"
	// Attacked Destination Volumetric Thresholds for Nxdomain Attack
	AttackedDestinationVolumetricThresholds *AttackedDestinationVolumetricThresholds `protobuf:"bytes,5,opt,name=attacked_destination_volumetric_thresholds,json=attackedDestinationVolumetricThresholds,proto3" json:"attacked_destination_volumetric_thresholds,omitempty"`
	// Valid Domains
	//
	// x-displayName: "Valid Domains"
	// x-example: "10"
	// DNS Valid Domains
	ValidDomains *ValidDomainsListConfig `protobuf:"bytes,6,opt,name=valid_domains,json=validDomains,proto3" json:"valid_domains,omitempty"`
}

func (m *NxDomainVectors) Reset()      { *m = NxDomainVectors{} }
func (*NxDomainVectors) ProtoMessage() {}
func (*NxDomainVectors) Descriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{2}
}
func (m *NxDomainVectors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NxDomainVectors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NxDomainVectors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NxDomainVectors.Merge(m, src)
}
func (m *NxDomainVectors) XXX_Size() int {
	return m.Size()
}
func (m *NxDomainVectors) XXX_DiscardUnknown() {
	xxx_messageInfo_NxDomainVectors.DiscardUnknown(m)
}

var xxx_messageInfo_NxDomainVectors proto.InternalMessageInfo

func (m *NxDomainVectors) GetState() State {
	if m != nil {
		return m.State
	}
	return DETECT
}

func (m *NxDomainVectors) GetVolumetricThresholds() *VolumetricThresholds {
	if m != nil {
		return m.VolumetricThresholds
	}
	return nil
}

func (m *NxDomainVectors) GetLearningParams() *NxDomainLearningParams {
	if m != nil {
		return m.LearningParams
	}
	return nil
}

func (m *NxDomainVectors) GetBadActorsVolumetricThresholds() *BadActorsVolumetricThresholds {
	if m != nil {
		return m.BadActorsVolumetricThresholds
	}
	return nil
}

func (m *NxDomainVectors) GetAttackedDestinationVolumetricThresholds() *AttackedDestinationVolumetricThresholds {
	if m != nil {
		return m.AttackedDestinationVolumetricThresholds
	}
	return nil
}

func (m *NxDomainVectors) GetValidDomains() *ValidDomainsListConfig {
	if m != nil {
		return m.ValidDomains
	}
	return nil
}

// Oversized DNS Vectors
//
// x-displayName: "Oversized DNS Vectors"
// Oversized DNS Vectors
type OversizedDNSVectors struct {
	// State
	//
	// x-displayName: "Choose an enforcement option"
	// x-required
	// x-example: "DETECTION"
	// Choose an enforcement option for Oversized DNS Attacks
	State State `protobuf:"varint,1,opt,name=state,proto3,enum=ves.io.schema.global_config.State" json:"state,omitempty"`
	// Max DNS Size
	//
	// x-displayName: "Max DNS Size"
	// x-required
	// x-example: "10"
	// Max DNS Packet size.
	MaxDnsSize uint32 `protobuf:"varint,2,opt,name=max_dns_size,json=maxDnsSize,proto3" json:"max_dns_size,omitempty"`
	// Volumetric Thresholds
	//
	// x-displayName: "Volumetric Thresholds"
	// Volumetric Thresholds
	VolumetricThresholds *VolumetricThresholds `protobuf:"bytes,3,opt,name=volumetric_thresholds,json=volumetricThresholds,proto3" json:"volumetric_thresholds,omitempty"`
	// Bad Actor Volumetric Thresholds
	//
	// x-displayName: "Bad Actor Volumetric Thresholds"
	// Bad Actor Volumetric Thresholds
	BadActorsVolumetricThresholds *BadActorsVolumetricThresholds `protobuf:"bytes,4,opt,name=bad_actors_volumetric_thresholds,json=badActorsVolumetricThresholds,proto3" json:"bad_actors_volumetric_thresholds,omitempty"`
	// Attacked Destination Volumetric Thresholds
	//
	// x-displayName: "Attacked Destination Volumetric Thresholds"
	// Attacked Destination Volumetric Thresholds
	AttackedDestinationVolumetricThresholds *AttackedDestinationVolumetricThresholds `protobuf:"bytes,5,opt,name=attacked_destination_volumetric_thresholds,json=attackedDestinationVolumetricThresholds,proto3" json:"attacked_destination_volumetric_thresholds,omitempty"`
}

func (m *OversizedDNSVectors) Reset()      { *m = OversizedDNSVectors{} }
func (*OversizedDNSVectors) ProtoMessage() {}
func (*OversizedDNSVectors) Descriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{3}
}
func (m *OversizedDNSVectors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OversizedDNSVectors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OversizedDNSVectors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OversizedDNSVectors.Merge(m, src)
}
func (m *OversizedDNSVectors) XXX_Size() int {
	return m.Size()
}
func (m *OversizedDNSVectors) XXX_DiscardUnknown() {
	xxx_messageInfo_OversizedDNSVectors.DiscardUnknown(m)
}

var xxx_messageInfo_OversizedDNSVectors proto.InternalMessageInfo

func (m *OversizedDNSVectors) GetState() State {
	if m != nil {
		return m.State
	}
	return DETECT
}

func (m *OversizedDNSVectors) GetMaxDnsSize() uint32 {
	if m != nil {
		return m.MaxDnsSize
	}
	return 0
}

func (m *OversizedDNSVectors) GetVolumetricThresholds() *VolumetricThresholds {
	if m != nil {
		return m.VolumetricThresholds
	}
	return nil
}

func (m *OversizedDNSVectors) GetBadActorsVolumetricThresholds() *BadActorsVolumetricThresholds {
	if m != nil {
		return m.BadActorsVolumetricThresholds
	}
	return nil
}

func (m *OversizedDNSVectors) GetAttackedDestinationVolumetricThresholds() *AttackedDestinationVolumetricThresholds {
	if m != nil {
		return m.AttackedDestinationVolumetricThresholds
	}
	return nil
}

// DNS Flood Vector
//
// x-displayName: "DNS Flood Vector"
// Configure to log or mitigate DNS Flood Attacks
type DNSFloodVector struct {
	// DNS Query Type
	//
	// x-displayName: "DNS Query Type"
	// x-required
	// x-example: "A"
	// DNS Query Type
	QueryType DNSQueryType `protobuf:"varint,1,opt,name=query_type,json=queryType,proto3,enum=ves.io.schema.global_config.DNSQueryType" json:"query_type,omitempty"`
	// State
	//
	// x-displayName: "Choose an enforcement option"
	// x-required
	// x-example: "DETECTION"
	// Choose an enforcement option for DNS Flood Attacks
	State State `protobuf:"varint,2,opt,name=state,proto3,enum=ves.io.schema.global_config.State" json:"state,omitempty"`
	// Volumetric Thresholds
	//
	// x-displayName: "Volumetric Thresholds"
	// Volumetric Thresholds
	VolumetricThresholds *VolumetricThresholds `protobuf:"bytes,3,opt,name=volumetric_thresholds,json=volumetricThresholds,proto3" json:"volumetric_thresholds,omitempty"`
	// Bad Actor Volumetric Thresholds
	//
	// x-displayName: "Bad Actor Volumetric Thresholds"
	// Bad Actor Volumetric Thresholds
	BadActorsVolumetricThresholds *BadActorsVolumetricThresholds `protobuf:"bytes,4,opt,name=bad_actors_volumetric_thresholds,json=badActorsVolumetricThresholds,proto3" json:"bad_actors_volumetric_thresholds,omitempty"`
	// Attacked Destination Volumetric Thresholds
	//
	// x-displayName: "Attacked Destination Volumetric Thresholds"
	// Attacked Destination Volumetric Thresholds
	AttackedDestinationVolumetricThresholds *AttackedDestinationVolumetricThresholds `protobuf:"bytes,5,opt,name=attacked_destination_volumetric_thresholds,json=attackedDestinationVolumetricThresholds,proto3" json:"attacked_destination_volumetric_thresholds,omitempty"`
}

func (m *DNSFloodVector) Reset()      { *m = DNSFloodVector{} }
func (*DNSFloodVector) ProtoMessage() {}
func (*DNSFloodVector) Descriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{4}
}
func (m *DNSFloodVector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNSFloodVector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DNSFloodVector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNSFloodVector.Merge(m, src)
}
func (m *DNSFloodVector) XXX_Size() int {
	return m.Size()
}
func (m *DNSFloodVector) XXX_DiscardUnknown() {
	xxx_messageInfo_DNSFloodVector.DiscardUnknown(m)
}

var xxx_messageInfo_DNSFloodVector proto.InternalMessageInfo

func (m *DNSFloodVector) GetQueryType() DNSQueryType {
	if m != nil {
		return m.QueryType
	}
	return A
}

func (m *DNSFloodVector) GetState() State {
	if m != nil {
		return m.State
	}
	return DETECT
}

func (m *DNSFloodVector) GetVolumetricThresholds() *VolumetricThresholds {
	if m != nil {
		return m.VolumetricThresholds
	}
	return nil
}

func (m *DNSFloodVector) GetBadActorsVolumetricThresholds() *BadActorsVolumetricThresholds {
	if m != nil {
		return m.BadActorsVolumetricThresholds
	}
	return nil
}

func (m *DNSFloodVector) GetAttackedDestinationVolumetricThresholds() *AttackedDestinationVolumetricThresholds {
	if m != nil {
		return m.AttackedDestinationVolumetricThresholds
	}
	return nil
}

// DNS Error Vector Config
//
// x-displayName: "DNS Error Vector Config"
// DNS Error Vector Config
type DNSErrorVector struct {
	// DNS Error Type
	//
	// x-displayName: "DNS Error Type"
	// x-required
	// x-example: "Malformed Request"
	// DNS Error Type
	DnsErrorType DNSErrorType `protobuf:"varint,1,opt,name=dns_error_type,json=dnsErrorType,proto3,enum=ves.io.schema.global_config.DNSErrorType" json:"dns_error_type,omitempty"`
	// Detection Threshold Percentage
	//
	// x-displayName: "Detection Threshold Percentage"
	// x-required
	// x-example: "500"
	// DNS Error Detection Threshold Percentage
	DetectionThresholdPercentage uint32 `protobuf:"varint,2,opt,name=detection_threshold_percentage,json=detectionThresholdPercentage,proto3" json:"detection_threshold_percentage,omitempty"`
	// Detection Threshold Events Per Sec
	//
	// x-displayName: "Detection Threshold Events Per Sec"
	// x-example: "100000"
	// DNS Error Detection Threshold Events Per Sec
	DetectionThresholdEps *ThresholdEPS `protobuf:"bytes,3,opt,name=detection_threshold_eps,json=detectionThresholdEps,proto3" json:"detection_threshold_eps,omitempty"`
}

func (m *DNSErrorVector) Reset()      { *m = DNSErrorVector{} }
func (*DNSErrorVector) ProtoMessage() {}
func (*DNSErrorVector) Descriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{5}
}
func (m *DNSErrorVector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNSErrorVector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DNSErrorVector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNSErrorVector.Merge(m, src)
}
func (m *DNSErrorVector) XXX_Size() int {
	return m.Size()
}
func (m *DNSErrorVector) XXX_DiscardUnknown() {
	xxx_messageInfo_DNSErrorVector.DiscardUnknown(m)
}

var xxx_messageInfo_DNSErrorVector proto.InternalMessageInfo

func (m *DNSErrorVector) GetDnsErrorType() DNSErrorType {
	if m != nil {
		return m.DnsErrorType
	}
	return DNS_MALFORMED
}

func (m *DNSErrorVector) GetDetectionThresholdPercentage() uint32 {
	if m != nil {
		return m.DetectionThresholdPercentage
	}
	return 0
}

func (m *DNSErrorVector) GetDetectionThresholdEps() *ThresholdEPS {
	if m != nil {
		return m.DetectionThresholdEps
	}
	return nil
}

// Allow Rule
//
// x-displayName: "Allow Rule"
// Specify the rule for a IP addresses or specfic traffic that need to be excluded from DDoS detection/mitigation
type AllowRule struct {
	// Protocol Type
	//
	// x-displayName: "Matching Protocol Type"
	// x-required
	// Matching Protocol Type
	ProtocolType ProtocolType `protobuf:"varint,1,opt,name=protocol_type,json=protocolType,proto3,enum=ves.io.schema.global_config.ProtocolType" json:"protocol_type,omitempty"`
	// Match Rule Type
	//
	// x-displayName: "Match Rule Type"
	// x-required
	// Match Rule Type
	MatchType *MatchRuleType `protobuf:"bytes,2,opt,name=match_type,json=matchType,proto3" json:"match_type,omitempty"`
	// Enable Status
	//
	// x-displayName: "Enable Status"
	EnableStatus EnableStatus `protobuf:"varint,3,opt,name=enable_status,json=enableStatus,proto3,enum=ves.io.schema.global_config.EnableStatus" json:"enable_status,omitempty"`
}

func (m *AllowRule) Reset()      { *m = AllowRule{} }
func (*AllowRule) ProtoMessage() {}
func (*AllowRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{6}
}
func (m *AllowRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllowRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AllowRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllowRule.Merge(m, src)
}
func (m *AllowRule) XXX_Size() int {
	return m.Size()
}
func (m *AllowRule) XXX_DiscardUnknown() {
	xxx_messageInfo_AllowRule.DiscardUnknown(m)
}

var xxx_messageInfo_AllowRule proto.InternalMessageInfo

func (m *AllowRule) GetProtocolType() ProtocolType {
	if m != nil {
		return m.ProtocolType
	}
	return ANY_PROTOCOL
}

func (m *AllowRule) GetMatchType() *MatchRuleType {
	if m != nil {
		return m.MatchType
	}
	return nil
}

func (m *AllowRule) GetEnableStatus() EnableStatus {
	if m != nil {
		return m.EnableStatus
	}
	return STATUS_ENABLE
}

// Match Rule Type
//
// x-displayName: "Match Rule Type"
// Specify the match rule
type MatchRuleType struct {
	// Match Rule
	//
	// x-displayName: "Match Rule"
	// x-required
	// Options to specify Match Rule
	//
	// Types that are valid to be assigned to Choice:
	//	*MatchRuleType_DestinationMatch
	//	*MatchRuleType_SourceMatch
	//	*MatchRuleType_AnyV4
	//	*MatchRuleType_AnyV6
	//	*MatchRuleType_AnyIp
	Choice isMatchRuleType_Choice `protobuf_oneof:"choice"`
}

func (m *MatchRuleType) Reset()      { *m = MatchRuleType{} }
func (*MatchRuleType) ProtoMessage() {}
func (*MatchRuleType) Descriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{7}
}
func (m *MatchRuleType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchRuleType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MatchRuleType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchRuleType.Merge(m, src)
}
func (m *MatchRuleType) XXX_Size() int {
	return m.Size()
}
func (m *MatchRuleType) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchRuleType.DiscardUnknown(m)
}

var xxx_messageInfo_MatchRuleType proto.InternalMessageInfo

type isMatchRuleType_Choice interface {
	isMatchRuleType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type MatchRuleType_DestinationMatch struct {
	DestinationMatch *MatchIPAddressWithPort `protobuf:"bytes,2,opt,name=destination_match,json=destinationMatch,proto3,oneof" json:"destination_match,omitempty"`
}
type MatchRuleType_SourceMatch struct {
	SourceMatch *MatchIPAddressWithPort `protobuf:"bytes,3,opt,name=source_match,json=sourceMatch,proto3,oneof" json:"source_match,omitempty"`
}
type MatchRuleType_AnyV4 struct {
	AnyV4 *DestinationPort `protobuf:"bytes,4,opt,name=any_v4,json=anyV4,proto3,oneof" json:"any_v4,omitempty"`
}
type MatchRuleType_AnyV6 struct {
	AnyV6 *DestinationPort `protobuf:"bytes,5,opt,name=any_v6,json=anyV6,proto3,oneof" json:"any_v6,omitempty"`
}
type MatchRuleType_AnyIp struct {
	AnyIp *DestinationPort `protobuf:"bytes,6,opt,name=any_ip,json=anyIp,proto3,oneof" json:"any_ip,omitempty"`
}

func (*MatchRuleType_DestinationMatch) isMatchRuleType_Choice() {}
func (*MatchRuleType_SourceMatch) isMatchRuleType_Choice()      {}
func (*MatchRuleType_AnyV4) isMatchRuleType_Choice()            {}
func (*MatchRuleType_AnyV6) isMatchRuleType_Choice()            {}
func (*MatchRuleType_AnyIp) isMatchRuleType_Choice()            {}

func (m *MatchRuleType) GetChoice() isMatchRuleType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *MatchRuleType) GetDestinationMatch() *MatchIPAddressWithPort {
	if x, ok := m.GetChoice().(*MatchRuleType_DestinationMatch); ok {
		return x.DestinationMatch
	}
	return nil
}

func (m *MatchRuleType) GetSourceMatch() *MatchIPAddressWithPort {
	if x, ok := m.GetChoice().(*MatchRuleType_SourceMatch); ok {
		return x.SourceMatch
	}
	return nil
}

func (m *MatchRuleType) GetAnyV4() *DestinationPort {
	if x, ok := m.GetChoice().(*MatchRuleType_AnyV4); ok {
		return x.AnyV4
	}
	return nil
}

func (m *MatchRuleType) GetAnyV6() *DestinationPort {
	if x, ok := m.GetChoice().(*MatchRuleType_AnyV6); ok {
		return x.AnyV6
	}
	return nil
}

func (m *MatchRuleType) GetAnyIp() *DestinationPort {
	if x, ok := m.GetChoice().(*MatchRuleType_AnyIp); ok {
		return x.AnyIp
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MatchRuleType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MatchRuleType_DestinationMatch)(nil),
		(*MatchRuleType_SourceMatch)(nil),
		(*MatchRuleType_AnyV4)(nil),
		(*MatchRuleType_AnyV6)(nil),
		(*MatchRuleType_AnyIp)(nil),
	}
}

// Match Rule
//
// x-displayName: "Match Rule"
// Specify the match rule
type MatchIPAddressWithPort struct {
	// Match Port
	//
	// x-displayName: "Match IP Address"
	// x-required
	// Options to specify Match IP Address
	//
	// Types that are valid to be assigned to Choice:
	//	*MatchIPAddressWithPort_Any
	//	*MatchIPAddressWithPort_Address
	Choice isMatchIPAddressWithPort_Choice `protobuf_oneof:"choice"`
	// Destination Port
	//
	// x-displayName: "Destination Port"
	// x-example: "53"
	// Destination Port
	DestinationPort *DestinationPort `protobuf:"bytes,4,opt,name=destination_port,json=destinationPort,proto3" json:"destination_port,omitempty"`
}

func (m *MatchIPAddressWithPort) Reset()      { *m = MatchIPAddressWithPort{} }
func (*MatchIPAddressWithPort) ProtoMessage() {}
func (*MatchIPAddressWithPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{8}
}
func (m *MatchIPAddressWithPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchIPAddressWithPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MatchIPAddressWithPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchIPAddressWithPort.Merge(m, src)
}
func (m *MatchIPAddressWithPort) XXX_Size() int {
	return m.Size()
}
func (m *MatchIPAddressWithPort) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchIPAddressWithPort.DiscardUnknown(m)
}

var xxx_messageInfo_MatchIPAddressWithPort proto.InternalMessageInfo

type isMatchIPAddressWithPort_Choice interface {
	isMatchIPAddressWithPort_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type MatchIPAddressWithPort_Any struct {
	Any *schema.Empty `protobuf:"bytes,2,opt,name=any,proto3,oneof" json:"any,omitempty"`
}
type MatchIPAddressWithPort_Address struct {
	Address string `protobuf:"bytes,3,opt,name=address,proto3,oneof" json:"address,omitempty"`
}

func (*MatchIPAddressWithPort_Any) isMatchIPAddressWithPort_Choice()     {}
func (*MatchIPAddressWithPort_Address) isMatchIPAddressWithPort_Choice() {}

func (m *MatchIPAddressWithPort) GetChoice() isMatchIPAddressWithPort_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *MatchIPAddressWithPort) GetAny() *schema.Empty {
	if x, ok := m.GetChoice().(*MatchIPAddressWithPort_Any); ok {
		return x.Any
	}
	return nil
}

func (m *MatchIPAddressWithPort) GetAddress() string {
	if x, ok := m.GetChoice().(*MatchIPAddressWithPort_Address); ok {
		return x.Address
	}
	return ""
}

func (m *MatchIPAddressWithPort) GetDestinationPort() *DestinationPort {
	if m != nil {
		return m.DestinationPort
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MatchIPAddressWithPort) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MatchIPAddressWithPort_Any)(nil),
		(*MatchIPAddressWithPort_Address)(nil),
	}
}

// Destination Port
//
// x-displayName: "Destination Port"
// Specify the Destination Port
type DestinationPort struct {
	// Destination Port
	//
	// x-displayName: "Destination Port"
	// x-required
	// Options to specify Destination Port
	//
	// Types that are valid to be assigned to Choice:
	//	*DestinationPort_Any
	//	*DestinationPort_Port
	Choice isDestinationPort_Choice `protobuf_oneof:"choice"`
}

func (m *DestinationPort) Reset()      { *m = DestinationPort{} }
func (*DestinationPort) ProtoMessage() {}
func (*DestinationPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{9}
}
func (m *DestinationPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DestinationPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DestinationPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DestinationPort.Merge(m, src)
}
func (m *DestinationPort) XXX_Size() int {
	return m.Size()
}
func (m *DestinationPort) XXX_DiscardUnknown() {
	xxx_messageInfo_DestinationPort.DiscardUnknown(m)
}

var xxx_messageInfo_DestinationPort proto.InternalMessageInfo

type isDestinationPort_Choice interface {
	isDestinationPort_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DestinationPort_Any struct {
	Any *schema.Empty `protobuf:"bytes,2,opt,name=any,proto3,oneof" json:"any,omitempty"`
}
type DestinationPort_Port struct {
	Port uint32 `protobuf:"varint,3,opt,name=port,proto3,oneof" json:"port,omitempty"`
}

func (*DestinationPort_Any) isDestinationPort_Choice()  {}
func (*DestinationPort_Port) isDestinationPort_Choice() {}

func (m *DestinationPort) GetChoice() isDestinationPort_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *DestinationPort) GetAny() *schema.Empty {
	if x, ok := m.GetChoice().(*DestinationPort_Any); ok {
		return x.Any
	}
	return nil
}

func (m *DestinationPort) GetPort() uint32 {
	if x, ok := m.GetChoice().(*DestinationPort_Port); ok {
		return x.Port
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DestinationPort) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DestinationPort_Any)(nil),
		(*DestinationPort_Port)(nil),
	}
}

// NxDomain Learning Config Parameters
//
// x-displayName: "Learning Config Parameters"
// NxDomain Learning Config Parameters
type NxDomainLearningParams struct {
	// DNS Nxdomain Learn Period
	//
	// x-displayName: "DNS Nxdomain Learn Period"
	// x-example: "7200"
	// Specify the learn period for NxDomain vector: 1 - 2147483647. The default value is 7200.
	DnsNxDomainLearnPeriod uint32 `protobuf:"varint,1,opt,name=dns_nx_domain_learn_period,json=dnsNxDomainLearnPeriod,proto3" json:"dns_nx_domain_learn_period,omitempty"`
	// Nxdomain Re-Learn Period
	//
	// x-displayName: "Nxdomain Re-Learn Period"
	// x-example: "86400"
	// Specify the relearn period for nx-domain vector: 1 - 2147483647. The default value is 86400.
	DnsNxDomainRelearnPeriod uint32 `protobuf:"varint,2,opt,name=dns_nx_domain_relearn_period,json=dnsNxDomainRelearnPeriod,proto3" json:"dns_nx_domain_relearn_period,omitempty"`
	// DNS Nxdomain Tracker Size
	//
	// x-displayName: "DNS Nxdomain Tracker Size"
	// x-example: "320"
	// Specify the tracker size for nx-domain vector: 64 - 8000. The default value is 320.
	DnsNxDomainTrackerSize uint32 `protobuf:"varint,3,opt,name=dns_nx_domain_tracker_size,json=dnsNxDomainTrackerSize,proto3" json:"dns_nx_domain_tracker_size,omitempty"`
}

func (m *NxDomainLearningParams) Reset()      { *m = NxDomainLearningParams{} }
func (*NxDomainLearningParams) ProtoMessage() {}
func (*NxDomainLearningParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{10}
}
func (m *NxDomainLearningParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NxDomainLearningParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NxDomainLearningParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NxDomainLearningParams.Merge(m, src)
}
func (m *NxDomainLearningParams) XXX_Size() int {
	return m.Size()
}
func (m *NxDomainLearningParams) XXX_DiscardUnknown() {
	xxx_messageInfo_NxDomainLearningParams.DiscardUnknown(m)
}

var xxx_messageInfo_NxDomainLearningParams proto.InternalMessageInfo

func (m *NxDomainLearningParams) GetDnsNxDomainLearnPeriod() uint32 {
	if m != nil {
		return m.DnsNxDomainLearnPeriod
	}
	return 0
}

func (m *NxDomainLearningParams) GetDnsNxDomainRelearnPeriod() uint32 {
	if m != nil {
		return m.DnsNxDomainRelearnPeriod
	}
	return 0
}

func (m *NxDomainLearningParams) GetDnsNxDomainTrackerSize() uint32 {
	if m != nil {
		return m.DnsNxDomainTrackerSize
	}
	return 0
}

// Valid Domains List Config
//
// x-displayName: "Valid Domains List Config"
// x-example: "["www.example1.com", "www.example2.com"]"
// [x-required]
// Valid Domains List Config
type ValidDomainsListConfig struct {
	// Domains List
	//
	// x-displayName: "Domains List"
	// x-example: "["www.example1.com", "www.example2.com"]"
	// Valid Domains List Served by the DNS Server
	Domains []string `protobuf:"bytes,4,rep,name=domains,proto3" json:"domains,omitempty"`
}

func (m *ValidDomainsListConfig) Reset()      { *m = ValidDomainsListConfig{} }
func (*ValidDomainsListConfig) ProtoMessage() {}
func (*ValidDomainsListConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{11}
}
func (m *ValidDomainsListConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidDomainsListConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ValidDomainsListConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidDomainsListConfig.Merge(m, src)
}
func (m *ValidDomainsListConfig) XXX_Size() int {
	return m.Size()
}
func (m *ValidDomainsListConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidDomainsListConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ValidDomainsListConfig proto.InternalMessageInfo

func (m *ValidDomainsListConfig) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

// Bad Actor Detection Thresholds
//
// x-displayName: "Bad Actor Detection Thresholds"
// Bad Actor Detection identifies Bad Actor IP addresses from which attacks appear to originate,
// by detecting packets per second from a source, and to apply rate limits to such IP addresses.
type BadActorsVolumetricThresholds struct {
	// Per Source IP Detection Events Per Sec
	//
	// x-displayName: "Per Source IP Detection Events Per Sec"
	// x-required
	// x-example: "10000"
	// specify the number of events from one IP address that identifies the IP source as a bad actor,
	// for purpose of attack detection and logging.
	PerSourceIpDetectionEps *ThresholdEPS `protobuf:"bytes,1,opt,name=per_source_ip_detection_eps,json=perSourceIpDetectionEps,proto3" json:"per_source_ip_detection_eps,omitempty"`
	// Per Source IP Mitigation Threshold Events Per Sec
	//
	// x-displayName: "Per Source IP Mitigation Threshold Events Per Sec"
	// x-required
	// x-example: "10000"
	// specify the number of events per second from one IP address,
	// above which rate limiting or leak limiting occurs.
	PerSourceIpLimitEps *ThresholdEPS `protobuf:"bytes,2,opt,name=per_source_ip_limit_eps,json=perSourceIpLimitEps,proto3" json:"per_source_ip_limit_eps,omitempty"`
}

func (m *BadActorsVolumetricThresholds) Reset()      { *m = BadActorsVolumetricThresholds{} }
func (*BadActorsVolumetricThresholds) ProtoMessage() {}
func (*BadActorsVolumetricThresholds) Descriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{12}
}
func (m *BadActorsVolumetricThresholds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BadActorsVolumetricThresholds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BadActorsVolumetricThresholds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BadActorsVolumetricThresholds.Merge(m, src)
}
func (m *BadActorsVolumetricThresholds) XXX_Size() int {
	return m.Size()
}
func (m *BadActorsVolumetricThresholds) XXX_DiscardUnknown() {
	xxx_messageInfo_BadActorsVolumetricThresholds.DiscardUnknown(m)
}

var xxx_messageInfo_BadActorsVolumetricThresholds proto.InternalMessageInfo

func (m *BadActorsVolumetricThresholds) GetPerSourceIpDetectionEps() *ThresholdEPS {
	if m != nil {
		return m.PerSourceIpDetectionEps
	}
	return nil
}

func (m *BadActorsVolumetricThresholds) GetPerSourceIpLimitEps() *ThresholdEPS {
	if m != nil {
		return m.PerSourceIpLimitEps
	}
	return nil
}

// Attacked Destination Thresholds
//
// x-displayName: "Attacked Destination Thresholds"
// Attacked Destination Detection
type AttackedDestinationVolumetricThresholds struct {
	// Per Destination IP Detection Threshold Events Per Sec
	//
	// x-displayName: "Per Destination IP Detection Threshold Events Per Sec"
	// x-example: "10000"
	// specify the number of events per second that IP source as a bad actor,
	// for purposes of attack detection and logging.
	PerDstIpDetectionEps *ThresholdEPS `protobuf:"bytes,1,opt,name=per_dst_ip_detection_eps,json=perDstIpDetectionEps,proto3" json:"per_dst_ip_detection_eps,omitempty"`
	// Per Destination IP Mitigation Threshold Events Per Sec
	//
	// x-displayName: "Per Destination IP Mitigation Threshold Events Per Sec"
	// x-example: "100000"
	// specify the number of events per second headed to one IP address, above which rate limiting occurs.
	PerDstIpLimitEps *ThresholdEPS `protobuf:"bytes,2,opt,name=per_dst_ip_limit_eps,json=perDstIpLimitEps,proto3" json:"per_dst_ip_limit_eps,omitempty"`
}

func (m *AttackedDestinationVolumetricThresholds) Reset() {
	*m = AttackedDestinationVolumetricThresholds{}
}
func (*AttackedDestinationVolumetricThresholds) ProtoMessage() {}
func (*AttackedDestinationVolumetricThresholds) Descriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{13}
}
func (m *AttackedDestinationVolumetricThresholds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttackedDestinationVolumetricThresholds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AttackedDestinationVolumetricThresholds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttackedDestinationVolumetricThresholds.Merge(m, src)
}
func (m *AttackedDestinationVolumetricThresholds) XXX_Size() int {
	return m.Size()
}
func (m *AttackedDestinationVolumetricThresholds) XXX_DiscardUnknown() {
	xxx_messageInfo_AttackedDestinationVolumetricThresholds.DiscardUnknown(m)
}

var xxx_messageInfo_AttackedDestinationVolumetricThresholds proto.InternalMessageInfo

func (m *AttackedDestinationVolumetricThresholds) GetPerDstIpDetectionEps() *ThresholdEPS {
	if m != nil {
		return m.PerDstIpDetectionEps
	}
	return nil
}

func (m *AttackedDestinationVolumetricThresholds) GetPerDstIpLimitEps() *ThresholdEPS {
	if m != nil {
		return m.PerDstIpLimitEps
	}
	return nil
}

// Attack Volumetric Thresholds
//
// x-displayName: "Attack Volumetric Thresholds"
// Attack Volumetric Thresholds
type VolumetricThresholds struct {
	// Detection Threshold Percentage
	//
	// x-displayName: "Detection Threshold Percentage"
	// x-example: "500"
	// Specify a value (in percentage of traffic) for the attack detection threshold.
	// If packets of the specified types cross the percentage threshold, an attack is logged and reported.
	// The system continues to check every second, and registers an attack as long as the threshold is exceeded.
	DetectionThresholdPercentage uint32 `protobuf:"varint,1,opt,name=detection_threshold_percentage,json=detectionThresholdPercentage,proto3" json:"detection_threshold_percentage,omitempty"`
	// Detection Threshold Events Per Sec
	//
	// x-displayName: "Detection Threshold Events Per Sec"
	// x-example: "100000"
	// Specify a value (in events per second) for the attack detection threshold.
	// If packets of the specified types cross the threshold, an attack is logged and reported.
	// The system continues to check every second, and registers an attack as long as the threshold is exceeded.
	// Use Infinite to set no value for the threshold, this Specify that this type of attack is not logged or reported based on this threshold.
	DetectionThresholdEps *ThresholdEPS `protobuf:"bytes,2,opt,name=detection_threshold_eps,json=detectionThresholdEps,proto3" json:"detection_threshold_eps,omitempty"`
	// Mitigation Threshold Events Per Sec
	//
	// x-displayName: "Mitigation Threshold Events Per Sec"
	// x-example: "100000"
	// Specify a value (in events per second), which should not be exceeded. If the number of events of this type exceeds the threshold,
	// excess events are dropped until the rate no longer exceeds the threshold.
	MitigationThresholdEps *ThresholdEPS `protobuf:"bytes,3,opt,name=mitigation_threshold_eps,json=mitigationThresholdEps,proto3" json:"mitigation_threshold_eps,omitempty"`
}

func (m *VolumetricThresholds) Reset()      { *m = VolumetricThresholds{} }
func (*VolumetricThresholds) ProtoMessage() {}
func (*VolumetricThresholds) Descriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{14}
}
func (m *VolumetricThresholds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VolumetricThresholds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VolumetricThresholds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumetricThresholds.Merge(m, src)
}
func (m *VolumetricThresholds) XXX_Size() int {
	return m.Size()
}
func (m *VolumetricThresholds) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumetricThresholds.DiscardUnknown(m)
}

var xxx_messageInfo_VolumetricThresholds proto.InternalMessageInfo

func (m *VolumetricThresholds) GetDetectionThresholdPercentage() uint32 {
	if m != nil {
		return m.DetectionThresholdPercentage
	}
	return 0
}

func (m *VolumetricThresholds) GetDetectionThresholdEps() *ThresholdEPS {
	if m != nil {
		return m.DetectionThresholdEps
	}
	return nil
}

func (m *VolumetricThresholds) GetMitigationThresholdEps() *ThresholdEPS {
	if m != nil {
		return m.MitigationThresholdEps
	}
	return nil
}

// Threshold Eps
//
// x-displayName: "Threshold Eps"
// Threshold Eps
type ThresholdEPS struct {
	// Threshold Value
	//
	// x-displayName: "Set a threshold Value"
	// Threshold Value
	//
	// Types that are valid to be assigned to Choice:
	//	*ThresholdEPS_Disable
	//	*ThresholdEPS_Value
	Choice isThresholdEPS_Choice `protobuf_oneof:"choice"`
}

func (m *ThresholdEPS) Reset()      { *m = ThresholdEPS{} }
func (*ThresholdEPS) ProtoMessage() {}
func (*ThresholdEPS) Descriptor() ([]byte, []int) {
	return fileDescriptor_114e9fbe64b15935, []int{15}
}
func (m *ThresholdEPS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThresholdEPS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ThresholdEPS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThresholdEPS.Merge(m, src)
}
func (m *ThresholdEPS) XXX_Size() int {
	return m.Size()
}
func (m *ThresholdEPS) XXX_DiscardUnknown() {
	xxx_messageInfo_ThresholdEPS.DiscardUnknown(m)
}

var xxx_messageInfo_ThresholdEPS proto.InternalMessageInfo

type isThresholdEPS_Choice interface {
	isThresholdEPS_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ThresholdEPS_Disable struct {
	Disable *schema.Empty `protobuf:"bytes,2,opt,name=disable,proto3,oneof" json:"disable,omitempty"`
}
type ThresholdEPS_Value struct {
	Value uint32 `protobuf:"varint,3,opt,name=value,proto3,oneof" json:"value,omitempty"`
}

func (*ThresholdEPS_Disable) isThresholdEPS_Choice() {}
func (*ThresholdEPS_Value) isThresholdEPS_Choice()   {}

func (m *ThresholdEPS) GetChoice() isThresholdEPS_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *ThresholdEPS) GetDisable() *schema.Empty {
	if x, ok := m.GetChoice().(*ThresholdEPS_Disable); ok {
		return x.Disable
	}
	return nil
}

func (m *ThresholdEPS) GetValue() uint32 {
	if x, ok := m.GetChoice().(*ThresholdEPS_Value); ok {
		return x.Value
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ThresholdEPS) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ThresholdEPS_Disable)(nil),
		(*ThresholdEPS_Value)(nil),
	}
}

func init() {
	proto.RegisterEnum("ves.io.schema.global_config.EnableStatus", EnableStatus_name, EnableStatus_value)
	golang_proto.RegisterEnum("ves.io.schema.global_config.EnableStatus", EnableStatus_name, EnableStatus_value)
	proto.RegisterEnum("ves.io.schema.global_config.ProtocolType", ProtocolType_name, ProtocolType_value)
	golang_proto.RegisterEnum("ves.io.schema.global_config.ProtocolType", ProtocolType_name, ProtocolType_value)
	proto.RegisterEnum("ves.io.schema.global_config.State", State_name, State_value)
	golang_proto.RegisterEnum("ves.io.schema.global_config.State", State_name, State_value)
	proto.RegisterEnum("ves.io.schema.global_config.DNSQueryType", DNSQueryType_name, DNSQueryType_value)
	golang_proto.RegisterEnum("ves.io.schema.global_config.DNSQueryType", DNSQueryType_name, DNSQueryType_value)
	proto.RegisterEnum("ves.io.schema.global_config.DNSErrorType", DNSErrorType_name, DNSErrorType_value)
	golang_proto.RegisterEnum("ves.io.schema.global_config.DNSErrorType", DNSErrorType_name, DNSErrorType_value)
	proto.RegisterType((*DDoSProfile)(nil), "ves.io.schema.global_config.DDoSProfile")
	golang_proto.RegisterType((*DDoSProfile)(nil), "ves.io.schema.global_config.DDoSProfile")
	proto.RegisterType((*DNSDDoSVectors)(nil), "ves.io.schema.global_config.DNSDDoSVectors")
	golang_proto.RegisterType((*DNSDDoSVectors)(nil), "ves.io.schema.global_config.DNSDDoSVectors")
	proto.RegisterType((*NxDomainVectors)(nil), "ves.io.schema.global_config.NxDomainVectors")
	golang_proto.RegisterType((*NxDomainVectors)(nil), "ves.io.schema.global_config.NxDomainVectors")
	proto.RegisterType((*OversizedDNSVectors)(nil), "ves.io.schema.global_config.OversizedDNSVectors")
	golang_proto.RegisterType((*OversizedDNSVectors)(nil), "ves.io.schema.global_config.OversizedDNSVectors")
	proto.RegisterType((*DNSFloodVector)(nil), "ves.io.schema.global_config.DNSFloodVector")
	golang_proto.RegisterType((*DNSFloodVector)(nil), "ves.io.schema.global_config.DNSFloodVector")
	proto.RegisterType((*DNSErrorVector)(nil), "ves.io.schema.global_config.DNSErrorVector")
	golang_proto.RegisterType((*DNSErrorVector)(nil), "ves.io.schema.global_config.DNSErrorVector")
	proto.RegisterType((*AllowRule)(nil), "ves.io.schema.global_config.AllowRule")
	golang_proto.RegisterType((*AllowRule)(nil), "ves.io.schema.global_config.AllowRule")
	proto.RegisterType((*MatchRuleType)(nil), "ves.io.schema.global_config.MatchRuleType")
	golang_proto.RegisterType((*MatchRuleType)(nil), "ves.io.schema.global_config.MatchRuleType")
	proto.RegisterType((*MatchIPAddressWithPort)(nil), "ves.io.schema.global_config.MatchIPAddressWithPort")
	golang_proto.RegisterType((*MatchIPAddressWithPort)(nil), "ves.io.schema.global_config.MatchIPAddressWithPort")
	proto.RegisterType((*DestinationPort)(nil), "ves.io.schema.global_config.DestinationPort")
	golang_proto.RegisterType((*DestinationPort)(nil), "ves.io.schema.global_config.DestinationPort")
	proto.RegisterType((*NxDomainLearningParams)(nil), "ves.io.schema.global_config.NxDomainLearningParams")
	golang_proto.RegisterType((*NxDomainLearningParams)(nil), "ves.io.schema.global_config.NxDomainLearningParams")
	proto.RegisterType((*ValidDomainsListConfig)(nil), "ves.io.schema.global_config.ValidDomainsListConfig")
	golang_proto.RegisterType((*ValidDomainsListConfig)(nil), "ves.io.schema.global_config.ValidDomainsListConfig")
	proto.RegisterType((*BadActorsVolumetricThresholds)(nil), "ves.io.schema.global_config.BadActorsVolumetricThresholds")
	golang_proto.RegisterType((*BadActorsVolumetricThresholds)(nil), "ves.io.schema.global_config.BadActorsVolumetricThresholds")
	proto.RegisterType((*AttackedDestinationVolumetricThresholds)(nil), "ves.io.schema.global_config.AttackedDestinationVolumetricThresholds")
	golang_proto.RegisterType((*AttackedDestinationVolumetricThresholds)(nil), "ves.io.schema.global_config.AttackedDestinationVolumetricThresholds")
	proto.RegisterType((*VolumetricThresholds)(nil), "ves.io.schema.global_config.VolumetricThresholds")
	golang_proto.RegisterType((*VolumetricThresholds)(nil), "ves.io.schema.global_config.VolumetricThresholds")
	proto.RegisterType((*ThresholdEPS)(nil), "ves.io.schema.global_config.ThresholdEPS")
	golang_proto.RegisterType((*ThresholdEPS)(nil), "ves.io.schema.global_config.ThresholdEPS")
}

func init() {
	proto.RegisterFile("ves.io/schema/global_config/ddos_types.proto", fileDescriptor_114e9fbe64b15935)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/global_config/ddos_types.proto", fileDescriptor_114e9fbe64b15935)
}

var fileDescriptor_114e9fbe64b15935 = []byte{
	// 1882 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0x4d, 0x6c, 0xdb, 0xc8,
	0x15, 0xd6, 0x88, 0x92, 0x65, 0x3f, 0xcb, 0x36, 0x3d, 0x71, 0x1c, 0xad, 0xe3, 0x10, 0x86, 0x0a,
	0x74, 0x5d, 0xaf, 0x23, 0x7b, 0x6d, 0x27, 0x4d, 0x5b, 0x6c, 0x51, 0xc9, 0x64, 0x6a, 0x2d, 0x6c,
	0x49, 0xa1, 0x14, 0xc7, 0x29, 0x52, 0xb0, 0xb4, 0x48, 0xcb, 0xc4, 0x52, 0x24, 0x97, 0xa4, 0x14,
	0x7b, 0x4f, 0x01, 0x7a, 0x2d, 0xb0, 0xc5, 0x02, 0xbd, 0xf5, 0xd0, 0x02, 0x45, 0xd1, 0x6b, 0xaf,
	0xd5, 0xc5, 0xe8, 0xa9, 0x97, 0x02, 0x39, 0x06, 0x3e, 0x35, 0xca, 0xa1, 0xdd, 0xdb, 0x9e, 0x8a,
	0xde, 0x5c, 0xcc, 0xf0, 0x47, 0x94, 0xa3, 0x95, 0x9d, 0xc4, 0x45, 0x2f, 0x81, 0x0f, 0x1e, 0x0e,
	0xdf, 0xf7, 0xbd, 0x9f, 0x79, 0xf3, 0xde, 0xa3, 0x60, 0xb9, 0xad, 0x3a, 0x39, 0xcd, 0x5c, 0x71,
	0xea, 0x87, 0x6a, 0x53, 0x5e, 0x69, 0xe8, 0xe6, 0xbe, 0xac, 0x4b, 0x75, 0xd3, 0x38, 0xd0, 0x1a,
	0x2b, 0x8a, 0x62, 0x3a, 0x92, 0x7b, 0x6c, 0xa9, 0x4e, 0xce, 0xb2, 0x4d, 0xd7, 0xc4, 0x37, 0x3d,
	0xe9, 0x9c, 0x27, 0x9d, 0xeb, 0x93, 0x9e, 0xbb, 0xdd, 0xd0, 0xdc, 0xc3, 0xd6, 0x7e, 0xae, 0x6e,
	0x36, 0x57, 0x1a, 0x66, 0xc3, 0x5c, 0xa1, 0x98, 0xfd, 0xd6, 0x01, 0x7d, 0xa2, 0x0f, 0x74, 0xe5,
	0x71, 0xcd, 0xdd, 0xec, 0xd7, 0x6c, 0x5a, 0xae, 0x66, 0x1a, 0xbe, 0xa2, 0xb9, 0x0f, 0xfa, 0x5f,
	0x46, 0x6c, 0x98, 0x9b, 0xef, 0x7f, 0xd5, 0x96, 0x75, 0x4d, 0x91, 0x5d, 0xd5, 0x7f, 0xbb, 0x70,
	0xee, 0xad, 0xa6, 0x3e, 0x95, 0xfa, 0xa8, 0xb3, 0x7f, 0x46, 0x30, 0xce, 0xf3, 0x66, 0xb5, 0x62,
	0x9b, 0x07, 0x9a, 0xae, 0xe2, 0x4f, 0x80, 0x51, 0x0c, 0x27, 0x83, 0x16, 0xd0, 0xe2, 0xf8, 0xda,
	0x47, 0xb9, 0x21, 0x1e, 0xe6, 0xf8, 0x52, 0x95, 0x20, 0x77, 0xd5, 0xba, 0x6b, 0xda, 0x8e, 0x48,
	0x70, 0xf8, 0xe7, 0x30, 0x2e, 0xeb, 0xba, 0xf9, 0x54, 0xb2, 0x5b, 0xba, 0xea, 0x64, 0xe2, 0x0b,
	0xcc, 0xe2, 0xf8, 0xda, 0x77, 0x87, 0xd2, 0xe4, 0x89, 0xbc, 0xd8, 0xd2, 0xd5, 0xc2, 0xcc, 0x5f,
	0xbe, 0x3e, 0x61, 0x92, 0x5f, 0xa1, 0x38, 0x3b, 0x1a, 0xac, 0x32, 0x48, 0x04, 0x39, 0x10, 0x70,
	0x3e, 0x4d, 0x8c, 0x32, 0x6c, 0x22, 0xfb, 0x57, 0x06, 0x26, 0xfb, 0x95, 0xe3, 0x3d, 0x98, 0x36,
	0x8e, 0x24, 0xc5, 0x6c, 0xca, 0x9a, 0x21, 0x59, 0x9e, 0x2f, 0xbe, 0x13, 0xcb, 0x43, 0xb5, 0x97,
	0x8e, 0x78, 0x0a, 0x0a, 0xbc, 0x98, 0x32, 0xfc, 0x8d, 0x20, 0x20, 0x0a, 0x5c, 0x37, 0xdb, 0xaa,
	0xed, 0x68, 0x5f, 0xa8, 0x8a, 0xa4, 0x18, 0x4e, 0xc8, 0x1e, 0xa7, 0xec, 0xab, 0x43, 0xd9, 0xcb,
	0x01, 0x92, 0x2f, 0x85, 0x71, 0xba, 0x16, 0xd2, 0xf1, 0x86, 0x13, 0x68, 0x79, 0x0a, 0xd3, 0x84,
	0xfb, 0x40, 0x37, 0x4d, 0x45, 0x6a, 0x7b, 0x92, 0x19, 0x86, 0x46, 0xef, 0xc2, 0x43, 0xb8, 0x4f,
	0x40, 0x1e, 0x7b, 0x81, 0x0b, 0x43, 0x38, 0x19, 0xac, 0x46, 0x51, 0x24, 0x98, 0x53, 0x8a, 0xe1,
	0x44, 0xe4, 0x9d, 0x40, 0xb1, 0x6a, 0xdb, 0xa6, 0x1d, 0x2a, 0x4e, 0x5c, 0x4e, 0xb1, 0x40, 0x40,
	0xaf, 0x29, 0x66, 0xbe, 0x55, 0x71, 0x44, 0xde, 0xc9, 0xfe, 0x26, 0x09, 0x53, 0xe7, 0x82, 0x8f,
	0xef, 0x41, 0xd2, 0x71, 0x65, 0xd7, 0x3b, 0xb9, 0xc9, 0xb5, 0xec, 0x50, 0x03, 0xaa, 0x44, 0x52,
	0xf4, 0x00, 0xf8, 0x00, 0xae, 0xb7, 0x4d, 0xbd, 0xd5, 0x54, 0x5d, 0x5b, 0xab, 0x4b, 0xee, 0xa1,
	0xad, 0x3a, 0x87, 0xa6, 0xae, 0x38, 0xfe, 0x29, 0x7d, 0x3c, 0x94, 0x69, 0x37, 0x44, 0xd6, 0x42,
	0xa0, 0x38, 0xd3, 0x1e, 0xb0, 0x8b, 0x9f, 0xc0, 0x94, 0xae, 0xca, 0xb6, 0xa1, 0x19, 0x0d, 0xc9,
	0x92, 0x6d, 0xb9, 0x49, 0x4e, 0x89, 0x68, 0x58, 0xbf, 0x54, 0x96, 0x6d, 0xfb, 0xd8, 0x0a, 0x85,
	0x8a, 0x93, 0x7a, 0xdf, 0x33, 0xfe, 0x25, 0x82, 0x85, 0x7d, 0x59, 0x91, 0x64, 0x1a, 0x0e, 0x69,
	0xb0, 0x47, 0x09, 0xaa, 0xef, 0x87, 0x43, 0xf5, 0x15, 0x64, 0x25, 0x4f, 0x39, 0x06, 0xba, 0x76,
	0x6b, 0x7f, 0xd8, 0x6b, 0xfc, 0x7b, 0x04, 0x4b, 0xb2, 0xeb, 0xca, 0xf5, 0xcf, 0x48, 0xc6, 0xab,
	0x8e, 0xab, 0x19, 0x32, 0x29, 0x19, 0xdf, 0x62, 0x4f, 0x92, 0xda, 0xc3, 0x0f, 0xbf, 0xe3, 0x3e,
	0x1d, 0xdf, 0x63, 0x1b, 0x68, 0xd9, 0x87, 0xf2, 0xe5, 0x04, 0xf1, 0x1e, 0x4c, 0xd0, 0x52, 0xe7,
	0x5f, 0x79, 0x27, 0x33, 0x72, 0x89, 0x53, 0xd8, 0x25, 0x08, 0xef, 0x20, 0x9c, 0x6d, 0xcd, 0x71,
	0x37, 0xe9, 0xb6, 0x98, 0x6e, 0x47, 0xf6, 0xb3, 0xbf, 0x4b, 0xc0, 0xb5, 0x01, 0xd7, 0xf6, 0x1d,
	0x72, 0xf3, 0x13, 0x48, 0x37, 0xe5, 0x23, 0x5a, 0x3b, 0x08, 0x29, 0x4d, 0xc9, 0x89, 0xc2, 0xcd,
	0xd3, 0x0e, 0x4a, 0x6c, 0xac, 0xfe, 0xe0, 0xee, 0x7f, 0x3a, 0x28, 0x46, 0x2e, 0x0a, 0x2c, 0x8d,
	0x66, 0xce, 0xce, 0xce, 0xce, 0xa6, 0x16, 0x91, 0x08, 0x4d, 0xf9, 0x88, 0x37, 0x9c, 0xaa, 0xf6,
	0xc5, 0x90, 0xd4, 0x66, 0xae, 0x36, 0xb5, 0xdf, 0x27, 0xdf, 0x25, 0x93, 0x2f, 0xfb, 0xc7, 0x04,
	0xed, 0x3f, 0x91, 0x3a, 0x8a, 0xb7, 0x00, 0x3e, 0x6f, 0xa9, 0xf6, 0x31, 0x9d, 0x0f, 0xfc, 0x14,
	0xf9, 0xde, 0x45, 0xf5, 0xf3, 0x01, 0x41, 0xd4, 0x8e, 0x2d, 0x55, 0x1c, 0xfb, 0x3c, 0x58, 0xf6,
	0xf2, 0x2c, 0x7e, 0x65, 0x35, 0xf0, 0x7d, 0xa2, 0xfc, 0xbf, 0x12, 0x25, 0x4e, 0x13, 0x25, 0xd2,
	0xf7, 0x70, 0x19, 0x26, 0x7b, 0xfd, 0xf6, 0x4d, 0x92, 0x85, 0x92, 0xd0, 0x64, 0x49, 0x07, 0xad,
	0x94, 0xe6, 0xcb, 0x2f, 0x80, 0x53, 0x54, 0x57, 0xad, 0x53, 0xdf, 0x43, 0x87, 0x25, 0x4b, 0xb5,
	0xeb, 0xaa, 0xe1, 0xca, 0x8d, 0xa0, 0xde, 0xcc, 0x9d, 0x76, 0x10, 0x73, 0x67, 0x75, 0x75, 0x50,
	0xb9, 0x99, 0x0f, 0x19, 0x42, 0xe3, 0x2b, 0x21, 0x1e, 0xcb, 0x70, 0x63, 0x90, 0x06, 0xd5, 0x0a,
	0x32, 0x6b, 0xb8, 0xed, 0x21, 0xa5, 0x50, 0xa9, 0x8a, 0xd7, 0x5f, 0xd7, 0x24, 0x58, 0x4e, 0xf6,
	0xdf, 0x08, 0xc6, 0xc2, 0x39, 0x10, 0x97, 0x60, 0x82, 0x0e, 0xa7, 0x75, 0x53, 0xbf, 0x7c, 0x88,
	0x2a, 0x3e, 0xc2, 0x0b, 0x91, 0x15, 0x79, 0xc2, 0x45, 0x80, 0xa6, 0xec, 0xd6, 0x0f, 0x3d, 0x32,
	0x6f, 0x22, 0x58, 0x1a, 0x4a, 0xb6, 0x43, 0xc4, 0x89, 0x2d, 0xde, 0xed, 0xa4, 0x68, 0x4a, 0x55,
	0x82, 0x09, 0xd5, 0x90, 0xf7, 0x75, 0x55, 0x22, 0x77, 0xae, 0xe5, 0x45, 0xe0, 0x22, 0xd3, 0x04,
	0x8a, 0xa8, 0x52, 0x80, 0x98, 0x56, 0x23, 0x4f, 0xd9, 0xbf, 0x33, 0x30, 0xd1, 0xa7, 0x0c, 0xef,
	0xc3, 0x74, 0x34, 0x9b, 0xa9, 0x6a, 0xdf, 0xe6, 0xf5, 0x8b, 0x6d, 0x2e, 0x56, 0xf2, 0x8a, 0x62,
	0xab, 0x8e, 0xf3, 0x48, 0x73, 0x0f, 0x2b, 0xa6, 0xed, 0x6e, 0xc5, 0x44, 0x36, 0xc2, 0x47, 0x85,
	0xf0, 0x1e, 0xa4, 0x1d, 0xb3, 0x65, 0xd7, 0x55, 0x9f, 0x9e, 0x79, 0x17, 0xfa, 0x71, 0x8f, 0xca,
	0x63, 0x16, 0x60, 0x44, 0x36, 0x8e, 0xa5, 0xf6, 0x86, 0x5f, 0x00, 0x86, 0x0f, 0xdf, 0x91, 0xfb,
	0xe3, 0x93, 0x25, 0x65, 0xe3, 0x78, 0x77, 0x23, 0xa4, 0xb9, 0xeb, 0xdf, 0xdb, 0xb7, 0xa2, 0xb9,
	0x1b, 0xd0, 0x68, 0x96, 0x3f, 0x1e, 0xbc, 0x0d, 0x4d, 0xd1, 0x2a, 0x7c, 0x07, 0x46, 0xea, 0x87,
	0xa6, 0x56, 0x57, 0xf1, 0x07, 0x27, 0x1d, 0x14, 0x7f, 0xde, 0x41, 0xa8, 0xdb, 0x41, 0x63, 0x6b,
	0xcb, 0xeb, 0xcb, 0x1b, 0xcb, 0x77, 0x96, 0x49, 0x07, 0x47, 0x9f, 0x26, 0x46, 0x11, 0x1b, 0x27,
	0x89, 0x3c, 0x3b, 0x38, 0x52, 0x78, 0x11, 0x18, 0xd9, 0x38, 0xf6, 0x8f, 0x72, 0xe6, 0x9c, 0x25,
	0x42, 0xd3, 0x72, 0x8f, 0xb7, 0x62, 0x22, 0x11, 0xc1, 0x1b, 0x90, 0x92, 0x3d, 0x30, 0x3d, 0x99,
	0xb1, 0x42, 0xe6, 0xb4, 0x83, 0x52, 0xab, 0x39, 0xfa, 0x17, 0xdc, 0xdf, 0x84, 0x1d, 0xb7, 0xd0,
	0x56, 0x4c, 0x0c, 0x44, 0xf1, 0x23, 0x88, 0x1e, 0xb4, 0x64, 0x99, 0xb6, 0xfb, 0x36, 0x87, 0x20,
	0x4e, 0x29, 0xfd, 0x1b, 0x85, 0x5b, 0xa1, 0xfb, 0xd7, 0x22, 0xee, 0x33, 0x6b, 0xcb, 0xeb, 0x11,
	0xc7, 0xbf, 0x44, 0x30, 0x75, 0x8e, 0xe9, 0x0d, 0x3c, 0xbe, 0x0d, 0x09, 0x6a, 0x2f, 0x43, 0x4b,
	0xd5, 0x8d, 0xd3, 0x0e, 0x8a, 0xdf, 0x59, 0x0f, 0x3c, 0x1d, 0x5d, 0x1a, 0xc9, 0x9c, 0x9d, 0x31,
	0x8b, 0xc4, 0x5b, 0x2a, 0x76, 0x39, 0x8b, 0xfe, 0x10, 0x87, 0xd9, 0xc1, 0x73, 0x37, 0x7e, 0x04,
	0x73, 0xa4, 0x08, 0xf7, 0xbe, 0x18, 0xe9, 0x1c, 0x4e, 0x6a, 0xa6, 0x66, 0x2a, 0xb4, 0xda, 0xf8,
	0xf3, 0xd9, 0xf7, 0xd7, 0x5e, 0x2f, 0x98, 0xa9, 0x45, 0x24, 0xce, 0x2a, 0x86, 0xd3, 0xc7, 0x5d,
	0xa1, 0x50, 0xfc, 0x04, 0xe6, 0xfb, 0x89, 0x6d, 0xb5, 0x8f, 0xda, 0x2b, 0xc5, 0xf3, 0xa7, 0x1d,
	0x94, 0xbc, 0x77, 0x77, 0x63, 0x30, 0x77, 0x26, 0xc2, 0x2d, 0x7a, 0x70, 0x9f, 0xbd, 0x7a, 0xde,
	0x6c, 0xd7, 0x26, 0x6d, 0xc8, 0xf6, 0xc6, 0xca, 0x5e, 0xec, 0x98, 0xf5, 0xb5, 0x90, 0x39, 0xb5,
	0x94, 0xcc, 0x9c, 0xfc, 0x78, 0xf1, 0x27, 0x7d, 0x26, 0xd7, 0x3c, 0x1c, 0x19, 0x2f, 0xb3, 0x12,
	0xcc, 0x0e, 0x9e, 0x8b, 0xb1, 0x00, 0xa9, 0x60, 0xba, 0x26, 0x1f, 0x84, 0x63, 0x85, 0x8f, 0x48,
	0xa0, 0x03, 0xe2, 0x91, 0xaf, 0x10, 0xc3, 0x3e, 0xab, 0xf4, 0x3e, 0xf1, 0xc8, 0x6a, 0xcc, 0x4e,
	0xb1, 0x28, 0xf3, 0x2c, 0x7e, 0x88, 0xc4, 0x00, 0x9b, 0xfd, 0x1a, 0xc1, 0xad, 0xa1, 0x9d, 0x1e,
	0x37, 0xe0, 0xa6, 0x45, 0xbc, 0xf0, 0x4a, 0x92, 0x66, 0x49, 0xbd, 0x76, 0x43, 0x9a, 0x0c, 0x7a,
	0xd3, 0x26, 0x73, 0xc3, 0x52, 0xed, 0x2a, 0x25, 0x2b, 0x5a, 0x7c, 0x40, 0x25, 0x58, 0x0e, 0x96,
	0xe0, 0x46, 0xbf, 0x22, 0x5d, 0x6b, 0x6a, 0x2e, 0x55, 0x12, 0x7f, 0x53, 0x25, 0xd7, 0x22, 0x4a,
	0xb6, 0x09, 0x0d, 0xe9, 0x63, 0xff, 0x44, 0xf0, 0xe1, 0x25, 0xa7, 0x08, 0x2c, 0x43, 0x86, 0x18,
	0xa3, 0x38, 0xee, 0x15, 0xb8, 0x3c, 0x63, 0xa9, 0x36, 0xef, 0xb8, 0xe7, 0xfc, 0x7d, 0x0c, 0x33,
	0x11, 0x15, 0xef, 0xe0, 0x2c, 0x1b, 0xd0, 0x87, 0x9e, 0x9e, 0xc4, 0x61, 0x66, 0xa0, 0x5b, 0x17,
	0xcf, 0x23, 0xe8, 0x7f, 0x37, 0x8f, 0xc4, 0xaf, 0x66, 0x1e, 0xc1, 0x75, 0xc8, 0x34, 0x35, 0x57,
	0x6b, 0xc8, 0x57, 0x31, 0xf3, 0xcc, 0xf6, 0xa8, 0xfa, 0x86, 0x9e, 0xdf, 0x22, 0x48, 0x47, 0x05,
	0xf1, 0x2a, 0xa4, 0x14, 0xcd, 0x21, 0xd3, 0xc1, 0x05, 0x35, 0x33, 0x10, 0xc3, 0x1b, 0x90, 0x6c,
	0xcb, 0x7a, 0x2b, 0xb8, 0xfc, 0xb4, 0xb0, 0x7c, 0xbc, 0xba, 0x3a, 0x30, 0xaa, 0xa4, 0x9f, 0x51,
	0xe1, 0x02, 0x17, 0x96, 0xcf, 0x99, 0x48, 0xf9, 0x4c, 0xac, 0x2d, 0x2f, 0x44, 0xea, 0xe7, 0xd2,
	0x8f, 0x20, 0x1d, 0x1d, 0x5c, 0xf0, 0x34, 0x4c, 0x54, 0x6b, 0xf9, 0xda, 0xc3, 0xaa, 0x24, 0x94,
	0xf2, 0x85, 0x6d, 0x81, 0x8d, 0x61, 0x0c, 0x93, 0xfe, 0x16, 0x5f, 0xac, 0xd2, 0x3d, 0x66, 0x2e,
	0x71, 0xd2, 0x41, 0xb1, 0xa5, 0x7b, 0x90, 0x8e, 0x0e, 0x64, 0x98, 0x85, 0x74, 0xbe, 0xf4, 0x58,
	0xaa, 0x88, 0xe5, 0x5a, 0x79, 0xb3, 0xbc, 0xcd, 0xc6, 0x70, 0x0a, 0x98, 0xda, 0x66, 0x85, 0x45,
	0x64, 0xf1, 0x90, 0xaf, 0xb0, 0x71, 0x1f, 0xb9, 0x01, 0x49, 0xfa, 0x55, 0x83, 0x01, 0x46, 0x78,
	0xa1, 0x26, 0x6c, 0xd6, 0xd8, 0x18, 0x4e, 0xc3, 0xe8, 0x4e, 0xb1, 0x56, 0xfc, 0x69, 0xbe, 0x26,
	0xb0, 0x08, 0x8f, 0x43, 0x2a, 0xd0, 0x17, 0xa0, 0x7e, 0x85, 0x20, 0x1d, 0xfd, 0xa2, 0xc2, 0x49,
	0x40, 0x79, 0x36, 0x86, 0x47, 0x21, 0x91, 0xcf, 0xe7, 0xf3, 0x9e, 0x9a, 0x4a, 0x4d, 0x64, 0xe3,
	0x74, 0x6b, 0xef, 0xbe, 0xc8, 0x32, 0x64, 0x55, 0x24, 0xab, 0x04, 0x1e, 0x83, 0xe4, 0x66, 0x29,
	0xbf, 0x23, 0xb0, 0x49, 0x3c, 0x02, 0xf1, 0x9d, 0x3d, 0x76, 0x84, 0xfc, 0x2f, 0x55, 0xd9, 0x14,
	0xc1, 0x55, 0xcb, 0x79, 0x76, 0x94, 0x2e, 0xc4, 0x5d, 0x76, 0x8c, 0x5a, 0xbe, 0x57, 0x63, 0x81,
	0x2c, 0xf2, 0xa5, 0xc7, 0xec, 0x38, 0x81, 0x97, 0x6b, 0x5b, 0x82, 0xc8, 0xa6, 0x7d, 0x73, 0x9e,
	0x50, 0x6b, 0x7a, 0x43, 0xfa, 0x34, 0x4c, 0xf0, 0xa5, 0xaa, 0xb4, 0x93, 0xdf, 0xbe, 0x5f, 0x16,
	0x77, 0x04, 0x9e, 0x8d, 0xe1, 0xeb, 0x30, 0x4d, 0xb6, 0x1e, 0xf0, 0x9b, 0xe5, 0x87, 0xa5, 0x9a,
	0xb4, 0x5d, 0xdc, 0x29, 0xd6, 0x58, 0x84, 0xe7, 0x21, 0xf3, 0xb0, 0x54, 0x2d, 0x6f, 0x17, 0x37,
	0x8b, 0x35, 0x81, 0x97, 0x88, 0x88, 0x28, 0x54, 0x2b, 0xe5, 0x52, 0x35, 0x74, 0xb6, 0xf0, 0x25,
	0x7a, 0xfe, 0x92, 0x8b, 0xbd, 0x78, 0xc9, 0xc5, 0xbe, 0x79, 0xc9, 0xa1, 0x67, 0x5d, 0x0e, 0xfd,
	0xa9, 0xcb, 0xa1, 0xbf, 0x75, 0x39, 0xf4, 0xbc, 0xcb, 0xa1, 0x17, 0x5d, 0x0e, 0xfd, 0xa3, 0xcb,
	0xa1, 0x7f, 0x75, 0xb9, 0xd8, 0x37, 0x5d, 0x0e, 0xfd, 0xfa, 0x15, 0x17, 0x3b, 0x79, 0xc5, 0xa1,
	0xe7, 0xaf, 0xb8, 0xd8, 0x8b, 0x57, 0x5c, 0xec, 0x67, 0x0f, 0x1a, 0xa6, 0xf5, 0x59, 0x23, 0xd7,
	0x36, 0x75, 0x57, 0xb5, 0x6d, 0x39, 0xd7, 0x72, 0x56, 0xe8, 0xe2, 0xc0, 0xb4, 0x9b, 0xb7, 0x2d,
	0xdb, 0x6c, 0x6b, 0x8a, 0x6a, 0xdf, 0x0e, 0x5e, 0xaf, 0x58, 0xfb, 0x0d, 0x73, 0x45, 0x3d, 0x72,
	0xfd, 0xdf, 0x90, 0x07, 0xfd, 0x34, 0xbe, 0x3f, 0x42, 0xe7, 0xed, 0xf5, 0xff, 0x06, 0x00, 0x00,
	0xff, 0xff, 0x26, 0x5d, 0xe7, 0x2f, 0x40, 0x17, 0x00, 0x00,
}

func (x EnableStatus) String() string {
	s, ok := EnableStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ProtocolType) String() string {
	s, ok := ProtocolType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x State) String() string {
	s, ok := State_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DNSQueryType) String() string {
	s, ok := DNSQueryType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DNSErrorType) String() string {
	s, ok := DNSErrorType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *DDoSProfile) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DDoSProfile)
	if !ok {
		that2, ok := that.(DDoSProfile)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Dns.Equal(that1.Dns) {
		return false
	}
	if len(this.AllowRules) != len(that1.AllowRules) {
		return false
	}
	for i := range this.AllowRules {
		if !this.AllowRules[i].Equal(that1.AllowRules[i]) {
			return false
		}
	}
	return true
}
func (this *DNSDDoSVectors) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DNSDDoSVectors)
	if !ok {
		that2, ok := that.(DNSDDoSVectors)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NxDomainProfile.Equal(that1.NxDomainProfile) {
		return false
	}
	if !this.OversizedDnsProfile.Equal(that1.OversizedDnsProfile) {
		return false
	}
	if len(this.DnsFloodVectors) != len(that1.DnsFloodVectors) {
		return false
	}
	for i := range this.DnsFloodVectors {
		if !this.DnsFloodVectors[i].Equal(that1.DnsFloodVectors[i]) {
			return false
		}
	}
	if len(this.DnsErrorVectors) != len(that1.DnsErrorVectors) {
		return false
	}
	for i := range this.DnsErrorVectors {
		if !this.DnsErrorVectors[i].Equal(that1.DnsErrorVectors[i]) {
			return false
		}
	}
	return true
}
func (this *NxDomainVectors) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NxDomainVectors)
	if !ok {
		that2, ok := that.(NxDomainVectors)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if !this.VolumetricThresholds.Equal(that1.VolumetricThresholds) {
		return false
	}
	if !this.LearningParams.Equal(that1.LearningParams) {
		return false
	}
	if !this.BadActorsVolumetricThresholds.Equal(that1.BadActorsVolumetricThresholds) {
		return false
	}
	if !this.AttackedDestinationVolumetricThresholds.Equal(that1.AttackedDestinationVolumetricThresholds) {
		return false
	}
	if !this.ValidDomains.Equal(that1.ValidDomains) {
		return false
	}
	return true
}
func (this *OversizedDNSVectors) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OversizedDNSVectors)
	if !ok {
		that2, ok := that.(OversizedDNSVectors)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.MaxDnsSize != that1.MaxDnsSize {
		return false
	}
	if !this.VolumetricThresholds.Equal(that1.VolumetricThresholds) {
		return false
	}
	if !this.BadActorsVolumetricThresholds.Equal(that1.BadActorsVolumetricThresholds) {
		return false
	}
	if !this.AttackedDestinationVolumetricThresholds.Equal(that1.AttackedDestinationVolumetricThresholds) {
		return false
	}
	return true
}
func (this *DNSFloodVector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DNSFloodVector)
	if !ok {
		that2, ok := that.(DNSFloodVector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.QueryType != that1.QueryType {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if !this.VolumetricThresholds.Equal(that1.VolumetricThresholds) {
		return false
	}
	if !this.BadActorsVolumetricThresholds.Equal(that1.BadActorsVolumetricThresholds) {
		return false
	}
	if !this.AttackedDestinationVolumetricThresholds.Equal(that1.AttackedDestinationVolumetricThresholds) {
		return false
	}
	return true
}
func (this *DNSErrorVector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DNSErrorVector)
	if !ok {
		that2, ok := that.(DNSErrorVector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DnsErrorType != that1.DnsErrorType {
		return false
	}
	if this.DetectionThresholdPercentage != that1.DetectionThresholdPercentage {
		return false
	}
	if !this.DetectionThresholdEps.Equal(that1.DetectionThresholdEps) {
		return false
	}
	return true
}
func (this *AllowRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllowRule)
	if !ok {
		that2, ok := that.(AllowRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProtocolType != that1.ProtocolType {
		return false
	}
	if !this.MatchType.Equal(that1.MatchType) {
		return false
	}
	if this.EnableStatus != that1.EnableStatus {
		return false
	}
	return true
}
func (this *MatchRuleType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatchRuleType)
	if !ok {
		that2, ok := that.(MatchRuleType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *MatchRuleType_DestinationMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatchRuleType_DestinationMatch)
	if !ok {
		that2, ok := that.(MatchRuleType_DestinationMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DestinationMatch.Equal(that1.DestinationMatch) {
		return false
	}
	return true
}
func (this *MatchRuleType_SourceMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatchRuleType_SourceMatch)
	if !ok {
		that2, ok := that.(MatchRuleType_SourceMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SourceMatch.Equal(that1.SourceMatch) {
		return false
	}
	return true
}
func (this *MatchRuleType_AnyV4) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatchRuleType_AnyV4)
	if !ok {
		that2, ok := that.(MatchRuleType_AnyV4)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyV4.Equal(that1.AnyV4) {
		return false
	}
	return true
}
func (this *MatchRuleType_AnyV6) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatchRuleType_AnyV6)
	if !ok {
		that2, ok := that.(MatchRuleType_AnyV6)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyV6.Equal(that1.AnyV6) {
		return false
	}
	return true
}
func (this *MatchRuleType_AnyIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatchRuleType_AnyIp)
	if !ok {
		that2, ok := that.(MatchRuleType_AnyIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyIp.Equal(that1.AnyIp) {
		return false
	}
	return true
}
func (this *MatchIPAddressWithPort) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatchIPAddressWithPort)
	if !ok {
		that2, ok := that.(MatchIPAddressWithPort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	if !this.DestinationPort.Equal(that1.DestinationPort) {
		return false
	}
	return true
}
func (this *MatchIPAddressWithPort_Any) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatchIPAddressWithPort_Any)
	if !ok {
		that2, ok := that.(MatchIPAddressWithPort_Any)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Any.Equal(that1.Any) {
		return false
	}
	return true
}
func (this *MatchIPAddressWithPort_Address) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatchIPAddressWithPort_Address)
	if !ok {
		that2, ok := that.(MatchIPAddressWithPort_Address)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	return true
}
func (this *DestinationPort) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DestinationPort)
	if !ok {
		that2, ok := that.(DestinationPort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *DestinationPort_Any) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DestinationPort_Any)
	if !ok {
		that2, ok := that.(DestinationPort_Any)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Any.Equal(that1.Any) {
		return false
	}
	return true
}
func (this *DestinationPort_Port) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DestinationPort_Port)
	if !ok {
		that2, ok := that.(DestinationPort_Port)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	return true
}
func (this *NxDomainLearningParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NxDomainLearningParams)
	if !ok {
		that2, ok := that.(NxDomainLearningParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DnsNxDomainLearnPeriod != that1.DnsNxDomainLearnPeriod {
		return false
	}
	if this.DnsNxDomainRelearnPeriod != that1.DnsNxDomainRelearnPeriod {
		return false
	}
	if this.DnsNxDomainTrackerSize != that1.DnsNxDomainTrackerSize {
		return false
	}
	return true
}
func (this *ValidDomainsListConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValidDomainsListConfig)
	if !ok {
		that2, ok := that.(ValidDomainsListConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	return true
}
func (this *BadActorsVolumetricThresholds) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BadActorsVolumetricThresholds)
	if !ok {
		that2, ok := that.(BadActorsVolumetricThresholds)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PerSourceIpDetectionEps.Equal(that1.PerSourceIpDetectionEps) {
		return false
	}
	if !this.PerSourceIpLimitEps.Equal(that1.PerSourceIpLimitEps) {
		return false
	}
	return true
}
func (this *AttackedDestinationVolumetricThresholds) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AttackedDestinationVolumetricThresholds)
	if !ok {
		that2, ok := that.(AttackedDestinationVolumetricThresholds)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PerDstIpDetectionEps.Equal(that1.PerDstIpDetectionEps) {
		return false
	}
	if !this.PerDstIpLimitEps.Equal(that1.PerDstIpLimitEps) {
		return false
	}
	return true
}
func (this *VolumetricThresholds) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VolumetricThresholds)
	if !ok {
		that2, ok := that.(VolumetricThresholds)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DetectionThresholdPercentage != that1.DetectionThresholdPercentage {
		return false
	}
	if !this.DetectionThresholdEps.Equal(that1.DetectionThresholdEps) {
		return false
	}
	if !this.MitigationThresholdEps.Equal(that1.MitigationThresholdEps) {
		return false
	}
	return true
}
func (this *ThresholdEPS) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ThresholdEPS)
	if !ok {
		that2, ok := that.(ThresholdEPS)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *ThresholdEPS_Disable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ThresholdEPS_Disable)
	if !ok {
		that2, ok := that.(ThresholdEPS_Disable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Disable.Equal(that1.Disable) {
		return false
	}
	return true
}
func (this *ThresholdEPS_Value) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ThresholdEPS_Value)
	if !ok {
		that2, ok := that.(ThresholdEPS_Value)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *DDoSProfile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&global_config.DDoSProfile{")
	if this.Dns != nil {
		s = append(s, "Dns: "+fmt.Sprintf("%#v", this.Dns)+",\n")
	}
	if this.AllowRules != nil {
		s = append(s, "AllowRules: "+fmt.Sprintf("%#v", this.AllowRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DNSDDoSVectors) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&global_config.DNSDDoSVectors{")
	if this.NxDomainProfile != nil {
		s = append(s, "NxDomainProfile: "+fmt.Sprintf("%#v", this.NxDomainProfile)+",\n")
	}
	if this.OversizedDnsProfile != nil {
		s = append(s, "OversizedDnsProfile: "+fmt.Sprintf("%#v", this.OversizedDnsProfile)+",\n")
	}
	if this.DnsFloodVectors != nil {
		s = append(s, "DnsFloodVectors: "+fmt.Sprintf("%#v", this.DnsFloodVectors)+",\n")
	}
	if this.DnsErrorVectors != nil {
		s = append(s, "DnsErrorVectors: "+fmt.Sprintf("%#v", this.DnsErrorVectors)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NxDomainVectors) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&global_config.NxDomainVectors{")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	if this.VolumetricThresholds != nil {
		s = append(s, "VolumetricThresholds: "+fmt.Sprintf("%#v", this.VolumetricThresholds)+",\n")
	}
	if this.LearningParams != nil {
		s = append(s, "LearningParams: "+fmt.Sprintf("%#v", this.LearningParams)+",\n")
	}
	if this.BadActorsVolumetricThresholds != nil {
		s = append(s, "BadActorsVolumetricThresholds: "+fmt.Sprintf("%#v", this.BadActorsVolumetricThresholds)+",\n")
	}
	if this.AttackedDestinationVolumetricThresholds != nil {
		s = append(s, "AttackedDestinationVolumetricThresholds: "+fmt.Sprintf("%#v", this.AttackedDestinationVolumetricThresholds)+",\n")
	}
	if this.ValidDomains != nil {
		s = append(s, "ValidDomains: "+fmt.Sprintf("%#v", this.ValidDomains)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OversizedDNSVectors) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&global_config.OversizedDNSVectors{")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "MaxDnsSize: "+fmt.Sprintf("%#v", this.MaxDnsSize)+",\n")
	if this.VolumetricThresholds != nil {
		s = append(s, "VolumetricThresholds: "+fmt.Sprintf("%#v", this.VolumetricThresholds)+",\n")
	}
	if this.BadActorsVolumetricThresholds != nil {
		s = append(s, "BadActorsVolumetricThresholds: "+fmt.Sprintf("%#v", this.BadActorsVolumetricThresholds)+",\n")
	}
	if this.AttackedDestinationVolumetricThresholds != nil {
		s = append(s, "AttackedDestinationVolumetricThresholds: "+fmt.Sprintf("%#v", this.AttackedDestinationVolumetricThresholds)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DNSFloodVector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&global_config.DNSFloodVector{")
	s = append(s, "QueryType: "+fmt.Sprintf("%#v", this.QueryType)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	if this.VolumetricThresholds != nil {
		s = append(s, "VolumetricThresholds: "+fmt.Sprintf("%#v", this.VolumetricThresholds)+",\n")
	}
	if this.BadActorsVolumetricThresholds != nil {
		s = append(s, "BadActorsVolumetricThresholds: "+fmt.Sprintf("%#v", this.BadActorsVolumetricThresholds)+",\n")
	}
	if this.AttackedDestinationVolumetricThresholds != nil {
		s = append(s, "AttackedDestinationVolumetricThresholds: "+fmt.Sprintf("%#v", this.AttackedDestinationVolumetricThresholds)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DNSErrorVector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&global_config.DNSErrorVector{")
	s = append(s, "DnsErrorType: "+fmt.Sprintf("%#v", this.DnsErrorType)+",\n")
	s = append(s, "DetectionThresholdPercentage: "+fmt.Sprintf("%#v", this.DetectionThresholdPercentage)+",\n")
	if this.DetectionThresholdEps != nil {
		s = append(s, "DetectionThresholdEps: "+fmt.Sprintf("%#v", this.DetectionThresholdEps)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AllowRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&global_config.AllowRule{")
	s = append(s, "ProtocolType: "+fmt.Sprintf("%#v", this.ProtocolType)+",\n")
	if this.MatchType != nil {
		s = append(s, "MatchType: "+fmt.Sprintf("%#v", this.MatchType)+",\n")
	}
	s = append(s, "EnableStatus: "+fmt.Sprintf("%#v", this.EnableStatus)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MatchRuleType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&global_config.MatchRuleType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MatchRuleType_DestinationMatch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&global_config.MatchRuleType_DestinationMatch{` +
		`DestinationMatch:` + fmt.Sprintf("%#v", this.DestinationMatch) + `}`}, ", ")
	return s
}
func (this *MatchRuleType_SourceMatch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&global_config.MatchRuleType_SourceMatch{` +
		`SourceMatch:` + fmt.Sprintf("%#v", this.SourceMatch) + `}`}, ", ")
	return s
}
func (this *MatchRuleType_AnyV4) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&global_config.MatchRuleType_AnyV4{` +
		`AnyV4:` + fmt.Sprintf("%#v", this.AnyV4) + `}`}, ", ")
	return s
}
func (this *MatchRuleType_AnyV6) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&global_config.MatchRuleType_AnyV6{` +
		`AnyV6:` + fmt.Sprintf("%#v", this.AnyV6) + `}`}, ", ")
	return s
}
func (this *MatchRuleType_AnyIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&global_config.MatchRuleType_AnyIp{` +
		`AnyIp:` + fmt.Sprintf("%#v", this.AnyIp) + `}`}, ", ")
	return s
}
func (this *MatchIPAddressWithPort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&global_config.MatchIPAddressWithPort{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	if this.DestinationPort != nil {
		s = append(s, "DestinationPort: "+fmt.Sprintf("%#v", this.DestinationPort)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MatchIPAddressWithPort_Any) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&global_config.MatchIPAddressWithPort_Any{` +
		`Any:` + fmt.Sprintf("%#v", this.Any) + `}`}, ", ")
	return s
}
func (this *MatchIPAddressWithPort_Address) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&global_config.MatchIPAddressWithPort_Address{` +
		`Address:` + fmt.Sprintf("%#v", this.Address) + `}`}, ", ")
	return s
}
func (this *DestinationPort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&global_config.DestinationPort{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DestinationPort_Any) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&global_config.DestinationPort_Any{` +
		`Any:` + fmt.Sprintf("%#v", this.Any) + `}`}, ", ")
	return s
}
func (this *DestinationPort_Port) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&global_config.DestinationPort_Port{` +
		`Port:` + fmt.Sprintf("%#v", this.Port) + `}`}, ", ")
	return s
}
func (this *NxDomainLearningParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&global_config.NxDomainLearningParams{")
	s = append(s, "DnsNxDomainLearnPeriod: "+fmt.Sprintf("%#v", this.DnsNxDomainLearnPeriod)+",\n")
	s = append(s, "DnsNxDomainRelearnPeriod: "+fmt.Sprintf("%#v", this.DnsNxDomainRelearnPeriod)+",\n")
	s = append(s, "DnsNxDomainTrackerSize: "+fmt.Sprintf("%#v", this.DnsNxDomainTrackerSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ValidDomainsListConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&global_config.ValidDomainsListConfig{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BadActorsVolumetricThresholds) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&global_config.BadActorsVolumetricThresholds{")
	if this.PerSourceIpDetectionEps != nil {
		s = append(s, "PerSourceIpDetectionEps: "+fmt.Sprintf("%#v", this.PerSourceIpDetectionEps)+",\n")
	}
	if this.PerSourceIpLimitEps != nil {
		s = append(s, "PerSourceIpLimitEps: "+fmt.Sprintf("%#v", this.PerSourceIpLimitEps)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AttackedDestinationVolumetricThresholds) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&global_config.AttackedDestinationVolumetricThresholds{")
	if this.PerDstIpDetectionEps != nil {
		s = append(s, "PerDstIpDetectionEps: "+fmt.Sprintf("%#v", this.PerDstIpDetectionEps)+",\n")
	}
	if this.PerDstIpLimitEps != nil {
		s = append(s, "PerDstIpLimitEps: "+fmt.Sprintf("%#v", this.PerDstIpLimitEps)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VolumetricThresholds) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&global_config.VolumetricThresholds{")
	s = append(s, "DetectionThresholdPercentage: "+fmt.Sprintf("%#v", this.DetectionThresholdPercentage)+",\n")
	if this.DetectionThresholdEps != nil {
		s = append(s, "DetectionThresholdEps: "+fmt.Sprintf("%#v", this.DetectionThresholdEps)+",\n")
	}
	if this.MitigationThresholdEps != nil {
		s = append(s, "MitigationThresholdEps: "+fmt.Sprintf("%#v", this.MitigationThresholdEps)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ThresholdEPS) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&global_config.ThresholdEPS{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ThresholdEPS_Disable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&global_config.ThresholdEPS_Disable{` +
		`Disable:` + fmt.Sprintf("%#v", this.Disable) + `}`}, ", ")
	return s
}
func (this *ThresholdEPS_Value) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&global_config.ThresholdEPS_Value{` +
		`Value:` + fmt.Sprintf("%#v", this.Value) + `}`}, ", ")
	return s
}
func valueToGoStringDdosTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *DDoSProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DDoSProfile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DDoSProfile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AllowRules) > 0 {
		for iNdEx := len(m.AllowRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AllowRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDdosTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Dns != nil {
		{
			size, err := m.Dns.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DNSDDoSVectors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNSDDoSVectors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DNSDDoSVectors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DnsErrorVectors) > 0 {
		for iNdEx := len(m.DnsErrorVectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DnsErrorVectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDdosTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DnsFloodVectors) > 0 {
		for iNdEx := len(m.DnsFloodVectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DnsFloodVectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDdosTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.OversizedDnsProfile != nil {
		{
			size, err := m.OversizedDnsProfile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NxDomainProfile != nil {
		{
			size, err := m.NxDomainProfile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NxDomainVectors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NxDomainVectors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NxDomainVectors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidDomains != nil {
		{
			size, err := m.ValidDomains.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.AttackedDestinationVolumetricThresholds != nil {
		{
			size, err := m.AttackedDestinationVolumetricThresholds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.BadActorsVolumetricThresholds != nil {
		{
			size, err := m.BadActorsVolumetricThresholds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.LearningParams != nil {
		{
			size, err := m.LearningParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.VolumetricThresholds != nil {
		{
			size, err := m.VolumetricThresholds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.State != 0 {
		i = encodeVarintDdosTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OversizedDNSVectors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OversizedDNSVectors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OversizedDNSVectors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AttackedDestinationVolumetricThresholds != nil {
		{
			size, err := m.AttackedDestinationVolumetricThresholds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.BadActorsVolumetricThresholds != nil {
		{
			size, err := m.BadActorsVolumetricThresholds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.VolumetricThresholds != nil {
		{
			size, err := m.VolumetricThresholds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MaxDnsSize != 0 {
		i = encodeVarintDdosTypes(dAtA, i, uint64(m.MaxDnsSize))
		i--
		dAtA[i] = 0x10
	}
	if m.State != 0 {
		i = encodeVarintDdosTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DNSFloodVector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNSFloodVector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DNSFloodVector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AttackedDestinationVolumetricThresholds != nil {
		{
			size, err := m.AttackedDestinationVolumetricThresholds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.BadActorsVolumetricThresholds != nil {
		{
			size, err := m.BadActorsVolumetricThresholds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.VolumetricThresholds != nil {
		{
			size, err := m.VolumetricThresholds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintDdosTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.QueryType != 0 {
		i = encodeVarintDdosTypes(dAtA, i, uint64(m.QueryType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DNSErrorVector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNSErrorVector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DNSErrorVector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DetectionThresholdEps != nil {
		{
			size, err := m.DetectionThresholdEps.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.DetectionThresholdPercentage != 0 {
		i = encodeVarintDdosTypes(dAtA, i, uint64(m.DetectionThresholdPercentage))
		i--
		dAtA[i] = 0x10
	}
	if m.DnsErrorType != 0 {
		i = encodeVarintDdosTypes(dAtA, i, uint64(m.DnsErrorType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AllowRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllowRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllowRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableStatus != 0 {
		i = encodeVarintDdosTypes(dAtA, i, uint64(m.EnableStatus))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchType != nil {
		{
			size, err := m.MatchType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ProtocolType != 0 {
		i = encodeVarintDdosTypes(dAtA, i, uint64(m.ProtocolType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MatchRuleType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchRuleType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchRuleType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MatchRuleType_DestinationMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchRuleType_DestinationMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DestinationMatch != nil {
		{
			size, err := m.DestinationMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MatchRuleType_SourceMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchRuleType_SourceMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SourceMatch != nil {
		{
			size, err := m.SourceMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *MatchRuleType_AnyV4) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchRuleType_AnyV4) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyV4 != nil {
		{
			size, err := m.AnyV4.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *MatchRuleType_AnyV6) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchRuleType_AnyV6) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyV6 != nil {
		{
			size, err := m.AnyV6.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *MatchRuleType_AnyIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchRuleType_AnyIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyIp != nil {
		{
			size, err := m.AnyIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *MatchIPAddressWithPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchIPAddressWithPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchIPAddressWithPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DestinationPort != nil {
		{
			size, err := m.DestinationPort.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MatchIPAddressWithPort_Any) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchIPAddressWithPort_Any) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Any != nil {
		{
			size, err := m.Any.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MatchIPAddressWithPort_Address) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchIPAddressWithPort_Address) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Address)
	copy(dAtA[i:], m.Address)
	i = encodeVarintDdosTypes(dAtA, i, uint64(len(m.Address)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *DestinationPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DestinationPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DestinationPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DestinationPort_Any) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DestinationPort_Any) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Any != nil {
		{
			size, err := m.Any.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DestinationPort_Port) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DestinationPort_Port) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintDdosTypes(dAtA, i, uint64(m.Port))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *NxDomainLearningParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NxDomainLearningParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NxDomainLearningParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DnsNxDomainTrackerSize != 0 {
		i = encodeVarintDdosTypes(dAtA, i, uint64(m.DnsNxDomainTrackerSize))
		i--
		dAtA[i] = 0x18
	}
	if m.DnsNxDomainRelearnPeriod != 0 {
		i = encodeVarintDdosTypes(dAtA, i, uint64(m.DnsNxDomainRelearnPeriod))
		i--
		dAtA[i] = 0x10
	}
	if m.DnsNxDomainLearnPeriod != 0 {
		i = encodeVarintDdosTypes(dAtA, i, uint64(m.DnsNxDomainLearnPeriod))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidDomainsListConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidDomainsListConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidDomainsListConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for iNdEx := len(m.Domains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Domains[iNdEx])
			copy(dAtA[i:], m.Domains[iNdEx])
			i = encodeVarintDdosTypes(dAtA, i, uint64(len(m.Domains[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	return len(dAtA) - i, nil
}

func (m *BadActorsVolumetricThresholds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BadActorsVolumetricThresholds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BadActorsVolumetricThresholds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PerSourceIpLimitEps != nil {
		{
			size, err := m.PerSourceIpLimitEps.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PerSourceIpDetectionEps != nil {
		{
			size, err := m.PerSourceIpDetectionEps.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttackedDestinationVolumetricThresholds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttackedDestinationVolumetricThresholds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttackedDestinationVolumetricThresholds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PerDstIpLimitEps != nil {
		{
			size, err := m.PerDstIpLimitEps.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PerDstIpDetectionEps != nil {
		{
			size, err := m.PerDstIpDetectionEps.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VolumetricThresholds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumetricThresholds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VolumetricThresholds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MitigationThresholdEps != nil {
		{
			size, err := m.MitigationThresholdEps.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.DetectionThresholdEps != nil {
		{
			size, err := m.DetectionThresholdEps.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DetectionThresholdPercentage != 0 {
		i = encodeVarintDdosTypes(dAtA, i, uint64(m.DetectionThresholdPercentage))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ThresholdEPS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThresholdEPS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThresholdEPS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ThresholdEPS_Disable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThresholdEPS_Disable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Disable != nil {
		{
			size, err := m.Disable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDdosTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ThresholdEPS_Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThresholdEPS_Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintDdosTypes(dAtA, i, uint64(m.Value))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func encodeVarintDdosTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovDdosTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DDoSProfile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dns != nil {
		l = m.Dns.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	if len(m.AllowRules) > 0 {
		for _, e := range m.AllowRules {
			l = e.Size()
			n += 1 + l + sovDdosTypes(uint64(l))
		}
	}
	return n
}

func (m *DNSDDoSVectors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NxDomainProfile != nil {
		l = m.NxDomainProfile.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	if m.OversizedDnsProfile != nil {
		l = m.OversizedDnsProfile.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	if len(m.DnsFloodVectors) > 0 {
		for _, e := range m.DnsFloodVectors {
			l = e.Size()
			n += 1 + l + sovDdosTypes(uint64(l))
		}
	}
	if len(m.DnsErrorVectors) > 0 {
		for _, e := range m.DnsErrorVectors {
			l = e.Size()
			n += 1 + l + sovDdosTypes(uint64(l))
		}
	}
	return n
}

func (m *NxDomainVectors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovDdosTypes(uint64(m.State))
	}
	if m.VolumetricThresholds != nil {
		l = m.VolumetricThresholds.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	if m.LearningParams != nil {
		l = m.LearningParams.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	if m.BadActorsVolumetricThresholds != nil {
		l = m.BadActorsVolumetricThresholds.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	if m.AttackedDestinationVolumetricThresholds != nil {
		l = m.AttackedDestinationVolumetricThresholds.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	if m.ValidDomains != nil {
		l = m.ValidDomains.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	return n
}

func (m *OversizedDNSVectors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovDdosTypes(uint64(m.State))
	}
	if m.MaxDnsSize != 0 {
		n += 1 + sovDdosTypes(uint64(m.MaxDnsSize))
	}
	if m.VolumetricThresholds != nil {
		l = m.VolumetricThresholds.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	if m.BadActorsVolumetricThresholds != nil {
		l = m.BadActorsVolumetricThresholds.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	if m.AttackedDestinationVolumetricThresholds != nil {
		l = m.AttackedDestinationVolumetricThresholds.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	return n
}

func (m *DNSFloodVector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryType != 0 {
		n += 1 + sovDdosTypes(uint64(m.QueryType))
	}
	if m.State != 0 {
		n += 1 + sovDdosTypes(uint64(m.State))
	}
	if m.VolumetricThresholds != nil {
		l = m.VolumetricThresholds.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	if m.BadActorsVolumetricThresholds != nil {
		l = m.BadActorsVolumetricThresholds.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	if m.AttackedDestinationVolumetricThresholds != nil {
		l = m.AttackedDestinationVolumetricThresholds.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	return n
}

func (m *DNSErrorVector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DnsErrorType != 0 {
		n += 1 + sovDdosTypes(uint64(m.DnsErrorType))
	}
	if m.DetectionThresholdPercentage != 0 {
		n += 1 + sovDdosTypes(uint64(m.DetectionThresholdPercentage))
	}
	if m.DetectionThresholdEps != nil {
		l = m.DetectionThresholdEps.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	return n
}

func (m *AllowRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProtocolType != 0 {
		n += 1 + sovDdosTypes(uint64(m.ProtocolType))
	}
	if m.MatchType != nil {
		l = m.MatchType.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	if m.EnableStatus != 0 {
		n += 1 + sovDdosTypes(uint64(m.EnableStatus))
	}
	return n
}

func (m *MatchRuleType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *MatchRuleType_DestinationMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DestinationMatch != nil {
		l = m.DestinationMatch.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	return n
}
func (m *MatchRuleType_SourceMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SourceMatch != nil {
		l = m.SourceMatch.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	return n
}
func (m *MatchRuleType_AnyV4) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyV4 != nil {
		l = m.AnyV4.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	return n
}
func (m *MatchRuleType_AnyV6) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyV6 != nil {
		l = m.AnyV6.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	return n
}
func (m *MatchRuleType_AnyIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyIp != nil {
		l = m.AnyIp.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	return n
}
func (m *MatchIPAddressWithPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	if m.DestinationPort != nil {
		l = m.DestinationPort.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	return n
}

func (m *MatchIPAddressWithPort_Any) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Any != nil {
		l = m.Any.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	return n
}
func (m *MatchIPAddressWithPort_Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	n += 1 + l + sovDdosTypes(uint64(l))
	return n
}
func (m *DestinationPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *DestinationPort_Any) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Any != nil {
		l = m.Any.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	return n
}
func (m *DestinationPort_Port) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovDdosTypes(uint64(m.Port))
	return n
}
func (m *NxDomainLearningParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DnsNxDomainLearnPeriod != 0 {
		n += 1 + sovDdosTypes(uint64(m.DnsNxDomainLearnPeriod))
	}
	if m.DnsNxDomainRelearnPeriod != 0 {
		n += 1 + sovDdosTypes(uint64(m.DnsNxDomainRelearnPeriod))
	}
	if m.DnsNxDomainTrackerSize != 0 {
		n += 1 + sovDdosTypes(uint64(m.DnsNxDomainTrackerSize))
	}
	return n
}

func (m *ValidDomainsListConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovDdosTypes(uint64(l))
		}
	}
	return n
}

func (m *BadActorsVolumetricThresholds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PerSourceIpDetectionEps != nil {
		l = m.PerSourceIpDetectionEps.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	if m.PerSourceIpLimitEps != nil {
		l = m.PerSourceIpLimitEps.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	return n
}

func (m *AttackedDestinationVolumetricThresholds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PerDstIpDetectionEps != nil {
		l = m.PerDstIpDetectionEps.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	if m.PerDstIpLimitEps != nil {
		l = m.PerDstIpLimitEps.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	return n
}

func (m *VolumetricThresholds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DetectionThresholdPercentage != 0 {
		n += 1 + sovDdosTypes(uint64(m.DetectionThresholdPercentage))
	}
	if m.DetectionThresholdEps != nil {
		l = m.DetectionThresholdEps.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	if m.MitigationThresholdEps != nil {
		l = m.MitigationThresholdEps.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	return n
}

func (m *ThresholdEPS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *ThresholdEPS_Disable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Disable != nil {
		l = m.Disable.Size()
		n += 1 + l + sovDdosTypes(uint64(l))
	}
	return n
}
func (m *ThresholdEPS_Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovDdosTypes(uint64(m.Value))
	return n
}

func sovDdosTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDdosTypes(x uint64) (n int) {
	return sovDdosTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *DDoSProfile) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAllowRules := "[]*AllowRule{"
	for _, f := range this.AllowRules {
		repeatedStringForAllowRules += strings.Replace(f.String(), "AllowRule", "AllowRule", 1) + ","
	}
	repeatedStringForAllowRules += "}"
	s := strings.Join([]string{`&DDoSProfile{`,
		`Dns:` + strings.Replace(this.Dns.String(), "DNSDDoSVectors", "DNSDDoSVectors", 1) + `,`,
		`AllowRules:` + repeatedStringForAllowRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *DNSDDoSVectors) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDnsFloodVectors := "[]*DNSFloodVector{"
	for _, f := range this.DnsFloodVectors {
		repeatedStringForDnsFloodVectors += strings.Replace(f.String(), "DNSFloodVector", "DNSFloodVector", 1) + ","
	}
	repeatedStringForDnsFloodVectors += "}"
	repeatedStringForDnsErrorVectors := "[]*DNSErrorVector{"
	for _, f := range this.DnsErrorVectors {
		repeatedStringForDnsErrorVectors += strings.Replace(f.String(), "DNSErrorVector", "DNSErrorVector", 1) + ","
	}
	repeatedStringForDnsErrorVectors += "}"
	s := strings.Join([]string{`&DNSDDoSVectors{`,
		`NxDomainProfile:` + strings.Replace(this.NxDomainProfile.String(), "NxDomainVectors", "NxDomainVectors", 1) + `,`,
		`OversizedDnsProfile:` + strings.Replace(this.OversizedDnsProfile.String(), "OversizedDNSVectors", "OversizedDNSVectors", 1) + `,`,
		`DnsFloodVectors:` + repeatedStringForDnsFloodVectors + `,`,
		`DnsErrorVectors:` + repeatedStringForDnsErrorVectors + `,`,
		`}`,
	}, "")
	return s
}
func (this *NxDomainVectors) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NxDomainVectors{`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`VolumetricThresholds:` + strings.Replace(this.VolumetricThresholds.String(), "VolumetricThresholds", "VolumetricThresholds", 1) + `,`,
		`LearningParams:` + strings.Replace(this.LearningParams.String(), "NxDomainLearningParams", "NxDomainLearningParams", 1) + `,`,
		`BadActorsVolumetricThresholds:` + strings.Replace(this.BadActorsVolumetricThresholds.String(), "BadActorsVolumetricThresholds", "BadActorsVolumetricThresholds", 1) + `,`,
		`AttackedDestinationVolumetricThresholds:` + strings.Replace(this.AttackedDestinationVolumetricThresholds.String(), "AttackedDestinationVolumetricThresholds", "AttackedDestinationVolumetricThresholds", 1) + `,`,
		`ValidDomains:` + strings.Replace(this.ValidDomains.String(), "ValidDomainsListConfig", "ValidDomainsListConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OversizedDNSVectors) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OversizedDNSVectors{`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`MaxDnsSize:` + fmt.Sprintf("%v", this.MaxDnsSize) + `,`,
		`VolumetricThresholds:` + strings.Replace(this.VolumetricThresholds.String(), "VolumetricThresholds", "VolumetricThresholds", 1) + `,`,
		`BadActorsVolumetricThresholds:` + strings.Replace(this.BadActorsVolumetricThresholds.String(), "BadActorsVolumetricThresholds", "BadActorsVolumetricThresholds", 1) + `,`,
		`AttackedDestinationVolumetricThresholds:` + strings.Replace(this.AttackedDestinationVolumetricThresholds.String(), "AttackedDestinationVolumetricThresholds", "AttackedDestinationVolumetricThresholds", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DNSFloodVector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DNSFloodVector{`,
		`QueryType:` + fmt.Sprintf("%v", this.QueryType) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`VolumetricThresholds:` + strings.Replace(this.VolumetricThresholds.String(), "VolumetricThresholds", "VolumetricThresholds", 1) + `,`,
		`BadActorsVolumetricThresholds:` + strings.Replace(this.BadActorsVolumetricThresholds.String(), "BadActorsVolumetricThresholds", "BadActorsVolumetricThresholds", 1) + `,`,
		`AttackedDestinationVolumetricThresholds:` + strings.Replace(this.AttackedDestinationVolumetricThresholds.String(), "AttackedDestinationVolumetricThresholds", "AttackedDestinationVolumetricThresholds", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DNSErrorVector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DNSErrorVector{`,
		`DnsErrorType:` + fmt.Sprintf("%v", this.DnsErrorType) + `,`,
		`DetectionThresholdPercentage:` + fmt.Sprintf("%v", this.DetectionThresholdPercentage) + `,`,
		`DetectionThresholdEps:` + strings.Replace(this.DetectionThresholdEps.String(), "ThresholdEPS", "ThresholdEPS", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AllowRule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AllowRule{`,
		`ProtocolType:` + fmt.Sprintf("%v", this.ProtocolType) + `,`,
		`MatchType:` + strings.Replace(this.MatchType.String(), "MatchRuleType", "MatchRuleType", 1) + `,`,
		`EnableStatus:` + fmt.Sprintf("%v", this.EnableStatus) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatchRuleType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatchRuleType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatchRuleType_DestinationMatch) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatchRuleType_DestinationMatch{`,
		`DestinationMatch:` + strings.Replace(fmt.Sprintf("%v", this.DestinationMatch), "MatchIPAddressWithPort", "MatchIPAddressWithPort", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatchRuleType_SourceMatch) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatchRuleType_SourceMatch{`,
		`SourceMatch:` + strings.Replace(fmt.Sprintf("%v", this.SourceMatch), "MatchIPAddressWithPort", "MatchIPAddressWithPort", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatchRuleType_AnyV4) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatchRuleType_AnyV4{`,
		`AnyV4:` + strings.Replace(fmt.Sprintf("%v", this.AnyV4), "DestinationPort", "DestinationPort", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatchRuleType_AnyV6) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatchRuleType_AnyV6{`,
		`AnyV6:` + strings.Replace(fmt.Sprintf("%v", this.AnyV6), "DestinationPort", "DestinationPort", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatchRuleType_AnyIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatchRuleType_AnyIp{`,
		`AnyIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyIp), "DestinationPort", "DestinationPort", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatchIPAddressWithPort) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatchIPAddressWithPort{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`DestinationPort:` + strings.Replace(this.DestinationPort.String(), "DestinationPort", "DestinationPort", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatchIPAddressWithPort_Any) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatchIPAddressWithPort_Any{`,
		`Any:` + strings.Replace(fmt.Sprintf("%v", this.Any), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatchIPAddressWithPort_Address) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatchIPAddressWithPort_Address{`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DestinationPort) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DestinationPort{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DestinationPort_Any) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DestinationPort_Any{`,
		`Any:` + strings.Replace(fmt.Sprintf("%v", this.Any), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DestinationPort_Port) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DestinationPort_Port{`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NxDomainLearningParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NxDomainLearningParams{`,
		`DnsNxDomainLearnPeriod:` + fmt.Sprintf("%v", this.DnsNxDomainLearnPeriod) + `,`,
		`DnsNxDomainRelearnPeriod:` + fmt.Sprintf("%v", this.DnsNxDomainRelearnPeriod) + `,`,
		`DnsNxDomainTrackerSize:` + fmt.Sprintf("%v", this.DnsNxDomainTrackerSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ValidDomainsListConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ValidDomainsListConfig{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BadActorsVolumetricThresholds) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BadActorsVolumetricThresholds{`,
		`PerSourceIpDetectionEps:` + strings.Replace(this.PerSourceIpDetectionEps.String(), "ThresholdEPS", "ThresholdEPS", 1) + `,`,
		`PerSourceIpLimitEps:` + strings.Replace(this.PerSourceIpLimitEps.String(), "ThresholdEPS", "ThresholdEPS", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AttackedDestinationVolumetricThresholds) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AttackedDestinationVolumetricThresholds{`,
		`PerDstIpDetectionEps:` + strings.Replace(this.PerDstIpDetectionEps.String(), "ThresholdEPS", "ThresholdEPS", 1) + `,`,
		`PerDstIpLimitEps:` + strings.Replace(this.PerDstIpLimitEps.String(), "ThresholdEPS", "ThresholdEPS", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolumetricThresholds) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolumetricThresholds{`,
		`DetectionThresholdPercentage:` + fmt.Sprintf("%v", this.DetectionThresholdPercentage) + `,`,
		`DetectionThresholdEps:` + strings.Replace(this.DetectionThresholdEps.String(), "ThresholdEPS", "ThresholdEPS", 1) + `,`,
		`MitigationThresholdEps:` + strings.Replace(this.MitigationThresholdEps.String(), "ThresholdEPS", "ThresholdEPS", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ThresholdEPS) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ThresholdEPS{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ThresholdEPS_Disable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ThresholdEPS_Disable{`,
		`Disable:` + strings.Replace(fmt.Sprintf("%v", this.Disable), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ThresholdEPS_Value) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ThresholdEPS_Value{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringDdosTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *DDoSProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdosTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DDoSProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DDoSProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dns == nil {
				m.Dns = &DNSDDoSVectors{}
			}
			if err := m.Dns.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowRules = append(m.AllowRules, &AllowRule{})
			if err := m.AllowRules[len(m.AllowRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDdosTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSDDoSVectors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdosTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSDDoSVectors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSDDoSVectors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NxDomainProfile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NxDomainProfile == nil {
				m.NxDomainProfile = &NxDomainVectors{}
			}
			if err := m.NxDomainProfile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OversizedDnsProfile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OversizedDnsProfile == nil {
				m.OversizedDnsProfile = &OversizedDNSVectors{}
			}
			if err := m.OversizedDnsProfile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsFloodVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsFloodVectors = append(m.DnsFloodVectors, &DNSFloodVector{})
			if err := m.DnsFloodVectors[len(m.DnsFloodVectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsErrorVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsErrorVectors = append(m.DnsErrorVectors, &DNSErrorVector{})
			if err := m.DnsErrorVectors[len(m.DnsErrorVectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDdosTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NxDomainVectors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdosTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NxDomainVectors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NxDomainVectors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumetricThresholds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumetricThresholds == nil {
				m.VolumetricThresholds = &VolumetricThresholds{}
			}
			if err := m.VolumetricThresholds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearningParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LearningParams == nil {
				m.LearningParams = &NxDomainLearningParams{}
			}
			if err := m.LearningParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadActorsVolumetricThresholds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadActorsVolumetricThresholds == nil {
				m.BadActorsVolumetricThresholds = &BadActorsVolumetricThresholds{}
			}
			if err := m.BadActorsVolumetricThresholds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackedDestinationVolumetricThresholds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttackedDestinationVolumetricThresholds == nil {
				m.AttackedDestinationVolumetricThresholds = &AttackedDestinationVolumetricThresholds{}
			}
			if err := m.AttackedDestinationVolumetricThresholds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidDomains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidDomains == nil {
				m.ValidDomains = &ValidDomainsListConfig{}
			}
			if err := m.ValidDomains.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDdosTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OversizedDNSVectors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdosTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OversizedDNSVectors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OversizedDNSVectors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDnsSize", wireType)
			}
			m.MaxDnsSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDnsSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumetricThresholds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumetricThresholds == nil {
				m.VolumetricThresholds = &VolumetricThresholds{}
			}
			if err := m.VolumetricThresholds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadActorsVolumetricThresholds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadActorsVolumetricThresholds == nil {
				m.BadActorsVolumetricThresholds = &BadActorsVolumetricThresholds{}
			}
			if err := m.BadActorsVolumetricThresholds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackedDestinationVolumetricThresholds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttackedDestinationVolumetricThresholds == nil {
				m.AttackedDestinationVolumetricThresholds = &AttackedDestinationVolumetricThresholds{}
			}
			if err := m.AttackedDestinationVolumetricThresholds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDdosTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSFloodVector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdosTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSFloodVector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSFloodVector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryType", wireType)
			}
			m.QueryType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueryType |= DNSQueryType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumetricThresholds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumetricThresholds == nil {
				m.VolumetricThresholds = &VolumetricThresholds{}
			}
			if err := m.VolumetricThresholds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadActorsVolumetricThresholds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadActorsVolumetricThresholds == nil {
				m.BadActorsVolumetricThresholds = &BadActorsVolumetricThresholds{}
			}
			if err := m.BadActorsVolumetricThresholds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackedDestinationVolumetricThresholds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttackedDestinationVolumetricThresholds == nil {
				m.AttackedDestinationVolumetricThresholds = &AttackedDestinationVolumetricThresholds{}
			}
			if err := m.AttackedDestinationVolumetricThresholds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDdosTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSErrorVector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdosTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSErrorVector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSErrorVector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsErrorType", wireType)
			}
			m.DnsErrorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnsErrorType |= DNSErrorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectionThresholdPercentage", wireType)
			}
			m.DetectionThresholdPercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DetectionThresholdPercentage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectionThresholdEps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DetectionThresholdEps == nil {
				m.DetectionThresholdEps = &ThresholdEPS{}
			}
			if err := m.DetectionThresholdEps.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDdosTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllowRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdosTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllowRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllowRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolType", wireType)
			}
			m.ProtocolType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolType |= ProtocolType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatchType == nil {
				m.MatchType = &MatchRuleType{}
			}
			if err := m.MatchType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableStatus", wireType)
			}
			m.EnableStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnableStatus |= EnableStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDdosTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchRuleType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdosTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchRuleType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchRuleType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatchIPAddressWithPort{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &MatchRuleType_DestinationMatch{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatchIPAddressWithPort{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &MatchRuleType_SourceMatch{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyV4", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DestinationPort{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &MatchRuleType_AnyV4{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyV6", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DestinationPort{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &MatchRuleType_AnyV6{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DestinationPort{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &MatchRuleType_AnyIp{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDdosTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchIPAddressWithPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdosTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchIPAddressWithPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchIPAddressWithPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Any", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &MatchIPAddressWithPort_Any{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Choice = &MatchIPAddressWithPort_Address{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestinationPort == nil {
				m.DestinationPort = &DestinationPort{}
			}
			if err := m.DestinationPort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDdosTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DestinationPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdosTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DestinationPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DestinationPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Any", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &DestinationPort_Any{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Choice = &DestinationPort_Port{v}
		default:
			iNdEx = preIndex
			skippy, err := skipDdosTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NxDomainLearningParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdosTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NxDomainLearningParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NxDomainLearningParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsNxDomainLearnPeriod", wireType)
			}
			m.DnsNxDomainLearnPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnsNxDomainLearnPeriod |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsNxDomainRelearnPeriod", wireType)
			}
			m.DnsNxDomainRelearnPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnsNxDomainRelearnPeriod |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsNxDomainTrackerSize", wireType)
			}
			m.DnsNxDomainTrackerSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnsNxDomainTrackerSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDdosTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidDomainsListConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdosTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidDomainsListConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidDomainsListConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDdosTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BadActorsVolumetricThresholds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdosTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BadActorsVolumetricThresholds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BadActorsVolumetricThresholds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerSourceIpDetectionEps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerSourceIpDetectionEps == nil {
				m.PerSourceIpDetectionEps = &ThresholdEPS{}
			}
			if err := m.PerSourceIpDetectionEps.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerSourceIpLimitEps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerSourceIpLimitEps == nil {
				m.PerSourceIpLimitEps = &ThresholdEPS{}
			}
			if err := m.PerSourceIpLimitEps.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDdosTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttackedDestinationVolumetricThresholds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdosTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttackedDestinationVolumetricThresholds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttackedDestinationVolumetricThresholds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerDstIpDetectionEps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerDstIpDetectionEps == nil {
				m.PerDstIpDetectionEps = &ThresholdEPS{}
			}
			if err := m.PerDstIpDetectionEps.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerDstIpLimitEps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerDstIpLimitEps == nil {
				m.PerDstIpLimitEps = &ThresholdEPS{}
			}
			if err := m.PerDstIpLimitEps.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDdosTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumetricThresholds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdosTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumetricThresholds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumetricThresholds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectionThresholdPercentage", wireType)
			}
			m.DetectionThresholdPercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DetectionThresholdPercentage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectionThresholdEps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DetectionThresholdEps == nil {
				m.DetectionThresholdEps = &ThresholdEPS{}
			}
			if err := m.DetectionThresholdEps.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MitigationThresholdEps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MitigationThresholdEps == nil {
				m.MitigationThresholdEps = &ThresholdEPS{}
			}
			if err := m.MitigationThresholdEps.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDdosTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThresholdEPS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdosTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThresholdEPS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThresholdEPS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdosTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &ThresholdEPS_Disable{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Choice = &ThresholdEPS_Value{v}
		default:
			iNdEx = preIndex
			skippy, err := skipDdosTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdosTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDdosTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDdosTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDdosTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDdosTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDdosTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDdosTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDdosTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDdosTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDdosTypes = fmt.Errorf("proto: unexpected end of group")
)
