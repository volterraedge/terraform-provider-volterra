// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package stored_object

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CreateObjectRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateObjectRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateObjectRequest) String() string {
	if m == nil {
		return ""
	}
	copy := m.DeepCopy()
	copy.Redact(context.Background())
	return copy.string()
}

func (m *CreateObjectRequest) GoString() string {
	copy := m.DeepCopy()
	copy.Redact(context.Background())
	return copy.goString()
}

// Redact squashes sensitive info in m (in-place)
func (m *CreateObjectRequest) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	switch x := m.Contents.(type) {
	case *CreateObjectRequest_StringValue:
		x.StringValue = ""

	case *CreateObjectRequest_BytesValue:
		x.BytesValue = []byte{}

	}

	return nil
}

func (m *CreateObjectRequest) DeepCopy() *CreateObjectRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateObjectRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateObjectRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateObjectRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateObjectRequestValidator().Validate(ctx, m, opts...)
}

type ValidateCreateObjectRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateObjectRequest) ContentsStringValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_StringValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for string_value")
	}
	return oValidatorFn_StringValue, nil
}
func (v *ValidateCreateObjectRequest) ContentsBytesValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_BytesValue, err := db.NewBytesValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bytes_value")
	}
	return oValidatorFn_BytesValue, nil
}

func (v *ValidateCreateObjectRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateCreateObjectRequest) ObjectTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for object_type")
	}

	return validatorFn, nil
}

func (v *ValidateCreateObjectRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateCreateObjectRequest) ContentFormatValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for content_format")
	}

	return validatorFn, nil
}

func (v *ValidateCreateObjectRequest) DescriptionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for description")
	}

	return validatorFn, nil
}

func (v *ValidateCreateObjectRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateObjectRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateObjectRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["content_format"]; exists {

		vOpts := append(opts, db.WithValidateField("content_format"))
		if err := fv(ctx, m.GetContentFormat(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetContents().(type) {
	case *CreateObjectRequest_StringValue:
		if fv, exists := v.FldValidators["contents.string_value"]; exists {
			val := m.GetContents().(*CreateObjectRequest_StringValue).StringValue
			vOpts := append(opts,
				db.WithValidateField("contents"),
				db.WithValidateField("string_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateObjectRequest_BytesValue:
		if fv, exists := v.FldValidators["contents.bytes_value"]; exists {
			val := m.GetContents().(*CreateObjectRequest_BytesValue).BytesValue
			vOpts := append(opts,
				db.WithValidateField("contents"),
				db.WithValidateField("bytes_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetObjectAttributes().(type) {
	case *CreateObjectRequest_NoAttributes:
		if fv, exists := v.FldValidators["object_attributes.no_attributes"]; exists {
			val := m.GetObjectAttributes().(*CreateObjectRequest_NoAttributes).NoAttributes
			vOpts := append(opts,
				db.WithValidateField("object_attributes"),
				db.WithValidateField("no_attributes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateObjectRequest_MobileSdk:
		if fv, exists := v.FldValidators["object_attributes.mobile_sdk"]; exists {
			val := m.GetObjectAttributes().(*CreateObjectRequest_MobileSdk).MobileSdk
			vOpts := append(opts,
				db.WithValidateField("object_attributes"),
				db.WithValidateField("mobile_sdk"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateObjectRequest_MobileIntegrator:
		if fv, exists := v.FldValidators["object_attributes.mobile_integrator"]; exists {
			val := m.GetObjectAttributes().(*CreateObjectRequest_MobileIntegrator).MobileIntegrator
			vOpts := append(opts,
				db.WithValidateField("object_attributes"),
				db.WithValidateField("mobile_integrator"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateObjectRequest_MobileAppShield:
		if fv, exists := v.FldValidators["object_attributes.mobile_app_shield"]; exists {
			val := m.GetObjectAttributes().(*CreateObjectRequest_MobileAppShield).MobileAppShield
			vOpts := append(opts,
				db.WithValidateField("object_attributes"),
				db.WithValidateField("mobile_app_shield"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["object_type"]; exists {

		vOpts := append(opts, db.WithValidateField("object_type"))
		if err := fv(ctx, m.GetObjectType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateObjectRequestValidator = func() *ValidateCreateObjectRequest {
	v := &ValidateCreateObjectRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhContentsStringValue := v.ContentsStringValueValidationRuleHandler
	rulesContentsStringValue := map[string]string{
		"ves.io.schema.rules.string.max_len": "5242880",
	}
	vFnMap["contents.string_value"], err = vrhContentsStringValue(rulesContentsStringValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CreateObjectRequest.contents_string_value: %s", err)
		panic(errMsg)
	}
	vrhContentsBytesValue := v.ContentsBytesValueValidationRuleHandler
	rulesContentsBytesValue := map[string]string{
		"ves.io.schema.rules.bytes.max_len": "5242880",
	}
	vFnMap["contents.bytes_value"], err = vrhContentsBytesValue(rulesContentsBytesValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CreateObjectRequest.contents_bytes_value: %s", err)
		panic(errMsg)
	}

	v.FldValidators["contents.string_value"] = vFnMap["contents.string_value"]
	v.FldValidators["contents.bytes_value"] = vFnMap["contents.bytes_value"]

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateObjectRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhObjectType := v.ObjectTypeValidationRuleHandler
	rulesObjectType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"swagger\", \"generic\", \"big-object\", \"mobile-sdk\", \"mobile-integrator\", \"mobile-app-shield\"]",
	}
	vFn, err = vrhObjectType(rulesObjectType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateObjectRequest.object_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["object_type"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required":       "true",
		"ves.io.schema.rules.string.max_len":         "512",
		"ves.io.schema.rules.string.min_len":         "1",
		"ves.io.schema.rules.string.ves_object_name": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateObjectRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhContentFormat := v.ContentFormatValidationRuleHandler
	rulesContentFormat := map[string]string{
		"ves.io.schema.rules.string.in": "[\"\", \"json\", \"yaml\", \"txt\", \"bin\"]",
	}
	vFn, err = vrhContentFormat(rulesContentFormat)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateObjectRequest.content_format: %s", err)
		panic(errMsg)
	}
	v.FldValidators["content_format"] = vFn

	vrhDescription := v.DescriptionValidationRuleHandler
	rulesDescription := map[string]string{
		"ves.io.schema.rules.string.max_len": "512",
	}
	vFn, err = vrhDescription(rulesDescription)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateObjectRequest.description: %s", err)
		panic(errMsg)
	}
	v.FldValidators["description"] = vFn

	v.FldValidators["object_attributes.mobile_sdk"] = MobileSDKAttributesValidator().Validate
	v.FldValidators["object_attributes.mobile_integrator"] = MobileIntegratorAttributesValidator().Validate
	v.FldValidators["object_attributes.mobile_app_shield"] = MobileAppShieldAttributesValidator().Validate

	return v
}()

func CreateObjectRequestValidator() db.Validator {
	return DefaultCreateObjectRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateObjectResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateObjectResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateObjectResponse) DeepCopy() *CreateObjectResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateObjectResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateObjectResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateObjectResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateObjectResponseValidator().Validate(ctx, m, opts...)
}

type ValidateCreateObjectResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateObjectResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateObjectResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateObjectResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAdditionalInfo().(type) {
	case *CreateObjectResponse_NoAdditionalInfo:
		if fv, exists := v.FldValidators["additional_info.no_additional_info"]; exists {
			val := m.GetAdditionalInfo().(*CreateObjectResponse_NoAdditionalInfo).NoAdditionalInfo
			vOpts := append(opts,
				db.WithValidateField("additional_info"),
				db.WithValidateField("no_additional_info"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateObjectResponse_PresignedUrl:
		if fv, exists := v.FldValidators["additional_info.presigned_url"]; exists {
			val := m.GetAdditionalInfo().(*CreateObjectResponse_PresignedUrl).PresignedUrl
			vOpts := append(opts,
				db.WithValidateField("additional_info"),
				db.WithValidateField("presigned_url"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateObjectResponseValidator = func() *ValidateCreateObjectResponse {
	v := &ValidateCreateObjectResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["metadata"] = StoredObjectDescriptorValidator().Validate

	return v
}()

func CreateObjectResponseValidator() db.Validator {
	return DefaultCreateObjectResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *DeleteObjectRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeleteObjectRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeleteObjectRequest) DeepCopy() *DeleteObjectRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeleteObjectRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeleteObjectRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeleteObjectRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeleteObjectRequestValidator().Validate(ctx, m, opts...)
}

type ValidateDeleteObjectRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeleteObjectRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateDeleteObjectRequest) ObjectTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for object_type")
	}

	return validatorFn, nil
}

func (v *ValidateDeleteObjectRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateDeleteObjectRequest) VersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for version")
	}

	return validatorFn, nil
}

func (v *ValidateDeleteObjectRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeleteObjectRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeleteObjectRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["force_delete"]; exists {

		vOpts := append(opts, db.WithValidateField("force_delete"))
		if err := fv(ctx, m.GetForceDelete(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["object_type"]; exists {

		vOpts := append(opts, db.WithValidateField("object_type"))
		if err := fv(ctx, m.GetObjectType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeleteObjectRequestValidator = func() *ValidateDeleteObjectRequest {
	v := &ValidateDeleteObjectRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DeleteObjectRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhObjectType := v.ObjectTypeValidationRuleHandler
	rulesObjectType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"swagger\", \"generic\", \"big-object\", \"mobile-sdk\", \"mobile-integrator\", \"mobile-app-shield\"]",
	}
	vFn, err = vrhObjectType(rulesObjectType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DeleteObjectRequest.object_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["object_type"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required":       "true",
		"ves.io.schema.rules.string.max_len":         "512",
		"ves.io.schema.rules.string.min_len":         "1",
		"ves.io.schema.rules.string.ves_object_name": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DeleteObjectRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhVersion := v.VersionValidationRuleHandler
	rulesVersion := map[string]string{
		"ves.io.schema.rules.string.pattern": "^(v|V)[0-9]+(-[0-9]{2}){3}$|^$",
	}
	vFn, err = vrhVersion(rulesVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DeleteObjectRequest.version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["version"] = vFn

	return v
}()

func DeleteObjectRequestValidator() db.Validator {
	return DefaultDeleteObjectRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *DeleteObjectResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeleteObjectResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeleteObjectResponse) DeepCopy() *DeleteObjectResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeleteObjectResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeleteObjectResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeleteObjectResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeleteObjectResponseValidator().Validate(ctx, m, opts...)
}

type ValidateDeleteObjectResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeleteObjectResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeleteObjectResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeleteObjectResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["deleted_objects"]; exists {

		vOpts := append(opts, db.WithValidateField("deleted_objects"))
		for idx, item := range m.GetDeletedObjects() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeleteObjectResponseValidator = func() *ValidateDeleteObjectResponse {
	v := &ValidateDeleteObjectResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DeleteObjectResponseValidator() db.Validator {
	return DefaultDeleteObjectResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *GetObjectRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetObjectRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetObjectRequest) DeepCopy() *GetObjectRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetObjectRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetObjectRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetObjectRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetObjectRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetObjectRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetObjectRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateGetObjectRequest) ObjectTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for object_type")
	}

	return validatorFn, nil
}

func (v *ValidateGetObjectRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateGetObjectRequest) VersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for version")
	}

	return validatorFn, nil
}

func (v *ValidateGetObjectRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetObjectRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetObjectRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["object_type"]; exists {

		vOpts := append(opts, db.WithValidateField("object_type"))
		if err := fv(ctx, m.GetObjectType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetObjectRequestValidator = func() *ValidateGetObjectRequest {
	v := &ValidateGetObjectRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetObjectRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhObjectType := v.ObjectTypeValidationRuleHandler
	rulesObjectType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"swagger\", \"generic\", \"big-object\", \"mobile-sdk\", \"mobile-integrator\", \"mobile-app-shield\"]",
	}
	vFn, err = vrhObjectType(rulesObjectType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetObjectRequest.object_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["object_type"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required":       "true",
		"ves.io.schema.rules.string.max_len":         "512",
		"ves.io.schema.rules.string.min_len":         "1",
		"ves.io.schema.rules.string.ves_object_name": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetObjectRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhVersion := v.VersionValidationRuleHandler
	rulesVersion := map[string]string{
		"ves.io.schema.rules.string.pattern": "^(v|V)[0-9]+(-[0-9]{2}){3}$",
	}
	vFn, err = vrhVersion(rulesVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetObjectRequest.version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["version"] = vFn

	return v
}()

func GetObjectRequestValidator() db.Validator {
	return DefaultGetObjectRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetObjectResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetObjectResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetObjectResponse) DeepCopy() *GetObjectResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetObjectResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetObjectResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetObjectResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetObjectResponseValidator().Validate(ctx, m, opts...)
}

type ValidateGetObjectResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetObjectResponse) ContentsStringValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_StringValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for string_value")
	}
	return oValidatorFn_StringValue, nil
}
func (v *ValidateGetObjectResponse) ContentsBytesValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_BytesValue, err := db.NewBytesValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bytes_value")
	}
	return oValidatorFn_BytesValue, nil
}

func (v *ValidateGetObjectResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetObjectResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetObjectResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["content_format"]; exists {

		vOpts := append(opts, db.WithValidateField("content_format"))
		if err := fv(ctx, m.GetContentFormat(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetContents().(type) {
	case *GetObjectResponse_StringValue:
		if fv, exists := v.FldValidators["contents.string_value"]; exists {
			val := m.GetContents().(*GetObjectResponse_StringValue).StringValue
			vOpts := append(opts,
				db.WithValidateField("contents"),
				db.WithValidateField("string_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetObjectResponse_BytesValue:
		if fv, exists := v.FldValidators["contents.bytes_value"]; exists {
			val := m.GetContents().(*GetObjectResponse_BytesValue).BytesValue
			vOpts := append(opts,
				db.WithValidateField("contents"),
				db.WithValidateField("bytes_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetObjectResponse_PresignedUrl:
		if fv, exists := v.FldValidators["contents.presigned_url"]; exists {
			val := m.GetContents().(*GetObjectResponse_PresignedUrl).PresignedUrl
			vOpts := append(opts,
				db.WithValidateField("contents"),
				db.WithValidateField("presigned_url"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetObjectResponseValidator = func() *ValidateGetObjectResponse {
	v := &ValidateGetObjectResponse{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhContentsStringValue := v.ContentsStringValueValidationRuleHandler
	rulesContentsStringValue := map[string]string{
		"ves.io.schema.rules.string.max_len": "5242880",
	}
	vFnMap["contents.string_value"], err = vrhContentsStringValue(rulesContentsStringValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GetObjectResponse.contents_string_value: %s", err)
		panic(errMsg)
	}
	vrhContentsBytesValue := v.ContentsBytesValueValidationRuleHandler
	rulesContentsBytesValue := map[string]string{
		"ves.io.schema.rules.bytes.max_len": "5242880",
	}
	vFnMap["contents.bytes_value"], err = vrhContentsBytesValue(rulesContentsBytesValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GetObjectResponse.contents_bytes_value: %s", err)
		panic(errMsg)
	}

	v.FldValidators["contents.string_value"] = vFnMap["contents.string_value"]
	v.FldValidators["contents.bytes_value"] = vFnMap["contents.bytes_value"]

	v.FldValidators["metadata"] = StoredObjectDescriptorValidator().Validate

	return v
}()

func GetObjectResponseValidator() db.Validator {
	return DefaultGetObjectResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListItemDescriptor) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListItemDescriptor) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListItemDescriptor) DeepCopy() *ListItemDescriptor {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListItemDescriptor{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListItemDescriptor) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListItemDescriptor) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListItemDescriptorValidator().Validate(ctx, m, opts...)
}

type ValidateListItemDescriptor struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListItemDescriptor) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListItemDescriptor)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListItemDescriptor got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetObjectAttributes().(type) {
	case *ListItemDescriptor_NoAttributes:
		if fv, exists := v.FldValidators["object_attributes.no_attributes"]; exists {
			val := m.GetObjectAttributes().(*ListItemDescriptor_NoAttributes).NoAttributes
			vOpts := append(opts,
				db.WithValidateField("object_attributes"),
				db.WithValidateField("no_attributes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ListItemDescriptor_MobileSdk:
		if fv, exists := v.FldValidators["object_attributes.mobile_sdk"]; exists {
			val := m.GetObjectAttributes().(*ListItemDescriptor_MobileSdk).MobileSdk
			vOpts := append(opts,
				db.WithValidateField("object_attributes"),
				db.WithValidateField("mobile_sdk"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ListItemDescriptor_MobileIntegrator:
		if fv, exists := v.FldValidators["object_attributes.mobile_integrator"]; exists {
			val := m.GetObjectAttributes().(*ListItemDescriptor_MobileIntegrator).MobileIntegrator
			vOpts := append(opts,
				db.WithValidateField("object_attributes"),
				db.WithValidateField("mobile_integrator"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ListItemDescriptor_MobileAppShield:
		if fv, exists := v.FldValidators["object_attributes.mobile_app_shield"]; exists {
			val := m.GetObjectAttributes().(*ListItemDescriptor_MobileAppShield).MobileAppShield
			vOpts := append(opts,
				db.WithValidateField("object_attributes"),
				db.WithValidateField("mobile_app_shield"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tenant"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant"))
		if err := fv(ctx, m.GetTenant(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["versions"]; exists {

		vOpts := append(opts, db.WithValidateField("versions"))
		for idx, item := range m.GetVersions() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListItemDescriptorValidator = func() *ValidateListItemDescriptor {
	v := &ValidateListItemDescriptor{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["object_attributes.mobile_sdk"] = MobileSDKAttributesValidator().Validate
	v.FldValidators["object_attributes.mobile_integrator"] = MobileIntegratorAttributesValidator().Validate
	v.FldValidators["object_attributes.mobile_app_shield"] = MobileAppShieldAttributesValidator().Validate

	v.FldValidators["versions"] = VersionDescriptorValidator().Validate

	return v
}()

func ListItemDescriptorValidator() db.Validator {
	return DefaultListItemDescriptorValidator
}

// augmented methods on protoc/std generated struct

func (m *ListObjectsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListObjectsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListObjectsRequest) DeepCopy() *ListObjectsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListObjectsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListObjectsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListObjectsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListObjectsRequestValidator().Validate(ctx, m, opts...)
}

type ValidateListObjectsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListObjectsRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateListObjectsRequest) ObjectTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for object_type")
	}

	return validatorFn, nil
}

func (v *ValidateListObjectsRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateListObjectsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListObjectsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListObjectsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["latest_version_only"]; exists {

		vOpts := append(opts, db.WithValidateField("latest_version_only"))
		if err := fv(ctx, m.GetLatestVersionOnly(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["object_type"]; exists {

		vOpts := append(opts, db.WithValidateField("object_type"))
		if err := fv(ctx, m.GetObjectType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query_type"]; exists {

		vOpts := append(opts, db.WithValidateField("query_type"))
		if err := fv(ctx, m.GetQueryType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListObjectsRequestValidator = func() *ValidateListObjectsRequest {
	v := &ValidateListObjectsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListObjectsRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhObjectType := v.ObjectTypeValidationRuleHandler
	rulesObjectType := map[string]string{
		"ves.io.schema.rules.string.in": "[\"swagger\", \"generic\", \"big-object\", \"mobile-sdk\", \"mobile-integrator\", \"mobile-app-shield\"]",
	}
	vFn, err = vrhObjectType(rulesObjectType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListObjectsRequest.object_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["object_type"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.string.max_len": "512",
		"ves.io.schema.rules.string.pattern": "^(([a-z]([-a-z0-9]*[a-z0-9])?/)?[a-z]([-a-z0-9]*[a-z0-9])?)?$",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListObjectsRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func ListObjectsRequestValidator() db.Validator {
	return DefaultListObjectsRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListObjectsResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListObjectsResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListObjectsResponse) DeepCopy() *ListObjectsResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListObjectsResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListObjectsResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListObjectsResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListObjectsResponseValidator().Validate(ctx, m, opts...)
}

type ValidateListObjectsResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListObjectsResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListObjectsResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListObjectsResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["items"]; exists {

		vOpts := append(opts, db.WithValidateField("items"))
		for idx, item := range m.GetItems() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListObjectsResponseValidator = func() *ValidateListObjectsResponse {
	v := &ValidateListObjectsResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["items"] = ListItemDescriptorValidator().Validate

	return v
}()

func ListObjectsResponseValidator() db.Validator {
	return DefaultListObjectsResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *MobileAppShieldAttributes) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MobileAppShieldAttributes) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MobileAppShieldAttributes) DeepCopy() *MobileAppShieldAttributes {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MobileAppShieldAttributes{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MobileAppShieldAttributes) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MobileAppShieldAttributes) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MobileAppShieldAttributesValidator().Validate(ctx, m, opts...)
}

type ValidateMobileAppShieldAttributes struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMobileAppShieldAttributes) OsTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(OSType)
		return int32(i)
	}
	// OSType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, OSType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for os_type")
	}

	return validatorFn, nil
}

func (v *ValidateMobileAppShieldAttributes) ReleaseVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for release_version")
	}

	return validatorFn, nil
}

func (v *ValidateMobileAppShieldAttributes) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MobileAppShieldAttributes)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MobileAppShieldAttributes got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["os_type"]; exists {

		vOpts := append(opts, db.WithValidateField("os_type"))
		if err := fv(ctx, m.GetOsType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["release_version"]; exists {

		vOpts := append(opts, db.WithValidateField("release_version"))
		if err := fv(ctx, m.GetReleaseVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMobileAppShieldAttributesValidator = func() *ValidateMobileAppShieldAttributes {
	v := &ValidateMobileAppShieldAttributes{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOsType := v.OsTypeValidationRuleHandler
	rulesOsType := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.message.required":  "true",
	}
	vFn, err = vrhOsType(rulesOsType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MobileAppShieldAttributes.os_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["os_type"] = vFn

	vrhReleaseVersion := v.ReleaseVersionValidationRuleHandler
	rulesReleaseVersion := map[string]string{
		"ves.io.schema.rules.string.max_len":   "32",
		"ves.io.schema.rules.string.not_empty": "true",
	}
	vFn, err = vrhReleaseVersion(rulesReleaseVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MobileAppShieldAttributes.release_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["release_version"] = vFn

	return v
}()

func MobileAppShieldAttributesValidator() db.Validator {
	return DefaultMobileAppShieldAttributesValidator
}

// augmented methods on protoc/std generated struct

func (m *MobileIntegratorAttributes) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MobileIntegratorAttributes) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MobileIntegratorAttributes) DeepCopy() *MobileIntegratorAttributes {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MobileIntegratorAttributes{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MobileIntegratorAttributes) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MobileIntegratorAttributes) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MobileIntegratorAttributesValidator().Validate(ctx, m, opts...)
}

type ValidateMobileIntegratorAttributes struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMobileIntegratorAttributes) OsTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(OSType)
		return int32(i)
	}
	// OSType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, OSType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for os_type")
	}

	return validatorFn, nil
}

func (v *ValidateMobileIntegratorAttributes) ReleaseVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for release_version")
	}

	return validatorFn, nil
}

func (v *ValidateMobileIntegratorAttributes) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MobileIntegratorAttributes)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MobileIntegratorAttributes got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["os_type"]; exists {

		vOpts := append(opts, db.WithValidateField("os_type"))
		if err := fv(ctx, m.GetOsType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["release_version"]; exists {

		vOpts := append(opts, db.WithValidateField("release_version"))
		if err := fv(ctx, m.GetReleaseVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMobileIntegratorAttributesValidator = func() *ValidateMobileIntegratorAttributes {
	v := &ValidateMobileIntegratorAttributes{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOsType := v.OsTypeValidationRuleHandler
	rulesOsType := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.message.required":  "true",
	}
	vFn, err = vrhOsType(rulesOsType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MobileIntegratorAttributes.os_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["os_type"] = vFn

	vrhReleaseVersion := v.ReleaseVersionValidationRuleHandler
	rulesReleaseVersion := map[string]string{
		"ves.io.schema.rules.string.max_len":   "32",
		"ves.io.schema.rules.string.not_empty": "true",
	}
	vFn, err = vrhReleaseVersion(rulesReleaseVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MobileIntegratorAttributes.release_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["release_version"] = vFn

	return v
}()

func MobileIntegratorAttributesValidator() db.Validator {
	return DefaultMobileIntegratorAttributesValidator
}

// augmented methods on protoc/std generated struct

func (m *MobileSDKAttributes) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MobileSDKAttributes) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MobileSDKAttributes) DeepCopy() *MobileSDKAttributes {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MobileSDKAttributes{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MobileSDKAttributes) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MobileSDKAttributes) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MobileSDKAttributesValidator().Validate(ctx, m, opts...)
}

type ValidateMobileSDKAttributes struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMobileSDKAttributes) OsTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(OSType)
		return int32(i)
	}
	// OSType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, OSType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for os_type")
	}

	return validatorFn, nil
}

func (v *ValidateMobileSDKAttributes) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MobileSDKAttributes)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MobileSDKAttributes got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["os_type"]; exists {

		vOpts := append(opts, db.WithValidateField("os_type"))
		if err := fv(ctx, m.GetOsType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["release_version"]; exists {

		vOpts := append(opts, db.WithValidateField("release_version"))
		if err := fv(ctx, m.GetReleaseVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMobileSDKAttributesValidator = func() *ValidateMobileSDKAttributes {
	v := &ValidateMobileSDKAttributes{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOsType := v.OsTypeValidationRuleHandler
	rulesOsType := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.message.required":  "true",
	}
	vFn, err = vrhOsType(rulesOsType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MobileSDKAttributes.os_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["os_type"] = vFn

	return v
}()

func MobileSDKAttributesValidator() db.Validator {
	return DefaultMobileSDKAttributesValidator
}

// augmented methods on protoc/std generated struct

func (m *PreSignedUrl) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PreSignedUrl) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PreSignedUrl) DeepCopy() *PreSignedUrl {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PreSignedUrl{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PreSignedUrl) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PreSignedUrl) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PreSignedUrlValidator().Validate(ctx, m, opts...)
}

type ValidatePreSignedUrl struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePreSignedUrl) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PreSignedUrl)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PreSignedUrl got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetStorageProviderChoice().(type) {
	case *PreSignedUrl_Aws:
		if fv, exists := v.FldValidators["storage_provider_choice.aws"]; exists {
			val := m.GetStorageProviderChoice().(*PreSignedUrl_Aws).Aws
			vOpts := append(opts,
				db.WithValidateField("storage_provider_choice"),
				db.WithValidateField("aws"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPreSignedUrlValidator = func() *ValidatePreSignedUrl {
	v := &ValidatePreSignedUrl{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PreSignedUrlValidator() db.Validator {
	return DefaultPreSignedUrlValidator
}

// augmented methods on protoc/std generated struct

func (m *PresignedUrlData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PresignedUrlData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PresignedUrlData) DeepCopy() *PresignedUrlData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PresignedUrlData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PresignedUrlData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PresignedUrlData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PresignedUrlDataValidator().Validate(ctx, m, opts...)
}

type ValidatePresignedUrlData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePresignedUrlData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PresignedUrlData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PresignedUrlData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["method"]; exists {

		vOpts := append(opts, db.WithValidateField("method"))
		if err := fv(ctx, m.GetMethod(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["url"]; exists {

		vOpts := append(opts, db.WithValidateField("url"))
		if err := fv(ctx, m.GetUrl(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPresignedUrlDataValidator = func() *ValidatePresignedUrlData {
	v := &ValidatePresignedUrlData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PresignedUrlDataValidator() db.Validator {
	return DefaultPresignedUrlDataValidator
}

// augmented methods on protoc/std generated struct

func (m *StoredObjectDescriptor) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StoredObjectDescriptor) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StoredObjectDescriptor) DeepCopy() *StoredObjectDescriptor {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StoredObjectDescriptor{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StoredObjectDescriptor) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StoredObjectDescriptor) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StoredObjectDescriptorValidator().Validate(ctx, m, opts...)
}

type ValidateStoredObjectDescriptor struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStoredObjectDescriptor) UrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for url")
	}

	return validatorFn, nil
}

func (v *ValidateStoredObjectDescriptor) DescriptionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for description")
	}

	return validatorFn, nil
}

func (v *ValidateStoredObjectDescriptor) CreationTimestampValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var (
		reqdValidatorFn db.ValidatorFunc
		err             error
	)

	reqdValidatorFn, err = db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for creation_timestamp")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if reqdValidatorFn != nil {
			if err = reqdValidatorFn(ctx, val, opts...); err != nil {
				return err
			}
		}
		// TODO: lookup configured third-party type validators
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStoredObjectDescriptor) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateStoredObjectDescriptor) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateStoredObjectDescriptor) VersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for version")
	}

	return validatorFn, nil
}

func (v *ValidateStoredObjectDescriptor) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StoredObjectDescriptor)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StoredObjectDescriptor got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["creation_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("creation_timestamp"))
		if err := fv(ctx, m.GetCreationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetObjectAttributes().(type) {
	case *StoredObjectDescriptor_NoAttributes:
		if fv, exists := v.FldValidators["object_attributes.no_attributes"]; exists {
			val := m.GetObjectAttributes().(*StoredObjectDescriptor_NoAttributes).NoAttributes
			vOpts := append(opts,
				db.WithValidateField("object_attributes"),
				db.WithValidateField("no_attributes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StoredObjectDescriptor_MobileSdk:
		if fv, exists := v.FldValidators["object_attributes.mobile_sdk"]; exists {
			val := m.GetObjectAttributes().(*StoredObjectDescriptor_MobileSdk).MobileSdk
			vOpts := append(opts,
				db.WithValidateField("object_attributes"),
				db.WithValidateField("mobile_sdk"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StoredObjectDescriptor_MobileIntegrator:
		if fv, exists := v.FldValidators["object_attributes.mobile_integrator"]; exists {
			val := m.GetObjectAttributes().(*StoredObjectDescriptor_MobileIntegrator).MobileIntegrator
			vOpts := append(opts,
				db.WithValidateField("object_attributes"),
				db.WithValidateField("mobile_integrator"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StoredObjectDescriptor_MobileAppShield:
		if fv, exists := v.FldValidators["object_attributes.mobile_app_shield"]; exists {
			val := m.GetObjectAttributes().(*StoredObjectDescriptor_MobileAppShield).MobileAppShield
			vOpts := append(opts,
				db.WithValidateField("object_attributes"),
				db.WithValidateField("mobile_app_shield"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["url"]; exists {

		vOpts := append(opts, db.WithValidateField("url"))
		if err := fv(ctx, m.GetUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStoredObjectDescriptorValidator = func() *ValidateStoredObjectDescriptor {
	v := &ValidateStoredObjectDescriptor{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhUrl := v.UrlValidationRuleHandler
	rulesUrl := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhUrl(rulesUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StoredObjectDescriptor.url: %s", err)
		panic(errMsg)
	}
	v.FldValidators["url"] = vFn

	vrhDescription := v.DescriptionValidationRuleHandler
	rulesDescription := map[string]string{
		"ves.io.schema.rules.string.max_len": "512",
	}
	vFn, err = vrhDescription(rulesDescription)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StoredObjectDescriptor.description: %s", err)
		panic(errMsg)
	}
	v.FldValidators["description"] = vFn

	vrhCreationTimestamp := v.CreationTimestampValidationRuleHandler
	rulesCreationTimestamp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhCreationTimestamp(rulesCreationTimestamp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StoredObjectDescriptor.creation_timestamp: %s", err)
		panic(errMsg)
	}
	v.FldValidators["creation_timestamp"] = vFn

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StoredObjectDescriptor.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StoredObjectDescriptor.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhVersion := v.VersionValidationRuleHandler
	rulesVersion := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhVersion(rulesVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StoredObjectDescriptor.version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["version"] = vFn

	v.FldValidators["object_attributes.mobile_sdk"] = MobileSDKAttributesValidator().Validate
	v.FldValidators["object_attributes.mobile_integrator"] = MobileIntegratorAttributesValidator().Validate
	v.FldValidators["object_attributes.mobile_app_shield"] = MobileAppShieldAttributesValidator().Validate

	return v
}()

func StoredObjectDescriptorValidator() db.Validator {
	return DefaultStoredObjectDescriptorValidator
}

// augmented methods on protoc/std generated struct

func (m *VersionDescriptor) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VersionDescriptor) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VersionDescriptor) DeepCopy() *VersionDescriptor {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VersionDescriptor{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VersionDescriptor) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VersionDescriptor) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VersionDescriptorValidator().Validate(ctx, m, opts...)
}

type ValidateVersionDescriptor struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVersionDescriptor) DescriptionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for description")
	}

	return validatorFn, nil
}

func (v *ValidateVersionDescriptor) CreationTimestampValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var (
		reqdValidatorFn db.ValidatorFunc
		err             error
	)

	reqdValidatorFn, err = db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for creation_timestamp")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if reqdValidatorFn != nil {
			if err = reqdValidatorFn(ctx, val, opts...); err != nil {
				return err
			}
		}
		// TODO: lookup configured third-party type validators
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateVersionDescriptor) UrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for url")
	}

	return validatorFn, nil
}

func (v *ValidateVersionDescriptor) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VersionDescriptor)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VersionDescriptor got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["creation_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("creation_timestamp"))
		if err := fv(ctx, m.GetCreationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["latest_version"]; exists {

		vOpts := append(opts, db.WithValidateField("latest_version"))
		if err := fv(ctx, m.GetLatestVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["url"]; exists {

		vOpts := append(opts, db.WithValidateField("url"))
		if err := fv(ctx, m.GetUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVersionDescriptorValidator = func() *ValidateVersionDescriptor {
	v := &ValidateVersionDescriptor{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDescription := v.DescriptionValidationRuleHandler
	rulesDescription := map[string]string{
		"ves.io.schema.rules.string.max_len": "512",
	}
	vFn, err = vrhDescription(rulesDescription)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VersionDescriptor.description: %s", err)
		panic(errMsg)
	}
	v.FldValidators["description"] = vFn

	vrhCreationTimestamp := v.CreationTimestampValidationRuleHandler
	rulesCreationTimestamp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhCreationTimestamp(rulesCreationTimestamp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VersionDescriptor.creation_timestamp: %s", err)
		panic(errMsg)
	}
	v.FldValidators["creation_timestamp"] = vFn

	vrhUrl := v.UrlValidationRuleHandler
	rulesUrl := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhUrl(rulesUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VersionDescriptor.url: %s", err)
		panic(errMsg)
	}
	v.FldValidators["url"] = vFn

	return v
}()

func VersionDescriptorValidator() db.Validator {
	return DefaultVersionDescriptorValidator
}
