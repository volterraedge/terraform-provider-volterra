// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/net.proto

package schema

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// VirtualNetworkType
//
// x-displayName: "Virtual Network Type"
// Different types of virtual networks understood by the system
type VirtualNetworkType int32

const (
	// x-displayName: "Site Local Network"
	// Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL provides connectivity to public (outside) network.
	// This is an insecure network and is connected to public internet via NAT Gateways/firwalls
	// Virtual-network of this type is local to every site. Two virtual networks of this type on different
	// sites are neither related nor connected.
	//
	// Constraints:
	// There can be atmost one virtual network of this type in a given site.
	// This network type is supported on CE sites. This network is created automatically and present on all sites
	VIRTUAL_NETWORK_SITE_LOCAL VirtualNetworkType = 0
	// x-displayName: "Site Local Inside Network"
	// Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL_INSIDE is a private network inside site.
	// It is a secure network and is not connected to public network.
	// Virtual-network of this type is local to every site. Two virtual networks of this type on different
	// sites are neither related nor connected.
	//
	// Constraints:
	// There can be atmost one virtual network of this type in a given site.
	// This network type is supported on CE sites. This network is created during provisioning of site
	VIRTUAL_NETWORK_SITE_LOCAL_INSIDE VirtualNetworkType = 1
	// x-displayName: "Per Site Network"
	// User defined per-site virtual network. Scope of this virtual network is limited to the site.
	// This is not yet supported
	VIRTUAL_NETWORK_PER_SITE VirtualNetworkType = 2
	// x-displayName: "Public Network"
	// Virtual-network of type VIRTUAL_NETWORK_PUBLIC directly conects to the public internet.
	// Virtual-network of this type is local to every site. Two virtual networks of this type on different sites are neither related nor connected.
	//
	// Constraints:
	// There can be atmost one virtual network of this type in a given site.
	// This network type is supported on RE sites only
	// It is an internally created by the system. They must not be created by user
	VIRTUAL_NETWORK_PUBLIC VirtualNetworkType = 3
	// x-displayName: "Global Network"
	// Virtual Neworks with global scope across different sites in Volterra domain.
	// An example global virtual-network called "AIN Network" is created for every tenant.
	// for volterra fabric
	//
	// Constraints:
	// It is currently only supported as internally created by the system.
	VIRTUAL_NETWORK_GLOBAL VirtualNetworkType = 4
	// x-displayName: "Site Local Service Network"
	// vK8s service network for a given tenant. Used to advertise a virtual host only to vk8s pods for that tenant
	// Constraints:
	// It is an internally created by the system. Must not be created by user
	VIRTUAL_NETWORK_SITE_SERVICE VirtualNetworkType = 5
	// x-displayName: "VER Internal Network"
	// VER internal network for the site. It can only be used for virtual hosts with SMA_PROXY type proxy
	// Constraints:
	// It is an internally created by the system. Must not be created by user
	VIRTUAL_NETWORK_VER_INTERNAL VirtualNetworkType = 6
	// x-displayName: "Site Local Inside And Outside Networks"
	// Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE represents both
	// VIRTUAL_NETWORK_SITE_LOCAL and VIRTUAL_NETWORK_SITE_LOCAL_INSIDE
	//
	// Constraints:
	// This network type is only meaningful in an advertise policy
	VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE VirtualNetworkType = 7
	// x-displayName: "IP Based Automatic Network"
	// When virtual-network of type VIRTUAL_NETWORK_IP_AUTO is selected for
	// an endpoint, VER will try to determine the network based on the provided
	// IP address
	//
	// Constraints:
	// This network type is only meaningful in an endpoint
	VIRTUAL_NETWORK_IP_AUTO VirtualNetworkType = 8
	// x-displayName: "VoltADN Private Network"
	//
	// VoltADN Private Network is used on volterra RE(s) to connect to customer private networks
	// This network is created by opening a support ticket
	VIRTUAL_NETWORK_VOLTADN_PRIVATE_NETWORK VirtualNetworkType = 9
	// x-displayName: "Per Site Srv6 Network"
	//
	// This network is per site srv6 network
	VIRTUAL_NETWORK_SRV6_NETWORK VirtualNetworkType = 10
	// x-displayName: "VER IP Fabric Network"
	// VER IP Fabric network for the site.
	// This Virtual network type is used for exposing virtual host on IP Fabric network on the VER site or
	// for endpoint in IP Fabric network
	// Constraints:
	// It is an internally created by the system. Must not be created by user
	VIRTUAL_NETWORK_IP_FABRIC VirtualNetworkType = 11
)

var VirtualNetworkType_name = map[int32]string{
	0:  "VIRTUAL_NETWORK_SITE_LOCAL",
	1:  "VIRTUAL_NETWORK_SITE_LOCAL_INSIDE",
	2:  "VIRTUAL_NETWORK_PER_SITE",
	3:  "VIRTUAL_NETWORK_PUBLIC",
	4:  "VIRTUAL_NETWORK_GLOBAL",
	5:  "VIRTUAL_NETWORK_SITE_SERVICE",
	6:  "VIRTUAL_NETWORK_VER_INTERNAL",
	7:  "VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE",
	8:  "VIRTUAL_NETWORK_IP_AUTO",
	9:  "VIRTUAL_NETWORK_VOLTADN_PRIVATE_NETWORK",
	10: "VIRTUAL_NETWORK_SRV6_NETWORK",
	11: "VIRTUAL_NETWORK_IP_FABRIC",
}

var VirtualNetworkType_value = map[string]int32{
	"VIRTUAL_NETWORK_SITE_LOCAL":                0,
	"VIRTUAL_NETWORK_SITE_LOCAL_INSIDE":         1,
	"VIRTUAL_NETWORK_PER_SITE":                  2,
	"VIRTUAL_NETWORK_PUBLIC":                    3,
	"VIRTUAL_NETWORK_GLOBAL":                    4,
	"VIRTUAL_NETWORK_SITE_SERVICE":              5,
	"VIRTUAL_NETWORK_VER_INTERNAL":              6,
	"VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE": 7,
	"VIRTUAL_NETWORK_IP_AUTO":                   8,
	"VIRTUAL_NETWORK_VOLTADN_PRIVATE_NETWORK":   9,
	"VIRTUAL_NETWORK_SRV6_NETWORK":              10,
	"VIRTUAL_NETWORK_IP_FABRIC":                 11,
}

func (VirtualNetworkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_34085f3b2015fb7b, []int{0}
}

// MAC Address
//
// x-displayName: "MAC Address"
// Mac Address in string format
type MacAddressType struct {
	// Mac Address
	//
	// x-displayName: "MAC Address"
	// x-example: "01:10:20:0a:bb:1c"
	Mac string `protobuf:"bytes,1,opt,name=mac,proto3" json:"mac,omitempty"`
}

func (m *MacAddressType) Reset()      { *m = MacAddressType{} }
func (*MacAddressType) ProtoMessage() {}
func (*MacAddressType) Descriptor() ([]byte, []int) {
	return fileDescriptor_34085f3b2015fb7b, []int{0}
}
func (m *MacAddressType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MacAddressType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MacAddressType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MacAddressType.Merge(m, src)
}
func (m *MacAddressType) XXX_Size() int {
	return m.Size()
}
func (m *MacAddressType) XXX_DiscardUnknown() {
	xxx_messageInfo_MacAddressType.DiscardUnknown(m)
}

var xxx_messageInfo_MacAddressType proto.InternalMessageInfo

func (m *MacAddressType) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

// IPv4 Address
//
// x-displayName: "IPv4 Address"
// IPv4 Address in dot-decimal notation
type Ipv4AddressType struct {
	// IPv4 Address
	//
	// x-displayName: "IPv4 Address"
	// x-example: "192.168.1.1"
	// IPv4 Address in string form with dot-decimal notation
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *Ipv4AddressType) Reset()      { *m = Ipv4AddressType{} }
func (*Ipv4AddressType) ProtoMessage() {}
func (*Ipv4AddressType) Descriptor() ([]byte, []int) {
	return fileDescriptor_34085f3b2015fb7b, []int{1}
}
func (m *Ipv4AddressType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ipv4AddressType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Ipv4AddressType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ipv4AddressType.Merge(m, src)
}
func (m *Ipv4AddressType) XXX_Size() int {
	return m.Size()
}
func (m *Ipv4AddressType) XXX_DiscardUnknown() {
	xxx_messageInfo_Ipv4AddressType.DiscardUnknown(m)
}

var xxx_messageInfo_Ipv4AddressType proto.InternalMessageInfo

func (m *Ipv4AddressType) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

// IPv4 Subnet
//
// x-displayName: "IPv4 Subnet"
// IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32
type Ipv4SubnetType struct {
	// Prefix
	//
	// x-displayName: "Prefix"
	// x-example: "192.168.1.0"
	// Prefix part of the IPv4 subnet in string form with dot-decimal notation
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// Prefix Length
	//
	// x-displayName: "Prefix Length"
	// x-example: 24
	// Prefix-length of the IPv4 subnet. Must be <= 32
	Plen uint32 `protobuf:"varint,2,opt,name=plen,proto3" json:"plen,omitempty"`
}

func (m *Ipv4SubnetType) Reset()      { *m = Ipv4SubnetType{} }
func (*Ipv4SubnetType) ProtoMessage() {}
func (*Ipv4SubnetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_34085f3b2015fb7b, []int{2}
}
func (m *Ipv4SubnetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ipv4SubnetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Ipv4SubnetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ipv4SubnetType.Merge(m, src)
}
func (m *Ipv4SubnetType) XXX_Size() int {
	return m.Size()
}
func (m *Ipv4SubnetType) XXX_DiscardUnknown() {
	xxx_messageInfo_Ipv4SubnetType.DiscardUnknown(m)
}

var xxx_messageInfo_Ipv4SubnetType proto.InternalMessageInfo

func (m *Ipv4SubnetType) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Ipv4SubnetType) GetPlen() uint32 {
	if m != nil {
		return m.Plen
	}
	return 0
}

// IPv6 Address
//
// x-displayName: "IPv6 Address"
// IPv6 Address specified as hexadecimal numbers separated by ':'
type Ipv6AddressType struct {
	// IPv6 Address
	//
	// x-displayName: "IPv6 Address"
	// x-example: "2001:db8:0:0:0:0:2:1"
	// IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':'
	// The address can be compacted by suppressing zeros
	// e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *Ipv6AddressType) Reset()      { *m = Ipv6AddressType{} }
func (*Ipv6AddressType) ProtoMessage() {}
func (*Ipv6AddressType) Descriptor() ([]byte, []int) {
	return fileDescriptor_34085f3b2015fb7b, []int{3}
}
func (m *Ipv6AddressType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ipv6AddressType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Ipv6AddressType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ipv6AddressType.Merge(m, src)
}
func (m *Ipv6AddressType) XXX_Size() int {
	return m.Size()
}
func (m *Ipv6AddressType) XXX_DiscardUnknown() {
	xxx_messageInfo_Ipv6AddressType.DiscardUnknown(m)
}

var xxx_messageInfo_Ipv6AddressType proto.InternalMessageInfo

func (m *Ipv6AddressType) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

// IPv6 Subnet
//
// x-displayName: "IPv6 Subnet"
// IPv6 subnets specified as prefix and prefix-length. prefix-legnth must be <= 128
type Ipv6SubnetType struct {
	// Prefix
	//
	// x-displayName: "Prefix"
	// x-example: "2001:db8:0:0:0:0:2:0"
	// Prefix part of the IPv6 subnet given in form of string.
	// IPv6 address must be specified as hexadecimal numbers separated by ':'
	// e.g. "2001:db8:0:0:0:2:0:0"
	// The address can be compacted by suppressing zeros
	// e.g. "2001:db8::2::"
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// Prefix length
	//
	// x-example: "38"
	// x-displayName: "Prefix Length"
	// Prefix length of the IPv6 subnet. Must be <= 128
	Plen uint32 `protobuf:"varint,2,opt,name=plen,proto3" json:"plen,omitempty"`
}

func (m *Ipv6SubnetType) Reset()      { *m = Ipv6SubnetType{} }
func (*Ipv6SubnetType) ProtoMessage() {}
func (*Ipv6SubnetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_34085f3b2015fb7b, []int{4}
}
func (m *Ipv6SubnetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ipv6SubnetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Ipv6SubnetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ipv6SubnetType.Merge(m, src)
}
func (m *Ipv6SubnetType) XXX_Size() int {
	return m.Size()
}
func (m *Ipv6SubnetType) XXX_DiscardUnknown() {
	xxx_messageInfo_Ipv6SubnetType.DiscardUnknown(m)
}

var xxx_messageInfo_Ipv6SubnetType proto.InternalMessageInfo

func (m *Ipv6SubnetType) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Ipv6SubnetType) GetPlen() uint32 {
	if m != nil {
		return m.Plen
	}
	return 0
}

// IP Address
//
// x-displayName: "IP Address"
// IP Address used to specify an IPv4 or IPv6 address
type IpAddressType struct {
	// Version
	//
	// x-displayName: "Version"
	// IP Address version. Can be IPv4 Address or IPv6 Address
	//
	// Types that are valid to be assigned to Ver:
	//	*IpAddressType_Ipv4
	//	*IpAddressType_Ipv6
	Ver isIpAddressType_Ver `protobuf_oneof:"ver"`
}

func (m *IpAddressType) Reset()      { *m = IpAddressType{} }
func (*IpAddressType) ProtoMessage() {}
func (*IpAddressType) Descriptor() ([]byte, []int) {
	return fileDescriptor_34085f3b2015fb7b, []int{5}
}
func (m *IpAddressType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpAddressType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IpAddressType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpAddressType.Merge(m, src)
}
func (m *IpAddressType) XXX_Size() int {
	return m.Size()
}
func (m *IpAddressType) XXX_DiscardUnknown() {
	xxx_messageInfo_IpAddressType.DiscardUnknown(m)
}

var xxx_messageInfo_IpAddressType proto.InternalMessageInfo

type isIpAddressType_Ver interface {
	isIpAddressType_Ver()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type IpAddressType_Ipv4 struct {
	Ipv4 *Ipv4AddressType `protobuf:"bytes,1,opt,name=ipv4,proto3,oneof" json:"ipv4,omitempty"`
}
type IpAddressType_Ipv6 struct {
	Ipv6 *Ipv6AddressType `protobuf:"bytes,2,opt,name=ipv6,proto3,oneof" json:"ipv6,omitempty"`
}

func (*IpAddressType_Ipv4) isIpAddressType_Ver() {}
func (*IpAddressType_Ipv6) isIpAddressType_Ver() {}

func (m *IpAddressType) GetVer() isIpAddressType_Ver {
	if m != nil {
		return m.Ver
	}
	return nil
}

func (m *IpAddressType) GetIpv4() *Ipv4AddressType {
	if x, ok := m.GetVer().(*IpAddressType_Ipv4); ok {
		return x.Ipv4
	}
	return nil
}

func (m *IpAddressType) GetIpv6() *Ipv6AddressType {
	if x, ok := m.GetVer().(*IpAddressType_Ipv6); ok {
		return x.Ipv6
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*IpAddressType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*IpAddressType_Ipv4)(nil),
		(*IpAddressType_Ipv6)(nil),
	}
}

// IP Subnet
//
// x-displayName: "IP Subnet"
// IP Address used to specify an IPv4 or IPv6 subnet addresses
type IpSubnetType struct {
	// Version
	//
	// x-displayName: "Version"
	// IP Address version. Can be IPv4 subnet address or IPv6 subnet address
	//
	// Types that are valid to be assigned to Ver:
	//	*IpSubnetType_Ipv4
	//	*IpSubnetType_Ipv6
	Ver isIpSubnetType_Ver `protobuf_oneof:"ver"`
}

func (m *IpSubnetType) Reset()      { *m = IpSubnetType{} }
func (*IpSubnetType) ProtoMessage() {}
func (*IpSubnetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_34085f3b2015fb7b, []int{6}
}
func (m *IpSubnetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpSubnetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IpSubnetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpSubnetType.Merge(m, src)
}
func (m *IpSubnetType) XXX_Size() int {
	return m.Size()
}
func (m *IpSubnetType) XXX_DiscardUnknown() {
	xxx_messageInfo_IpSubnetType.DiscardUnknown(m)
}

var xxx_messageInfo_IpSubnetType proto.InternalMessageInfo

type isIpSubnetType_Ver interface {
	isIpSubnetType_Ver()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type IpSubnetType_Ipv4 struct {
	Ipv4 *Ipv4SubnetType `protobuf:"bytes,1,opt,name=ipv4,proto3,oneof" json:"ipv4,omitempty"`
}
type IpSubnetType_Ipv6 struct {
	Ipv6 *Ipv6SubnetType `protobuf:"bytes,2,opt,name=ipv6,proto3,oneof" json:"ipv6,omitempty"`
}

func (*IpSubnetType_Ipv4) isIpSubnetType_Ver() {}
func (*IpSubnetType_Ipv6) isIpSubnetType_Ver() {}

func (m *IpSubnetType) GetVer() isIpSubnetType_Ver {
	if m != nil {
		return m.Ver
	}
	return nil
}

func (m *IpSubnetType) GetIpv4() *Ipv4SubnetType {
	if x, ok := m.GetVer().(*IpSubnetType_Ipv4); ok {
		return x.Ipv4
	}
	return nil
}

func (m *IpSubnetType) GetIpv6() *Ipv6SubnetType {
	if x, ok := m.GetVer().(*IpSubnetType_Ipv6); ok {
		return x.Ipv6
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*IpSubnetType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*IpSubnetType_Ipv4)(nil),
		(*IpSubnetType_Ipv6)(nil),
	}
}

// IP Prefix List
//
// x-displayName: "IP Prefix List"
// List of IP Address prefixes. Prefix must contain both prefix and prefix-length
// The list can contain mix of both IPv4 and IPv6 prefixes
type PrefixListType struct {
	// Prefix
	//
	// x-displayName: "Prefix"
	// x-example: "[192.168.1.0/24, 192.168.2.0/24]" or "[2001:db8::1::/112, 2001::db8::2::/112]"
	// IP Address prefix in string format. String must contain both prefix and prefix-length
	Prefix []string `protobuf:"bytes,1,rep,name=prefix,proto3" json:"prefix,omitempty"`
}

func (m *PrefixListType) Reset()      { *m = PrefixListType{} }
func (*PrefixListType) ProtoMessage() {}
func (*PrefixListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_34085f3b2015fb7b, []int{7}
}
func (m *PrefixListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrefixListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PrefixListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrefixListType.Merge(m, src)
}
func (m *PrefixListType) XXX_Size() int {
	return m.Size()
}
func (m *PrefixListType) XXX_DiscardUnknown() {
	xxx_messageInfo_PrefixListType.DiscardUnknown(m)
}

var xxx_messageInfo_PrefixListType proto.InternalMessageInfo

func (m *PrefixListType) GetPrefix() []string {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.VirtualNetworkType", VirtualNetworkType_name, VirtualNetworkType_value)
	golang_proto.RegisterEnum("ves.io.schema.VirtualNetworkType", VirtualNetworkType_name, VirtualNetworkType_value)
	proto.RegisterType((*MacAddressType)(nil), "ves.io.schema.MacAddressType")
	golang_proto.RegisterType((*MacAddressType)(nil), "ves.io.schema.MacAddressType")
	proto.RegisterType((*Ipv4AddressType)(nil), "ves.io.schema.Ipv4AddressType")
	golang_proto.RegisterType((*Ipv4AddressType)(nil), "ves.io.schema.Ipv4AddressType")
	proto.RegisterType((*Ipv4SubnetType)(nil), "ves.io.schema.Ipv4SubnetType")
	golang_proto.RegisterType((*Ipv4SubnetType)(nil), "ves.io.schema.Ipv4SubnetType")
	proto.RegisterType((*Ipv6AddressType)(nil), "ves.io.schema.Ipv6AddressType")
	golang_proto.RegisterType((*Ipv6AddressType)(nil), "ves.io.schema.Ipv6AddressType")
	proto.RegisterType((*Ipv6SubnetType)(nil), "ves.io.schema.Ipv6SubnetType")
	golang_proto.RegisterType((*Ipv6SubnetType)(nil), "ves.io.schema.Ipv6SubnetType")
	proto.RegisterType((*IpAddressType)(nil), "ves.io.schema.IpAddressType")
	golang_proto.RegisterType((*IpAddressType)(nil), "ves.io.schema.IpAddressType")
	proto.RegisterType((*IpSubnetType)(nil), "ves.io.schema.IpSubnetType")
	golang_proto.RegisterType((*IpSubnetType)(nil), "ves.io.schema.IpSubnetType")
	proto.RegisterType((*PrefixListType)(nil), "ves.io.schema.PrefixListType")
	golang_proto.RegisterType((*PrefixListType)(nil), "ves.io.schema.PrefixListType")
}

func init() { proto.RegisterFile("ves.io/schema/net.proto", fileDescriptor_34085f3b2015fb7b) }
func init() { golang_proto.RegisterFile("ves.io/schema/net.proto", fileDescriptor_34085f3b2015fb7b) }

var fileDescriptor_34085f3b2015fb7b = []byte{
	// 765 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x94, 0xc1, 0x8f, 0xea, 0x54,
	0x14, 0xc6, 0x7b, 0x28, 0xc3, 0x7b, 0x73, 0x9f, 0xf0, 0x9a, 0x2e, 0xde, 0x43, 0x1c, 0xaf, 0xbc,
	0x26, 0xa3, 0xe3, 0x44, 0x8a, 0x0e, 0xd8, 0x85, 0x0b, 0x93, 0xc2, 0xab, 0x4e, 0xb5, 0x02, 0x29,
	0x05, 0x93, 0x89, 0x49, 0x53, 0xa0, 0xc3, 0x34, 0x03, 0xb4, 0x29, 0x85, 0x19, 0x17, 0x26, 0xf8,
	0x1f, 0x98, 0x59, 0x9b, 0xb8, 0xf5, 0x4f, 0x30, 0xb2, 0x99, 0xa5, 0x1b, 0x13, 0x96, 0xb3, 0x74,
	0xca, 0x46, 0x77, 0x13, 0x57, 0xb3, 0x34, 0xdc, 0xc2, 0x4c, 0x0b, 0x18, 0x5d, 0x71, 0x2f, 0xdf,
	0xf7, 0x9d, 0xf3, 0x3b, 0xf7, 0x36, 0x17, 0xbd, 0x1c, 0x9b, 0x43, 0xde, 0xb2, 0xf3, 0xc3, 0xf6,
	0x99, 0xd9, 0x37, 0xf2, 0x03, 0xd3, 0xe3, 0x1d, 0xd7, 0xf6, 0x6c, 0x36, 0x19, 0x08, 0x7c, 0x20,
	0x64, 0x72, 0x5d, 0xcb, 0x3b, 0x1b, 0xb5, 0xf8, 0xb6, 0xdd, 0xcf, 0x77, 0xed, 0xae, 0x9d, 0x27,
	0xae, 0xd6, 0xe8, 0x94, 0xec, 0xc8, 0x86, 0xac, 0x82, 0x74, 0xe6, 0xad, 0x68, 0x59, 0xdb, 0xf1,
	0x2c, 0x7b, 0x30, 0x5c, 0x8a, 0x7b, 0x51, 0x71, 0x6c, 0xf4, 0xac, 0x8e, 0xe1, 0x99, 0x4b, 0x35,
	0xbb, 0xa6, 0x5a, 0xe6, 0x85, 0x1e, 0xc9, 0x73, 0x47, 0x28, 0xf5, 0x95, 0xd1, 0x16, 0x3b, 0x1d,
	0xd7, 0x1c, 0x0e, 0xb5, 0x6f, 0x1d, 0x93, 0xcd, 0x22, 0xba, 0x6f, 0xb4, 0xd3, 0x90, 0x85, 0x83,
	0xdd, 0x52, 0xea, 0x7e, 0x0a, 0xd4, 0xaf, 0x7f, 0x5d, 0xd3, 0x3b, 0x2e, 0xfd, 0x0b, 0x80, 0xba,
	0x90, 0xb8, 0x22, 0x7a, 0x2e, 0x3b, 0xe3, 0x62, 0x38, 0xf4, 0x0a, 0xc5, 0x8d, 0x4e, 0xc7, 0x5d,
	0xa6, 0x92, 0xab, 0x54, 0xdc, 0x8d, 0x5d, 0x82, 0x4a, 0x24, 0xee, 0x04, 0xa5, 0x16, 0xa9, 0xfa,
	0xa8, 0x35, 0x30, 0x3d, 0x12, 0xda, 0x47, 0x09, 0xc7, 0x35, 0x4f, 0xad, 0xcb, 0xed, 0xb1, 0xa5,
	0xb8, 0xa8, 0xed, 0xf4, 0xcc, 0x41, 0x3a, 0x96, 0x85, 0x83, 0x64, 0xc8, 0x74, 0x18, 0x4b, 0x67,
	0x55, 0x22, 0x71, 0x1f, 0x13, 0x22, 0x21, 0x4c, 0xc4, 0x45, 0x88, 0xc2, 0x73, 0x4c, 0x60, 0x85,
	0xf4, 0x0d, 0x41, 0x12, 0x42, 0x48, 0xef, 0xae, 0x21, 0xad, 0xe7, 0x56, 0x4c, 0x5c, 0x84, 0xe9,
	0xd1, 0x75, 0x48, 0xa7, 0x27, 0xb0, 0x84, 0xfa, 0x09, 0x50, 0x52, 0x76, 0xc2, 0x4c, 0x45, 0x14,
	0xb7, 0x9c, 0x71, 0x91, 0xd4, 0x7e, 0x76, 0x84, 0xf9, 0xc8, 0x67, 0xc1, 0xaf, 0x9d, 0xe9, 0x31,
	0xa5, 0x12, 0xf7, 0x32, 0x25, 0x90, 0x5e, 0x5b, 0x53, 0xc2, 0x66, 0x4a, 0xf8, 0x24, 0xfe, 0xf7,
	0xa7, 0x50, 0x28, 0xbd, 0x40, 0xf4, 0xd8, 0x74, 0xd9, 0xe7, 0xd7, 0x53, 0x80, 0xd9, 0x14, 0x68,
	0x7f, 0x0a, 0xf4, 0x47, 0x1f, 0x1c, 0x7d, 0x11, 0x7f, 0x4a, 0x33, 0x71, 0xee, 0x47, 0x40, 0x6f,
	0xc8, 0x4e, 0x68, 0xfc, 0x42, 0x04, 0xf0, 0xed, 0x2d, 0x80, 0x8f, 0xe6, 0x07, 0xbe, 0x42, 0x84,
	0x6f, 0x4b, 0x48, 0xd8, 0x08, 0xfd, 0x3f, 0xbc, 0x63, 0x94, 0xaa, 0x91, 0xe3, 0x56, 0xac, 0x61,
	0xc0, 0x27, 0x84, 0xae, 0x87, 0x3e, 0xd8, 0x2d, 0xe1, 0xd5, 0xc1, 0xa3, 0x2b, 0x78, 0xc2, 0xed,
	0xb8, 0xf4, 0x3d, 0xc0, 0x62, 0x9b, 0xb8, 0x02, 0x9a, 0x99, 0xc4, 0x56, 0xd7, 0x75, 0xf8, 0x3b,
	0x8d, 0xd8, 0xa6, 0xe5, 0x7a, 0x23, 0xa3, 0x57, 0x31, 0xbd, 0x0b, 0xdb, 0x3d, 0x27, 0xe5, 0x30,
	0xca, 0x34, 0x65, 0x55, 0x6b, 0x88, 0x8a, 0x5e, 0x91, 0xb4, 0xaf, 0xab, 0xea, 0x97, 0x7a, 0x5d,
	0xd6, 0x24, 0x5d, 0xa9, 0x96, 0x45, 0x85, 0xa1, 0xd8, 0x7d, 0xf4, 0xea, 0xdf, 0x75, 0x5d, 0xae,
	0xd4, 0xe5, 0xd7, 0x12, 0x03, 0xec, 0x1e, 0x4a, 0xaf, 0xdb, 0x6a, 0x92, 0x4a, 0xac, 0x4c, 0x8c,
	0x7d, 0x07, 0xbd, 0xd8, 0x50, 0x1b, 0x25, 0x45, 0x2e, 0x33, 0x74, 0x86, 0x9e, 0x7c, 0x07, 0x6c,
	0x66, 0xd3, 0xf0, 0xb9, 0x52, 0x2d, 0x89, 0x0a, 0x13, 0x67, 0xb3, 0x68, 0x6f, 0x2b, 0x41, 0x5d,
	0x52, 0x9b, 0x72, 0x59, 0x62, 0x76, 0xd8, 0xfd, 0x4d, 0x47, 0x53, 0x52, 0x75, 0xb9, 0xa2, 0x49,
	0x6a, 0x45, 0x54, 0x98, 0x44, 0xd0, 0x24, 0x87, 0xde, 0xff, 0xcf, 0x51, 0xf4, 0x6a, 0x43, 0x23,
	0x23, 0x3d, 0x61, 0xb3, 0xe8, 0xe5, 0xba, 0x5d, 0xae, 0xe9, 0x62, 0x43, 0xab, 0x32, 0x4f, 0x83,
	0x82, 0x1f, 0xa2, 0xf7, 0x36, 0xfa, 0x56, 0x15, 0x4d, 0x7c, 0x5d, 0xd1, 0x6b, 0xaa, 0xdc, 0x14,
	0x35, 0x69, 0xf5, 0x3f, 0xb3, 0x1b, 0x24, 0xb6, 0x90, 0xd6, 0xd5, 0xa6, 0xf0, 0x60, 0x43, 0x81,
	0x8d, 0x43, 0x6f, 0x6e, 0x69, 0xfd, 0x99, 0x58, 0x52, 0xe5, 0x32, 0xf3, 0x8c, 0x78, 0x4a, 0xdf,
	0xc3, 0xec, 0x16, 0x53, 0x37, 0xb7, 0x98, 0xba, 0xbb, 0xc5, 0x30, 0xf1, 0x31, 0xfc, 0xec, 0x63,
	0xf8, 0xcd, 0xc7, 0x30, 0xf3, 0x31, 0xdc, 0xf8, 0x18, 0xfe, 0xf0, 0x31, 0xfc, 0xe9, 0x63, 0xea,
	0xce, 0xc7, 0xf0, 0xc3, 0x1c, 0x53, 0xd7, 0x73, 0x0c, 0xb3, 0x39, 0xa6, 0x6e, 0xe6, 0x98, 0x3a,
	0x29, 0x77, 0x6d, 0xe7, 0xbc, 0xcb, 0x8f, 0xed, 0x9e, 0x67, 0xba, 0xae, 0xc1, 0x8f, 0x86, 0x79,
	0xb2, 0x38, 0xb5, 0xdd, 0x7e, 0xce, 0x71, 0xed, 0xb1, 0xd5, 0x31, 0xdd, 0xdc, 0x4a, 0xce, 0x3b,
	0xad, 0xae, 0x9d, 0x37, 0x2f, 0xbd, 0xe5, 0x2b, 0x1a, 0xfc, 0xb4, 0x12, 0xe4, 0x01, 0x2d, 0xfc,
	0x13, 0x00, 0x00, 0xff, 0xff, 0x0c, 0x77, 0xd7, 0x85, 0xf6, 0x05, 0x00, 0x00,
}

func (x VirtualNetworkType) String() string {
	s, ok := VirtualNetworkType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *MacAddressType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MacAddressType)
	if !ok {
		that2, ok := that.(MacAddressType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mac != that1.Mac {
		return false
	}
	return true
}
func (this *Ipv4AddressType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ipv4AddressType)
	if !ok {
		that2, ok := that.(Ipv4AddressType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Addr != that1.Addr {
		return false
	}
	return true
}
func (this *Ipv4SubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ipv4SubnetType)
	if !ok {
		that2, ok := that.(Ipv4SubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Prefix != that1.Prefix {
		return false
	}
	if this.Plen != that1.Plen {
		return false
	}
	return true
}
func (this *Ipv6AddressType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ipv6AddressType)
	if !ok {
		that2, ok := that.(Ipv6AddressType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Addr != that1.Addr {
		return false
	}
	return true
}
func (this *Ipv6SubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ipv6SubnetType)
	if !ok {
		that2, ok := that.(Ipv6SubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Prefix != that1.Prefix {
		return false
	}
	if this.Plen != that1.Plen {
		return false
	}
	return true
}
func (this *IpAddressType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpAddressType)
	if !ok {
		that2, ok := that.(IpAddressType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Ver == nil {
		if this.Ver != nil {
			return false
		}
	} else if this.Ver == nil {
		return false
	} else if !this.Ver.Equal(that1.Ver) {
		return false
	}
	return true
}
func (this *IpAddressType_Ipv4) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpAddressType_Ipv4)
	if !ok {
		that2, ok := that.(IpAddressType_Ipv4)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv4.Equal(that1.Ipv4) {
		return false
	}
	return true
}
func (this *IpAddressType_Ipv6) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpAddressType_Ipv6)
	if !ok {
		that2, ok := that.(IpAddressType_Ipv6)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv6.Equal(that1.Ipv6) {
		return false
	}
	return true
}
func (this *IpSubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpSubnetType)
	if !ok {
		that2, ok := that.(IpSubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Ver == nil {
		if this.Ver != nil {
			return false
		}
	} else if this.Ver == nil {
		return false
	} else if !this.Ver.Equal(that1.Ver) {
		return false
	}
	return true
}
func (this *IpSubnetType_Ipv4) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpSubnetType_Ipv4)
	if !ok {
		that2, ok := that.(IpSubnetType_Ipv4)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv4.Equal(that1.Ipv4) {
		return false
	}
	return true
}
func (this *IpSubnetType_Ipv6) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpSubnetType_Ipv6)
	if !ok {
		that2, ok := that.(IpSubnetType_Ipv6)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv6.Equal(that1.Ipv6) {
		return false
	}
	return true
}
func (this *PrefixListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PrefixListType)
	if !ok {
		that2, ok := that.(PrefixListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Prefix) != len(that1.Prefix) {
		return false
	}
	for i := range this.Prefix {
		if this.Prefix[i] != that1.Prefix[i] {
			return false
		}
	}
	return true
}
func (this *MacAddressType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.MacAddressType{")
	s = append(s, "Mac: "+fmt.Sprintf("%#v", this.Mac)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Ipv4AddressType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.Ipv4AddressType{")
	s = append(s, "Addr: "+fmt.Sprintf("%#v", this.Addr)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Ipv4SubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.Ipv4SubnetType{")
	s = append(s, "Prefix: "+fmt.Sprintf("%#v", this.Prefix)+",\n")
	s = append(s, "Plen: "+fmt.Sprintf("%#v", this.Plen)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Ipv6AddressType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.Ipv6AddressType{")
	s = append(s, "Addr: "+fmt.Sprintf("%#v", this.Addr)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Ipv6SubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.Ipv6SubnetType{")
	s = append(s, "Prefix: "+fmt.Sprintf("%#v", this.Prefix)+",\n")
	s = append(s, "Plen: "+fmt.Sprintf("%#v", this.Plen)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IpAddressType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.IpAddressType{")
	if this.Ver != nil {
		s = append(s, "Ver: "+fmt.Sprintf("%#v", this.Ver)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IpAddressType_Ipv4) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.IpAddressType_Ipv4{` +
		`Ipv4:` + fmt.Sprintf("%#v", this.Ipv4) + `}`}, ", ")
	return s
}
func (this *IpAddressType_Ipv6) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.IpAddressType_Ipv6{` +
		`Ipv6:` + fmt.Sprintf("%#v", this.Ipv6) + `}`}, ", ")
	return s
}
func (this *IpSubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.IpSubnetType{")
	if this.Ver != nil {
		s = append(s, "Ver: "+fmt.Sprintf("%#v", this.Ver)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IpSubnetType_Ipv4) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.IpSubnetType_Ipv4{` +
		`Ipv4:` + fmt.Sprintf("%#v", this.Ipv4) + `}`}, ", ")
	return s
}
func (this *IpSubnetType_Ipv6) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.IpSubnetType_Ipv6{` +
		`Ipv6:` + fmt.Sprintf("%#v", this.Ipv6) + `}`}, ", ")
	return s
}
func (this *PrefixListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.PrefixListType{")
	s = append(s, "Prefix: "+fmt.Sprintf("%#v", this.Prefix)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringNet(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *MacAddressType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MacAddressType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MacAddressType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Mac) > 0 {
		i -= len(m.Mac)
		copy(dAtA[i:], m.Mac)
		i = encodeVarintNet(dAtA, i, uint64(len(m.Mac)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Ipv4AddressType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ipv4AddressType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ipv4AddressType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintNet(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Ipv4SubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ipv4SubnetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ipv4SubnetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Plen != 0 {
		i = encodeVarintNet(dAtA, i, uint64(m.Plen))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintNet(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Ipv6AddressType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ipv6AddressType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ipv6AddressType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintNet(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Ipv6SubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ipv6SubnetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ipv6SubnetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Plen != 0 {
		i = encodeVarintNet(dAtA, i, uint64(m.Plen))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintNet(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IpAddressType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpAddressType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpAddressType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ver != nil {
		{
			size := m.Ver.Size()
			i -= size
			if _, err := m.Ver.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *IpAddressType_Ipv4) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpAddressType_Ipv4) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ipv4 != nil {
		{
			size, err := m.Ipv4.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *IpAddressType_Ipv6) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpAddressType_Ipv6) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ipv6 != nil {
		{
			size, err := m.Ipv6.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *IpSubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpSubnetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpSubnetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ver != nil {
		{
			size := m.Ver.Size()
			i -= size
			if _, err := m.Ver.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *IpSubnetType_Ipv4) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpSubnetType_Ipv4) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ipv4 != nil {
		{
			size, err := m.Ipv4.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *IpSubnetType_Ipv6) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpSubnetType_Ipv6) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ipv6 != nil {
		{
			size, err := m.Ipv6.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PrefixListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrefixListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrefixListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Prefix) > 0 {
		for iNdEx := len(m.Prefix) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Prefix[iNdEx])
			copy(dAtA[i:], m.Prefix[iNdEx])
			i = encodeVarintNet(dAtA, i, uint64(len(m.Prefix[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintNet(dAtA []byte, offset int, v uint64) int {
	offset -= sovNet(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MacAddressType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Mac)
	if l > 0 {
		n += 1 + l + sovNet(uint64(l))
	}
	return n
}

func (m *Ipv4AddressType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovNet(uint64(l))
	}
	return n
}

func (m *Ipv4SubnetType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovNet(uint64(l))
	}
	if m.Plen != 0 {
		n += 1 + sovNet(uint64(m.Plen))
	}
	return n
}

func (m *Ipv6AddressType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovNet(uint64(l))
	}
	return n
}

func (m *Ipv6SubnetType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovNet(uint64(l))
	}
	if m.Plen != 0 {
		n += 1 + sovNet(uint64(m.Plen))
	}
	return n
}

func (m *IpAddressType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != nil {
		n += m.Ver.Size()
	}
	return n
}

func (m *IpAddressType_Ipv4) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipv4 != nil {
		l = m.Ipv4.Size()
		n += 1 + l + sovNet(uint64(l))
	}
	return n
}
func (m *IpAddressType_Ipv6) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipv6 != nil {
		l = m.Ipv6.Size()
		n += 1 + l + sovNet(uint64(l))
	}
	return n
}
func (m *IpSubnetType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != nil {
		n += m.Ver.Size()
	}
	return n
}

func (m *IpSubnetType_Ipv4) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipv4 != nil {
		l = m.Ipv4.Size()
		n += 1 + l + sovNet(uint64(l))
	}
	return n
}
func (m *IpSubnetType_Ipv6) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipv6 != nil {
		l = m.Ipv6.Size()
		n += 1 + l + sovNet(uint64(l))
	}
	return n
}
func (m *PrefixListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Prefix) > 0 {
		for _, s := range m.Prefix {
			l = len(s)
			n += 1 + l + sovNet(uint64(l))
		}
	}
	return n
}

func sovNet(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNet(x uint64) (n int) {
	return sovNet(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *MacAddressType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MacAddressType{`,
		`Mac:` + fmt.Sprintf("%v", this.Mac) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Ipv4AddressType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Ipv4AddressType{`,
		`Addr:` + fmt.Sprintf("%v", this.Addr) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Ipv4SubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Ipv4SubnetType{`,
		`Prefix:` + fmt.Sprintf("%v", this.Prefix) + `,`,
		`Plen:` + fmt.Sprintf("%v", this.Plen) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Ipv6AddressType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Ipv6AddressType{`,
		`Addr:` + fmt.Sprintf("%v", this.Addr) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Ipv6SubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Ipv6SubnetType{`,
		`Prefix:` + fmt.Sprintf("%v", this.Prefix) + `,`,
		`Plen:` + fmt.Sprintf("%v", this.Plen) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpAddressType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpAddressType{`,
		`Ver:` + fmt.Sprintf("%v", this.Ver) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpAddressType_Ipv4) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpAddressType_Ipv4{`,
		`Ipv4:` + strings.Replace(fmt.Sprintf("%v", this.Ipv4), "Ipv4AddressType", "Ipv4AddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpAddressType_Ipv6) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpAddressType_Ipv6{`,
		`Ipv6:` + strings.Replace(fmt.Sprintf("%v", this.Ipv6), "Ipv6AddressType", "Ipv6AddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpSubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpSubnetType{`,
		`Ver:` + fmt.Sprintf("%v", this.Ver) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpSubnetType_Ipv4) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpSubnetType_Ipv4{`,
		`Ipv4:` + strings.Replace(fmt.Sprintf("%v", this.Ipv4), "Ipv4SubnetType", "Ipv4SubnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpSubnetType_Ipv6) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpSubnetType_Ipv6{`,
		`Ipv6:` + strings.Replace(fmt.Sprintf("%v", this.Ipv6), "Ipv6SubnetType", "Ipv6SubnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PrefixListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PrefixListType{`,
		`Prefix:` + fmt.Sprintf("%v", this.Prefix) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringNet(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *MacAddressType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MacAddressType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MacAddressType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ipv4AddressType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ipv4AddressType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ipv4AddressType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ipv4SubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ipv4SubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ipv4SubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plen", wireType)
			}
			m.Plen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Plen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ipv6AddressType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ipv6AddressType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ipv6AddressType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ipv6SubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ipv6SubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ipv6SubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plen", wireType)
			}
			m.Plen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Plen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpAddressType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpAddressType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpAddressType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Ipv4AddressType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ver = &IpAddressType_Ipv4{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Ipv6AddressType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ver = &IpAddressType_Ipv6{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpSubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpSubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpSubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Ipv4SubnetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ver = &IpSubnetType_Ipv4{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Ipv6SubnetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ver = &IpSubnetType_Ipv6{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrefixListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrefixListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrefixListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = append(m.Prefix, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNet(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNet
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNet
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNet
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNet
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNet        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNet          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNet = fmt.Errorf("proto: unexpected end of group")
)
