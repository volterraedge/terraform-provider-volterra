// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/api_sec/code_base_integration/types.proto

package code_base_integration

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// HealthStatus
//
// x-displayName: "Health Status"
// Union of all possible Health Status options
type HealthStatus int32

const (
	// x-displayName: "Initializing"
	INITIALIZING HealthStatus = 0
	// x-displayName: "Connected"
	CONNECTED HealthStatus = 1
	// x-displayName: "Disconnected"
	DISCONNECTED HealthStatus = 2
)

var HealthStatus_name = map[int32]string{
	0: "INITIALIZING",
	1: "CONNECTED",
	2: "DISCONNECTED",
}

var HealthStatus_value = map[string]int32{
	"INITIALIZING": 0,
	"CONNECTED":    1,
	"DISCONNECTED": 2,
}

func (HealthStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4809bbd2ddaeb262, []int{0}
}

// GlobalSpecType
//
// x-displayName: "Specification"
// Code Base Integration Specification
type GlobalSpecType struct {
	// Code Base
	//
	// x-displayName: "Integration Data"
	// Choose your code base (e.g. GitHub, GitLab, Bitbucket, Azure) and provide credentials and connection details
	CodeBaseIntegration *CodeBaseIntegration `protobuf:"bytes,1,opt,name=code_base_integration,json=codeBaseIntegration,proto3" json:"code_base_integration,omitempty"`
	// Integration Health
	//
	// x-displayName: "Integration Health Status"
	// x-required
	// Indicates the code base integration health status
	IntegrationHealth *IntegrationHealth `protobuf:"bytes,9,opt,name=integration_health,json=integrationHealth,proto3" json:"integration_health,omitempty"`
	// Number of Repositories
	//
	// x-displayName: "Number of Repositories"
	// Number of repositories found in the code base
	NumberOfRepos int32 `protobuf:"varint,5,opt,name=number_of_repos,json=numberOfRepos,proto3" json:"number_of_repos,omitempty"`
	// Number of API Repositories
	//
	// x-displayName: "Number of API Repositories"
	// Number of API repositories found in the code base
	NumberOfApiRepos int32 `protobuf:"varint,6,opt,name=number_of_api_repos,json=numberOfApiRepos,proto3" json:"number_of_api_repos,omitempty"`
	//    Last Scan
	//
	// x-displayName: "Last Scan"
	// The last time where the coed base was scanned
	UpdatedAt *types.Timestamp `protobuf:"bytes,7,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4809bbd2ddaeb262, []int{0}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetCodeBaseIntegration() *CodeBaseIntegration {
	if m != nil {
		return m.CodeBaseIntegration
	}
	return nil
}

func (m *GlobalSpecType) GetIntegrationHealth() *IntegrationHealth {
	if m != nil {
		return m.IntegrationHealth
	}
	return nil
}

func (m *GlobalSpecType) GetNumberOfRepos() int32 {
	if m != nil {
		return m.NumberOfRepos
	}
	return 0
}

func (m *GlobalSpecType) GetNumberOfApiRepos() int32 {
	if m != nil {
		return m.NumberOfApiRepos
	}
	return 0
}

func (m *GlobalSpecType) GetUpdatedAt() *types.Timestamp {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

// Github Enterprise Integration
//
// x-displayName: "GitHub Enterprise Integration"
type GithubEnterpriseIntegration struct {
	// hostname
	//
	// x-displayName: "GitHub Hostname"
	// x-required
	Hostname string `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// username
	//
	// x-displayName: "GitHub Username"
	// x-required
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	// access_token
	//
	// x-displayName: "GitHub Personal Access Token"
	// x-required
	AccessToken *schema.SecretType `protobuf:"bytes,4,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
}

func (m *GithubEnterpriseIntegration) Reset()      { *m = GithubEnterpriseIntegration{} }
func (*GithubEnterpriseIntegration) ProtoMessage() {}
func (*GithubEnterpriseIntegration) Descriptor() ([]byte, []int) {
	return fileDescriptor_4809bbd2ddaeb262, []int{1}
}
func (m *GithubEnterpriseIntegration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GithubEnterpriseIntegration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GithubEnterpriseIntegration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GithubEnterpriseIntegration.Merge(m, src)
}
func (m *GithubEnterpriseIntegration) XXX_Size() int {
	return m.Size()
}
func (m *GithubEnterpriseIntegration) XXX_DiscardUnknown() {
	xxx_messageInfo_GithubEnterpriseIntegration.DiscardUnknown(m)
}

var xxx_messageInfo_GithubEnterpriseIntegration proto.InternalMessageInfo

func (m *GithubEnterpriseIntegration) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *GithubEnterpriseIntegration) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *GithubEnterpriseIntegration) GetAccessToken() *schema.SecretType {
	if m != nil {
		return m.AccessToken
	}
	return nil
}

// Github Integration
//
// x-displayName: "Github Integration"
type GithubIntegration struct {
	// username
	//
	// x-displayName: "GitHub Username"
	// x-required
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	//  verify_ssl
	//
	// x-displayName: "GitHub Verify SSL"
	VerifySsl bool `protobuf:"varint,3,opt,name=verify_ssl,json=verifySsl,proto3" json:"verify_ssl,omitempty"`
	// access_token
	//
	// x-displayName: "GitHub Personal Access Token"
	// x-required
	AccessToken *schema.SecretType `protobuf:"bytes,4,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
}

func (m *GithubIntegration) Reset()      { *m = GithubIntegration{} }
func (*GithubIntegration) ProtoMessage() {}
func (*GithubIntegration) Descriptor() ([]byte, []int) {
	return fileDescriptor_4809bbd2ddaeb262, []int{2}
}
func (m *GithubIntegration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GithubIntegration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GithubIntegration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GithubIntegration.Merge(m, src)
}
func (m *GithubIntegration) XXX_Size() int {
	return m.Size()
}
func (m *GithubIntegration) XXX_DiscardUnknown() {
	xxx_messageInfo_GithubIntegration.DiscardUnknown(m)
}

var xxx_messageInfo_GithubIntegration proto.InternalMessageInfo

func (m *GithubIntegration) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *GithubIntegration) GetVerifySsl() bool {
	if m != nil {
		return m.VerifySsl
	}
	return false
}

func (m *GithubIntegration) GetAccessToken() *schema.SecretType {
	if m != nil {
		return m.AccessToken
	}
	return nil
}

// GitLab Enterprise Integration
//
// x-displayName: "GitLab Enterprise Integration"
type GitlabEnterpriseIntegration struct {
	// url
	//
	// x-displayName: "GitLab URL"
	// x-required
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// access_token
	//
	// x-displayName: "GitLab Personal Access Token"
	// x-required
	AccessToken *schema.SecretType `protobuf:"bytes,3,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
}

func (m *GitlabEnterpriseIntegration) Reset()      { *m = GitlabEnterpriseIntegration{} }
func (*GitlabEnterpriseIntegration) ProtoMessage() {}
func (*GitlabEnterpriseIntegration) Descriptor() ([]byte, []int) {
	return fileDescriptor_4809bbd2ddaeb262, []int{3}
}
func (m *GitlabEnterpriseIntegration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GitlabEnterpriseIntegration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GitlabEnterpriseIntegration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GitlabEnterpriseIntegration.Merge(m, src)
}
func (m *GitlabEnterpriseIntegration) XXX_Size() int {
	return m.Size()
}
func (m *GitlabEnterpriseIntegration) XXX_DiscardUnknown() {
	xxx_messageInfo_GitlabEnterpriseIntegration.DiscardUnknown(m)
}

var xxx_messageInfo_GitlabEnterpriseIntegration proto.InternalMessageInfo

func (m *GitlabEnterpriseIntegration) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *GitlabEnterpriseIntegration) GetAccessToken() *schema.SecretType {
	if m != nil {
		return m.AccessToken
	}
	return nil
}

// GitLab Cloud Integration
//
// x-displayName: "GitLab Cloud Integration"
type GitlabCloudIntegration struct {
	// access_token
	//
	// x-displayName: "GitLab Personal Access Token"
	// x-required
	AccessToken *schema.SecretType `protobuf:"bytes,2,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
}

func (m *GitlabCloudIntegration) Reset()      { *m = GitlabCloudIntegration{} }
func (*GitlabCloudIntegration) ProtoMessage() {}
func (*GitlabCloudIntegration) Descriptor() ([]byte, []int) {
	return fileDescriptor_4809bbd2ddaeb262, []int{4}
}
func (m *GitlabCloudIntegration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GitlabCloudIntegration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GitlabCloudIntegration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GitlabCloudIntegration.Merge(m, src)
}
func (m *GitlabCloudIntegration) XXX_Size() int {
	return m.Size()
}
func (m *GitlabCloudIntegration) XXX_DiscardUnknown() {
	xxx_messageInfo_GitlabCloudIntegration.DiscardUnknown(m)
}

var xxx_messageInfo_GitlabCloudIntegration proto.InternalMessageInfo

func (m *GitlabCloudIntegration) GetAccessToken() *schema.SecretType {
	if m != nil {
		return m.AccessToken
	}
	return nil
}

// BitBucket Cloud Integration
//
// x-displayName: "BitBucket Cloud Integration"
type BitBucketCloudIntegration struct {
	// username
	//
	// x-displayName: "BitBucket Username"
	// x-required
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	// passwd
	//
	// x-displayName: "BitBucket Password"
	// x-required
	Passwd *schema.SecretType `protobuf:"bytes,3,opt,name=passwd,proto3" json:"passwd,omitempty"`
}

func (m *BitBucketCloudIntegration) Reset()      { *m = BitBucketCloudIntegration{} }
func (*BitBucketCloudIntegration) ProtoMessage() {}
func (*BitBucketCloudIntegration) Descriptor() ([]byte, []int) {
	return fileDescriptor_4809bbd2ddaeb262, []int{5}
}
func (m *BitBucketCloudIntegration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BitBucketCloudIntegration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BitBucketCloudIntegration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BitBucketCloudIntegration.Merge(m, src)
}
func (m *BitBucketCloudIntegration) XXX_Size() int {
	return m.Size()
}
func (m *BitBucketCloudIntegration) XXX_DiscardUnknown() {
	xxx_messageInfo_BitBucketCloudIntegration.DiscardUnknown(m)
}

var xxx_messageInfo_BitBucketCloudIntegration proto.InternalMessageInfo

func (m *BitBucketCloudIntegration) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *BitBucketCloudIntegration) GetPasswd() *schema.SecretType {
	if m != nil {
		return m.Passwd
	}
	return nil
}

// BitBucket Server Integration
//
// x-displayName: "BitBucket Server Integration"
type BitBucketServerIntegration struct {
	// url
	//
	// x-displayName: "BitBucket Server URL"
	// x-required
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// username
	//
	// x-displayName: "BitBucket Server Username"
	// x-required
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	// verify_ssl
	//
	// x-displayName: "Verify SSL"
	VerifySsl bool `protobuf:"varint,4,opt,name=verify_ssl,json=verifySsl,proto3" json:"verify_ssl,omitempty"`
	// passwd
	//
	// x-displayName: "BitBucket Server Password"
	// x-required
	Passwd *schema.SecretType `protobuf:"bytes,5,opt,name=passwd,proto3" json:"passwd,omitempty"`
}

func (m *BitBucketServerIntegration) Reset()      { *m = BitBucketServerIntegration{} }
func (*BitBucketServerIntegration) ProtoMessage() {}
func (*BitBucketServerIntegration) Descriptor() ([]byte, []int) {
	return fileDescriptor_4809bbd2ddaeb262, []int{6}
}
func (m *BitBucketServerIntegration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BitBucketServerIntegration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BitBucketServerIntegration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BitBucketServerIntegration.Merge(m, src)
}
func (m *BitBucketServerIntegration) XXX_Size() int {
	return m.Size()
}
func (m *BitBucketServerIntegration) XXX_DiscardUnknown() {
	xxx_messageInfo_BitBucketServerIntegration.DiscardUnknown(m)
}

var xxx_messageInfo_BitBucketServerIntegration proto.InternalMessageInfo

func (m *BitBucketServerIntegration) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *BitBucketServerIntegration) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *BitBucketServerIntegration) GetVerifySsl() bool {
	if m != nil {
		return m.VerifySsl
	}
	return false
}

func (m *BitBucketServerIntegration) GetPasswd() *schema.SecretType {
	if m != nil {
		return m.Passwd
	}
	return nil
}

// Azure Repos Integration
//
// x-displayName: "Azure Repos Integration"
type AzureReposIntegration struct {
	// access_token
	//
	// x-displayName: "Azure Repos Personal Access Token"
	// x-required
	AccessToken *schema.SecretType `protobuf:"bytes,2,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
}

func (m *AzureReposIntegration) Reset()      { *m = AzureReposIntegration{} }
func (*AzureReposIntegration) ProtoMessage() {}
func (*AzureReposIntegration) Descriptor() ([]byte, []int) {
	return fileDescriptor_4809bbd2ddaeb262, []int{7}
}
func (m *AzureReposIntegration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureReposIntegration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureReposIntegration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureReposIntegration.Merge(m, src)
}
func (m *AzureReposIntegration) XXX_Size() int {
	return m.Size()
}
func (m *AzureReposIntegration) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureReposIntegration.DiscardUnknown(m)
}

var xxx_messageInfo_AzureReposIntegration proto.InternalMessageInfo

func (m *AzureReposIntegration) GetAccessToken() *schema.SecretType {
	if m != nil {
		return m.AccessToken
	}
	return nil
}

// Integration Health
//
// x-displayName: "Code Base Integration Health Status"
type IntegrationHealth struct {
	// Integration Health Status
	//
	// x-displayName: "Health Status"
	HealthStatus HealthStatus `protobuf:"varint,1,opt,name=health_status,json=healthStatus,proto3,enum=ves.io.schema.api_sec.code_base_integration.HealthStatus" json:"health_status,omitempty"`
	// Integration Health Status Reason
	//
	// x-displayName: "Health Status Reason"
	Reason string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *IntegrationHealth) Reset()      { *m = IntegrationHealth{} }
func (*IntegrationHealth) ProtoMessage() {}
func (*IntegrationHealth) Descriptor() ([]byte, []int) {
	return fileDescriptor_4809bbd2ddaeb262, []int{8}
}
func (m *IntegrationHealth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntegrationHealth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IntegrationHealth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntegrationHealth.Merge(m, src)
}
func (m *IntegrationHealth) XXX_Size() int {
	return m.Size()
}
func (m *IntegrationHealth) XXX_DiscardUnknown() {
	xxx_messageInfo_IntegrationHealth.DiscardUnknown(m)
}

var xxx_messageInfo_IntegrationHealth proto.InternalMessageInfo

func (m *IntegrationHealth) GetHealthStatus() HealthStatus {
	if m != nil {
		return m.HealthStatus
	}
	return INITIALIZING
}

func (m *IntegrationHealth) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// Code Base
//
// x-displayName: "Integration Data"
// Choose your code base (e.g. GitHub, GitLab, Bitbucket, Azure) and provide credentials and connection details
type CodeBaseIntegration struct {
	// Code Base
	//
	// x-displayName: "Code Base"
	// x-required
	// Select the type of code base you want to integrate with such as GitHub, GitLab, Bitbucket or Azure.
	//
	// Types that are valid to be assigned to Type:
	//	*CodeBaseIntegration_Github
	//	*CodeBaseIntegration_GithubEnterprise
	//	*CodeBaseIntegration_Gitlab
	//	*CodeBaseIntegration_GitlabEnterprise
	//	*CodeBaseIntegration_Bitbucket
	//	*CodeBaseIntegration_BitbucketServer
	//	*CodeBaseIntegration_AzureRepos
	Type isCodeBaseIntegration_Type `protobuf_oneof:"type"`
}

func (m *CodeBaseIntegration) Reset()      { *m = CodeBaseIntegration{} }
func (*CodeBaseIntegration) ProtoMessage() {}
func (*CodeBaseIntegration) Descriptor() ([]byte, []int) {
	return fileDescriptor_4809bbd2ddaeb262, []int{9}
}
func (m *CodeBaseIntegration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CodeBaseIntegration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CodeBaseIntegration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CodeBaseIntegration.Merge(m, src)
}
func (m *CodeBaseIntegration) XXX_Size() int {
	return m.Size()
}
func (m *CodeBaseIntegration) XXX_DiscardUnknown() {
	xxx_messageInfo_CodeBaseIntegration.DiscardUnknown(m)
}

var xxx_messageInfo_CodeBaseIntegration proto.InternalMessageInfo

type isCodeBaseIntegration_Type interface {
	isCodeBaseIntegration_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CodeBaseIntegration_Github struct {
	Github *GithubIntegration `protobuf:"bytes,2,opt,name=github,proto3,oneof" json:"github,omitempty"`
}
type CodeBaseIntegration_GithubEnterprise struct {
	GithubEnterprise *GithubEnterpriseIntegration `protobuf:"bytes,3,opt,name=github_enterprise,json=githubEnterprise,proto3,oneof" json:"github_enterprise,omitempty"`
}
type CodeBaseIntegration_Gitlab struct {
	Gitlab *GitlabCloudIntegration `protobuf:"bytes,4,opt,name=gitlab,proto3,oneof" json:"gitlab,omitempty"`
}
type CodeBaseIntegration_GitlabEnterprise struct {
	GitlabEnterprise *GitlabEnterpriseIntegration `protobuf:"bytes,5,opt,name=gitlab_enterprise,json=gitlabEnterprise,proto3,oneof" json:"gitlab_enterprise,omitempty"`
}
type CodeBaseIntegration_Bitbucket struct {
	Bitbucket *BitBucketCloudIntegration `protobuf:"bytes,6,opt,name=bitbucket,proto3,oneof" json:"bitbucket,omitempty"`
}
type CodeBaseIntegration_BitbucketServer struct {
	BitbucketServer *BitBucketServerIntegration `protobuf:"bytes,7,opt,name=bitbucket_server,json=bitbucketServer,proto3,oneof" json:"bitbucket_server,omitempty"`
}
type CodeBaseIntegration_AzureRepos struct {
	AzureRepos *AzureReposIntegration `protobuf:"bytes,8,opt,name=azure_repos,json=azureRepos,proto3,oneof" json:"azure_repos,omitempty"`
}

func (*CodeBaseIntegration_Github) isCodeBaseIntegration_Type()           {}
func (*CodeBaseIntegration_GithubEnterprise) isCodeBaseIntegration_Type() {}
func (*CodeBaseIntegration_Gitlab) isCodeBaseIntegration_Type()           {}
func (*CodeBaseIntegration_GitlabEnterprise) isCodeBaseIntegration_Type() {}
func (*CodeBaseIntegration_Bitbucket) isCodeBaseIntegration_Type()        {}
func (*CodeBaseIntegration_BitbucketServer) isCodeBaseIntegration_Type()  {}
func (*CodeBaseIntegration_AzureRepos) isCodeBaseIntegration_Type()       {}

func (m *CodeBaseIntegration) GetType() isCodeBaseIntegration_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *CodeBaseIntegration) GetGithub() *GithubIntegration {
	if x, ok := m.GetType().(*CodeBaseIntegration_Github); ok {
		return x.Github
	}
	return nil
}

func (m *CodeBaseIntegration) GetGithubEnterprise() *GithubEnterpriseIntegration {
	if x, ok := m.GetType().(*CodeBaseIntegration_GithubEnterprise); ok {
		return x.GithubEnterprise
	}
	return nil
}

func (m *CodeBaseIntegration) GetGitlab() *GitlabCloudIntegration {
	if x, ok := m.GetType().(*CodeBaseIntegration_Gitlab); ok {
		return x.Gitlab
	}
	return nil
}

func (m *CodeBaseIntegration) GetGitlabEnterprise() *GitlabEnterpriseIntegration {
	if x, ok := m.GetType().(*CodeBaseIntegration_GitlabEnterprise); ok {
		return x.GitlabEnterprise
	}
	return nil
}

func (m *CodeBaseIntegration) GetBitbucket() *BitBucketCloudIntegration {
	if x, ok := m.GetType().(*CodeBaseIntegration_Bitbucket); ok {
		return x.Bitbucket
	}
	return nil
}

func (m *CodeBaseIntegration) GetBitbucketServer() *BitBucketServerIntegration {
	if x, ok := m.GetType().(*CodeBaseIntegration_BitbucketServer); ok {
		return x.BitbucketServer
	}
	return nil
}

func (m *CodeBaseIntegration) GetAzureRepos() *AzureReposIntegration {
	if x, ok := m.GetType().(*CodeBaseIntegration_AzureRepos); ok {
		return x.AzureRepos
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CodeBaseIntegration) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CodeBaseIntegration_Github)(nil),
		(*CodeBaseIntegration_GithubEnterprise)(nil),
		(*CodeBaseIntegration_Gitlab)(nil),
		(*CodeBaseIntegration_GitlabEnterprise)(nil),
		(*CodeBaseIntegration_Bitbucket)(nil),
		(*CodeBaseIntegration_BitbucketServer)(nil),
		(*CodeBaseIntegration_AzureRepos)(nil),
	}
}

// GET integration details
//
// x-displayName: "GET Code Base Integration"
// GET code base integration details
type GetSpecType struct {
	CodeBaseIntegration *CodeBaseIntegration `protobuf:"bytes,1,opt,name=code_base_integration,json=codeBaseIntegration,proto3" json:"code_base_integration,omitempty"`
	IntegrationHealth   *IntegrationHealth   `protobuf:"bytes,9,opt,name=integration_health,json=integrationHealth,proto3" json:"integration_health,omitempty"`
	NumberOfRepos       int32                `protobuf:"varint,5,opt,name=number_of_repos,json=numberOfRepos,proto3" json:"number_of_repos,omitempty"`
	NumberOfApiRepos    int32                `protobuf:"varint,6,opt,name=number_of_api_repos,json=numberOfApiRepos,proto3" json:"number_of_api_repos,omitempty"`
	UpdatedAt           *types.Timestamp     `protobuf:"bytes,7,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4809bbd2ddaeb262, []int{10}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetCodeBaseIntegration() *CodeBaseIntegration {
	if m != nil {
		return m.CodeBaseIntegration
	}
	return nil
}

func (m *GetSpecType) GetIntegrationHealth() *IntegrationHealth {
	if m != nil {
		return m.IntegrationHealth
	}
	return nil
}

func (m *GetSpecType) GetNumberOfRepos() int32 {
	if m != nil {
		return m.NumberOfRepos
	}
	return 0
}

func (m *GetSpecType) GetNumberOfApiRepos() int32 {
	if m != nil {
		return m.NumberOfApiRepos
	}
	return 0
}

func (m *GetSpecType) GetUpdatedAt() *types.Timestamp {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

// CREATE integration details
//
// x-displayName: "CREATE Code Base Integration"
// CREATE integration details
type CreateSpecType struct {
	CodeBaseIntegration *CodeBaseIntegration `protobuf:"bytes,1,opt,name=code_base_integration,json=codeBaseIntegration,proto3" json:"code_base_integration,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4809bbd2ddaeb262, []int{11}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetCodeBaseIntegration() *CodeBaseIntegration {
	if m != nil {
		return m.CodeBaseIntegration
	}
	return nil
}

// Replace integration details
//
// x-displayName: "Replace Code Base Integration"
// Replace integration details
type ReplaceSpecType struct {
	CodeBaseIntegration *CodeBaseIntegration `protobuf:"bytes,1,opt,name=code_base_integration,json=codeBaseIntegration,proto3" json:"code_base_integration,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4809bbd2ddaeb262, []int{12}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

func (m *ReplaceSpecType) GetCodeBaseIntegration() *CodeBaseIntegration {
	if m != nil {
		return m.CodeBaseIntegration
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.api_sec.code_base_integration.HealthStatus", HealthStatus_name, HealthStatus_value)
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.api_sec.code_base_integration.GlobalSpecType")
	proto.RegisterType((*GithubEnterpriseIntegration)(nil), "ves.io.schema.api_sec.code_base_integration.GithubEnterpriseIntegration")
	proto.RegisterType((*GithubIntegration)(nil), "ves.io.schema.api_sec.code_base_integration.GithubIntegration")
	proto.RegisterType((*GitlabEnterpriseIntegration)(nil), "ves.io.schema.api_sec.code_base_integration.GitlabEnterpriseIntegration")
	proto.RegisterType((*GitlabCloudIntegration)(nil), "ves.io.schema.api_sec.code_base_integration.GitlabCloudIntegration")
	proto.RegisterType((*BitBucketCloudIntegration)(nil), "ves.io.schema.api_sec.code_base_integration.BitBucketCloudIntegration")
	proto.RegisterType((*BitBucketServerIntegration)(nil), "ves.io.schema.api_sec.code_base_integration.BitBucketServerIntegration")
	proto.RegisterType((*AzureReposIntegration)(nil), "ves.io.schema.api_sec.code_base_integration.AzureReposIntegration")
	proto.RegisterType((*IntegrationHealth)(nil), "ves.io.schema.api_sec.code_base_integration.IntegrationHealth")
	proto.RegisterType((*CodeBaseIntegration)(nil), "ves.io.schema.api_sec.code_base_integration.CodeBaseIntegration")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.api_sec.code_base_integration.GetSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.api_sec.code_base_integration.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.api_sec.code_base_integration.ReplaceSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/api_sec/code_base_integration/types.proto", fileDescriptor_4809bbd2ddaeb262)
}

var fileDescriptor_4809bbd2ddaeb262 = []byte{
	// 1061 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0xcd, 0x6f, 0xe3, 0x44,
	0x14, 0xf7, 0x24, 0x69, 0x48, 0xa6, 0xed, 0xae, 0xeb, 0xaa, 0xab, 0x34, 0x0b, 0xa6, 0xca, 0x01,
	0x2a, 0x48, 0x1d, 0xd1, 0x05, 0x96, 0x45, 0x68, 0x45, 0x93, 0x2d, 0x4d, 0x2a, 0xd4, 0x95, 0x9c,
	0x1e, 0xd0, 0xf2, 0x61, 0x4d, 0x9c, 0x97, 0xc4, 0xaa, 0x93, 0xb1, 0x66, 0xc6, 0x29, 0xe5, 0xc4,
	0x9d, 0x0b, 0x57, 0x3e, 0x24, 0xae, 0x08, 0x21, 0xf1, 0x07, 0xf4, 0x1f, 0x40, 0x9c, 0x7a, 0xac,
	0x38, 0xd1, 0xf4, 0xc2, 0x71, 0xff, 0x04, 0xe4, 0xb1, 0xf3, 0x9d, 0x96, 0x4d, 0x41, 0x5a, 0x0e,
	0xdc, 0xfc, 0xe6, 0xf7, 0xe6, 0xfd, 0xde, 0xc7, 0xbc, 0x37, 0x63, 0x7c, 0xbf, 0x0b, 0xdc, 0x70,
	0x68, 0x81, 0xdb, 0x2d, 0x68, 0x93, 0x02, 0xf1, 0x1c, 0x8b, 0x83, 0x5d, 0xb0, 0x69, 0x1d, 0xac,
	0x1a, 0xe1, 0x60, 0x39, 0x1d, 0x01, 0x4d, 0x46, 0x84, 0x43, 0x3b, 0x05, 0x71, 0xe2, 0x01, 0x37,
	0x3c, 0x46, 0x05, 0xd5, 0x5e, 0x0f, 0x37, 0x1a, 0xe1, 0x46, 0x23, 0xda, 0x68, 0xcc, 0xdc, 0x98,
	0xdd, 0x6a, 0x3a, 0xa2, 0xe5, 0xd7, 0x0c, 0x9b, 0xb6, 0x0b, 0x4d, 0xda, 0xa4, 0x05, 0x69, 0xa3,
	0xe6, 0x37, 0xa4, 0x24, 0x05, 0xf9, 0x15, 0xda, 0xce, 0xae, 0x37, 0x29, 0x6d, 0xba, 0x30, 0xd4,
	0x22, 0x9d, 0x93, 0x08, 0x7a, 0x79, 0x12, 0x12, 0x4e, 0x1b, 0xb8, 0x20, 0x6d, 0x2f, 0x52, 0xb8,
	0x3b, 0x1e, 0x10, 0xf5, 0x02, 0x07, 0x78, 0xdf, 0xf0, 0x38, 0x38, 0x12, 0x4f, 0xf6, 0xc5, 0x71,
	0xa8, 0x4b, 0x5c, 0xa7, 0x4e, 0x04, 0x44, 0xe8, 0xc6, 0x04, 0xea, 0xc0, 0xb1, 0x35, 0x66, 0x3a,
	0xf7, 0x43, 0x1c, 0xdf, 0xda, 0x73, 0x69, 0x8d, 0xb8, 0x55, 0x0f, 0xec, 0xc3, 0x13, 0x0f, 0x34,
	0x81, 0xd7, 0x66, 0xa6, 0x23, 0x83, 0x36, 0xd0, 0xe6, 0xe2, 0xf6, 0xfb, 0xc6, 0x1c, 0x29, 0x34,
	0x4a, 0xb4, 0x0e, 0x45, 0xc2, 0xa1, 0x32, 0x5c, 0x33, 0x57, 0xed, 0xe9, 0x45, 0xad, 0x8d, 0xb5,
	0x91, 0x7d, 0x56, 0x0b, 0x88, 0x2b, 0x5a, 0x99, 0xb4, 0xa4, 0x7c, 0x38, 0x17, 0xe5, 0x88, 0xd5,
	0xb2, 0xb4, 0x62, 0xae, 0x38, 0x93, 0x4b, 0xda, 0x2b, 0xf8, 0x76, 0xc7, 0x6f, 0xd7, 0x80, 0x59,
	0xb4, 0x61, 0x31, 0xf0, 0x28, 0xcf, 0x2c, 0x6c, 0xa0, 0xcd, 0x05, 0x73, 0x39, 0x5c, 0x7e, 0xdc,
	0x30, 0x83, 0x45, 0x6d, 0x0b, 0xaf, 0x0e, 0xf5, 0x02, 0xde, 0x50, 0x37, 0x29, 0x75, 0xd5, 0xbe,
	0xee, 0x8e, 0xe7, 0x84, 0xea, 0x0f, 0x30, 0xf6, 0xbd, 0xa0, 0x00, 0x75, 0x8b, 0x88, 0xcc, 0x0b,
	0xd2, 0xfb, 0xac, 0x11, 0x16, 0xdf, 0xe8, 0x17, 0xdf, 0x38, 0xec, 0x17, 0xdf, 0x4c, 0x47, 0xda,
	0x3b, 0x62, 0x3f, 0x91, 0x8a, 0xa9, 0xf1, 0xfd, 0x44, 0x2a, 0xae, 0x26, 0xf6, 0x13, 0xa9, 0x84,
	0xba, 0xb0, 0x9f, 0x48, 0xa5, 0xd4, 0x74, 0xee, 0x1b, 0x84, 0xef, 0xee, 0xc9, 0x73, 0xb8, 0xdb,
	0x11, 0xc0, 0x3c, 0xe6, 0x8c, 0x27, 0x2e, 0x8b, 0x53, 0x2d, 0xca, 0x45, 0x87, 0xb4, 0x41, 0x56,
	0x28, 0x6d, 0x0e, 0xe4, 0x00, 0xf3, 0x39, 0x30, 0x89, 0xc5, 0x42, 0xac, 0x2f, 0x6b, 0xef, 0xe1,
	0x25, 0x62, 0xdb, 0xc0, 0xb9, 0x25, 0xe8, 0x11, 0x74, 0x32, 0x09, 0xe9, 0xec, 0xfa, 0x44, 0xaa,
	0xab, 0x60, 0x33, 0x10, 0xc1, 0xb9, 0x30, 0x17, 0x43, 0xf5, 0xc3, 0x40, 0x3b, 0xf4, 0x33, 0xf7,
	0x3d, 0xc2, 0x2b, 0xa1, 0x6f, 0x13, 0x1e, 0x0d, 0x58, 0xd1, 0x04, 0xeb, 0xab, 0x18, 0x77, 0x81,
	0x39, 0x8d, 0x13, 0x8b, 0x73, 0x37, 0x13, 0xdf, 0x40, 0x9b, 0xa9, 0x62, 0xea, 0xf7, 0x53, 0x94,
	0x10, 0xcc, 0x07, 0x33, 0x1d, 0x62, 0x55, 0xee, 0xfe, 0x63, 0xf7, 0x62, 0x6a, 0x3c, 0xc7, 0x65,
	0xe6, 0x5c, 0x72, 0x45, 0xe6, 0x54, 0x1c, 0xf7, 0x99, 0x1b, 0xb9, 0x18, 0x7c, 0x4e, 0x91, 0xc6,
	0x6f, 0x40, 0xfa, 0x09, 0xbe, 0x13, 0x92, 0x96, 0x5c, 0xea, 0xd7, 0x47, 0xf9, 0x26, 0xad, 0xc7,
	0xe6, 0xb4, 0x8e, 0xd4, 0x58, 0xce, 0xc3, 0xeb, 0x45, 0x47, 0x14, 0x7d, 0xfb, 0x08, 0xc4, 0x14,
	0xc1, 0x75, 0x89, 0x7f, 0x03, 0x27, 0x3d, 0xc2, 0xf9, 0x71, 0xfd, 0xef, 0x83, 0x8a, 0x14, 0xa3,
	0x78, 0x7e, 0x46, 0x38, 0x3b, 0xa0, 0xac, 0x02, 0xeb, 0x02, 0xbb, 0x3e, 0x89, 0xd7, 0x1d, 0xba,
	0xf1, 0xf2, 0x27, 0xae, 0x2e, 0xff, 0xd0, 0xdd, 0x85, 0x67, 0x77, 0x37, 0x38, 0x92, 0x1f, 0xe3,
	0xb5, 0x9d, 0x2f, 0x7c, 0x06, 0xb2, 0x1f, 0xff, 0xed, 0xec, 0x7f, 0x85, 0xf0, 0xca, 0xd4, 0x78,
	0xd1, 0x3e, 0xc3, 0xcb, 0xe1, 0xb8, 0xb2, 0xb8, 0x20, 0xc2, 0xe7, 0x32, 0x19, 0xb7, 0xb6, 0x1f,
	0xcc, 0x35, 0xb5, 0x42, 0x5b, 0x55, 0x69, 0xc0, 0x5c, 0x6a, 0x8d, 0x48, 0xda, 0x1d, 0x9c, 0x64,
	0x40, 0x38, 0xed, 0x44, 0xe9, 0x8c, 0xa4, 0xdc, 0x4f, 0x49, 0xbc, 0x3a, 0x63, 0xbe, 0x6a, 0x1f,
	0xe1, 0x64, 0x78, 0x71, 0x45, 0x31, 0xce, 0x37, 0x3e, 0xa7, 0xfa, 0xb9, 0xac, 0x98, 0x91, 0x3d,
	0xed, 0x18, 0xaf, 0x84, 0x5f, 0x16, 0x0c, 0x3a, 0x2a, 0x3a, 0x4f, 0xe5, 0x1b, 0x90, 0xcc, 0x6c,
	0xcb, 0xb2, 0x62, 0xaa, 0xcd, 0x09, 0x58, 0xfb, 0x54, 0x86, 0xe4, 0x92, 0x5a, 0x34, 0x07, 0x4a,
	0xf3, 0xb2, 0xcd, 0xe8, 0xc7, 0x28, 0x2e, 0x97, 0xf4, 0xe3, 0x72, 0xc9, 0x58, 0x5c, 0x0b, 0x37,
	0x8b, 0xeb, 0xaa, 0x71, 0x13, 0xc5, 0x35, 0x06, 0x6b, 0x0d, 0x9c, 0xae, 0x39, 0xa2, 0x26, 0x7b,
	0x4b, 0x5e, 0x2a, 0x8b, 0xdb, 0x1f, 0xcc, 0x45, 0x78, 0xe5, 0x30, 0x28, 0x2b, 0xe6, 0xd0, 0xb4,
	0x26, 0xb0, 0x3a, 0x10, 0x2c, 0x2e, 0x9b, 0x38, 0xba, 0x9d, 0xf6, 0x6e, 0x46, 0x37, 0x35, 0x08,
	0xca, 0x8a, 0x79, 0x7b, 0x40, 0x11, 0xa2, 0x1a, 0xe0, 0x45, 0x12, 0xf4, 0x62, 0x74, 0x69, 0xa6,
	0x24, 0x61, 0x71, 0x2e, 0xc2, 0x99, 0xbd, 0x5c, 0x56, 0x4c, 0x4c, 0x06, 0x40, 0xf1, 0x25, 0x9c,
	0x08, 0x9e, 0x44, 0xda, 0xda, 0xd9, 0x29, 0x42, 0xbd, 0x53, 0xb4, 0xbc, 0x9d, 0xbf, 0x97, 0x7f,
	0x33, 0xff, 0x56, 0xfe, 0xed, 0xfc, 0xfd, 0xfc, 0x3b, 0x51, 0xeb, 0xfe, 0x12, 0xc7, 0x8b, 0x7b,
	0x20, 0xfe, 0x7f, 0xe5, 0x3c, 0xd7, 0x57, 0xce, 0xbb, 0x2b, 0xbf, 0x3d, 0x9c, 0x78, 0x6f, 0x5e,
	0xf7, 0xf0, 0xb9, 0x55, 0x62, 0x40, 0x04, 0x3c, 0xdf, 0xa2, 0xcd, 0xf0, 0x39, 0xf7, 0x2d, 0xc2,
	0xb7, 0x4d, 0xf0, 0x5c, 0x62, 0xff, 0xf7, 0x9c, 0x7b, 0x6d, 0x07, 0x2f, 0x8d, 0xde, 0x26, 0x9a,
	0x8a, 0x97, 0x2a, 0x07, 0x95, 0xc3, 0xca, 0xce, 0x87, 0x95, 0x27, 0x95, 0x83, 0x3d, 0x55, 0xd1,
	0x96, 0x71, 0xba, 0xf4, 0xf8, 0xe0, 0x60, 0xb7, 0x74, 0xb8, 0xfb, 0x48, 0x45, 0x81, 0xc2, 0xa3,
	0x4a, 0x75, 0xb8, 0x12, 0x2b, 0x7e, 0x87, 0xce, 0x2e, 0x74, 0xe5, 0xfc, 0x42, 0x57, 0x9e, 0x5e,
	0xe8, 0xe8, 0xcb, 0x9e, 0x8e, 0x7e, 0xec, 0xe9, 0xe8, 0xd7, 0x9e, 0x8e, 0xce, 0x7a, 0x3a, 0x3a,
	0xef, 0xe9, 0xe8, 0x8f, 0x9e, 0x8e, 0xfe, 0xec, 0xe9, 0xca, 0xd3, 0x9e, 0x8e, 0xbe, 0xbe, 0xd4,
	0x95, 0xb3, 0x4b, 0x5d, 0x39, 0xbf, 0xd4, 0x95, 0x27, 0xa4, 0x49, 0xbd, 0xa3, 0xa6, 0xd1, 0xa5,
	0xae, 0x00, 0xc6, 0x88, 0xe1, 0xf3, 0x82, 0xfc, 0x68, 0x50, 0xd6, 0xde, 0xf2, 0x18, 0xed, 0x3a,
	0x75, 0x60, 0x5b, 0x7d, 0xb8, 0xe0, 0xd5, 0x9a, 0xb4, 0x00, 0x9f, 0x8b, 0xe8, 0x17, 0xe5, 0x59,
	0x7e, 0xe8, 0x6a, 0x49, 0x79, 0xc6, 0xee, 0xfd, 0x15, 0x00, 0x00, 0xff, 0xff, 0x41, 0xb0, 0xcd,
	0x85, 0x06, 0x0e, 0x00, 0x00,
}

func (x HealthStatus) String() string {
	s, ok := HealthStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CodeBaseIntegration.Equal(that1.CodeBaseIntegration) {
		return false
	}
	if !this.IntegrationHealth.Equal(that1.IntegrationHealth) {
		return false
	}
	if this.NumberOfRepos != that1.NumberOfRepos {
		return false
	}
	if this.NumberOfApiRepos != that1.NumberOfApiRepos {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	return true
}
func (this *GithubEnterpriseIntegration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GithubEnterpriseIntegration)
	if !ok {
		that2, ok := that.(GithubEnterpriseIntegration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if !this.AccessToken.Equal(that1.AccessToken) {
		return false
	}
	return true
}
func (this *GithubIntegration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GithubIntegration)
	if !ok {
		that2, ok := that.(GithubIntegration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if this.VerifySsl != that1.VerifySsl {
		return false
	}
	if !this.AccessToken.Equal(that1.AccessToken) {
		return false
	}
	return true
}
func (this *GitlabEnterpriseIntegration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GitlabEnterpriseIntegration)
	if !ok {
		that2, ok := that.(GitlabEnterpriseIntegration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if !this.AccessToken.Equal(that1.AccessToken) {
		return false
	}
	return true
}
func (this *GitlabCloudIntegration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GitlabCloudIntegration)
	if !ok {
		that2, ok := that.(GitlabCloudIntegration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AccessToken.Equal(that1.AccessToken) {
		return false
	}
	return true
}
func (this *BitBucketCloudIntegration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BitBucketCloudIntegration)
	if !ok {
		that2, ok := that.(BitBucketCloudIntegration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if !this.Passwd.Equal(that1.Passwd) {
		return false
	}
	return true
}
func (this *BitBucketServerIntegration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BitBucketServerIntegration)
	if !ok {
		that2, ok := that.(BitBucketServerIntegration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if this.VerifySsl != that1.VerifySsl {
		return false
	}
	if !this.Passwd.Equal(that1.Passwd) {
		return false
	}
	return true
}
func (this *AzureReposIntegration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureReposIntegration)
	if !ok {
		that2, ok := that.(AzureReposIntegration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AccessToken.Equal(that1.AccessToken) {
		return false
	}
	return true
}
func (this *IntegrationHealth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IntegrationHealth)
	if !ok {
		that2, ok := that.(IntegrationHealth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HealthStatus != that1.HealthStatus {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	return true
}
func (this *CodeBaseIntegration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CodeBaseIntegration)
	if !ok {
		that2, ok := that.(CodeBaseIntegration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *CodeBaseIntegration_Github) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CodeBaseIntegration_Github)
	if !ok {
		that2, ok := that.(CodeBaseIntegration_Github)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Github.Equal(that1.Github) {
		return false
	}
	return true
}
func (this *CodeBaseIntegration_GithubEnterprise) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CodeBaseIntegration_GithubEnterprise)
	if !ok {
		that2, ok := that.(CodeBaseIntegration_GithubEnterprise)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GithubEnterprise.Equal(that1.GithubEnterprise) {
		return false
	}
	return true
}
func (this *CodeBaseIntegration_Gitlab) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CodeBaseIntegration_Gitlab)
	if !ok {
		that2, ok := that.(CodeBaseIntegration_Gitlab)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Gitlab.Equal(that1.Gitlab) {
		return false
	}
	return true
}
func (this *CodeBaseIntegration_GitlabEnterprise) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CodeBaseIntegration_GitlabEnterprise)
	if !ok {
		that2, ok := that.(CodeBaseIntegration_GitlabEnterprise)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GitlabEnterprise.Equal(that1.GitlabEnterprise) {
		return false
	}
	return true
}
func (this *CodeBaseIntegration_Bitbucket) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CodeBaseIntegration_Bitbucket)
	if !ok {
		that2, ok := that.(CodeBaseIntegration_Bitbucket)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Bitbucket.Equal(that1.Bitbucket) {
		return false
	}
	return true
}
func (this *CodeBaseIntegration_BitbucketServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CodeBaseIntegration_BitbucketServer)
	if !ok {
		that2, ok := that.(CodeBaseIntegration_BitbucketServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BitbucketServer.Equal(that1.BitbucketServer) {
		return false
	}
	return true
}
func (this *CodeBaseIntegration_AzureRepos) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CodeBaseIntegration_AzureRepos)
	if !ok {
		that2, ok := that.(CodeBaseIntegration_AzureRepos)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AzureRepos.Equal(that1.AzureRepos) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CodeBaseIntegration.Equal(that1.CodeBaseIntegration) {
		return false
	}
	if !this.IntegrationHealth.Equal(that1.IntegrationHealth) {
		return false
	}
	if this.NumberOfRepos != that1.NumberOfRepos {
		return false
	}
	if this.NumberOfApiRepos != that1.NumberOfApiRepos {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CodeBaseIntegration.Equal(that1.CodeBaseIntegration) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CodeBaseIntegration.Equal(that1.CodeBaseIntegration) {
		return false
	}
	return true
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&code_base_integration.GlobalSpecType{")
	if this.CodeBaseIntegration != nil {
		s = append(s, "CodeBaseIntegration: "+fmt.Sprintf("%#v", this.CodeBaseIntegration)+",\n")
	}
	if this.IntegrationHealth != nil {
		s = append(s, "IntegrationHealth: "+fmt.Sprintf("%#v", this.IntegrationHealth)+",\n")
	}
	s = append(s, "NumberOfRepos: "+fmt.Sprintf("%#v", this.NumberOfRepos)+",\n")
	s = append(s, "NumberOfApiRepos: "+fmt.Sprintf("%#v", this.NumberOfApiRepos)+",\n")
	if this.UpdatedAt != nil {
		s = append(s, "UpdatedAt: "+fmt.Sprintf("%#v", this.UpdatedAt)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GithubEnterpriseIntegration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&code_base_integration.GithubEnterpriseIntegration{")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	if this.AccessToken != nil {
		s = append(s, "AccessToken: "+fmt.Sprintf("%#v", this.AccessToken)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GithubIntegration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&code_base_integration.GithubIntegration{")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	s = append(s, "VerifySsl: "+fmt.Sprintf("%#v", this.VerifySsl)+",\n")
	if this.AccessToken != nil {
		s = append(s, "AccessToken: "+fmt.Sprintf("%#v", this.AccessToken)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GitlabEnterpriseIntegration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&code_base_integration.GitlabEnterpriseIntegration{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	if this.AccessToken != nil {
		s = append(s, "AccessToken: "+fmt.Sprintf("%#v", this.AccessToken)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GitlabCloudIntegration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&code_base_integration.GitlabCloudIntegration{")
	if this.AccessToken != nil {
		s = append(s, "AccessToken: "+fmt.Sprintf("%#v", this.AccessToken)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BitBucketCloudIntegration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&code_base_integration.BitBucketCloudIntegration{")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	if this.Passwd != nil {
		s = append(s, "Passwd: "+fmt.Sprintf("%#v", this.Passwd)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BitBucketServerIntegration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&code_base_integration.BitBucketServerIntegration{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	s = append(s, "VerifySsl: "+fmt.Sprintf("%#v", this.VerifySsl)+",\n")
	if this.Passwd != nil {
		s = append(s, "Passwd: "+fmt.Sprintf("%#v", this.Passwd)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureReposIntegration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&code_base_integration.AzureReposIntegration{")
	if this.AccessToken != nil {
		s = append(s, "AccessToken: "+fmt.Sprintf("%#v", this.AccessToken)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IntegrationHealth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&code_base_integration.IntegrationHealth{")
	s = append(s, "HealthStatus: "+fmt.Sprintf("%#v", this.HealthStatus)+",\n")
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CodeBaseIntegration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&code_base_integration.CodeBaseIntegration{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CodeBaseIntegration_Github) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&code_base_integration.CodeBaseIntegration_Github{` +
		`Github:` + fmt.Sprintf("%#v", this.Github) + `}`}, ", ")
	return s
}
func (this *CodeBaseIntegration_GithubEnterprise) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&code_base_integration.CodeBaseIntegration_GithubEnterprise{` +
		`GithubEnterprise:` + fmt.Sprintf("%#v", this.GithubEnterprise) + `}`}, ", ")
	return s
}
func (this *CodeBaseIntegration_Gitlab) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&code_base_integration.CodeBaseIntegration_Gitlab{` +
		`Gitlab:` + fmt.Sprintf("%#v", this.Gitlab) + `}`}, ", ")
	return s
}
func (this *CodeBaseIntegration_GitlabEnterprise) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&code_base_integration.CodeBaseIntegration_GitlabEnterprise{` +
		`GitlabEnterprise:` + fmt.Sprintf("%#v", this.GitlabEnterprise) + `}`}, ", ")
	return s
}
func (this *CodeBaseIntegration_Bitbucket) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&code_base_integration.CodeBaseIntegration_Bitbucket{` +
		`Bitbucket:` + fmt.Sprintf("%#v", this.Bitbucket) + `}`}, ", ")
	return s
}
func (this *CodeBaseIntegration_BitbucketServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&code_base_integration.CodeBaseIntegration_BitbucketServer{` +
		`BitbucketServer:` + fmt.Sprintf("%#v", this.BitbucketServer) + `}`}, ", ")
	return s
}
func (this *CodeBaseIntegration_AzureRepos) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&code_base_integration.CodeBaseIntegration_AzureRepos{` +
		`AzureRepos:` + fmt.Sprintf("%#v", this.AzureRepos) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&code_base_integration.GetSpecType{")
	if this.CodeBaseIntegration != nil {
		s = append(s, "CodeBaseIntegration: "+fmt.Sprintf("%#v", this.CodeBaseIntegration)+",\n")
	}
	if this.IntegrationHealth != nil {
		s = append(s, "IntegrationHealth: "+fmt.Sprintf("%#v", this.IntegrationHealth)+",\n")
	}
	s = append(s, "NumberOfRepos: "+fmt.Sprintf("%#v", this.NumberOfRepos)+",\n")
	s = append(s, "NumberOfApiRepos: "+fmt.Sprintf("%#v", this.NumberOfApiRepos)+",\n")
	if this.UpdatedAt != nil {
		s = append(s, "UpdatedAt: "+fmt.Sprintf("%#v", this.UpdatedAt)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&code_base_integration.CreateSpecType{")
	if this.CodeBaseIntegration != nil {
		s = append(s, "CodeBaseIntegration: "+fmt.Sprintf("%#v", this.CodeBaseIntegration)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&code_base_integration.ReplaceSpecType{")
	if this.CodeBaseIntegration != nil {
		s = append(s, "CodeBaseIntegration: "+fmt.Sprintf("%#v", this.CodeBaseIntegration)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IntegrationHealth != nil {
		{
			size, err := m.IntegrationHealth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.NumberOfApiRepos != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NumberOfApiRepos))
		i--
		dAtA[i] = 0x30
	}
	if m.NumberOfRepos != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NumberOfRepos))
		i--
		dAtA[i] = 0x28
	}
	if m.CodeBaseIntegration != nil {
		{
			size, err := m.CodeBaseIntegration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GithubEnterpriseIntegration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GithubEnterpriseIntegration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GithubEnterpriseIntegration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AccessToken != nil {
		{
			size, err := m.AccessToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GithubIntegration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GithubIntegration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GithubIntegration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AccessToken != nil {
		{
			size, err := m.AccessToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.VerifySsl {
		i--
		if m.VerifySsl {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GitlabEnterpriseIntegration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GitlabEnterpriseIntegration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GitlabEnterpriseIntegration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AccessToken != nil {
		{
			size, err := m.AccessToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GitlabCloudIntegration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GitlabCloudIntegration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GitlabCloudIntegration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AccessToken != nil {
		{
			size, err := m.AccessToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *BitBucketCloudIntegration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BitBucketCloudIntegration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BitBucketCloudIntegration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Passwd != nil {
		{
			size, err := m.Passwd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BitBucketServerIntegration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BitBucketServerIntegration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BitBucketServerIntegration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Passwd != nil {
		{
			size, err := m.Passwd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.VerifySsl {
		i--
		if m.VerifySsl {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureReposIntegration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureReposIntegration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureReposIntegration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AccessToken != nil {
		{
			size, err := m.AccessToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *IntegrationHealth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntegrationHealth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntegrationHealth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.HealthStatus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.HealthStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CodeBaseIntegration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CodeBaseIntegration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CodeBaseIntegration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CodeBaseIntegration_Github) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CodeBaseIntegration_Github) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Github != nil {
		{
			size, err := m.Github.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CodeBaseIntegration_GithubEnterprise) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CodeBaseIntegration_GithubEnterprise) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GithubEnterprise != nil {
		{
			size, err := m.GithubEnterprise.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CodeBaseIntegration_Gitlab) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CodeBaseIntegration_Gitlab) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Gitlab != nil {
		{
			size, err := m.Gitlab.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CodeBaseIntegration_GitlabEnterprise) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CodeBaseIntegration_GitlabEnterprise) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GitlabEnterprise != nil {
		{
			size, err := m.GitlabEnterprise.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CodeBaseIntegration_Bitbucket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CodeBaseIntegration_Bitbucket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Bitbucket != nil {
		{
			size, err := m.Bitbucket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *CodeBaseIntegration_BitbucketServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CodeBaseIntegration_BitbucketServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BitbucketServer != nil {
		{
			size, err := m.BitbucketServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *CodeBaseIntegration_AzureRepos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CodeBaseIntegration_AzureRepos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AzureRepos != nil {
		{
			size, err := m.AzureRepos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IntegrationHealth != nil {
		{
			size, err := m.IntegrationHealth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.NumberOfApiRepos != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NumberOfApiRepos))
		i--
		dAtA[i] = 0x30
	}
	if m.NumberOfRepos != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NumberOfRepos))
		i--
		dAtA[i] = 0x28
	}
	if m.CodeBaseIntegration != nil {
		{
			size, err := m.CodeBaseIntegration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CodeBaseIntegration != nil {
		{
			size, err := m.CodeBaseIntegration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CodeBaseIntegration != nil {
		{
			size, err := m.CodeBaseIntegration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CodeBaseIntegration != nil {
		l = m.CodeBaseIntegration.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NumberOfRepos != 0 {
		n += 1 + sovTypes(uint64(m.NumberOfRepos))
	}
	if m.NumberOfApiRepos != 0 {
		n += 1 + sovTypes(uint64(m.NumberOfApiRepos))
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IntegrationHealth != nil {
		l = m.IntegrationHealth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GithubEnterpriseIntegration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AccessToken != nil {
		l = m.AccessToken.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GithubIntegration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VerifySsl {
		n += 2
	}
	if m.AccessToken != nil {
		l = m.AccessToken.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GitlabEnterpriseIntegration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AccessToken != nil {
		l = m.AccessToken.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GitlabCloudIntegration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccessToken != nil {
		l = m.AccessToken.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *BitBucketCloudIntegration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Passwd != nil {
		l = m.Passwd.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *BitBucketServerIntegration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VerifySsl {
		n += 2
	}
	if m.Passwd != nil {
		l = m.Passwd.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AzureReposIntegration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccessToken != nil {
		l = m.AccessToken.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *IntegrationHealth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HealthStatus != 0 {
		n += 1 + sovTypes(uint64(m.HealthStatus))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CodeBaseIntegration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *CodeBaseIntegration_Github) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Github != nil {
		l = m.Github.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CodeBaseIntegration_GithubEnterprise) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GithubEnterprise != nil {
		l = m.GithubEnterprise.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CodeBaseIntegration_Gitlab) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gitlab != nil {
		l = m.Gitlab.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CodeBaseIntegration_GitlabEnterprise) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GitlabEnterprise != nil {
		l = m.GitlabEnterprise.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CodeBaseIntegration_Bitbucket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bitbucket != nil {
		l = m.Bitbucket.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CodeBaseIntegration_BitbucketServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BitbucketServer != nil {
		l = m.BitbucketServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CodeBaseIntegration_AzureRepos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AzureRepos != nil {
		l = m.AzureRepos.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CodeBaseIntegration != nil {
		l = m.CodeBaseIntegration.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NumberOfRepos != 0 {
		n += 1 + sovTypes(uint64(m.NumberOfRepos))
	}
	if m.NumberOfApiRepos != 0 {
		n += 1 + sovTypes(uint64(m.NumberOfApiRepos))
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IntegrationHealth != nil {
		l = m.IntegrationHealth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CodeBaseIntegration != nil {
		l = m.CodeBaseIntegration.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CodeBaseIntegration != nil {
		l = m.CodeBaseIntegration.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`CodeBaseIntegration:` + strings.Replace(this.CodeBaseIntegration.String(), "CodeBaseIntegration", "CodeBaseIntegration", 1) + `,`,
		`NumberOfRepos:` + fmt.Sprintf("%v", this.NumberOfRepos) + `,`,
		`NumberOfApiRepos:` + fmt.Sprintf("%v", this.NumberOfApiRepos) + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`IntegrationHealth:` + strings.Replace(this.IntegrationHealth.String(), "IntegrationHealth", "IntegrationHealth", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GithubEnterpriseIntegration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GithubEnterpriseIntegration{`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`AccessToken:` + strings.Replace(fmt.Sprintf("%v", this.AccessToken), "SecretType", "schema.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GithubIntegration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GithubIntegration{`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`VerifySsl:` + fmt.Sprintf("%v", this.VerifySsl) + `,`,
		`AccessToken:` + strings.Replace(fmt.Sprintf("%v", this.AccessToken), "SecretType", "schema.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GitlabEnterpriseIntegration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GitlabEnterpriseIntegration{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`AccessToken:` + strings.Replace(fmt.Sprintf("%v", this.AccessToken), "SecretType", "schema.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GitlabCloudIntegration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GitlabCloudIntegration{`,
		`AccessToken:` + strings.Replace(fmt.Sprintf("%v", this.AccessToken), "SecretType", "schema.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BitBucketCloudIntegration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BitBucketCloudIntegration{`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`Passwd:` + strings.Replace(fmt.Sprintf("%v", this.Passwd), "SecretType", "schema.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BitBucketServerIntegration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BitBucketServerIntegration{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`VerifySsl:` + fmt.Sprintf("%v", this.VerifySsl) + `,`,
		`Passwd:` + strings.Replace(fmt.Sprintf("%v", this.Passwd), "SecretType", "schema.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureReposIntegration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureReposIntegration{`,
		`AccessToken:` + strings.Replace(fmt.Sprintf("%v", this.AccessToken), "SecretType", "schema.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IntegrationHealth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IntegrationHealth{`,
		`HealthStatus:` + fmt.Sprintf("%v", this.HealthStatus) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CodeBaseIntegration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CodeBaseIntegration{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CodeBaseIntegration_Github) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CodeBaseIntegration_Github{`,
		`Github:` + strings.Replace(fmt.Sprintf("%v", this.Github), "GithubIntegration", "GithubIntegration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CodeBaseIntegration_GithubEnterprise) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CodeBaseIntegration_GithubEnterprise{`,
		`GithubEnterprise:` + strings.Replace(fmt.Sprintf("%v", this.GithubEnterprise), "GithubEnterpriseIntegration", "GithubEnterpriseIntegration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CodeBaseIntegration_Gitlab) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CodeBaseIntegration_Gitlab{`,
		`Gitlab:` + strings.Replace(fmt.Sprintf("%v", this.Gitlab), "GitlabCloudIntegration", "GitlabCloudIntegration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CodeBaseIntegration_GitlabEnterprise) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CodeBaseIntegration_GitlabEnterprise{`,
		`GitlabEnterprise:` + strings.Replace(fmt.Sprintf("%v", this.GitlabEnterprise), "GitlabEnterpriseIntegration", "GitlabEnterpriseIntegration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CodeBaseIntegration_Bitbucket) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CodeBaseIntegration_Bitbucket{`,
		`Bitbucket:` + strings.Replace(fmt.Sprintf("%v", this.Bitbucket), "BitBucketCloudIntegration", "BitBucketCloudIntegration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CodeBaseIntegration_BitbucketServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CodeBaseIntegration_BitbucketServer{`,
		`BitbucketServer:` + strings.Replace(fmt.Sprintf("%v", this.BitbucketServer), "BitBucketServerIntegration", "BitBucketServerIntegration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CodeBaseIntegration_AzureRepos) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CodeBaseIntegration_AzureRepos{`,
		`AzureRepos:` + strings.Replace(fmt.Sprintf("%v", this.AzureRepos), "AzureReposIntegration", "AzureReposIntegration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`CodeBaseIntegration:` + strings.Replace(this.CodeBaseIntegration.String(), "CodeBaseIntegration", "CodeBaseIntegration", 1) + `,`,
		`NumberOfRepos:` + fmt.Sprintf("%v", this.NumberOfRepos) + `,`,
		`NumberOfApiRepos:` + fmt.Sprintf("%v", this.NumberOfApiRepos) + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`IntegrationHealth:` + strings.Replace(this.IntegrationHealth.String(), "IntegrationHealth", "IntegrationHealth", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`CodeBaseIntegration:` + strings.Replace(this.CodeBaseIntegration.String(), "CodeBaseIntegration", "CodeBaseIntegration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`CodeBaseIntegration:` + strings.Replace(this.CodeBaseIntegration.String(), "CodeBaseIntegration", "CodeBaseIntegration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeBaseIntegration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CodeBaseIntegration == nil {
				m.CodeBaseIntegration = &CodeBaseIntegration{}
			}
			if err := m.CodeBaseIntegration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfRepos", wireType)
			}
			m.NumberOfRepos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfRepos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfApiRepos", wireType)
			}
			m.NumberOfApiRepos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfApiRepos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &types.Timestamp{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntegrationHealth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IntegrationHealth == nil {
				m.IntegrationHealth = &IntegrationHealth{}
			}
			if err := m.IntegrationHealth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GithubEnterpriseIntegration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GithubEnterpriseIntegration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GithubEnterpriseIntegration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessToken == nil {
				m.AccessToken = &schema.SecretType{}
			}
			if err := m.AccessToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GithubIntegration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GithubIntegration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GithubIntegration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifySsl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VerifySsl = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessToken == nil {
				m.AccessToken = &schema.SecretType{}
			}
			if err := m.AccessToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GitlabEnterpriseIntegration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GitlabEnterpriseIntegration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GitlabEnterpriseIntegration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessToken == nil {
				m.AccessToken = &schema.SecretType{}
			}
			if err := m.AccessToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GitlabCloudIntegration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GitlabCloudIntegration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GitlabCloudIntegration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessToken == nil {
				m.AccessToken = &schema.SecretType{}
			}
			if err := m.AccessToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BitBucketCloudIntegration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BitBucketCloudIntegration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BitBucketCloudIntegration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passwd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Passwd == nil {
				m.Passwd = &schema.SecretType{}
			}
			if err := m.Passwd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BitBucketServerIntegration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BitBucketServerIntegration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BitBucketServerIntegration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifySsl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VerifySsl = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passwd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Passwd == nil {
				m.Passwd = &schema.SecretType{}
			}
			if err := m.Passwd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureReposIntegration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureReposIntegration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureReposIntegration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessToken == nil {
				m.AccessToken = &schema.SecretType{}
			}
			if err := m.AccessToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntegrationHealth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntegrationHealth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntegrationHealth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthStatus", wireType)
			}
			m.HealthStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HealthStatus |= HealthStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CodeBaseIntegration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CodeBaseIntegration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CodeBaseIntegration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Github", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GithubIntegration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &CodeBaseIntegration_Github{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GithubEnterprise", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GithubEnterpriseIntegration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &CodeBaseIntegration_GithubEnterprise{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gitlab", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GitlabCloudIntegration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &CodeBaseIntegration_Gitlab{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitlabEnterprise", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GitlabEnterpriseIntegration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &CodeBaseIntegration_GitlabEnterprise{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bitbucket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BitBucketCloudIntegration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &CodeBaseIntegration_Bitbucket{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BitbucketServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BitBucketServerIntegration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &CodeBaseIntegration_BitbucketServer{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureRepos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureReposIntegration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &CodeBaseIntegration_AzureRepos{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeBaseIntegration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CodeBaseIntegration == nil {
				m.CodeBaseIntegration = &CodeBaseIntegration{}
			}
			if err := m.CodeBaseIntegration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfRepos", wireType)
			}
			m.NumberOfRepos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfRepos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfApiRepos", wireType)
			}
			m.NumberOfApiRepos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfApiRepos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &types.Timestamp{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntegrationHealth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IntegrationHealth == nil {
				m.IntegrationHealth = &IntegrationHealth{}
			}
			if err := m.IntegrationHealth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeBaseIntegration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CodeBaseIntegration == nil {
				m.CodeBaseIntegration = &CodeBaseIntegration{}
			}
			if err := m.CodeBaseIntegration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeBaseIntegration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CodeBaseIntegration == nil {
				m.CodeBaseIntegration = &CodeBaseIntegration{}
			}
			if err := m.CodeBaseIntegration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
