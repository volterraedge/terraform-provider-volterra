// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package rule_suggestion

import (
	"bytes"
	"context"
	"fmt"
	io "io"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create RuleSuggestionAPI GRPC Client satisfying server.CustomClient
type RuleSuggestionAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient RuleSuggestionAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *RuleSuggestionAPIGrpcClient) doRPCGetSuggestedAPIEndpointProtectionRule(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetSuggestedAPIEndpointProtectionRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.api_sec.rule_suggestion.GetSuggestedAPIEndpointProtectionRuleReq", yamlReq)
	}
	rsp, err := c.grpcClient.GetSuggestedAPIEndpointProtectionRule(ctx, req, opts...)
	return rsp, err
}

func (c *RuleSuggestionAPIGrpcClient) doRPCGetSuggestedOasValidationRule(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetSuggestedOasValidationRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.api_sec.rule_suggestion.GetSuggestedOasValidationRuleReq", yamlReq)
	}
	rsp, err := c.grpcClient.GetSuggestedOasValidationRule(ctx, req, opts...)
	return rsp, err
}

func (c *RuleSuggestionAPIGrpcClient) doRPCGetSuggestedRateLimitRule(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetSuggestedRateLimitRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.api_sec.rule_suggestion.GetSuggestedRateLimitRuleReq", yamlReq)
	}
	rsp, err := c.grpcClient.GetSuggestedRateLimitRule(ctx, req, opts...)
	return rsp, err
}

func (c *RuleSuggestionAPIGrpcClient) doRPCGetSuggestedSensitiveDataRule(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetSuggestedSensitiveDataRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.api_sec.rule_suggestion.GetSuggestedSensitiveDataRuleReq", yamlReq)
	}
	rsp, err := c.grpcClient.GetSuggestedSensitiveDataRule(ctx, req, opts...)
	return rsp, err
}

func (c *RuleSuggestionAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func NewRuleSuggestionAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &RuleSuggestionAPIGrpcClient{
		conn:       cc,
		grpcClient: NewRuleSuggestionAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["GetSuggestedAPIEndpointProtectionRule"] = ccl.doRPCGetSuggestedAPIEndpointProtectionRule

	rpcFns["GetSuggestedOasValidationRule"] = ccl.doRPCGetSuggestedOasValidationRule

	rpcFns["GetSuggestedRateLimitRule"] = ccl.doRPCGetSuggestedRateLimitRule

	rpcFns["GetSuggestedSensitiveDataRule"] = ccl.doRPCGetSuggestedSensitiveDataRule

	ccl.rpcFns = rpcFns

	return ccl
}

// Create RuleSuggestionAPI REST Client satisfying server.CustomClient
type RuleSuggestionAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *RuleSuggestionAPIRestClient) doRPCGetSuggestedAPIEndpointProtectionRule(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetSuggestedAPIEndpointProtectionRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.api_sec.rule_suggestion.GetSuggestedAPIEndpointProtectionRuleReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("method", fmt.Sprintf("%v", req.Method))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("path", fmt.Sprintf("%v", req.Path))
		q.Add("virtual_host_name", fmt.Sprintf("%v", req.VirtualHostName))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetSuggestedAPIEndpointProtectionRuleRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.api_sec.rule_suggestion.GetSuggestedAPIEndpointProtectionRuleRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *RuleSuggestionAPIRestClient) doRPCGetSuggestedOasValidationRule(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetSuggestedOasValidationRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.api_sec.rule_suggestion.GetSuggestedOasValidationRuleReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		for _, item := range req.ApiGroups {
			q.Add("api_groups", fmt.Sprintf("%v", item))
		}
		q.Add("method", fmt.Sprintf("%v", req.Method))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("path", fmt.Sprintf("%v", req.Path))
		q.Add("virtual_host_name", fmt.Sprintf("%v", req.VirtualHostName))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetSuggestedOasValidationRuleRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.api_sec.rule_suggestion.GetSuggestedOasValidationRuleRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *RuleSuggestionAPIRestClient) doRPCGetSuggestedRateLimitRule(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetSuggestedRateLimitRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.api_sec.rule_suggestion.GetSuggestedRateLimitRuleReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("method", fmt.Sprintf("%v", req.Method))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("path", fmt.Sprintf("%v", req.Path))
		q.Add("virtual_host_name", fmt.Sprintf("%v", req.VirtualHostName))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetSuggestedRateLimitRuleRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.api_sec.rule_suggestion.GetSuggestedRateLimitRuleRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *RuleSuggestionAPIRestClient) doRPCGetSuggestedSensitiveDataRule(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetSuggestedSensitiveDataRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.api_sec.rule_suggestion.GetSuggestedSensitiveDataRuleReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("method", fmt.Sprintf("%v", req.Method))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("path", fmt.Sprintf("%v", req.Path))
		q.Add("virtual_host_name", fmt.Sprintf("%v", req.VirtualHostName))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetSuggestedSensitiveDataRuleRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.api_sec.rule_suggestion.GetSuggestedSensitiveDataRuleRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *RuleSuggestionAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewRuleSuggestionAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &RuleSuggestionAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["GetSuggestedAPIEndpointProtectionRule"] = ccl.doRPCGetSuggestedAPIEndpointProtectionRule

	rpcFns["GetSuggestedOasValidationRule"] = ccl.doRPCGetSuggestedOasValidationRule

	rpcFns["GetSuggestedRateLimitRule"] = ccl.doRPCGetSuggestedRateLimitRule

	rpcFns["GetSuggestedSensitiveDataRule"] = ccl.doRPCGetSuggestedSensitiveDataRule

	ccl.rpcFns = rpcFns

	return ccl
}

// Create ruleSuggestionAPIInprocClient

// INPROC Client (satisfying RuleSuggestionAPIClient interface)
type ruleSuggestionAPIInprocClient struct {
	RuleSuggestionAPIServer
}

func (c *ruleSuggestionAPIInprocClient) GetSuggestedAPIEndpointProtectionRule(ctx context.Context, in *GetSuggestedAPIEndpointProtectionRuleReq, opts ...grpc.CallOption) (*GetSuggestedAPIEndpointProtectionRuleRsp, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI.GetSuggestedAPIEndpointProtectionRule")
	return c.RuleSuggestionAPIServer.GetSuggestedAPIEndpointProtectionRule(ctx, in)
}
func (c *ruleSuggestionAPIInprocClient) GetSuggestedOasValidationRule(ctx context.Context, in *GetSuggestedOasValidationRuleReq, opts ...grpc.CallOption) (*GetSuggestedOasValidationRuleRsp, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI.GetSuggestedOasValidationRule")
	return c.RuleSuggestionAPIServer.GetSuggestedOasValidationRule(ctx, in)
}
func (c *ruleSuggestionAPIInprocClient) GetSuggestedRateLimitRule(ctx context.Context, in *GetSuggestedRateLimitRuleReq, opts ...grpc.CallOption) (*GetSuggestedRateLimitRuleRsp, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI.GetSuggestedRateLimitRule")
	return c.RuleSuggestionAPIServer.GetSuggestedRateLimitRule(ctx, in)
}
func (c *ruleSuggestionAPIInprocClient) GetSuggestedSensitiveDataRule(ctx context.Context, in *GetSuggestedSensitiveDataRuleReq, opts ...grpc.CallOption) (*GetSuggestedSensitiveDataRuleRsp, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI.GetSuggestedSensitiveDataRule")
	return c.RuleSuggestionAPIServer.GetSuggestedSensitiveDataRule(ctx, in)
}

func NewRuleSuggestionAPIInprocClient(svc svcfw.Service) RuleSuggestionAPIClient {
	return &ruleSuggestionAPIInprocClient{RuleSuggestionAPIServer: NewRuleSuggestionAPIServer(svc)}
}

// RegisterGwRuleSuggestionAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwRuleSuggestionAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterRuleSuggestionAPIHandlerClient(ctx, mux, NewRuleSuggestionAPIInprocClient(s))
}

// Create ruleSuggestionAPISrv

// SERVER (satisfying RuleSuggestionAPIServer interface)
type ruleSuggestionAPISrv struct {
	svc svcfw.Service
}

func (s *ruleSuggestionAPISrv) GetSuggestedAPIEndpointProtectionRule(ctx context.Context, in *GetSuggestedAPIEndpointProtectionRuleReq) (*GetSuggestedAPIEndpointProtectionRuleRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI")
	cah, ok := ah.(RuleSuggestionAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *RuleSuggestionAPIServer", ah)
	}

	var (
		rsp *GetSuggestedAPIEndpointProtectionRuleRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.api_sec.rule_suggestion.GetSuggestedAPIEndpointProtectionRuleReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'RuleSuggestionAPI.GetSuggestedAPIEndpointProtectionRule' operation on 'rule_suggestion'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI.GetSuggestedAPIEndpointProtectionRule"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetSuggestedAPIEndpointProtectionRule(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.api_sec.rule_suggestion.GetSuggestedAPIEndpointProtectionRuleRsp", rsp)...)

	return rsp, nil
}
func (s *ruleSuggestionAPISrv) GetSuggestedOasValidationRule(ctx context.Context, in *GetSuggestedOasValidationRuleReq) (*GetSuggestedOasValidationRuleRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI")
	cah, ok := ah.(RuleSuggestionAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *RuleSuggestionAPIServer", ah)
	}

	var (
		rsp *GetSuggestedOasValidationRuleRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.api_sec.rule_suggestion.GetSuggestedOasValidationRuleReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'RuleSuggestionAPI.GetSuggestedOasValidationRule' operation on 'rule_suggestion'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI.GetSuggestedOasValidationRule"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetSuggestedOasValidationRule(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.api_sec.rule_suggestion.GetSuggestedOasValidationRuleRsp", rsp)...)

	return rsp, nil
}
func (s *ruleSuggestionAPISrv) GetSuggestedRateLimitRule(ctx context.Context, in *GetSuggestedRateLimitRuleReq) (*GetSuggestedRateLimitRuleRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI")
	cah, ok := ah.(RuleSuggestionAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *RuleSuggestionAPIServer", ah)
	}

	var (
		rsp *GetSuggestedRateLimitRuleRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.api_sec.rule_suggestion.GetSuggestedRateLimitRuleReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'RuleSuggestionAPI.GetSuggestedRateLimitRule' operation on 'rule_suggestion'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI.GetSuggestedRateLimitRule"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetSuggestedRateLimitRule(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.api_sec.rule_suggestion.GetSuggestedRateLimitRuleRsp", rsp)...)

	return rsp, nil
}
func (s *ruleSuggestionAPISrv) GetSuggestedSensitiveDataRule(ctx context.Context, in *GetSuggestedSensitiveDataRuleReq) (*GetSuggestedSensitiveDataRuleRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI")
	cah, ok := ah.(RuleSuggestionAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *RuleSuggestionAPIServer", ah)
	}

	var (
		rsp *GetSuggestedSensitiveDataRuleRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.api_sec.rule_suggestion.GetSuggestedSensitiveDataRuleReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'RuleSuggestionAPI.GetSuggestedSensitiveDataRule' operation on 'rule_suggestion'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI.GetSuggestedSensitiveDataRule"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetSuggestedSensitiveDataRule(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.api_sec.rule_suggestion.GetSuggestedSensitiveDataRuleRsp", rsp)...)

	return rsp, nil
}

func NewRuleSuggestionAPIServer(svc svcfw.Service) RuleSuggestionAPIServer {
	return &ruleSuggestionAPISrv{svc: svc}
}

var RuleSuggestionAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "Application Security Monitoring APIs",
        "description": "APIs to get rule suggestions from App Security Monitoring pages",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/public/namespaces/{namespace}/api_sec/rule_suggestion/api_endpoint_protection": {
            "post": {
                "summary": "Suggest api endpoint protection rule",
                "description": "Suggest API endpoint protection rule for a given path",
                "operationId": "ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI.GetSuggestedAPIEndpointProtectionRule",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/rule_suggestionGetSuggestedAPIEndpointProtectionRuleRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nx-required\nNamespace of the App type for current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rule_suggestionGetSuggestedAPIEndpointProtectionRuleReq"
                        }
                    }
                ],
                "tags": [
                    "RuleSuggestionAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-api_sec-rule_suggestion-rulesuggestionapi-getsuggestedapiendpointprotectionrule"
                },
                "x-ves-proto-rpc": "ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI.GetSuggestedAPIEndpointProtectionRule"
            },
            "x-displayname": "Open API Rule Suggestion API",
            "x-ves-proto-service": "ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/api_sec/rule_suggestion/data_exposure": {
            "post": {
                "summary": "Suggest sensitive data rule",
                "description": "Suggest sensitive data rule for a given path",
                "operationId": "ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI.GetSuggestedSensitiveDataRule",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/rule_suggestionGetSuggestedSensitiveDataRuleRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nx-required\nNamespace of the App type for current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rule_suggestionGetSuggestedSensitiveDataRuleReq"
                        }
                    }
                ],
                "tags": [
                    "RuleSuggestionAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-api_sec-rule_suggestion-rulesuggestionapi-getsuggestedsensitivedatarule"
                },
                "x-ves-proto-rpc": "ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI.GetSuggestedSensitiveDataRule"
            },
            "x-displayname": "Open API Rule Suggestion API",
            "x-ves-proto-service": "ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/api_sec/rule_suggestion/oas_validation": {
            "post": {
                "summary": "Suggest Open API specification validation rule",
                "description": "Suggest Open API specification validation rule for a given path",
                "operationId": "ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI.GetSuggestedOasValidationRule",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/rule_suggestionGetSuggestedOasValidationRuleRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nx-required\nNamespace of the App type for current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rule_suggestionGetSuggestedOasValidationRuleReq"
                        }
                    }
                ],
                "tags": [
                    "RuleSuggestionAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-api_sec-rule_suggestion-rulesuggestionapi-getsuggestedoasvalidationrule"
                },
                "x-ves-proto-rpc": "ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI.GetSuggestedOasValidationRule"
            },
            "x-displayname": "Open API Rule Suggestion API",
            "x-ves-proto-service": "ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/api_sec/rule_suggestion/rate_limit": {
            "post": {
                "summary": "Suggest rate limit rule",
                "description": "Suggest rate limit rule for a given path",
                "operationId": "ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI.GetSuggestedRateLimitRule",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/rule_suggestionGetSuggestedRateLimitRuleRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nx-required\nNamespace of the App type for current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rule_suggestionGetSuggestedRateLimitRuleReq"
                        }
                    }
                ],
                "tags": [
                    "RuleSuggestionAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-api_sec-rule_suggestion-rulesuggestionapi-getsuggestedratelimitrule"
                },
                "x-ves-proto-rpc": "ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI.GetSuggestedRateLimitRule"
            },
            "x-displayname": "Open API Rule Suggestion API",
            "x-ves-proto-service": "ves.io.schema.api_sec.rule_suggestion.RuleSuggestionAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        }
    },
    "definitions": {
        "common_wafAPIEndpointProtectionRule": {
            "type": "object",
            "description": "API Protection Rule for a specific endpoint",
            "title": "API Endpoint Protection Rule",
            "x-displayname": "API Endpoint Protection Rule",
            "x-ves-oneof-field-domain_choice": "[\"any_domain\",\"specific_domain\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.APIEndpointProtectionRule",
            "properties": {
                "action": {
                    "description": " The action to take if the input request matches the rule.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "action",
                    "$ref": "#/definitions/common_wafAPIProtectionRuleAction",
                    "x-displayname": "Rule Action",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "any_domain": {
                    "description": "Exclusive with [specific_domain]\n The rule will apply for all domains.",
                    "title": "any domain",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Any Domain"
                },
                "api_endpoint_method": {
                    "description": " The list of expected values for the HTTP method in the request API. The actual value of the HTTP method is extracted from the HTTP request.\n The predicate evaluates to true if the actual HTTP method belongs is present in the list of expected values.",
                    "title": "method",
                    "$ref": "#/definitions/policyHttpMethodMatcherType",
                    "x-displayname": "HTTP Methods"
                },
                "api_endpoint_path": {
                    "type": "string",
                    "description": " The endpoint (path) of the request.\n\nExample: - \"/endpoint1\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_len: 1024\n  ves.io.schema.rules.string.templated_http_path: true\n",
                    "title": "api endpoint path",
                    "maxLength": 1024,
                    "x-displayname": "API Endpoint",
                    "x-ves-example": "/endpoint1",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_len": "1024",
                        "ves.io.schema.rules.string.templated_http_path": "true"
                    }
                },
                "client_matcher": {
                    "description": " Conditions related to the origin of the request, such as client IP, TLS fingerprint, etc.",
                    "title": "client_matcher",
                    "$ref": "#/definitions/policyClientMatcher",
                    "x-displayname": "Clients"
                },
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "request_matcher": {
                    "description": " Conditions related to the request, such as query parameters, headers, etc.",
                    "title": "request_matcher",
                    "$ref": "#/definitions/policyRequestMatcher",
                    "x-displayname": "Request"
                },
                "specific_domain": {
                    "type": "string",
                    "description": "Exclusive with [any_domain]\n The rule will apply for a specific domain.\n For example: api.example.com\n\nExample: - \"api.example.com\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n  ves.io.schema.rules.string.vh_domain: true\n",
                    "title": "domain",
                    "maxLength": 128,
                    "x-displayname": "Specific Domain",
                    "x-ves-example": "api.example.com",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128",
                        "ves.io.schema.rules.string.vh_domain": "true"
                    }
                }
            }
        },
        "common_wafAPIProtectionRuleAction": {
            "type": "object",
            "description": "The action to take if the input request matches the rule.",
            "title": "API Protection Rule Action",
            "x-displayname": "API Protection Rule Action",
            "x-ves-oneof-field-action": "[\"allow\",\"deny\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.APIProtectionRuleAction",
            "properties": {
                "allow": {
                    "description": "Exclusive with [deny]\n Allow the request to proceed.",
                    "title": "Allow",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Allow"
                },
                "deny": {
                    "description": "Exclusive with [allow]\n Deny the request.",
                    "title": "Deny",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Deny"
                }
            }
        },
        "common_wafApiEndpointDetails": {
            "type": "object",
            "description": "This defines api endpoint",
            "title": "ApiEndpointDetails",
            "x-displayname": "API Endpoint",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.ApiEndpointDetails",
            "properties": {
                "methods": {
                    "type": "array",
                    "description": " Methods to be matched\n\nExample: - \"GET\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.enum.defined_only: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Methods",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemaHttpMethod"
                    },
                    "x-displayname": "Methods",
                    "x-ves-example": "GET",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "path": {
                    "type": "string",
                    "description": " Path to be matched\n\nExample: - \"/api/v1/login\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_len: 1024\n  ves.io.schema.rules.string.templated_http_path: true\n",
                    "title": "Path",
                    "maxLength": 1024,
                    "x-displayname": "Path",
                    "x-ves-example": "/api/v1/login",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_len": "1024",
                        "ves.io.schema.rules.string.templated_http_path": "true"
                    }
                }
            }
        },
        "common_wafApiEndpointRule": {
            "type": "object",
            "title": "ApiEndpointRule",
            "x-displayname": "ApiEndpointRule",
            "x-ves-oneof-field-domain_choice": "[\"any_domain\",\"specific_domain\"]",
            "x-ves-oneof-field-rate_limiter_choice": "[\"inline_rate_limiter\",\"ref_rate_limiter\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.ApiEndpointRule",
            "properties": {
                "any_domain": {
                    "description": "Exclusive with [specific_domain]\n The rule will apply for all domains.",
                    "title": "any domain",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Any Domain"
                },
                "api_endpoint_method": {
                    "description": " The list of expected values for the HTTP method in the request API. The actual value of the HTTP method is extracted from the HTTP request.\n The predicate evaluates to true if the actual HTTP method belongs is present in the list of expected values.",
                    "title": "method",
                    "$ref": "#/definitions/policyHttpMethodMatcherType",
                    "x-displayname": "HTTP Methods"
                },
                "api_endpoint_path": {
                    "type": "string",
                    "description": " The endpoint (path) of the request.\n\nExample: - \"value\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_len: 1024\n  ves.io.schema.rules.string.templated_http_path: true\n",
                    "title": "api endpoint path",
                    "maxLength": 1024,
                    "x-displayname": "API Endpoint",
                    "x-ves-example": "value",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_len": "1024",
                        "ves.io.schema.rules.string.templated_http_path": "true"
                    }
                },
                "client_matcher": {
                    "description": " Conditions related to the origin of the request, such as client IP, TLS fingerprint, etc.",
                    "title": "client_matcher",
                    "$ref": "#/definitions/policyClientMatcher",
                    "x-displayname": "Clients"
                },
                "inline_rate_limiter": {
                    "description": "Exclusive with [ref_rate_limiter]\n Specify rate values for the rule.",
                    "title": "Inline Rate Limiter",
                    "$ref": "#/definitions/common_wafInlineRateLimiter",
                    "x-displayname": "Specific Values"
                },
                "ref_rate_limiter": {
                    "description": "Exclusive with [inline_rate_limiter]\n Select external rate limiter.",
                    "title": "External Rate Limiter",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "External Rate Limiter"
                },
                "request_matcher": {
                    "description": " Conditions related to the request, such as query parameters, headers, etc.",
                    "title": "request_matcher",
                    "$ref": "#/definitions/policyRequestMatcher",
                    "x-displayname": "Request"
                },
                "specific_domain": {
                    "type": "string",
                    "description": "Exclusive with [any_domain]\n The rule will apply for a specific domain.\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n  ves.io.schema.rules.string.vh_domain: true\n",
                    "title": "domain",
                    "maxLength": 128,
                    "x-displayname": "Specific Domain",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128",
                        "ves.io.schema.rules.string.vh_domain": "true"
                    }
                }
            }
        },
        "common_wafCustomFallThroughMode": {
            "type": "object",
            "description": "Define the fall through settings",
            "title": "Custom Fall Through Mode",
            "x-displayname": "Custom Fall Through Mode",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.CustomFallThroughMode",
            "properties": {
                "open_api_validation_rules": {
                    "type": "array",
                    "description": "\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 15\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "title": "Custom Fall Through Rule List",
                    "maxItems": 15,
                    "items": {
                        "$ref": "#/definitions/common_wafFallThroughRule"
                    },
                    "x-displayname": "Custom Fall Through Rule List",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "15",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                }
            }
        },
        "common_wafFallThroughRule": {
            "type": "object",
            "description": "Fall Through Rule for a specific endpoint, base-path, or API group",
            "title": "Fall Through Rule",
            "x-displayname": "Fall Through Rule",
            "x-ves-oneof-field-action_choice": "[\"action_block\",\"action_report\",\"action_skip\"]",
            "x-ves-oneof-field-condition_type_choice": "[\"api_endpoint\",\"api_group\",\"base_path\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.FallThroughRule",
            "properties": {
                "action_block": {
                    "description": "Exclusive with [action_report action_skip]\n Block the request and issue an API security event",
                    "title": "block",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Block"
                },
                "action_report": {
                    "description": "Exclusive with [action_block action_skip]\n Continue processing the request and issue an API security event",
                    "title": "report",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Report"
                },
                "action_skip": {
                    "description": "Exclusive with [action_block action_report]\n Continue processing the request",
                    "title": "skip",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Skip"
                },
                "api_endpoint": {
                    "description": "Exclusive with [api_group base_path]\n The API endpoint (Path + Method) which this validation applies to",
                    "title": "API Endpoint",
                    "$ref": "#/definitions/common_wafApiEndpointDetails",
                    "x-displayname": "API Endpoint"
                },
                "api_group": {
                    "type": "string",
                    "description": "Exclusive with [api_endpoint base_path]\n The API group which this validation applies to\n\nExample: - \"oas-all-operations\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "api_group",
                    "maxLength": 128,
                    "x-displayname": "API Group",
                    "x-ves-example": "oas-all-operations",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "base_path": {
                    "type": "string",
                    "description": "Exclusive with [api_endpoint api_group]\n The base path which this validation applies to\n\nExample: - \"/api/v1\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.http_path: true\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "base path",
                    "maxLength": 128,
                    "x-displayname": "Base Path",
                    "x-ves-example": "/api/v1",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.http_path": "true",
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "common_wafInlineRateLimiter": {
            "type": "object",
            "title": "InlineRateLimiter",
            "x-displayname": "InlineRateLimiter",
            "x-ves-oneof-field-count_by_choice": "[\"ref_user_id\",\"use_http_lb_user_id\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.InlineRateLimiter",
            "properties": {
                "ref_user_id": {
                    "description": "Exclusive with [use_http_lb_user_id]\n A reference to user_identification object.\n The rules in the user_identification object are evaluated to determine the user identifier to be rate limited.\n If traffic cannot be identified by the rules in the user_identification object, by default it will be identified by the HTTP-LB User Identifier.",
                    "title": "ref_user_id",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "User Identification Policy"
                },
                "threshold": {
                    "type": "integer",
                    "description": " The total number of allowed requests for 1 unit (e.g. SECOND/MINUTE/HOUR etc.) of the specified period.\n\nExample: - \"1\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.uint32.gt: 0\n  ves.io.schema.rules.uint32.lte: 8192\n",
                    "title": "threshold",
                    "format": "int64",
                    "x-displayname": "Threshold",
                    "x-ves-example": "1",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.uint32.gt": "0",
                        "ves.io.schema.rules.uint32.lte": "8192"
                    }
                },
                "unit": {
                    "description": " Unit for the period per which the rate limit is applied.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "rate",
                    "$ref": "#/definitions/rate_limiterRateLimitPeriodUnit",
                    "x-displayname": "Duration",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "use_http_lb_user_id": {
                    "description": "Exclusive with [ref_user_id]\n Defined in HTTP-LB Security Configuration -\u003e User Identifier.",
                    "title": "use_http_lb_user_id",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Use HTTP-LB User Identifier"
                }
            }
        },
        "common_wafOpenApiFallThroughMode": {
            "type": "object",
            "description": "x-required\nDetermine what to do with unprotected endpoints (not in the OpenAPI specification file (a.k.a. swagger) or doesn't have a specific rule in custom rules)",
            "title": "Fall Through Mode",
            "x-displayname": "Fall Through Mode",
            "x-ves-oneof-field-fall_through_mode_choice": "[\"fall_through_mode_allow\",\"fall_through_mode_custom\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.OpenApiFallThroughMode",
            "properties": {
                "fall_through_mode_allow": {
                    "description": "Exclusive with [fall_through_mode_custom]\n Allow any unprotected end point",
                    "title": "Allow",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Allow"
                },
                "fall_through_mode_custom": {
                    "description": "Exclusive with [fall_through_mode_allow]\n Custom rules for any unprotected end point",
                    "title": "Custom",
                    "$ref": "#/definitions/common_wafCustomFallThroughMode",
                    "x-displayname": "Custom"
                }
            }
        },
        "common_wafOpenApiValidationAllSpecEndpointsSettings": {
            "type": "object",
            "description": "Settings for API Inventory validation",
            "title": "OpenAPI Validation API Inventory Settings",
            "x-displayname": "API Inventory",
            "x-ves-oneof-field-oversized_body_choice": "[]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.OpenApiValidationAllSpecEndpointsSettings",
            "properties": {
                "fall_through_mode": {
                    "description": " Determine what to do with unprotected endpoints (not part of the API Inventory or doesn't have a specific rule in custom rules)\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Fall Through Mode",
                    "$ref": "#/definitions/common_wafOpenApiFallThroughMode",
                    "x-displayname": "Fall Through Mode",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "settings": {
                    "description": " OpenAPI specification validation settings relevant for \"API Inventory\" enforcement and for \"Custom list\" enforcement",
                    "title": "OpenAPI specification validation common settings",
                    "$ref": "#/definitions/common_wafOpenApiValidationCommonSettings",
                    "x-displayname": "Common Settings"
                },
                "validation_mode": {
                    "description": " Validation mode of OpenAPI specification.\n  When a validation mismatch occurs on a request to one of the API Inventory endpoints\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Validation Mode",
                    "$ref": "#/definitions/common_wafOpenApiValidationMode",
                    "x-displayname": "Validation Mode",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "common_wafOpenApiValidationCommonSettings": {
            "type": "object",
            "description": "OpenAPI specification validation settings relevant for \"API Inventory\" enforcement and for \"Custom list\" enforcement",
            "title": "OpenAPI specification validation common settings",
            "x-displayname": "Common Settings",
            "x-ves-oneof-field-fail_configuration": "[]",
            "x-ves-oneof-field-oversized_body_choice": "[\"oversized_body_fail_validation\",\"oversized_body_skip_validation\"]",
            "x-ves-oneof-field-property_validation_settings_choice": "[\"property_validation_settings_custom\",\"property_validation_settings_default\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.OpenApiValidationCommonSettings",
            "properties": {
                "oversized_body_fail_validation": {
                    "description": "Exclusive with [oversized_body_skip_validation]\n Apply the request/response action (block or report) when the body length is too long to verify (default 64Kb)",
                    "title": "Fail the validation for over-sized body",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Fail Body Validation"
                },
                "oversized_body_skip_validation": {
                    "description": "Exclusive with [oversized_body_fail_validation]\n Skip body validation when the body length is too long to verify (default 64Kb)",
                    "title": "Skip validation for over-sized body",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Skip Body Validation"
                },
                "property_validation_settings_custom": {
                    "description": "Exclusive with [property_validation_settings_default]\n Use custom settings with Open API specification validation",
                    "title": "Custom settings",
                    "$ref": "#/definitions/common_wafValidationPropertySetting",
                    "x-displayname": "Custom"
                },
                "property_validation_settings_default": {
                    "description": "Exclusive with [property_validation_settings_custom]\n Keep the default settings of OpenAPI specification validation",
                    "title": "Default",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Default"
                }
            }
        },
        "common_wafOpenApiValidationMode": {
            "type": "object",
            "description": "x-required\nValidation mode of OpenAPI specification.\n When a validation mismatch occurs on a request to one of the endpoints listed on the OpenAPI specification file (a.k.a. swagger)",
            "title": "Validation Mode",
            "x-displayname": "Validation Mode",
            "x-ves-oneof-field-response_validation_mode_choice": "[\"response_validation_mode_active\",\"skip_response_validation\"]",
            "x-ves-oneof-field-validation_mode_choice": "[\"skip_validation\",\"validation_mode_active\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.OpenApiValidationMode",
            "properties": {
                "response_validation_mode_active": {
                    "description": "Exclusive with [skip_response_validation]\n Enforce OpenAPI validation processing for this event",
                    "title": "Validate",
                    "$ref": "#/definitions/common_wafOpenApiValidationModeActiveResponse",
                    "x-displayname": "Validate"
                },
                "skip_response_validation": {
                    "description": "Exclusive with [response_validation_mode_active]\n Skip OpenAPI validation processing for this event",
                    "title": "Skip",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Skip"
                },
                "skip_validation": {
                    "description": "Exclusive with [validation_mode_active]\n Skip OpenAPI validation processing for this event",
                    "title": "Skip",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Skip"
                },
                "validation_mode_active": {
                    "description": "Exclusive with [skip_validation]\n Enforce OpenAPI validation processing for this event",
                    "title": "Validate",
                    "$ref": "#/definitions/common_wafOpenApiValidationModeActive",
                    "x-displayname": "Validate"
                }
            }
        },
        "common_wafOpenApiValidationModeActive": {
            "type": "object",
            "description": "Validation mode properties of request",
            "title": "Open API Validation Mode Active For Request",
            "x-displayname": "Open API Validation Mode Active",
            "x-ves-oneof-field-validation_enforcement_type": "[\"enforcement_block\",\"enforcement_report\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.OpenApiValidationModeActive",
            "properties": {
                "enforcement_block": {
                    "description": "Exclusive with [enforcement_report]\n Block the request, trigger an API security event",
                    "title": "Block",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Block"
                },
                "enforcement_report": {
                    "description": "Exclusive with [enforcement_block]\n Allow the request, trigger an API security event",
                    "title": "Report",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Report"
                },
                "request_validation_properties": {
                    "type": "array",
                    "description": " List of properties of the request to validate according to the OpenAPI specification file (a.k.a. swagger)\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.enum.defined_only: true\n  ves.io.schema.rules.repeated.items.enum.not_in: [7]\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Request Validation Properties",
                    "minItems": 1,
                    "items": {
                        "$ref": "#/definitions/schemaOpenApiValidationProperties"
                    },
                    "x-displayname": "Request Validation Properties",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.items.enum.not_in": "[7]",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "common_wafOpenApiValidationModeActiveResponse": {
            "type": "object",
            "description": "Validation mode properties of response",
            "title": "Open API Validation Mode Active For Response",
            "x-displayname": "Open API Validation Mode Active",
            "x-ves-oneof-field-validation_enforcement_type": "[\"enforcement_block\",\"enforcement_report\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.OpenApiValidationModeActiveResponse",
            "properties": {
                "enforcement_block": {
                    "description": "Exclusive with [enforcement_report]\n Block the response, trigger an API security event",
                    "title": "Block",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Block"
                },
                "enforcement_report": {
                    "description": "Exclusive with [enforcement_block]\n Allow the response, trigger an API security event",
                    "title": "Report",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Report"
                },
                "response_validation_properties": {
                    "type": "array",
                    "description": " List of properties of the response to validate according to the OpenAPI specification file (a.k.a. swagger)\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.enum.defined_only: true\n  ves.io.schema.rules.repeated.items.enum.in: [2,4,5,7]\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Response Validation Properties",
                    "minItems": 1,
                    "items": {
                        "$ref": "#/definitions/schemaOpenApiValidationProperties"
                    },
                    "x-displayname": "Response Validation Properties",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.items.enum.in": "[2,4,5,7]",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "common_wafOpenApiValidationRule": {
            "type": "object",
            "description": "OpenAPI Validation Rule for a specific endpoint, base-path, or API group",
            "title": "OpenAPI Validation Rule",
            "x-displayname": "OpenAPI Validation Rule",
            "x-ves-oneof-field-condition_type_choice": "[\"api_endpoint\",\"api_group\",\"base_path\"]",
            "x-ves-oneof-field-domain_choice": "[\"any_domain\",\"specific_domain\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.OpenApiValidationRule",
            "properties": {
                "any_domain": {
                    "description": "Exclusive with [specific_domain]\n The rule will apply for all domains.",
                    "title": "any domain",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Any Domain"
                },
                "api_endpoint": {
                    "description": "Exclusive with [api_group base_path]\n The API endpoint (Path + Method) which this validation applies to",
                    "title": "API Endpoint",
                    "$ref": "#/definitions/common_wafApiEndpointDetails",
                    "x-displayname": "API Endpoint"
                },
                "api_group": {
                    "type": "string",
                    "description": "Exclusive with [api_endpoint base_path]\n The API group which this validation applies to\n\nExample: - \"oas-all-operations\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "api_group",
                    "maxLength": 128,
                    "x-displayname": "API Group",
                    "x-ves-example": "oas-all-operations",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "base_path": {
                    "type": "string",
                    "description": "Exclusive with [api_endpoint api_group]\n The base path which this validation applies to\n\nExample: - \"/api/v1\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.http_path: true\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "base path",
                    "maxLength": 128,
                    "x-displayname": "Base Path",
                    "x-ves-example": "/api/v1",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.http_path": "true",
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "specific_domain": {
                    "type": "string",
                    "description": "Exclusive with [any_domain]\n The rule will apply for a specific domain.\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n  ves.io.schema.rules.string.vh_domain: true\n",
                    "title": "domain",
                    "maxLength": 128,
                    "x-displayname": "Specific Domain",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128",
                        "ves.io.schema.rules.string.vh_domain": "true"
                    }
                },
                "validation_mode": {
                    "description": " Validation mode of OpenAPI specification.\n  When a validation mismatch occurs on a request to one of the endpoints listed on the OpenAPI specification file (a.k.a. swagger)\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Validation Mode",
                    "$ref": "#/definitions/common_wafOpenApiValidationMode",
                    "x-displayname": "Validation Mode",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "common_wafValidationPropertySetting": {
            "type": "object",
            "description": "Custom property validation settings",
            "title": "Validation Property settings",
            "x-displayname": "Validation Property Settings",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.ValidationPropertySetting",
            "properties": {
                "queryParameters": {
                    "description": " Custom settings for query parameters validation",
                    "title": "Query parameters validation settings",
                    "$ref": "#/definitions/common_wafValidationSettingForQueryParameters",
                    "x-displayname": "Validation Settings For Query Parameters"
                }
            }
        },
        "common_wafValidationSettingForHeaders": {
            "type": "object",
            "description": "x-displayName: \"Validation Settings For Headers\"\nCustom settings for headers validation",
            "title": "Validation Settings For Headers",
            "properties": {
                "allow_additional_headers": {
                    "description": "x-displayName: \"Allow\"\nAllow extra headers (on top of what specified in the OAS documentation)",
                    "title": "Allow",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "disallow_additional_headers": {
                    "description": "x-displayName: \"Disallow\"\nDisallow extra headers (on top of what specified in the OAS documentation)",
                    "title": "Custom settings",
                    "$ref": "#/definitions/schemaEmpty"
                }
            }
        },
        "common_wafValidationSettingForQueryParameters": {
            "type": "object",
            "description": "Custom settings for query parameters validation",
            "title": "Validation Settings For Query Parameters",
            "x-displayname": "Validation Settings For Query Parameters",
            "x-ves-oneof-field-additional_parameters_choice": "[\"allow_additional_parameters\",\"disallow_additional_parameters\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.ValidationSettingForQueryParameters",
            "properties": {
                "allow_additional_parameters": {
                    "description": "Exclusive with [disallow_additional_parameters]\n Allow extra query parameters (on top of what specified in the OAS documentation)",
                    "title": "Allow",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Allow"
                },
                "disallow_additional_parameters": {
                    "description": "Exclusive with [allow_additional_parameters]\n Disallow extra query parameters (on top of what specified in the OAS documentation)",
                    "title": "Custom settings",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Disallow"
                }
            }
        },
        "http_loadbalancerBodySectionMaskingOptions": {
            "type": "object",
            "description": "Options for HTTP Body Masking",
            "title": "Body Section Masking Options",
            "x-displayname": "Body Section Masking Options",
            "x-ves-proto-message": "ves.io.schema.views.http_loadbalancer.BodySectionMaskingOptions",
            "properties": {
                "fields": {
                    "type": "array",
                    "description": " List of JSON Path field values. Use square brackets with an underscore [_] to indicate array elements (e.g., person.emails[_]). To reference JSON keys that contain spaces, enclose the entire path in double quotes. For example: \"person.first name\".\n\nExample: - \"['user.email', 'credit_card']\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.string.json_path: true\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.min_bytes: 1\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Field Values",
                    "minItems": 1,
                    "maxItems": 16,
                    "items": {
                        "type": "string",
                        "minLength": 1,
                        "maxLength": 256
                    },
                    "x-displayname": "Values",
                    "x-ves-example": "['user.email', 'credit_card']",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.string.json_path": "true",
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.min_bytes": "1",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "http_loadbalancerSensitiveDataTypes": {
            "type": "object",
            "description": "Settings to mask sensitive data in request/response payload",
            "title": "Sensitive Data Types",
            "x-displayname": "Sensitive Data Types",
            "x-ves-oneof-field-masking_mode_choice": "[\"mask\",\"report\"]",
            "x-ves-oneof-field-type_condition_type_choice": "[\"api_endpoint\"]",
            "x-ves-proto-message": "ves.io.schema.views.http_loadbalancer.SensitiveDataTypes",
            "properties": {
                "api_endpoint": {
                    "description": "Exclusive with []\n The API endpoint (Path + Method) which this validation applies to",
                    "title": "API Endpoint",
                    "$ref": "#/definitions/common_wafApiEndpointDetails",
                    "x-displayname": "API Endpoint"
                },
                "body": {
                    "title": "Body Section Masking Options",
                    "$ref": "#/definitions/http_loadbalancerBodySectionMaskingOptions",
                    "x-displayname": "JSON Path"
                },
                "mask": {
                    "description": "Exclusive with [report]\n",
                    "title": "Masking",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Mask Sensitive Data"
                },
                "report": {
                    "description": "Exclusive with [mask]\n",
                    "title": "Reporting",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Report Sensitive Data"
                }
            }
        },
        "ioschemaObjectRefType": {
            "type": "object",
            "description": "This type establishes a 'direct reference' from one object(the referrer) to another(the referred).\nSuch a reference is in form of tenant/namespace/name for public API and Uid for private API\nThis type of reference is called direct because the relation is explicit and concrete (as opposed\nto selector reference which builds a group based on labels of selectee objects)",
            "title": "ObjectRefType",
            "x-displayname": "Object reference",
            "x-ves-proto-message": "ves.io.schema.ObjectRefType",
            "properties": {
                "kind": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then kind will hold the referred object's kind (e.g. \"route\")\n\nExample: - \"virtual_site\"-",
                    "title": "kind",
                    "x-displayname": "Kind",
                    "x-ves-example": "virtual_site"
                },
                "name": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then name will hold the referred object's(e.g. route's) name.\n\nExample: - \"contactus-route\"-",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "contactus-route"
                },
                "namespace": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then namespace will hold the referred object's(e.g. route's) namespace.\n\nExample: - \"ns1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1"
                },
                "tenant": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then tenant will hold the referred object's(e.g. route's) tenant.\n\nExample: - \"acmecorp\"-",
                    "title": "tenant",
                    "x-displayname": "Tenant",
                    "x-ves-example": "acmecorp"
                },
                "uid": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then uid will hold the referred object's(e.g. route's) uid.\n\nExample: - \"d15f1fad-4d37-48c0-8706-df1824d76d31\"-",
                    "title": "uid",
                    "x-displayname": "UID",
                    "x-ves-example": "d15f1fad-4d37-48c0-8706-df1824d76d31"
                }
            }
        },
        "policyAsnMatchList": {
            "type": "object",
            "description": "An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
            "title": "Asn Match List",
            "x-displayname": "ASN Match List",
            "x-ves-proto-message": "ves.io.schema.policy.AsnMatchList",
            "properties": {
                "as_numbers": {
                    "type": "array",
                    "description": " An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.\n\nExample: - \"[713, 7932, 847325, 4683, 15269, 1000001]\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "as numbers",
                    "minItems": 1,
                    "maxItems": 16,
                    "items": {
                        "type": "integer",
                        "format": "int64"
                    },
                    "x-displayname": "AS Numbers",
                    "x-ves-example": "[713, 7932, 847325, 4683, 15269, 1000001]",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyAsnMatcherType": {
            "type": "object",
            "description": "Match any AS number contained in the list of bgp_asn_sets.",
            "title": "asn matcher type",
            "x-displayname": "ASN Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.AsnMatcherType",
            "properties": {
                "asn_sets": {
                    "type": "array",
                    "description": " A list of references to bgp_asn_set objects.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 4\n",
                    "title": "asn_sets",
                    "maxItems": 4,
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "BGP ASN Sets",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "4"
                    }
                }
            }
        },
        "policyClientMatcher": {
            "type": "object",
            "description": "Client conditions for matching a rule",
            "title": "Client Matcher",
            "x-displayname": "Client Matcher",
            "x-ves-oneof-field-client_choice": "[\"any_client\",\"client_selector\",\"ip_threat_category_list\"]",
            "x-ves-oneof-field-ip_asn_choice": "[\"any_ip\",\"asn_list\",\"asn_matcher\",\"ip_matcher\",\"ip_prefix_list\"]",
            "x-ves-proto-message": "ves.io.schema.policy.ClientMatcher",
            "properties": {
                "any_client": {
                    "description": "Exclusive with [client_selector ip_threat_category_list]\n Any Client",
                    "title": "any ip",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Any Client"
                },
                "any_ip": {
                    "description": "Exclusive with [asn_list asn_matcher ip_matcher ip_prefix_list]\n Any Source IP",
                    "title": "any ip",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Any Source IP"
                },
                "asn_list": {
                    "description": "Exclusive with [any_ip asn_matcher ip_matcher ip_prefix_list]\n List of 4-byte ASN values.\n The predicate evaluates to true if the origin ASN is present in the ASN list.",
                    "title": "asn list",
                    "$ref": "#/definitions/policyAsnMatchList",
                    "x-displayname": "ASN List"
                },
                "asn_matcher": {
                    "description": "Exclusive with [any_ip asn_list ip_matcher ip_prefix_list]\n List of references to BGP ASN Set objects.\n The predicate evaluates to true if the origin ASN is present in one of the BGP ASN Set objects.",
                    "title": "asn matcher",
                    "$ref": "#/definitions/policyAsnMatcherType",
                    "x-displayname": "BGP ASN Sets"
                },
                "client_selector": {
                    "description": "Exclusive with [any_client ip_threat_category_list]\n A label selector that describes the expected set of clients. The labels associated with the client making the API request are used to evaluate the label\n expressions in the selector. These labels can be derived from the client TLS certificate or from the volterra internal control plane.\n This is a more flexible and powerful version of the client name matcher predicate that allows a given rule to be applicable to a set of clients based on the\n client labels rather than being limited to relying on patterns in the client name.\n The predicate evaluates to true if the expressions in the label selector are true for the client labels.",
                    "title": "client selector",
                    "$ref": "#/definitions/schemaLabelSelectorType",
                    "x-displayname": "Group of Clients by Label Selector"
                },
                "ip_matcher": {
                    "description": "Exclusive with [any_ip asn_list asn_matcher ip_prefix_list]\n List of references to IP Prefix Set objects.\n The predicate evaluates to true if the client IP Address is covered by one or more of the IP Prefixes in the IP Prefix Sets.",
                    "title": "ip matcher",
                    "$ref": "#/definitions/policyIpMatcherType",
                    "x-displayname": "IP Prefix Sets"
                },
                "ip_prefix_list": {
                    "description": "Exclusive with [any_ip asn_list asn_matcher ip_matcher]\n List of IP Prefixes values.\n The predicate evaluates to true if the client IP Address is covered by one or more of the IP Prefixes from the list.",
                    "title": "ip prefix list",
                    "$ref": "#/definitions/policyPrefixMatchList",
                    "x-displayname": "IP Prefix List"
                },
                "ip_threat_category_list": {
                    "description": "Exclusive with [any_client client_selector]\n IP threat categories to choose from",
                    "title": "IP Threat Category List",
                    "$ref": "#/definitions/schemapolicyIPThreatCategoryListType",
                    "x-displayname": "List of IP Threat Categories"
                },
                "tls_fingerprint_matcher": {
                    "description": " TLS JA3 fingerprints to be matched.\n The predicate evaluates to true if the TLS fingerprint matches any of the exact values or classes of known TLS fingerprints.",
                    "title": "TLS JA3 fingerprint matcher",
                    "$ref": "#/definitions/policyTlsFingerprintMatcherType",
                    "x-displayname": "TLS Fingerprint Matcher"
                }
            }
        },
        "policyCookieMatcherType": {
            "type": "object",
            "description": "A cookie matcher specifies the name of a single cookie and the criteria to match it. The input has a list of values for each\ncookie in the request.\nA cookie matcher can check for one of the following:\n* Presence or absence of the cookie\n* At least one of the values for the cookie in the request satisfies the MatcherType item",
            "title": "CookieMatcherType",
            "x-displayname": "Cookie Matcher",
            "x-ves-displayorder": "1,6,4",
            "x-ves-oneof-field-match": "[\"check_not_present\",\"check_present\",\"item\"]",
            "x-ves-proto-message": "ves.io.schema.policy.CookieMatcherType",
            "properties": {
                "check_not_present": {
                    "description": "Exclusive with [check_present item]\n Check that the cookie is not present.",
                    "title": "check_not_present",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Not Present"
                },
                "check_present": {
                    "description": "Exclusive with [check_not_present item]\n Check that the cookie is present.",
                    "title": "check_present",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Present"
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert Match of the expression defined",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Matcher"
                },
                "item": {
                    "description": "Exclusive with [check_not_present check_present]\n Criteria for matching the values for the cookie. The match is successful if any of the values in the input satisfies the criteria in the matcher.",
                    "title": "item",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Match Values"
                },
                "name": {
                    "type": "string",
                    "description": " A case-sensitive cookie name.\n\nExample: - \"Session\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "name",
                    "maxLength": 256,
                    "x-displayname": "Cookie Name",
                    "x-ves-example": "Session",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                }
            }
        },
        "policyHttpMethodMatcherType": {
            "type": "object",
            "description": "A http method matcher specifies a list of methods to match an input HTTP method. The match is considered successful if the input method is a member of the list.\nThe result of the match based on the method list is inverted if invert_matcher is true.",
            "title": "HttpMethodMatcherType",
            "x-displayname": "HTTP Method Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.HttpMethodMatcherType",
            "properties": {
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Method Matcher"
                },
                "methods": {
                    "type": "array",
                    "description": " List of methods values to match against.\n\nExample: - \"['GET', 'POST', 'DELETE']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.enum.defined_only: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "methods",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemaHttpMethod"
                    },
                    "x-displayname": "Method List",
                    "x-ves-example": "['GET', 'POST', 'DELETE']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyIPThreatCategory": {
            "type": "string",
            "description": "The IP threat categories to use when a policy based IP threat category is configured.\n\n - SPAM_SOURCES: SPAM_SOURCES\n\n - WINDOWS_EXPLOITS: WINDOWS_EXPLOITS\n\n - WEB_ATTACKS: WEB_ATTACKS\n\n - BOTNETS: BOTNETS\n\n - SCANNERS: SCANNERS\n\n - REPUTATION: REPUTATION\n\n - PHISHING: PHISHING\n\n - PROXY: PROXY\n\n - MOBILE_THREATS: MOBILE_THREATS\n\n - TOR_PROXY: TOR_PROXY\n\n - DENIAL_OF_SERVICE: DENIAL_OF_SERVICE\n\n - NETWORK: NETWORK\n",
            "title": "IP Threat Category",
            "enum": [
                "SPAM_SOURCES",
                "WINDOWS_EXPLOITS",
                "WEB_ATTACKS",
                "BOTNETS",
                "SCANNERS",
                "REPUTATION",
                "PHISHING",
                "PROXY",
                "MOBILE_THREATS",
                "TOR_PROXY",
                "DENIAL_OF_SERVICE",
                "NETWORK"
            ],
            "default": "SPAM_SOURCES",
            "x-displayname": "IP Threat Category",
            "x-ves-proto-enum": "ves.io.schema.policy.IPThreatCategory"
        },
        "policyIpMatcherType": {
            "type": "object",
            "description": "Match any ip prefix contained in the list of ip_prefix_sets.\nThe result of the match is inverted if invert_matcher is true.",
            "title": "ip matcher type",
            "x-displayname": "IP Prefix Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.IpMatcherType",
            "properties": {
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert IP Matcher"
                },
                "prefix_sets": {
                    "type": "array",
                    "description": " A list of references to ip_prefix_set objects.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 4\n",
                    "title": "prefix_sets",
                    "maxItems": 4,
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "IP Prefix Sets",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "4"
                    }
                }
            }
        },
        "policyJWTClaimMatcherType": {
            "type": "object",
            "description": "A JWT claim matcher specifies the name of a single JWT claim and the criteria for the input request to match it.\nThe input has a list of actual values for each JWT claim name in the JWT payload.\nA JWT claim matcher can check for one of the following:\n* Presence or absence of the JWT Claim in the input\n* At least one of the values for the JWT Claim in the input satisfies the MatcherType item",
            "title": "JWTClaimMatcherType",
            "x-displayname": "JWT Claim Matcher",
            "x-ves-displayorder": "1,2,6",
            "x-ves-oneof-field-match": "[\"check_not_present\",\"check_present\",\"item\"]",
            "x-ves-proto-message": "ves.io.schema.policy.JWTClaimMatcherType",
            "properties": {
                "check_not_present": {
                    "description": "Exclusive with [check_present item]\n Check that the JWT Claim is not present.",
                    "title": "check_not_present",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Not Present"
                },
                "check_present": {
                    "description": "Exclusive with [check_not_present item]\n Check that the JWT Claim is present.",
                    "title": "check_present",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Present"
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Matcher"
                },
                "item": {
                    "description": "Exclusive with [check_not_present check_present]\n Criteria for matching the values for the JWT Claim. The match is successful if any of the values in the input satisfies the criteria in the matcher.",
                    "title": "item",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Match Values"
                },
                "name": {
                    "type": "string",
                    "description": " JWT claim name.\n\nExample: - \"user_id\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "name",
                    "maxLength": 256,
                    "x-displayname": "JWT Claim Name",
                    "x-ves-example": "user_id",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                }
            }
        },
        "policyKnownTlsFingerprintClass": {
            "type": "string",
            "description": "Specifies known TLS fingerprint classes\n\n - TLS_FINGERPRINT_NONE: TLS_FINGERPRINT_NONE\n\nNo TLS fingerprint\n - ANY_MALICIOUS_FINGERPRINT: ANY_MALICIOUS_FINGERPRINT\n\nTLS fingerprints known to be associated with malicious clients\n - ADWARE: ADWARE\n\nTLS fingerprints known to be associated with adware\n - ADWIND: ADWIND\n\nTLS fingerprints known to be associated with adwind\n - DRIDEX: DRIDEX\n\nTLS fingerprints known to be associated with dridex\n - GOOTKIT: GOOTKIT\n\nTLS fingerprints known to be associated with gootkit\n - GOZI: GOZI\n\nTLS fingerprints known to be associated with gozi\n - JBIFROST: JBIFROST\n\nTLS fingerprints known to be associated with jbifrost\n - QUAKBOT: QUAKBOT\n\nTLS fingerprints known to be associated with quakbot\n - RANSOMWARE: RANSOMWARE\n\nTLS fingerprints known to be associated with ransomware\n - TROLDESH: TROLDESH\n\nTLS fingerprints known to be associated with troldesh\n - TOFSEE: TOFSEE\n\nTLS fingerprints known to be associated with tofsee\n - TORRENTLOCKER: TORRENTLOCKER\n\nTLS fingerprints known to be associated with torrentlocker\n - TRICKBOT: TRICKBOT\n\nTLS fingerprints known to be associated with trickbot",
            "title": "TLS known fingerprint class",
            "enum": [
                "TLS_FINGERPRINT_NONE",
                "ANY_MALICIOUS_FINGERPRINT",
                "ADWARE",
                "ADWIND",
                "DRIDEX",
                "GOOTKIT",
                "GOZI",
                "JBIFROST",
                "QUAKBOT",
                "RANSOMWARE",
                "TROLDESH",
                "TOFSEE",
                "TORRENTLOCKER",
                "TRICKBOT"
            ],
            "default": "TLS_FINGERPRINT_NONE",
            "x-displayname": "TLS known fingerprint class",
            "x-ves-proto-enum": "ves.io.schema.policy.KnownTlsFingerprintClass"
        },
        "policyMatcherType": {
            "type": "object",
            "description": "A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set\nof supported match criteria includes a list of exact values and a list of regular expressions.",
            "title": "MatcherType",
            "x-displayname": "Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.MatcherType",
            "properties": {
                "exact_values": {
                    "type": "array",
                    "description": " A list of exact values to match the input against.\n\nExample: - \"['new york', 'london', 'sydney', 'tokyo', 'cairo']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "exact values",
                    "maxItems": 64,
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "Exact Values",
                    "x-ves-example": "['new york', 'london', 'sydney', 'tokyo', 'cairo']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "regex_values": {
                    "type": "array",
                    "description": " A list of regular expressions to match the input against.\n\nExample: - \"['^new .*$', 'san f.*', '.* del .*']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.items.string.regex: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "regex values",
                    "maxItems": 16,
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "Regex Values",
                    "x-ves-example": "['^new .*$', 'san f.*', '.* del .*']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.items.string.regex": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "transformers": {
                    "type": "array",
                    "description": " An ordered list of transformers (starting from index 0) to be applied to the path before matching.\n\nExample: - \"[BASE64_DECODE, LOWER_CASE]-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 9\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "transformers",
                    "maxItems": 9,
                    "items": {
                        "$ref": "#/definitions/policyTransformer"
                    },
                    "x-displayname": "Transformers",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "9",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyPrefixMatchList": {
            "type": "object",
            "description": "List of IP Prefix strings to match against.",
            "title": "IP Prefix Match List",
            "x-displayname": "IP Prefix Match List",
            "x-ves-proto-message": "ves.io.schema.policy.PrefixMatchList",
            "properties": {
                "invert_match": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Match Result"
                },
                "ip_prefixes": {
                    "type": "array",
                    "description": " List of IPv4 prefix strings.\n\nExample: - \"192.168.20.0/24\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.ipv4_prefix: true\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "ip prefixes",
                    "maxItems": 128,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv4 Prefix List",
                    "x-ves-example": "192.168.20.0/24",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "ipv6_prefixes": {
                    "type": "array",
                    "description": " List of IPv6 prefix strings.\n\nExample: - \"fd48:fa09:d9d4::/48\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.ipv6_prefix: true\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "ipv6 prefixes",
                    "maxItems": 128,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv6 Prefix List",
                    "x-ves-example": "fd48:fa09:d9d4::/48",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.ipv6_prefix": "true",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyRequestMatcher": {
            "type": "object",
            "description": "Request conditions for matching a rule",
            "title": "Request Matcher",
            "x-displayname": "Request Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.RequestMatcher",
            "properties": {
                "cookie_matchers": {
                    "type": "array",
                    "description": " A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances\n of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.\n Note that all specified cookie matcher predicates must evaluate to true.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n",
                    "title": "cookie matchers",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/policyCookieMatcherType"
                    },
                    "x-displayname": "Cookie Matchers",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16"
                    }
                },
                "headers": {
                    "type": "array",
                    "description": " A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType\n instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.\n Note that all specified header predicates must evaluate to true.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n",
                    "title": "headers",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemapolicyHeaderMatcherType"
                    },
                    "x-displayname": "HTTP Headers",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16"
                    }
                },
                "jwt_claims": {
                    "type": "array",
                    "description": " A list of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType\n instances. The actual JWT claims values are extracted from the JWT payload as a list of strings.\n Note that all specified JWT claim predicates must evaluate to true.\n Note that this feature only works on LBs with JWT Validation feature enabled.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n",
                    "title": "JWT claims",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/policyJWTClaimMatcherType"
                    },
                    "x-displayname": "JWT Claims",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16"
                    }
                },
                "query_params": {
                    "type": "array",
                    "description": " A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances\n of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name.\n Note that all specified query parameter predicates must evaluate to true.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n",
                    "title": "query params",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemapolicyQueryParameterMatcherType"
                    },
                    "x-displayname": "HTTP Query Parameters",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16"
                    }
                }
            }
        },
        "policyTlsFingerprintMatcherType": {
            "type": "object",
            "description": "A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known\nclasses of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input\nfingerprint is not one of the excluded values.",
            "title": "TlsFingerprintMatcherType",
            "x-displayname": "TLS Fingerprint Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.TlsFingerprintMatcherType",
            "properties": {
                "classes": {
                    "type": "array",
                    "description": " A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against.\n\nExample: - \"['ADWARE', 'TRICKBOT']-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "classes",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/policyKnownTlsFingerprintClass"
                    },
                    "x-displayname": "TLS fingerprint classes",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "exact_values": {
                    "type": "array",
                    "description": " A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.\n\nExample: - \"['ed6dfd54b01ebe31b7a65b88abfa7297', '16efcf0e00504ddfedde13bfea997952', 'de364c46b0dfc283b5e38c79ceae3f8f']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.len: 32\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "exact values",
                    "maxItems": 16,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Exact Values",
                    "x-ves-example": "['ed6dfd54b01ebe31b7a65b88abfa7297', '16efcf0e00504ddfedde13bfea997952', 'de364c46b0dfc283b5e38c79ceae3f8f']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.len": "32",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "excluded_values": {
                    "type": "array",
                    "description": " A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one\n or more known TLS fingerprint classes in the enclosing matcher.\n\nExample: - \"['fb00055a1196aeea8d1bc609885ba953', 'b386946a5a44d1ddcc843bc75336dfce']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.len: 32\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "excluded values",
                    "maxItems": 32,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Excluded Values",
                    "x-ves-example": "['fb00055a1196aeea8d1bc609885ba953', 'b386946a5a44d1ddcc843bc75336dfce']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.len": "32",
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyTransformer": {
            "type": "string",
            "description": "Transformers to be applied on the part of the request before matching.\n\n - TRANSFORMER_NONE: transformer none\n\nNo transformers enabled\n - LOWER_CASE: lower case\n\nConvert string to lower case\n - UPPER_CASE: upper case\n\nConvert string to upper case\n - BASE64_DECODE: base64 decode\n\nDecode string assuming base64 encoding\n - NORMALIZE_PATH: normalize path\n\nNormalize URL path so that /a/b/../c will be transformed to /a/c\n - REMOVE_WHITESPACE: remove whitespace\n\nRemove whitespaces\n - URL_DECODE: URL decode\n\nDecode string assuming URL encoding as per rfc1738\n - TRIM_LEFT: trim left\n\nRemove whitespace from the left side of the input string\n - TRIM_RIGHT: trim right\n\nRemove whitespace from the right side of the input string\n - TRIM: trim\n\nRemove whitespace from the both sides of the input string",
            "title": "Transformer",
            "enum": [
                "LOWER_CASE",
                "UPPER_CASE",
                "BASE64_DECODE",
                "NORMALIZE_PATH",
                "REMOVE_WHITESPACE",
                "URL_DECODE",
                "TRIM_LEFT",
                "TRIM_RIGHT",
                "TRIM"
            ],
            "default": "TRANSFORMER_NONE",
            "x-displayname": "Transformer",
            "x-ves-proto-enum": "ves.io.schema.policy.Transformer"
        },
        "rate_limiterRateLimitPeriodUnit": {
            "type": "string",
            "description": "Unit for the period per which the rate limit is applied.\n\n - SECOND: Second\n\nRate limit period unit is seconds\n - MINUTE: Minute\n\nRate limit period unit is minutes\n - HOUR: Hour\n\nRate limit period unit is hours\n - DAY: Day\n\nRate limit period unit is days",
            "title": "RateLimitPeriodUnit",
            "enum": [
                "SECOND",
                "MINUTE",
                "HOUR"
            ],
            "default": "SECOND",
            "x-displayname": "Rate Limit Period Unit",
            "x-ves-proto-enum": "ves.io.schema.rate_limiter.RateLimitPeriodUnit"
        },
        "rule_suggestionGetSuggestedAPIEndpointProtectionRuleReq": {
            "type": "object",
            "description": "Get suggested API endpoint protection rule for a given path",
            "title": "GetSuggestedAPIEndpointProtectionRuleReq",
            "x-displayname": "Get Suggested API endpoint protection Rule Request",
            "x-ves-proto-message": "ves.io.schema.api_sec.rule_suggestion.GetSuggestedAPIEndpointProtectionRuleReq",
            "properties": {
                "method": {
                    "description": " Method to apply the API endpoint protection to\n\nExample: - \"POST\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.enum.defined_only: true\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Method",
                    "$ref": "#/definitions/schemaHttpMethod",
                    "x-displayname": "Request Method",
                    "x-ves-example": "POST",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.enum.defined_only": "true",
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace of the App type for current request\n\nExample: - \"shared\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "shared",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "path": {
                    "type": "string",
                    "description": " Path to apply the API endpoint protection to\n\nExample: - \"/example\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_len: 1024\n  ves.io.schema.rules.string.templated_http_path: true\n",
                    "title": "Path",
                    "maxLength": 1024,
                    "x-displayname": "Request Path",
                    "x-ves-example": "/example",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_len": "1024",
                        "ves.io.schema.rules.string.templated_http_path": "true"
                    }
                },
                "virtual_host_name": {
                    "type": "string",
                    "description": " Virtual Host for which this API endpoint protection rule applied\n\nExample: - \"ves-io-frontend\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Name",
                    "x-displayname": "Virtual Host Name",
                    "x-ves-example": "ves-io-frontend",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "rule_suggestionGetSuggestedAPIEndpointProtectionRuleRsp": {
            "type": "object",
            "description": "Get suggested API endpoint protection rule for a given path",
            "title": "GetSuggestedAPIEndpointProtectionRuleRsp",
            "x-displayname": "Get Suggested API endpoint protection Rule Response",
            "x-ves-proto-message": "ves.io.schema.api_sec.rule_suggestion.GetSuggestedAPIEndpointProtectionRuleRsp",
            "properties": {
                "found_existing_rule": {
                    "description": " Specifies if an existing rule already exists with same conditions",
                    "title": "FoundExistingRule",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Found existing rule"
                },
                "loadbalancer_type": {
                    "description": " The type of load balancer, can be \"http\" or \"cdn\"",
                    "title": "Loadbalancer Type",
                    "$ref": "#/definitions/virtual_hostVirtualHostType",
                    "x-displayname": "Loadbalancer Type"
                },
                "rule": {
                    "description": " Api endpoint protection rule specifies the endpoint to be API endpoint protected",
                    "title": "ApiEndpointRule",
                    "$ref": "#/definitions/common_wafAPIEndpointProtectionRule",
                    "x-displayname": "Api Endpoint Protection Rule"
                }
            }
        },
        "rule_suggestionGetSuggestedOasValidationRuleReq": {
            "type": "object",
            "description": "Get suggested Open API specification validation for a given path",
            "title": "GetSuggestedOasValidationRuleReq",
            "x-displayname": "Get Suggested Open API specification validation Rule Request",
            "x-ves-proto-message": "ves.io.schema.api_sec.rule_suggestion.GetSuggestedOasValidationRuleReq",
            "properties": {
                "api_groups": {
                    "type": "array",
                    "description": " List of API Groups the API Endpoint is a member of.\n\nExample: - [\"group-1\", \"group-2\"]-",
                    "title": "API Groups membership",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "API Groups membership"
                },
                "method": {
                    "description": " Method to apply the Open API specification validation to\n\nExample: - \"POST\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.enum.defined_only: true\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Method",
                    "$ref": "#/definitions/schemaHttpMethod",
                    "x-displayname": "Request Method",
                    "x-ves-example": "POST",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.enum.defined_only": "true",
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace of the App type for current request\n\nExample: - \"shared\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "shared",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "path": {
                    "type": "string",
                    "description": " Path to apply the Open API specification validation to\n\nExample: - \"/example\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_len: 1024\n  ves.io.schema.rules.string.templated_http_path: true\n",
                    "title": "Path",
                    "maxLength": 1024,
                    "x-displayname": "Request Path",
                    "x-ves-example": "/example",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_len": "1024",
                        "ves.io.schema.rules.string.templated_http_path": "true"
                    }
                },
                "virtual_host_name": {
                    "type": "string",
                    "description": " Virtual Host for which this Open API specification validation rule applied\n\nExample: - \"ves-io-frontend\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Name",
                    "x-displayname": "Virtual Host Name",
                    "x-ves-example": "ves-io-frontend",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "rule_suggestionGetSuggestedOasValidationRuleRsp": {
            "type": "object",
            "description": "Get suggested Open API specification validation for a given path",
            "title": "GetSuggestedOasValidationRuleRsp",
            "x-displayname": "Get Suggested Open API specification validation Rule Response",
            "x-ves-oneof-field-api_validation_choice": "[\"all_endpoints_oas_validation\",\"custom_oas_validation\"]",
            "x-ves-proto-message": "ves.io.schema.api_sec.rule_suggestion.GetSuggestedOasValidationRuleRsp",
            "properties": {
                "all_endpoints_oas_validation": {
                    "description": "Exclusive with [custom_oas_validation]\n",
                    "$ref": "#/definitions/common_wafOpenApiValidationAllSpecEndpointsSettings"
                },
                "custom_oas_validation": {
                    "description": "Exclusive with [all_endpoints_oas_validation]\n",
                    "$ref": "#/definitions/common_wafOpenApiValidationRule"
                },
                "found_existing_rule": {
                    "description": " Specifies if an existing rule to block this client already exists with same match conditions",
                    "title": "FoundExistingRule",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Found existing rule"
                },
                "loadbalancer_type": {
                    "description": " The type of load balancer, can be \"http\" or \"cdn\"",
                    "title": "Loadbalancer Type",
                    "$ref": "#/definitions/virtual_hostVirtualHostType",
                    "x-displayname": "Loadbalancer Type"
                }
            }
        },
        "rule_suggestionGetSuggestedRateLimitRuleReq": {
            "type": "object",
            "description": "Get suggested rate limit rule for a given path",
            "title": "GetSuggestedRateLimitRuleReq",
            "x-displayname": "Get Suggested Rate Limit Rule Request",
            "x-ves-proto-message": "ves.io.schema.api_sec.rule_suggestion.GetSuggestedRateLimitRuleReq",
            "properties": {
                "method": {
                    "description": " Method to apply the rate limit to\n\nExample: - \"POST\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.enum.defined_only: true\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Method",
                    "$ref": "#/definitions/schemaHttpMethod",
                    "x-displayname": "Request Method",
                    "x-ves-example": "POST",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.enum.defined_only": "true",
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace of the App type for current request\n\nExample: - \"shared\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "shared",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "path": {
                    "type": "string",
                    "description": " Path to apply the rate limit to\n\nExample: - \"/example\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_len: 1024\n  ves.io.schema.rules.string.templated_http_path: true\n",
                    "title": "Path",
                    "maxLength": 1024,
                    "x-displayname": "Request Path",
                    "x-ves-example": "/example",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_len": "1024",
                        "ves.io.schema.rules.string.templated_http_path": "true"
                    }
                },
                "virtual_host_name": {
                    "type": "string",
                    "description": " Virtual Host for which this rate limit rule applied\n\nExample: - \"ves-io-frontend\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Name",
                    "x-displayname": "Virtual Host Name",
                    "x-ves-example": "ves-io-frontend",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "rule_suggestionGetSuggestedRateLimitRuleRsp": {
            "type": "object",
            "description": "Get suggested rate limit rule for a given path",
            "title": "GetSuggestedRateLimitRuleRsp",
            "x-displayname": "Get Suggested Rate Limit Rule Response",
            "x-ves-proto-message": "ves.io.schema.api_sec.rule_suggestion.GetSuggestedRateLimitRuleRsp",
            "properties": {
                "found_existing_rule": {
                    "description": " Specifies if an existing rule to block this client already exists with same match conditions",
                    "title": "FoundExistingRule",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Found existing rule"
                },
                "loadbalancer_type": {
                    "description": " The type of load balancer, can be \"http\" or \"cdn\"",
                    "title": "Loadbalancer Type",
                    "$ref": "#/definitions/virtual_hostVirtualHostType",
                    "x-displayname": "Loadbalancer Type"
                },
                "rule": {
                    "description": " Api endpoint rule specifies the endpoint to be rate limited",
                    "title": "ApiEndpointRule",
                    "$ref": "#/definitions/common_wafApiEndpointRule",
                    "x-displayname": "Api Endpoint Rule"
                }
            }
        },
        "rule_suggestionGetSuggestedSensitiveDataRuleReq": {
            "type": "object",
            "description": "Get suggested sensitive data rule for a given path",
            "title": "GetSuggestedSensitiveDataRuleReq",
            "x-displayname": "Get Suggested Sensitive Data Rule Request",
            "x-ves-proto-message": "ves.io.schema.api_sec.rule_suggestion.GetSuggestedSensitiveDataRuleReq",
            "properties": {
                "method": {
                    "description": " Method to apply the sensitive data to\n\nExample: - \"POST\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.enum.defined_only: true\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Method",
                    "$ref": "#/definitions/schemaHttpMethod",
                    "x-displayname": "Request Method",
                    "x-ves-example": "POST",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.enum.defined_only": "true",
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace of the App type for current request\n\nExample: - \"shared\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "shared",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "path": {
                    "type": "string",
                    "description": " Path to apply the senstive data to\n\nExample: - \"/example\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_len: 1024\n  ves.io.schema.rules.string.templated_http_path: true\n",
                    "title": "Path",
                    "maxLength": 1024,
                    "x-displayname": "Request Path",
                    "x-ves-example": "/example",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_len": "1024",
                        "ves.io.schema.rules.string.templated_http_path": "true"
                    }
                },
                "virtual_host_name": {
                    "type": "string",
                    "description": " Virtual Host for which this sensitive data rule applied\n\nExample: - \"ves-io-frontend\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Name",
                    "x-displayname": "Virtual Host Name",
                    "x-ves-example": "ves-io-frontend",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "rule_suggestionGetSuggestedSensitiveDataRuleRsp": {
            "type": "object",
            "description": "Get suggested sensitive data rule for a given path",
            "title": "GetSuggestedSensitiveDataRuleRsp",
            "x-displayname": "Get Suggested Sensitive Data Rule Response",
            "x-ves-proto-message": "ves.io.schema.api_sec.rule_suggestion.GetSuggestedSensitiveDataRuleRsp",
            "properties": {
                "found_existing_rule": {
                    "description": " Specifies if an existing rule to block this client already exists with same match conditions",
                    "title": "FoundExistingRule",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Found existing rule"
                },
                "loadbalancer_type": {
                    "description": " The type of load balancer, can be \"http\" or \"cdn\"",
                    "title": "Loadbalancer Type",
                    "$ref": "#/definitions/virtual_hostVirtualHostType",
                    "x-displayname": "Loadbalancer Type"
                },
                "rule": {
                    "description": " Api endpoint rule specifies the endpoint to be handled with sensitive data",
                    "title": "ApiEndpointRule",
                    "$ref": "#/definitions/http_loadbalancerSensitiveDataTypes",
                    "x-displayname": "Api Endpoint Rule"
                }
            }
        },
        "schemaEmpty": {
            "type": "object",
            "description": "This can be used for messages where no values are needed",
            "title": "Empty",
            "x-displayname": "Empty",
            "x-ves-proto-message": "ves.io.schema.Empty"
        },
        "schemaHttpMethod": {
            "type": "string",
            "description": "Specifies the HTTP method used to access a resource.\n\nAny HTTP Method",
            "title": "HttpMethod",
            "enum": [
                "ANY",
                "GET",
                "HEAD",
                "POST",
                "PUT",
                "DELETE",
                "CONNECT",
                "OPTIONS",
                "TRACE",
                "PATCH",
                "COPY"
            ],
            "default": "ANY",
            "x-displayname": "HTTP Method",
            "x-ves-proto-enum": "ves.io.schema.HttpMethod"
        },
        "schemaLabelSelectorType": {
            "type": "object",
            "description": "This type can be used to establish a 'selector reference' from one object(called selector) to\na set of other objects(called selectees) based on the value of expresssions.\nA label selector is a label query over a set of resources. An empty label selector matches all objects.\nA null label selector matches no objects. Label selector is immutable.\nexpressions is a list of strings of label selection expression.\nEach string has \",\" separated values which are \"AND\" and all strings are logically \"OR\".\nBNF for expression string\n\u003cselector-syntax\u003e         ::= \u003crequirement\u003e | \u003crequirement\u003e \",\" \u003cselector-syntax\u003e\n\u003crequirement\u003e             ::= [!] KEY [ \u003cset-based-restriction\u003e | \u003cexact-match-restriction\u003e ]\n\u003cset-based-restriction\u003e   ::= \"\" | \u003cinclusion-exclusion\u003e \u003cvalue-set\u003e\n\u003cinclusion-exclusion\u003e     ::= \u003cinclusion\u003e | \u003cexclusion\u003e\n\u003cexclusion\u003e               ::= \"notin\"\n\u003cinclusion\u003e               ::= \"in\"\n\u003cvalue-set\u003e               ::= \"(\" \u003cvalues\u003e \")\"\n\u003cvalues\u003e                  ::= VALUE | VALUE \",\" \u003cvalues\u003e\n\u003cexact-match-restriction\u003e ::= [\"=\"|\"==\"|\"!=\"] VALUE",
            "title": "LabelSelectorType",
            "x-displayname": "Label Selector",
            "x-ves-proto-message": "ves.io.schema.LabelSelectorType",
            "properties": {
                "expressions": {
                    "type": "array",
                    "description": " expressions contains the kubernetes style label expression for selections.\n\nExample: - \"region in (us-west1, us-west2),tier in (staging)\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.string.k8s_label_selector: true\n  ves.io.schema.rules.repeated.items.string.max_len: 4096\n  ves.io.schema.rules.repeated.items.string.min_len: 1\n  ves.io.schema.rules.repeated.max_items: 1\n",
                    "title": "expressions",
                    "maxItems": 1,
                    "items": {
                        "type": "string",
                        "minLength": 1,
                        "maxLength": 4096
                    },
                    "x-displayname": "Selector Expression",
                    "x-ves-example": "region in (us-west1, us-west2),tier in (staging)",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.string.k8s_label_selector": "true",
                        "ves.io.schema.rules.repeated.items.string.max_len": "4096",
                        "ves.io.schema.rules.repeated.items.string.min_len": "1",
                        "ves.io.schema.rules.repeated.max_items": "1"
                    }
                }
            }
        },
        "schemaMessageMetaType": {
            "type": "object",
            "description": "MessageMetaType is metadata (common attributes) of a message that only certain messages\nhave. This information is propagated to the metadata of a child object that gets created\nfrom the containing message during view processing.\nThe information in this type can be specified by user during create and replace APIs.",
            "title": "MessageMetaType",
            "x-displayname": "Message Metadata",
            "x-ves-proto-message": "ves.io.schema.MessageMetaType",
            "properties": {
                "description": {
                    "type": "string",
                    "description": " Human readable description.\n\nExample: - \"Virtual Host for acmecorp website\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "description",
                    "maxLength": 256,
                    "x-displayname": "Description",
                    "x-ves-example": "Virtual Host for acmecorp website",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "name": {
                    "type": "string",
                    "description": " This is the name of the message.\n The value of name has to follow DNS-1035 format.\n\nExample: - \"acmecorp-web\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.min_len: 1\n  ves.io.schema.rules.string.ves_object_name: true\n",
                    "title": "name",
                    "minLength": 1,
                    "x-displayname": "Name",
                    "x-ves-example": "acmecorp-web",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.min_len": "1",
                        "ves.io.schema.rules.string.ves_object_name": "true"
                    }
                }
            }
        },
        "schemaOpenApiValidationProperties": {
            "type": "string",
            "description": "List of required properties to validate against the OpenAPI spec\n\nValidate that all query parameters are according to the OpenAPI specification\nValidate that all path parameters are according to the OpenAPI specification\nValidate that the content type of the request is according to the OpenAPI specification\nValidate that all cookies are according to the OpenAPI specification\nValidate that all HTTP headers are according to the OpenAPI specification\nValidate that the body is according to the OpenAPI specification\nValidate that the security schema is according to the OpenAPI specification\nValidate that the response code is according to the OpenAPI specification",
            "title": "OpenApiValidationProperties",
            "enum": [
                "PROPERTY_QUERY_PARAMETERS",
                "PROPERTY_PATH_PARAMETERS",
                "PROPERTY_CONTENT_TYPE",
                "PROPERTY_COOKIE_PARAMETERS",
                "PROPERTY_HTTP_HEADERS",
                "PROPERTY_HTTP_BODY",
                "PROPERTY_SECURITY_SCHEMA",
                "PROPERTY_RESPONSE_CODE"
            ],
            "default": "PROPERTY_QUERY_PARAMETERS",
            "x-displayname": "OpenAPI Validation Properties",
            "x-ves-proto-enum": "ves.io.schema.OpenApiValidationProperties"
        },
        "schemapolicyHeaderMatcherType": {
            "type": "object",
            "description": "A header matcher specifies the name of a single HTTP header and the criteria for the input request to match it. The input has a list of actual values for each\nheader name in the original HTTP request.\nA header matcher can check for one of the following:\n* Presence or absence of the header in the input\n* At least one of the values for the header in the input satisfies the MatcherType item",
            "title": "HeaderMatcherType",
            "x-displayname": "Header Matcher",
            "x-ves-displayorder": "1,6,4",
            "x-ves-oneof-field-match": "[\"check_not_present\",\"check_present\",\"item\"]",
            "x-ves-proto-message": "ves.io.schema.policy.HeaderMatcherType",
            "properties": {
                "check_not_present": {
                    "description": "Exclusive with [check_present item]\n Check that the header is not present.",
                    "title": "check_not_present",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Not Present"
                },
                "check_present": {
                    "description": "Exclusive with [check_not_present item]\n Check that the header is present.",
                    "title": "check_present",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Present"
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Header Matcher"
                },
                "item": {
                    "description": "Exclusive with [check_not_present check_present]\n Criteria for matching the values for the header. The match is successful if any of the values in the input satisfies the criteria in the matcher.",
                    "title": "item",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Match Values"
                },
                "name": {
                    "type": "string",
                    "description": " A case-insensitive HTTP header name.\n\nExample: - \"Accept-Encoding\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.http_header_field: true\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "name",
                    "maxLength": 256,
                    "x-displayname": "Header Name",
                    "x-ves-example": "Accept-Encoding",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.http_header_field": "true",
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                }
            }
        },
        "schemapolicyIPThreatCategoryListType": {
            "type": "object",
            "description": "List of ip threat categories",
            "title": "IP Threat Category List Type",
            "x-displayname": "IP Threat Category List Type",
            "x-ves-proto-message": "ves.io.schema.policy.IPThreatCategoryListType",
            "properties": {
                "ip_threat_categories": {
                    "type": "array",
                    "description": " The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "IP Threat Categories",
                    "maxItems": 32,
                    "items": {
                        "$ref": "#/definitions/policyIPThreatCategory"
                    },
                    "x-displayname": "List of IP Threat Categories to choose",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "schemapolicyQueryParameterMatcherType": {
            "type": "object",
            "description": "A query parameter matcher specifies the name of a single query parameter and the criteria for the input request to match it. The input has a list of actual\nvalues for each query parameter name in the original HTTP request.\nA query parameter matcher can check for one of the following:\n* Presence or absence of the query parameter in the input\n* At least one of the values for the query parameter in the input satisfies the MatcherType item",
            "title": "QueryParameterMatcherType",
            "x-displayname": "Query Parameter Matcher",
            "x-ves-displayorder": "1,6,4",
            "x-ves-oneof-field-match": "[\"check_not_present\",\"check_present\",\"item\"]",
            "x-ves-proto-message": "ves.io.schema.policy.QueryParameterMatcherType",
            "properties": {
                "check_not_present": {
                    "description": "Exclusive with [check_present item]\n Check that the query parameter is not present.",
                    "title": "check_not_present",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Not Present"
                },
                "check_present": {
                    "description": "Exclusive with [check_not_present item]\n Check that the query parameter is present.",
                    "title": "check_present",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Present"
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Query Parameter Matcher"
                },
                "item": {
                    "description": "Exclusive with [check_not_present check_present]\n Criteria for matching the values for the given query parameter. The match is successful if any of the values for the query parameter satisfies the\n criteria in the matcher.",
                    "title": "item",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Match Values"
                },
                "key": {
                    "type": "string",
                    "description": " A case-sensitive HTTP query parameter name.\n\nExample: - \"sourceid\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "key",
                    "maxLength": 256,
                    "x-displayname": "Query Parameter Name",
                    "x-ves-example": "sourceid",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                }
            }
        },
        "schemaviewsObjectRefType": {
            "type": "object",
            "description": "This type establishes a direct reference from one object(the referrer) to another(the referred).\nSuch a reference is in form of tenant/namespace/name",
            "title": "ObjectRefType",
            "x-displayname": "Object reference",
            "x-ves-proto-message": "ves.io.schema.views.ObjectRefType",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then name will hold the referred object's(e.g. route's) name.\n\nExample: - \"contacts-route\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 128\n  ves.io.schema.rules.string.min_bytes: 1\n",
                    "title": "name",
                    "minLength": 1,
                    "maxLength": 128,
                    "x-displayname": "Name",
                    "x-ves-example": "contacts-route",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "128",
                        "ves.io.schema.rules.string.min_bytes": "1"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then namespace will hold the referred object's(e.g. route's) namespace.\n\nExample: - \"ns1\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 64\n",
                    "title": "namespace",
                    "maxLength": 64,
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "64"
                    }
                },
                "tenant": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then tenant will hold the referred object's(e.g. route's) tenant.\n\nExample: - \"acmecorp\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 64\n",
                    "title": "tenant",
                    "maxLength": 64,
                    "x-displayname": "Tenant",
                    "x-ves-example": "acmecorp",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "64"
                    }
                }
            }
        },
        "virtual_hostVirtualHostType": {
            "type": "string",
            "description": "VirtualHostType tells the type of virtual_host. Functionally, all types are same,\nthis is mainly used for categorizing metrics.\n\n - VIRTUAL_SERVICE: VirtualService\n\nVirtual Host used Virtual Service\n - HTTP_LOAD_BALANCER: HTTP LoadBalancer\n\nVirtual Host used as Load Balancer\n - API_GATEWAY: APIGateway\n\nVirtual Host used API Gateway\n - TCP_LOAD_BALANCER: TCP LoadBalancer\n\nVirtual Host used as Load Balancer\n - PROXY: Proxy\n\nVirtual Host used as Proxy\n - LOCAL_K8S_API_GATEWAY: LOCAL_K8S_API_GATEWAY\n\nInternal use only, used for k8s cluster api gateway on the site.\n - CDN_LOAD_BALANCER: CDN LoadBalancer\n\n Virtual Host used as Load Balancer\n - NGINX_SERVER: NGINX Server\n\nVirtual Host representing an NGINX Server block\n - BIGIP_VIRTUAL_SERVER: BIG-IP Virtual Server\n\nVirtual Host representing a BIG-IP Virtual Server\n - UDP_LOAD_BALANCER: UDP LoadBalancer\n\nVirtual Host used as Load Balancer",
            "title": "VirtualHostType",
            "enum": [
                "VIRTUAL_SERVICE",
                "HTTP_LOAD_BALANCER",
                "API_GATEWAY",
                "TCP_LOAD_BALANCER",
                "PROXY",
                "CDN_LOAD_BALANCER",
                "NGINX_SERVER",
                "UDP_LOAD_BALANCER"
            ],
            "default": "VIRTUAL_SERVICE",
            "x-displayname": "Virtual Host Type",
            "x-ves-proto-enum": "ves.io.schema.virtual_host.VirtualHostType"
        }
    },
    "x-displayname": "Application Security Monitoring APIs",
    "x-ves-proto-file": "ves.io/schema/api_sec/rule_suggestion/public_rule_suggestions_api.proto"
}`
