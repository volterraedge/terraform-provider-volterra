// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/uztna/uztna_active_sessions/public_uztna_active_sessions.proto

// manage active sessions
//
// x-displayName: "Manage Active Sessions"
// APIs to monitor UZTNA active sessions on all applications.

package uztna_active_sessions

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/vesenv"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Session status
//
// x-displayName: "Session Status"
// The status of the active session
type SessionStatus int32

const (
	// x-displayName: "Pending"
	// Session status is pending
	PENDING SessionStatus = 0
	// x-displayName: "Established"
	// Session status is established
	ESTABLISHED SessionStatus = 1
)

var SessionStatus_name = map[int32]string{
	0: "PENDING",
	1: "ESTABLISHED",
}

var SessionStatus_value = map[string]int32{
	"PENDING":     0,
	"ESTABLISHED": 1,
}

func (SessionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d16f9e315887ac6, []int{0}
}

// ListActiveSessionsRequest
//
// x-displayName: "List Active Sessions Request"
// Request structure for active sessions list
type ListActiveSessionsRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "ns1"
	// Namespace of the App type for the current request
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// offset
	//
	// x-displayName: "Offset"
	// x-example: "9d6d591"
	// Offset to query the next set of sessions. Offset contains the session ID to offset from
	Offset string `protobuf:"bytes,2,opt,name=offset,proto3" json:"offset,omitempty"`
	// limit
	//
	// x-displayName: "Limit"
	// x-example: "25"
	// Limits the number of results to the specified number
	Limit int32 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *ListActiveSessionsRequest) Reset()      { *m = ListActiveSessionsRequest{} }
func (*ListActiveSessionsRequest) ProtoMessage() {}
func (*ListActiveSessionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d16f9e315887ac6, []int{0}
}
func (m *ListActiveSessionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListActiveSessionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListActiveSessionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListActiveSessionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListActiveSessionsRequest.Merge(m, src)
}
func (m *ListActiveSessionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListActiveSessionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListActiveSessionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListActiveSessionsRequest proto.InternalMessageInfo

func (m *ListActiveSessionsRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ListActiveSessionsRequest) GetOffset() string {
	if m != nil {
		return m.Offset
	}
	return ""
}

func (m *ListActiveSessionsRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// ListActiveSessionsItem
//
// x-displayName: "List Active Session Item"
// An object representing an active session
type ListActiveSessionsItem struct {
	// id
	//
	// x-displayName: "Session ID"
	// x-example: "9d6d591"
	// ID of the session
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// status
	//
	// x-displayName: "Status"
	// The status of session
	Status SessionStatus `protobuf:"varint,2,opt,name=status,proto3,enum=ves.io.schema.uztna.uztna_active_sessions.SessionStatus" json:"status,omitempty"`
	// username
	//
	// x-displayName: "Username"
	// x-example: "testUser"
	// Username used in authentication of this session
	Username string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
	// client ip
	//
	// x-displayName: "Client IP"
	// x-example: "10.192.0.1"
	// Client IP of the user that connected via the session
	ClientIp string `protobuf:"bytes,4,opt,name=client_ip,json=clientIp,proto3" json:"client_ip,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "2024-08-06T20:58:46.089939+0000"
	// Start time of the session in ISO-8601 format
	StartTime *types.Timestamp `protobuf:"bytes,5,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// expiration time
	//
	// x-displayName: "Expiration Time"
	// x-example: "2024-08-07T20:58:46.089939+0000"
	// Expiration time of the session in ISO-8601 format
	ExpirationTime *types.Timestamp `protobuf:"bytes,6,opt,name=expiration_time,json=expirationTime,proto3" json:"expiration_time,omitempty"`
}

func (m *ListActiveSessionsItem) Reset()      { *m = ListActiveSessionsItem{} }
func (*ListActiveSessionsItem) ProtoMessage() {}
func (*ListActiveSessionsItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d16f9e315887ac6, []int{1}
}
func (m *ListActiveSessionsItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListActiveSessionsItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListActiveSessionsItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListActiveSessionsItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListActiveSessionsItem.Merge(m, src)
}
func (m *ListActiveSessionsItem) XXX_Size() int {
	return m.Size()
}
func (m *ListActiveSessionsItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ListActiveSessionsItem.DiscardUnknown(m)
}

var xxx_messageInfo_ListActiveSessionsItem proto.InternalMessageInfo

func (m *ListActiveSessionsItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ListActiveSessionsItem) GetStatus() SessionStatus {
	if m != nil {
		return m.Status
	}
	return PENDING
}

func (m *ListActiveSessionsItem) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *ListActiveSessionsItem) GetClientIp() string {
	if m != nil {
		return m.ClientIp
	}
	return ""
}

func (m *ListActiveSessionsItem) GetStartTime() *types.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *ListActiveSessionsItem) GetExpirationTime() *types.Timestamp {
	if m != nil {
		return m.ExpirationTime
	}
	return nil
}

// ListActiveSessionResponse
//
// x-displayName: "List Active Sessions Response"
// Response structure for active sessions list
type ListActiveSessionsResponse struct {
	// items
	//
	// x-displayName: "Sessions"
	// List of active sessions
	Items []*ListActiveSessionsItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	// count
	//
	// x-displayName: "Count"
	// x-example: "20"
	// Total count of active sessions
	Count int32 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *ListActiveSessionsResponse) Reset()      { *m = ListActiveSessionsResponse{} }
func (*ListActiveSessionsResponse) ProtoMessage() {}
func (*ListActiveSessionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d16f9e315887ac6, []int{2}
}
func (m *ListActiveSessionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListActiveSessionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListActiveSessionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListActiveSessionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListActiveSessionsResponse.Merge(m, src)
}
func (m *ListActiveSessionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListActiveSessionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListActiveSessionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListActiveSessionsResponse proto.InternalMessageInfo

func (m *ListActiveSessionsResponse) GetItems() []*ListActiveSessionsItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *ListActiveSessionsResponse) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// GetActiveSessionRequest
//
// x-displayName: "Get Active Session Request"
// Request structure of active session query
type GetActiveSessionRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "ns1"
	// Namespace of the App type for the current request
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// id
	//
	// x-displayName: "Session ID"
	// x-example: "9d6d591"
	// ID of the session
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GetActiveSessionRequest) Reset()      { *m = GetActiveSessionRequest{} }
func (*GetActiveSessionRequest) ProtoMessage() {}
func (*GetActiveSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d16f9e315887ac6, []int{3}
}
func (m *GetActiveSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetActiveSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetActiveSessionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetActiveSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetActiveSessionRequest.Merge(m, src)
}
func (m *GetActiveSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetActiveSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetActiveSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetActiveSessionRequest proto.InternalMessageInfo

func (m *GetActiveSessionRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *GetActiveSessionRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// SessionVariable
//
// x-displayName: "Session Variable"
// An object representing a session variable
type SessionVariable struct {
	// variable
	//
	// x-displayName: "Variable"
	// x-example: "session.user.starttime"
	// The variable name
	Variable string `protobuf:"bytes,1,opt,name=variable,proto3" json:"variable,omitempty"`
	// value
	//
	// x-displayName: "Value"
	// x-example: "1724969282346"
	// The variable value
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *SessionVariable) Reset()      { *m = SessionVariable{} }
func (*SessionVariable) ProtoMessage() {}
func (*SessionVariable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d16f9e315887ac6, []int{4}
}
func (m *SessionVariable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionVariable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionVariable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionVariable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionVariable.Merge(m, src)
}
func (m *SessionVariable) XXX_Size() int {
	return m.Size()
}
func (m *SessionVariable) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionVariable.DiscardUnknown(m)
}

var xxx_messageInfo_SessionVariable proto.InternalMessageInfo

func (m *SessionVariable) GetVariable() string {
	if m != nil {
		return m.Variable
	}
	return ""
}

func (m *SessionVariable) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// GetActiveSessionResponse
//
// x-displayName: "Get Active Session Response"
// Response structure of active session query
type GetActiveSessionResponse struct {
	// id
	//
	// x-displayName: "Session ID"
	// x-example: "9d6d591"
	// ID of the session
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// status
	//
	// x-displayName: "Status"
	// x-example: "Established"
	// The status of session
	Status SessionStatus `protobuf:"varint,2,opt,name=status,proto3,enum=ves.io.schema.uztna.uztna_active_sessions.SessionStatus" json:"status,omitempty"`
	// username
	//
	// x-displayName: "Username"
	// x-example: "testUser"
	// Username used in authentication of this session
	Username string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
	// client ip
	//
	// x-displayName: "Client IP"
	// x-example: "10.192.0.1"
	// Client IP of the user that connected via the session
	ClientIp string `protobuf:"bytes,4,opt,name=client_ip,json=clientIp,proto3" json:"client_ip,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "2024-08-06T20:58:46.089939+0000"
	// Start time of the session in ISO-8601 format
	StartTime *types.Timestamp `protobuf:"bytes,5,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// expiration time
	//
	// x-displayName: "Expiration Time"
	// x-example: "2024-08-07T20:58:46.089939+0000"
	// Expiration time of the session in ISO-8601 format
	ExpirationTime *types.Timestamp `protobuf:"bytes,6,opt,name=expiration_time,json=expirationTime,proto3" json:"expiration_time,omitempty"`
	// Session variables
	//
	// x-displayName: "Session Variables"
	// Session variables present in the session
	Variables []*SessionVariable `protobuf:"bytes,7,rep,name=variables,proto3" json:"variables,omitempty"`
}

func (m *GetActiveSessionResponse) Reset()      { *m = GetActiveSessionResponse{} }
func (*GetActiveSessionResponse) ProtoMessage() {}
func (*GetActiveSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d16f9e315887ac6, []int{5}
}
func (m *GetActiveSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetActiveSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetActiveSessionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetActiveSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetActiveSessionResponse.Merge(m, src)
}
func (m *GetActiveSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetActiveSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetActiveSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetActiveSessionResponse proto.InternalMessageInfo

func (m *GetActiveSessionResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *GetActiveSessionResponse) GetStatus() SessionStatus {
	if m != nil {
		return m.Status
	}
	return PENDING
}

func (m *GetActiveSessionResponse) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *GetActiveSessionResponse) GetClientIp() string {
	if m != nil {
		return m.ClientIp
	}
	return ""
}

func (m *GetActiveSessionResponse) GetStartTime() *types.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *GetActiveSessionResponse) GetExpirationTime() *types.Timestamp {
	if m != nil {
		return m.ExpirationTime
	}
	return nil
}

func (m *GetActiveSessionResponse) GetVariables() []*SessionVariable {
	if m != nil {
		return m.Variables
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.uztna.uztna_active_sessions.SessionStatus", SessionStatus_name, SessionStatus_value)
	golang_proto.RegisterEnum("ves.io.schema.uztna.uztna_active_sessions.SessionStatus", SessionStatus_name, SessionStatus_value)
	proto.RegisterType((*ListActiveSessionsRequest)(nil), "ves.io.schema.uztna.uztna_active_sessions.ListActiveSessionsRequest")
	golang_proto.RegisterType((*ListActiveSessionsRequest)(nil), "ves.io.schema.uztna.uztna_active_sessions.ListActiveSessionsRequest")
	proto.RegisterType((*ListActiveSessionsItem)(nil), "ves.io.schema.uztna.uztna_active_sessions.ListActiveSessionsItem")
	golang_proto.RegisterType((*ListActiveSessionsItem)(nil), "ves.io.schema.uztna.uztna_active_sessions.ListActiveSessionsItem")
	proto.RegisterType((*ListActiveSessionsResponse)(nil), "ves.io.schema.uztna.uztna_active_sessions.ListActiveSessionsResponse")
	golang_proto.RegisterType((*ListActiveSessionsResponse)(nil), "ves.io.schema.uztna.uztna_active_sessions.ListActiveSessionsResponse")
	proto.RegisterType((*GetActiveSessionRequest)(nil), "ves.io.schema.uztna.uztna_active_sessions.GetActiveSessionRequest")
	golang_proto.RegisterType((*GetActiveSessionRequest)(nil), "ves.io.schema.uztna.uztna_active_sessions.GetActiveSessionRequest")
	proto.RegisterType((*SessionVariable)(nil), "ves.io.schema.uztna.uztna_active_sessions.SessionVariable")
	golang_proto.RegisterType((*SessionVariable)(nil), "ves.io.schema.uztna.uztna_active_sessions.SessionVariable")
	proto.RegisterType((*GetActiveSessionResponse)(nil), "ves.io.schema.uztna.uztna_active_sessions.GetActiveSessionResponse")
	golang_proto.RegisterType((*GetActiveSessionResponse)(nil), "ves.io.schema.uztna.uztna_active_sessions.GetActiveSessionResponse")
}

func init() {
	proto.RegisterFile("ves.io/schema/uztna/uztna_active_sessions/public_uztna_active_sessions.proto", fileDescriptor_2d16f9e315887ac6)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/uztna/uztna_active_sessions/public_uztna_active_sessions.proto", fileDescriptor_2d16f9e315887ac6)
}

var fileDescriptor_2d16f9e315887ac6 = []byte{
	// 918 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x56, 0xcf, 0x6f, 0x1b, 0x45,
	0x14, 0xf6, 0xac, 0xb1, 0x8b, 0x27, 0x22, 0x09, 0x23, 0x54, 0x16, 0x37, 0x5a, 0x2c, 0x9f, 0x9c,
	0x8a, 0xdd, 0xad, 0xc2, 0x0f, 0x11, 0x90, 0x40, 0xf9, 0xa5, 0x60, 0x29, 0x2a, 0xd1, 0xa6, 0x02,
	0x44, 0x54, 0x59, 0xe3, 0xf5, 0x78, 0x3b, 0xb0, 0xbb, 0xb3, 0xec, 0xcc, 0x2e, 0x51, 0xaa, 0x4a,
	0xa8, 0xd7, 0x1e, 0x40, 0xe2, 0xc4, 0x7f, 0xc0, 0x8d, 0x03, 0x17, 0xa4, 0x72, 0xe8, 0xad, 0x3d,
	0xa1, 0x00, 0x97, 0x1e, 0x89, 0xc3, 0x01, 0x71, 0xa1, 0x37, 0xae, 0x68, 0x67, 0xc6, 0x0e, 0x76,
	0x5c, 0x9a, 0x10, 0x8e, 0x5c, 0xac, 0x79, 0xf3, 0xde, 0xfb, 0xf6, 0xed, 0xf7, 0x7d, 0xe3, 0x1d,
	0xb8, 0x95, 0x13, 0xee, 0x50, 0xe6, 0x72, 0xff, 0x06, 0x89, 0xb0, 0x9b, 0xed, 0x8b, 0x58, 0xff,
	0x76, 0xb0, 0x2f, 0x68, 0x4e, 0x3a, 0x9c, 0x70, 0x4e, 0x59, 0xcc, 0xdd, 0x24, 0xeb, 0x86, 0xd4,
	0xef, 0x4c, 0x4d, 0x3a, 0x49, 0xca, 0x04, 0x43, 0x8b, 0x0a, 0xcd, 0x51, 0x68, 0x8e, 0x2c, 0x75,
	0xa6, 0x36, 0xd4, 0xed, 0x80, 0x8a, 0x1b, 0x59, 0xd7, 0xf1, 0x59, 0xe4, 0x06, 0x2c, 0x60, 0xae,
	0x44, 0xe8, 0x66, 0x7d, 0x19, 0xc9, 0x40, 0xae, 0x14, 0x72, 0x7d, 0x21, 0x60, 0x2c, 0x08, 0x89,
	0x8b, 0x13, 0xea, 0xe2, 0x38, 0x66, 0x02, 0x8b, 0xe3, 0xe7, 0xd6, 0x5f, 0xd4, 0xd9, 0x11, 0x86,
	0xa0, 0x11, 0xe1, 0x02, 0x47, 0x89, 0x2e, 0xb8, 0x34, 0xfe, 0x9a, 0x2c, 0xf9, 0x7b, 0xf7, 0xc2,
	0x78, 0x32, 0xc7, 0x21, 0xed, 0x61, 0x41, 0x74, 0xb6, 0x39, 0x91, 0x25, 0x9c, 0xc4, 0xf9, 0x04,
	0x42, 0x63, 0xa2, 0x86, 0x92, 0x4f, 0x3b, 0x63, 0x15, 0xcd, 0x00, 0xbe, 0xb0, 0x45, 0xb9, 0x58,
	0x91, 0x2c, 0xec, 0x68, 0x12, 0x3c, 0xf2, 0x49, 0x46, 0xb8, 0x40, 0x0b, 0xb0, 0x16, 0xe3, 0x88,
	0xf0, 0x04, 0xfb, 0xc4, 0x04, 0x0d, 0xd0, 0xaa, 0x79, 0xc7, 0x1b, 0xe8, 0x22, 0xac, 0xb2, 0x7e,
	0x9f, 0x13, 0x61, 0x1a, 0x32, 0xa5, 0x23, 0xf4, 0x1c, 0xac, 0x84, 0x34, 0xa2, 0xc2, 0x2c, 0x37,
	0x40, 0xab, 0xe2, 0xa9, 0xa0, 0xf9, 0xad, 0x01, 0x2f, 0x9e, 0x7c, 0x52, 0x5b, 0x90, 0x08, 0xcd,
	0x42, 0x83, 0xf6, 0x34, 0xbe, 0x41, 0x7b, 0x68, 0x1b, 0x56, 0xb9, 0xc0, 0x22, 0xe3, 0x12, 0x78,
	0x76, 0xe9, 0x75, 0xe7, 0xd4, 0xf2, 0x39, 0x1a, 0x78, 0x47, 0xf6, 0x7b, 0x1a, 0x07, 0xd5, 0xe1,
	0xd3, 0x19, 0x27, 0x69, 0x31, 0xbb, 0x9c, 0xaa, 0xe6, 0x8d, 0x62, 0x74, 0x09, 0xd6, 0xfc, 0x90,
	0x92, 0x58, 0x74, 0x68, 0x62, 0x3e, 0xa5, 0x92, 0x6a, 0xa3, 0x9d, 0xa0, 0x65, 0x08, 0xb9, 0xc0,
	0xa9, 0xe8, 0x14, 0xc2, 0x99, 0x95, 0x06, 0x68, 0xcd, 0x2c, 0xd5, 0x1d, 0xa5, 0xaa, 0x33, 0x54,
	0xd5, 0xb9, 0x36, 0x54, 0xd5, 0xab, 0xc9, 0xea, 0x22, 0x46, 0x6b, 0x70, 0x8e, 0xec, 0x25, 0x34,
	0x95, 0x86, 0x50, 0xfd, 0xd5, 0x27, 0xf6, 0xcf, 0x1e, 0xb7, 0x14, 0x9b, 0xcd, 0x3b, 0x00, 0xd6,
	0xa7, 0xe9, 0xc3, 0x13, 0x16, 0x73, 0x82, 0xde, 0x87, 0x15, 0x2a, 0x48, 0xc4, 0x4d, 0xd0, 0x28,
	0xb7, 0x66, 0x96, 0x56, 0xce, 0x40, 0xd4, 0x74, 0x2d, 0x3c, 0x85, 0x57, 0x68, 0xe8, 0xb3, 0x2c,
	0x56, 0xd2, 0x56, 0x3c, 0x15, 0x34, 0x37, 0xe1, 0xf3, 0x9b, 0x64, 0xbc, 0xeb, 0x74, 0x56, 0x51,
	0x0a, 0x1b, 0x43, 0x85, 0x9b, 0x6b, 0x70, 0x4e, 0xf7, 0xbf, 0x87, 0x53, 0x8a, 0xbb, 0x21, 0x29,
	0x24, 0xca, 0xf5, 0x5a, 0xf7, 0x8f, 0xe2, 0x62, 0x9a, 0x1c, 0x87, 0x19, 0xd1, 0x08, 0x2a, 0x68,
	0x7e, 0x5e, 0x86, 0xe6, 0xc9, 0x71, 0x34, 0x33, 0xff, 0x7b, 0xea, 0x71, 0x9e, 0x42, 0x1f, 0xc0,
	0xda, 0x90, 0x59, 0x6e, 0x5e, 0x90, 0xc6, 0x79, 0xe3, 0xec, 0x6c, 0x0c, 0x85, 0xf3, 0x8e, 0xc1,
	0x2e, 0xdb, 0xf0, 0x99, 0x31, 0xae, 0xd0, 0x0c, 0xbc, 0xb0, 0xbd, 0x71, 0x75, 0xbd, 0x7d, 0x75,
	0x73, 0xbe, 0x84, 0xe6, 0xe0, 0xcc, 0xc6, 0xce, 0xb5, 0x95, 0xd5, 0xad, 0xf6, 0xce, 0x3b, 0x1b,
	0xeb, 0xf3, 0x60, 0xe9, 0xcf, 0x2a, 0x7c, 0x76, 0xdc, 0x82, 0x2b, 0xdb, 0x6d, 0xf4, 0x8d, 0x01,
	0xd1, 0x49, 0x73, 0xa2, 0xf5, 0x73, 0x79, 0x5b, 0xdb, 0xb4, 0xbe, 0x71, 0x4e, 0x14, 0xe5, 0xae,
	0xe6, 0x1d, 0xf0, 0xe0, 0x3b, 0x03, 0x0c, 0xee, 0x9b, 0x9b, 0xfd, 0x57, 0xf7, 0x7c, 0x3b, 0x8b,
	0x69, 0x4e, 0x52, 0x8e, 0x43, 0xbb, 0x00, 0xb2, 0xb9, 0xc0, 0x71, 0x0f, 0xa7, 0x3d, 0x3b, 0x62,
	0x31, 0x15, 0x2c, 0x7d, 0xa9, 0xf1, 0x8f, 0x55, 0x85, 0x6b, 0x6e, 0xff, 0xfc, 0xeb, 0x97, 0xc6,
	0x6b, 0xe8, 0x15, 0xfd, 0x31, 0x73, 0x47, 0x47, 0x87, 0xbb, 0x37, 0x47, 0xeb, 0x5b, 0xfa, 0x33,
	0xa8, 0x06, 0xb5, 0x87, 0x83, 0xa2, 0x3f, 0xca, 0x70, 0x7e, 0xf2, 0x20, 0xa0, 0xd5, 0x33, 0xbc,
	0xe9, 0x63, 0x0e, 0x75, 0x7d, 0xed, 0x5c, 0x18, 0x9a, 0xab, 0x1f, 0x8d, 0xff, 0x98, 0xab, 0xdf,
	0xef, 0x9b, 0xdf, 0x03, 0x79, 0x41, 0xb0, 0x29, 0xb3, 0xd5, 0x68, 0xb6, 0x1c, 0x4a, 0xff, 0x4e,
	0xf0, 0xa3, 0xe3, 0x61, 0x88, 0x13, 0x6a, 0x07, 0x44, 0x8c, 0x6d, 0xa2, 0x10, 0x96, 0x03, 0x22,
	0x10, 0x99, 0xc2, 0x7f, 0x6b, 0x17, 0xdb, 0xfb, 0xd7, 0x5b, 0xbb, 0x36, 0xb6, 0xf7, 0xaf, 0xd8,
	0xcb, 0xd7, 0x2f, 0xef, 0xea, 0xc5, 0xe2, 0xdb, 0x8b, 0xd3, 0x05, 0x51, 0x2d, 0x45, 0xc9, 0xf4,
	0x2e, 0x29, 0xf6, 0x9b, 0x68, 0xf9, 0xdf, 0x88, 0xed, 0xde, 0xa4, 0xbd, 0x5b, 0xf5, 0xb7, 0xee,
	0xdd, 0x05, 0xe5, 0x9f, 0xee, 0x82, 0x2b, 0xa7, 0xd7, 0xe7, 0xdd, 0xee, 0x47, 0xc4, 0x17, 0xb7,
	0x7f, 0x30, 0x0d, 0x13, 0xac, 0x7e, 0x05, 0x0e, 0x0e, 0xad, 0xd2, 0xc3, 0x43, 0xab, 0xf4, 0xe8,
	0xd0, 0x02, 0x9f, 0x0d, 0x2c, 0xf0, 0xf5, 0xc0, 0x02, 0x0f, 0x06, 0x16, 0x38, 0x18, 0x58, 0xe0,
	0x97, 0x81, 0x05, 0x7e, 0x1b, 0x58, 0xa5, 0x47, 0x03, 0x0b, 0x7c, 0x71, 0x64, 0x95, 0xee, 0x1d,
	0x59, 0xe0, 0xe0, 0xc8, 0x2a, 0x3d, 0x3c, 0xb2, 0x4a, 0x1f, 0x76, 0x02, 0x96, 0x7c, 0x1c, 0x38,
	0x39, 0x0b, 0x05, 0x49, 0x53, 0xec, 0x64, 0xdc, 0x95, 0x8b, 0x3e, 0x4b, 0x23, 0x3b, 0x49, 0x59,
	0x4e, 0x7b, 0x24, 0xb5, 0x87, 0x69, 0x37, 0xe9, 0x06, 0xcc, 0x25, 0x7b, 0x42, 0xdf, 0x40, 0x9e,
	0x7c, 0x9d, 0xeb, 0x56, 0xe5, 0x5f, 0xd8, 0xcb, 0x7f, 0x05, 0x00, 0x00, 0xff, 0xff, 0x5e, 0x0c,
	0xef, 0x7a, 0x02, 0x0a, 0x00, 0x00,
}

func (x SessionStatus) String() string {
	s, ok := SessionStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *ListActiveSessionsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListActiveSessionsRequest)
	if !ok {
		that2, ok := that.(ListActiveSessionsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Offset != that1.Offset {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	return true
}
func (this *ListActiveSessionsItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListActiveSessionsItem)
	if !ok {
		that2, ok := that.(ListActiveSessionsItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if this.ClientIp != that1.ClientIp {
		return false
	}
	if !this.StartTime.Equal(that1.StartTime) {
		return false
	}
	if !this.ExpirationTime.Equal(that1.ExpirationTime) {
		return false
	}
	return true
}
func (this *ListActiveSessionsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListActiveSessionsResponse)
	if !ok {
		that2, ok := that.(ListActiveSessionsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	if this.Count != that1.Count {
		return false
	}
	return true
}
func (this *GetActiveSessionRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetActiveSessionRequest)
	if !ok {
		that2, ok := that.(GetActiveSessionRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *SessionVariable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SessionVariable)
	if !ok {
		that2, ok := that.(SessionVariable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Variable != that1.Variable {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *GetActiveSessionResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetActiveSessionResponse)
	if !ok {
		that2, ok := that.(GetActiveSessionResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if this.ClientIp != that1.ClientIp {
		return false
	}
	if !this.StartTime.Equal(that1.StartTime) {
		return false
	}
	if !this.ExpirationTime.Equal(that1.ExpirationTime) {
		return false
	}
	if len(this.Variables) != len(that1.Variables) {
		return false
	}
	for i := range this.Variables {
		if !this.Variables[i].Equal(that1.Variables[i]) {
			return false
		}
	}
	return true
}
func (this *ListActiveSessionsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&uztna_active_sessions.ListActiveSessionsRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Offset: "+fmt.Sprintf("%#v", this.Offset)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListActiveSessionsItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&uztna_active_sessions.ListActiveSessionsItem{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	s = append(s, "ClientIp: "+fmt.Sprintf("%#v", this.ClientIp)+",\n")
	if this.StartTime != nil {
		s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	}
	if this.ExpirationTime != nil {
		s = append(s, "ExpirationTime: "+fmt.Sprintf("%#v", this.ExpirationTime)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListActiveSessionsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_active_sessions.ListActiveSessionsResponse{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetActiveSessionRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_active_sessions.GetActiveSessionRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SessionVariable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_active_sessions.SessionVariable{")
	s = append(s, "Variable: "+fmt.Sprintf("%#v", this.Variable)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetActiveSessionResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&uztna_active_sessions.GetActiveSessionResponse{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	s = append(s, "ClientIp: "+fmt.Sprintf("%#v", this.ClientIp)+",\n")
	if this.StartTime != nil {
		s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	}
	if this.ExpirationTime != nil {
		s = append(s, "ExpirationTime: "+fmt.Sprintf("%#v", this.ExpirationTime)+",\n")
	}
	if this.Variables != nil {
		s = append(s, "Variables: "+fmt.Sprintf("%#v", this.Variables)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPublicUztnaActiveSessions(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ActiveSessionsAPIClient is the client API for ActiveSessionsAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ActiveSessionsAPIClient interface {
	// ListActiveSessions
	//
	// x-displayName: "List Active Sessions"
	// List all active sessions
	ListActiveSessions(ctx context.Context, in *ListActiveSessionsRequest, opts ...grpc.CallOption) (*ListActiveSessionsResponse, error)
	// GetActiveSession
	//
	// x-displayName: "Get Active Session"
	// Get an active session by ID
	GetActiveSession(ctx context.Context, in *GetActiveSessionRequest, opts ...grpc.CallOption) (*GetActiveSessionResponse, error)
}

type activeSessionsAPIClient struct {
	cc *grpc.ClientConn
}

func NewActiveSessionsAPIClient(cc *grpc.ClientConn) ActiveSessionsAPIClient {
	return &activeSessionsAPIClient{cc}
}

func (c *activeSessionsAPIClient) ListActiveSessions(ctx context.Context, in *ListActiveSessionsRequest, opts ...grpc.CallOption) (*ListActiveSessionsResponse, error) {
	out := new(ListActiveSessionsResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.uztna.uztna_active_sessions.ActiveSessionsAPI/ListActiveSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activeSessionsAPIClient) GetActiveSession(ctx context.Context, in *GetActiveSessionRequest, opts ...grpc.CallOption) (*GetActiveSessionResponse, error) {
	out := new(GetActiveSessionResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.uztna.uztna_active_sessions.ActiveSessionsAPI/GetActiveSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ActiveSessionsAPIServer is the server API for ActiveSessionsAPI service.
type ActiveSessionsAPIServer interface {
	// ListActiveSessions
	//
	// x-displayName: "List Active Sessions"
	// List all active sessions
	ListActiveSessions(context.Context, *ListActiveSessionsRequest) (*ListActiveSessionsResponse, error)
	// GetActiveSession
	//
	// x-displayName: "Get Active Session"
	// Get an active session by ID
	GetActiveSession(context.Context, *GetActiveSessionRequest) (*GetActiveSessionResponse, error)
}

// UnimplementedActiveSessionsAPIServer can be embedded to have forward compatible implementations.
type UnimplementedActiveSessionsAPIServer struct {
}

func (*UnimplementedActiveSessionsAPIServer) ListActiveSessions(ctx context.Context, req *ListActiveSessionsRequest) (*ListActiveSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListActiveSessions not implemented")
}
func (*UnimplementedActiveSessionsAPIServer) GetActiveSession(ctx context.Context, req *GetActiveSessionRequest) (*GetActiveSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveSession not implemented")
}

func RegisterActiveSessionsAPIServer(s *grpc.Server, srv ActiveSessionsAPIServer) {
	s.RegisterService(&_ActiveSessionsAPI_serviceDesc, srv)
}

func _ActiveSessionsAPI_ListActiveSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListActiveSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActiveSessionsAPIServer).ListActiveSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.uztna.uztna_active_sessions.ActiveSessionsAPI/ListActiveSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActiveSessionsAPIServer).ListActiveSessions(ctx, req.(*ListActiveSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActiveSessionsAPI_GetActiveSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActiveSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActiveSessionsAPIServer).GetActiveSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.uztna.uztna_active_sessions.ActiveSessionsAPI/GetActiveSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActiveSessionsAPIServer).GetActiveSession(ctx, req.(*GetActiveSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ActiveSessionsAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ves.io.schema.uztna.uztna_active_sessions.ActiveSessionsAPI",
	HandlerType: (*ActiveSessionsAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListActiveSessions",
			Handler:    _ActiveSessionsAPI_ListActiveSessions_Handler,
		},
		{
			MethodName: "GetActiveSession",
			Handler:    _ActiveSessionsAPI_GetActiveSession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ves.io/schema/uztna/uztna_active_sessions/public_uztna_active_sessions.proto",
}

func (m *ListActiveSessionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListActiveSessionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListActiveSessionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Offset) > 0 {
		i -= len(m.Offset)
		copy(dAtA[i:], m.Offset)
		i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(len(m.Offset)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListActiveSessionsItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListActiveSessionsItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListActiveSessionsItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpirationTime != nil {
		{
			size, err := m.ExpirationTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ClientIp) > 0 {
		i -= len(m.ClientIp)
		copy(dAtA[i:], m.ClientIp)
		i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(len(m.ClientIp)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListActiveSessionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListActiveSessionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListActiveSessionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetActiveSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetActiveSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetActiveSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionVariable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionVariable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionVariable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Variable) > 0 {
		i -= len(m.Variable)
		copy(dAtA[i:], m.Variable)
		i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(len(m.Variable)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetActiveSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetActiveSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetActiveSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Variables) > 0 {
		for iNdEx := len(m.Variables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Variables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.ExpirationTime != nil {
		{
			size, err := m.ExpirationTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ClientIp) > 0 {
		i -= len(m.ClientIp)
		copy(dAtA[i:], m.ClientIp)
		i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(len(m.ClientIp)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPublicUztnaActiveSessions(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPublicUztnaActiveSessions(dAtA []byte, offset int, v uint64) int {
	offset -= sovPublicUztnaActiveSessions(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ListActiveSessionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicUztnaActiveSessions(uint64(l))
	}
	l = len(m.Offset)
	if l > 0 {
		n += 1 + l + sovPublicUztnaActiveSessions(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovPublicUztnaActiveSessions(uint64(m.Limit))
	}
	return n
}

func (m *ListActiveSessionsItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPublicUztnaActiveSessions(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovPublicUztnaActiveSessions(uint64(m.Status))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovPublicUztnaActiveSessions(uint64(l))
	}
	l = len(m.ClientIp)
	if l > 0 {
		n += 1 + l + sovPublicUztnaActiveSessions(uint64(l))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovPublicUztnaActiveSessions(uint64(l))
	}
	if m.ExpirationTime != nil {
		l = m.ExpirationTime.Size()
		n += 1 + l + sovPublicUztnaActiveSessions(uint64(l))
	}
	return n
}

func (m *ListActiveSessionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPublicUztnaActiveSessions(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovPublicUztnaActiveSessions(uint64(m.Count))
	}
	return n
}

func (m *GetActiveSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicUztnaActiveSessions(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPublicUztnaActiveSessions(uint64(l))
	}
	return n
}

func (m *SessionVariable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Variable)
	if l > 0 {
		n += 1 + l + sovPublicUztnaActiveSessions(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPublicUztnaActiveSessions(uint64(l))
	}
	return n
}

func (m *GetActiveSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPublicUztnaActiveSessions(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovPublicUztnaActiveSessions(uint64(m.Status))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovPublicUztnaActiveSessions(uint64(l))
	}
	l = len(m.ClientIp)
	if l > 0 {
		n += 1 + l + sovPublicUztnaActiveSessions(uint64(l))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovPublicUztnaActiveSessions(uint64(l))
	}
	if m.ExpirationTime != nil {
		l = m.ExpirationTime.Size()
		n += 1 + l + sovPublicUztnaActiveSessions(uint64(l))
	}
	if len(m.Variables) > 0 {
		for _, e := range m.Variables {
			l = e.Size()
			n += 1 + l + sovPublicUztnaActiveSessions(uint64(l))
		}
	}
	return n
}

func sovPublicUztnaActiveSessions(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPublicUztnaActiveSessions(x uint64) (n int) {
	return sovPublicUztnaActiveSessions(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ListActiveSessionsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListActiveSessionsRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListActiveSessionsItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListActiveSessionsItem{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`ClientIp:` + fmt.Sprintf("%v", this.ClientIp) + `,`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`ExpirationTime:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListActiveSessionsResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*ListActiveSessionsItem{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "ListActiveSessionsItem", "ListActiveSessionsItem", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ListActiveSessionsResponse{`,
		`Items:` + repeatedStringForItems + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetActiveSessionRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetActiveSessionRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SessionVariable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SessionVariable{`,
		`Variable:` + fmt.Sprintf("%v", this.Variable) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetActiveSessionResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVariables := "[]*SessionVariable{"
	for _, f := range this.Variables {
		repeatedStringForVariables += strings.Replace(f.String(), "SessionVariable", "SessionVariable", 1) + ","
	}
	repeatedStringForVariables += "}"
	s := strings.Join([]string{`&GetActiveSessionResponse{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`ClientIp:` + fmt.Sprintf("%v", this.ClientIp) + `,`,
		`StartTime:` + strings.Replace(fmt.Sprintf("%v", this.StartTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`ExpirationTime:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`Variables:` + repeatedStringForVariables + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringPublicUztnaActiveSessions(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ListActiveSessionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicUztnaActiveSessions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListActiveSessionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListActiveSessionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Offset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicUztnaActiveSessions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListActiveSessionsItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicUztnaActiveSessions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListActiveSessionsItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListActiveSessionsItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SessionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &types.Timestamp{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTime == nil {
				m.ExpirationTime = &types.Timestamp{}
			}
			if err := m.ExpirationTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicUztnaActiveSessions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListActiveSessionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicUztnaActiveSessions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListActiveSessionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListActiveSessionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ListActiveSessionsItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicUztnaActiveSessions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetActiveSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicUztnaActiveSessions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetActiveSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetActiveSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicUztnaActiveSessions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionVariable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicUztnaActiveSessions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionVariable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionVariable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variable = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicUztnaActiveSessions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetActiveSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicUztnaActiveSessions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetActiveSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetActiveSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SessionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &types.Timestamp{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTime == nil {
				m.ExpirationTime = &types.Timestamp{}
			}
			if err := m.ExpirationTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variables = append(m.Variables, &SessionVariable{})
			if err := m.Variables[len(m.Variables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicUztnaActiveSessions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicUztnaActiveSessions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPublicUztnaActiveSessions(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPublicUztnaActiveSessions
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicUztnaActiveSessions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPublicUztnaActiveSessions
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPublicUztnaActiveSessions
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPublicUztnaActiveSessions
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPublicUztnaActiveSessions        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPublicUztnaActiveSessions          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPublicUztnaActiveSessions = fmt.Errorf("proto: unexpected end of group")
)
