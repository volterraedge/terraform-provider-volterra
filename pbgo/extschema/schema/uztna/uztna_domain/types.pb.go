// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/uztna/uztna_domain/types.proto

package uztna_domain

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// LeasePool
//
// x-displayName: "LeasePool"
//
// Lease Pool For UZTNA Domain
type LeasePoolList struct {
	// LeasePool
	//
	// x-displayName: "LeasePool"
	// Lease Pool for UZTNA Domain
	UztnaLpool []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=uztna_lpool,json=uztnaLpool,proto3" json:"uztna_lpool,omitempty"`
}

func (m *LeasePoolList) Reset()      { *m = LeasePoolList{} }
func (*LeasePoolList) ProtoMessage() {}
func (*LeasePoolList) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{0}
}
func (m *LeasePoolList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeasePoolList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeasePoolList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeasePoolList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeasePoolList.Merge(m, src)
}
func (m *LeasePoolList) XXX_Size() int {
	return m.Size()
}
func (m *LeasePoolList) XXX_DiscardUnknown() {
	xxx_messageInfo_LeasePoolList.DiscardUnknown(m)
}

var xxx_messageInfo_LeasePoolList proto.InternalMessageInfo

func (m *LeasePoolList) GetUztnaLpool() []*schema.ObjectRefType {
	if m != nil {
		return m.UztnaLpool
	}
	return nil
}

// Perimeter RE Site
//
// x-displayName: "Perimeter RE Site"
//
// Selected Perimeter RE Sites
type DomainPerimeterRE struct {
	// Permitere RE Site
	//
	// x-displayName: "Perimeter RE Site"
	// Selected Perimeter RE Site.
	PerimeterReSite []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=perimeter_re_site,json=perimeterReSite,proto3" json:"perimeter_re_site,omitempty"`
}

func (m *DomainPerimeterRE) Reset()      { *m = DomainPerimeterRE{} }
func (*DomainPerimeterRE) ProtoMessage() {}
func (*DomainPerimeterRE) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{1}
}
func (m *DomainPerimeterRE) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DomainPerimeterRE) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DomainPerimeterRE.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DomainPerimeterRE) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DomainPerimeterRE.Merge(m, src)
}
func (m *DomainPerimeterRE) XXX_Size() int {
	return m.Size()
}
func (m *DomainPerimeterRE) XXX_DiscardUnknown() {
	xxx_messageInfo_DomainPerimeterRE.DiscardUnknown(m)
}

var xxx_messageInfo_DomainPerimeterRE proto.InternalMessageInfo

func (m *DomainPerimeterRE) GetPerimeterReSite() []*schema.ObjectRefType {
	if m != nil {
		return m.PerimeterReSite
	}
	return nil
}

// BigIP CE
//
// x-displayName: "BigIP CE"
// Selected BigIP CE.
type DomainSites struct {
	// Available Big Ip Access List
	//
	// x-displayName: "Available Big IP CE"
	// List of All avaliable Big IP CE List
	UztnaGateway []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=uztna_gateway,json=uztnaGateway,proto3" json:"uztna_gateway,omitempty"`
}

func (m *DomainSites) Reset()      { *m = DomainSites{} }
func (*DomainSites) ProtoMessage() {}
func (*DomainSites) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{2}
}
func (m *DomainSites) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DomainSites) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DomainSites.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DomainSites) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DomainSites.Merge(m, src)
}
func (m *DomainSites) XXX_Size() int {
	return m.Size()
}
func (m *DomainSites) XXX_DiscardUnknown() {
	xxx_messageInfo_DomainSites.DiscardUnknown(m)
}

var xxx_messageInfo_DomainSites proto.InternalMessageInfo

func (m *DomainSites) GetUztnaGateway() []*schema.ObjectRefType {
	if m != nil {
		return m.UztnaGateway
	}
	return nil
}

// PerimeterREAdvertisement
//
// x-displayName: "PerimeterREAdvertisement"
// Advertise on all perimeter RE or Some Selected
// Perimter RE list
type PerimeterREAdvertisement struct {
	// Perimeter RE Advertisement
	//
	// x-displayName: "Perimeter RE Advertisement"
	//
	// Select either All perimeter RE or some of them.
	//
	// Types that are valid to be assigned to PerimterReChoice:
	//	*PerimeterREAdvertisement_AllPerimeter
	//	*PerimeterREAdvertisement_DomainReSites
	PerimterReChoice isPerimeterREAdvertisement_PerimterReChoice `protobuf_oneof:"perimter_re_choice"`
}

func (m *PerimeterREAdvertisement) Reset()      { *m = PerimeterREAdvertisement{} }
func (*PerimeterREAdvertisement) ProtoMessage() {}
func (*PerimeterREAdvertisement) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{3}
}
func (m *PerimeterREAdvertisement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PerimeterREAdvertisement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PerimeterREAdvertisement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PerimeterREAdvertisement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PerimeterREAdvertisement.Merge(m, src)
}
func (m *PerimeterREAdvertisement) XXX_Size() int {
	return m.Size()
}
func (m *PerimeterREAdvertisement) XXX_DiscardUnknown() {
	xxx_messageInfo_PerimeterREAdvertisement.DiscardUnknown(m)
}

var xxx_messageInfo_PerimeterREAdvertisement proto.InternalMessageInfo

type isPerimeterREAdvertisement_PerimterReChoice interface {
	isPerimeterREAdvertisement_PerimterReChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PerimeterREAdvertisement_AllPerimeter struct {
	AllPerimeter *schema.Empty `protobuf:"bytes,1,opt,name=all_perimeter,json=allPerimeter,proto3,oneof" json:"all_perimeter,omitempty"`
}
type PerimeterREAdvertisement_DomainReSites struct {
	DomainReSites *DomainPerimeterRE `protobuf:"bytes,2,opt,name=domain_re_sites,json=domainReSites,proto3,oneof" json:"domain_re_sites,omitempty"`
}

func (*PerimeterREAdvertisement_AllPerimeter) isPerimeterREAdvertisement_PerimterReChoice()  {}
func (*PerimeterREAdvertisement_DomainReSites) isPerimeterREAdvertisement_PerimterReChoice() {}

func (m *PerimeterREAdvertisement) GetPerimterReChoice() isPerimeterREAdvertisement_PerimterReChoice {
	if m != nil {
		return m.PerimterReChoice
	}
	return nil
}

func (m *PerimeterREAdvertisement) GetAllPerimeter() *schema.Empty {
	if x, ok := m.GetPerimterReChoice().(*PerimeterREAdvertisement_AllPerimeter); ok {
		return x.AllPerimeter
	}
	return nil
}

func (m *PerimeterREAdvertisement) GetDomainReSites() *DomainPerimeterRE {
	if x, ok := m.GetPerimterReChoice().(*PerimeterREAdvertisement_DomainReSites); ok {
		return x.DomainReSites
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PerimeterREAdvertisement) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PerimeterREAdvertisement_AllPerimeter)(nil),
		(*PerimeterREAdvertisement_DomainReSites)(nil),
	}
}

// Gateways
//
// x-displayName: "Gateways"
//
// Each UZTNA ZeroTrust Domain will have one or more gateways associated with it.
// The gateways represent the sites where the end user can connect to terminate
// the mTLS/DTLS tunnels. The gateways associated with a UZTNA ZeroTrust Domain would all be front
// ending the same set of applications and will enforce same set of policies for
// authentication and authorisation to grant access to these applications.
// This ensures same user experience no matter which gateway is reached for tunnel termination.
// Each Gateway will have a lease pool defined to allocate IP address to
// client for the terminated tunne
type Gateways struct {
	// PerimeterREAdvertisement
	//
	// x-displayName: "Perimeter RE"
	// Select the Gateways (either Perimeter RE or BigIP CE).
	PerimeterRe *PerimeterREAdvertisement `protobuf:"bytes,1,opt,name=perimeter_re,json=perimeterRe,proto3" json:"perimeter_re,omitempty"`
	// BigIP CE List
	//
	// x-displayName: "Available BigIP Next CE"
	// This is used to show all the available big ip ce.
	// From the available bigip CE List select bigip CE .
	BigipCe *DomainSites `protobuf:"bytes,2,opt,name=bigip_ce,json=bigipCe,proto3" json:"bigip_ce,omitempty"`
}

func (m *Gateways) Reset()      { *m = Gateways{} }
func (*Gateways) ProtoMessage() {}
func (*Gateways) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{4}
}
func (m *Gateways) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Gateways) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Gateways.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Gateways) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Gateways.Merge(m, src)
}
func (m *Gateways) XXX_Size() int {
	return m.Size()
}
func (m *Gateways) XXX_DiscardUnknown() {
	xxx_messageInfo_Gateways.DiscardUnknown(m)
}

var xxx_messageInfo_Gateways proto.InternalMessageInfo

func (m *Gateways) GetPerimeterRe() *PerimeterREAdvertisement {
	if m != nil {
		return m.PerimeterRe
	}
	return nil
}

func (m *Gateways) GetBigipCe() *DomainSites {
	if m != nil {
		return m.BigipCe
	}
	return nil
}

// TLS Certificate
//
// x-displayName: "Certificate"
// This is used to import or create new certificate for tls communication
type Certificate struct {
	// TLS Certificates
	//
	// x-displayName: "TLS Certificates"
	// Select/Add one or more TLS Certificate objects to associate with this ZeroTrust Domain
	Certificate []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=certificate,proto3" json:"certificate,omitempty"`
}

func (m *Certificate) Reset()      { *m = Certificate{} }
func (*Certificate) ProtoMessage() {}
func (*Certificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{5}
}
func (m *Certificate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Certificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Certificate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Certificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Certificate.Merge(m, src)
}
func (m *Certificate) XXX_Size() int {
	return m.Size()
}
func (m *Certificate) XXX_DiscardUnknown() {
	xxx_messageInfo_Certificate.DiscardUnknown(m)
}

var xxx_messageInfo_Certificate proto.InternalMessageInfo

func (m *Certificate) GetCertificate() []*schema.ObjectRefType {
	if m != nil {
		return m.Certificate
	}
	return nil
}

// GlobalSpecType
//
// x-displayName: "ZeroTrust Domain Info Specification"
// Shape of the view internal specification
type GlobalSpecType struct {
	// Leaspool
	//
	// x-displayName: "Leaspool object reference"
	// x-required
	// This is List of LeasePool Object created.From the List we can assign one LeasePool to one ZeroTrust Domain.
	LeasePool *LeasePoolList `protobuf:"bytes,1,opt,name=lease_pool,json=leasePool,proto3" json:"lease_pool,omitempty"`
	// Gateways
	//
	// x-displayName: "Gateways"
	// x-required
	// List of all RE prime and Big Ip edge CE
	Gateways *Gateways `protobuf:"bytes,2,opt,name=gateways,proto3" json:"gateways,omitempty"`
	// Access URL
	//
	// x-displayName: "Access Url"
	// x-example: "https://example.com/landing/page"
	// x-example: "/not-found"
	// x-required
	// Url to access the gateways
	AccessUrl string `protobuf:"bytes,3,opt,name=access_url,json=accessUrl,proto3" json:"access_url,omitempty"`
	// Certificate
	//
	// x-displayName: "Certificate"
	// x-required
	// A ZTNA ZeroTrust Domain being a TLS Gateway requires a Valid
	// Certificate associated with the Access FQDN.
	// The approach to attach a certificate and key to a
	// Domain in XC is an establis
	Cert *Certificate `protobuf:"bytes,4,opt,name=cert,proto3" json:"cert,omitempty"`
	// Profile Name
	//
	// x-displayName: "Ztna Profile"
	// x-required
	// Ztna Profile Name used to refer the ZTNA profile
	ProfileName string `protobuf:"bytes,5,opt,name=profile_name,json=profileName,proto3" json:"profile_name,omitempty"`
	// CDN CE gatway virtual host reference
	//
	// x-displayName: "CDN CE gateway virtual host reference"
	// Internal reference to cdn ce api gateway VH
	CdnCeVhApiGw []*schema.ObjectRefType `protobuf:"bytes,6,rep,name=cdn_ce_vh_api_gw,json=cdnCeVhApiGw,proto3" json:"cdn_ce_vh_api_gw,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{6}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobalSpecType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetLeasePool() *LeasePoolList {
	if m != nil {
		return m.LeasePool
	}
	return nil
}

func (m *GlobalSpecType) GetGateways() *Gateways {
	if m != nil {
		return m.Gateways
	}
	return nil
}

func (m *GlobalSpecType) GetAccessUrl() string {
	if m != nil {
		return m.AccessUrl
	}
	return ""
}

func (m *GlobalSpecType) GetCert() *Certificate {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *GlobalSpecType) GetProfileName() string {
	if m != nil {
		return m.ProfileName
	}
	return ""
}

func (m *GlobalSpecType) GetCdnCeVhApiGw() []*schema.ObjectRefType {
	if m != nil {
		return m.CdnCeVhApiGw
	}
	return nil
}

// CreateSpecType
//
// x-displayName: "Create Specification"
// Shape of the UZTNA ZeroTrust Domain
type CreateSpecType struct {
	LeasePool    *LeasePoolList          `protobuf:"bytes,1,opt,name=lease_pool,json=leasePool,proto3" json:"lease_pool,omitempty"`
	Gateways     *Gateways               `protobuf:"bytes,2,opt,name=gateways,proto3" json:"gateways,omitempty"`
	AccessUrl    string                  `protobuf:"bytes,3,opt,name=access_url,json=accessUrl,proto3" json:"access_url,omitempty"`
	Cert         *Certificate            `protobuf:"bytes,4,opt,name=cert,proto3" json:"cert,omitempty"`
	ProfileName  string                  `protobuf:"bytes,5,opt,name=profile_name,json=profileName,proto3" json:"profile_name,omitempty"`
	CdnCeVhApiGw []*schema.ObjectRefType `protobuf:"bytes,6,rep,name=cdn_ce_vh_api_gw,json=cdnCeVhApiGw,proto3" json:"cdn_ce_vh_api_gw,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{7}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateSpecType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetLeasePool() *LeasePoolList {
	if m != nil {
		return m.LeasePool
	}
	return nil
}

func (m *CreateSpecType) GetGateways() *Gateways {
	if m != nil {
		return m.Gateways
	}
	return nil
}

func (m *CreateSpecType) GetAccessUrl() string {
	if m != nil {
		return m.AccessUrl
	}
	return ""
}

func (m *CreateSpecType) GetCert() *Certificate {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *CreateSpecType) GetProfileName() string {
	if m != nil {
		return m.ProfileName
	}
	return ""
}

func (m *CreateSpecType) GetCdnCeVhApiGw() []*schema.ObjectRefType {
	if m != nil {
		return m.CdnCeVhApiGw
	}
	return nil
}

// ReplaceSpecType
//
// x-displayName: "Replace Specification"
// Shape of the UZTNA ZeroTrust Domain
type ReplaceSpecType struct {
	LeasePool    *LeasePoolList          `protobuf:"bytes,1,opt,name=lease_pool,json=leasePool,proto3" json:"lease_pool,omitempty"`
	Gateways     *Gateways               `protobuf:"bytes,2,opt,name=gateways,proto3" json:"gateways,omitempty"`
	AccessUrl    string                  `protobuf:"bytes,3,opt,name=access_url,json=accessUrl,proto3" json:"access_url,omitempty"`
	Cert         *Certificate            `protobuf:"bytes,4,opt,name=cert,proto3" json:"cert,omitempty"`
	ProfileName  string                  `protobuf:"bytes,5,opt,name=profile_name,json=profileName,proto3" json:"profile_name,omitempty"`
	CdnCeVhApiGw []*schema.ObjectRefType `protobuf:"bytes,6,rep,name=cdn_ce_vh_api_gw,json=cdnCeVhApiGw,proto3" json:"cdn_ce_vh_api_gw,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{8}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplaceSpecType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

func (m *ReplaceSpecType) GetLeasePool() *LeasePoolList {
	if m != nil {
		return m.LeasePool
	}
	return nil
}

func (m *ReplaceSpecType) GetGateways() *Gateways {
	if m != nil {
		return m.Gateways
	}
	return nil
}

func (m *ReplaceSpecType) GetAccessUrl() string {
	if m != nil {
		return m.AccessUrl
	}
	return ""
}

func (m *ReplaceSpecType) GetCert() *Certificate {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *ReplaceSpecType) GetProfileName() string {
	if m != nil {
		return m.ProfileName
	}
	return ""
}

func (m *ReplaceSpecType) GetCdnCeVhApiGw() []*schema.ObjectRefType {
	if m != nil {
		return m.CdnCeVhApiGw
	}
	return nil
}

// GetSpecType
//
// x-displayName: "Get Specification"
// Shape of the UZTNA ZeroTrust Domain
type GetSpecType struct {
	LeasePool    *LeasePoolList          `protobuf:"bytes,1,opt,name=lease_pool,json=leasePool,proto3" json:"lease_pool,omitempty"`
	Gateways     *Gateways               `protobuf:"bytes,2,opt,name=gateways,proto3" json:"gateways,omitempty"`
	AccessUrl    string                  `protobuf:"bytes,3,opt,name=access_url,json=accessUrl,proto3" json:"access_url,omitempty"`
	Cert         *Certificate            `protobuf:"bytes,4,opt,name=cert,proto3" json:"cert,omitempty"`
	ProfileName  string                  `protobuf:"bytes,5,opt,name=profile_name,json=profileName,proto3" json:"profile_name,omitempty"`
	CdnCeVhApiGw []*schema.ObjectRefType `protobuf:"bytes,6,rep,name=cdn_ce_vh_api_gw,json=cdnCeVhApiGw,proto3" json:"cdn_ce_vh_api_gw,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{9}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSpecType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetLeasePool() *LeasePoolList {
	if m != nil {
		return m.LeasePool
	}
	return nil
}

func (m *GetSpecType) GetGateways() *Gateways {
	if m != nil {
		return m.Gateways
	}
	return nil
}

func (m *GetSpecType) GetAccessUrl() string {
	if m != nil {
		return m.AccessUrl
	}
	return ""
}

func (m *GetSpecType) GetCert() *Certificate {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *GetSpecType) GetProfileName() string {
	if m != nil {
		return m.ProfileName
	}
	return ""
}

func (m *GetSpecType) GetCdnCeVhApiGw() []*schema.ObjectRefType {
	if m != nil {
		return m.CdnCeVhApiGw
	}
	return nil
}

func init() {
	proto.RegisterType((*LeasePoolList)(nil), "ves.io.schema.uztna.uztna_domain.LeasePoolList")
	proto.RegisterType((*DomainPerimeterRE)(nil), "ves.io.schema.uztna.uztna_domain.DomainPerimeterRE")
	proto.RegisterType((*DomainSites)(nil), "ves.io.schema.uztna.uztna_domain.DomainSites")
	proto.RegisterType((*PerimeterREAdvertisement)(nil), "ves.io.schema.uztna.uztna_domain.PerimeterREAdvertisement")
	proto.RegisterType((*Gateways)(nil), "ves.io.schema.uztna.uztna_domain.Gateways")
	proto.RegisterType((*Certificate)(nil), "ves.io.schema.uztna.uztna_domain.Certificate")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.uztna.uztna_domain.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.uztna.uztna_domain.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.uztna.uztna_domain.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.uztna.uztna_domain.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/uztna/uztna_domain/types.proto", fileDescriptor_4628a4276549e24f)
}

var fileDescriptor_4628a4276549e24f = []byte{
	// 902 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x56, 0xcf, 0x6f, 0x1b, 0x45,
	0x14, 0xf6, 0xd8, 0x4e, 0x71, 0xde, 0xda, 0x4d, 0xb2, 0xaa, 0xc4, 0x12, 0xca, 0xe2, 0xae, 0x38,
	0x44, 0x55, 0xb3, 0x96, 0xd2, 0x5b, 0x90, 0x90, 0x92, 0x34, 0x24, 0x40, 0x54, 0xaa, 0x2d, 0x2d,
	0x08, 0x14, 0xad, 0xc6, 0xeb, 0x67, 0x7b, 0xca, 0xd8, 0xb3, 0x9a, 0x9d, 0x38, 0x04, 0xc9, 0x92,
	0x25, 0x24, 0xb8, 0x70, 0x40, 0xfc, 0x15, 0x28, 0x27, 0x24, 0x6e, 0x98, 0x43, 0x25, 0x2e, 0xa8,
	0xa7, 0x1c, 0x73, 0x24, 0xce, 0xa5, 0xdc, 0x7a, 0xe4, 0x88, 0xf6, 0x87, 0xcd, 0x6e, 0x4c, 0x15,
	0x0b, 0x21, 0x95, 0x43, 0x2f, 0x96, 0x67, 0xde, 0xfb, 0xde, 0x37, 0xef, 0xfb, 0xde, 0xac, 0x06,
	0x6e, 0xf5, 0x30, 0xb0, 0x99, 0xa8, 0x05, 0x5e, 0x1b, 0x3b, 0xb4, 0x76, 0xf0, 0xa5, 0xea, 0x26,
	0xbf, 0x6e, 0x43, 0x74, 0x28, 0xeb, 0xd6, 0xd4, 0x91, 0x8f, 0x81, 0xed, 0x4b, 0xa1, 0x84, 0x5e,
	0x8d, 0xb3, 0xed, 0x38, 0xdb, 0x8e, 0xf2, 0xec, 0x74, 0xf6, 0xf2, 0xab, 0xd9, 0x7a, 0x5d, 0x54,
	0x31, 0x74, 0xf9, 0xf5, 0x6c, 0x40, 0xf8, 0x8a, 0x89, 0x6e, 0x52, 0x77, 0xf9, 0xb5, 0x6c, 0x30,
	0x45, 0xb9, 0x7c, 0x3d, 0x1b, 0xea, 0x51, 0xce, 0x1a, 0x54, 0x61, 0x12, 0xad, 0x5e, 0x88, 0x32,
	0x3c, 0x74, 0xb3, 0xa5, 0xdf, 0x9c, 0xce, 0x08, 0xd2, 0x04, 0x96, 0x0f, 0x95, 0x3d, 0xa4, 0x01,
	0xde, 0x13, 0x82, 0xef, 0xb1, 0x40, 0xe9, 0x2e, 0x68, 0x71, 0x4b, 0xdc, 0x17, 0x82, 0x1b, 0xa4,
	0x5a, 0x58, 0xd1, 0xd6, 0xae, 0xdb, 0xd9, 0xd6, 0x3f, 0xac, 0x3f, 0x42, 0x4f, 0x39, 0xd8, 0xfc,
	0xe8, 0xc8, 0xc7, 0xcd, 0xea, 0x71, 0x7f, 0x21, 0xc1, 0x84, 0xa5, 0x42, 0xdc, 0xe0, 0x17, 0x42,
	0x7e, 0xfe, 0xe3, 0x71, 0x61, 0xee, 0x7b, 0x92, 0x5f, 0x24, 0x0e, 0x44, 0xe1, 0xbd, 0x30, 0x62,
	0x3d, 0x82, 0xa5, 0x3b, 0x91, 0x5a, 0xf7, 0x50, 0xb2, 0x0e, 0x2a, 0x94, 0xce, 0xb6, 0xfe, 0x00,
	0x96, 0xfc, 0xf1, 0xd2, 0x95, 0xe8, 0x06, 0x4c, 0xe1, 0x4c, 0xdc, 0xda, 0x71, 0xbf, 0x18, 0x26,
	0x87, 0x84, 0xce, 0xc2, 0xa4, 0x86, 0x83, 0xf7, 0x99, 0x42, 0xab, 0x09, 0x5a, 0xcc, 0x15, 0xae,
	0x02, 0xfd, 0x63, 0xa8, 0xc4, 0xe7, 0x6c, 0x51, 0x85, 0x87, 0xf4, 0x68, 0x26, 0x86, 0x6b, 0xc7,
	0xfd, 0x2c, 0x2a, 0xa2, 0x2a, 0x47, 0x5b, 0x3b, 0xf1, 0x8e, 0xf5, 0x6b, 0x1e, 0x8c, 0x54, 0x3b,
	0x1b, 0x8d, 0x1e, 0x4a, 0xc5, 0x02, 0xec, 0x60, 0x57, 0xe9, 0x6f, 0x43, 0x85, 0x72, 0xee, 0x4e,
	0xce, 0x66, 0x90, 0x2a, 0x59, 0xd1, 0xd6, 0xae, 0x5d, 0x60, 0xdd, 0xee, 0xf8, 0xea, 0x68, 0x37,
	0xe7, 0x94, 0x29, 0xe7, 0x93, 0x5a, 0xfa, 0x3e, 0x2c, 0xc4, 0xb3, 0x35, 0x56, 0x25, 0x30, 0xf2,
	0x11, 0xfc, 0xb6, 0x7d, 0xd9, 0x34, 0xda, 0x53, 0x32, 0xef, 0xe6, 0x9c, 0x4a, 0x1c, 0x8b, 0xf5,
	0x09, 0xd6, 0xe9, 0x93, 0x21, 0xd9, 0x87, 0xcf, 0xa0, 0x3c, 0xc9, 0xaa, 0x3a, 0xdb, 0x37, 0x3f,
	0x80, 0xf7, 0xe0, 0xc6, 0x85, 0x53, 0xaf, 0x2d, 0x6e, 0x70, 0x5e, 0x4d, 0xa7, 0xc1, 0x5b, 0x53,
	0x67, 0x5b, 0x9b, 0xb6, 0x76, 0xd3, 0x02, 0x3d, 0x2a, 0x92, 0x38, 0xeb, 0xb5, 0x05, 0xf3, 0x50,
	0x2f, 0x3f, 0x1e, 0x12, 0x72, 0x32, 0x24, 0xc5, 0x3f, 0x87, 0x24, 0xff, 0x7e, 0xb1, 0x54, 0x5c,
	0x9c, 0xb3, 0x7e, 0x22, 0x50, 0x4a, 0x14, 0x0d, 0xf4, 0x7d, 0x28, 0xa7, 0x27, 0x22, 0x11, 0x6d,
	0xfd, 0xf2, 0xae, 0x9f, 0xe7, 0x83, 0xa3, 0xa5, 0xa6, 0x43, 0xdf, 0x85, 0x52, 0x9d, 0xb5, 0x98,
	0xef, 0x7a, 0x98, 0x08, 0xba, 0x3a, 0xab, 0xa0, 0x91, 0x72, 0xce, 0x2b, 0x11, 0x7c, 0x0b, 0xad,
	0x16, 0x68, 0x5b, 0x21, 0x4b, 0x93, 0x79, 0x54, 0xa1, 0xfe, 0x09, 0x68, 0xde, 0xdf, 0x4b, 0x23,
	0x3f, 0xc3, 0x84, 0x19, 0xc7, 0xfd, 0x34, 0x26, 0x75, 0x6f, 0xd2, 0xdb, 0xd6, 0x8f, 0x05, 0xb8,
	0xba, 0xc3, 0x45, 0x9d, 0xf2, 0xfb, 0x3e, 0x7a, 0x21, 0x52, 0xbf, 0x0b, 0x10, 0x5d, 0x39, 0x37,
	0xb9, 0xab, 0x61, 0x1f, 0xb5, 0xcb, 0xfb, 0xc8, 0xdc, 0x78, 0x67, 0x9e, 0x8f, 0x97, 0xfa, 0xbb,
	0x50, 0x4a, 0x86, 0x7c, 0x3c, 0x66, 0x37, 0x2f, 0xaf, 0x36, 0xb6, 0xcc, 0x99, 0x60, 0xf5, 0x5b,
	0x00, 0xd4, 0xf3, 0x30, 0x08, 0xdc, 0x03, 0xc9, 0x8d, 0x42, 0x95, 0xac, 0xcc, 0x6f, 0x56, 0xc2,
	0xbe, 0x4a, 0xf2, 0xca, 0xca, 0xa0, 0x34, 0x98, 0x23, 0xce, 0x7c, 0x9c, 0xf0, 0x40, 0x72, 0x7d,
	0x03, 0x8a, 0x61, 0x9f, 0x46, 0x71, 0x56, 0x1f, 0x52, 0x7a, 0x3b, 0x11, 0x54, 0x5f, 0x85, 0xb2,
	0x2f, 0x45, 0x93, 0x71, 0x74, 0xbb, 0xb4, 0x83, 0xc6, 0x5c, 0x44, 0x09, 0x91, 0x94, 0xb2, 0x60,
	0x0c, 0x4a, 0x8e, 0x96, 0xc4, 0xef, 0xd2, 0x0e, 0xea, 0x4d, 0x58, 0xf4, 0x1a, 0x5d, 0xd7, 0x43,
	0xb7, 0xd7, 0x76, 0xa9, 0xcf, 0xdc, 0xd6, 0xa1, 0x71, 0x65, 0xb6, 0x2f, 0x5d, 0xb9, 0xc7, 0xa4,
	0x3a, 0xa0, 0xdc, 0x6d, 0x8b, 0x40, 0x9d, 0xf6, 0xc9, 0xd3, 0x61, 0xe6, 0x4b, 0x57, 0xf6, 0x1a,
	0xdd, 0x2d, 0x7c, 0xd8, 0xde, 0xf0, 0xd9, 0xce, 0xa1, 0xf5, 0x75, 0x01, 0xae, 0x6e, 0x49, 0xa4,
	0x0a, 0xff, 0xf7, 0x96, 0xbd, 0x31, 0x6d, 0xd9, 0x7f, 0xec, 0xd1, 0x8d, 0x7f, 0xf2, 0x28, 0xeb,
	0xcb, 0x9d, 0x7f, 0xe7, 0x4b, 0x56, 0xf5, 0xf5, 0xa5, 0x27, 0xef, 0x5c, 0xb8, 0x28, 0xd6, 0x37,
	0x05, 0x58, 0x70, 0xd0, 0xe7, 0xd4, 0x7b, 0xe9, 0xc4, 0x8b, 0x75, 0xe2, 0xab, 0x02, 0x68, 0x3b,
	0xa8, 0x5e, 0xba, 0xf0, 0x22, 0x5d, 0xd8, 0xfc, 0x96, 0x9c, 0x9c, 0x99, 0xb9, 0xd3, 0x33, 0x33,
	0xf7, 0xec, 0xcc, 0x24, 0x83, 0x91, 0x49, 0x7e, 0x18, 0x99, 0xe4, 0xb7, 0x91, 0x49, 0x4e, 0x46,
	0x26, 0xf9, 0x7d, 0x64, 0x92, 0xa7, 0x23, 0x33, 0xf7, 0x6c, 0x64, 0x92, 0xef, 0xce, 0xcd, 0xdc,
	0xc9, 0xb9, 0x99, 0x3b, 0x3d, 0x37, 0x73, 0x9f, 0x3e, 0x6c, 0x09, 0xff, 0xf3, 0x96, 0xdd, 0x13,
	0x5c, 0xa1, 0x94, 0xd4, 0x3e, 0x08, 0x6a, 0xd1, 0x9f, 0xa6, 0x90, 0x9d, 0x55, 0x5f, 0x8a, 0x1e,
	0x6b, 0xa0, 0x5c, 0x1d, 0x87, 0x6b, 0x7e, 0xbd, 0x25, 0x6a, 0xf8, 0x85, 0x4a, 0x5e, 0x9f, 0xcf,
	0x7d, 0x65, 0xd7, 0xaf, 0x44, 0x8f, 0xd1, 0xdb, 0x7f, 0x05, 0x00, 0x00, 0xff, 0xff, 0x5f, 0x52,
	0x4a, 0x2a, 0x90, 0x0b, 0x00, 0x00,
}

func (this *LeasePoolList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LeasePoolList)
	if !ok {
		that2, ok := that.(LeasePoolList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.UztnaLpool) != len(that1.UztnaLpool) {
		return false
	}
	for i := range this.UztnaLpool {
		if !this.UztnaLpool[i].Equal(that1.UztnaLpool[i]) {
			return false
		}
	}
	return true
}
func (this *DomainPerimeterRE) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DomainPerimeterRE)
	if !ok {
		that2, ok := that.(DomainPerimeterRE)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.PerimeterReSite) != len(that1.PerimeterReSite) {
		return false
	}
	for i := range this.PerimeterReSite {
		if !this.PerimeterReSite[i].Equal(that1.PerimeterReSite[i]) {
			return false
		}
	}
	return true
}
func (this *DomainSites) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DomainSites)
	if !ok {
		that2, ok := that.(DomainSites)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.UztnaGateway) != len(that1.UztnaGateway) {
		return false
	}
	for i := range this.UztnaGateway {
		if !this.UztnaGateway[i].Equal(that1.UztnaGateway[i]) {
			return false
		}
	}
	return true
}
func (this *PerimeterREAdvertisement) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PerimeterREAdvertisement)
	if !ok {
		that2, ok := that.(PerimeterREAdvertisement)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PerimterReChoice == nil {
		if this.PerimterReChoice != nil {
			return false
		}
	} else if this.PerimterReChoice == nil {
		return false
	} else if !this.PerimterReChoice.Equal(that1.PerimterReChoice) {
		return false
	}
	return true
}
func (this *PerimeterREAdvertisement_AllPerimeter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PerimeterREAdvertisement_AllPerimeter)
	if !ok {
		that2, ok := that.(PerimeterREAdvertisement_AllPerimeter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllPerimeter.Equal(that1.AllPerimeter) {
		return false
	}
	return true
}
func (this *PerimeterREAdvertisement_DomainReSites) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PerimeterREAdvertisement_DomainReSites)
	if !ok {
		that2, ok := that.(PerimeterREAdvertisement_DomainReSites)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DomainReSites.Equal(that1.DomainReSites) {
		return false
	}
	return true
}
func (this *Gateways) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Gateways)
	if !ok {
		that2, ok := that.(Gateways)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PerimeterRe.Equal(that1.PerimeterRe) {
		return false
	}
	if !this.BigipCe.Equal(that1.BigipCe) {
		return false
	}
	return true
}
func (this *Certificate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Certificate)
	if !ok {
		that2, ok := that.(Certificate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Certificate) != len(that1.Certificate) {
		return false
	}
	for i := range this.Certificate {
		if !this.Certificate[i].Equal(that1.Certificate[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LeasePool.Equal(that1.LeasePool) {
		return false
	}
	if !this.Gateways.Equal(that1.Gateways) {
		return false
	}
	if this.AccessUrl != that1.AccessUrl {
		return false
	}
	if !this.Cert.Equal(that1.Cert) {
		return false
	}
	if this.ProfileName != that1.ProfileName {
		return false
	}
	if len(this.CdnCeVhApiGw) != len(that1.CdnCeVhApiGw) {
		return false
	}
	for i := range this.CdnCeVhApiGw {
		if !this.CdnCeVhApiGw[i].Equal(that1.CdnCeVhApiGw[i]) {
			return false
		}
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LeasePool.Equal(that1.LeasePool) {
		return false
	}
	if !this.Gateways.Equal(that1.Gateways) {
		return false
	}
	if this.AccessUrl != that1.AccessUrl {
		return false
	}
	if !this.Cert.Equal(that1.Cert) {
		return false
	}
	if this.ProfileName != that1.ProfileName {
		return false
	}
	if len(this.CdnCeVhApiGw) != len(that1.CdnCeVhApiGw) {
		return false
	}
	for i := range this.CdnCeVhApiGw {
		if !this.CdnCeVhApiGw[i].Equal(that1.CdnCeVhApiGw[i]) {
			return false
		}
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LeasePool.Equal(that1.LeasePool) {
		return false
	}
	if !this.Gateways.Equal(that1.Gateways) {
		return false
	}
	if this.AccessUrl != that1.AccessUrl {
		return false
	}
	if !this.Cert.Equal(that1.Cert) {
		return false
	}
	if this.ProfileName != that1.ProfileName {
		return false
	}
	if len(this.CdnCeVhApiGw) != len(that1.CdnCeVhApiGw) {
		return false
	}
	for i := range this.CdnCeVhApiGw {
		if !this.CdnCeVhApiGw[i].Equal(that1.CdnCeVhApiGw[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LeasePool.Equal(that1.LeasePool) {
		return false
	}
	if !this.Gateways.Equal(that1.Gateways) {
		return false
	}
	if this.AccessUrl != that1.AccessUrl {
		return false
	}
	if !this.Cert.Equal(that1.Cert) {
		return false
	}
	if this.ProfileName != that1.ProfileName {
		return false
	}
	if len(this.CdnCeVhApiGw) != len(that1.CdnCeVhApiGw) {
		return false
	}
	for i := range this.CdnCeVhApiGw {
		if !this.CdnCeVhApiGw[i].Equal(that1.CdnCeVhApiGw[i]) {
			return false
		}
	}
	return true
}
func (this *LeasePoolList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_domain.LeasePoolList{")
	if this.UztnaLpool != nil {
		s = append(s, "UztnaLpool: "+fmt.Sprintf("%#v", this.UztnaLpool)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DomainPerimeterRE) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_domain.DomainPerimeterRE{")
	if this.PerimeterReSite != nil {
		s = append(s, "PerimeterReSite: "+fmt.Sprintf("%#v", this.PerimeterReSite)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DomainSites) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_domain.DomainSites{")
	if this.UztnaGateway != nil {
		s = append(s, "UztnaGateway: "+fmt.Sprintf("%#v", this.UztnaGateway)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PerimeterREAdvertisement) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_domain.PerimeterREAdvertisement{")
	if this.PerimterReChoice != nil {
		s = append(s, "PerimterReChoice: "+fmt.Sprintf("%#v", this.PerimterReChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PerimeterREAdvertisement_AllPerimeter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_domain.PerimeterREAdvertisement_AllPerimeter{` +
		`AllPerimeter:` + fmt.Sprintf("%#v", this.AllPerimeter) + `}`}, ", ")
	return s
}
func (this *PerimeterREAdvertisement_DomainReSites) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_domain.PerimeterREAdvertisement_DomainReSites{` +
		`DomainReSites:` + fmt.Sprintf("%#v", this.DomainReSites) + `}`}, ", ")
	return s
}
func (this *Gateways) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_domain.Gateways{")
	if this.PerimeterRe != nil {
		s = append(s, "PerimeterRe: "+fmt.Sprintf("%#v", this.PerimeterRe)+",\n")
	}
	if this.BigipCe != nil {
		s = append(s, "BigipCe: "+fmt.Sprintf("%#v", this.BigipCe)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Certificate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_domain.Certificate{")
	if this.Certificate != nil {
		s = append(s, "Certificate: "+fmt.Sprintf("%#v", this.Certificate)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&uztna_domain.GlobalSpecType{")
	if this.LeasePool != nil {
		s = append(s, "LeasePool: "+fmt.Sprintf("%#v", this.LeasePool)+",\n")
	}
	if this.Gateways != nil {
		s = append(s, "Gateways: "+fmt.Sprintf("%#v", this.Gateways)+",\n")
	}
	s = append(s, "AccessUrl: "+fmt.Sprintf("%#v", this.AccessUrl)+",\n")
	if this.Cert != nil {
		s = append(s, "Cert: "+fmt.Sprintf("%#v", this.Cert)+",\n")
	}
	s = append(s, "ProfileName: "+fmt.Sprintf("%#v", this.ProfileName)+",\n")
	if this.CdnCeVhApiGw != nil {
		s = append(s, "CdnCeVhApiGw: "+fmt.Sprintf("%#v", this.CdnCeVhApiGw)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&uztna_domain.CreateSpecType{")
	if this.LeasePool != nil {
		s = append(s, "LeasePool: "+fmt.Sprintf("%#v", this.LeasePool)+",\n")
	}
	if this.Gateways != nil {
		s = append(s, "Gateways: "+fmt.Sprintf("%#v", this.Gateways)+",\n")
	}
	s = append(s, "AccessUrl: "+fmt.Sprintf("%#v", this.AccessUrl)+",\n")
	if this.Cert != nil {
		s = append(s, "Cert: "+fmt.Sprintf("%#v", this.Cert)+",\n")
	}
	s = append(s, "ProfileName: "+fmt.Sprintf("%#v", this.ProfileName)+",\n")
	if this.CdnCeVhApiGw != nil {
		s = append(s, "CdnCeVhApiGw: "+fmt.Sprintf("%#v", this.CdnCeVhApiGw)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&uztna_domain.ReplaceSpecType{")
	if this.LeasePool != nil {
		s = append(s, "LeasePool: "+fmt.Sprintf("%#v", this.LeasePool)+",\n")
	}
	if this.Gateways != nil {
		s = append(s, "Gateways: "+fmt.Sprintf("%#v", this.Gateways)+",\n")
	}
	s = append(s, "AccessUrl: "+fmt.Sprintf("%#v", this.AccessUrl)+",\n")
	if this.Cert != nil {
		s = append(s, "Cert: "+fmt.Sprintf("%#v", this.Cert)+",\n")
	}
	s = append(s, "ProfileName: "+fmt.Sprintf("%#v", this.ProfileName)+",\n")
	if this.CdnCeVhApiGw != nil {
		s = append(s, "CdnCeVhApiGw: "+fmt.Sprintf("%#v", this.CdnCeVhApiGw)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&uztna_domain.GetSpecType{")
	if this.LeasePool != nil {
		s = append(s, "LeasePool: "+fmt.Sprintf("%#v", this.LeasePool)+",\n")
	}
	if this.Gateways != nil {
		s = append(s, "Gateways: "+fmt.Sprintf("%#v", this.Gateways)+",\n")
	}
	s = append(s, "AccessUrl: "+fmt.Sprintf("%#v", this.AccessUrl)+",\n")
	if this.Cert != nil {
		s = append(s, "Cert: "+fmt.Sprintf("%#v", this.Cert)+",\n")
	}
	s = append(s, "ProfileName: "+fmt.Sprintf("%#v", this.ProfileName)+",\n")
	if this.CdnCeVhApiGw != nil {
		s = append(s, "CdnCeVhApiGw: "+fmt.Sprintf("%#v", this.CdnCeVhApiGw)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *LeasePoolList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeasePoolList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeasePoolList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UztnaLpool) > 0 {
		for iNdEx := len(m.UztnaLpool) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UztnaLpool[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DomainPerimeterRE) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainPerimeterRE) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainPerimeterRE) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PerimeterReSite) > 0 {
		for iNdEx := len(m.PerimeterReSite) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PerimeterReSite[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DomainSites) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainSites) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainSites) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UztnaGateway) > 0 {
		for iNdEx := len(m.UztnaGateway) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UztnaGateway[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PerimeterREAdvertisement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PerimeterREAdvertisement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerimeterREAdvertisement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PerimterReChoice != nil {
		{
			size := m.PerimterReChoice.Size()
			i -= size
			if _, err := m.PerimterReChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PerimeterREAdvertisement_AllPerimeter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerimeterREAdvertisement_AllPerimeter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllPerimeter != nil {
		{
			size, err := m.AllPerimeter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *PerimeterREAdvertisement_DomainReSites) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerimeterREAdvertisement_DomainReSites) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DomainReSites != nil {
		{
			size, err := m.DomainReSites.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Gateways) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Gateways) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Gateways) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BigipCe != nil {
		{
			size, err := m.BigipCe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PerimeterRe != nil {
		{
			size, err := m.PerimeterRe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Certificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Certificate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Certificate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Certificate) > 0 {
		for iNdEx := len(m.Certificate) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Certificate[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CdnCeVhApiGw) > 0 {
		for iNdEx := len(m.CdnCeVhApiGw) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CdnCeVhApiGw[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ProfileName) > 0 {
		i -= len(m.ProfileName)
		copy(dAtA[i:], m.ProfileName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProfileName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Cert != nil {
		{
			size, err := m.Cert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.AccessUrl) > 0 {
		i -= len(m.AccessUrl)
		copy(dAtA[i:], m.AccessUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccessUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Gateways != nil {
		{
			size, err := m.Gateways.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LeasePool != nil {
		{
			size, err := m.LeasePool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CdnCeVhApiGw) > 0 {
		for iNdEx := len(m.CdnCeVhApiGw) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CdnCeVhApiGw[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ProfileName) > 0 {
		i -= len(m.ProfileName)
		copy(dAtA[i:], m.ProfileName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProfileName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Cert != nil {
		{
			size, err := m.Cert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.AccessUrl) > 0 {
		i -= len(m.AccessUrl)
		copy(dAtA[i:], m.AccessUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccessUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Gateways != nil {
		{
			size, err := m.Gateways.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LeasePool != nil {
		{
			size, err := m.LeasePool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CdnCeVhApiGw) > 0 {
		for iNdEx := len(m.CdnCeVhApiGw) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CdnCeVhApiGw[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ProfileName) > 0 {
		i -= len(m.ProfileName)
		copy(dAtA[i:], m.ProfileName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProfileName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Cert != nil {
		{
			size, err := m.Cert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.AccessUrl) > 0 {
		i -= len(m.AccessUrl)
		copy(dAtA[i:], m.AccessUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccessUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Gateways != nil {
		{
			size, err := m.Gateways.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LeasePool != nil {
		{
			size, err := m.LeasePool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CdnCeVhApiGw) > 0 {
		for iNdEx := len(m.CdnCeVhApiGw) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CdnCeVhApiGw[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ProfileName) > 0 {
		i -= len(m.ProfileName)
		copy(dAtA[i:], m.ProfileName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProfileName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Cert != nil {
		{
			size, err := m.Cert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.AccessUrl) > 0 {
		i -= len(m.AccessUrl)
		copy(dAtA[i:], m.AccessUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccessUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Gateways != nil {
		{
			size, err := m.Gateways.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LeasePool != nil {
		{
			size, err := m.LeasePool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LeasePoolList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UztnaLpool) > 0 {
		for _, e := range m.UztnaLpool {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DomainPerimeterRE) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PerimeterReSite) > 0 {
		for _, e := range m.PerimeterReSite {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DomainSites) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UztnaGateway) > 0 {
		for _, e := range m.UztnaGateway {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PerimeterREAdvertisement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PerimterReChoice != nil {
		n += m.PerimterReChoice.Size()
	}
	return n
}

func (m *PerimeterREAdvertisement_AllPerimeter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllPerimeter != nil {
		l = m.AllPerimeter.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PerimeterREAdvertisement_DomainReSites) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DomainReSites != nil {
		l = m.DomainReSites.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Gateways) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PerimeterRe != nil {
		l = m.PerimeterRe.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BigipCe != nil {
		l = m.BigipCe.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Certificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Certificate) > 0 {
		for _, e := range m.Certificate {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeasePool != nil {
		l = m.LeasePool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Gateways != nil {
		l = m.Gateways.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AccessUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cert != nil {
		l = m.Cert.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProfileName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CdnCeVhApiGw) > 0 {
		for _, e := range m.CdnCeVhApiGw {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeasePool != nil {
		l = m.LeasePool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Gateways != nil {
		l = m.Gateways.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AccessUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cert != nil {
		l = m.Cert.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProfileName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CdnCeVhApiGw) > 0 {
		for _, e := range m.CdnCeVhApiGw {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeasePool != nil {
		l = m.LeasePool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Gateways != nil {
		l = m.Gateways.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AccessUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cert != nil {
		l = m.Cert.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProfileName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CdnCeVhApiGw) > 0 {
		for _, e := range m.CdnCeVhApiGw {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeasePool != nil {
		l = m.LeasePool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Gateways != nil {
		l = m.Gateways.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AccessUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cert != nil {
		l = m.Cert.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProfileName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CdnCeVhApiGw) > 0 {
		for _, e := range m.CdnCeVhApiGw {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *LeasePoolList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForUztnaLpool := "[]*ObjectRefType{"
	for _, f := range this.UztnaLpool {
		repeatedStringForUztnaLpool += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForUztnaLpool += "}"
	s := strings.Join([]string{`&LeasePoolList{`,
		`UztnaLpool:` + repeatedStringForUztnaLpool + `,`,
		`}`,
	}, "")
	return s
}
func (this *DomainPerimeterRE) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPerimeterReSite := "[]*ObjectRefType{"
	for _, f := range this.PerimeterReSite {
		repeatedStringForPerimeterReSite += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForPerimeterReSite += "}"
	s := strings.Join([]string{`&DomainPerimeterRE{`,
		`PerimeterReSite:` + repeatedStringForPerimeterReSite + `,`,
		`}`,
	}, "")
	return s
}
func (this *DomainSites) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForUztnaGateway := "[]*ObjectRefType{"
	for _, f := range this.UztnaGateway {
		repeatedStringForUztnaGateway += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForUztnaGateway += "}"
	s := strings.Join([]string{`&DomainSites{`,
		`UztnaGateway:` + repeatedStringForUztnaGateway + `,`,
		`}`,
	}, "")
	return s
}
func (this *PerimeterREAdvertisement) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PerimeterREAdvertisement{`,
		`PerimterReChoice:` + fmt.Sprintf("%v", this.PerimterReChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PerimeterREAdvertisement_AllPerimeter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PerimeterREAdvertisement_AllPerimeter{`,
		`AllPerimeter:` + strings.Replace(fmt.Sprintf("%v", this.AllPerimeter), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PerimeterREAdvertisement_DomainReSites) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PerimeterREAdvertisement_DomainReSites{`,
		`DomainReSites:` + strings.Replace(fmt.Sprintf("%v", this.DomainReSites), "DomainPerimeterRE", "DomainPerimeterRE", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Gateways) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Gateways{`,
		`PerimeterRe:` + strings.Replace(this.PerimeterRe.String(), "PerimeterREAdvertisement", "PerimeterREAdvertisement", 1) + `,`,
		`BigipCe:` + strings.Replace(this.BigipCe.String(), "DomainSites", "DomainSites", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Certificate) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCertificate := "[]*ObjectRefType{"
	for _, f := range this.Certificate {
		repeatedStringForCertificate += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCertificate += "}"
	s := strings.Join([]string{`&Certificate{`,
		`Certificate:` + repeatedStringForCertificate + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCdnCeVhApiGw := "[]*ObjectRefType{"
	for _, f := range this.CdnCeVhApiGw {
		repeatedStringForCdnCeVhApiGw += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCdnCeVhApiGw += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`LeasePool:` + strings.Replace(this.LeasePool.String(), "LeasePoolList", "LeasePoolList", 1) + `,`,
		`Gateways:` + strings.Replace(this.Gateways.String(), "Gateways", "Gateways", 1) + `,`,
		`AccessUrl:` + fmt.Sprintf("%v", this.AccessUrl) + `,`,
		`Cert:` + strings.Replace(this.Cert.String(), "Certificate", "Certificate", 1) + `,`,
		`ProfileName:` + fmt.Sprintf("%v", this.ProfileName) + `,`,
		`CdnCeVhApiGw:` + repeatedStringForCdnCeVhApiGw + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCdnCeVhApiGw := "[]*ObjectRefType{"
	for _, f := range this.CdnCeVhApiGw {
		repeatedStringForCdnCeVhApiGw += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCdnCeVhApiGw += "}"
	s := strings.Join([]string{`&CreateSpecType{`,
		`LeasePool:` + strings.Replace(this.LeasePool.String(), "LeasePoolList", "LeasePoolList", 1) + `,`,
		`Gateways:` + strings.Replace(this.Gateways.String(), "Gateways", "Gateways", 1) + `,`,
		`AccessUrl:` + fmt.Sprintf("%v", this.AccessUrl) + `,`,
		`Cert:` + strings.Replace(this.Cert.String(), "Certificate", "Certificate", 1) + `,`,
		`ProfileName:` + fmt.Sprintf("%v", this.ProfileName) + `,`,
		`CdnCeVhApiGw:` + repeatedStringForCdnCeVhApiGw + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCdnCeVhApiGw := "[]*ObjectRefType{"
	for _, f := range this.CdnCeVhApiGw {
		repeatedStringForCdnCeVhApiGw += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCdnCeVhApiGw += "}"
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`LeasePool:` + strings.Replace(this.LeasePool.String(), "LeasePoolList", "LeasePoolList", 1) + `,`,
		`Gateways:` + strings.Replace(this.Gateways.String(), "Gateways", "Gateways", 1) + `,`,
		`AccessUrl:` + fmt.Sprintf("%v", this.AccessUrl) + `,`,
		`Cert:` + strings.Replace(this.Cert.String(), "Certificate", "Certificate", 1) + `,`,
		`ProfileName:` + fmt.Sprintf("%v", this.ProfileName) + `,`,
		`CdnCeVhApiGw:` + repeatedStringForCdnCeVhApiGw + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCdnCeVhApiGw := "[]*ObjectRefType{"
	for _, f := range this.CdnCeVhApiGw {
		repeatedStringForCdnCeVhApiGw += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCdnCeVhApiGw += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`LeasePool:` + strings.Replace(this.LeasePool.String(), "LeasePoolList", "LeasePoolList", 1) + `,`,
		`Gateways:` + strings.Replace(this.Gateways.String(), "Gateways", "Gateways", 1) + `,`,
		`AccessUrl:` + fmt.Sprintf("%v", this.AccessUrl) + `,`,
		`Cert:` + strings.Replace(this.Cert.String(), "Certificate", "Certificate", 1) + `,`,
		`ProfileName:` + fmt.Sprintf("%v", this.ProfileName) + `,`,
		`CdnCeVhApiGw:` + repeatedStringForCdnCeVhApiGw + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *LeasePoolList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeasePoolList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeasePoolList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UztnaLpool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UztnaLpool = append(m.UztnaLpool, &schema.ObjectRefType{})
			if err := m.UztnaLpool[len(m.UztnaLpool)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainPerimeterRE) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DomainPerimeterRE: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DomainPerimeterRE: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerimeterReSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PerimeterReSite = append(m.PerimeterReSite, &schema.ObjectRefType{})
			if err := m.PerimeterReSite[len(m.PerimeterReSite)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainSites) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DomainSites: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DomainSites: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UztnaGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UztnaGateway = append(m.UztnaGateway, &schema.ObjectRefType{})
			if err := m.UztnaGateway[len(m.UztnaGateway)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PerimeterREAdvertisement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PerimeterREAdvertisement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PerimeterREAdvertisement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllPerimeter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PerimterReChoice = &PerimeterREAdvertisement_AllPerimeter{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainReSites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DomainPerimeterRE{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PerimterReChoice = &PerimeterREAdvertisement_DomainReSites{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Gateways) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Gateways: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Gateways: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerimeterRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerimeterRe == nil {
				m.PerimeterRe = &PerimeterREAdvertisement{}
			}
			if err := m.PerimeterRe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigipCe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BigipCe == nil {
				m.BigipCe = &DomainSites{}
			}
			if err := m.BigipCe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Certificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Certificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Certificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certificate = append(m.Certificate, &schema.ObjectRefType{})
			if err := m.Certificate[len(m.Certificate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeasePool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeasePool == nil {
				m.LeasePool = &LeasePoolList{}
			}
			if err := m.LeasePool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateways == nil {
				m.Gateways = &Gateways{}
			}
			if err := m.Gateways.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cert == nil {
				m.Cert = &Certificate{}
			}
			if err := m.Cert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdnCeVhApiGw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CdnCeVhApiGw = append(m.CdnCeVhApiGw, &schema.ObjectRefType{})
			if err := m.CdnCeVhApiGw[len(m.CdnCeVhApiGw)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeasePool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeasePool == nil {
				m.LeasePool = &LeasePoolList{}
			}
			if err := m.LeasePool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateways == nil {
				m.Gateways = &Gateways{}
			}
			if err := m.Gateways.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cert == nil {
				m.Cert = &Certificate{}
			}
			if err := m.Cert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdnCeVhApiGw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CdnCeVhApiGw = append(m.CdnCeVhApiGw, &schema.ObjectRefType{})
			if err := m.CdnCeVhApiGw[len(m.CdnCeVhApiGw)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeasePool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeasePool == nil {
				m.LeasePool = &LeasePoolList{}
			}
			if err := m.LeasePool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateways == nil {
				m.Gateways = &Gateways{}
			}
			if err := m.Gateways.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cert == nil {
				m.Cert = &Certificate{}
			}
			if err := m.Cert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdnCeVhApiGw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CdnCeVhApiGw = append(m.CdnCeVhApiGw, &schema.ObjectRefType{})
			if err := m.CdnCeVhApiGw[len(m.CdnCeVhApiGw)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeasePool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeasePool == nil {
				m.LeasePool = &LeasePoolList{}
			}
			if err := m.LeasePool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateways == nil {
				m.Gateways = &Gateways{}
			}
			if err := m.Gateways.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cert == nil {
				m.Cert = &Certificate{}
			}
			if err := m.Cert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdnCeVhApiGw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CdnCeVhApiGw = append(m.CdnCeVhApiGw, &schema.ObjectRefType{})
			if err := m.CdnCeVhApiGw[len(m.CdnCeVhApiGw)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
