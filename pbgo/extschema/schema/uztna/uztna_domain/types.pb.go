// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/uztna/uztna_domain/types.proto

package uztna_domain

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// IPv4 Lease Pool
//
// x-displayName: "IPv4 Lease Pool"
// x-required
// Select or create new IPv4 Lease Pool
type IPv4Leasepool struct {
	// IPv4 Lease Pool
	//
	// x-displayName: "IPv4 Lease Pool"
	// x-required
	// Select or create new IPv4 Lease Pool
	Ipv4Leasepool []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=ipv4_leasepool,json=ipv4Leasepool,proto3" json:"ipv4_leasepool,omitempty"`
}

func (m *IPv4Leasepool) Reset()      { *m = IPv4Leasepool{} }
func (*IPv4Leasepool) ProtoMessage() {}
func (*IPv4Leasepool) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{0}
}
func (m *IPv4Leasepool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv4Leasepool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv4Leasepool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPv4Leasepool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv4Leasepool.Merge(m, src)
}
func (m *IPv4Leasepool) XXX_Size() int {
	return m.Size()
}
func (m *IPv4Leasepool) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv4Leasepool.DiscardUnknown(m)
}

var xxx_messageInfo_IPv4Leasepool proto.InternalMessageInfo

func (m *IPv4Leasepool) GetIpv4Leasepool() []*schema.ObjectRefType {
	if m != nil {
		return m.Ipv4Leasepool
	}
	return nil
}

// IPv6 Lease Pool
//
// x-displayName: "IPv6 Lease Pool"
// x-required
// Select or create new IPv6 Lease Pool
type IPv6Leasepool struct {
	// IPv6 Lease Pool
	//
	// x-displayName: "IPv6 Lease Pool"
	// x-required
	// Select or create new IPv6 Lease Pools
	Ipv6Leasepool []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=ipv6_leasepool,json=ipv6Leasepool,proto3" json:"ipv6_leasepool,omitempty"`
}

func (m *IPv6Leasepool) Reset()      { *m = IPv6Leasepool{} }
func (*IPv6Leasepool) ProtoMessage() {}
func (*IPv6Leasepool) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{1}
}
func (m *IPv6Leasepool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv6Leasepool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv6Leasepool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPv6Leasepool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv6Leasepool.Merge(m, src)
}
func (m *IPv6Leasepool) XXX_Size() int {
	return m.Size()
}
func (m *IPv6Leasepool) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv6Leasepool.DiscardUnknown(m)
}

var xxx_messageInfo_IPv6Leasepool proto.InternalMessageInfo

func (m *IPv6Leasepool) GetIpv6Leasepool() []*schema.ObjectRefType {
	if m != nil {
		return m.Ipv6Leasepool
	}
	return nil
}

// Dual Stack Lease Pool
//
// x-displayName: "Dual Stack Lease Pool"
//
// This is used to import or create new IPv4 and Ipv6 Lease Pools
type DualStackLeasePool struct {
	// IPv4 Lease Pool
	//
	// x-displayName: "IPv4 Lease Pool"
	// x-required
	// Select or create new IPv4 Lease Pools
	Ipv4Leasepool *IPv4Leasepool `protobuf:"bytes,3,opt,name=ipv4_leasepool,json=ipv4Leasepool,proto3" json:"ipv4_leasepool,omitempty"`
	// IPv6 Lease Pool
	//
	// x-displayName: "IPv6 Lease Pool"
	// x-required
	// Select or create new IPv6 Lease Pools
	Ipv6Leasepool *IPv6Leasepool `protobuf:"bytes,4,opt,name=ipv6_leasepool,json=ipv6Leasepool,proto3" json:"ipv6_leasepool,omitempty"`
}

func (m *DualStackLeasePool) Reset()      { *m = DualStackLeasePool{} }
func (*DualStackLeasePool) ProtoMessage() {}
func (*DualStackLeasePool) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{2}
}
func (m *DualStackLeasePool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DualStackLeasePool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DualStackLeasePool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DualStackLeasePool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DualStackLeasePool.Merge(m, src)
}
func (m *DualStackLeasePool) XXX_Size() int {
	return m.Size()
}
func (m *DualStackLeasePool) XXX_DiscardUnknown() {
	xxx_messageInfo_DualStackLeasePool.DiscardUnknown(m)
}

var xxx_messageInfo_DualStackLeasePool proto.InternalMessageInfo

func (m *DualStackLeasePool) GetIpv4Leasepool() *IPv4Leasepool {
	if m != nil {
		return m.Ipv4Leasepool
	}
	return nil
}

func (m *DualStackLeasePool) GetIpv6Leasepool() *IPv6Leasepool {
	if m != nil {
		return m.Ipv6Leasepool
	}
	return nil
}

// Lease Pools
//
// x-displayName: "Lease Pools"
//
// Lease Pool For UZTNA Domain View.
type LeasePoolList struct {
	// Lease Pool
	//
	// x-displayName: "Lease Pool"
	// x-required
	// Lease Pool for UZTNA Domain View
	//
	// Types that are valid to be assigned to IpaddressType:
	//	*LeasePoolList_Ipv4Leasepool
	//	*LeasePoolList_Ipv6Leasepool
	//	*LeasePoolList_Ipv4Ipv6Leasepool
	IpaddressType isLeasePoolList_IpaddressType `protobuf_oneof:"ipaddress_type"`
}

func (m *LeasePoolList) Reset()      { *m = LeasePoolList{} }
func (*LeasePoolList) ProtoMessage() {}
func (*LeasePoolList) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{3}
}
func (m *LeasePoolList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeasePoolList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeasePoolList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeasePoolList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeasePoolList.Merge(m, src)
}
func (m *LeasePoolList) XXX_Size() int {
	return m.Size()
}
func (m *LeasePoolList) XXX_DiscardUnknown() {
	xxx_messageInfo_LeasePoolList.DiscardUnknown(m)
}

var xxx_messageInfo_LeasePoolList proto.InternalMessageInfo

type isLeasePoolList_IpaddressType interface {
	isLeasePoolList_IpaddressType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LeasePoolList_Ipv4Leasepool struct {
	Ipv4Leasepool *IPv4Leasepool `protobuf:"bytes,2,opt,name=ipv4_leasepool,json=ipv4Leasepool,proto3,oneof" json:"ipv4_leasepool,omitempty"`
}
type LeasePoolList_Ipv6Leasepool struct {
	Ipv6Leasepool *IPv6Leasepool `protobuf:"bytes,3,opt,name=ipv6_leasepool,json=ipv6Leasepool,proto3,oneof" json:"ipv6_leasepool,omitempty"`
}
type LeasePoolList_Ipv4Ipv6Leasepool struct {
	Ipv4Ipv6Leasepool *DualStackLeasePool `protobuf:"bytes,4,opt,name=ipv4_ipv6_leasepool,json=ipv4Ipv6Leasepool,proto3,oneof" json:"ipv4_ipv6_leasepool,omitempty"`
}

func (*LeasePoolList_Ipv4Leasepool) isLeasePoolList_IpaddressType()     {}
func (*LeasePoolList_Ipv6Leasepool) isLeasePoolList_IpaddressType()     {}
func (*LeasePoolList_Ipv4Ipv6Leasepool) isLeasePoolList_IpaddressType() {}

func (m *LeasePoolList) GetIpaddressType() isLeasePoolList_IpaddressType {
	if m != nil {
		return m.IpaddressType
	}
	return nil
}

func (m *LeasePoolList) GetIpv4Leasepool() *IPv4Leasepool {
	if x, ok := m.GetIpaddressType().(*LeasePoolList_Ipv4Leasepool); ok {
		return x.Ipv4Leasepool
	}
	return nil
}

func (m *LeasePoolList) GetIpv6Leasepool() *IPv6Leasepool {
	if x, ok := m.GetIpaddressType().(*LeasePoolList_Ipv6Leasepool); ok {
		return x.Ipv6Leasepool
	}
	return nil
}

func (m *LeasePoolList) GetIpv4Ipv6Leasepool() *DualStackLeasePool {
	if x, ok := m.GetIpaddressType().(*LeasePoolList_Ipv4Ipv6Leasepool); ok {
		return x.Ipv4Ipv6Leasepool
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LeasePoolList) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LeasePoolList_Ipv4Leasepool)(nil),
		(*LeasePoolList_Ipv6Leasepool)(nil),
		(*LeasePoolList_Ipv4Ipv6Leasepool)(nil),
	}
}

// ZTNA Policy
//
// x-displayName: "ZTNA Policy"
type Policy struct {
	// ZTNA Policy
	//
	// x-displayName: "ZTNA Policy"
	// x-required
	// Select/Add ZTNA Policy to associate with this ZeroTrust Domain
	Policy []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=policy,proto3" json:"policy,omitempty"`
}

func (m *Policy) Reset()      { *m = Policy{} }
func (*Policy) ProtoMessage() {}
func (*Policy) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{4}
}
func (m *Policy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Policy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Policy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Policy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Policy.Merge(m, src)
}
func (m *Policy) XXX_Size() int {
	return m.Size()
}
func (m *Policy) XXX_DiscardUnknown() {
	xxx_messageInfo_Policy.DiscardUnknown(m)
}

var xxx_messageInfo_Policy proto.InternalMessageInfo

func (m *Policy) GetPolicy() []*schema.ObjectRefType {
	if m != nil {
		return m.Policy
	}
	return nil
}

// IPv4 App VIP Pool
//
// x-displayName: "IPv4 App VIP Pool"
// x-required
// Select or create new IPv4 App VIP Pool
type IPv4AppVipPool struct {
	// IPv4 App VIP Pool
	//
	// x-displayName: "IPv4 App VIP Pool"
	// x-required
	// Select or create new IPv4 App VIP Pool
	Ipv4AppVipPool []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=ipv4_app_vip_pool,json=ipv4AppVipPool,proto3" json:"ipv4_app_vip_pool,omitempty"`
}

func (m *IPv4AppVipPool) Reset()      { *m = IPv4AppVipPool{} }
func (*IPv4AppVipPool) ProtoMessage() {}
func (*IPv4AppVipPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{5}
}
func (m *IPv4AppVipPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv4AppVipPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv4AppVipPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPv4AppVipPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv4AppVipPool.Merge(m, src)
}
func (m *IPv4AppVipPool) XXX_Size() int {
	return m.Size()
}
func (m *IPv4AppVipPool) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv4AppVipPool.DiscardUnknown(m)
}

var xxx_messageInfo_IPv4AppVipPool proto.InternalMessageInfo

func (m *IPv4AppVipPool) GetIpv4AppVipPool() []*schema.ObjectRefType {
	if m != nil {
		return m.Ipv4AppVipPool
	}
	return nil
}

// IPv6 App VIP Pool
//
// x-displayName: "IPv6 App VIP Pool"
// x-required
// Select or create new IPv6 App VIP Pool
type IPv6AppVipPool struct {
	// IPv6 App VIP Pool
	//
	// x-displayName: "IPv6 App VIP Pool"
	// x-required
	// Select or create new IPv6 App VIP Pools
	Ipv6AppVipPool []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=ipv6_app_vip_pool,json=ipv6AppVipPool,proto3" json:"ipv6_app_vip_pool,omitempty"`
}

func (m *IPv6AppVipPool) Reset()      { *m = IPv6AppVipPool{} }
func (*IPv6AppVipPool) ProtoMessage() {}
func (*IPv6AppVipPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{6}
}
func (m *IPv6AppVipPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv6AppVipPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv6AppVipPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPv6AppVipPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv6AppVipPool.Merge(m, src)
}
func (m *IPv6AppVipPool) XXX_Size() int {
	return m.Size()
}
func (m *IPv6AppVipPool) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv6AppVipPool.DiscardUnknown(m)
}

var xxx_messageInfo_IPv6AppVipPool proto.InternalMessageInfo

func (m *IPv6AppVipPool) GetIpv6AppVipPool() []*schema.ObjectRefType {
	if m != nil {
		return m.Ipv6AppVipPool
	}
	return nil
}

// Dual Stack App VIP Pool
//
// x-displayName: "Dual Stack App VIP Pool"
//
// This is used to import or create new IPv4 and Ipv6 App VIP Pools
type DualStackAppVipPool struct {
	// IPv4 App VIP Pool
	//
	// x-displayName: "IPv4 App VIP Pool"
	// x-required
	// Select or create new IPv4 App VIP Pools
	Ipv4AppVipPool *IPv4AppVipPool `protobuf:"bytes,1,opt,name=ipv4_app_vip_pool,json=ipv4AppVipPool,proto3" json:"ipv4_app_vip_pool,omitempty"`
	// IPv6 App VIP Pool
	//
	// x-displayName: "IPv6 App VIP Pool"
	// x-required
	// Select or create new IPv6 App VIP Pools
	Ipv6AppVipPool *IPv6AppVipPool `protobuf:"bytes,2,opt,name=ipv6_app_vip_pool,json=ipv6AppVipPool,proto3" json:"ipv6_app_vip_pool,omitempty"`
}

func (m *DualStackAppVipPool) Reset()      { *m = DualStackAppVipPool{} }
func (*DualStackAppVipPool) ProtoMessage() {}
func (*DualStackAppVipPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{7}
}
func (m *DualStackAppVipPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DualStackAppVipPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DualStackAppVipPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DualStackAppVipPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DualStackAppVipPool.Merge(m, src)
}
func (m *DualStackAppVipPool) XXX_Size() int {
	return m.Size()
}
func (m *DualStackAppVipPool) XXX_DiscardUnknown() {
	xxx_messageInfo_DualStackAppVipPool.DiscardUnknown(m)
}

var xxx_messageInfo_DualStackAppVipPool proto.InternalMessageInfo

func (m *DualStackAppVipPool) GetIpv4AppVipPool() *IPv4AppVipPool {
	if m != nil {
		return m.Ipv4AppVipPool
	}
	return nil
}

func (m *DualStackAppVipPool) GetIpv6AppVipPool() *IPv6AppVipPool {
	if m != nil {
		return m.Ipv6AppVipPool
	}
	return nil
}

// Application VIP Pool
//
// x-displayName: "Advanced Configuration"
// This is used to select VIP Network and VIP Range from
// the already created VIP Pool.
type AppVIPPool struct {
	// App VIP Pool
	//
	// x-displayName: "App VIP Pool"
	// Selected VIP Pools
	//
	// Types that are valid to be assigned to IpaddressType:
	//	*AppVIPPool_Ipv4AppVipPool
	//	*AppVIPPool_Ipv6AppVipPool
	//	*AppVIPPool_Ipv4Ipv6AppVipPool
	IpaddressType isAppVIPPool_IpaddressType `protobuf_oneof:"ipaddress_type"`
}

func (m *AppVIPPool) Reset()      { *m = AppVIPPool{} }
func (*AppVIPPool) ProtoMessage() {}
func (*AppVIPPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{8}
}
func (m *AppVIPPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppVIPPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppVIPPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppVIPPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppVIPPool.Merge(m, src)
}
func (m *AppVIPPool) XXX_Size() int {
	return m.Size()
}
func (m *AppVIPPool) XXX_DiscardUnknown() {
	xxx_messageInfo_AppVIPPool.DiscardUnknown(m)
}

var xxx_messageInfo_AppVIPPool proto.InternalMessageInfo

type isAppVIPPool_IpaddressType interface {
	isAppVIPPool_IpaddressType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AppVIPPool_Ipv4AppVipPool struct {
	Ipv4AppVipPool *IPv4AppVipPool `protobuf:"bytes,2,opt,name=ipv4_app_vip_pool,json=ipv4AppVipPool,proto3,oneof" json:"ipv4_app_vip_pool,omitempty"`
}
type AppVIPPool_Ipv6AppVipPool struct {
	Ipv6AppVipPool *IPv6AppVipPool `protobuf:"bytes,3,opt,name=ipv6_app_vip_pool,json=ipv6AppVipPool,proto3,oneof" json:"ipv6_app_vip_pool,omitempty"`
}
type AppVIPPool_Ipv4Ipv6AppVipPool struct {
	Ipv4Ipv6AppVipPool *DualStackAppVipPool `protobuf:"bytes,4,opt,name=ipv4_ipv6_app_vip_pool,json=ipv4Ipv6AppVipPool,proto3,oneof" json:"ipv4_ipv6_app_vip_pool,omitempty"`
}

func (*AppVIPPool_Ipv4AppVipPool) isAppVIPPool_IpaddressType()     {}
func (*AppVIPPool_Ipv6AppVipPool) isAppVIPPool_IpaddressType()     {}
func (*AppVIPPool_Ipv4Ipv6AppVipPool) isAppVIPPool_IpaddressType() {}

func (m *AppVIPPool) GetIpaddressType() isAppVIPPool_IpaddressType {
	if m != nil {
		return m.IpaddressType
	}
	return nil
}

func (m *AppVIPPool) GetIpv4AppVipPool() *IPv4AppVipPool {
	if x, ok := m.GetIpaddressType().(*AppVIPPool_Ipv4AppVipPool); ok {
		return x.Ipv4AppVipPool
	}
	return nil
}

func (m *AppVIPPool) GetIpv6AppVipPool() *IPv6AppVipPool {
	if x, ok := m.GetIpaddressType().(*AppVIPPool_Ipv6AppVipPool); ok {
		return x.Ipv6AppVipPool
	}
	return nil
}

func (m *AppVIPPool) GetIpv4Ipv6AppVipPool() *DualStackAppVipPool {
	if x, ok := m.GetIpaddressType().(*AppVIPPool_Ipv4Ipv6AppVipPool); ok {
		return x.Ipv4Ipv6AppVipPool
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AppVIPPool) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AppVIPPool_Ipv4AppVipPool)(nil),
		(*AppVIPPool_Ipv6AppVipPool)(nil),
		(*AppVIPPool_Ipv4Ipv6AppVipPool)(nil),
	}
}

// Cloud Gateway
//
// x-displayName: "Cloud Gateway"
//
// Selected Cloud Gateways
type CloudGateways struct {
	// Cloud Gateway
	//
	// x-displayName: "Cloud Gateway"
	//
	// Selected Cloud Gateway
	CloudGateway []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=cloud_gateway,json=cloudGateway,proto3" json:"cloud_gateway,omitempty"`
}

func (m *CloudGateways) Reset()      { *m = CloudGateways{} }
func (*CloudGateways) ProtoMessage() {}
func (*CloudGateways) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{9}
}
func (m *CloudGateways) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudGateways) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudGateways.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudGateways) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudGateways.Merge(m, src)
}
func (m *CloudGateways) XXX_Size() int {
	return m.Size()
}
func (m *CloudGateways) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudGateways.DiscardUnknown(m)
}

var xxx_messageInfo_CloudGateways proto.InternalMessageInfo

func (m *CloudGateways) GetCloudGateway() []*schema.ObjectRefType {
	if m != nil {
		return m.CloudGateway
	}
	return nil
}

// Cloud Gateway Advertisement
//
// x-displayName: "Cloud Gateway Advertisement"
//
// Advertise on all Cloud Gateways or some selective
type CloudGatewayAdvertisement struct {
	// Cloud Gateway Advertisement
	//
	// x-displayName: "Cloud Gateways Advertisement"
	//
	// Select either All Cloud Gateway or some of them.
	//
	// Types that are valid to be assigned to CloudGatewayChoice:
	//	*CloudGatewayAdvertisement_AllCloud
	//	*CloudGatewayAdvertisement_ReSites
	CloudGatewayChoice isCloudGatewayAdvertisement_CloudGatewayChoice `protobuf_oneof:"cloud_gateway_choice"`
}

func (m *CloudGatewayAdvertisement) Reset()      { *m = CloudGatewayAdvertisement{} }
func (*CloudGatewayAdvertisement) ProtoMessage() {}
func (*CloudGatewayAdvertisement) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{10}
}
func (m *CloudGatewayAdvertisement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudGatewayAdvertisement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudGatewayAdvertisement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudGatewayAdvertisement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudGatewayAdvertisement.Merge(m, src)
}
func (m *CloudGatewayAdvertisement) XXX_Size() int {
	return m.Size()
}
func (m *CloudGatewayAdvertisement) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudGatewayAdvertisement.DiscardUnknown(m)
}

var xxx_messageInfo_CloudGatewayAdvertisement proto.InternalMessageInfo

type isCloudGatewayAdvertisement_CloudGatewayChoice interface {
	isCloudGatewayAdvertisement_CloudGatewayChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CloudGatewayAdvertisement_AllCloud struct {
	AllCloud *schema.Empty `protobuf:"bytes,5,opt,name=all_cloud,json=allCloud,proto3,oneof" json:"all_cloud,omitempty"`
}
type CloudGatewayAdvertisement_ReSites struct {
	ReSites *CloudGateways `protobuf:"bytes,6,opt,name=re_sites,json=reSites,proto3,oneof" json:"re_sites,omitempty"`
}

func (*CloudGatewayAdvertisement_AllCloud) isCloudGatewayAdvertisement_CloudGatewayChoice() {}
func (*CloudGatewayAdvertisement_ReSites) isCloudGatewayAdvertisement_CloudGatewayChoice()  {}

func (m *CloudGatewayAdvertisement) GetCloudGatewayChoice() isCloudGatewayAdvertisement_CloudGatewayChoice {
	if m != nil {
		return m.CloudGatewayChoice
	}
	return nil
}

func (m *CloudGatewayAdvertisement) GetAllCloud() *schema.Empty {
	if x, ok := m.GetCloudGatewayChoice().(*CloudGatewayAdvertisement_AllCloud); ok {
		return x.AllCloud
	}
	return nil
}

func (m *CloudGatewayAdvertisement) GetReSites() *CloudGateways {
	if x, ok := m.GetCloudGatewayChoice().(*CloudGatewayAdvertisement_ReSites); ok {
		return x.ReSites
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CloudGatewayAdvertisement) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CloudGatewayAdvertisement_AllCloud)(nil),
		(*CloudGatewayAdvertisement_ReSites)(nil),
	}
}

// Gateways
//
// x-displayName: "Gateways"
//
// Each UZTNA ZeroTrust Domain will have one or more gateways associated with it.
// The gateways represent the sites where the end user can connect to terminate
// the mTLS/DTLS tunnels. The gateways associated with a UZTNA ZeroTrust Domain would all be front
// ending the same set of applications and will enforce same set of policies for
// authentication and authorisation to grant access to these applications.
// This ensures same user experience no matter which gateway is reached for tunnel termination.
// Each Gateway will have a lease pool defined to allocate IP address to
// client for the terminated tunne
type Gateways struct {
	// PerimeterREAdvertisement
	//
	// x-displayName: "Cloud Gateways"
	//
	// List of all Cloud Gateways and Big-IP Edge Gateways
	PerimeterRe *CloudGatewayAdvertisement `protobuf:"bytes,4,opt,name=perimeter_re,json=perimeterRe,proto3" json:"perimeter_re,omitempty"`
	// BigIP Edge Gateways
	//
	// x-displayName: "BIG-IP Edge Gateways"
	//
	// This is used to show all the available Big-IP Edge Gateways.
	// From the available Big-IP Edge Gateway List select Big-IP Edge Gateway.
	BigipSite []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=bigip_site,json=bigipSite,proto3" json:"bigip_site,omitempty"`
}

func (m *Gateways) Reset()      { *m = Gateways{} }
func (*Gateways) ProtoMessage() {}
func (*Gateways) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{11}
}
func (m *Gateways) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Gateways) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Gateways.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Gateways) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Gateways.Merge(m, src)
}
func (m *Gateways) XXX_Size() int {
	return m.Size()
}
func (m *Gateways) XXX_DiscardUnknown() {
	xxx_messageInfo_Gateways.DiscardUnknown(m)
}

var xxx_messageInfo_Gateways proto.InternalMessageInfo

func (m *Gateways) GetPerimeterRe() *CloudGatewayAdvertisement {
	if m != nil {
		return m.PerimeterRe
	}
	return nil
}

func (m *Gateways) GetBigipSite() []*schema.ObjectRefType {
	if m != nil {
		return m.BigipSite
	}
	return nil
}

// TLS Certificate
//
// x-displayName: "Certificate"
// This is used to import or create new certificate for tls communication
type Certificate struct {
	// TLS Certificates
	//
	// x-displayName: "TLS Certificates"
	// Select/Add one or more TLS Certificate objects to associate with this ZeroTrust Domain
	Certificate []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=certificate,proto3" json:"certificate,omitempty"`
}

func (m *Certificate) Reset()      { *m = Certificate{} }
func (*Certificate) ProtoMessage() {}
func (*Certificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{12}
}
func (m *Certificate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Certificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Certificate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Certificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Certificate.Merge(m, src)
}
func (m *Certificate) XXX_Size() int {
	return m.Size()
}
func (m *Certificate) XXX_DiscardUnknown() {
	xxx_messageInfo_Certificate.DiscardUnknown(m)
}

var xxx_messageInfo_Certificate proto.InternalMessageInfo

func (m *Certificate) GetCertificate() []*schema.ObjectRefType {
	if m != nil {
		return m.Certificate
	}
	return nil
}

// GlobalSpecType
//
// x-displayName: "ZeroTrust Domain Info Specification"
// Shape of the view internal specification
type GlobalSpecType struct {
	// Lease Pools
	//
	// x-displayName: "Lease Pools"
	// x-required
	// The Lease Pool List assigned to the Zero Trust Domain.
	LeasePool *LeasePoolList `protobuf:"bytes,1,opt,name=lease_pool,json=leasePool,proto3" json:"lease_pool,omitempty"`
	// Gateways
	//
	// x-displayName: "Gateways"
	// x-required
	// List of all Cloud Gateways and Big-IP Edge Gateways
	Gateways *Gateways `protobuf:"bytes,2,opt,name=gateways,proto3" json:"gateways,omitempty"`
	// Access FQDN
	//
	// x-displayName: "Access FQDN"
	// x-required
	// FQDN to access the gateways
	AccessFqdn string `protobuf:"bytes,11,opt,name=access_fqdn,json=accessFqdn,proto3" json:"access_fqdn,omitempty"`
	// Certificate
	//
	// x-displayName: "Certificate"
	// x-required
	// A ZTNA ZeroTrust Domain being a TLS Gateway requires a Valid
	// Certificate associated with the Access FQDN.
	// The approach to attach a certificate and key to a
	// Domain in XC is an established pattern and we would reuse the same.
	Cert *Certificate `protobuf:"bytes,4,opt,name=cert,proto3" json:"cert,omitempty"`
	// CDN CE gatway virtual host reference
	//
	// x-displayName: "CDN CE gateway virtual host reference"
	// Internal reference to cdn ce api gateway VH
	CdnCeVhApiGw []*schema.ObjectRefType `protobuf:"bytes,6,rep,name=cdn_ce_vh_api_gw,json=cdnCeVhApiGw,proto3" json:"cdn_ce_vh_api_gw,omitempty"`
	// Selected VIP Pools
	//
	// x-displayName: "Application VIP Pools"
	// Appliacation VIP Pools
	AppVipPool *AppVIPPool `protobuf:"bytes,7,opt,name=app_vip_pool,json=appVipPool,proto3" json:"app_vip_pool,omitempty"`
	// ZTNA Policy
	//
	// x-displayName: "ZTNA Policy"
	// x-required
	// This is used to import or create new ZTNA Policy
	Policy *Policy `protobuf:"bytes,8,opt,name=policy,proto3" json:"policy,omitempty"`
	// DNS VIP
	//
	// x-displayName: "VIP address for internal DNS proxy"
	// x-required
	//  VIP address for internal DNS proxy
	VipDnsProxy *schema.IpAddressType `protobuf:"bytes,9,opt,name=vip_dns_proxy,json=vipDnsProxy,proto3" json:"vip_dns_proxy,omitempty"`
	// APPLICATION VIP PREFIX
	//
	// x-displayName: "Application VIP Prefix"
	// x-required
	// Application VIP prefix holds array of subnet, under which Global ip allocator allocates ip on this range
	AppVipSubnet []string `protobuf:"bytes,12,rep,name=app_vip_subnet,json=appVipSubnet,proto3" json:"app_vip_subnet,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{13}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobalSpecType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetLeasePool() *LeasePoolList {
	if m != nil {
		return m.LeasePool
	}
	return nil
}

func (m *GlobalSpecType) GetGateways() *Gateways {
	if m != nil {
		return m.Gateways
	}
	return nil
}

func (m *GlobalSpecType) GetAccessFqdn() string {
	if m != nil {
		return m.AccessFqdn
	}
	return ""
}

func (m *GlobalSpecType) GetCert() *Certificate {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *GlobalSpecType) GetCdnCeVhApiGw() []*schema.ObjectRefType {
	if m != nil {
		return m.CdnCeVhApiGw
	}
	return nil
}

func (m *GlobalSpecType) GetAppVipPool() *AppVIPPool {
	if m != nil {
		return m.AppVipPool
	}
	return nil
}

func (m *GlobalSpecType) GetPolicy() *Policy {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *GlobalSpecType) GetVipDnsProxy() *schema.IpAddressType {
	if m != nil {
		return m.VipDnsProxy
	}
	return nil
}

func (m *GlobalSpecType) GetAppVipSubnet() []string {
	if m != nil {
		return m.AppVipSubnet
	}
	return nil
}

// CreateSpecType
//
// x-displayName: "Create Specification"
// Shape of the UZTNA ZeroTrust Domain
type CreateSpecType struct {
	LeasePool    *LeasePoolList          `protobuf:"bytes,1,opt,name=lease_pool,json=leasePool,proto3" json:"lease_pool,omitempty"`
	Gateways     *Gateways               `protobuf:"bytes,2,opt,name=gateways,proto3" json:"gateways,omitempty"`
	AccessFqdn   string                  `protobuf:"bytes,11,opt,name=access_fqdn,json=accessFqdn,proto3" json:"access_fqdn,omitempty"`
	Cert         *Certificate            `protobuf:"bytes,4,opt,name=cert,proto3" json:"cert,omitempty"`
	CdnCeVhApiGw []*schema.ObjectRefType `protobuf:"bytes,6,rep,name=cdn_ce_vh_api_gw,json=cdnCeVhApiGw,proto3" json:"cdn_ce_vh_api_gw,omitempty"`
	AppVipPool   *AppVIPPool             `protobuf:"bytes,7,opt,name=app_vip_pool,json=appVipPool,proto3" json:"app_vip_pool,omitempty"`
	Policy       *Policy                 `protobuf:"bytes,8,opt,name=policy,proto3" json:"policy,omitempty"`
	VipDnsProxy  *schema.IpAddressType   `protobuf:"bytes,9,opt,name=vip_dns_proxy,json=vipDnsProxy,proto3" json:"vip_dns_proxy,omitempty"`
	AppVipSubnet []string                `protobuf:"bytes,12,rep,name=app_vip_subnet,json=appVipSubnet,proto3" json:"app_vip_subnet,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{14}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateSpecType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetLeasePool() *LeasePoolList {
	if m != nil {
		return m.LeasePool
	}
	return nil
}

func (m *CreateSpecType) GetGateways() *Gateways {
	if m != nil {
		return m.Gateways
	}
	return nil
}

func (m *CreateSpecType) GetAccessFqdn() string {
	if m != nil {
		return m.AccessFqdn
	}
	return ""
}

func (m *CreateSpecType) GetCert() *Certificate {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *CreateSpecType) GetCdnCeVhApiGw() []*schema.ObjectRefType {
	if m != nil {
		return m.CdnCeVhApiGw
	}
	return nil
}

func (m *CreateSpecType) GetAppVipPool() *AppVIPPool {
	if m != nil {
		return m.AppVipPool
	}
	return nil
}

func (m *CreateSpecType) GetPolicy() *Policy {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *CreateSpecType) GetVipDnsProxy() *schema.IpAddressType {
	if m != nil {
		return m.VipDnsProxy
	}
	return nil
}

func (m *CreateSpecType) GetAppVipSubnet() []string {
	if m != nil {
		return m.AppVipSubnet
	}
	return nil
}

// ReplaceSpecType
//
// x-displayName: "Replace Specification"
// Shape of the UZTNA ZeroTrust Domain
type ReplaceSpecType struct {
	LeasePool    *LeasePoolList          `protobuf:"bytes,1,opt,name=lease_pool,json=leasePool,proto3" json:"lease_pool,omitempty"`
	Gateways     *Gateways               `protobuf:"bytes,2,opt,name=gateways,proto3" json:"gateways,omitempty"`
	AccessFqdn   string                  `protobuf:"bytes,11,opt,name=access_fqdn,json=accessFqdn,proto3" json:"access_fqdn,omitempty"`
	Cert         *Certificate            `protobuf:"bytes,4,opt,name=cert,proto3" json:"cert,omitempty"`
	CdnCeVhApiGw []*schema.ObjectRefType `protobuf:"bytes,6,rep,name=cdn_ce_vh_api_gw,json=cdnCeVhApiGw,proto3" json:"cdn_ce_vh_api_gw,omitempty"`
	AppVipPool   *AppVIPPool             `protobuf:"bytes,7,opt,name=app_vip_pool,json=appVipPool,proto3" json:"app_vip_pool,omitempty"`
	Policy       *Policy                 `protobuf:"bytes,8,opt,name=policy,proto3" json:"policy,omitempty"`
	VipDnsProxy  *schema.IpAddressType   `protobuf:"bytes,9,opt,name=vip_dns_proxy,json=vipDnsProxy,proto3" json:"vip_dns_proxy,omitempty"`
	AppVipSubnet []string                `protobuf:"bytes,12,rep,name=app_vip_subnet,json=appVipSubnet,proto3" json:"app_vip_subnet,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{15}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplaceSpecType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

func (m *ReplaceSpecType) GetLeasePool() *LeasePoolList {
	if m != nil {
		return m.LeasePool
	}
	return nil
}

func (m *ReplaceSpecType) GetGateways() *Gateways {
	if m != nil {
		return m.Gateways
	}
	return nil
}

func (m *ReplaceSpecType) GetAccessFqdn() string {
	if m != nil {
		return m.AccessFqdn
	}
	return ""
}

func (m *ReplaceSpecType) GetCert() *Certificate {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *ReplaceSpecType) GetCdnCeVhApiGw() []*schema.ObjectRefType {
	if m != nil {
		return m.CdnCeVhApiGw
	}
	return nil
}

func (m *ReplaceSpecType) GetAppVipPool() *AppVIPPool {
	if m != nil {
		return m.AppVipPool
	}
	return nil
}

func (m *ReplaceSpecType) GetPolicy() *Policy {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *ReplaceSpecType) GetVipDnsProxy() *schema.IpAddressType {
	if m != nil {
		return m.VipDnsProxy
	}
	return nil
}

func (m *ReplaceSpecType) GetAppVipSubnet() []string {
	if m != nil {
		return m.AppVipSubnet
	}
	return nil
}

// GetSpecType
//
// x-displayName: "Get Specification"
// Shape of the UZTNA ZeroTrust Domain
type GetSpecType struct {
	LeasePool    *LeasePoolList          `protobuf:"bytes,1,opt,name=lease_pool,json=leasePool,proto3" json:"lease_pool,omitempty"`
	Gateways     *Gateways               `protobuf:"bytes,2,opt,name=gateways,proto3" json:"gateways,omitempty"`
	AccessFqdn   string                  `protobuf:"bytes,11,opt,name=access_fqdn,json=accessFqdn,proto3" json:"access_fqdn,omitempty"`
	Cert         *Certificate            `protobuf:"bytes,4,opt,name=cert,proto3" json:"cert,omitempty"`
	CdnCeVhApiGw []*schema.ObjectRefType `protobuf:"bytes,6,rep,name=cdn_ce_vh_api_gw,json=cdnCeVhApiGw,proto3" json:"cdn_ce_vh_api_gw,omitempty"`
	AppVipPool   *AppVIPPool             `protobuf:"bytes,7,opt,name=app_vip_pool,json=appVipPool,proto3" json:"app_vip_pool,omitempty"`
	Policy       *Policy                 `protobuf:"bytes,8,opt,name=policy,proto3" json:"policy,omitempty"`
	VipDnsProxy  *schema.IpAddressType   `protobuf:"bytes,9,opt,name=vip_dns_proxy,json=vipDnsProxy,proto3" json:"vip_dns_proxy,omitempty"`
	AppVipSubnet []string                `protobuf:"bytes,12,rep,name=app_vip_subnet,json=appVipSubnet,proto3" json:"app_vip_subnet,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4628a4276549e24f, []int{16}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSpecType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetLeasePool() *LeasePoolList {
	if m != nil {
		return m.LeasePool
	}
	return nil
}

func (m *GetSpecType) GetGateways() *Gateways {
	if m != nil {
		return m.Gateways
	}
	return nil
}

func (m *GetSpecType) GetAccessFqdn() string {
	if m != nil {
		return m.AccessFqdn
	}
	return ""
}

func (m *GetSpecType) GetCert() *Certificate {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *GetSpecType) GetCdnCeVhApiGw() []*schema.ObjectRefType {
	if m != nil {
		return m.CdnCeVhApiGw
	}
	return nil
}

func (m *GetSpecType) GetAppVipPool() *AppVIPPool {
	if m != nil {
		return m.AppVipPool
	}
	return nil
}

func (m *GetSpecType) GetPolicy() *Policy {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *GetSpecType) GetVipDnsProxy() *schema.IpAddressType {
	if m != nil {
		return m.VipDnsProxy
	}
	return nil
}

func (m *GetSpecType) GetAppVipSubnet() []string {
	if m != nil {
		return m.AppVipSubnet
	}
	return nil
}

func init() {
	proto.RegisterType((*IPv4Leasepool)(nil), "ves.io.schema.uztna.uztna_domain.IPv4Leasepool")
	proto.RegisterType((*IPv6Leasepool)(nil), "ves.io.schema.uztna.uztna_domain.IPv6Leasepool")
	proto.RegisterType((*DualStackLeasePool)(nil), "ves.io.schema.uztna.uztna_domain.DualStackLeasePool")
	proto.RegisterType((*LeasePoolList)(nil), "ves.io.schema.uztna.uztna_domain.LeasePoolList")
	proto.RegisterType((*Policy)(nil), "ves.io.schema.uztna.uztna_domain.Policy")
	proto.RegisterType((*IPv4AppVipPool)(nil), "ves.io.schema.uztna.uztna_domain.IPv4AppVipPool")
	proto.RegisterType((*IPv6AppVipPool)(nil), "ves.io.schema.uztna.uztna_domain.IPv6AppVipPool")
	proto.RegisterType((*DualStackAppVipPool)(nil), "ves.io.schema.uztna.uztna_domain.DualStackAppVipPool")
	proto.RegisterType((*AppVIPPool)(nil), "ves.io.schema.uztna.uztna_domain.AppVIPPool")
	proto.RegisterType((*CloudGateways)(nil), "ves.io.schema.uztna.uztna_domain.CloudGateways")
	proto.RegisterType((*CloudGatewayAdvertisement)(nil), "ves.io.schema.uztna.uztna_domain.CloudGatewayAdvertisement")
	proto.RegisterType((*Gateways)(nil), "ves.io.schema.uztna.uztna_domain.Gateways")
	proto.RegisterType((*Certificate)(nil), "ves.io.schema.uztna.uztna_domain.Certificate")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.uztna.uztna_domain.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.uztna.uztna_domain.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.uztna.uztna_domain.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.uztna.uztna_domain.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/uztna/uztna_domain/types.proto", fileDescriptor_4628a4276549e24f)
}

var fileDescriptor_4628a4276549e24f = []byte{
	// 1438 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0xdf, 0x6f, 0xd3, 0xe6,
	0x1a, 0xce, 0xe7, 0x38, 0x69, 0xfa, 0xe6, 0x07, 0xc1, 0x70, 0x20, 0x14, 0x94, 0x46, 0x81, 0x8b,
	0x0a, 0x95, 0xe4, 0x50, 0x7a, 0x72, 0x8e, 0x38, 0xd2, 0x44, 0xd2, 0x8e, 0xfe, 0x50, 0xc7, 0x2a,
	0x97, 0x55, 0x88, 0x6d, 0x78, 0x8e, 0xfd, 0x35, 0xf1, 0x70, 0x6c, 0x63, 0x3b, 0x29, 0x45, 0x8a,
	0xc4, 0x1f, 0xb0, 0x8b, 0x89, 0xbf, 0x02, 0xe5, 0x2f, 0x98, 0x16, 0x2e, 0xaa, 0x49, 0x48, 0x13,
	0x37, 0xeb, 0x65, 0x2f, 0x76, 0x01, 0xe1, 0x86, 0xdd, 0x4c, 0x6c, 0x57, 0xbb, 0x9c, 0xfc, 0xd9,
	0x71, 0x6c, 0x27, 0xa8, 0x69, 0xc7, 0xd0, 0x2e, 0x7a, 0x53, 0xc5, 0xdf, 0x8f, 0xe7, 0xf9, 0x9e,
	0xf7, 0x7d, 0x9f, 0xd7, 0x5f, 0x0d, 0xb3, 0x2d, 0x6c, 0x14, 0x24, 0xb5, 0x68, 0x08, 0x75, 0xdc,
	0xe0, 0x8b, 0xcd, 0x47, 0xa6, 0xe2, 0xfc, 0xe5, 0x44, 0xb5, 0xc1, 0x4b, 0x4a, 0xd1, 0xdc, 0xd1,
	0xb0, 0x51, 0xd0, 0x74, 0xd5, 0x54, 0x99, 0x9c, 0xbd, 0xba, 0x60, 0xaf, 0x2e, 0x90, 0x75, 0x05,
	0xef, 0xea, 0xa9, 0xb3, 0x7e, 0x3c, 0x05, 0x9b, 0xf6, 0xd6, 0xa9, 0xf3, 0xfe, 0x09, 0x55, 0x33,
	0x25, 0x55, 0x71, 0x70, 0xa7, 0xce, 0xf9, 0x27, 0x3d, 0x94, 0x53, 0x17, 0xfc, 0x53, 0x2d, 0x5e,
	0x96, 0x44, 0xde, 0xc4, 0xce, 0x6c, 0x2e, 0x30, 0x2b, 0xe1, 0x6d, 0xce, 0x0f, 0x3d, 0x3d, 0xbc,
	0xc2, 0xf0, 0x12, 0xe4, 0x1f, 0x42, 0x72, 0x65, 0xbd, 0x35, 0xbf, 0x86, 0x79, 0x03, 0x6b, 0xaa,
	0x2a, 0x33, 0x3c, 0xa4, 0x24, 0xad, 0x35, 0xcf, 0xc9, 0xfd, 0x91, 0x0c, 0x95, 0x0b, 0xcf, 0xc4,
	0xe7, 0x2e, 0x14, 0xfc, 0xea, 0x3f, 0xad, 0x7e, 0x8d, 0x05, 0x93, 0xc5, 0x5b, 0xb7, 0x77, 0x34,
	0x5c, 0xb9, 0xd0, 0x69, 0x9f, 0xb0, 0x23, 0xe1, 0xee, 0xfb, 0xfe, 0x97, 0xdd, 0x70, 0xe4, 0x09,
	0xa2, 0xd2, 0x88, 0x4d, 0x5a, 0x88, 0x2e, 0xc5, 0x2a, 0x1d, 0x43, 0x69, 0xca, 0x61, 0x2e, 0x05,
	0x99, 0x4b, 0xef, 0x9d, 0xb9, 0x14, 0x64, 0xde, 0x43, 0xc0, 0x2c, 0x36, 0x79, 0x79, 0xc3, 0xe4,
	0x85, 0xfb, 0x64, 0x72, 0xdd, 0xe2, 0xdf, 0x1c, 0x52, 0x1e, 0xce, 0xa1, 0x99, 0xf8, 0x5c, 0xb1,
	0x70, 0x50, 0xde, 0x0b, 0xbe, 0x10, 0x06, 0xe4, 0x3a, 0xb8, 0x5e, 0x5d, 0xf4, 0x21, 0x70, 0x4b,
	0x7e, 0xdc, 0xa0, 0x98, 0x55, 0x3a, 0x46, 0xa5, 0xc3, 0xf9, 0x37, 0x14, 0x24, 0x5d, 0x25, 0x6b,
	0x92, 0x61, 0x32, 0x77, 0x46, 0xe4, 0xf1, 0x28, 0x6a, 0x96, 0x43, 0x41, 0x3d, 0xf7, 0x86, 0xf4,
	0x84, 0x8f, 0xa4, 0xa7, 0x42, 0xbf, 0xe9, 0x22, 0xe4, 0xe0, 0x7b, 0xea, 0x40, 0x86, 0x53, 0xe4,
	0xe4, 0x23, 0x83, 0x36, 0x7f, 0x30, 0xc9, 0x70, 0x6a, 0x5d, 0xa6, 0x93, 0x16, 0xf0, 0x8a, 0x97,
	0xad, 0x72, 0xd1, 0x52, 0xc3, 0x8b, 0xa2, 0x8e, 0x0d, 0x83, 0xb3, 0x9c, 0xc1, 0x9c, 0xdc, 0xed,
	0x22, 0x6a, 0xaf, 0x8b, 0x22, 0xbd, 0x2e, 0x8a, 0xcc, 0xcd, 0x5e, 0x9b, 0x9d, 0x77, 0x43, 0x1d,
	0x49, 0x47, 0xf3, 0x55, 0x88, 0xae, 0xab, 0xb2, 0x24, 0xec, 0x30, 0x77, 0x20, 0xaa, 0x91, 0x5f,
	0x19, 0x34, 0x46, 0xa1, 0xe6, 0x3b, 0xed, 0x7f, 0xd9, 0xe7, 0xb4, 0x37, 0x71, 0x26, 0x6e, 0x68,
	0x32, 0x6f, 0x62, 0x4f, 0xb9, 0x3a, 0x78, 0xf9, 0x47, 0x90, 0xb2, 0x92, 0x50, 0xd6, 0xb4, 0x4d,
	0x49, 0x23, 0xc5, 0x59, 0x07, 0x72, 0x76, 0x8e, 0xd7, 0x34, 0xae, 0x25, 0x69, 0x1c, 0x09, 0xc9,
	0x38, 0xb4, 0xd3, 0x9d, 0x36, 0x63, 0xd3, 0x7a, 0xb7, 0x7a, 0x38, 0x49, 0x99, 0x0c, 0x98, 0x1c,
	0xee, 0xd2, 0x10, 0x77, 0xe9, 0x6f, 0xe2, 0xf6, 0x30, 0xe5, 0x7f, 0x42, 0x70, 0xca, 0x4d, 0x9f,
	0xe7, 0x04, 0x9f, 0x8f, 0x56, 0x6f, 0x15, 0xc4, 0xbf, 0xc7, 0xab, 0xe7, 0x01, 0x58, 0x50, 0xb0,
	0x03, 0x1e, 0x90, 0x47, 0x1d, 0x02, 0xbc, 0x14, 0x00, 0xf7, 0x2a, 0x7a, 0x4b, 0x01, 0x58, 0x8f,
	0x2b, 0xeb, 0x84, 0xeb, 0xcb, 0x51, 0x42, 0xa8, 0xa3, 0x09, 0x59, 0x0e, 0x0d, 0x49, 0x11, 0x46,
	0x49, 0x09, 0x1f, 0x4d, 0x8a, 0x6b, 0x9a, 0x80, 0x24, 0xe6, 0x01, 0x9c, 0x19, 0xf8, 0xd3, 0xc7,
	0x64, 0x5b, 0xf4, 0x3f, 0x87, 0xb0, 0xe8, 0x08, 0x3a, 0xa6, 0xef, 0x51, 0xcf, 0xdc, 0xf4, 0x90,
	0x49, 0x93, 0xef, 0x36, 0x28, 0x07, 0xc9, 0x05, 0x59, 0x6d, 0x8a, 0x4b, 0xbc, 0x89, 0xb7, 0xf9,
	0x1d, 0x83, 0xb9, 0x05, 0x49, 0xc1, 0x1a, 0xe0, 0x6a, 0xf6, 0xc8, 0x58, 0xb5, 0x1b, 0xef, 0xb4,
	0x69, 0x43, 0x32, 0xf1, 0xe3, 0x67, 0x08, 0xb1, 0x09, 0xc1, 0x03, 0x98, 0xff, 0x8e, 0x82, 0x73,
	0x5e, 0x86, 0xb2, 0xd8, 0xc2, 0xba, 0x29, 0x19, 0xb8, 0x81, 0x15, 0x93, 0xb9, 0x06, 0x93, 0xbc,
	0x2c, 0x73, 0x64, 0x47, 0x26, 0x42, 0x22, 0x72, 0x3a, 0xc0, 0xf4, 0x71, 0x43, 0x33, 0x77, 0x96,
	0x43, 0x6c, 0x8c, 0x97, 0x65, 0x02, 0xc4, 0xac, 0x41, 0x4c, 0xc7, 0x9c, 0xc5, 0x67, 0x64, 0xa2,
	0xe3, 0x76, 0x53, 0x9f, 0xca, 0xe5, 0x10, 0x3b, 0xa1, 0xe3, 0x0d, 0x0b, 0xe1, 0xfa, 0x57, 0x2f,
	0xba, 0xe8, 0x0b, 0xb8, 0x0b, 0x29, 0xb2, 0x22, 0xd7, 0x5f, 0x72, 0x79, 0x19, 0x6e, 0xc2, 0xb4,
	0xe7, 0x78, 0x73, 0x4c, 0x59, 0x96, 0x73, 0xfe, 0x45, 0x70, 0x71, 0x70, 0x94, 0xb9, 0xb3, 0x8b,
	0x84, 0x69, 0x53, 0xc2, 0xdb, 0x3e, 0xb2, 0xca, 0x25, 0x38, 0xed, 0x0b, 0x29, 0x27, 0xd4, 0x55,
	0x49, 0xc0, 0x4c, 0x62, 0xb7, 0x8b, 0x22, 0x7b, 0x5d, 0x44, 0xff, 0xd1, 0x45, 0x94, 0xf7, 0x0d,
	0xb5, 0x4a, 0xc7, 0xe8, 0x74, 0x24, 0xff, 0x1c, 0x41, 0xcc, 0xcd, 0xcb, 0x3d, 0x48, 0x68, 0x58,
	0x97, 0x1a, 0xd8, 0xc4, 0x3a, 0xa7, 0x63, 0xa7, 0x7c, 0xfe, 0x7f, 0x38, 0xe1, 0xbe, 0xe0, 0xb3,
	0x71, 0x17, 0x90, 0xc5, 0xcc, 0x27, 0x00, 0x55, 0xa9, 0x26, 0x69, 0x44, 0x4c, 0x26, 0x3c, 0x46,
	0xd2, 0xd3, 0x9d, 0x76, 0xd2, 0x66, 0x72, 0x74, 0xb1, 0x93, 0x04, 0xc1, 0x0a, 0xab, 0xef, 0x7d,
	0x5b, 0x83, 0xf8, 0x82, 0x45, 0xbb, 0x25, 0x09, 0xbc, 0x89, 0x99, 0x3b, 0x10, 0x17, 0x06, 0x8f,
	0x63, 0xdd, 0x5b, 0x32, 0x9d, 0xb6, 0x77, 0x8f, 0xa7, 0x29, 0x7a, 0x87, 0xf3, 0x3f, 0x47, 0x21,
	0xb5, 0x24, 0xab, 0x55, 0x5e, 0xde, 0xd0, 0xb0, 0x60, 0xed, 0x64, 0x6e, 0x01, 0x90, 0xb7, 0xa2,
	0xb7, 0x0b, 0x8e, 0x51, 0x2d, 0xbe, 0xeb, 0x01, 0x3b, 0x29, 0xbb, 0xf7, 0x9e, 0x9b, 0x10, 0x73,
	0xd4, 0x1a, 0x4e, 0x2b, 0xba, 0x7c, 0x30, 0x5a, 0x3f, 0x89, 0xac, 0xbb, 0x97, 0x29, 0x42, 0x9c,
	0x17, 0x04, 0xcb, 0xa1, 0x5b, 0x0f, 0x44, 0x25, 0x13, 0xcf, 0xa1, 0x99, 0xc9, 0x4a, 0xca, 0x12,
	0x36, 0xa9, 0x4f, 0xa4, 0x51, 0xe6, 0x31, 0x55, 0x47, 0x2c, 0xd8, 0x4b, 0x6e, 0x3e, 0x10, 0x15,
	0xa6, 0x0c, 0xb4, 0x25, 0xd5, 0xc9, 0xfb, 0x95, 0x31, 0xf2, 0x3e, 0x08, 0x0c, 0x4b, 0xb6, 0x32,
	0x5b, 0x90, 0x16, 0x44, 0x85, 0x13, 0x30, 0xd7, 0xaa, 0x73, 0xbc, 0x26, 0x71, 0xb5, 0xed, 0x4c,
	0x74, 0x8c, 0xe8, 0xe7, 0x3a, 0xed, 0x44, 0x4b, 0xd2, 0xcd, 0x26, 0x2f, 0x73, 0x75, 0xd5, 0x30,
	0xf7, 0xdb, 0xc8, 0x6a, 0x3f, 0x9e, 0x2c, 0x24, 0x04, 0x51, 0x59, 0xc0, 0x9b, 0xf5, 0xb2, 0x26,
	0x2d, 0x6d, 0x33, 0xb7, 0x21, 0xe1, 0xeb, 0x74, 0x13, 0xe4, 0xc8, 0xb3, 0x07, 0x1f, 0x79, 0xd0,
	0xfb, 0x2b, 0xf4, 0x6e, 0x17, 0x59, 0x01, 0x18, 0x74, 0xd2, 0x1b, 0xee, 0x05, 0x22, 0x46, 0xf0,
	0x66, 0x0e, 0xc6, 0xb3, 0xaf, 0x1e, 0xfd, 0x8b, 0x02, 0xb3, 0x02, 0x49, 0xeb, 0x4c, 0xa2, 0x62,
	0x70, 0x9a, 0xae, 0x3e, 0xdc, 0xc9, 0x4c, 0x12, 0xa0, 0xa0, 0xf8, 0x15, 0xad, 0x6c, 0x37, 0x4f,
	0x22, 0x7e, 0xc2, 0x51, 0xcb, 0xc6, 0x5b, 0x92, 0xb6, 0xa8, 0x18, 0xeb, 0xd6, 0x4e, 0xa6, 0x01,
	0xa9, 0xbe, 0x44, 0xa3, 0x59, 0x55, 0xb0, 0x99, 0x49, 0xe4, 0xc2, 0x33, 0x93, 0x95, 0x25, 0x2b,
	0x28, 0xf0, 0x04, 0x4d, 0xe4, 0x23, 0x7a, 0xf8, 0xa9, 0x1d, 0xa3, 0xfe, 0xe3, 0xbe, 0x27, 0x64,
	0xd0, 0xff, 0x15, 0x73, 0xc7, 0x32, 0xa8, 0xf7, 0xf2, 0x79, 0x38, 0xfa, 0xe4, 0x19, 0xa2, 0xd2,
	0x21, 0x36, 0x61, 0x2b, 0xdf, 0x20, 0xe0, 0xd7, 0xf5, 0x1f, 0xba, 0x48, 0x81, 0x13, 0x00, 0xa4,
	0x2e, 0x73, 0x24, 0x1e, 0xe8, 0x2a, 0x24, 0x3d, 0xfd, 0x01, 0xcd, 0x41, 0x1a, 0xa0, 0x4c, 0x0a,
	0x26, 0xf7, 0x19, 0xbb, 0xc6, 0x50, 0x57, 0xaf, 0x42, 0xda, 0xef, 0x3c, 0x34, 0x0f, 0x71, 0xf7,
	0x42, 0x86, 0xfe, 0x07, 0xe7, 0xe1, 0x4c, 0x59, 0x6c, 0xf1, 0x8a, 0x80, 0xc5, 0xdc, 0x82, 0xaa,
	0x6c, 0x49, 0xb5, 0xa6, 0xce, 0x5b, 0xff, 0x11, 0x31, 0xe8, 0xbf, 0xab, 0x74, 0x2c, 0x9c, 0xa6,
	0xed, 0xb7, 0xc4, 0x2a, 0x1d, 0x83, 0x74, 0x3c, 0xff, 0x1b, 0x0d, 0xa9, 0x05, 0x1d, 0xf3, 0x26,
	0xfe, 0xc7, 0xdb, 0x6b, 0x7a, 0x84, 0xbd, 0xde, 0xb7, 0x9d, 0x16, 0x8f, 0x66, 0xa7, 0x80, 0x59,
	0x6e, 0xfd, 0x75, 0xb3, 0xbc, 0x67, 0x9b, 0xdc, 0x38, 0x82, 0x4d, 0xfc, 0xee, 0xb8, 0x34, 0xda,
	0x1d, 0x81, 0xa2, 0x3e, 0xf9, 0xe2, 0xa3, 0x40, 0xb7, 0x1e, 0x51, 0x73, 0xbf, 0xd3, 0x70, 0x82,
	0xc5, 0x9a, 0xcc, 0x0b, 0xc7, 0x45, 0x77, 0x5c, 0x74, 0x1f, 0xa8, 0xe8, 0x7e, 0xa5, 0x21, 0xbe,
	0x84, 0xcd, 0xe3, 0x82, 0x3b, 0x2e, 0xb8, 0x0f, 0x52, 0x70, 0x95, 0x6f, 0xd0, 0xde, 0xab, 0x6c,
	0x68, 0xff, 0x55, 0x36, 0xf4, 0xf6, 0x55, 0x16, 0x3d, 0xee, 0x65, 0xd1, 0xd3, 0x5e, 0x16, 0xfd,
	0xd8, 0xcb, 0xa2, 0xbd, 0x5e, 0x16, 0xbd, 0xec, 0x65, 0xd1, 0x9b, 0x5e, 0x36, 0xf4, 0xb6, 0x97,
	0x45, 0xdf, 0xbe, 0xce, 0x86, 0xf6, 0x5e, 0x67, 0x43, 0xfb, 0xaf, 0xb3, 0xa1, 0xbb, 0x9b, 0x35,
	0x55, 0xbb, 0x5f, 0x2b, 0xb4, 0x54, 0xd9, 0xc4, 0xba, 0xce, 0x17, 0x9a, 0x46, 0x91, 0xfc, 0xd8,
	0x52, 0xf5, 0xc6, 0x15, 0x4d, 0x57, 0x5b, 0x92, 0x88, 0xf5, 0x2b, 0xfd, 0xe9, 0xa2, 0x56, 0xad,
	0xa9, 0x45, 0xfc, 0xd0, 0x74, 0xbe, 0x6f, 0xbe, 0xf3, 0x3b, 0x6e, 0x35, 0x4a, 0x3e, 0x77, 0x5e,
	0xfb, 0x33, 0x00, 0x00, 0xff, 0xff, 0x6c, 0xa0, 0xe9, 0x2c, 0xf2, 0x15, 0x00, 0x00,
}

func (this *IPv4Leasepool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPv4Leasepool)
	if !ok {
		that2, ok := that.(IPv4Leasepool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ipv4Leasepool) != len(that1.Ipv4Leasepool) {
		return false
	}
	for i := range this.Ipv4Leasepool {
		if !this.Ipv4Leasepool[i].Equal(that1.Ipv4Leasepool[i]) {
			return false
		}
	}
	return true
}
func (this *IPv6Leasepool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPv6Leasepool)
	if !ok {
		that2, ok := that.(IPv6Leasepool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ipv6Leasepool) != len(that1.Ipv6Leasepool) {
		return false
	}
	for i := range this.Ipv6Leasepool {
		if !this.Ipv6Leasepool[i].Equal(that1.Ipv6Leasepool[i]) {
			return false
		}
	}
	return true
}
func (this *DualStackLeasePool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DualStackLeasePool)
	if !ok {
		that2, ok := that.(DualStackLeasePool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv4Leasepool.Equal(that1.Ipv4Leasepool) {
		return false
	}
	if !this.Ipv6Leasepool.Equal(that1.Ipv6Leasepool) {
		return false
	}
	return true
}
func (this *LeasePoolList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LeasePoolList)
	if !ok {
		that2, ok := that.(LeasePoolList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.IpaddressType == nil {
		if this.IpaddressType != nil {
			return false
		}
	} else if this.IpaddressType == nil {
		return false
	} else if !this.IpaddressType.Equal(that1.IpaddressType) {
		return false
	}
	return true
}
func (this *LeasePoolList_Ipv4Leasepool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LeasePoolList_Ipv4Leasepool)
	if !ok {
		that2, ok := that.(LeasePoolList_Ipv4Leasepool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv4Leasepool.Equal(that1.Ipv4Leasepool) {
		return false
	}
	return true
}
func (this *LeasePoolList_Ipv6Leasepool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LeasePoolList_Ipv6Leasepool)
	if !ok {
		that2, ok := that.(LeasePoolList_Ipv6Leasepool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv6Leasepool.Equal(that1.Ipv6Leasepool) {
		return false
	}
	return true
}
func (this *LeasePoolList_Ipv4Ipv6Leasepool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LeasePoolList_Ipv4Ipv6Leasepool)
	if !ok {
		that2, ok := that.(LeasePoolList_Ipv4Ipv6Leasepool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv4Ipv6Leasepool.Equal(that1.Ipv4Ipv6Leasepool) {
		return false
	}
	return true
}
func (this *Policy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Policy)
	if !ok {
		that2, ok := that.(Policy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Policy) != len(that1.Policy) {
		return false
	}
	for i := range this.Policy {
		if !this.Policy[i].Equal(that1.Policy[i]) {
			return false
		}
	}
	return true
}
func (this *IPv4AppVipPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPv4AppVipPool)
	if !ok {
		that2, ok := that.(IPv4AppVipPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ipv4AppVipPool) != len(that1.Ipv4AppVipPool) {
		return false
	}
	for i := range this.Ipv4AppVipPool {
		if !this.Ipv4AppVipPool[i].Equal(that1.Ipv4AppVipPool[i]) {
			return false
		}
	}
	return true
}
func (this *IPv6AppVipPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPv6AppVipPool)
	if !ok {
		that2, ok := that.(IPv6AppVipPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ipv6AppVipPool) != len(that1.Ipv6AppVipPool) {
		return false
	}
	for i := range this.Ipv6AppVipPool {
		if !this.Ipv6AppVipPool[i].Equal(that1.Ipv6AppVipPool[i]) {
			return false
		}
	}
	return true
}
func (this *DualStackAppVipPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DualStackAppVipPool)
	if !ok {
		that2, ok := that.(DualStackAppVipPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv4AppVipPool.Equal(that1.Ipv4AppVipPool) {
		return false
	}
	if !this.Ipv6AppVipPool.Equal(that1.Ipv6AppVipPool) {
		return false
	}
	return true
}
func (this *AppVIPPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppVIPPool)
	if !ok {
		that2, ok := that.(AppVIPPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.IpaddressType == nil {
		if this.IpaddressType != nil {
			return false
		}
	} else if this.IpaddressType == nil {
		return false
	} else if !this.IpaddressType.Equal(that1.IpaddressType) {
		return false
	}
	return true
}
func (this *AppVIPPool_Ipv4AppVipPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppVIPPool_Ipv4AppVipPool)
	if !ok {
		that2, ok := that.(AppVIPPool_Ipv4AppVipPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv4AppVipPool.Equal(that1.Ipv4AppVipPool) {
		return false
	}
	return true
}
func (this *AppVIPPool_Ipv6AppVipPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppVIPPool_Ipv6AppVipPool)
	if !ok {
		that2, ok := that.(AppVIPPool_Ipv6AppVipPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv6AppVipPool.Equal(that1.Ipv6AppVipPool) {
		return false
	}
	return true
}
func (this *AppVIPPool_Ipv4Ipv6AppVipPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppVIPPool_Ipv4Ipv6AppVipPool)
	if !ok {
		that2, ok := that.(AppVIPPool_Ipv4Ipv6AppVipPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv4Ipv6AppVipPool.Equal(that1.Ipv4Ipv6AppVipPool) {
		return false
	}
	return true
}
func (this *CloudGateways) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudGateways)
	if !ok {
		that2, ok := that.(CloudGateways)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.CloudGateway) != len(that1.CloudGateway) {
		return false
	}
	for i := range this.CloudGateway {
		if !this.CloudGateway[i].Equal(that1.CloudGateway[i]) {
			return false
		}
	}
	return true
}
func (this *CloudGatewayAdvertisement) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudGatewayAdvertisement)
	if !ok {
		that2, ok := that.(CloudGatewayAdvertisement)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.CloudGatewayChoice == nil {
		if this.CloudGatewayChoice != nil {
			return false
		}
	} else if this.CloudGatewayChoice == nil {
		return false
	} else if !this.CloudGatewayChoice.Equal(that1.CloudGatewayChoice) {
		return false
	}
	return true
}
func (this *CloudGatewayAdvertisement_AllCloud) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudGatewayAdvertisement_AllCloud)
	if !ok {
		that2, ok := that.(CloudGatewayAdvertisement_AllCloud)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllCloud.Equal(that1.AllCloud) {
		return false
	}
	return true
}
func (this *CloudGatewayAdvertisement_ReSites) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudGatewayAdvertisement_ReSites)
	if !ok {
		that2, ok := that.(CloudGatewayAdvertisement_ReSites)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ReSites.Equal(that1.ReSites) {
		return false
	}
	return true
}
func (this *Gateways) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Gateways)
	if !ok {
		that2, ok := that.(Gateways)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PerimeterRe.Equal(that1.PerimeterRe) {
		return false
	}
	if len(this.BigipSite) != len(that1.BigipSite) {
		return false
	}
	for i := range this.BigipSite {
		if !this.BigipSite[i].Equal(that1.BigipSite[i]) {
			return false
		}
	}
	return true
}
func (this *Certificate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Certificate)
	if !ok {
		that2, ok := that.(Certificate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Certificate) != len(that1.Certificate) {
		return false
	}
	for i := range this.Certificate {
		if !this.Certificate[i].Equal(that1.Certificate[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LeasePool.Equal(that1.LeasePool) {
		return false
	}
	if !this.Gateways.Equal(that1.Gateways) {
		return false
	}
	if this.AccessFqdn != that1.AccessFqdn {
		return false
	}
	if !this.Cert.Equal(that1.Cert) {
		return false
	}
	if len(this.CdnCeVhApiGw) != len(that1.CdnCeVhApiGw) {
		return false
	}
	for i := range this.CdnCeVhApiGw {
		if !this.CdnCeVhApiGw[i].Equal(that1.CdnCeVhApiGw[i]) {
			return false
		}
	}
	if !this.AppVipPool.Equal(that1.AppVipPool) {
		return false
	}
	if !this.Policy.Equal(that1.Policy) {
		return false
	}
	if !this.VipDnsProxy.Equal(that1.VipDnsProxy) {
		return false
	}
	if len(this.AppVipSubnet) != len(that1.AppVipSubnet) {
		return false
	}
	for i := range this.AppVipSubnet {
		if this.AppVipSubnet[i] != that1.AppVipSubnet[i] {
			return false
		}
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LeasePool.Equal(that1.LeasePool) {
		return false
	}
	if !this.Gateways.Equal(that1.Gateways) {
		return false
	}
	if this.AccessFqdn != that1.AccessFqdn {
		return false
	}
	if !this.Cert.Equal(that1.Cert) {
		return false
	}
	if len(this.CdnCeVhApiGw) != len(that1.CdnCeVhApiGw) {
		return false
	}
	for i := range this.CdnCeVhApiGw {
		if !this.CdnCeVhApiGw[i].Equal(that1.CdnCeVhApiGw[i]) {
			return false
		}
	}
	if !this.AppVipPool.Equal(that1.AppVipPool) {
		return false
	}
	if !this.Policy.Equal(that1.Policy) {
		return false
	}
	if !this.VipDnsProxy.Equal(that1.VipDnsProxy) {
		return false
	}
	if len(this.AppVipSubnet) != len(that1.AppVipSubnet) {
		return false
	}
	for i := range this.AppVipSubnet {
		if this.AppVipSubnet[i] != that1.AppVipSubnet[i] {
			return false
		}
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LeasePool.Equal(that1.LeasePool) {
		return false
	}
	if !this.Gateways.Equal(that1.Gateways) {
		return false
	}
	if this.AccessFqdn != that1.AccessFqdn {
		return false
	}
	if !this.Cert.Equal(that1.Cert) {
		return false
	}
	if len(this.CdnCeVhApiGw) != len(that1.CdnCeVhApiGw) {
		return false
	}
	for i := range this.CdnCeVhApiGw {
		if !this.CdnCeVhApiGw[i].Equal(that1.CdnCeVhApiGw[i]) {
			return false
		}
	}
	if !this.AppVipPool.Equal(that1.AppVipPool) {
		return false
	}
	if !this.Policy.Equal(that1.Policy) {
		return false
	}
	if !this.VipDnsProxy.Equal(that1.VipDnsProxy) {
		return false
	}
	if len(this.AppVipSubnet) != len(that1.AppVipSubnet) {
		return false
	}
	for i := range this.AppVipSubnet {
		if this.AppVipSubnet[i] != that1.AppVipSubnet[i] {
			return false
		}
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LeasePool.Equal(that1.LeasePool) {
		return false
	}
	if !this.Gateways.Equal(that1.Gateways) {
		return false
	}
	if this.AccessFqdn != that1.AccessFqdn {
		return false
	}
	if !this.Cert.Equal(that1.Cert) {
		return false
	}
	if len(this.CdnCeVhApiGw) != len(that1.CdnCeVhApiGw) {
		return false
	}
	for i := range this.CdnCeVhApiGw {
		if !this.CdnCeVhApiGw[i].Equal(that1.CdnCeVhApiGw[i]) {
			return false
		}
	}
	if !this.AppVipPool.Equal(that1.AppVipPool) {
		return false
	}
	if !this.Policy.Equal(that1.Policy) {
		return false
	}
	if !this.VipDnsProxy.Equal(that1.VipDnsProxy) {
		return false
	}
	if len(this.AppVipSubnet) != len(that1.AppVipSubnet) {
		return false
	}
	for i := range this.AppVipSubnet {
		if this.AppVipSubnet[i] != that1.AppVipSubnet[i] {
			return false
		}
	}
	return true
}
func (this *IPv4Leasepool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_domain.IPv4Leasepool{")
	if this.Ipv4Leasepool != nil {
		s = append(s, "Ipv4Leasepool: "+fmt.Sprintf("%#v", this.Ipv4Leasepool)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IPv6Leasepool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_domain.IPv6Leasepool{")
	if this.Ipv6Leasepool != nil {
		s = append(s, "Ipv6Leasepool: "+fmt.Sprintf("%#v", this.Ipv6Leasepool)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DualStackLeasePool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_domain.DualStackLeasePool{")
	if this.Ipv4Leasepool != nil {
		s = append(s, "Ipv4Leasepool: "+fmt.Sprintf("%#v", this.Ipv4Leasepool)+",\n")
	}
	if this.Ipv6Leasepool != nil {
		s = append(s, "Ipv6Leasepool: "+fmt.Sprintf("%#v", this.Ipv6Leasepool)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LeasePoolList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&uztna_domain.LeasePoolList{")
	if this.IpaddressType != nil {
		s = append(s, "IpaddressType: "+fmt.Sprintf("%#v", this.IpaddressType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LeasePoolList_Ipv4Leasepool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_domain.LeasePoolList_Ipv4Leasepool{` +
		`Ipv4Leasepool:` + fmt.Sprintf("%#v", this.Ipv4Leasepool) + `}`}, ", ")
	return s
}
func (this *LeasePoolList_Ipv6Leasepool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_domain.LeasePoolList_Ipv6Leasepool{` +
		`Ipv6Leasepool:` + fmt.Sprintf("%#v", this.Ipv6Leasepool) + `}`}, ", ")
	return s
}
func (this *LeasePoolList_Ipv4Ipv6Leasepool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_domain.LeasePoolList_Ipv4Ipv6Leasepool{` +
		`Ipv4Ipv6Leasepool:` + fmt.Sprintf("%#v", this.Ipv4Ipv6Leasepool) + `}`}, ", ")
	return s
}
func (this *Policy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_domain.Policy{")
	if this.Policy != nil {
		s = append(s, "Policy: "+fmt.Sprintf("%#v", this.Policy)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IPv4AppVipPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_domain.IPv4AppVipPool{")
	if this.Ipv4AppVipPool != nil {
		s = append(s, "Ipv4AppVipPool: "+fmt.Sprintf("%#v", this.Ipv4AppVipPool)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IPv6AppVipPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_domain.IPv6AppVipPool{")
	if this.Ipv6AppVipPool != nil {
		s = append(s, "Ipv6AppVipPool: "+fmt.Sprintf("%#v", this.Ipv6AppVipPool)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DualStackAppVipPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_domain.DualStackAppVipPool{")
	if this.Ipv4AppVipPool != nil {
		s = append(s, "Ipv4AppVipPool: "+fmt.Sprintf("%#v", this.Ipv4AppVipPool)+",\n")
	}
	if this.Ipv6AppVipPool != nil {
		s = append(s, "Ipv6AppVipPool: "+fmt.Sprintf("%#v", this.Ipv6AppVipPool)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AppVIPPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&uztna_domain.AppVIPPool{")
	if this.IpaddressType != nil {
		s = append(s, "IpaddressType: "+fmt.Sprintf("%#v", this.IpaddressType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AppVIPPool_Ipv4AppVipPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_domain.AppVIPPool_Ipv4AppVipPool{` +
		`Ipv4AppVipPool:` + fmt.Sprintf("%#v", this.Ipv4AppVipPool) + `}`}, ", ")
	return s
}
func (this *AppVIPPool_Ipv6AppVipPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_domain.AppVIPPool_Ipv6AppVipPool{` +
		`Ipv6AppVipPool:` + fmt.Sprintf("%#v", this.Ipv6AppVipPool) + `}`}, ", ")
	return s
}
func (this *AppVIPPool_Ipv4Ipv6AppVipPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_domain.AppVIPPool_Ipv4Ipv6AppVipPool{` +
		`Ipv4Ipv6AppVipPool:` + fmt.Sprintf("%#v", this.Ipv4Ipv6AppVipPool) + `}`}, ", ")
	return s
}
func (this *CloudGateways) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_domain.CloudGateways{")
	if this.CloudGateway != nil {
		s = append(s, "CloudGateway: "+fmt.Sprintf("%#v", this.CloudGateway)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudGatewayAdvertisement) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_domain.CloudGatewayAdvertisement{")
	if this.CloudGatewayChoice != nil {
		s = append(s, "CloudGatewayChoice: "+fmt.Sprintf("%#v", this.CloudGatewayChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudGatewayAdvertisement_AllCloud) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_domain.CloudGatewayAdvertisement_AllCloud{` +
		`AllCloud:` + fmt.Sprintf("%#v", this.AllCloud) + `}`}, ", ")
	return s
}
func (this *CloudGatewayAdvertisement_ReSites) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_domain.CloudGatewayAdvertisement_ReSites{` +
		`ReSites:` + fmt.Sprintf("%#v", this.ReSites) + `}`}, ", ")
	return s
}
func (this *Gateways) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_domain.Gateways{")
	if this.PerimeterRe != nil {
		s = append(s, "PerimeterRe: "+fmt.Sprintf("%#v", this.PerimeterRe)+",\n")
	}
	if this.BigipSite != nil {
		s = append(s, "BigipSite: "+fmt.Sprintf("%#v", this.BigipSite)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Certificate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_domain.Certificate{")
	if this.Certificate != nil {
		s = append(s, "Certificate: "+fmt.Sprintf("%#v", this.Certificate)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&uztna_domain.GlobalSpecType{")
	if this.LeasePool != nil {
		s = append(s, "LeasePool: "+fmt.Sprintf("%#v", this.LeasePool)+",\n")
	}
	if this.Gateways != nil {
		s = append(s, "Gateways: "+fmt.Sprintf("%#v", this.Gateways)+",\n")
	}
	s = append(s, "AccessFqdn: "+fmt.Sprintf("%#v", this.AccessFqdn)+",\n")
	if this.Cert != nil {
		s = append(s, "Cert: "+fmt.Sprintf("%#v", this.Cert)+",\n")
	}
	if this.CdnCeVhApiGw != nil {
		s = append(s, "CdnCeVhApiGw: "+fmt.Sprintf("%#v", this.CdnCeVhApiGw)+",\n")
	}
	if this.AppVipPool != nil {
		s = append(s, "AppVipPool: "+fmt.Sprintf("%#v", this.AppVipPool)+",\n")
	}
	if this.Policy != nil {
		s = append(s, "Policy: "+fmt.Sprintf("%#v", this.Policy)+",\n")
	}
	if this.VipDnsProxy != nil {
		s = append(s, "VipDnsProxy: "+fmt.Sprintf("%#v", this.VipDnsProxy)+",\n")
	}
	s = append(s, "AppVipSubnet: "+fmt.Sprintf("%#v", this.AppVipSubnet)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&uztna_domain.CreateSpecType{")
	if this.LeasePool != nil {
		s = append(s, "LeasePool: "+fmt.Sprintf("%#v", this.LeasePool)+",\n")
	}
	if this.Gateways != nil {
		s = append(s, "Gateways: "+fmt.Sprintf("%#v", this.Gateways)+",\n")
	}
	s = append(s, "AccessFqdn: "+fmt.Sprintf("%#v", this.AccessFqdn)+",\n")
	if this.Cert != nil {
		s = append(s, "Cert: "+fmt.Sprintf("%#v", this.Cert)+",\n")
	}
	if this.CdnCeVhApiGw != nil {
		s = append(s, "CdnCeVhApiGw: "+fmt.Sprintf("%#v", this.CdnCeVhApiGw)+",\n")
	}
	if this.AppVipPool != nil {
		s = append(s, "AppVipPool: "+fmt.Sprintf("%#v", this.AppVipPool)+",\n")
	}
	if this.Policy != nil {
		s = append(s, "Policy: "+fmt.Sprintf("%#v", this.Policy)+",\n")
	}
	if this.VipDnsProxy != nil {
		s = append(s, "VipDnsProxy: "+fmt.Sprintf("%#v", this.VipDnsProxy)+",\n")
	}
	s = append(s, "AppVipSubnet: "+fmt.Sprintf("%#v", this.AppVipSubnet)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&uztna_domain.ReplaceSpecType{")
	if this.LeasePool != nil {
		s = append(s, "LeasePool: "+fmt.Sprintf("%#v", this.LeasePool)+",\n")
	}
	if this.Gateways != nil {
		s = append(s, "Gateways: "+fmt.Sprintf("%#v", this.Gateways)+",\n")
	}
	s = append(s, "AccessFqdn: "+fmt.Sprintf("%#v", this.AccessFqdn)+",\n")
	if this.Cert != nil {
		s = append(s, "Cert: "+fmt.Sprintf("%#v", this.Cert)+",\n")
	}
	if this.CdnCeVhApiGw != nil {
		s = append(s, "CdnCeVhApiGw: "+fmt.Sprintf("%#v", this.CdnCeVhApiGw)+",\n")
	}
	if this.AppVipPool != nil {
		s = append(s, "AppVipPool: "+fmt.Sprintf("%#v", this.AppVipPool)+",\n")
	}
	if this.Policy != nil {
		s = append(s, "Policy: "+fmt.Sprintf("%#v", this.Policy)+",\n")
	}
	if this.VipDnsProxy != nil {
		s = append(s, "VipDnsProxy: "+fmt.Sprintf("%#v", this.VipDnsProxy)+",\n")
	}
	s = append(s, "AppVipSubnet: "+fmt.Sprintf("%#v", this.AppVipSubnet)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&uztna_domain.GetSpecType{")
	if this.LeasePool != nil {
		s = append(s, "LeasePool: "+fmt.Sprintf("%#v", this.LeasePool)+",\n")
	}
	if this.Gateways != nil {
		s = append(s, "Gateways: "+fmt.Sprintf("%#v", this.Gateways)+",\n")
	}
	s = append(s, "AccessFqdn: "+fmt.Sprintf("%#v", this.AccessFqdn)+",\n")
	if this.Cert != nil {
		s = append(s, "Cert: "+fmt.Sprintf("%#v", this.Cert)+",\n")
	}
	if this.CdnCeVhApiGw != nil {
		s = append(s, "CdnCeVhApiGw: "+fmt.Sprintf("%#v", this.CdnCeVhApiGw)+",\n")
	}
	if this.AppVipPool != nil {
		s = append(s, "AppVipPool: "+fmt.Sprintf("%#v", this.AppVipPool)+",\n")
	}
	if this.Policy != nil {
		s = append(s, "Policy: "+fmt.Sprintf("%#v", this.Policy)+",\n")
	}
	if this.VipDnsProxy != nil {
		s = append(s, "VipDnsProxy: "+fmt.Sprintf("%#v", this.VipDnsProxy)+",\n")
	}
	s = append(s, "AppVipSubnet: "+fmt.Sprintf("%#v", this.AppVipSubnet)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *IPv4Leasepool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv4Leasepool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPv4Leasepool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ipv4Leasepool) > 0 {
		for iNdEx := len(m.Ipv4Leasepool) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ipv4Leasepool[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *IPv6Leasepool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv6Leasepool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPv6Leasepool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ipv6Leasepool) > 0 {
		for iNdEx := len(m.Ipv6Leasepool) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ipv6Leasepool[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *DualStackLeasePool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DualStackLeasePool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DualStackLeasePool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ipv6Leasepool != nil {
		{
			size, err := m.Ipv6Leasepool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Ipv4Leasepool != nil {
		{
			size, err := m.Ipv4Leasepool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *LeasePoolList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeasePoolList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeasePoolList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IpaddressType != nil {
		{
			size := m.IpaddressType.Size()
			i -= size
			if _, err := m.IpaddressType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *LeasePoolList_Ipv4Leasepool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeasePoolList_Ipv4Leasepool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ipv4Leasepool != nil {
		{
			size, err := m.Ipv4Leasepool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *LeasePoolList_Ipv6Leasepool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeasePoolList_Ipv6Leasepool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ipv6Leasepool != nil {
		{
			size, err := m.Ipv6Leasepool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *LeasePoolList_Ipv4Ipv6Leasepool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeasePoolList_Ipv4Ipv6Leasepool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ipv4Ipv6Leasepool != nil {
		{
			size, err := m.Ipv4Ipv6Leasepool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Policy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Policy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Policy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Policy) > 0 {
		for iNdEx := len(m.Policy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Policy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IPv4AppVipPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv4AppVipPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPv4AppVipPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ipv4AppVipPool) > 0 {
		for iNdEx := len(m.Ipv4AppVipPool) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ipv4AppVipPool[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IPv6AppVipPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv6AppVipPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPv6AppVipPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ipv6AppVipPool) > 0 {
		for iNdEx := len(m.Ipv6AppVipPool) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ipv6AppVipPool[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DualStackAppVipPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DualStackAppVipPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DualStackAppVipPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ipv6AppVipPool != nil {
		{
			size, err := m.Ipv6AppVipPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Ipv4AppVipPool != nil {
		{
			size, err := m.Ipv4AppVipPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppVIPPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppVIPPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppVIPPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IpaddressType != nil {
		{
			size := m.IpaddressType.Size()
			i -= size
			if _, err := m.IpaddressType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AppVIPPool_Ipv4AppVipPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppVIPPool_Ipv4AppVipPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ipv4AppVipPool != nil {
		{
			size, err := m.Ipv4AppVipPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AppVIPPool_Ipv6AppVipPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppVIPPool_Ipv6AppVipPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ipv6AppVipPool != nil {
		{
			size, err := m.Ipv6AppVipPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AppVIPPool_Ipv4Ipv6AppVipPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppVIPPool_Ipv4Ipv6AppVipPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ipv4Ipv6AppVipPool != nil {
		{
			size, err := m.Ipv4Ipv6AppVipPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CloudGateways) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudGateways) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudGateways) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CloudGateway) > 0 {
		for iNdEx := len(m.CloudGateway) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CloudGateway[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CloudGatewayAdvertisement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudGatewayAdvertisement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudGatewayAdvertisement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CloudGatewayChoice != nil {
		{
			size := m.CloudGatewayChoice.Size()
			i -= size
			if _, err := m.CloudGatewayChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CloudGatewayAdvertisement_AllCloud) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudGatewayAdvertisement_AllCloud) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllCloud != nil {
		{
			size, err := m.AllCloud.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CloudGatewayAdvertisement_ReSites) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudGatewayAdvertisement_ReSites) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReSites != nil {
		{
			size, err := m.ReSites.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Gateways) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Gateways) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Gateways) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PerimeterRe != nil {
		{
			size, err := m.PerimeterRe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.BigipSite) > 0 {
		for iNdEx := len(m.BigipSite) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BigipSite[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	return len(dAtA) - i, nil
}

func (m *Certificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Certificate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Certificate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Certificate) > 0 {
		for iNdEx := len(m.Certificate) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Certificate[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AppVipSubnet) > 0 {
		for iNdEx := len(m.AppVipSubnet) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AppVipSubnet[iNdEx])
			copy(dAtA[i:], m.AppVipSubnet[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AppVipSubnet[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.AccessFqdn) > 0 {
		i -= len(m.AccessFqdn)
		copy(dAtA[i:], m.AccessFqdn)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccessFqdn)))
		i--
		dAtA[i] = 0x5a
	}
	if m.VipDnsProxy != nil {
		{
			size, err := m.VipDnsProxy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Policy != nil {
		{
			size, err := m.Policy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.AppVipPool != nil {
		{
			size, err := m.AppVipPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CdnCeVhApiGw) > 0 {
		for iNdEx := len(m.CdnCeVhApiGw) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CdnCeVhApiGw[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Cert != nil {
		{
			size, err := m.Cert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Gateways != nil {
		{
			size, err := m.Gateways.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LeasePool != nil {
		{
			size, err := m.LeasePool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AppVipSubnet) > 0 {
		for iNdEx := len(m.AppVipSubnet) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AppVipSubnet[iNdEx])
			copy(dAtA[i:], m.AppVipSubnet[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AppVipSubnet[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.AccessFqdn) > 0 {
		i -= len(m.AccessFqdn)
		copy(dAtA[i:], m.AccessFqdn)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccessFqdn)))
		i--
		dAtA[i] = 0x5a
	}
	if m.VipDnsProxy != nil {
		{
			size, err := m.VipDnsProxy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Policy != nil {
		{
			size, err := m.Policy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.AppVipPool != nil {
		{
			size, err := m.AppVipPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CdnCeVhApiGw) > 0 {
		for iNdEx := len(m.CdnCeVhApiGw) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CdnCeVhApiGw[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Cert != nil {
		{
			size, err := m.Cert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Gateways != nil {
		{
			size, err := m.Gateways.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LeasePool != nil {
		{
			size, err := m.LeasePool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AppVipSubnet) > 0 {
		for iNdEx := len(m.AppVipSubnet) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AppVipSubnet[iNdEx])
			copy(dAtA[i:], m.AppVipSubnet[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AppVipSubnet[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.AccessFqdn) > 0 {
		i -= len(m.AccessFqdn)
		copy(dAtA[i:], m.AccessFqdn)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccessFqdn)))
		i--
		dAtA[i] = 0x5a
	}
	if m.VipDnsProxy != nil {
		{
			size, err := m.VipDnsProxy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Policy != nil {
		{
			size, err := m.Policy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.AppVipPool != nil {
		{
			size, err := m.AppVipPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CdnCeVhApiGw) > 0 {
		for iNdEx := len(m.CdnCeVhApiGw) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CdnCeVhApiGw[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Cert != nil {
		{
			size, err := m.Cert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Gateways != nil {
		{
			size, err := m.Gateways.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LeasePool != nil {
		{
			size, err := m.LeasePool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AppVipSubnet) > 0 {
		for iNdEx := len(m.AppVipSubnet) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AppVipSubnet[iNdEx])
			copy(dAtA[i:], m.AppVipSubnet[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AppVipSubnet[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.AccessFqdn) > 0 {
		i -= len(m.AccessFqdn)
		copy(dAtA[i:], m.AccessFqdn)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccessFqdn)))
		i--
		dAtA[i] = 0x5a
	}
	if m.VipDnsProxy != nil {
		{
			size, err := m.VipDnsProxy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Policy != nil {
		{
			size, err := m.Policy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.AppVipPool != nil {
		{
			size, err := m.AppVipPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CdnCeVhApiGw) > 0 {
		for iNdEx := len(m.CdnCeVhApiGw) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CdnCeVhApiGw[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Cert != nil {
		{
			size, err := m.Cert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Gateways != nil {
		{
			size, err := m.Gateways.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LeasePool != nil {
		{
			size, err := m.LeasePool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *IPv4Leasepool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ipv4Leasepool) > 0 {
		for _, e := range m.Ipv4Leasepool {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *IPv6Leasepool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ipv6Leasepool) > 0 {
		for _, e := range m.Ipv6Leasepool {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DualStackLeasePool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipv4Leasepool != nil {
		l = m.Ipv4Leasepool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Ipv6Leasepool != nil {
		l = m.Ipv6Leasepool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *LeasePoolList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpaddressType != nil {
		n += m.IpaddressType.Size()
	}
	return n
}

func (m *LeasePoolList_Ipv4Leasepool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipv4Leasepool != nil {
		l = m.Ipv4Leasepool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LeasePoolList_Ipv6Leasepool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipv6Leasepool != nil {
		l = m.Ipv6Leasepool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LeasePoolList_Ipv4Ipv6Leasepool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipv4Ipv6Leasepool != nil {
		l = m.Ipv4Ipv6Leasepool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Policy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Policy) > 0 {
		for _, e := range m.Policy {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *IPv4AppVipPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ipv4AppVipPool) > 0 {
		for _, e := range m.Ipv4AppVipPool {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *IPv6AppVipPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ipv6AppVipPool) > 0 {
		for _, e := range m.Ipv6AppVipPool {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DualStackAppVipPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipv4AppVipPool != nil {
		l = m.Ipv4AppVipPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Ipv6AppVipPool != nil {
		l = m.Ipv6AppVipPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AppVIPPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpaddressType != nil {
		n += m.IpaddressType.Size()
	}
	return n
}

func (m *AppVIPPool_Ipv4AppVipPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipv4AppVipPool != nil {
		l = m.Ipv4AppVipPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AppVIPPool_Ipv6AppVipPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipv6AppVipPool != nil {
		l = m.Ipv6AppVipPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AppVIPPool_Ipv4Ipv6AppVipPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipv4Ipv6AppVipPool != nil {
		l = m.Ipv4Ipv6AppVipPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CloudGateways) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CloudGateway) > 0 {
		for _, e := range m.CloudGateway {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CloudGatewayAdvertisement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudGatewayChoice != nil {
		n += m.CloudGatewayChoice.Size()
	}
	return n
}

func (m *CloudGatewayAdvertisement_AllCloud) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllCloud != nil {
		l = m.AllCloud.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CloudGatewayAdvertisement_ReSites) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReSites != nil {
		l = m.ReSites.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Gateways) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BigipSite) > 0 {
		for _, e := range m.BigipSite {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.PerimeterRe != nil {
		l = m.PerimeterRe.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Certificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Certificate) > 0 {
		for _, e := range m.Certificate {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeasePool != nil {
		l = m.LeasePool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Gateways != nil {
		l = m.Gateways.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cert != nil {
		l = m.Cert.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CdnCeVhApiGw) > 0 {
		for _, e := range m.CdnCeVhApiGw {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.AppVipPool != nil {
		l = m.AppVipPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VipDnsProxy != nil {
		l = m.VipDnsProxy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AccessFqdn)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AppVipSubnet) > 0 {
		for _, s := range m.AppVipSubnet {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeasePool != nil {
		l = m.LeasePool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Gateways != nil {
		l = m.Gateways.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cert != nil {
		l = m.Cert.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CdnCeVhApiGw) > 0 {
		for _, e := range m.CdnCeVhApiGw {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.AppVipPool != nil {
		l = m.AppVipPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VipDnsProxy != nil {
		l = m.VipDnsProxy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AccessFqdn)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AppVipSubnet) > 0 {
		for _, s := range m.AppVipSubnet {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeasePool != nil {
		l = m.LeasePool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Gateways != nil {
		l = m.Gateways.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cert != nil {
		l = m.Cert.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CdnCeVhApiGw) > 0 {
		for _, e := range m.CdnCeVhApiGw {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.AppVipPool != nil {
		l = m.AppVipPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VipDnsProxy != nil {
		l = m.VipDnsProxy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AccessFqdn)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AppVipSubnet) > 0 {
		for _, s := range m.AppVipSubnet {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeasePool != nil {
		l = m.LeasePool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Gateways != nil {
		l = m.Gateways.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cert != nil {
		l = m.Cert.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CdnCeVhApiGw) > 0 {
		for _, e := range m.CdnCeVhApiGw {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.AppVipPool != nil {
		l = m.AppVipPool.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VipDnsProxy != nil {
		l = m.VipDnsProxy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AccessFqdn)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AppVipSubnet) > 0 {
		for _, s := range m.AppVipSubnet {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *IPv4Leasepool) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForIpv4Leasepool := "[]*ObjectRefType{"
	for _, f := range this.Ipv4Leasepool {
		repeatedStringForIpv4Leasepool += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForIpv4Leasepool += "}"
	s := strings.Join([]string{`&IPv4Leasepool{`,
		`Ipv4Leasepool:` + repeatedStringForIpv4Leasepool + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPv6Leasepool) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForIpv6Leasepool := "[]*ObjectRefType{"
	for _, f := range this.Ipv6Leasepool {
		repeatedStringForIpv6Leasepool += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForIpv6Leasepool += "}"
	s := strings.Join([]string{`&IPv6Leasepool{`,
		`Ipv6Leasepool:` + repeatedStringForIpv6Leasepool + `,`,
		`}`,
	}, "")
	return s
}
func (this *DualStackLeasePool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DualStackLeasePool{`,
		`Ipv4Leasepool:` + strings.Replace(this.Ipv4Leasepool.String(), "IPv4Leasepool", "IPv4Leasepool", 1) + `,`,
		`Ipv6Leasepool:` + strings.Replace(this.Ipv6Leasepool.String(), "IPv6Leasepool", "IPv6Leasepool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LeasePoolList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LeasePoolList{`,
		`IpaddressType:` + fmt.Sprintf("%v", this.IpaddressType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LeasePoolList_Ipv4Leasepool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LeasePoolList_Ipv4Leasepool{`,
		`Ipv4Leasepool:` + strings.Replace(fmt.Sprintf("%v", this.Ipv4Leasepool), "IPv4Leasepool", "IPv4Leasepool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LeasePoolList_Ipv6Leasepool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LeasePoolList_Ipv6Leasepool{`,
		`Ipv6Leasepool:` + strings.Replace(fmt.Sprintf("%v", this.Ipv6Leasepool), "IPv6Leasepool", "IPv6Leasepool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LeasePoolList_Ipv4Ipv6Leasepool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LeasePoolList_Ipv4Ipv6Leasepool{`,
		`Ipv4Ipv6Leasepool:` + strings.Replace(fmt.Sprintf("%v", this.Ipv4Ipv6Leasepool), "DualStackLeasePool", "DualStackLeasePool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Policy) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPolicy := "[]*ObjectRefType{"
	for _, f := range this.Policy {
		repeatedStringForPolicy += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForPolicy += "}"
	s := strings.Join([]string{`&Policy{`,
		`Policy:` + repeatedStringForPolicy + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPv4AppVipPool) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForIpv4AppVipPool := "[]*ObjectRefType{"
	for _, f := range this.Ipv4AppVipPool {
		repeatedStringForIpv4AppVipPool += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForIpv4AppVipPool += "}"
	s := strings.Join([]string{`&IPv4AppVipPool{`,
		`Ipv4AppVipPool:` + repeatedStringForIpv4AppVipPool + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPv6AppVipPool) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForIpv6AppVipPool := "[]*ObjectRefType{"
	for _, f := range this.Ipv6AppVipPool {
		repeatedStringForIpv6AppVipPool += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForIpv6AppVipPool += "}"
	s := strings.Join([]string{`&IPv6AppVipPool{`,
		`Ipv6AppVipPool:` + repeatedStringForIpv6AppVipPool + `,`,
		`}`,
	}, "")
	return s
}
func (this *DualStackAppVipPool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DualStackAppVipPool{`,
		`Ipv4AppVipPool:` + strings.Replace(this.Ipv4AppVipPool.String(), "IPv4AppVipPool", "IPv4AppVipPool", 1) + `,`,
		`Ipv6AppVipPool:` + strings.Replace(this.Ipv6AppVipPool.String(), "IPv6AppVipPool", "IPv6AppVipPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AppVIPPool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AppVIPPool{`,
		`IpaddressType:` + fmt.Sprintf("%v", this.IpaddressType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AppVIPPool_Ipv4AppVipPool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AppVIPPool_Ipv4AppVipPool{`,
		`Ipv4AppVipPool:` + strings.Replace(fmt.Sprintf("%v", this.Ipv4AppVipPool), "IPv4AppVipPool", "IPv4AppVipPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AppVIPPool_Ipv6AppVipPool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AppVIPPool_Ipv6AppVipPool{`,
		`Ipv6AppVipPool:` + strings.Replace(fmt.Sprintf("%v", this.Ipv6AppVipPool), "IPv6AppVipPool", "IPv6AppVipPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AppVIPPool_Ipv4Ipv6AppVipPool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AppVIPPool_Ipv4Ipv6AppVipPool{`,
		`Ipv4Ipv6AppVipPool:` + strings.Replace(fmt.Sprintf("%v", this.Ipv4Ipv6AppVipPool), "DualStackAppVipPool", "DualStackAppVipPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudGateways) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCloudGateway := "[]*ObjectRefType{"
	for _, f := range this.CloudGateway {
		repeatedStringForCloudGateway += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCloudGateway += "}"
	s := strings.Join([]string{`&CloudGateways{`,
		`CloudGateway:` + repeatedStringForCloudGateway + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudGatewayAdvertisement) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudGatewayAdvertisement{`,
		`CloudGatewayChoice:` + fmt.Sprintf("%v", this.CloudGatewayChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudGatewayAdvertisement_AllCloud) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudGatewayAdvertisement_AllCloud{`,
		`AllCloud:` + strings.Replace(fmt.Sprintf("%v", this.AllCloud), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudGatewayAdvertisement_ReSites) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudGatewayAdvertisement_ReSites{`,
		`ReSites:` + strings.Replace(fmt.Sprintf("%v", this.ReSites), "CloudGateways", "CloudGateways", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Gateways) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForBigipSite := "[]*ObjectRefType{"
	for _, f := range this.BigipSite {
		repeatedStringForBigipSite += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForBigipSite += "}"
	s := strings.Join([]string{`&Gateways{`,
		`BigipSite:` + repeatedStringForBigipSite + `,`,
		`PerimeterRe:` + strings.Replace(this.PerimeterRe.String(), "CloudGatewayAdvertisement", "CloudGatewayAdvertisement", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Certificate) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCertificate := "[]*ObjectRefType{"
	for _, f := range this.Certificate {
		repeatedStringForCertificate += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCertificate += "}"
	s := strings.Join([]string{`&Certificate{`,
		`Certificate:` + repeatedStringForCertificate + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCdnCeVhApiGw := "[]*ObjectRefType{"
	for _, f := range this.CdnCeVhApiGw {
		repeatedStringForCdnCeVhApiGw += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCdnCeVhApiGw += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`LeasePool:` + strings.Replace(this.LeasePool.String(), "LeasePoolList", "LeasePoolList", 1) + `,`,
		`Gateways:` + strings.Replace(this.Gateways.String(), "Gateways", "Gateways", 1) + `,`,
		`Cert:` + strings.Replace(this.Cert.String(), "Certificate", "Certificate", 1) + `,`,
		`CdnCeVhApiGw:` + repeatedStringForCdnCeVhApiGw + `,`,
		`AppVipPool:` + strings.Replace(this.AppVipPool.String(), "AppVIPPool", "AppVIPPool", 1) + `,`,
		`Policy:` + strings.Replace(this.Policy.String(), "Policy", "Policy", 1) + `,`,
		`VipDnsProxy:` + strings.Replace(fmt.Sprintf("%v", this.VipDnsProxy), "IpAddressType", "schema.IpAddressType", 1) + `,`,
		`AccessFqdn:` + fmt.Sprintf("%v", this.AccessFqdn) + `,`,
		`AppVipSubnet:` + fmt.Sprintf("%v", this.AppVipSubnet) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCdnCeVhApiGw := "[]*ObjectRefType{"
	for _, f := range this.CdnCeVhApiGw {
		repeatedStringForCdnCeVhApiGw += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCdnCeVhApiGw += "}"
	s := strings.Join([]string{`&CreateSpecType{`,
		`LeasePool:` + strings.Replace(this.LeasePool.String(), "LeasePoolList", "LeasePoolList", 1) + `,`,
		`Gateways:` + strings.Replace(this.Gateways.String(), "Gateways", "Gateways", 1) + `,`,
		`Cert:` + strings.Replace(this.Cert.String(), "Certificate", "Certificate", 1) + `,`,
		`CdnCeVhApiGw:` + repeatedStringForCdnCeVhApiGw + `,`,
		`AppVipPool:` + strings.Replace(this.AppVipPool.String(), "AppVIPPool", "AppVIPPool", 1) + `,`,
		`Policy:` + strings.Replace(this.Policy.String(), "Policy", "Policy", 1) + `,`,
		`VipDnsProxy:` + strings.Replace(fmt.Sprintf("%v", this.VipDnsProxy), "IpAddressType", "schema.IpAddressType", 1) + `,`,
		`AccessFqdn:` + fmt.Sprintf("%v", this.AccessFqdn) + `,`,
		`AppVipSubnet:` + fmt.Sprintf("%v", this.AppVipSubnet) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCdnCeVhApiGw := "[]*ObjectRefType{"
	for _, f := range this.CdnCeVhApiGw {
		repeatedStringForCdnCeVhApiGw += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCdnCeVhApiGw += "}"
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`LeasePool:` + strings.Replace(this.LeasePool.String(), "LeasePoolList", "LeasePoolList", 1) + `,`,
		`Gateways:` + strings.Replace(this.Gateways.String(), "Gateways", "Gateways", 1) + `,`,
		`Cert:` + strings.Replace(this.Cert.String(), "Certificate", "Certificate", 1) + `,`,
		`CdnCeVhApiGw:` + repeatedStringForCdnCeVhApiGw + `,`,
		`AppVipPool:` + strings.Replace(this.AppVipPool.String(), "AppVIPPool", "AppVIPPool", 1) + `,`,
		`Policy:` + strings.Replace(this.Policy.String(), "Policy", "Policy", 1) + `,`,
		`VipDnsProxy:` + strings.Replace(fmt.Sprintf("%v", this.VipDnsProxy), "IpAddressType", "schema.IpAddressType", 1) + `,`,
		`AccessFqdn:` + fmt.Sprintf("%v", this.AccessFqdn) + `,`,
		`AppVipSubnet:` + fmt.Sprintf("%v", this.AppVipSubnet) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCdnCeVhApiGw := "[]*ObjectRefType{"
	for _, f := range this.CdnCeVhApiGw {
		repeatedStringForCdnCeVhApiGw += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCdnCeVhApiGw += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`LeasePool:` + strings.Replace(this.LeasePool.String(), "LeasePoolList", "LeasePoolList", 1) + `,`,
		`Gateways:` + strings.Replace(this.Gateways.String(), "Gateways", "Gateways", 1) + `,`,
		`Cert:` + strings.Replace(this.Cert.String(), "Certificate", "Certificate", 1) + `,`,
		`CdnCeVhApiGw:` + repeatedStringForCdnCeVhApiGw + `,`,
		`AppVipPool:` + strings.Replace(this.AppVipPool.String(), "AppVIPPool", "AppVIPPool", 1) + `,`,
		`Policy:` + strings.Replace(this.Policy.String(), "Policy", "Policy", 1) + `,`,
		`VipDnsProxy:` + strings.Replace(fmt.Sprintf("%v", this.VipDnsProxy), "IpAddressType", "schema.IpAddressType", 1) + `,`,
		`AccessFqdn:` + fmt.Sprintf("%v", this.AccessFqdn) + `,`,
		`AppVipSubnet:` + fmt.Sprintf("%v", this.AppVipSubnet) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *IPv4Leasepool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv4Leasepool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv4Leasepool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Leasepool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4Leasepool = append(m.Ipv4Leasepool, &schema.ObjectRefType{})
			if err := m.Ipv4Leasepool[len(m.Ipv4Leasepool)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv6Leasepool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv6Leasepool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv6Leasepool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Leasepool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6Leasepool = append(m.Ipv6Leasepool, &schema.ObjectRefType{})
			if err := m.Ipv6Leasepool[len(m.Ipv6Leasepool)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DualStackLeasePool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DualStackLeasePool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DualStackLeasePool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Leasepool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ipv4Leasepool == nil {
				m.Ipv4Leasepool = &IPv4Leasepool{}
			}
			if err := m.Ipv4Leasepool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Leasepool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ipv6Leasepool == nil {
				m.Ipv6Leasepool = &IPv6Leasepool{}
			}
			if err := m.Ipv6Leasepool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeasePoolList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeasePoolList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeasePoolList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Leasepool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPv4Leasepool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpaddressType = &LeasePoolList_Ipv4Leasepool{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Leasepool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPv6Leasepool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpaddressType = &LeasePoolList_Ipv6Leasepool{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Ipv6Leasepool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DualStackLeasePool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpaddressType = &LeasePoolList_Ipv4Ipv6Leasepool{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Policy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Policy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Policy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Policy = append(m.Policy, &schema.ObjectRefType{})
			if err := m.Policy[len(m.Policy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv4AppVipPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv4AppVipPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv4AppVipPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4AppVipPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4AppVipPool = append(m.Ipv4AppVipPool, &schema.ObjectRefType{})
			if err := m.Ipv4AppVipPool[len(m.Ipv4AppVipPool)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv6AppVipPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv6AppVipPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv6AppVipPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6AppVipPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6AppVipPool = append(m.Ipv6AppVipPool, &schema.ObjectRefType{})
			if err := m.Ipv6AppVipPool[len(m.Ipv6AppVipPool)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DualStackAppVipPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DualStackAppVipPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DualStackAppVipPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4AppVipPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ipv4AppVipPool == nil {
				m.Ipv4AppVipPool = &IPv4AppVipPool{}
			}
			if err := m.Ipv4AppVipPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6AppVipPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ipv6AppVipPool == nil {
				m.Ipv6AppVipPool = &IPv6AppVipPool{}
			}
			if err := m.Ipv6AppVipPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppVIPPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppVIPPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppVIPPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4AppVipPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPv4AppVipPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpaddressType = &AppVIPPool_Ipv4AppVipPool{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6AppVipPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPv6AppVipPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpaddressType = &AppVIPPool_Ipv6AppVipPool{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Ipv6AppVipPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DualStackAppVipPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpaddressType = &AppVIPPool_Ipv4Ipv6AppVipPool{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudGateways) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudGateways: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudGateways: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudGateway = append(m.CloudGateway, &schema.ObjectRefType{})
			if err := m.CloudGateway[len(m.CloudGateway)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudGatewayAdvertisement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudGatewayAdvertisement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudGatewayAdvertisement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllCloud", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudGatewayChoice = &CloudGatewayAdvertisement_AllCloud{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReSites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloudGateways{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudGatewayChoice = &CloudGatewayAdvertisement_ReSites{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Gateways) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Gateways: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Gateways: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigipSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BigipSite = append(m.BigipSite, &schema.ObjectRefType{})
			if err := m.BigipSite[len(m.BigipSite)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerimeterRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerimeterRe == nil {
				m.PerimeterRe = &CloudGatewayAdvertisement{}
			}
			if err := m.PerimeterRe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Certificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Certificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Certificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certificate = append(m.Certificate, &schema.ObjectRefType{})
			if err := m.Certificate[len(m.Certificate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeasePool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeasePool == nil {
				m.LeasePool = &LeasePoolList{}
			}
			if err := m.LeasePool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateways == nil {
				m.Gateways = &Gateways{}
			}
			if err := m.Gateways.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cert == nil {
				m.Cert = &Certificate{}
			}
			if err := m.Cert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdnCeVhApiGw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CdnCeVhApiGw = append(m.CdnCeVhApiGw, &schema.ObjectRefType{})
			if err := m.CdnCeVhApiGw[len(m.CdnCeVhApiGw)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVipPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppVipPool == nil {
				m.AppVipPool = &AppVIPPool{}
			}
			if err := m.AppVipPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &Policy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipDnsProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VipDnsProxy == nil {
				m.VipDnsProxy = &schema.IpAddressType{}
			}
			if err := m.VipDnsProxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessFqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessFqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVipSubnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVipSubnet = append(m.AppVipSubnet, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeasePool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeasePool == nil {
				m.LeasePool = &LeasePoolList{}
			}
			if err := m.LeasePool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateways == nil {
				m.Gateways = &Gateways{}
			}
			if err := m.Gateways.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cert == nil {
				m.Cert = &Certificate{}
			}
			if err := m.Cert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdnCeVhApiGw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CdnCeVhApiGw = append(m.CdnCeVhApiGw, &schema.ObjectRefType{})
			if err := m.CdnCeVhApiGw[len(m.CdnCeVhApiGw)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVipPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppVipPool == nil {
				m.AppVipPool = &AppVIPPool{}
			}
			if err := m.AppVipPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &Policy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipDnsProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VipDnsProxy == nil {
				m.VipDnsProxy = &schema.IpAddressType{}
			}
			if err := m.VipDnsProxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessFqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessFqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVipSubnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVipSubnet = append(m.AppVipSubnet, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeasePool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeasePool == nil {
				m.LeasePool = &LeasePoolList{}
			}
			if err := m.LeasePool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateways == nil {
				m.Gateways = &Gateways{}
			}
			if err := m.Gateways.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cert == nil {
				m.Cert = &Certificate{}
			}
			if err := m.Cert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdnCeVhApiGw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CdnCeVhApiGw = append(m.CdnCeVhApiGw, &schema.ObjectRefType{})
			if err := m.CdnCeVhApiGw[len(m.CdnCeVhApiGw)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVipPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppVipPool == nil {
				m.AppVipPool = &AppVIPPool{}
			}
			if err := m.AppVipPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &Policy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipDnsProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VipDnsProxy == nil {
				m.VipDnsProxy = &schema.IpAddressType{}
			}
			if err := m.VipDnsProxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessFqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessFqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVipSubnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVipSubnet = append(m.AppVipSubnet, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeasePool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeasePool == nil {
				m.LeasePool = &LeasePoolList{}
			}
			if err := m.LeasePool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateways == nil {
				m.Gateways = &Gateways{}
			}
			if err := m.Gateways.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cert == nil {
				m.Cert = &Certificate{}
			}
			if err := m.Cert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdnCeVhApiGw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CdnCeVhApiGw = append(m.CdnCeVhApiGw, &schema.ObjectRefType{})
			if err := m.CdnCeVhApiGw[len(m.CdnCeVhApiGw)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVipPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppVipPool == nil {
				m.AppVipPool = &AppVIPPool{}
			}
			if err := m.AppVipPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &Policy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipDnsProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VipDnsProxy == nil {
				m.VipDnsProxy = &schema.IpAddressType{}
			}
			if err := m.VipDnsProxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessFqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessFqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVipSubnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVipSubnet = append(m.AppVipSubnet, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
