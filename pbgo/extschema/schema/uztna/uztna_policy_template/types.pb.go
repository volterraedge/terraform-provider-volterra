// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/uztna/uztna_policy_template/types.proto

package uztna_policy_template

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/api_group_element"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SAML Federation
//
// x-displayName: "SAML Federation"
//
// SAML Federation
type SAMLFederation struct {
	// SAML Federation
	//
	// x-displayName: "SAML Federation"
	// x-required
	// This option will allow to create or select
	// flows of type SAML Federation
	Saml []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=saml,proto3" json:"saml,omitempty"`
}

func (m *SAMLFederation) Reset()      { *m = SAMLFederation{} }
func (*SAMLFederation) ProtoMessage() {}
func (*SAMLFederation) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab7665321aa29a7a, []int{0}
}
func (m *SAMLFederation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SAMLFederation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SAMLFederation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SAMLFederation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SAMLFederation.Merge(m, src)
}
func (m *SAMLFederation) XXX_Size() int {
	return m.Size()
}
func (m *SAMLFederation) XXX_DiscardUnknown() {
	xxx_messageInfo_SAMLFederation.DiscardUnknown(m)
}

var xxx_messageInfo_SAMLFederation proto.InternalMessageInfo

func (m *SAMLFederation) GetSaml() []*schema.ObjectRefType {
	if m != nil {
		return m.Saml
	}
	return nil
}

// GEOLocation Match
//
// x-displayName: "GEOLocation Match"
//
// Geolocation Match
type GeoLocationMatch struct {
	// GEOLocation Match
	//
	// x-displayName: "GEOLocation Match"
	// x-required
	// This option will allow to create or select
	// flows of type GEOLocation Match
	Geomatch []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=geomatch,proto3" json:"geomatch,omitempty"`
}

func (m *GeoLocationMatch) Reset()      { *m = GeoLocationMatch{} }
func (*GeoLocationMatch) ProtoMessage() {}
func (*GeoLocationMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab7665321aa29a7a, []int{1}
}
func (m *GeoLocationMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeoLocationMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeoLocationMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GeoLocationMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoLocationMatch.Merge(m, src)
}
func (m *GeoLocationMatch) XXX_Size() int {
	return m.Size()
}
func (m *GeoLocationMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoLocationMatch.DiscardUnknown(m)
}

var xxx_messageInfo_GeoLocationMatch proto.InternalMessageInfo

func (m *GeoLocationMatch) GetGeomatch() []*schema.ObjectRefType {
	if m != nil {
		return m.Geomatch
	}
	return nil
}

// Flows
//
// x-displayName: "Flows"
//
// Select from SAML or ip geolocation or empty
type Flows struct {
	// Flow Type
	//
	// x-displayName: "Flow Type"
	//
	// Select SAML or Geolocation Match or Empty
	//
	// Types that are valid to be assigned to FlowType:
	//	*Flows_AllowAll
	//	*Flows_SamlFederation
	//	*Flows_GeolocationMatch
	FlowType isFlows_FlowType `protobuf_oneof:"flow_type"`
}

func (m *Flows) Reset()      { *m = Flows{} }
func (*Flows) ProtoMessage() {}
func (*Flows) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab7665321aa29a7a, []int{2}
}
func (m *Flows) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Flows) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Flows.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Flows) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Flows.Merge(m, src)
}
func (m *Flows) XXX_Size() int {
	return m.Size()
}
func (m *Flows) XXX_DiscardUnknown() {
	xxx_messageInfo_Flows.DiscardUnknown(m)
}

var xxx_messageInfo_Flows proto.InternalMessageInfo

type isFlows_FlowType interface {
	isFlows_FlowType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Flows_AllowAll struct {
	AllowAll *schema.Empty `protobuf:"bytes,2,opt,name=allow_all,json=allowAll,proto3,oneof" json:"allow_all,omitempty"`
}
type Flows_SamlFederation struct {
	SamlFederation *SAMLFederation `protobuf:"bytes,3,opt,name=saml_federation,json=samlFederation,proto3,oneof" json:"saml_federation,omitempty"`
}
type Flows_GeolocationMatch struct {
	GeolocationMatch *GeoLocationMatch `protobuf:"bytes,4,opt,name=geolocation_match,json=geolocationMatch,proto3,oneof" json:"geolocation_match,omitempty"`
}

func (*Flows_AllowAll) isFlows_FlowType()         {}
func (*Flows_SamlFederation) isFlows_FlowType()   {}
func (*Flows_GeolocationMatch) isFlows_FlowType() {}

func (m *Flows) GetFlowType() isFlows_FlowType {
	if m != nil {
		return m.FlowType
	}
	return nil
}

func (m *Flows) GetAllowAll() *schema.Empty {
	if x, ok := m.GetFlowType().(*Flows_AllowAll); ok {
		return x.AllowAll
	}
	return nil
}

func (m *Flows) GetSamlFederation() *SAMLFederation {
	if x, ok := m.GetFlowType().(*Flows_SamlFederation); ok {
		return x.SamlFederation
	}
	return nil
}

func (m *Flows) GetGeolocationMatch() *GeoLocationMatch {
	if x, ok := m.GetFlowType().(*Flows_GeolocationMatch); ok {
		return x.GeolocationMatch
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Flows) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Flows_AllowAll)(nil),
		(*Flows_SamlFederation)(nil),
		(*Flows_GeolocationMatch)(nil),
	}
}

// SimpleTemplate
//
// x-displayName: "SimpleTemplate"
// Simple Template
type SimpleTemplate struct {
	// Selection of Flow Type
	//
	// x-displayName: "Add Flow"
	// x-required
	// SimpleTemplate allows you to add/select two types of Flows
	// SAML Federation and Geolocation Match
	// Or you can also Empty Flow
	Flows []*Flows `protobuf:"bytes,1,rep,name=flows,proto3" json:"flows,omitempty"`
}

func (m *SimpleTemplate) Reset()      { *m = SimpleTemplate{} }
func (*SimpleTemplate) ProtoMessage() {}
func (*SimpleTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab7665321aa29a7a, []int{3}
}
func (m *SimpleTemplate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleTemplate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimpleTemplate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimpleTemplate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleTemplate.Merge(m, src)
}
func (m *SimpleTemplate) XXX_Size() int {
	return m.Size()
}
func (m *SimpleTemplate) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleTemplate.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleTemplate proto.InternalMessageInfo

func (m *SimpleTemplate) GetFlows() []*Flows {
	if m != nil {
		return m.Flows
	}
	return nil
}

// TemplateType
//
// x-displayName: "Template"
// Select Template type
type TemplateType struct {
	// TemplateType
	//
	// x-displayName: "Template"
	// x-required
	// We have two options of Templates
	// Simple and Deny All
	//
	// Types that are valid to be assigned to TemplateType:
	//	*TemplateType_DenyAll
	//	*TemplateType_Simple
	TemplateType isTemplateType_TemplateType `protobuf_oneof:"template_type"`
}

func (m *TemplateType) Reset()      { *m = TemplateType{} }
func (*TemplateType) ProtoMessage() {}
func (*TemplateType) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab7665321aa29a7a, []int{4}
}
func (m *TemplateType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TemplateType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TemplateType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TemplateType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TemplateType.Merge(m, src)
}
func (m *TemplateType) XXX_Size() int {
	return m.Size()
}
func (m *TemplateType) XXX_DiscardUnknown() {
	xxx_messageInfo_TemplateType.DiscardUnknown(m)
}

var xxx_messageInfo_TemplateType proto.InternalMessageInfo

type isTemplateType_TemplateType interface {
	isTemplateType_TemplateType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TemplateType_DenyAll struct {
	DenyAll *schema.Empty `protobuf:"bytes,2,opt,name=deny_all,json=denyAll,proto3,oneof" json:"deny_all,omitempty"`
}
type TemplateType_Simple struct {
	Simple *SimpleTemplate `protobuf:"bytes,3,opt,name=simple,proto3,oneof" json:"simple,omitempty"`
}

func (*TemplateType_DenyAll) isTemplateType_TemplateType() {}
func (*TemplateType_Simple) isTemplateType_TemplateType()  {}

func (m *TemplateType) GetTemplateType() isTemplateType_TemplateType {
	if m != nil {
		return m.TemplateType
	}
	return nil
}

func (m *TemplateType) GetDenyAll() *schema.Empty {
	if x, ok := m.GetTemplateType().(*TemplateType_DenyAll); ok {
		return x.DenyAll
	}
	return nil
}

func (m *TemplateType) GetSimple() *SimpleTemplate {
	if x, ok := m.GetTemplateType().(*TemplateType_Simple); ok {
		return x.Simple
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TemplateType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TemplateType_DenyAll)(nil),
		(*TemplateType_Simple)(nil),
	}
}

// GlobalSpecType
//
// x-displayName: "Global Specification"
// Shape of the UZTNA Policy Template
type GlobalSpecType struct {
	// On Start Flows
	//
	// x-displayName: "On Start Flows"
	// x-required
	// On Start Flows are evaluated continuously, in order,
	// throughout the entirety of the session
	OnStartFlow *TemplateType `protobuf:"bytes,1,opt,name=on_start_flow,json=onStartFlow,proto3" json:"on_start_flow,omitempty"`
	// Continuous Flows
	//
	// x-displayName: "Continuous Flows"
	// x-required
	// Continuous Flows provide a constant check of policy compliance
	// and continuously validates the relevant flows assigned in on start
	ContinuousFlow *TemplateType `protobuf:"bytes,2,opt,name=continuous_flow,json=continuousFlow,proto3" json:"continuous_flow,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab7665321aa29a7a, []int{5}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobalSpecType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetOnStartFlow() *TemplateType {
	if m != nil {
		return m.OnStartFlow
	}
	return nil
}

func (m *GlobalSpecType) GetContinuousFlow() *TemplateType {
	if m != nil {
		return m.ContinuousFlow
	}
	return nil
}

// CreateSpecType
//
// x-displayName: "Create Specification"
// Shape of the UZTNA Policy Template
type CreateSpecType struct {
	OnStartFlow    *TemplateType `protobuf:"bytes,1,opt,name=on_start_flow,json=onStartFlow,proto3" json:"on_start_flow,omitempty"`
	ContinuousFlow *TemplateType `protobuf:"bytes,2,opt,name=continuous_flow,json=continuousFlow,proto3" json:"continuous_flow,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab7665321aa29a7a, []int{6}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateSpecType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetOnStartFlow() *TemplateType {
	if m != nil {
		return m.OnStartFlow
	}
	return nil
}

func (m *CreateSpecType) GetContinuousFlow() *TemplateType {
	if m != nil {
		return m.ContinuousFlow
	}
	return nil
}

// ReplaceSpecType
//
// x-displayName: "Replace Specification"
// Shape of the UZTNA Policy Template
type ReplaceSpecType struct {
	OnStartFlow    *TemplateType `protobuf:"bytes,1,opt,name=on_start_flow,json=onStartFlow,proto3" json:"on_start_flow,omitempty"`
	ContinuousFlow *TemplateType `protobuf:"bytes,2,opt,name=continuous_flow,json=continuousFlow,proto3" json:"continuous_flow,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab7665321aa29a7a, []int{7}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplaceSpecType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

func (m *ReplaceSpecType) GetOnStartFlow() *TemplateType {
	if m != nil {
		return m.OnStartFlow
	}
	return nil
}

func (m *ReplaceSpecType) GetContinuousFlow() *TemplateType {
	if m != nil {
		return m.ContinuousFlow
	}
	return nil
}

// GetSpecType
//
// x-displayName: "Get Specification"
// Shape of the UZTNA Policy Template
type GetSpecType struct {
	OnStartFlow    *TemplateType `protobuf:"bytes,1,opt,name=on_start_flow,json=onStartFlow,proto3" json:"on_start_flow,omitempty"`
	ContinuousFlow *TemplateType `protobuf:"bytes,2,opt,name=continuous_flow,json=continuousFlow,proto3" json:"continuous_flow,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab7665321aa29a7a, []int{8}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSpecType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetOnStartFlow() *TemplateType {
	if m != nil {
		return m.OnStartFlow
	}
	return nil
}

func (m *GetSpecType) GetContinuousFlow() *TemplateType {
	if m != nil {
		return m.ContinuousFlow
	}
	return nil
}

func init() {
	proto.RegisterType((*SAMLFederation)(nil), "ves.io.schema.uztna.uztna_policy_template.SAMLFederation")
	proto.RegisterType((*GeoLocationMatch)(nil), "ves.io.schema.uztna.uztna_policy_template.GeoLocationMatch")
	proto.RegisterType((*Flows)(nil), "ves.io.schema.uztna.uztna_policy_template.Flows")
	proto.RegisterType((*SimpleTemplate)(nil), "ves.io.schema.uztna.uztna_policy_template.SimpleTemplate")
	proto.RegisterType((*TemplateType)(nil), "ves.io.schema.uztna.uztna_policy_template.TemplateType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.uztna.uztna_policy_template.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.uztna.uztna_policy_template.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.uztna.uztna_policy_template.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.uztna.uztna_policy_template.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/uztna/uztna_policy_template/types.proto", fileDescriptor_ab7665321aa29a7a)
}

var fileDescriptor_ab7665321aa29a7a = []byte{
	// 795 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x96, 0xcf, 0x6b, 0xe3, 0x46,
	0x14, 0xc7, 0x35, 0x76, 0xbc, 0x75, 0x9e, 0x37, 0xb6, 0x57, 0x2c, 0xac, 0x37, 0x5d, 0x54, 0x23,
	0x28, 0x6c, 0x7f, 0xac, 0xdc, 0x3a, 0x94, 0xd2, 0x2d, 0x14, 0xd6, 0x61, 0xd7, 0x6e, 0xd9, 0x25,
	0x54, 0xce, 0xa9, 0x39, 0xa8, 0x63, 0x79, 0xec, 0x28, 0x1d, 0x69, 0x84, 0x34, 0xb6, 0xe3, 0x42,
	0xa1, 0x7f, 0x42, 0x29, 0xf4, 0x7f, 0x28, 0xbd, 0xf7, 0x12, 0x43, 0xc9, 0xb1, 0xe4, 0x52, 0x1f,
	0x73, 0x6b, 0x23, 0x5f, 0x5a, 0xe8, 0x21, 0xc7, 0x1e, 0xcb, 0x8c, 0xa5, 0xc4, 0x72, 0x02, 0x4d,
	0x9a, 0x5b, 0x2e, 0x66, 0xec, 0xf7, 0xde, 0xf7, 0xbd, 0xf7, 0x99, 0xaf, 0x91, 0xe0, 0x83, 0x21,
	0x09, 0x0d, 0x87, 0xd5, 0x42, 0x7b, 0x97, 0xb8, 0xb8, 0x36, 0xf8, 0x9a, 0x7b, 0xf1, 0xa7, 0xe5,
	0x33, 0xea, 0xd8, 0x63, 0x8b, 0x13, 0xd7, 0xa7, 0x98, 0x93, 0x1a, 0x1f, 0xfb, 0x24, 0x34, 0xfc,
	0x80, 0x71, 0xa6, 0xbe, 0x35, 0x2f, 0x33, 0xe6, 0x65, 0x86, 0x2c, 0x30, 0x2e, 0x2d, 0x5b, 0x7f,
	0x27, 0xdd, 0x01, 0xfb, 0x8e, 0xd5, 0x0f, 0xd8, 0xc0, 0xb7, 0x08, 0x25, 0x2e, 0xf1, 0xf8, 0xa2,
	0xee, 0xfa, 0x83, 0x74, 0xb2, 0x47, 0x78, 0x1c, 0x78, 0x3d, 0x1d, 0x60, 0x3e, 0x77, 0x98, 0x97,
	0x54, 0x3d, 0x4c, 0x07, 0x17, 0x05, 0x1f, 0xa5, 0x43, 0x43, 0x4c, 0x9d, 0x2e, 0xe6, 0x24, 0x8e,
	0x56, 0x97, 0xa2, 0x0e, 0x19, 0x59, 0x69, 0xe9, 0x37, 0x2e, 0x66, 0x84, 0x8b, 0x0d, 0xf4, 0x1d,
	0x28, 0xb6, 0x9f, 0xbd, 0x7a, 0xf9, 0x82, 0x74, 0x49, 0x80, 0x45, 0xa5, 0xfa, 0x29, 0xac, 0x84,
	0xd8, 0xa5, 0x95, 0x4c, 0x35, 0xfb, 0xb8, 0x50, 0x7f, 0x64, 0xa4, 0x51, 0x6d, 0x75, 0xf6, 0x88,
	0xcd, 0x4d, 0xd2, 0xdb, 0x1e, 0xfb, 0xa4, 0xf1, 0xe0, 0xa7, 0x6f, 0x60, 0x8e, 0xad, 0x47, 0xd9,
	0xe8, 0xe0, 0xaf, 0xc3, 0x6c, 0xee, 0x7b, 0x94, 0x29, 0x23, 0x53, 0x4a, 0xe8, 0x04, 0xca, 0x4d,
	0xc2, 0x5e, 0x32, 0x5b, 0x2a, 0xbf, 0xc2, 0xdc, 0xde, 0x55, 0x3f, 0x87, 0x7c, 0x9f, 0x30, 0x57,
	0x9c, 0x2b, 0xd9, 0x9b, 0xb4, 0x38, 0x93, 0xd1, 0xff, 0xce, 0x42, 0xee, 0x05, 0x65, 0xa3, 0x50,
	0xdd, 0x80, 0x55, 0x4c, 0x29, 0x1b, 0x59, 0x98, 0x8a, 0x05, 0xd0, 0xe3, 0x42, 0xfd, 0xfe, 0x92,
	0xfa, 0x73, 0xd7, 0xe7, 0xe3, 0x96, 0x62, 0xe6, 0x65, 0xe2, 0x33, 0x4a, 0xd5, 0x2e, 0x94, 0xc4,
	0xb4, 0x56, 0xef, 0x8c, 0x41, 0x25, 0x2b, 0x4b, 0x3f, 0x32, 0xae, 0x6c, 0x13, 0x23, 0x0d, 0xb1,
	0xa5, 0x98, 0x45, 0xa1, 0xb9, 0x80, 0x75, 0x0f, 0xee, 0xf5, 0x09, 0xa3, 0x31, 0x0b, 0x6b, 0x0e,
	0x60, 0x45, 0xf6, 0xf9, 0xf8, 0x1a, 0x7d, 0x96, 0x79, 0xb6, 0x14, 0xb3, 0xbc, 0xa0, 0x2b, 0x7f,
	0x7b, 0x7a, 0x80, 0x8e, 0x26, 0xe8, 0x67, 0x04, 0x1e, 0xac, 0x0a, 0x2e, 0x55, 0x01, 0xf2, 0x6d,
	0x0c, 0x16, 0xa8, 0x0b, 0x7c, 0xea, 0x39, 0x89, 0x02, 0xf4, 0x0b, 0xeb, 0xd7, 0x4b, 0x62, 0x9b,
	0xea, 0xf9, 0xf0, 0xf0, 0xe6, 0x25, 0xc3, 0xd7, 0xcb, 0xcd, 0xe7, 0x5b, 0xa9, 0x59, 0x60, 0x13,
	0xd6, 0x36, 0x99, 0xd7, 0x73, 0xfa, 0x83, 0x58, 0xa8, 0x0e, 0xf7, 0x97, 0xb4, 0x0d, 0xf1, 0x1d,
	0xd6, 0x2f, 0xa8, 0x19, 0xc9, 0x6d, 0x36, 0x1e, 0xc2, 0xaa, 0xb8, 0x69, 0x4b, 0xb8, 0x54, 0xbd,
	0x7b, 0x38, 0x41, 0x99, 0xe9, 0x04, 0xa1, 0x7f, 0x26, 0x28, 0xf3, 0xd9, 0x4a, 0x1e, 0x95, 0x33,
	0xfa, 0x3e, 0x14, 0xdb, 0x8e, 0xeb, 0x53, 0xb2, 0x1d, 0x43, 0x51, 0x7b, 0x90, 0x13, 0x25, 0x61,
	0x05, 0x49, 0x43, 0xbd, 0x77, 0x0d, 0x9e, 0xd2, 0x37, 0x0d, 0xed, 0xcc, 0x57, 0x99, 0xe4, 0x94,
	0x47, 0xc9, 0xa9, 0x82, 0xcc, 0xb9, 0xbc, 0xfe, 0x0b, 0x82, 0xbb, 0x49, 0x53, 0xc1, 0x54, 0x7d,
	0x1f, 0xf2, 0x5d, 0xe2, 0x8d, 0xaf, 0x60, 0xb7, 0xd7, 0x44, 0x9e, 0x70, 0x5b, 0x1b, 0xee, 0x84,
	0x72, 0xfa, 0xff, 0x63, 0xb2, 0xd4, 0xda, 0x2d, 0xc5, 0x8c, 0xa5, 0x1a, 0x55, 0x58, 0x4b, 0x92,
	0xe6, 0xdc, 0x4a, 0x09, 0xb7, 0x68, 0x82, 0xb2, 0xf5, 0x77, 0x37, 0x62, 0x74, 0xbf, 0x21, 0x28,
	0x36, 0x29, 0xeb, 0x60, 0xda, 0xf6, 0x89, 0x2d, 0x57, 0xd8, 0x81, 0x35, 0xe6, 0x59, 0x21, 0xc7,
	0x01, 0x97, 0xff, 0xb0, 0x0a, 0x92, 0x63, 0x7d, 0x78, 0x8d, 0xb1, 0x16, 0x91, 0x98, 0x05, 0xe6,
	0xb5, 0x85, 0x98, 0x00, 0xab, 0x7e, 0x09, 0x25, 0x9b, 0x79, 0xdc, 0xf1, 0x06, 0x6c, 0x10, 0xce,
	0xe5, 0x33, 0x37, 0x93, 0x2f, 0x9e, 0xeb, 0x89, 0x0e, 0x7a, 0x84, 0xa0, 0xb8, 0x19, 0x10, 0xcc,
	0xc9, 0x2d, 0xd9, 0xe8, 0xe9, 0xbd, 0xa3, 0x4f, 0x96, 0xee, 0x48, 0x9f, 0x21, 0x28, 0x99, 0xc4,
	0xa7, 0xd8, 0xbe, 0xcd, 0x5b, 0xfe, 0x8e, 0xa0, 0xd0, 0x24, 0xfc, 0xf6, 0x6e, 0xd8, 0xf8, 0x01,
	0x4d, 0x4f, 0x34, 0xe5, 0xf8, 0x44, 0x53, 0x4e, 0x4f, 0x34, 0xf4, 0x6d, 0xa4, 0xa1, 0x1f, 0x23,
	0x0d, 0xfd, 0x1a, 0x69, 0x68, 0x1a, 0x69, 0xe8, 0x8f, 0x48, 0x43, 0x7f, 0x46, 0x9a, 0x72, 0x1a,
	0x69, 0xe8, 0xbb, 0x99, 0xa6, 0x4c, 0x67, 0x9a, 0x72, 0x3c, 0xd3, 0x94, 0x2f, 0xac, 0x3e, 0xf3,
	0xbf, 0xea, 0x1b, 0x43, 0x46, 0x39, 0x09, 0x02, 0x6c, 0x0c, 0xc2, 0x9a, 0x3c, 0xf4, 0x58, 0xe0,
	0x3e, 0xf1, 0x03, 0x36, 0x74, 0xba, 0x24, 0x78, 0x92, 0x84, 0x6b, 0x7e, 0xa7, 0xcf, 0x6a, 0x64,
	0x9f, 0xc7, 0xcf, 0xfc, 0xff, 0x7e, 0x35, 0xea, 0xdc, 0x91, 0xef, 0x02, 0x1b, 0xff, 0x06, 0x00,
	0x00, 0xff, 0xff, 0xcd, 0x47, 0x18, 0x23, 0x4e, 0x09, 0x00, 0x00,
}

func (this *SAMLFederation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SAMLFederation)
	if !ok {
		that2, ok := that.(SAMLFederation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Saml) != len(that1.Saml) {
		return false
	}
	for i := range this.Saml {
		if !this.Saml[i].Equal(that1.Saml[i]) {
			return false
		}
	}
	return true
}
func (this *GeoLocationMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GeoLocationMatch)
	if !ok {
		that2, ok := that.(GeoLocationMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Geomatch) != len(that1.Geomatch) {
		return false
	}
	for i := range this.Geomatch {
		if !this.Geomatch[i].Equal(that1.Geomatch[i]) {
			return false
		}
	}
	return true
}
func (this *Flows) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Flows)
	if !ok {
		that2, ok := that.(Flows)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.FlowType == nil {
		if this.FlowType != nil {
			return false
		}
	} else if this.FlowType == nil {
		return false
	} else if !this.FlowType.Equal(that1.FlowType) {
		return false
	}
	return true
}
func (this *Flows_AllowAll) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Flows_AllowAll)
	if !ok {
		that2, ok := that.(Flows_AllowAll)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowAll.Equal(that1.AllowAll) {
		return false
	}
	return true
}
func (this *Flows_SamlFederation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Flows_SamlFederation)
	if !ok {
		that2, ok := that.(Flows_SamlFederation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SamlFederation.Equal(that1.SamlFederation) {
		return false
	}
	return true
}
func (this *Flows_GeolocationMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Flows_GeolocationMatch)
	if !ok {
		that2, ok := that.(Flows_GeolocationMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GeolocationMatch.Equal(that1.GeolocationMatch) {
		return false
	}
	return true
}
func (this *SimpleTemplate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleTemplate)
	if !ok {
		that2, ok := that.(SimpleTemplate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Flows) != len(that1.Flows) {
		return false
	}
	for i := range this.Flows {
		if !this.Flows[i].Equal(that1.Flows[i]) {
			return false
		}
	}
	return true
}
func (this *TemplateType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TemplateType)
	if !ok {
		that2, ok := that.(TemplateType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.TemplateType == nil {
		if this.TemplateType != nil {
			return false
		}
	} else if this.TemplateType == nil {
		return false
	} else if !this.TemplateType.Equal(that1.TemplateType) {
		return false
	}
	return true
}
func (this *TemplateType_DenyAll) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TemplateType_DenyAll)
	if !ok {
		that2, ok := that.(TemplateType_DenyAll)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyAll.Equal(that1.DenyAll) {
		return false
	}
	return true
}
func (this *TemplateType_Simple) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TemplateType_Simple)
	if !ok {
		that2, ok := that.(TemplateType_Simple)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Simple.Equal(that1.Simple) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OnStartFlow.Equal(that1.OnStartFlow) {
		return false
	}
	if !this.ContinuousFlow.Equal(that1.ContinuousFlow) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OnStartFlow.Equal(that1.OnStartFlow) {
		return false
	}
	if !this.ContinuousFlow.Equal(that1.ContinuousFlow) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OnStartFlow.Equal(that1.OnStartFlow) {
		return false
	}
	if !this.ContinuousFlow.Equal(that1.ContinuousFlow) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OnStartFlow.Equal(that1.OnStartFlow) {
		return false
	}
	if !this.ContinuousFlow.Equal(that1.ContinuousFlow) {
		return false
	}
	return true
}
func (this *SAMLFederation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_policy_template.SAMLFederation{")
	if this.Saml != nil {
		s = append(s, "Saml: "+fmt.Sprintf("%#v", this.Saml)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GeoLocationMatch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_policy_template.GeoLocationMatch{")
	if this.Geomatch != nil {
		s = append(s, "Geomatch: "+fmt.Sprintf("%#v", this.Geomatch)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Flows) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&uztna_policy_template.Flows{")
	if this.FlowType != nil {
		s = append(s, "FlowType: "+fmt.Sprintf("%#v", this.FlowType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Flows_AllowAll) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_policy_template.Flows_AllowAll{` +
		`AllowAll:` + fmt.Sprintf("%#v", this.AllowAll) + `}`}, ", ")
	return s
}
func (this *Flows_SamlFederation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_policy_template.Flows_SamlFederation{` +
		`SamlFederation:` + fmt.Sprintf("%#v", this.SamlFederation) + `}`}, ", ")
	return s
}
func (this *Flows_GeolocationMatch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_policy_template.Flows_GeolocationMatch{` +
		`GeolocationMatch:` + fmt.Sprintf("%#v", this.GeolocationMatch) + `}`}, ", ")
	return s
}
func (this *SimpleTemplate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_policy_template.SimpleTemplate{")
	if this.Flows != nil {
		s = append(s, "Flows: "+fmt.Sprintf("%#v", this.Flows)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TemplateType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_policy_template.TemplateType{")
	if this.TemplateType != nil {
		s = append(s, "TemplateType: "+fmt.Sprintf("%#v", this.TemplateType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TemplateType_DenyAll) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_policy_template.TemplateType_DenyAll{` +
		`DenyAll:` + fmt.Sprintf("%#v", this.DenyAll) + `}`}, ", ")
	return s
}
func (this *TemplateType_Simple) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_policy_template.TemplateType_Simple{` +
		`Simple:` + fmt.Sprintf("%#v", this.Simple) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_policy_template.GlobalSpecType{")
	if this.OnStartFlow != nil {
		s = append(s, "OnStartFlow: "+fmt.Sprintf("%#v", this.OnStartFlow)+",\n")
	}
	if this.ContinuousFlow != nil {
		s = append(s, "ContinuousFlow: "+fmt.Sprintf("%#v", this.ContinuousFlow)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_policy_template.CreateSpecType{")
	if this.OnStartFlow != nil {
		s = append(s, "OnStartFlow: "+fmt.Sprintf("%#v", this.OnStartFlow)+",\n")
	}
	if this.ContinuousFlow != nil {
		s = append(s, "ContinuousFlow: "+fmt.Sprintf("%#v", this.ContinuousFlow)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_policy_template.ReplaceSpecType{")
	if this.OnStartFlow != nil {
		s = append(s, "OnStartFlow: "+fmt.Sprintf("%#v", this.OnStartFlow)+",\n")
	}
	if this.ContinuousFlow != nil {
		s = append(s, "ContinuousFlow: "+fmt.Sprintf("%#v", this.ContinuousFlow)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_policy_template.GetSpecType{")
	if this.OnStartFlow != nil {
		s = append(s, "OnStartFlow: "+fmt.Sprintf("%#v", this.OnStartFlow)+",\n")
	}
	if this.ContinuousFlow != nil {
		s = append(s, "ContinuousFlow: "+fmt.Sprintf("%#v", this.ContinuousFlow)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *SAMLFederation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SAMLFederation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SAMLFederation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Saml) > 0 {
		for iNdEx := len(m.Saml) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Saml[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *GeoLocationMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeoLocationMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeoLocationMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Geomatch) > 0 {
		for iNdEx := len(m.Geomatch) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Geomatch[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	return len(dAtA) - i, nil
}

func (m *Flows) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Flows) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flows) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FlowType != nil {
		{
			size := m.FlowType.Size()
			i -= size
			if _, err := m.FlowType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Flows_AllowAll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flows_AllowAll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowAll != nil {
		{
			size, err := m.AllowAll.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Flows_SamlFederation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flows_SamlFederation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SamlFederation != nil {
		{
			size, err := m.SamlFederation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Flows_GeolocationMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flows_GeolocationMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GeolocationMatch != nil {
		{
			size, err := m.GeolocationMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *SimpleTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleTemplate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleTemplate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Flows) > 0 {
		for iNdEx := len(m.Flows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Flows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TemplateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TemplateType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TemplateType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TemplateType != nil {
		{
			size := m.TemplateType.Size()
			i -= size
			if _, err := m.TemplateType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TemplateType_DenyAll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TemplateType_DenyAll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyAll != nil {
		{
			size, err := m.DenyAll.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *TemplateType_Simple) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TemplateType_Simple) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Simple != nil {
		{
			size, err := m.Simple.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContinuousFlow != nil {
		{
			size, err := m.ContinuousFlow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.OnStartFlow != nil {
		{
			size, err := m.OnStartFlow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContinuousFlow != nil {
		{
			size, err := m.ContinuousFlow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.OnStartFlow != nil {
		{
			size, err := m.OnStartFlow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContinuousFlow != nil {
		{
			size, err := m.ContinuousFlow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.OnStartFlow != nil {
		{
			size, err := m.OnStartFlow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContinuousFlow != nil {
		{
			size, err := m.ContinuousFlow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.OnStartFlow != nil {
		{
			size, err := m.OnStartFlow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SAMLFederation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Saml) > 0 {
		for _, e := range m.Saml {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GeoLocationMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Geomatch) > 0 {
		for _, e := range m.Geomatch {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Flows) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlowType != nil {
		n += m.FlowType.Size()
	}
	return n
}

func (m *Flows_AllowAll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowAll != nil {
		l = m.AllowAll.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Flows_SamlFederation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SamlFederation != nil {
		l = m.SamlFederation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Flows_GeolocationMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GeolocationMatch != nil {
		l = m.GeolocationMatch.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SimpleTemplate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Flows) > 0 {
		for _, e := range m.Flows {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *TemplateType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TemplateType != nil {
		n += m.TemplateType.Size()
	}
	return n
}

func (m *TemplateType_DenyAll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyAll != nil {
		l = m.DenyAll.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TemplateType_Simple) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Simple != nil {
		l = m.Simple.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OnStartFlow != nil {
		l = m.OnStartFlow.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ContinuousFlow != nil {
		l = m.ContinuousFlow.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OnStartFlow != nil {
		l = m.OnStartFlow.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ContinuousFlow != nil {
		l = m.ContinuousFlow.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OnStartFlow != nil {
		l = m.OnStartFlow.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ContinuousFlow != nil {
		l = m.ContinuousFlow.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OnStartFlow != nil {
		l = m.OnStartFlow.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ContinuousFlow != nil {
		l = m.ContinuousFlow.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *SAMLFederation) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSaml := "[]*ObjectRefType{"
	for _, f := range this.Saml {
		repeatedStringForSaml += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSaml += "}"
	s := strings.Join([]string{`&SAMLFederation{`,
		`Saml:` + repeatedStringForSaml + `,`,
		`}`,
	}, "")
	return s
}
func (this *GeoLocationMatch) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForGeomatch := "[]*ObjectRefType{"
	for _, f := range this.Geomatch {
		repeatedStringForGeomatch += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForGeomatch += "}"
	s := strings.Join([]string{`&GeoLocationMatch{`,
		`Geomatch:` + repeatedStringForGeomatch + `,`,
		`}`,
	}, "")
	return s
}
func (this *Flows) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Flows{`,
		`FlowType:` + fmt.Sprintf("%v", this.FlowType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Flows_AllowAll) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Flows_AllowAll{`,
		`AllowAll:` + strings.Replace(fmt.Sprintf("%v", this.AllowAll), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Flows_SamlFederation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Flows_SamlFederation{`,
		`SamlFederation:` + strings.Replace(fmt.Sprintf("%v", this.SamlFederation), "SAMLFederation", "SAMLFederation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Flows_GeolocationMatch) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Flows_GeolocationMatch{`,
		`GeolocationMatch:` + strings.Replace(fmt.Sprintf("%v", this.GeolocationMatch), "GeoLocationMatch", "GeoLocationMatch", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleTemplate) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForFlows := "[]*Flows{"
	for _, f := range this.Flows {
		repeatedStringForFlows += strings.Replace(f.String(), "Flows", "Flows", 1) + ","
	}
	repeatedStringForFlows += "}"
	s := strings.Join([]string{`&SimpleTemplate{`,
		`Flows:` + repeatedStringForFlows + `,`,
		`}`,
	}, "")
	return s
}
func (this *TemplateType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TemplateType{`,
		`TemplateType:` + fmt.Sprintf("%v", this.TemplateType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TemplateType_DenyAll) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TemplateType_DenyAll{`,
		`DenyAll:` + strings.Replace(fmt.Sprintf("%v", this.DenyAll), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TemplateType_Simple) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TemplateType_Simple{`,
		`Simple:` + strings.Replace(fmt.Sprintf("%v", this.Simple), "SimpleTemplate", "SimpleTemplate", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`OnStartFlow:` + strings.Replace(this.OnStartFlow.String(), "TemplateType", "TemplateType", 1) + `,`,
		`ContinuousFlow:` + strings.Replace(this.ContinuousFlow.String(), "TemplateType", "TemplateType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`OnStartFlow:` + strings.Replace(this.OnStartFlow.String(), "TemplateType", "TemplateType", 1) + `,`,
		`ContinuousFlow:` + strings.Replace(this.ContinuousFlow.String(), "TemplateType", "TemplateType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`OnStartFlow:` + strings.Replace(this.OnStartFlow.String(), "TemplateType", "TemplateType", 1) + `,`,
		`ContinuousFlow:` + strings.Replace(this.ContinuousFlow.String(), "TemplateType", "TemplateType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`OnStartFlow:` + strings.Replace(this.OnStartFlow.String(), "TemplateType", "TemplateType", 1) + `,`,
		`ContinuousFlow:` + strings.Replace(this.ContinuousFlow.String(), "TemplateType", "TemplateType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *SAMLFederation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SAMLFederation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SAMLFederation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Saml", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Saml = append(m.Saml, &schema.ObjectRefType{})
			if err := m.Saml[len(m.Saml)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeoLocationMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeoLocationMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeoLocationMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Geomatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Geomatch = append(m.Geomatch, &schema.ObjectRefType{})
			if err := m.Geomatch[len(m.Geomatch)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Flows) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flows: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flows: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAll", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FlowType = &Flows_AllowAll{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamlFederation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SAMLFederation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FlowType = &Flows_SamlFederation{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeolocationMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GeoLocationMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FlowType = &Flows_GeolocationMatch{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flows = append(m.Flows, &Flows{})
			if err := m.Flows[len(m.Flows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TemplateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TemplateType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TemplateType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyAll", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TemplateType = &TemplateType_DenyAll{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Simple", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SimpleTemplate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TemplateType = &TemplateType_Simple{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnStartFlow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnStartFlow == nil {
				m.OnStartFlow = &TemplateType{}
			}
			if err := m.OnStartFlow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContinuousFlow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContinuousFlow == nil {
				m.ContinuousFlow = &TemplateType{}
			}
			if err := m.ContinuousFlow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnStartFlow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnStartFlow == nil {
				m.OnStartFlow = &TemplateType{}
			}
			if err := m.OnStartFlow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContinuousFlow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContinuousFlow == nil {
				m.ContinuousFlow = &TemplateType{}
			}
			if err := m.ContinuousFlow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnStartFlow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnStartFlow == nil {
				m.OnStartFlow = &TemplateType{}
			}
			if err := m.OnStartFlow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContinuousFlow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContinuousFlow == nil {
				m.ContinuousFlow = &TemplateType{}
			}
			if err := m.ContinuousFlow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnStartFlow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnStartFlow == nil {
				m.OnStartFlow = &TemplateType{}
			}
			if err := m.OnStartFlow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContinuousFlow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContinuousFlow == nil {
				m.ContinuousFlow = &TemplateType{}
			}
			if err := m.ContinuousFlow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
