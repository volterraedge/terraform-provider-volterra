// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package uztna_flow

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *ApplicationTagging) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ApplicationTagging) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ApplicationTagging) DeepCopy() *ApplicationTagging {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ApplicationTagging{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ApplicationTagging) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ApplicationTagging) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ApplicationTaggingValidator().Validate(ctx, m, opts...)
}

type ValidateApplicationTagging struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateApplicationTagging) SamlAppTagValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for saml_app_tag")
	}

	return validatorFn, nil
}

func (v *ValidateApplicationTagging) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ApplicationTagging)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ApplicationTagging got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["saml_app_tag"]; exists {

		vOpts := append(opts, db.WithValidateField("saml_app_tag"))
		if err := fv(ctx, m.GetSamlAppTag(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultApplicationTaggingValidator = func() *ValidateApplicationTagging {
	v := &ValidateApplicationTagging{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSamlAppTag := v.SamlAppTagValidationRuleHandler
	rulesSamlAppTag := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "1024",
	}
	vFn, err = vrhSamlAppTag(rulesSamlAppTag)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApplicationTagging.saml_app_tag: %s", err)
		panic(errMsg)
	}
	v.FldValidators["saml_app_tag"] = vFn

	return v
}()

func ApplicationTaggingValidator() db.Validator {
	return DefaultApplicationTaggingValidator
}

// augmented methods on protoc/std generated struct

func (m *AudienceUri) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AudienceUri) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AudienceUri) DeepCopy() *AudienceUri {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AudienceUri{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AudienceUri) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AudienceUri) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AudienceUriValidator().Validate(ctx, m, opts...)
}

type ValidateAudienceUri struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAudienceUri) AudienceUriChoiceUniformResourceLocatorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	return UniformResourceLocatorValidator().Validate, nil
}
func (v *ValidateAudienceUri) AudienceUriChoiceUniformResourceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	return UniformResourceNameValidator().Validate, nil
}

func (v *ValidateAudienceUri) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AudienceUri)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AudienceUri got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAudienceUriChoice().(type) {
	case *AudienceUri_UniformResourceLocator:
		if fv, exists := v.FldValidators["audience_uri_choice.uniform_resource_locator"]; exists {
			val := m.GetAudienceUriChoice().(*AudienceUri_UniformResourceLocator).UniformResourceLocator
			vOpts := append(opts,
				db.WithValidateField("audience_uri_choice"),
				db.WithValidateField("uniform_resource_locator"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AudienceUri_UniformResourceName:
		if fv, exists := v.FldValidators["audience_uri_choice.uniform_resource_name"]; exists {
			val := m.GetAudienceUriChoice().(*AudienceUri_UniformResourceName).UniformResourceName
			vOpts := append(opts,
				db.WithValidateField("audience_uri_choice"),
				db.WithValidateField("uniform_resource_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAudienceUriValidator = func() *ValidateAudienceUri {
	v := &ValidateAudienceUri{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAudienceUriChoiceUniformResourceLocator := v.AudienceUriChoiceUniformResourceLocatorValidationRuleHandler
	rulesAudienceUriChoiceUniformResourceLocator := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFnMap["audience_uri_choice.uniform_resource_locator"], err = vrhAudienceUriChoiceUniformResourceLocator(rulesAudienceUriChoiceUniformResourceLocator)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AudienceUri.audience_uri_choice_uniform_resource_locator: %s", err)
		panic(errMsg)
	}
	vrhAudienceUriChoiceUniformResourceName := v.AudienceUriChoiceUniformResourceNameValidationRuleHandler
	rulesAudienceUriChoiceUniformResourceName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFnMap["audience_uri_choice.uniform_resource_name"], err = vrhAudienceUriChoiceUniformResourceName(rulesAudienceUriChoiceUniformResourceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AudienceUri.audience_uri_choice_uniform_resource_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["audience_uri_choice.uniform_resource_locator"] = vFnMap["audience_uri_choice.uniform_resource_locator"]
	v.FldValidators["audience_uri_choice.uniform_resource_name"] = vFnMap["audience_uri_choice.uniform_resource_name"]

	return v
}()

func AudienceUriValidator() db.Validator {
	return DefaultAudienceUriValidator
}

// augmented methods on protoc/std generated struct

func (m *Certificate) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Certificate) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Certificate) DeepCopy() *Certificate {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Certificate{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Certificate) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Certificate) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CertificateValidator().Validate(ctx, m, opts...)
}

func (m *Certificate) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetCertificateDRefInfo()

}

func (m *Certificate) GetCertificateDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetCertificate()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("Certificate.certificate[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "certificate.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "certificate",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetCertificateDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *Certificate) GetCertificateDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "certificate.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: certificate")
	}
	for _, ref := range m.GetCertificate() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateCertificate struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCertificate) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Certificate)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Certificate got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["certificate"]; exists {

		vOpts := append(opts, db.WithValidateField("certificate"))
		for idx, item := range m.GetCertificate() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCertificateValidator = func() *ValidateCertificate {
	v := &ValidateCertificate{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CertificateValidator() db.Validator {
	return DefaultCertificateValidator
}

// augmented methods on protoc/std generated struct

func (m *ProviderMetadata) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ProviderMetadata) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ProviderMetadata) DeepCopy() *ProviderMetadata {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ProviderMetadata{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ProviderMetadata) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ProviderMetadata) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ProviderMetadataValidator().Validate(ctx, m, opts...)
}

type ValidateProviderMetadata struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateProviderMetadata) ServiceProviderMetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_provider_metadata")
	}

	return validatorFn, nil
}

func (v *ValidateProviderMetadata) IdpProviderMetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for idp_provider_metadata")
	}

	return validatorFn, nil
}

func (v *ValidateProviderMetadata) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ProviderMetadata)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ProviderMetadata got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["idp_provider_metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("idp_provider_metadata"))
		if err := fv(ctx, m.GetIdpProviderMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_provider_metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("service_provider_metadata"))
		if err := fv(ctx, m.GetServiceProviderMetadata(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultProviderMetadataValidator = func() *ValidateProviderMetadata {
	v := &ValidateProviderMetadata{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhServiceProviderMetadata := v.ServiceProviderMetadataValidationRuleHandler
	rulesServiceProviderMetadata := map[string]string{
		"ves.io.schema.rules.string.max_len": "1024",
	}
	vFn, err = vrhServiceProviderMetadata(rulesServiceProviderMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProviderMetadata.service_provider_metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_provider_metadata"] = vFn

	vrhIdpProviderMetadata := v.IdpProviderMetadataValidationRuleHandler
	rulesIdpProviderMetadata := map[string]string{
		"ves.io.schema.rules.string.max_len": "1024",
	}
	vFn, err = vrhIdpProviderMetadata(rulesIdpProviderMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProviderMetadata.idp_provider_metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["idp_provider_metadata"] = vFn

	return v
}()

func ProviderMetadataValidator() db.Validator {
	return DefaultProviderMetadataValidator
}

// augmented methods on protoc/std generated struct

func (m *SAMLMessage) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SAMLMessage) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SAMLMessage) DeepCopy() *SAMLMessage {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SAMLMessage{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SAMLMessage) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SAMLMessage) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SAMLMessageValidator().Validate(ctx, m, opts...)
}

func (m *SAMLMessage) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetServiceProviderPropertiesDRefInfo()

}

// GetDRefInfo for the field's type
func (m *SAMLMessage) GetServiceProviderPropertiesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetServiceProviderProperties() == nil {
		return nil, nil
	}

	drInfos, err := m.GetServiceProviderProperties().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetServiceProviderProperties().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "service_provider_properties." + dri.DRField
	}
	return drInfos, err

}

type ValidateSAMLMessage struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSAMLMessage) ServiceProviderPropertiesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for service_provider_properties")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ServiceProviderPropertiesValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSAMLMessage) ProviderMetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for provider_metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ProviderMetadataValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSAMLMessage) ApplicationTagValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for application_tag")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ApplicationTaggingValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSAMLMessage) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SAMLMessage)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SAMLMessage got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["application_tag"]; exists {

		vOpts := append(opts, db.WithValidateField("application_tag"))
		if err := fv(ctx, m.GetApplicationTag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provider_metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("provider_metadata"))
		if err := fv(ctx, m.GetProviderMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_provider_properties"]; exists {

		vOpts := append(opts, db.WithValidateField("service_provider_properties"))
		if err := fv(ctx, m.GetServiceProviderProperties(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSAMLMessageValidator = func() *ValidateSAMLMessage {
	v := &ValidateSAMLMessage{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhServiceProviderProperties := v.ServiceProviderPropertiesValidationRuleHandler
	rulesServiceProviderProperties := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhServiceProviderProperties(rulesServiceProviderProperties)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SAMLMessage.service_provider_properties: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_provider_properties"] = vFn

	vrhProviderMetadata := v.ProviderMetadataValidationRuleHandler
	rulesProviderMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhProviderMetadata(rulesProviderMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SAMLMessage.provider_metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["provider_metadata"] = vFn

	vrhApplicationTag := v.ApplicationTagValidationRuleHandler
	rulesApplicationTag := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhApplicationTag(rulesApplicationTag)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SAMLMessage.application_tag: %s", err)
		panic(errMsg)
	}
	v.FldValidators["application_tag"] = vFn

	return v
}()

func SAMLMessageValidator() db.Validator {
	return DefaultSAMLMessageValidator
}

// augmented methods on protoc/std generated struct

func (m *ServiceProviderProperties) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ServiceProviderProperties) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ServiceProviderProperties) DeepCopy() *ServiceProviderProperties {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ServiceProviderProperties{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ServiceProviderProperties) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ServiceProviderProperties) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ServiceProviderPropertiesValidator().Validate(ctx, m, opts...)
}

func (m *ServiceProviderProperties) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetSignAuthenticationRequestDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSignAuthenticationRequestDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWantEncryptedAssertionDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetWantEncryptedAssertionDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *ServiceProviderProperties) GetSignAuthenticationRequestDRefInfo() ([]db.DRefInfo, error) {
	if m.GetSignAuthenticationRequest() == nil {
		return nil, nil
	}

	drInfos, err := m.GetSignAuthenticationRequest().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetSignAuthenticationRequest().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "sign_authentication_request." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *ServiceProviderProperties) GetWantEncryptedAssertionDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWantEncryptedAssertion() == nil {
		return nil, nil
	}

	drInfos, err := m.GetWantEncryptedAssertion().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetWantEncryptedAssertion().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "want_encrypted_assertion." + dri.DRField
	}
	return drInfos, err

}

type ValidateServiceProviderProperties struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateServiceProviderProperties) AudienceUriValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for audience_uri")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := AudienceUriValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateServiceProviderProperties) RelayStateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for relay_state")
	}

	return validatorFn, nil
}

func (v *ValidateServiceProviderProperties) TypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(AssertionConsumerServiceBinding)
		return int32(i)
	}
	// AssertionConsumerServiceBinding_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, AssertionConsumerServiceBinding_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for type")
	}

	return validatorFn, nil
}

func (v *ValidateServiceProviderProperties) SignAuthenticationRequestValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for sign_authentication_request")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := SignAuthenticationRequestValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateServiceProviderProperties) WantEncryptedAssertionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for want_encrypted_assertion")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := WantEncryptedRequestValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateServiceProviderProperties) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ServiceProviderProperties)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ServiceProviderProperties got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["audience_uri"]; exists {

		vOpts := append(opts, db.WithValidateField("audience_uri"))
		if err := fv(ctx, m.GetAudienceUri(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["force_authentication"]; exists {

		vOpts := append(opts, db.WithValidateField("force_authentication"))
		if err := fv(ctx, m.GetForceAuthentication(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["relay_state"]; exists {

		vOpts := append(opts, db.WithValidateField("relay_state"))
		if err := fv(ctx, m.GetRelayState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sign_authentication_request"]; exists {

		vOpts := append(opts, db.WithValidateField("sign_authentication_request"))
		if err := fv(ctx, m.GetSignAuthenticationRequest(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["want_encrypted_assertion"]; exists {

		vOpts := append(opts, db.WithValidateField("want_encrypted_assertion"))
		if err := fv(ctx, m.GetWantEncryptedAssertion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["want_signed_assertion"]; exists {

		vOpts := append(opts, db.WithValidateField("want_signed_assertion"))
		if err := fv(ctx, m.GetWantSignedAssertion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultServiceProviderPropertiesValidator = func() *ValidateServiceProviderProperties {
	v := &ValidateServiceProviderProperties{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAudienceUri := v.AudienceUriValidationRuleHandler
	rulesAudienceUri := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAudienceUri(rulesAudienceUri)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceProviderProperties.audience_uri: %s", err)
		panic(errMsg)
	}
	v.FldValidators["audience_uri"] = vFn

	vrhRelayState := v.RelayStateValidationRuleHandler
	rulesRelayState := map[string]string{
		"ves.io.schema.rules.string.max_len": "1024",
	}
	vFn, err = vrhRelayState(rulesRelayState)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceProviderProperties.relay_state: %s", err)
		panic(errMsg)
	}
	v.FldValidators["relay_state"] = vFn

	vrhType := v.TypeValidationRuleHandler
	rulesType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhType(rulesType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceProviderProperties.type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["type"] = vFn

	vrhSignAuthenticationRequest := v.SignAuthenticationRequestValidationRuleHandler
	rulesSignAuthenticationRequest := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSignAuthenticationRequest(rulesSignAuthenticationRequest)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceProviderProperties.sign_authentication_request: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sign_authentication_request"] = vFn

	vrhWantEncryptedAssertion := v.WantEncryptedAssertionValidationRuleHandler
	rulesWantEncryptedAssertion := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhWantEncryptedAssertion(rulesWantEncryptedAssertion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceProviderProperties.want_encrypted_assertion: %s", err)
		panic(errMsg)
	}
	v.FldValidators["want_encrypted_assertion"] = vFn

	return v
}()

func ServiceProviderPropertiesValidator() db.Validator {
	return DefaultServiceProviderPropertiesValidator
}

// augmented methods on protoc/std generated struct

func (m *SignAuthenticationRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SignAuthenticationRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SignAuthenticationRequest) DeepCopy() *SignAuthenticationRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SignAuthenticationRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SignAuthenticationRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SignAuthenticationRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SignAuthenticationRequestValidator().Validate(ctx, m, opts...)
}

func (m *SignAuthenticationRequest) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetSignAuthTypeChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *SignAuthenticationRequest) GetSignAuthTypeChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetSignAuthTypeChoice() == nil {
		return nil, nil
	}
	switch m.GetSignAuthTypeChoice().(type) {
	case *SignAuthenticationRequest_NoAuthReq:

		return nil, nil

	case *SignAuthenticationRequest_SignAuth:

		drInfos, err := m.GetSignAuth().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSignAuth().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "sign_auth." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateSignAuthenticationRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSignAuthenticationRequest) SignAuthTypeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for sign_auth_type_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSignAuthenticationRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SignAuthenticationRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SignAuthenticationRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["sign_auth_type_choice"]; exists {
		val := m.GetSignAuthTypeChoice()
		vOpts := append(opts,
			db.WithValidateField("sign_auth_type_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSignAuthTypeChoice().(type) {
	case *SignAuthenticationRequest_NoAuthReq:
		if fv, exists := v.FldValidators["sign_auth_type_choice.no_auth_req"]; exists {
			val := m.GetSignAuthTypeChoice().(*SignAuthenticationRequest_NoAuthReq).NoAuthReq
			vOpts := append(opts,
				db.WithValidateField("sign_auth_type_choice"),
				db.WithValidateField("no_auth_req"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SignAuthenticationRequest_SignAuth:
		if fv, exists := v.FldValidators["sign_auth_type_choice.sign_auth"]; exists {
			val := m.GetSignAuthTypeChoice().(*SignAuthenticationRequest_SignAuth).SignAuth
			vOpts := append(opts,
				db.WithValidateField("sign_auth_type_choice"),
				db.WithValidateField("sign_auth"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSignAuthenticationRequestValidator = func() *ValidateSignAuthenticationRequest {
	v := &ValidateSignAuthenticationRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSignAuthTypeChoice := v.SignAuthTypeChoiceValidationRuleHandler
	rulesSignAuthTypeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSignAuthTypeChoice(rulesSignAuthTypeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SignAuthenticationRequest.sign_auth_type_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sign_auth_type_choice"] = vFn

	return v
}()

func SignAuthenticationRequestValidator() db.Validator {
	return DefaultSignAuthenticationRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *UniformResourceLocator) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UniformResourceLocator) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UniformResourceLocator) DeepCopy() *UniformResourceLocator {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UniformResourceLocator{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UniformResourceLocator) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UniformResourceLocator) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UniformResourceLocatorValidator().Validate(ctx, m, opts...)
}

type ValidateUniformResourceLocator struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUniformResourceLocator) UrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for url")
	}

	return validatorFn, nil
}

func (v *ValidateUniformResourceLocator) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UniformResourceLocator)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UniformResourceLocator got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["url"]; exists {

		vOpts := append(opts, db.WithValidateField("url"))
		if err := fv(ctx, m.GetUrl(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUniformResourceLocatorValidator = func() *ValidateUniformResourceLocator {
	v := &ValidateUniformResourceLocator{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhUrl := v.UrlValidationRuleHandler
	rulesUrl := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "1024",
	}
	vFn, err = vrhUrl(rulesUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UniformResourceLocator.url: %s", err)
		panic(errMsg)
	}
	v.FldValidators["url"] = vFn

	return v
}()

func UniformResourceLocatorValidator() db.Validator {
	return DefaultUniformResourceLocatorValidator
}

// augmented methods on protoc/std generated struct

func (m *UniformResourceName) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UniformResourceName) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UniformResourceName) DeepCopy() *UniformResourceName {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UniformResourceName{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UniformResourceName) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UniformResourceName) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UniformResourceNameValidator().Validate(ctx, m, opts...)
}

type ValidateUniformResourceName struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUniformResourceName) UrnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for urn")
	}

	return validatorFn, nil
}

func (v *ValidateUniformResourceName) HostNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for host_name")
	}

	return validatorFn, nil
}

func (v *ValidateUniformResourceName) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UniformResourceName)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UniformResourceName got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["host_name"]; exists {

		vOpts := append(opts, db.WithValidateField("host_name"))
		if err := fv(ctx, m.GetHostName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["urn"]; exists {

		vOpts := append(opts, db.WithValidateField("urn"))
		if err := fv(ctx, m.GetUrn(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUniformResourceNameValidator = func() *ValidateUniformResourceName {
	v := &ValidateUniformResourceName{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhUrn := v.UrnValidationRuleHandler
	rulesUrn := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "128",
		"ves.io.schema.rules.string.min_len":   "1",
		"ves.io.schema.rules.string.uri_ref":   "true",
	}
	vFn, err = vrhUrn(rulesUrn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UniformResourceName.urn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["urn"] = vFn

	vrhHostName := v.HostNameValidationRuleHandler
	rulesHostName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.hostname":  "true",
		"ves.io.schema.rules.string.max_len":   "1024",
	}
	vFn, err = vrhHostName(rulesHostName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UniformResourceName.host_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["host_name"] = vFn

	return v
}()

func UniformResourceNameValidator() db.Validator {
	return DefaultUniformResourceNameValidator
}

// augmented methods on protoc/std generated struct

func (m *WantEncryptedRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WantEncryptedRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WantEncryptedRequest) DeepCopy() *WantEncryptedRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WantEncryptedRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WantEncryptedRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WantEncryptedRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WantEncryptedRequestValidator().Validate(ctx, m, opts...)
}

func (m *WantEncryptedRequest) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetWantEncryptedRequestDRefInfo()

}

// GetDRefInfo for the field's type
func (m *WantEncryptedRequest) GetWantEncryptedRequestDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWantEncryptedRequest() == nil {
		return nil, nil
	}
	switch m.GetWantEncryptedRequest().(type) {
	case *WantEncryptedRequest_NoEncryptReq:

		return nil, nil

	case *WantEncryptedRequest_EncryptReq:

		drInfos, err := m.GetEncryptReq().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetEncryptReq().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "encrypt_req." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateWantEncryptedRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWantEncryptedRequest) WantEncryptedRequestValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for want_encrypted_request")
	}
	return validatorFn, nil
}

func (v *ValidateWantEncryptedRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WantEncryptedRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WantEncryptedRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["want_encrypted_request"]; exists {
		val := m.GetWantEncryptedRequest()
		vOpts := append(opts,
			db.WithValidateField("want_encrypted_request"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetWantEncryptedRequest().(type) {
	case *WantEncryptedRequest_NoEncryptReq:
		if fv, exists := v.FldValidators["want_encrypted_request.no_encrypt_req"]; exists {
			val := m.GetWantEncryptedRequest().(*WantEncryptedRequest_NoEncryptReq).NoEncryptReq
			vOpts := append(opts,
				db.WithValidateField("want_encrypted_request"),
				db.WithValidateField("no_encrypt_req"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WantEncryptedRequest_EncryptReq:
		if fv, exists := v.FldValidators["want_encrypted_request.encrypt_req"]; exists {
			val := m.GetWantEncryptedRequest().(*WantEncryptedRequest_EncryptReq).EncryptReq
			vOpts := append(opts,
				db.WithValidateField("want_encrypted_request"),
				db.WithValidateField("encrypt_req"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWantEncryptedRequestValidator = func() *ValidateWantEncryptedRequest {
	v := &ValidateWantEncryptedRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhWantEncryptedRequest := v.WantEncryptedRequestValidationRuleHandler
	rulesWantEncryptedRequest := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhWantEncryptedRequest(rulesWantEncryptedRequest)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WantEncryptedRequest.want_encrypted_request: %s", err)
		panic(errMsg)
	}
	v.FldValidators["want_encrypted_request"] = vFn

	return v
}()

func WantEncryptedRequestValidator() db.Validator {
	return DefaultWantEncryptedRequestValidator
}
