// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package uztna_flow

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *ApplicationTagging) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ApplicationTagging) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ApplicationTagging) DeepCopy() *ApplicationTagging {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ApplicationTagging{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ApplicationTagging) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ApplicationTagging) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ApplicationTaggingValidator().Validate(ctx, m, opts...)
}

type ValidateApplicationTagging struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateApplicationTagging) SamlAppTagValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for saml_app_tag")
	}

	return validatorFn, nil
}

func (v *ValidateApplicationTagging) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ApplicationTagging)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ApplicationTagging got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["saml_app_tag"]; exists {

		vOpts := append(opts, db.WithValidateField("saml_app_tag"))
		if err := fv(ctx, m.GetSamlAppTag(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultApplicationTaggingValidator = func() *ValidateApplicationTagging {
	v := &ValidateApplicationTagging{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSamlAppTag := v.SamlAppTagValidationRuleHandler
	rulesSamlAppTag := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "1024",
	}
	vFn, err = vrhSamlAppTag(rulesSamlAppTag)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApplicationTagging.saml_app_tag: %s", err)
		panic(errMsg)
	}
	v.FldValidators["saml_app_tag"] = vFn

	return v
}()

func ApplicationTaggingValidator() db.Validator {
	return DefaultApplicationTaggingValidator
}

// augmented methods on protoc/std generated struct

func (m *AudienceUri) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AudienceUri) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AudienceUri) DeepCopy() *AudienceUri {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AudienceUri{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AudienceUri) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AudienceUri) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AudienceUriValidator().Validate(ctx, m, opts...)
}

type ValidateAudienceUri struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAudienceUri) AudienceUriChoiceUniformResourceLocatorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	return UniformResourceLocatorValidator().Validate, nil
}

func (v *ValidateAudienceUri) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AudienceUri)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AudienceUri got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAudienceUriChoice().(type) {
	case *AudienceUri_UniformResourceLocator:
		if fv, exists := v.FldValidators["audience_uri_choice.uniform_resource_locator"]; exists {
			val := m.GetAudienceUriChoice().(*AudienceUri_UniformResourceLocator).UniformResourceLocator
			vOpts := append(opts,
				db.WithValidateField("audience_uri_choice"),
				db.WithValidateField("uniform_resource_locator"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AudienceUri_UniformResourceName:
		if fv, exists := v.FldValidators["audience_uri_choice.uniform_resource_name"]; exists {
			val := m.GetAudienceUriChoice().(*AudienceUri_UniformResourceName).UniformResourceName
			vOpts := append(opts,
				db.WithValidateField("audience_uri_choice"),
				db.WithValidateField("uniform_resource_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAudienceUriValidator = func() *ValidateAudienceUri {
	v := &ValidateAudienceUri{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAudienceUriChoiceUniformResourceLocator := v.AudienceUriChoiceUniformResourceLocatorValidationRuleHandler
	rulesAudienceUriChoiceUniformResourceLocator := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFnMap["audience_uri_choice.uniform_resource_locator"], err = vrhAudienceUriChoiceUniformResourceLocator(rulesAudienceUriChoiceUniformResourceLocator)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AudienceUri.audience_uri_choice_uniform_resource_locator: %s", err)
		panic(errMsg)
	}

	v.FldValidators["audience_uri_choice.uniform_resource_locator"] = vFnMap["audience_uri_choice.uniform_resource_locator"]

	v.FldValidators["audience_uri_choice.uniform_resource_name"] = UniformResourceNameValidator().Validate

	return v
}()

func AudienceUriValidator() db.Validator {
	return DefaultAudienceUriValidator
}

// augmented methods on protoc/std generated struct

func (m *Certificate) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Certificate) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Certificate) DeepCopy() *Certificate {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Certificate{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Certificate) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Certificate) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CertificateValidator().Validate(ctx, m, opts...)
}

func (m *Certificate) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetCertificateDRefInfo()

}

func (m *Certificate) GetCertificateDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetCertificate()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("Certificate.certificate[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "certificate.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "certificate",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetCertificateDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *Certificate) GetCertificateDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "certificate.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: certificate")
	}
	for _, ref := range m.GetCertificate() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateCertificate struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCertificate) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Certificate)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Certificate got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["certificate"]; exists {

		vOpts := append(opts, db.WithValidateField("certificate"))
		for idx, item := range m.GetCertificate() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCertificateValidator = func() *ValidateCertificate {
	v := &ValidateCertificate{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CertificateValidator() db.Validator {
	return DefaultCertificateValidator
}

// augmented methods on protoc/std generated struct

func (m *IdentityProvider) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IdentityProvider) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IdentityProvider) DeepCopy() *IdentityProvider {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IdentityProvider{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IdentityProvider) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IdentityProvider) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IdentityProviderValidator().Validate(ctx, m, opts...)
}

func (m *IdentityProvider) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetIdpAssertVerificationCertDRefInfo()

}

// GetDRefInfo for the field's type
func (m *IdentityProvider) GetIdpAssertVerificationCertDRefInfo() ([]db.DRefInfo, error) {
	if m.GetIdpAssertVerificationCert() == nil {
		return nil, nil
	}

	drInfos, err := m.GetIdpAssertVerificationCert().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetIdpAssertVerificationCert().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "idp_assert_verification_cert." + dri.DRField
	}
	return drInfos, err

}

type ValidateIdentityProvider struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIdentityProvider) SsoServiceBindingValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for sso_service_binding")
	}
	return validatorFn, nil
}

func (v *ValidateIdentityProvider) IssuerValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for issuer")
	}

	return validatorFn, nil
}

func (v *ValidateIdentityProvider) SsoUrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for sso_url")
	}

	return validatorFn, nil
}

func (v *ValidateIdentityProvider) IdpSecurityPropertyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for idp_security_property")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := IdpSecurityPropertyValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateIdentityProvider) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IdentityProvider)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IdentityProvider got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["idp_assert_verification_cert"]; exists {

		vOpts := append(opts, db.WithValidateField("idp_assert_verification_cert"))
		if err := fv(ctx, m.GetIdpAssertVerificationCert(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["idp_security_property"]; exists {

		vOpts := append(opts, db.WithValidateField("idp_security_property"))
		if err := fv(ctx, m.GetIdpSecurityProperty(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["issuer"]; exists {

		vOpts := append(opts, db.WithValidateField("issuer"))
		if err := fv(ctx, m.GetIssuer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sso_service_binding"]; exists {
		val := m.GetSsoServiceBinding()
		vOpts := append(opts,
			db.WithValidateField("sso_service_binding"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSsoServiceBinding().(type) {
	case *IdentityProvider_Post:
		if fv, exists := v.FldValidators["sso_service_binding.post"]; exists {
			val := m.GetSsoServiceBinding().(*IdentityProvider_Post).Post
			vOpts := append(opts,
				db.WithValidateField("sso_service_binding"),
				db.WithValidateField("post"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *IdentityProvider_Redirect:
		if fv, exists := v.FldValidators["sso_service_binding.redirect"]; exists {
			val := m.GetSsoServiceBinding().(*IdentityProvider_Redirect).Redirect
			vOpts := append(opts,
				db.WithValidateField("sso_service_binding"),
				db.WithValidateField("redirect"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["sso_url"]; exists {

		vOpts := append(opts, db.WithValidateField("sso_url"))
		if err := fv(ctx, m.GetSsoUrl(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIdentityProviderValidator = func() *ValidateIdentityProvider {
	v := &ValidateIdentityProvider{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSsoServiceBinding := v.SsoServiceBindingValidationRuleHandler
	rulesSsoServiceBinding := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSsoServiceBinding(rulesSsoServiceBinding)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IdentityProvider.sso_service_binding: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sso_service_binding"] = vFn

	vrhIssuer := v.IssuerValidationRuleHandler
	rulesIssuer := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "2048",
		"ves.io.schema.rules.string.uri":       "true",
	}
	vFn, err = vrhIssuer(rulesIssuer)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IdentityProvider.issuer: %s", err)
		panic(errMsg)
	}
	v.FldValidators["issuer"] = vFn

	vrhSsoUrl := v.SsoUrlValidationRuleHandler
	rulesSsoUrl := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "1024",
		"ves.io.schema.rules.string.uri_ref":   "true",
	}
	vFn, err = vrhSsoUrl(rulesSsoUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IdentityProvider.sso_url: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sso_url"] = vFn

	vrhIdpSecurityProperty := v.IdpSecurityPropertyValidationRuleHandler
	rulesIdpSecurityProperty := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhIdpSecurityProperty(rulesIdpSecurityProperty)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IdentityProvider.idp_security_property: %s", err)
		panic(errMsg)
	}
	v.FldValidators["idp_security_property"] = vFn

	return v
}()

func IdentityProviderValidator() db.Validator {
	return DefaultIdentityProviderValidator
}

// augmented methods on protoc/std generated struct

func (m *IdpSecurityProperty) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IdpSecurityProperty) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IdpSecurityProperty) DeepCopy() *IdpSecurityProperty {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IdpSecurityProperty{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IdpSecurityProperty) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IdpSecurityProperty) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IdpSecurityPropertyValidator().Validate(ctx, m, opts...)
}

type ValidateIdpSecurityProperty struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIdpSecurityProperty) AuthRequestSignedValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for auth_request_signed")
	}
	return validatorFn, nil
}

func (v *ValidateIdpSecurityProperty) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IdpSecurityProperty)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IdpSecurityProperty got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["auth_request_signed"]; exists {
		val := m.GetAuthRequestSigned()
		vOpts := append(opts,
			db.WithValidateField("auth_request_signed"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAuthRequestSigned().(type) {
	case *IdpSecurityProperty_No:
		if fv, exists := v.FldValidators["auth_request_signed.no"]; exists {
			val := m.GetAuthRequestSigned().(*IdpSecurityProperty_No).No
			vOpts := append(opts,
				db.WithValidateField("auth_request_signed"),
				db.WithValidateField("no"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *IdpSecurityProperty_Yes:
		if fv, exists := v.FldValidators["auth_request_signed.yes"]; exists {
			val := m.GetAuthRequestSigned().(*IdpSecurityProperty_Yes).Yes
			vOpts := append(opts,
				db.WithValidateField("auth_request_signed"),
				db.WithValidateField("yes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIdpSecurityPropertyValidator = func() *ValidateIdpSecurityProperty {
	v := &ValidateIdpSecurityProperty{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAuthRequestSigned := v.AuthRequestSignedValidationRuleHandler
	rulesAuthRequestSigned := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAuthRequestSigned(rulesAuthRequestSigned)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IdpSecurityProperty.auth_request_signed: %s", err)
		panic(errMsg)
	}
	v.FldValidators["auth_request_signed"] = vFn

	v.FldValidators["auth_request_signed.yes"] = SignAlgorithmValidator().Validate

	return v
}()

func IdpSecurityPropertyValidator() db.Validator {
	return DefaultIdpSecurityPropertyValidator
}

// augmented methods on protoc/std generated struct

func (m *SAMLMessage) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SAMLMessage) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SAMLMessage) DeepCopy() *SAMLMessage {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SAMLMessage{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SAMLMessage) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SAMLMessage) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SAMLMessageValidator().Validate(ctx, m, opts...)
}

func (m *SAMLMessage) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetIdpDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetIdpDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetServiceProviderPropertiesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetServiceProviderPropertiesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *SAMLMessage) GetIdpDRefInfo() ([]db.DRefInfo, error) {
	if m.GetIdp() == nil {
		return nil, nil
	}

	drInfos, err := m.GetIdp().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetIdp().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "idp." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *SAMLMessage) GetServiceProviderPropertiesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetServiceProviderProperties() == nil {
		return nil, nil
	}

	drInfos, err := m.GetServiceProviderProperties().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetServiceProviderProperties().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "service_provider_properties." + dri.DRField
	}
	return drInfos, err

}

type ValidateSAMLMessage struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSAMLMessage) ServiceProviderPropertiesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for service_provider_properties")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ServiceProviderPropertiesValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSAMLMessage) ApplicationTagValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for application_tag")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ApplicationTaggingValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSAMLMessage) IdpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for idp")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := IdentityProviderValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSAMLMessage) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SAMLMessage)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SAMLMessage got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["application_tag"]; exists {

		vOpts := append(opts, db.WithValidateField("application_tag"))
		if err := fv(ctx, m.GetApplicationTag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["idp"]; exists {

		vOpts := append(opts, db.WithValidateField("idp"))
		if err := fv(ctx, m.GetIdp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_provider_properties"]; exists {

		vOpts := append(opts, db.WithValidateField("service_provider_properties"))
		if err := fv(ctx, m.GetServiceProviderProperties(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSAMLMessageValidator = func() *ValidateSAMLMessage {
	v := &ValidateSAMLMessage{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhServiceProviderProperties := v.ServiceProviderPropertiesValidationRuleHandler
	rulesServiceProviderProperties := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhServiceProviderProperties(rulesServiceProviderProperties)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SAMLMessage.service_provider_properties: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_provider_properties"] = vFn

	vrhApplicationTag := v.ApplicationTagValidationRuleHandler
	rulesApplicationTag := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhApplicationTag(rulesApplicationTag)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SAMLMessage.application_tag: %s", err)
		panic(errMsg)
	}
	v.FldValidators["application_tag"] = vFn

	vrhIdp := v.IdpValidationRuleHandler
	rulesIdp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhIdp(rulesIdp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SAMLMessage.idp: %s", err)
		panic(errMsg)
	}
	v.FldValidators["idp"] = vFn

	return v
}()

func SAMLMessageValidator() db.Validator {
	return DefaultSAMLMessageValidator
}

// augmented methods on protoc/std generated struct

func (m *ServiceProviderProperties) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ServiceProviderProperties) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ServiceProviderProperties) DeepCopy() *ServiceProviderProperties {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ServiceProviderProperties{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ServiceProviderProperties) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ServiceProviderProperties) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ServiceProviderPropertiesValidator().Validate(ctx, m, opts...)
}

func (m *ServiceProviderProperties) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetSignAuthenticationRequestDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSignAuthenticationRequestDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWantEncryptedAssertionDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetWantEncryptedAssertionDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *ServiceProviderProperties) GetSignAuthenticationRequestDRefInfo() ([]db.DRefInfo, error) {
	if m.GetSignAuthenticationRequest() == nil {
		return nil, nil
	}

	drInfos, err := m.GetSignAuthenticationRequest().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetSignAuthenticationRequest().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "sign_authentication_request." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *ServiceProviderProperties) GetWantEncryptedAssertionDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWantEncryptedAssertion() == nil {
		return nil, nil
	}

	drInfos, err := m.GetWantEncryptedAssertion().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetWantEncryptedAssertion().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "want_encrypted_assertion." + dri.DRField
	}
	return drInfos, err

}

type ValidateServiceProviderProperties struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateServiceProviderProperties) AudienceUriValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for audience_uri")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := AudienceUriValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateServiceProviderProperties) RelayStateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for relay_state")
	}

	return validatorFn, nil
}

func (v *ValidateServiceProviderProperties) TypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(AssertionConsumerServiceBinding)
		return int32(i)
	}
	// AssertionConsumerServiceBinding_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, AssertionConsumerServiceBinding_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for type")
	}

	return validatorFn, nil
}

func (v *ValidateServiceProviderProperties) SignAuthenticationRequestValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for sign_authentication_request")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := SignAuthenticationRequestValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateServiceProviderProperties) WantEncryptedAssertionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for want_encrypted_assertion")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := WantEncryptedRequestValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateServiceProviderProperties) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ServiceProviderProperties)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ServiceProviderProperties got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["audience_uri"]; exists {

		vOpts := append(opts, db.WithValidateField("audience_uri"))
		if err := fv(ctx, m.GetAudienceUri(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["force_authentication"]; exists {

		vOpts := append(opts, db.WithValidateField("force_authentication"))
		if err := fv(ctx, m.GetForceAuthentication(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["relay_state"]; exists {

		vOpts := append(opts, db.WithValidateField("relay_state"))
		if err := fv(ctx, m.GetRelayState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sign_authentication_request"]; exists {

		vOpts := append(opts, db.WithValidateField("sign_authentication_request"))
		if err := fv(ctx, m.GetSignAuthenticationRequest(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["want_encrypted_assertion"]; exists {

		vOpts := append(opts, db.WithValidateField("want_encrypted_assertion"))
		if err := fv(ctx, m.GetWantEncryptedAssertion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["want_signed_assertion"]; exists {

		vOpts := append(opts, db.WithValidateField("want_signed_assertion"))
		if err := fv(ctx, m.GetWantSignedAssertion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultServiceProviderPropertiesValidator = func() *ValidateServiceProviderProperties {
	v := &ValidateServiceProviderProperties{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAudienceUri := v.AudienceUriValidationRuleHandler
	rulesAudienceUri := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAudienceUri(rulesAudienceUri)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceProviderProperties.audience_uri: %s", err)
		panic(errMsg)
	}
	v.FldValidators["audience_uri"] = vFn

	vrhRelayState := v.RelayStateValidationRuleHandler
	rulesRelayState := map[string]string{
		"ves.io.schema.rules.string.max_len": "1024",
	}
	vFn, err = vrhRelayState(rulesRelayState)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceProviderProperties.relay_state: %s", err)
		panic(errMsg)
	}
	v.FldValidators["relay_state"] = vFn

	vrhType := v.TypeValidationRuleHandler
	rulesType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhType(rulesType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceProviderProperties.type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["type"] = vFn

	vrhSignAuthenticationRequest := v.SignAuthenticationRequestValidationRuleHandler
	rulesSignAuthenticationRequest := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSignAuthenticationRequest(rulesSignAuthenticationRequest)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceProviderProperties.sign_authentication_request: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sign_authentication_request"] = vFn

	vrhWantEncryptedAssertion := v.WantEncryptedAssertionValidationRuleHandler
	rulesWantEncryptedAssertion := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhWantEncryptedAssertion(rulesWantEncryptedAssertion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceProviderProperties.want_encrypted_assertion: %s", err)
		panic(errMsg)
	}
	v.FldValidators["want_encrypted_assertion"] = vFn

	return v
}()

func ServiceProviderPropertiesValidator() db.Validator {
	return DefaultServiceProviderPropertiesValidator
}

// augmented methods on protoc/std generated struct

func (m *SignAlgorithm) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SignAlgorithm) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SignAlgorithm) DeepCopy() *SignAlgorithm {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SignAlgorithm{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SignAlgorithm) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SignAlgorithm) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SignAlgorithmValidator().Validate(ctx, m, opts...)
}

type ValidateSignAlgorithm struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSignAlgorithm) SignAlgoValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for sign_algo")
	}
	return validatorFn, nil
}

func (v *ValidateSignAlgorithm) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SignAlgorithm)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SignAlgorithm got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["sign_algo"]; exists {
		val := m.GetSignAlgo()
		vOpts := append(opts,
			db.WithValidateField("sign_algo"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSignAlgo().(type) {
	case *SignAlgorithm_RsaSha1:
		if fv, exists := v.FldValidators["sign_algo.rsa_sha1"]; exists {
			val := m.GetSignAlgo().(*SignAlgorithm_RsaSha1).RsaSha1
			vOpts := append(opts,
				db.WithValidateField("sign_algo"),
				db.WithValidateField("rsa_sha1"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SignAlgorithm_RsaSha256:
		if fv, exists := v.FldValidators["sign_algo.rsa_sha256"]; exists {
			val := m.GetSignAlgo().(*SignAlgorithm_RsaSha256).RsaSha256
			vOpts := append(opts,
				db.WithValidateField("sign_algo"),
				db.WithValidateField("rsa_sha256"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SignAlgorithm_RsaSha384:
		if fv, exists := v.FldValidators["sign_algo.rsa_sha384"]; exists {
			val := m.GetSignAlgo().(*SignAlgorithm_RsaSha384).RsaSha384
			vOpts := append(opts,
				db.WithValidateField("sign_algo"),
				db.WithValidateField("rsa_sha384"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SignAlgorithm_RsaSha512:
		if fv, exists := v.FldValidators["sign_algo.rsa_sha512"]; exists {
			val := m.GetSignAlgo().(*SignAlgorithm_RsaSha512).RsaSha512
			vOpts := append(opts,
				db.WithValidateField("sign_algo"),
				db.WithValidateField("rsa_sha512"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSignAlgorithmValidator = func() *ValidateSignAlgorithm {
	v := &ValidateSignAlgorithm{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSignAlgo := v.SignAlgoValidationRuleHandler
	rulesSignAlgo := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSignAlgo(rulesSignAlgo)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SignAlgorithm.sign_algo: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sign_algo"] = vFn

	return v
}()

func SignAlgorithmValidator() db.Validator {
	return DefaultSignAlgorithmValidator
}

// augmented methods on protoc/std generated struct

func (m *SignAuthenticationRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SignAuthenticationRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SignAuthenticationRequest) DeepCopy() *SignAuthenticationRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SignAuthenticationRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SignAuthenticationRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SignAuthenticationRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SignAuthenticationRequestValidator().Validate(ctx, m, opts...)
}

func (m *SignAuthenticationRequest) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetSignAuthTypeChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *SignAuthenticationRequest) GetSignAuthTypeChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetSignAuthTypeChoice() == nil {
		return nil, nil
	}
	switch m.GetSignAuthTypeChoice().(type) {
	case *SignAuthenticationRequest_NoAuthReq:

		return nil, nil

	case *SignAuthenticationRequest_SignAuth:

		drInfos, err := m.GetSignAuth().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSignAuth().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "sign_auth." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateSignAuthenticationRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSignAuthenticationRequest) SignAuthTypeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for sign_auth_type_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSignAuthenticationRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SignAuthenticationRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SignAuthenticationRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["sign_auth_type_choice"]; exists {
		val := m.GetSignAuthTypeChoice()
		vOpts := append(opts,
			db.WithValidateField("sign_auth_type_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSignAuthTypeChoice().(type) {
	case *SignAuthenticationRequest_NoAuthReq:
		if fv, exists := v.FldValidators["sign_auth_type_choice.no_auth_req"]; exists {
			val := m.GetSignAuthTypeChoice().(*SignAuthenticationRequest_NoAuthReq).NoAuthReq
			vOpts := append(opts,
				db.WithValidateField("sign_auth_type_choice"),
				db.WithValidateField("no_auth_req"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SignAuthenticationRequest_SignAuth:
		if fv, exists := v.FldValidators["sign_auth_type_choice.sign_auth"]; exists {
			val := m.GetSignAuthTypeChoice().(*SignAuthenticationRequest_SignAuth).SignAuth
			vOpts := append(opts,
				db.WithValidateField("sign_auth_type_choice"),
				db.WithValidateField("sign_auth"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSignAuthenticationRequestValidator = func() *ValidateSignAuthenticationRequest {
	v := &ValidateSignAuthenticationRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSignAuthTypeChoice := v.SignAuthTypeChoiceValidationRuleHandler
	rulesSignAuthTypeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSignAuthTypeChoice(rulesSignAuthTypeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SignAuthenticationRequest.sign_auth_type_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sign_auth_type_choice"] = vFn

	return v
}()

func SignAuthenticationRequestValidator() db.Validator {
	return DefaultSignAuthenticationRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *UniformResourceLocator) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UniformResourceLocator) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UniformResourceLocator) DeepCopy() *UniformResourceLocator {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UniformResourceLocator{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UniformResourceLocator) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UniformResourceLocator) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UniformResourceLocatorValidator().Validate(ctx, m, opts...)
}

type ValidateUniformResourceLocator struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUniformResourceLocator) UrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for url")
	}

	return validatorFn, nil
}

func (v *ValidateUniformResourceLocator) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UniformResourceLocator)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UniformResourceLocator got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["url"]; exists {

		vOpts := append(opts, db.WithValidateField("url"))
		if err := fv(ctx, m.GetUrl(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUniformResourceLocatorValidator = func() *ValidateUniformResourceLocator {
	v := &ValidateUniformResourceLocator{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhUrl := v.UrlValidationRuleHandler
	rulesUrl := map[string]string{
		"ves.io.schema.rules.message.required":      "true",
		"ves.io.schema.rules.string.max_bytes":      "1024",
		"ves.io.schema.rules.string.url_or_uri_ref": "true",
	}
	vFn, err = vrhUrl(rulesUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UniformResourceLocator.url: %s", err)
		panic(errMsg)
	}
	v.FldValidators["url"] = vFn

	return v
}()

func UniformResourceLocatorValidator() db.Validator {
	return DefaultUniformResourceLocatorValidator
}

// augmented methods on protoc/std generated struct

func (m *UniformResourceName) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UniformResourceName) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UniformResourceName) DeepCopy() *UniformResourceName {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UniformResourceName{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UniformResourceName) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UniformResourceName) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UniformResourceNameValidator().Validate(ctx, m, opts...)
}

type ValidateUniformResourceName struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUniformResourceName) UrnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for urn")
	}

	return validatorFn, nil
}

func (v *ValidateUniformResourceName) HostNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for host_name")
	}

	return validatorFn, nil
}

func (v *ValidateUniformResourceName) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UniformResourceName)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UniformResourceName got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["host_name"]; exists {

		vOpts := append(opts, db.WithValidateField("host_name"))
		if err := fv(ctx, m.GetHostName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["urn"]; exists {

		vOpts := append(opts, db.WithValidateField("urn"))
		if err := fv(ctx, m.GetUrn(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUniformResourceNameValidator = func() *ValidateUniformResourceName {
	v := &ValidateUniformResourceName{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhUrn := v.UrnValidationRuleHandler
	rulesUrn := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "128",
		"ves.io.schema.rules.string.min_len":   "1",
		"ves.io.schema.rules.string.uri_ref":   "true",
	}
	vFn, err = vrhUrn(rulesUrn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UniformResourceName.urn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["urn"] = vFn

	vrhHostName := v.HostNameValidationRuleHandler
	rulesHostName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.hostname":  "true",
		"ves.io.schema.rules.string.max_len":   "1024",
	}
	vFn, err = vrhHostName(rulesHostName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UniformResourceName.host_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["host_name"] = vFn

	return v
}()

func UniformResourceNameValidator() db.Validator {
	return DefaultUniformResourceNameValidator
}

// augmented methods on protoc/std generated struct

func (m *WantEncryptedRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WantEncryptedRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WantEncryptedRequest) DeepCopy() *WantEncryptedRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WantEncryptedRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WantEncryptedRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WantEncryptedRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WantEncryptedRequestValidator().Validate(ctx, m, opts...)
}

func (m *WantEncryptedRequest) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetWantEncryptedRequestDRefInfo()

}

// GetDRefInfo for the field's type
func (m *WantEncryptedRequest) GetWantEncryptedRequestDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWantEncryptedRequest() == nil {
		return nil, nil
	}
	switch m.GetWantEncryptedRequest().(type) {
	case *WantEncryptedRequest_NoEncryptReq:

		return nil, nil

	case *WantEncryptedRequest_EncryptReq:

		drInfos, err := m.GetEncryptReq().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetEncryptReq().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "encrypt_req." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateWantEncryptedRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWantEncryptedRequest) WantEncryptedRequestValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for want_encrypted_request")
	}
	return validatorFn, nil
}

func (v *ValidateWantEncryptedRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WantEncryptedRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WantEncryptedRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["want_encrypted_request"]; exists {
		val := m.GetWantEncryptedRequest()
		vOpts := append(opts,
			db.WithValidateField("want_encrypted_request"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetWantEncryptedRequest().(type) {
	case *WantEncryptedRequest_NoEncryptReq:
		if fv, exists := v.FldValidators["want_encrypted_request.no_encrypt_req"]; exists {
			val := m.GetWantEncryptedRequest().(*WantEncryptedRequest_NoEncryptReq).NoEncryptReq
			vOpts := append(opts,
				db.WithValidateField("want_encrypted_request"),
				db.WithValidateField("no_encrypt_req"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WantEncryptedRequest_EncryptReq:
		if fv, exists := v.FldValidators["want_encrypted_request.encrypt_req"]; exists {
			val := m.GetWantEncryptedRequest().(*WantEncryptedRequest_EncryptReq).EncryptReq
			vOpts := append(opts,
				db.WithValidateField("want_encrypted_request"),
				db.WithValidateField("encrypt_req"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWantEncryptedRequestValidator = func() *ValidateWantEncryptedRequest {
	v := &ValidateWantEncryptedRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhWantEncryptedRequest := v.WantEncryptedRequestValidationRuleHandler
	rulesWantEncryptedRequest := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhWantEncryptedRequest(rulesWantEncryptedRequest)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WantEncryptedRequest.want_encrypted_request: %s", err)
		panic(errMsg)
	}
	v.FldValidators["want_encrypted_request"] = vFn

	return v
}()

func WantEncryptedRequestValidator() db.Validator {
	return DefaultWantEncryptedRequestValidator
}
