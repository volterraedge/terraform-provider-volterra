// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/uztna/uztna_flow/saml.proto

package uztna_flow

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/api_group_element"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Assertion Consumer Service Binding
//
// x-displayName: "Assertion Consumer Service Binding"
// Binding  message
type AssertionConsumerServiceBinding int32

const (
	// x-displayName: " Post"
	POST AssertionConsumerServiceBinding = 0
	// x-displayName: " Redirect"
	REDIRECT AssertionConsumerServiceBinding = 1
)

var AssertionConsumerServiceBinding_name = map[int32]string{
	0: "POST",
	1: "REDIRECT",
}

var AssertionConsumerServiceBinding_value = map[string]int32{
	"POST":     0,
	"REDIRECT": 1,
}

func (AssertionConsumerServiceBinding) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{0}
}

// TLS Certificate
//
// x-displayName: "Certificate"
// This is used to import or create new certificate for tls communication
type Certificate struct {
	// TLS Certificates
	//
	// x-displayName: "TLS Certificates"
	// Select/Add one or more TLS Certificate objects to associate with this uztna flow
	Certificate []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=certificate,proto3" json:"certificate,omitempty"`
}

func (m *Certificate) Reset()      { *m = Certificate{} }
func (*Certificate) ProtoMessage() {}
func (*Certificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{0}
}
func (m *Certificate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Certificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Certificate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Certificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Certificate.Merge(m, src)
}
func (m *Certificate) XXX_Size() int {
	return m.Size()
}
func (m *Certificate) XXX_DiscardUnknown() {
	xxx_messageInfo_Certificate.DiscardUnknown(m)
}

var xxx_messageInfo_Certificate proto.InternalMessageInfo

func (m *Certificate) GetCertificate() []*schema.ObjectRefType {
	if m != nil {
		return m.Certificate
	}
	return nil
}

// Uniform Resource Name
//
// x-displayName: "Uniform Resource Name"
// Uniform Resource Name to identify the Uniform resource locator
type UniformResourceName struct {
	// Uniform Resource Name
	//
	// x-displayName: "URN"
	// x-required
	// Name of Uniform resource
	Urn string `protobuf:"bytes,1,opt,name=urn,proto3" json:"urn,omitempty"`
	// Host Name
	//
	// x-displayName: "Host Name"
	// x-required
	// Host name of Uniform resource
	HostName string `protobuf:"bytes,2,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
}

func (m *UniformResourceName) Reset()      { *m = UniformResourceName{} }
func (*UniformResourceName) ProtoMessage() {}
func (*UniformResourceName) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{1}
}
func (m *UniformResourceName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UniformResourceName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UniformResourceName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UniformResourceName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UniformResourceName.Merge(m, src)
}
func (m *UniformResourceName) XXX_Size() int {
	return m.Size()
}
func (m *UniformResourceName) XXX_DiscardUnknown() {
	xxx_messageInfo_UniformResourceName.DiscardUnknown(m)
}

var xxx_messageInfo_UniformResourceName proto.InternalMessageInfo

func (m *UniformResourceName) GetUrn() string {
	if m != nil {
		return m.Urn
	}
	return ""
}

func (m *UniformResourceName) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

// Uniform Resource Locator
//
// x-displayName: "Uniform Resource Locator"
type UniformResourceLocator struct {
	// Uniform Resource Name
	//
	// x-displayName: "URL"
	// x-example: https://sp.example.com
	// x-required
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *UniformResourceLocator) Reset()      { *m = UniformResourceLocator{} }
func (*UniformResourceLocator) ProtoMessage() {}
func (*UniformResourceLocator) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{2}
}
func (m *UniformResourceLocator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UniformResourceLocator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UniformResourceLocator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UniformResourceLocator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UniformResourceLocator.Merge(m, src)
}
func (m *UniformResourceLocator) XXX_Size() int {
	return m.Size()
}
func (m *UniformResourceLocator) XXX_DiscardUnknown() {
	xxx_messageInfo_UniformResourceLocator.DiscardUnknown(m)
}

var xxx_messageInfo_UniformResourceLocator proto.InternalMessageInfo

func (m *UniformResourceLocator) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// Audience URI
//
// x-displayName: "Audience URI"
// Audience URI
// Select Audience URI
type AudienceUri struct {
	// Uniform Resource Locator
	//
	// x-displayName: " "
	//
	// Types that are valid to be assigned to AudienceUriChoice:
	//	*AudienceUri_UniformResourceLocator
	//	*AudienceUri_UniformResourceName
	AudienceUriChoice isAudienceUri_AudienceUriChoice `protobuf_oneof:"audience_uri_choice"`
}

func (m *AudienceUri) Reset()      { *m = AudienceUri{} }
func (*AudienceUri) ProtoMessage() {}
func (*AudienceUri) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{3}
}
func (m *AudienceUri) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AudienceUri) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AudienceUri.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AudienceUri) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AudienceUri.Merge(m, src)
}
func (m *AudienceUri) XXX_Size() int {
	return m.Size()
}
func (m *AudienceUri) XXX_DiscardUnknown() {
	xxx_messageInfo_AudienceUri.DiscardUnknown(m)
}

var xxx_messageInfo_AudienceUri proto.InternalMessageInfo

type isAudienceUri_AudienceUriChoice interface {
	isAudienceUri_AudienceUriChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AudienceUri_UniformResourceLocator struct {
	UniformResourceLocator *UniformResourceLocator `protobuf:"bytes,1,opt,name=uniform_resource_locator,json=uniformResourceLocator,proto3,oneof" json:"uniform_resource_locator,omitempty"`
}
type AudienceUri_UniformResourceName struct {
	UniformResourceName *UniformResourceName `protobuf:"bytes,2,opt,name=uniform_resource_name,json=uniformResourceName,proto3,oneof" json:"uniform_resource_name,omitempty"`
}

func (*AudienceUri_UniformResourceLocator) isAudienceUri_AudienceUriChoice() {}
func (*AudienceUri_UniformResourceName) isAudienceUri_AudienceUriChoice()    {}

func (m *AudienceUri) GetAudienceUriChoice() isAudienceUri_AudienceUriChoice {
	if m != nil {
		return m.AudienceUriChoice
	}
	return nil
}

func (m *AudienceUri) GetUniformResourceLocator() *UniformResourceLocator {
	if x, ok := m.GetAudienceUriChoice().(*AudienceUri_UniformResourceLocator); ok {
		return x.UniformResourceLocator
	}
	return nil
}

func (m *AudienceUri) GetUniformResourceName() *UniformResourceName {
	if x, ok := m.GetAudienceUriChoice().(*AudienceUri_UniformResourceName); ok {
		return x.UniformResourceName
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AudienceUri) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AudienceUri_UniformResourceLocator)(nil),
		(*AudienceUri_UniformResourceName)(nil),
	}
}

// Sign_Authentication_Request
//
// x-displayName: "Sign_Authentication_Request"
// Sign_Authentication_Request
// x-required
type SignAuthenticationRequest struct {
	// Sign_Authentication_Request
	//
	// x-displayName: "Sign Authentication Request"
	// x-required
	// When Response Cache is enabled, clients will receive persistent answers
	//
	// Types that are valid to be assigned to SignAuthTypeChoice:
	//	*SignAuthenticationRequest_NoAuthReq
	//	*SignAuthenticationRequest_SignAuth
	SignAuthTypeChoice isSignAuthenticationRequest_SignAuthTypeChoice `protobuf_oneof:"sign_auth_type_choice"`
}

func (m *SignAuthenticationRequest) Reset()      { *m = SignAuthenticationRequest{} }
func (*SignAuthenticationRequest) ProtoMessage() {}
func (*SignAuthenticationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{4}
}
func (m *SignAuthenticationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignAuthenticationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignAuthenticationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignAuthenticationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignAuthenticationRequest.Merge(m, src)
}
func (m *SignAuthenticationRequest) XXX_Size() int {
	return m.Size()
}
func (m *SignAuthenticationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SignAuthenticationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SignAuthenticationRequest proto.InternalMessageInfo

type isSignAuthenticationRequest_SignAuthTypeChoice interface {
	isSignAuthenticationRequest_SignAuthTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SignAuthenticationRequest_NoAuthReq struct {
	NoAuthReq *schema.Empty `protobuf:"bytes,2,opt,name=no_auth_req,json=noAuthReq,proto3,oneof" json:"no_auth_req,omitempty"`
}
type SignAuthenticationRequest_SignAuth struct {
	SignAuth *Certificate `protobuf:"bytes,3,opt,name=sign_auth,json=signAuth,proto3,oneof" json:"sign_auth,omitempty"`
}

func (*SignAuthenticationRequest_NoAuthReq) isSignAuthenticationRequest_SignAuthTypeChoice() {}
func (*SignAuthenticationRequest_SignAuth) isSignAuthenticationRequest_SignAuthTypeChoice()  {}

func (m *SignAuthenticationRequest) GetSignAuthTypeChoice() isSignAuthenticationRequest_SignAuthTypeChoice {
	if m != nil {
		return m.SignAuthTypeChoice
	}
	return nil
}

func (m *SignAuthenticationRequest) GetNoAuthReq() *schema.Empty {
	if x, ok := m.GetSignAuthTypeChoice().(*SignAuthenticationRequest_NoAuthReq); ok {
		return x.NoAuthReq
	}
	return nil
}

func (m *SignAuthenticationRequest) GetSignAuth() *Certificate {
	if x, ok := m.GetSignAuthTypeChoice().(*SignAuthenticationRequest_SignAuth); ok {
		return x.SignAuth
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SignAuthenticationRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SignAuthenticationRequest_NoAuthReq)(nil),
		(*SignAuthenticationRequest_SignAuth)(nil),
	}
}

// Want Encrypted Request
//
// x-displayName: "Want Encrypted Request"
// WantEncryptedRequest
// x-required
type WantEncryptedRequest struct {
	// Want Encrypted Request
	//
	// x-displayName: "Want Encrypted Request"
	// x-required
	// When Response Cache is enabled, clients will receive persistent answers
	//
	// Types that are valid to be assigned to WantEncryptedRequest:
	//	*WantEncryptedRequest_NoEncryptReq
	//	*WantEncryptedRequest_EncryptReq
	WantEncryptedRequest isWantEncryptedRequest_WantEncryptedRequest `protobuf_oneof:"want_encrypted_request"`
}

func (m *WantEncryptedRequest) Reset()      { *m = WantEncryptedRequest{} }
func (*WantEncryptedRequest) ProtoMessage() {}
func (*WantEncryptedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{5}
}
func (m *WantEncryptedRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WantEncryptedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WantEncryptedRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WantEncryptedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WantEncryptedRequest.Merge(m, src)
}
func (m *WantEncryptedRequest) XXX_Size() int {
	return m.Size()
}
func (m *WantEncryptedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WantEncryptedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WantEncryptedRequest proto.InternalMessageInfo

type isWantEncryptedRequest_WantEncryptedRequest interface {
	isWantEncryptedRequest_WantEncryptedRequest()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type WantEncryptedRequest_NoEncryptReq struct {
	NoEncryptReq *schema.Empty `protobuf:"bytes,2,opt,name=no_encrypt_req,json=noEncryptReq,proto3,oneof" json:"no_encrypt_req,omitempty"`
}
type WantEncryptedRequest_EncryptReq struct {
	EncryptReq *Certificate `protobuf:"bytes,3,opt,name=encrypt_req,json=encryptReq,proto3,oneof" json:"encrypt_req,omitempty"`
}

func (*WantEncryptedRequest_NoEncryptReq) isWantEncryptedRequest_WantEncryptedRequest() {}
func (*WantEncryptedRequest_EncryptReq) isWantEncryptedRequest_WantEncryptedRequest()   {}

func (m *WantEncryptedRequest) GetWantEncryptedRequest() isWantEncryptedRequest_WantEncryptedRequest {
	if m != nil {
		return m.WantEncryptedRequest
	}
	return nil
}

func (m *WantEncryptedRequest) GetNoEncryptReq() *schema.Empty {
	if x, ok := m.GetWantEncryptedRequest().(*WantEncryptedRequest_NoEncryptReq); ok {
		return x.NoEncryptReq
	}
	return nil
}

func (m *WantEncryptedRequest) GetEncryptReq() *Certificate {
	if x, ok := m.GetWantEncryptedRequest().(*WantEncryptedRequest_EncryptReq); ok {
		return x.EncryptReq
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*WantEncryptedRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*WantEncryptedRequest_NoEncryptReq)(nil),
		(*WantEncryptedRequest_EncryptReq)(nil),
	}
}

// Service Provider Properties
//
// x-displayName: "Service Provider Properties"
// Service Provider Properties.
type ServiceProviderProperties struct {
	// Audience URI
	//
	// x-displayName: "Audience URI(Entity ID)"
	// x-required
	AudienceUri *AudienceUri `protobuf:"bytes,1,opt,name=audience_uri,json=audienceUri,proto3" json:"audience_uri,omitempty"`
	// Relay State
	//
	// x-displayName: "Relay State"
	RelayState string `protobuf:"bytes,2,opt,name=relay_state,json=relayState,proto3" json:"relay_state,omitempty"`
	// Assertion Consumer Service Binding
	//
	// x-displayName: "Assertion Consumer Service Binding"
	// Binding  message
	// x-required
	Type AssertionConsumerServiceBinding `protobuf:"varint,3,opt,name=type,proto3,enum=ves.io.schema.uztna.uztna_flow.AssertionConsumerServiceBinding" json:"type,omitempty"`
	// Sign Authentication Requests
	//
	// x-displayName: "Sign Authentication Requests"
	// x-required
	SignAuthenticationRequest *SignAuthenticationRequest `protobuf:"bytes,4,opt,name=sign_authentication_request,json=signAuthenticationRequest,proto3" json:"sign_authentication_request,omitempty"`
	// Want Encrypted Assertion
	//
	// x-displayName: "Want Encrypted Assertion"
	// x-required
	WantEncryptedAssertion *WantEncryptedRequest `protobuf:"bytes,5,opt,name=want_encrypted_assertion,json=wantEncryptedAssertion,proto3" json:"want_encrypted_assertion,omitempty"`
	// Force Authentication
	//
	// x-displayName: "Force Authentication"
	ForceAuthentication bool `protobuf:"varint,6,opt,name=force_authentication,json=forceAuthentication,proto3" json:"force_authentication,omitempty"`
	// Want Signed Assertion
	//
	// x-displayName: "Want Signed Assertion"
	WantSignedAssertion bool `protobuf:"varint,7,opt,name=want_signed_assertion,json=wantSignedAssertion,proto3" json:"want_signed_assertion,omitempty"`
}

func (m *ServiceProviderProperties) Reset()      { *m = ServiceProviderProperties{} }
func (*ServiceProviderProperties) ProtoMessage() {}
func (*ServiceProviderProperties) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{6}
}
func (m *ServiceProviderProperties) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceProviderProperties) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceProviderProperties.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceProviderProperties) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceProviderProperties.Merge(m, src)
}
func (m *ServiceProviderProperties) XXX_Size() int {
	return m.Size()
}
func (m *ServiceProviderProperties) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceProviderProperties.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceProviderProperties proto.InternalMessageInfo

func (m *ServiceProviderProperties) GetAudienceUri() *AudienceUri {
	if m != nil {
		return m.AudienceUri
	}
	return nil
}

func (m *ServiceProviderProperties) GetRelayState() string {
	if m != nil {
		return m.RelayState
	}
	return ""
}

func (m *ServiceProviderProperties) GetType() AssertionConsumerServiceBinding {
	if m != nil {
		return m.Type
	}
	return POST
}

func (m *ServiceProviderProperties) GetSignAuthenticationRequest() *SignAuthenticationRequest {
	if m != nil {
		return m.SignAuthenticationRequest
	}
	return nil
}

func (m *ServiceProviderProperties) GetWantEncryptedAssertion() *WantEncryptedRequest {
	if m != nil {
		return m.WantEncryptedAssertion
	}
	return nil
}

func (m *ServiceProviderProperties) GetForceAuthentication() bool {
	if m != nil {
		return m.ForceAuthentication
	}
	return false
}

func (m *ServiceProviderProperties) GetWantSignedAssertion() bool {
	if m != nil {
		return m.WantSignedAssertion
	}
	return false
}

// Application Tagging
//
// x-displayName: "ApplicationTagging"
type ApplicationTagging struct {
	// Applicatin Tagging
	//
	// x-displayName: "Name of SAML attribute that contains application tag"
	// x-required
	SamlAppTag string `protobuf:"bytes,1,opt,name=saml_app_tag,json=samlAppTag,proto3" json:"saml_app_tag,omitempty"`
}

func (m *ApplicationTagging) Reset()      { *m = ApplicationTagging{} }
func (*ApplicationTagging) ProtoMessage() {}
func (*ApplicationTagging) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{7}
}
func (m *ApplicationTagging) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplicationTagging) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplicationTagging.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplicationTagging) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationTagging.Merge(m, src)
}
func (m *ApplicationTagging) XXX_Size() int {
	return m.Size()
}
func (m *ApplicationTagging) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationTagging.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationTagging proto.InternalMessageInfo

func (m *ApplicationTagging) GetSamlAppTag() string {
	if m != nil {
		return m.SamlAppTag
	}
	return ""
}

// Provider Metadata
//
// x-displayName: "Provider Metadata"
type ProviderMetadata struct {
	// Service  Provider Metadata
	//
	// x-displayName: "Service Provider Metadata"
	// Service Provider Metadata is an XML file containing information needed to establish
	// a secure connection between Distributed Cloud and an Identity Provider for single sign-on (SSO).
	// Once downloaded, securely send this file to your identity provider so they can complete the federation.
	ServiceProviderMetadata string `protobuf:"bytes,1,opt,name=service_provider_metadata,json=serviceProviderMetadata,proto3" json:"service_provider_metadata,omitempty"`
	// Identity Provider Metadata
	//
	// x-displayName: "Identity Provider Metadata"
	// Identity Provider Metadata is an XML file containing information about your identity provider (IdP),
	// including security certificates and endpoints used for single sign-on (SSO).
	IdpProviderMetadata string `protobuf:"bytes,2,opt,name=idp_provider_metadata,json=idpProviderMetadata,proto3" json:"idp_provider_metadata,omitempty"`
}

func (m *ProviderMetadata) Reset()      { *m = ProviderMetadata{} }
func (*ProviderMetadata) ProtoMessage() {}
func (*ProviderMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{8}
}
func (m *ProviderMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProviderMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProviderMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProviderMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProviderMetadata.Merge(m, src)
}
func (m *ProviderMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ProviderMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ProviderMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ProviderMetadata proto.InternalMessageInfo

func (m *ProviderMetadata) GetServiceProviderMetadata() string {
	if m != nil {
		return m.ServiceProviderMetadata
	}
	return ""
}

func (m *ProviderMetadata) GetIdpProviderMetadata() string {
	if m != nil {
		return m.IdpProviderMetadata
	}
	return ""
}

// SAML Message
//
// x-displayName: "SAML Message"
//
// SAML Flow type
type SAMLMessage struct {
	// Service Provider Properties
	//
	// x-displayName: "Service Provider Properties "
	// x-required
	// Service Provider Properties
	ServiceProviderProperties *ServiceProviderProperties `protobuf:"bytes,1,opt,name=service_provider_properties,json=serviceProviderProperties,proto3" json:"service_provider_properties,omitempty"`
	// Provider Properties
	//
	// x-displayName: "Provider Metadata "
	// x-required
	// Provide metadata is xml kind of input for Service provider metadata and IDP .
	ProviderMetadata *ProviderMetadata `protobuf:"bytes,2,opt,name=provider_metadata,json=providerMetadata,proto3" json:"provider_metadata,omitempty"`
	// Application Tagging
	//
	// x-displayName: "Application Tagging "
	// x-required
	// Application Tagging
	ApplicationTag *ApplicationTagging `protobuf:"bytes,3,opt,name=application_tag,json=applicationTag,proto3" json:"application_tag,omitempty"`
}

func (m *SAMLMessage) Reset()      { *m = SAMLMessage{} }
func (*SAMLMessage) ProtoMessage() {}
func (*SAMLMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{9}
}
func (m *SAMLMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SAMLMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SAMLMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SAMLMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SAMLMessage.Merge(m, src)
}
func (m *SAMLMessage) XXX_Size() int {
	return m.Size()
}
func (m *SAMLMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_SAMLMessage.DiscardUnknown(m)
}

var xxx_messageInfo_SAMLMessage proto.InternalMessageInfo

func (m *SAMLMessage) GetServiceProviderProperties() *ServiceProviderProperties {
	if m != nil {
		return m.ServiceProviderProperties
	}
	return nil
}

func (m *SAMLMessage) GetProviderMetadata() *ProviderMetadata {
	if m != nil {
		return m.ProviderMetadata
	}
	return nil
}

func (m *SAMLMessage) GetApplicationTag() *ApplicationTagging {
	if m != nil {
		return m.ApplicationTag
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.uztna.uztna_flow.AssertionConsumerServiceBinding", AssertionConsumerServiceBinding_name, AssertionConsumerServiceBinding_value)
	proto.RegisterType((*Certificate)(nil), "ves.io.schema.uztna.uztna_flow.Certificate")
	proto.RegisterType((*UniformResourceName)(nil), "ves.io.schema.uztna.uztna_flow.UniformResourceName")
	proto.RegisterType((*UniformResourceLocator)(nil), "ves.io.schema.uztna.uztna_flow.UniformResourceLocator")
	proto.RegisterType((*AudienceUri)(nil), "ves.io.schema.uztna.uztna_flow.AudienceUri")
	proto.RegisterType((*SignAuthenticationRequest)(nil), "ves.io.schema.uztna.uztna_flow.SignAuthenticationRequest")
	proto.RegisterType((*WantEncryptedRequest)(nil), "ves.io.schema.uztna.uztna_flow.WantEncryptedRequest")
	proto.RegisterType((*ServiceProviderProperties)(nil), "ves.io.schema.uztna.uztna_flow.ServiceProviderProperties")
	proto.RegisterType((*ApplicationTagging)(nil), "ves.io.schema.uztna.uztna_flow.ApplicationTagging")
	proto.RegisterType((*ProviderMetadata)(nil), "ves.io.schema.uztna.uztna_flow.ProviderMetadata")
	proto.RegisterType((*SAMLMessage)(nil), "ves.io.schema.uztna.uztna_flow.SAMLMessage")
}

func init() {
	proto.RegisterFile("ves.io/schema/uztna/uztna_flow/saml.proto", fileDescriptor_d2b77cd57ae9845f)
}

var fileDescriptor_d2b77cd57ae9845f = []byte{
	// 1138 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xcf, 0x6f, 0x1b, 0x45,
	0x14, 0xf6, 0xc4, 0x6e, 0x71, 0xde, 0x5a, 0xc1, 0xac, 0x93, 0xd6, 0x6e, 0xab, 0xad, 0x31, 0x42,
	0x2a, 0x4d, 0x6a, 0xb7, 0x4e, 0x15, 0xa9, 0xa8, 0x02, 0xc5, 0x21, 0x28, 0x8d, 0x9a, 0x34, 0x5a,
	0x3b, 0x42, 0x02, 0x55, 0xab, 0x89, 0x3d, 0x5e, 0x0f, 0xd8, 0x33, 0x9b, 0xd9, 0xd9, 0xa4, 0xae,
	0x00, 0xf5, 0xcc, 0xa9, 0x67, 0x2e, 0x5c, 0x11, 0x7f, 0x02, 0xbe, 0xf4, 0xc0, 0x01, 0x10, 0x12,
	0x39, 0x56, 0x9c, 0x88, 0x73, 0x81, 0x5b, 0x8f, 0x1c, 0xd1, 0xac, 0xd7, 0x8e, 0xd7, 0x3f, 0x30,
	0x70, 0xb1, 0xbc, 0xf3, 0xde, 0xfb, 0xde, 0xf7, 0xbd, 0x1f, 0xbb, 0x03, 0xef, 0x1c, 0x11, 0x37,
	0x4f, 0x79, 0xc1, 0xad, 0x36, 0x48, 0x0b, 0x17, 0xbc, 0xa7, 0x92, 0x05, 0xbf, 0x56, 0xbd, 0xc9,
	0x8f, 0x0b, 0x2e, 0x6e, 0x35, 0xf3, 0x8e, 0xe0, 0x92, 0xeb, 0x46, 0xcf, 0x35, 0xdf, 0x73, 0xcd,
	0xfb, 0x4e, 0xf9, 0x73, 0xd7, 0x2b, 0xcb, 0x61, 0x28, 0xec, 0x50, 0xcb, 0x16, 0xdc, 0x73, 0x2c,
	0xd2, 0x24, 0x2d, 0xc2, 0x64, 0x41, 0xb6, 0x1d, 0xe2, 0xf6, 0xc0, 0xae, 0x5c, 0x0e, 0x3b, 0x33,
	0x22, 0x03, 0xc3, 0xd5, 0xb0, 0x81, 0x3b, 0x92, 0x72, 0xd6, 0x8f, 0xca, 0x84, 0x8d, 0xc3, 0x80,
	0xd7, 0xc2, 0xa6, 0x23, 0xdc, 0xa4, 0x35, 0x2c, 0x49, 0x60, 0xcd, 0x8e, 0x58, 0x29, 0x39, 0xb6,
	0xc2, 0xd0, 0xd7, 0xc7, 0x3d, 0xdc, 0xe1, 0x04, 0xb9, 0xc7, 0xa0, 0x6d, 0x10, 0x21, 0x69, 0x9d,
	0x56, 0xb1, 0x24, 0xfa, 0x2e, 0x68, 0xd5, 0xf3, 0xc7, 0xf4, 0x5c, 0x36, 0x7a, 0x43, 0x2b, 0x5e,
	0xcb, 0x87, 0x6b, 0xf4, 0xe8, 0xe0, 0x53, 0x52, 0x95, 0x26, 0xa9, 0x57, 0xda, 0x0e, 0x29, 0x2d,
	0x7c, 0xf7, 0xc5, 0x70, 0x8c, 0x39, 0xfc, 0x90, 0xfb, 0x1c, 0x52, 0xfb, 0x8c, 0xd6, 0xb9, 0x68,
	0x99, 0xc4, 0xe5, 0x9e, 0xa8, 0x92, 0x5d, 0xdc, 0x22, 0xfa, 0x2a, 0x44, 0x3d, 0xc1, 0xd2, 0x28,
	0x8b, 0x6e, 0xcc, 0x97, 0xde, 0xfc, 0xab, 0x83, 0xe6, 0xbe, 0xff, 0xf3, 0x45, 0xf4, 0x82, 0x88,
	0xa6, 0x9f, 0x21, 0xf5, 0x2f, 0x26, 0xe6, 0x92, 0x28, 0x38, 0x7a, 0x8e, 0x90, 0xa9, 0xbc, 0xf5,
	0xdb, 0x30, 0xdf, 0xe0, 0xae, 0xb4, 0x18, 0x6e, 0x29, 0x66, 0x2a, 0x34, 0x15, 0x38, 0x37, 0xd0,
	0x20, 0x3e, 0x6e, 0xc6, 0x95, 0x97, 0x4a, 0x93, 0x5b, 0x83, 0x4b, 0x23, 0xd9, 0x1f, 0xf2, 0x2a,
	0x96, 0x5c, 0xe8, 0xd7, 0x14, 0x81, 0x66, 0x40, 0x00, 0x86, 0x82, 0xd5, 0x71, 0xee, 0x9b, 0x28,
	0x68, 0xeb, 0x5e, 0x8d, 0x12, 0x56, 0x25, 0xfb, 0x82, 0xea, 0x02, 0xd2, 0x5e, 0x0f, 0xc7, 0x12,
	0x01, 0x90, 0xd5, 0xec, 0x21, 0xf9, 0x10, 0x5a, 0x71, 0x2d, 0xff, 0xcf, 0x63, 0x94, 0x9f, 0xcc,
	0x63, 0x2b, 0x62, 0x5e, 0xf2, 0x26, 0x33, 0xa4, 0xb0, 0x34, 0x96, 0x73, 0xa0, 0x5c, 0x2b, 0xae,
	0xfe, 0xc7, 0x84, 0xaa, 0x1e, 0x5b, 0x11, 0x33, 0xe5, 0x8d, 0x1f, 0xbf, 0xfb, 0xe5, 0xcf, 0x1d,
	0xf4, 0x14, 0x9e, 0x40, 0xa2, 0xaf, 0x39, 0xbb, 0x6f, 0x3e, 0xb8, 0xd9, 0x80, 0x3a, 0xdc, 0x9d,
	0x2e, 0xbc, 0x98, 0x0e, 0x32, 0x64, 0xfb, 0x58, 0xd9, 0x80, 0x3a, 0xe4, 0xa7, 0x50, 0x2f, 0x2e,
	0x8d, 0x85, 0xa8, 0xfc, 0xa5, 0x65, 0x48, 0xe1, 0x20, 0xb3, 0xe5, 0x09, 0x6a, 0x55, 0x1b, 0x9c,
	0x56, 0x89, 0xbe, 0xf8, 0xa2, 0x83, 0xd0, 0x49, 0x07, 0xc5, 0xba, 0x1d, 0x14, 0xbb, 0xb3, 0x92,
	0x2d, 0xaa, 0x39, 0xd9, 0x8e, 0xc5, 0x63, 0xc9, 0x0b, 0xb9, 0x5f, 0x10, 0x64, 0xca, 0xd4, 0x66,
	0xeb, 0x9e, 0x6c, 0x10, 0x26, 0xd5, 0xb0, 0x51, 0xce, 0x4c, 0x72, 0xe8, 0x11, 0x57, 0xea, 0x6b,
	0xa0, 0x31, 0x6e, 0x61, 0x4f, 0x36, 0x2c, 0x41, 0x0e, 0x83, 0x8a, 0x2d, 0x8e, 0x54, 0x6c, 0xb3,
	0xe5, 0xc8, 0xf6, 0x56, 0xc4, 0x9c, 0x67, 0x5c, 0xa1, 0x98, 0xe4, 0x50, 0xdf, 0x86, 0x79, 0x97,
	0xda, 0xcc, 0x8f, 0x4c, 0x47, 0xfd, 0xa8, 0xe5, 0x59, 0x75, 0x1e, 0xda, 0x9e, 0xad, 0x88, 0x19,
	0x77, 0x03, 0x52, 0xa5, 0xb7, 0x61, 0x69, 0x80, 0x65, 0xa9, 0x8d, 0xeb, 0xcb, 0x4a, 0x9c, 0x74,
	0x10, 0x52, 0x92, 0x8a, 0x2b, 0xd9, 0xd5, 0xed, 0x58, 0x1c, 0x25, 0xe7, 0x72, 0xbf, 0x22, 0x58,
	0xfc, 0x08, 0x33, 0xb9, 0xc9, 0xaa, 0xa2, 0xed, 0x48, 0x52, 0xeb, 0x2b, 0xb9, 0x0f, 0x0b, 0x8c,
	0x5b, 0xa4, 0x77, 0xfc, 0x2f, 0xc4, 0x24, 0x18, 0x0f, 0x30, 0x94, 0x9e, 0x5d, 0xd0, 0x86, 0x43,
	0xff, 0x97, 0x22, 0x20, 0x03, 0xbc, 0xd2, 0x5b, 0x70, 0xe9, 0x18, 0x33, 0xd9, 0xe7, 0x43, 0x6a,
	0x0a, 0xd6, 0xe7, 0x39, 0x1f, 0x88, 0x42, 0xc5, 0x40, 0xd1, 0x4f, 0x31, 0xc8, 0x94, 0x89, 0x38,
	0xa2, 0x55, 0xb2, 0x27, 0xf8, 0x11, 0xad, 0x11, 0xb1, 0x27, 0xb8, 0xa3, 0xa0, 0x89, 0xab, 0xef,
	0x42, 0x62, 0xb8, 0xe3, 0xc1, 0x12, 0xcd, 0x64, 0x36, 0xb4, 0x93, 0xa6, 0x86, 0x87, 0x16, 0x74,
	0x19, 0x34, 0x41, 0x9a, 0xb8, 0x6d, 0xb9, 0xb2, 0xf7, 0xda, 0x1a, 0x5d, 0x6b, 0xf0, 0xcd, 0x65,
	0x65, 0xd5, 0xcb, 0x10, 0x53, 0xfd, 0xf0, 0xcb, 0xb1, 0x50, 0x7c, 0x7f, 0x66, 0x52, 0xd7, 0x55,
	0xac, 0x39, 0xdb, 0xe0, 0xcc, 0xf5, 0x5a, 0x44, 0x04, 0xb2, 0x4a, 0x94, 0xd5, 0x28, 0xb3, 0x4d,
	0x1f, 0x4c, 0x6f, 0xc3, 0xd5, 0x41, 0xbb, 0xcf, 0x07, 0xb2, 0x5f, 0x9f, 0x74, 0xcc, 0x17, 0x78,
	0x6f, 0x56, 0xae, 0xa9, 0x23, 0x6d, 0x66, 0xdc, 0xa9, 0xd3, 0xce, 0x20, 0x3d, 0xd2, 0x15, 0xdc,
	0xa7, 0x9c, 0xbe, 0xe0, 0xe7, 0xbd, 0x3b, 0x2b, 0xef, 0xa4, 0xd9, 0x33, 0xfd, 0x5e, 0x0f, 0x4e,
	0x07, 0x65, 0xd0, 0xef, 0xc0, 0x62, 0x9d, 0xab, 0x9d, 0x0e, 0x6b, 0x4d, 0x5f, 0xcc, 0xa2, 0x1b,
	0x71, 0x33, 0xe5, 0xdb, 0xc2, 0x4c, 0xf5, 0xfb, 0xb0, 0xe4, 0x53, 0x54, 0x22, 0x42, 0xfc, 0x5e,
	0x53, 0x31, 0xa5, 0xf8, 0x6f, 0x1d, 0x14, 0x93, 0xc2, 0x23, 0x66, 0x4a, 0xb9, 0x95, 0x7d, 0xaf,
	0x41, 0xc2, 0x5c, 0x09, 0xf4, 0x75, 0xc7, 0x69, 0x06, 0x60, 0x15, 0x6c, 0xdb, 0x94, 0xd9, 0xfa,
	0x0a, 0x24, 0xd4, 0x67, 0xdc, 0xc2, 0x8e, 0x63, 0x49, 0x6c, 0x4f, 0x78, 0x97, 0x83, 0xb2, 0xaf,
	0x3b, 0x4e, 0x05, 0xdb, 0xb9, 0xaf, 0x11, 0x24, 0xfb, 0x83, 0xb8, 0x43, 0x24, 0xae, 0x61, 0x89,
	0xf5, 0x0f, 0x21, 0xe3, 0xf6, 0x9a, 0x69, 0x39, 0x81, 0xcd, 0x6a, 0x05, 0xc6, 0x09, 0x78, 0x97,
	0xdd, 0xf0, 0x40, 0x0f, 0x70, 0xde, 0x83, 0x25, 0x5a, 0x73, 0x26, 0x60, 0x8c, 0x0f, 0x62, 0x8a,
	0xd6, 0x9c, 0xd1, 0xf8, 0xdc, 0x0f, 0x73, 0xa0, 0x95, 0xd7, 0x77, 0x1e, 0xee, 0x10, 0xd7, 0xc5,
	0x76, 0x6f, 0x98, 0x46, 0x79, 0x39, 0x83, 0xed, 0x09, 0xb6, 0x65, 0xf6, 0x30, 0x4d, 0x5b, 0x3f,
	0x33, 0xe3, 0x4e, 0xdd, 0xcc, 0xc7, 0xf0, 0xc6, 0x64, 0x19, 0x5a, 0xf1, 0xf6, 0xac, 0x84, 0xa3,
	0xba, 0xcc, 0xa4, 0x33, 0x5a, 0xa9, 0x4f, 0xe0, 0x75, 0x7c, 0xde, 0x4a, 0xbf, 0x6f, 0xbd, 0xb7,
	0x52, 0x71, 0xe6, 0x1a, 0x8e, 0x4d, 0x80, 0xb9, 0x80, 0x43, 0x67, 0x37, 0xef, 0xc1, 0xf5, 0x19,
	0xcb, 0xaa, 0xc7, 0x21, 0xb6, 0xf7, 0xa8, 0x5c, 0x49, 0x46, 0xf4, 0x04, 0xc4, 0xcd, 0xcd, 0x0f,
	0x1e, 0x98, 0x9b, 0x1b, 0x95, 0x24, 0x2a, 0x7d, 0x85, 0x4e, 0x4e, 0x8d, 0xc8, 0xcb, 0x53, 0x23,
	0xf2, 0xea, 0xd4, 0x40, 0xcf, 0xba, 0x06, 0xfa, 0xb6, 0x6b, 0xa0, 0x1f, 0xbb, 0x06, 0x3a, 0xe9,
	0x1a, 0xe8, 0xf7, 0xae, 0x81, 0xfe, 0xe8, 0x1a, 0x91, 0x57, 0x5d, 0x03, 0x3d, 0x3f, 0x33, 0x22,
	0x27, 0x67, 0x46, 0xe4, 0xe5, 0x99, 0x11, 0xf9, 0xb8, 0x62, 0x73, 0xe7, 0x33, 0x3b, 0x7f, 0xc4,
	0x9b, 0x92, 0x08, 0x81, 0xf3, 0x9e, 0x5b, 0xf0, 0xff, 0xa8, 0x8f, 0xdc, 0xad, 0xbe, 0xf8, 0x5b,
	0x7d, 0x73, 0xc1, 0x39, 0xb0, 0x79, 0x81, 0x3c, 0x91, 0xc1, 0x6d, 0x6c, 0xca, 0xed, 0xf4, 0xe0,
	0xa2, 0x7f, 0x35, 0x5b, 0xfd, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xdb, 0xa3, 0xbd, 0x21, 0xc6, 0x0a,
	0x00, 0x00,
}

func (x AssertionConsumerServiceBinding) String() string {
	s, ok := AssertionConsumerServiceBinding_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Certificate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Certificate)
	if !ok {
		that2, ok := that.(Certificate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Certificate) != len(that1.Certificate) {
		return false
	}
	for i := range this.Certificate {
		if !this.Certificate[i].Equal(that1.Certificate[i]) {
			return false
		}
	}
	return true
}
func (this *UniformResourceName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UniformResourceName)
	if !ok {
		that2, ok := that.(UniformResourceName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Urn != that1.Urn {
		return false
	}
	if this.HostName != that1.HostName {
		return false
	}
	return true
}
func (this *UniformResourceLocator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UniformResourceLocator)
	if !ok {
		that2, ok := that.(UniformResourceLocator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	return true
}
func (this *AudienceUri) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AudienceUri)
	if !ok {
		that2, ok := that.(AudienceUri)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AudienceUriChoice == nil {
		if this.AudienceUriChoice != nil {
			return false
		}
	} else if this.AudienceUriChoice == nil {
		return false
	} else if !this.AudienceUriChoice.Equal(that1.AudienceUriChoice) {
		return false
	}
	return true
}
func (this *AudienceUri_UniformResourceLocator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AudienceUri_UniformResourceLocator)
	if !ok {
		that2, ok := that.(AudienceUri_UniformResourceLocator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UniformResourceLocator.Equal(that1.UniformResourceLocator) {
		return false
	}
	return true
}
func (this *AudienceUri_UniformResourceName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AudienceUri_UniformResourceName)
	if !ok {
		that2, ok := that.(AudienceUri_UniformResourceName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UniformResourceName.Equal(that1.UniformResourceName) {
		return false
	}
	return true
}
func (this *SignAuthenticationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SignAuthenticationRequest)
	if !ok {
		that2, ok := that.(SignAuthenticationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.SignAuthTypeChoice == nil {
		if this.SignAuthTypeChoice != nil {
			return false
		}
	} else if this.SignAuthTypeChoice == nil {
		return false
	} else if !this.SignAuthTypeChoice.Equal(that1.SignAuthTypeChoice) {
		return false
	}
	return true
}
func (this *SignAuthenticationRequest_NoAuthReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SignAuthenticationRequest_NoAuthReq)
	if !ok {
		that2, ok := that.(SignAuthenticationRequest_NoAuthReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoAuthReq.Equal(that1.NoAuthReq) {
		return false
	}
	return true
}
func (this *SignAuthenticationRequest_SignAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SignAuthenticationRequest_SignAuth)
	if !ok {
		that2, ok := that.(SignAuthenticationRequest_SignAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SignAuth.Equal(that1.SignAuth) {
		return false
	}
	return true
}
func (this *WantEncryptedRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WantEncryptedRequest)
	if !ok {
		that2, ok := that.(WantEncryptedRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.WantEncryptedRequest == nil {
		if this.WantEncryptedRequest != nil {
			return false
		}
	} else if this.WantEncryptedRequest == nil {
		return false
	} else if !this.WantEncryptedRequest.Equal(that1.WantEncryptedRequest) {
		return false
	}
	return true
}
func (this *WantEncryptedRequest_NoEncryptReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WantEncryptedRequest_NoEncryptReq)
	if !ok {
		that2, ok := that.(WantEncryptedRequest_NoEncryptReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoEncryptReq.Equal(that1.NoEncryptReq) {
		return false
	}
	return true
}
func (this *WantEncryptedRequest_EncryptReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WantEncryptedRequest_EncryptReq)
	if !ok {
		that2, ok := that.(WantEncryptedRequest_EncryptReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EncryptReq.Equal(that1.EncryptReq) {
		return false
	}
	return true
}
func (this *ServiceProviderProperties) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceProviderProperties)
	if !ok {
		that2, ok := that.(ServiceProviderProperties)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AudienceUri.Equal(that1.AudienceUri) {
		return false
	}
	if this.RelayState != that1.RelayState {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.SignAuthenticationRequest.Equal(that1.SignAuthenticationRequest) {
		return false
	}
	if !this.WantEncryptedAssertion.Equal(that1.WantEncryptedAssertion) {
		return false
	}
	if this.ForceAuthentication != that1.ForceAuthentication {
		return false
	}
	if this.WantSignedAssertion != that1.WantSignedAssertion {
		return false
	}
	return true
}
func (this *ApplicationTagging) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApplicationTagging)
	if !ok {
		that2, ok := that.(ApplicationTagging)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SamlAppTag != that1.SamlAppTag {
		return false
	}
	return true
}
func (this *ProviderMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProviderMetadata)
	if !ok {
		that2, ok := that.(ProviderMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServiceProviderMetadata != that1.ServiceProviderMetadata {
		return false
	}
	if this.IdpProviderMetadata != that1.IdpProviderMetadata {
		return false
	}
	return true
}
func (this *SAMLMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SAMLMessage)
	if !ok {
		that2, ok := that.(SAMLMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServiceProviderProperties.Equal(that1.ServiceProviderProperties) {
		return false
	}
	if !this.ProviderMetadata.Equal(that1.ProviderMetadata) {
		return false
	}
	if !this.ApplicationTag.Equal(that1.ApplicationTag) {
		return false
	}
	return true
}
func (this *Certificate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_flow.Certificate{")
	if this.Certificate != nil {
		s = append(s, "Certificate: "+fmt.Sprintf("%#v", this.Certificate)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UniformResourceName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_flow.UniformResourceName{")
	s = append(s, "Urn: "+fmt.Sprintf("%#v", this.Urn)+",\n")
	s = append(s, "HostName: "+fmt.Sprintf("%#v", this.HostName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UniformResourceLocator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_flow.UniformResourceLocator{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AudienceUri) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_flow.AudienceUri{")
	if this.AudienceUriChoice != nil {
		s = append(s, "AudienceUriChoice: "+fmt.Sprintf("%#v", this.AudienceUriChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AudienceUri_UniformResourceLocator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.AudienceUri_UniformResourceLocator{` +
		`UniformResourceLocator:` + fmt.Sprintf("%#v", this.UniformResourceLocator) + `}`}, ", ")
	return s
}
func (this *AudienceUri_UniformResourceName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.AudienceUri_UniformResourceName{` +
		`UniformResourceName:` + fmt.Sprintf("%#v", this.UniformResourceName) + `}`}, ", ")
	return s
}
func (this *SignAuthenticationRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_flow.SignAuthenticationRequest{")
	if this.SignAuthTypeChoice != nil {
		s = append(s, "SignAuthTypeChoice: "+fmt.Sprintf("%#v", this.SignAuthTypeChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SignAuthenticationRequest_NoAuthReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.SignAuthenticationRequest_NoAuthReq{` +
		`NoAuthReq:` + fmt.Sprintf("%#v", this.NoAuthReq) + `}`}, ", ")
	return s
}
func (this *SignAuthenticationRequest_SignAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.SignAuthenticationRequest_SignAuth{` +
		`SignAuth:` + fmt.Sprintf("%#v", this.SignAuth) + `}`}, ", ")
	return s
}
func (this *WantEncryptedRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_flow.WantEncryptedRequest{")
	if this.WantEncryptedRequest != nil {
		s = append(s, "WantEncryptedRequest: "+fmt.Sprintf("%#v", this.WantEncryptedRequest)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WantEncryptedRequest_NoEncryptReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.WantEncryptedRequest_NoEncryptReq{` +
		`NoEncryptReq:` + fmt.Sprintf("%#v", this.NoEncryptReq) + `}`}, ", ")
	return s
}
func (this *WantEncryptedRequest_EncryptReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.WantEncryptedRequest_EncryptReq{` +
		`EncryptReq:` + fmt.Sprintf("%#v", this.EncryptReq) + `}`}, ", ")
	return s
}
func (this *ServiceProviderProperties) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&uztna_flow.ServiceProviderProperties{")
	if this.AudienceUri != nil {
		s = append(s, "AudienceUri: "+fmt.Sprintf("%#v", this.AudienceUri)+",\n")
	}
	s = append(s, "RelayState: "+fmt.Sprintf("%#v", this.RelayState)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.SignAuthenticationRequest != nil {
		s = append(s, "SignAuthenticationRequest: "+fmt.Sprintf("%#v", this.SignAuthenticationRequest)+",\n")
	}
	if this.WantEncryptedAssertion != nil {
		s = append(s, "WantEncryptedAssertion: "+fmt.Sprintf("%#v", this.WantEncryptedAssertion)+",\n")
	}
	s = append(s, "ForceAuthentication: "+fmt.Sprintf("%#v", this.ForceAuthentication)+",\n")
	s = append(s, "WantSignedAssertion: "+fmt.Sprintf("%#v", this.WantSignedAssertion)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ApplicationTagging) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_flow.ApplicationTagging{")
	s = append(s, "SamlAppTag: "+fmt.Sprintf("%#v", this.SamlAppTag)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProviderMetadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_flow.ProviderMetadata{")
	s = append(s, "ServiceProviderMetadata: "+fmt.Sprintf("%#v", this.ServiceProviderMetadata)+",\n")
	s = append(s, "IdpProviderMetadata: "+fmt.Sprintf("%#v", this.IdpProviderMetadata)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SAMLMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&uztna_flow.SAMLMessage{")
	if this.ServiceProviderProperties != nil {
		s = append(s, "ServiceProviderProperties: "+fmt.Sprintf("%#v", this.ServiceProviderProperties)+",\n")
	}
	if this.ProviderMetadata != nil {
		s = append(s, "ProviderMetadata: "+fmt.Sprintf("%#v", this.ProviderMetadata)+",\n")
	}
	if this.ApplicationTag != nil {
		s = append(s, "ApplicationTag: "+fmt.Sprintf("%#v", this.ApplicationTag)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringSaml(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Certificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Certificate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Certificate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Certificate) > 0 {
		for iNdEx := len(m.Certificate) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Certificate[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSaml(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *UniformResourceName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UniformResourceName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UniformResourceName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintSaml(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Urn) > 0 {
		i -= len(m.Urn)
		copy(dAtA[i:], m.Urn)
		i = encodeVarintSaml(dAtA, i, uint64(len(m.Urn)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UniformResourceLocator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UniformResourceLocator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UniformResourceLocator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintSaml(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AudienceUri) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AudienceUri) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AudienceUri) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AudienceUriChoice != nil {
		{
			size := m.AudienceUriChoice.Size()
			i -= size
			if _, err := m.AudienceUriChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AudienceUri_UniformResourceLocator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AudienceUri_UniformResourceLocator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UniformResourceLocator != nil {
		{
			size, err := m.UniformResourceLocator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AudienceUri_UniformResourceName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AudienceUri_UniformResourceName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UniformResourceName != nil {
		{
			size, err := m.UniformResourceName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SignAuthenticationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignAuthenticationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignAuthenticationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SignAuthTypeChoice != nil {
		{
			size := m.SignAuthTypeChoice.Size()
			i -= size
			if _, err := m.SignAuthTypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SignAuthenticationRequest_NoAuthReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignAuthenticationRequest_NoAuthReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoAuthReq != nil {
		{
			size, err := m.NoAuthReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SignAuthenticationRequest_SignAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignAuthenticationRequest_SignAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SignAuth != nil {
		{
			size, err := m.SignAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *WantEncryptedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WantEncryptedRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WantEncryptedRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WantEncryptedRequest != nil {
		{
			size := m.WantEncryptedRequest.Size()
			i -= size
			if _, err := m.WantEncryptedRequest.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *WantEncryptedRequest_NoEncryptReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WantEncryptedRequest_NoEncryptReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoEncryptReq != nil {
		{
			size, err := m.NoEncryptReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *WantEncryptedRequest_EncryptReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WantEncryptedRequest_EncryptReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EncryptReq != nil {
		{
			size, err := m.EncryptReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ServiceProviderProperties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceProviderProperties) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceProviderProperties) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WantSignedAssertion {
		i--
		if m.WantSignedAssertion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.ForceAuthentication {
		i--
		if m.ForceAuthentication {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.WantEncryptedAssertion != nil {
		{
			size, err := m.WantEncryptedAssertion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.SignAuthenticationRequest != nil {
		{
			size, err := m.SignAuthenticationRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintSaml(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RelayState) > 0 {
		i -= len(m.RelayState)
		copy(dAtA[i:], m.RelayState)
		i = encodeVarintSaml(dAtA, i, uint64(len(m.RelayState)))
		i--
		dAtA[i] = 0x12
	}
	if m.AudienceUri != nil {
		{
			size, err := m.AudienceUri.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ApplicationTagging) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplicationTagging) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplicationTagging) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SamlAppTag) > 0 {
		i -= len(m.SamlAppTag)
		copy(dAtA[i:], m.SamlAppTag)
		i = encodeVarintSaml(dAtA, i, uint64(len(m.SamlAppTag)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProviderMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IdpProviderMetadata) > 0 {
		i -= len(m.IdpProviderMetadata)
		copy(dAtA[i:], m.IdpProviderMetadata)
		i = encodeVarintSaml(dAtA, i, uint64(len(m.IdpProviderMetadata)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServiceProviderMetadata) > 0 {
		i -= len(m.ServiceProviderMetadata)
		copy(dAtA[i:], m.ServiceProviderMetadata)
		i = encodeVarintSaml(dAtA, i, uint64(len(m.ServiceProviderMetadata)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SAMLMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SAMLMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SAMLMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ApplicationTag != nil {
		{
			size, err := m.ApplicationTag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ProviderMetadata != nil {
		{
			size, err := m.ProviderMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ServiceProviderProperties != nil {
		{
			size, err := m.ServiceProviderProperties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSaml(dAtA []byte, offset int, v uint64) int {
	offset -= sovSaml(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Certificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Certificate) > 0 {
		for _, e := range m.Certificate {
			l = e.Size()
			n += 1 + l + sovSaml(uint64(l))
		}
	}
	return n
}

func (m *UniformResourceName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Urn)
	if l > 0 {
		n += 1 + l + sovSaml(uint64(l))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}

func (m *UniformResourceLocator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}

func (m *AudienceUri) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AudienceUriChoice != nil {
		n += m.AudienceUriChoice.Size()
	}
	return n
}

func (m *AudienceUri_UniformResourceLocator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UniformResourceLocator != nil {
		l = m.UniformResourceLocator.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *AudienceUri_UniformResourceName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UniformResourceName != nil {
		l = m.UniformResourceName.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *SignAuthenticationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignAuthTypeChoice != nil {
		n += m.SignAuthTypeChoice.Size()
	}
	return n
}

func (m *SignAuthenticationRequest_NoAuthReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoAuthReq != nil {
		l = m.NoAuthReq.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *SignAuthenticationRequest_SignAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignAuth != nil {
		l = m.SignAuth.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *WantEncryptedRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WantEncryptedRequest != nil {
		n += m.WantEncryptedRequest.Size()
	}
	return n
}

func (m *WantEncryptedRequest_NoEncryptReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoEncryptReq != nil {
		l = m.NoEncryptReq.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *WantEncryptedRequest_EncryptReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EncryptReq != nil {
		l = m.EncryptReq.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *ServiceProviderProperties) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AudienceUri != nil {
		l = m.AudienceUri.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	l = len(m.RelayState)
	if l > 0 {
		n += 1 + l + sovSaml(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovSaml(uint64(m.Type))
	}
	if m.SignAuthenticationRequest != nil {
		l = m.SignAuthenticationRequest.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	if m.WantEncryptedAssertion != nil {
		l = m.WantEncryptedAssertion.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	if m.ForceAuthentication {
		n += 2
	}
	if m.WantSignedAssertion {
		n += 2
	}
	return n
}

func (m *ApplicationTagging) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SamlAppTag)
	if l > 0 {
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}

func (m *ProviderMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServiceProviderMetadata)
	if l > 0 {
		n += 1 + l + sovSaml(uint64(l))
	}
	l = len(m.IdpProviderMetadata)
	if l > 0 {
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}

func (m *SAMLMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServiceProviderProperties != nil {
		l = m.ServiceProviderProperties.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	if m.ProviderMetadata != nil {
		l = m.ProviderMetadata.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	if m.ApplicationTag != nil {
		l = m.ApplicationTag.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}

func sovSaml(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSaml(x uint64) (n int) {
	return sovSaml(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Certificate) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCertificate := "[]*ObjectRefType{"
	for _, f := range this.Certificate {
		repeatedStringForCertificate += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCertificate += "}"
	s := strings.Join([]string{`&Certificate{`,
		`Certificate:` + repeatedStringForCertificate + `,`,
		`}`,
	}, "")
	return s
}
func (this *UniformResourceName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UniformResourceName{`,
		`Urn:` + fmt.Sprintf("%v", this.Urn) + `,`,
		`HostName:` + fmt.Sprintf("%v", this.HostName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UniformResourceLocator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UniformResourceLocator{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AudienceUri) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AudienceUri{`,
		`AudienceUriChoice:` + fmt.Sprintf("%v", this.AudienceUriChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AudienceUri_UniformResourceLocator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AudienceUri_UniformResourceLocator{`,
		`UniformResourceLocator:` + strings.Replace(fmt.Sprintf("%v", this.UniformResourceLocator), "UniformResourceLocator", "UniformResourceLocator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AudienceUri_UniformResourceName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AudienceUri_UniformResourceName{`,
		`UniformResourceName:` + strings.Replace(fmt.Sprintf("%v", this.UniformResourceName), "UniformResourceName", "UniformResourceName", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignAuthenticationRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SignAuthenticationRequest{`,
		`SignAuthTypeChoice:` + fmt.Sprintf("%v", this.SignAuthTypeChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignAuthenticationRequest_NoAuthReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SignAuthenticationRequest_NoAuthReq{`,
		`NoAuthReq:` + strings.Replace(fmt.Sprintf("%v", this.NoAuthReq), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignAuthenticationRequest_SignAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SignAuthenticationRequest_SignAuth{`,
		`SignAuth:` + strings.Replace(fmt.Sprintf("%v", this.SignAuth), "Certificate", "Certificate", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WantEncryptedRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WantEncryptedRequest{`,
		`WantEncryptedRequest:` + fmt.Sprintf("%v", this.WantEncryptedRequest) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WantEncryptedRequest_NoEncryptReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WantEncryptedRequest_NoEncryptReq{`,
		`NoEncryptReq:` + strings.Replace(fmt.Sprintf("%v", this.NoEncryptReq), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WantEncryptedRequest_EncryptReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WantEncryptedRequest_EncryptReq{`,
		`EncryptReq:` + strings.Replace(fmt.Sprintf("%v", this.EncryptReq), "Certificate", "Certificate", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceProviderProperties) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceProviderProperties{`,
		`AudienceUri:` + strings.Replace(this.AudienceUri.String(), "AudienceUri", "AudienceUri", 1) + `,`,
		`RelayState:` + fmt.Sprintf("%v", this.RelayState) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`SignAuthenticationRequest:` + strings.Replace(this.SignAuthenticationRequest.String(), "SignAuthenticationRequest", "SignAuthenticationRequest", 1) + `,`,
		`WantEncryptedAssertion:` + strings.Replace(this.WantEncryptedAssertion.String(), "WantEncryptedRequest", "WantEncryptedRequest", 1) + `,`,
		`ForceAuthentication:` + fmt.Sprintf("%v", this.ForceAuthentication) + `,`,
		`WantSignedAssertion:` + fmt.Sprintf("%v", this.WantSignedAssertion) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ApplicationTagging) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ApplicationTagging{`,
		`SamlAppTag:` + fmt.Sprintf("%v", this.SamlAppTag) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProviderMetadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProviderMetadata{`,
		`ServiceProviderMetadata:` + fmt.Sprintf("%v", this.ServiceProviderMetadata) + `,`,
		`IdpProviderMetadata:` + fmt.Sprintf("%v", this.IdpProviderMetadata) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SAMLMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SAMLMessage{`,
		`ServiceProviderProperties:` + strings.Replace(this.ServiceProviderProperties.String(), "ServiceProviderProperties", "ServiceProviderProperties", 1) + `,`,
		`ProviderMetadata:` + strings.Replace(this.ProviderMetadata.String(), "ProviderMetadata", "ProviderMetadata", 1) + `,`,
		`ApplicationTag:` + strings.Replace(this.ApplicationTag.String(), "ApplicationTagging", "ApplicationTagging", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringSaml(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Certificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Certificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Certificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certificate = append(m.Certificate, &schema.ObjectRefType{})
			if err := m.Certificate[len(m.Certificate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UniformResourceName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UniformResourceName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UniformResourceName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Urn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Urn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UniformResourceLocator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UniformResourceLocator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UniformResourceLocator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AudienceUri) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AudienceUri: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AudienceUri: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniformResourceLocator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UniformResourceLocator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AudienceUriChoice = &AudienceUri_UniformResourceLocator{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniformResourceName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UniformResourceName{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AudienceUriChoice = &AudienceUri_UniformResourceName{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignAuthenticationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignAuthenticationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignAuthenticationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoAuthReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SignAuthTypeChoice = &SignAuthenticationRequest_NoAuthReq{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Certificate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SignAuthTypeChoice = &SignAuthenticationRequest_SignAuth{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WantEncryptedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WantEncryptedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WantEncryptedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoEncryptReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WantEncryptedRequest = &WantEncryptedRequest_NoEncryptReq{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Certificate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WantEncryptedRequest = &WantEncryptedRequest_EncryptReq{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceProviderProperties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceProviderProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceProviderProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudienceUri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AudienceUri == nil {
				m.AudienceUri = &AudienceUri{}
			}
			if err := m.AudienceUri.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= AssertionConsumerServiceBinding(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignAuthenticationRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignAuthenticationRequest == nil {
				m.SignAuthenticationRequest = &SignAuthenticationRequest{}
			}
			if err := m.SignAuthenticationRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WantEncryptedAssertion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WantEncryptedAssertion == nil {
				m.WantEncryptedAssertion = &WantEncryptedRequest{}
			}
			if err := m.WantEncryptedAssertion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceAuthentication", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceAuthentication = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WantSignedAssertion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WantSignedAssertion = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplicationTagging) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplicationTagging: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplicationTagging: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamlAppTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SamlAppTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceProviderMetadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceProviderMetadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdpProviderMetadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdpProviderMetadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SAMLMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SAMLMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SAMLMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceProviderProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceProviderProperties == nil {
				m.ServiceProviderProperties = &ServiceProviderProperties{}
			}
			if err := m.ServiceProviderProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProviderMetadata == nil {
				m.ProviderMetadata = &ProviderMetadata{}
			}
			if err := m.ProviderMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationTag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplicationTag == nil {
				m.ApplicationTag = &ApplicationTagging{}
			}
			if err := m.ApplicationTag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSaml(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSaml
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSaml
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSaml
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSaml        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSaml          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSaml = fmt.Errorf("proto: unexpected end of group")
)
