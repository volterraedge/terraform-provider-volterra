// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/uztna/uztna_flow/saml.proto

package uztna_flow

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/api_group_element"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Assertion Consumer Service Binding
//
// x-displayName: "Assertion Consumer Service Binding"
// Binding  message
type AssertionConsumerServiceBinding int32

const (
	// x-displayName: " Post"
	POST AssertionConsumerServiceBinding = 0
	// x-displayName: " Redirect"
	REDIRECT AssertionConsumerServiceBinding = 1
)

var AssertionConsumerServiceBinding_name = map[int32]string{
	0: "POST",
	1: "REDIRECT",
}

var AssertionConsumerServiceBinding_value = map[string]int32{
	"POST":     0,
	"REDIRECT": 1,
}

func (AssertionConsumerServiceBinding) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{0}
}

// TLS Certificate
//
// x-displayName: "Certificate"
// This is used to import or create new certificate for tls communication
type Certificate struct {
	// TLS Certificates
	//
	// x-displayName: "TLS Certificates"
	// Select/Add one or more TLS Certificate objects to associate with this uztna flow
	Certificate []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=certificate,proto3" json:"certificate,omitempty"`
}

func (m *Certificate) Reset()      { *m = Certificate{} }
func (*Certificate) ProtoMessage() {}
func (*Certificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{0}
}
func (m *Certificate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Certificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Certificate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Certificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Certificate.Merge(m, src)
}
func (m *Certificate) XXX_Size() int {
	return m.Size()
}
func (m *Certificate) XXX_DiscardUnknown() {
	xxx_messageInfo_Certificate.DiscardUnknown(m)
}

var xxx_messageInfo_Certificate proto.InternalMessageInfo

func (m *Certificate) GetCertificate() []*schema.ObjectRefType {
	if m != nil {
		return m.Certificate
	}
	return nil
}

// Uniform Resource Name
//
// x-displayName: "Uniform Resource Name"
// Uniform Resource Name to identify the Uniform resource locator
type UniformResourceName struct {
	// Uniform Resource Name
	//
	// x-displayName: "URN"
	// x-required
	// Name of Uniform resource
	Urn string `protobuf:"bytes,1,opt,name=urn,proto3" json:"urn,omitempty"`
	// Host Name
	//
	// x-displayName: "Host Name"
	// x-required
	// Host name of Uniform resource
	HostName string `protobuf:"bytes,2,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
}

func (m *UniformResourceName) Reset()      { *m = UniformResourceName{} }
func (*UniformResourceName) ProtoMessage() {}
func (*UniformResourceName) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{1}
}
func (m *UniformResourceName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UniformResourceName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UniformResourceName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UniformResourceName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UniformResourceName.Merge(m, src)
}
func (m *UniformResourceName) XXX_Size() int {
	return m.Size()
}
func (m *UniformResourceName) XXX_DiscardUnknown() {
	xxx_messageInfo_UniformResourceName.DiscardUnknown(m)
}

var xxx_messageInfo_UniformResourceName proto.InternalMessageInfo

func (m *UniformResourceName) GetUrn() string {
	if m != nil {
		return m.Urn
	}
	return ""
}

func (m *UniformResourceName) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

// Uniform Resource Locator
//
// x-displayName: "Uniform Resource Locator"
type UniformResourceLocator struct {
	// Uniform Resource Name
	//
	// x-displayName: "URL"
	// x-example: https://sp.example.com
	// x-required
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *UniformResourceLocator) Reset()      { *m = UniformResourceLocator{} }
func (*UniformResourceLocator) ProtoMessage() {}
func (*UniformResourceLocator) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{2}
}
func (m *UniformResourceLocator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UniformResourceLocator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UniformResourceLocator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UniformResourceLocator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UniformResourceLocator.Merge(m, src)
}
func (m *UniformResourceLocator) XXX_Size() int {
	return m.Size()
}
func (m *UniformResourceLocator) XXX_DiscardUnknown() {
	xxx_messageInfo_UniformResourceLocator.DiscardUnknown(m)
}

var xxx_messageInfo_UniformResourceLocator proto.InternalMessageInfo

func (m *UniformResourceLocator) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// Audience URI
//
// x-displayName: "Audience URI"
// Audience URI
// Select Audience URI
type AudienceUri struct {
	// Uniform Resource Locator
	//
	// x-displayName: " "
	//
	// Types that are valid to be assigned to AudienceUriChoice:
	//	*AudienceUri_UniformResourceLocator
	//	*AudienceUri_UniformResourceName
	AudienceUriChoice isAudienceUri_AudienceUriChoice `protobuf_oneof:"audience_uri_choice"`
}

func (m *AudienceUri) Reset()      { *m = AudienceUri{} }
func (*AudienceUri) ProtoMessage() {}
func (*AudienceUri) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{3}
}
func (m *AudienceUri) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AudienceUri) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AudienceUri.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AudienceUri) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AudienceUri.Merge(m, src)
}
func (m *AudienceUri) XXX_Size() int {
	return m.Size()
}
func (m *AudienceUri) XXX_DiscardUnknown() {
	xxx_messageInfo_AudienceUri.DiscardUnknown(m)
}

var xxx_messageInfo_AudienceUri proto.InternalMessageInfo

type isAudienceUri_AudienceUriChoice interface {
	isAudienceUri_AudienceUriChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AudienceUri_UniformResourceLocator struct {
	UniformResourceLocator *UniformResourceLocator `protobuf:"bytes,1,opt,name=uniform_resource_locator,json=uniformResourceLocator,proto3,oneof" json:"uniform_resource_locator,omitempty"`
}
type AudienceUri_UniformResourceName struct {
	UniformResourceName *UniformResourceName `protobuf:"bytes,2,opt,name=uniform_resource_name,json=uniformResourceName,proto3,oneof" json:"uniform_resource_name,omitempty"`
}

func (*AudienceUri_UniformResourceLocator) isAudienceUri_AudienceUriChoice() {}
func (*AudienceUri_UniformResourceName) isAudienceUri_AudienceUriChoice()    {}

func (m *AudienceUri) GetAudienceUriChoice() isAudienceUri_AudienceUriChoice {
	if m != nil {
		return m.AudienceUriChoice
	}
	return nil
}

func (m *AudienceUri) GetUniformResourceLocator() *UniformResourceLocator {
	if x, ok := m.GetAudienceUriChoice().(*AudienceUri_UniformResourceLocator); ok {
		return x.UniformResourceLocator
	}
	return nil
}

func (m *AudienceUri) GetUniformResourceName() *UniformResourceName {
	if x, ok := m.GetAudienceUriChoice().(*AudienceUri_UniformResourceName); ok {
		return x.UniformResourceName
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AudienceUri) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AudienceUri_UniformResourceLocator)(nil),
		(*AudienceUri_UniformResourceName)(nil),
	}
}

// Sign_Authentication_Request
//
// x-displayName: "Sign_Authentication_Request"
// Sign_Authentication_Request
// x-required
type SignAuthenticationRequest struct {
	// Sign_Authentication_Request
	//
	// x-displayName: "Sign Authentication Request"
	// x-required
	// When Response Cache is enabled, clients will receive persistent answers
	//
	// Types that are valid to be assigned to SignAuthTypeChoice:
	//	*SignAuthenticationRequest_NoAuthReq
	//	*SignAuthenticationRequest_SignAuth
	SignAuthTypeChoice isSignAuthenticationRequest_SignAuthTypeChoice `protobuf_oneof:"sign_auth_type_choice"`
}

func (m *SignAuthenticationRequest) Reset()      { *m = SignAuthenticationRequest{} }
func (*SignAuthenticationRequest) ProtoMessage() {}
func (*SignAuthenticationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{4}
}
func (m *SignAuthenticationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignAuthenticationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignAuthenticationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignAuthenticationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignAuthenticationRequest.Merge(m, src)
}
func (m *SignAuthenticationRequest) XXX_Size() int {
	return m.Size()
}
func (m *SignAuthenticationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SignAuthenticationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SignAuthenticationRequest proto.InternalMessageInfo

type isSignAuthenticationRequest_SignAuthTypeChoice interface {
	isSignAuthenticationRequest_SignAuthTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SignAuthenticationRequest_NoAuthReq struct {
	NoAuthReq *schema.Empty `protobuf:"bytes,2,opt,name=no_auth_req,json=noAuthReq,proto3,oneof" json:"no_auth_req,omitempty"`
}
type SignAuthenticationRequest_SignAuth struct {
	SignAuth *Certificate `protobuf:"bytes,3,opt,name=sign_auth,json=signAuth,proto3,oneof" json:"sign_auth,omitempty"`
}

func (*SignAuthenticationRequest_NoAuthReq) isSignAuthenticationRequest_SignAuthTypeChoice() {}
func (*SignAuthenticationRequest_SignAuth) isSignAuthenticationRequest_SignAuthTypeChoice()  {}

func (m *SignAuthenticationRequest) GetSignAuthTypeChoice() isSignAuthenticationRequest_SignAuthTypeChoice {
	if m != nil {
		return m.SignAuthTypeChoice
	}
	return nil
}

func (m *SignAuthenticationRequest) GetNoAuthReq() *schema.Empty {
	if x, ok := m.GetSignAuthTypeChoice().(*SignAuthenticationRequest_NoAuthReq); ok {
		return x.NoAuthReq
	}
	return nil
}

func (m *SignAuthenticationRequest) GetSignAuth() *Certificate {
	if x, ok := m.GetSignAuthTypeChoice().(*SignAuthenticationRequest_SignAuth); ok {
		return x.SignAuth
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SignAuthenticationRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SignAuthenticationRequest_NoAuthReq)(nil),
		(*SignAuthenticationRequest_SignAuth)(nil),
	}
}

// Want Encrypted Request
//
// x-displayName: "Want Encrypted Request"
// WantEncryptedRequest
// x-required
type WantEncryptedRequest struct {
	// Want Encrypted Request
	//
	// x-displayName: "Want Encrypted Request"
	// x-required
	// When Response Cache is enabled, clients will receive persistent answers
	//
	// Types that are valid to be assigned to WantEncryptedRequest:
	//	*WantEncryptedRequest_NoEncryptReq
	//	*WantEncryptedRequest_EncryptReq
	WantEncryptedRequest isWantEncryptedRequest_WantEncryptedRequest `protobuf_oneof:"want_encrypted_request"`
}

func (m *WantEncryptedRequest) Reset()      { *m = WantEncryptedRequest{} }
func (*WantEncryptedRequest) ProtoMessage() {}
func (*WantEncryptedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{5}
}
func (m *WantEncryptedRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WantEncryptedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WantEncryptedRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WantEncryptedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WantEncryptedRequest.Merge(m, src)
}
func (m *WantEncryptedRequest) XXX_Size() int {
	return m.Size()
}
func (m *WantEncryptedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WantEncryptedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WantEncryptedRequest proto.InternalMessageInfo

type isWantEncryptedRequest_WantEncryptedRequest interface {
	isWantEncryptedRequest_WantEncryptedRequest()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type WantEncryptedRequest_NoEncryptReq struct {
	NoEncryptReq *schema.Empty `protobuf:"bytes,2,opt,name=no_encrypt_req,json=noEncryptReq,proto3,oneof" json:"no_encrypt_req,omitempty"`
}
type WantEncryptedRequest_EncryptReq struct {
	EncryptReq *Certificate `protobuf:"bytes,3,opt,name=encrypt_req,json=encryptReq,proto3,oneof" json:"encrypt_req,omitempty"`
}

func (*WantEncryptedRequest_NoEncryptReq) isWantEncryptedRequest_WantEncryptedRequest() {}
func (*WantEncryptedRequest_EncryptReq) isWantEncryptedRequest_WantEncryptedRequest()   {}

func (m *WantEncryptedRequest) GetWantEncryptedRequest() isWantEncryptedRequest_WantEncryptedRequest {
	if m != nil {
		return m.WantEncryptedRequest
	}
	return nil
}

func (m *WantEncryptedRequest) GetNoEncryptReq() *schema.Empty {
	if x, ok := m.GetWantEncryptedRequest().(*WantEncryptedRequest_NoEncryptReq); ok {
		return x.NoEncryptReq
	}
	return nil
}

func (m *WantEncryptedRequest) GetEncryptReq() *Certificate {
	if x, ok := m.GetWantEncryptedRequest().(*WantEncryptedRequest_EncryptReq); ok {
		return x.EncryptReq
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*WantEncryptedRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*WantEncryptedRequest_NoEncryptReq)(nil),
		(*WantEncryptedRequest_EncryptReq)(nil),
	}
}

// Service Provider Properties
//
// x-displayName: "Service Provider Properties"
// Service Provider Properties.
type ServiceProviderProperties struct {
	// Audience URI
	//
	// x-displayName: "Audience URI(Entity ID)"
	// x-required
	AudienceUri *AudienceUri `protobuf:"bytes,1,opt,name=audience_uri,json=audienceUri,proto3" json:"audience_uri,omitempty"`
	// Relay State
	//
	// x-displayName: "Relay State"
	RelayState string `protobuf:"bytes,2,opt,name=relay_state,json=relayState,proto3" json:"relay_state,omitempty"`
	// Assertion Consumer Service Binding
	//
	// x-displayName: "Assertion Consumer Service Binding"
	// Binding  message
	// x-required
	Type AssertionConsumerServiceBinding `protobuf:"varint,3,opt,name=type,proto3,enum=ves.io.schema.uztna.uztna_flow.AssertionConsumerServiceBinding" json:"type,omitempty"`
	// Sign Authentication Requests
	//
	// x-displayName: "Sign Authentication Requests"
	// x-required
	SignAuthenticationRequest *SignAuthenticationRequest `protobuf:"bytes,4,opt,name=sign_authentication_request,json=signAuthenticationRequest,proto3" json:"sign_authentication_request,omitempty"`
	// Want Encrypted Assertion
	//
	// x-displayName: "Want Encrypted Assertion"
	// x-required
	WantEncryptedAssertion *WantEncryptedRequest `protobuf:"bytes,5,opt,name=want_encrypted_assertion,json=wantEncryptedAssertion,proto3" json:"want_encrypted_assertion,omitempty"`
	// Force Authentication
	//
	// x-displayName: "Force Authentication"
	ForceAuthentication bool `protobuf:"varint,6,opt,name=force_authentication,json=forceAuthentication,proto3" json:"force_authentication,omitempty"`
	// Want Signed Assertion
	//
	// x-displayName: "Want Signed Assertion"
	WantSignedAssertion bool `protobuf:"varint,7,opt,name=want_signed_assertion,json=wantSignedAssertion,proto3" json:"want_signed_assertion,omitempty"`
}

func (m *ServiceProviderProperties) Reset()      { *m = ServiceProviderProperties{} }
func (*ServiceProviderProperties) ProtoMessage() {}
func (*ServiceProviderProperties) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{6}
}
func (m *ServiceProviderProperties) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceProviderProperties) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceProviderProperties.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceProviderProperties) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceProviderProperties.Merge(m, src)
}
func (m *ServiceProviderProperties) XXX_Size() int {
	return m.Size()
}
func (m *ServiceProviderProperties) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceProviderProperties.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceProviderProperties proto.InternalMessageInfo

func (m *ServiceProviderProperties) GetAudienceUri() *AudienceUri {
	if m != nil {
		return m.AudienceUri
	}
	return nil
}

func (m *ServiceProviderProperties) GetRelayState() string {
	if m != nil {
		return m.RelayState
	}
	return ""
}

func (m *ServiceProviderProperties) GetType() AssertionConsumerServiceBinding {
	if m != nil {
		return m.Type
	}
	return POST
}

func (m *ServiceProviderProperties) GetSignAuthenticationRequest() *SignAuthenticationRequest {
	if m != nil {
		return m.SignAuthenticationRequest
	}
	return nil
}

func (m *ServiceProviderProperties) GetWantEncryptedAssertion() *WantEncryptedRequest {
	if m != nil {
		return m.WantEncryptedAssertion
	}
	return nil
}

func (m *ServiceProviderProperties) GetForceAuthentication() bool {
	if m != nil {
		return m.ForceAuthentication
	}
	return false
}

func (m *ServiceProviderProperties) GetWantSignedAssertion() bool {
	if m != nil {
		return m.WantSignedAssertion
	}
	return false
}

// Application Tagging
//
// x-displayName: "ApplicationTagging"
type ApplicationTagging struct {
	// Applicatin Tagging
	//
	// x-displayName: "Name of SAML attribute that contains application tag"
	// x-required
	SamlAppTag string `protobuf:"bytes,1,opt,name=saml_app_tag,json=samlAppTag,proto3" json:"saml_app_tag,omitempty"`
}

func (m *ApplicationTagging) Reset()      { *m = ApplicationTagging{} }
func (*ApplicationTagging) ProtoMessage() {}
func (*ApplicationTagging) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{7}
}
func (m *ApplicationTagging) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplicationTagging) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplicationTagging.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplicationTagging) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationTagging.Merge(m, src)
}
func (m *ApplicationTagging) XXX_Size() int {
	return m.Size()
}
func (m *ApplicationTagging) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationTagging.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationTagging proto.InternalMessageInfo

func (m *ApplicationTagging) GetSamlAppTag() string {
	if m != nil {
		return m.SamlAppTag
	}
	return ""
}

// Signing Algoritm
//
// x-displayName: "Signing Algorithm"
// x-example: sha1/sha256/sha384/sha512
type SignAlgorithm struct {
	// Supported Sign Algo
	//
	// x-displayName: "Signing Algoritm"
	// x-required
	// Supported Signing Algorithm List
	//
	// Types that are valid to be assigned to SignAlgo:
	//	*SignAlgorithm_RsaSha1
	//	*SignAlgorithm_RsaSha256
	//	*SignAlgorithm_RsaSha384
	//	*SignAlgorithm_RsaSha512
	SignAlgo isSignAlgorithm_SignAlgo `protobuf_oneof:"sign_algo"`
}

func (m *SignAlgorithm) Reset()      { *m = SignAlgorithm{} }
func (*SignAlgorithm) ProtoMessage() {}
func (*SignAlgorithm) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{8}
}
func (m *SignAlgorithm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignAlgorithm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignAlgorithm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignAlgorithm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignAlgorithm.Merge(m, src)
}
func (m *SignAlgorithm) XXX_Size() int {
	return m.Size()
}
func (m *SignAlgorithm) XXX_DiscardUnknown() {
	xxx_messageInfo_SignAlgorithm.DiscardUnknown(m)
}

var xxx_messageInfo_SignAlgorithm proto.InternalMessageInfo

type isSignAlgorithm_SignAlgo interface {
	isSignAlgorithm_SignAlgo()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SignAlgorithm_RsaSha1 struct {
	RsaSha1 *schema.Empty `protobuf:"bytes,5,opt,name=rsa_sha1,json=rsaSha1,proto3,oneof" json:"rsa_sha1,omitempty"`
}
type SignAlgorithm_RsaSha256 struct {
	RsaSha256 *schema.Empty `protobuf:"bytes,6,opt,name=rsa_sha256,json=rsaSha256,proto3,oneof" json:"rsa_sha256,omitempty"`
}
type SignAlgorithm_RsaSha384 struct {
	RsaSha384 *schema.Empty `protobuf:"bytes,7,opt,name=rsa_sha384,json=rsaSha384,proto3,oneof" json:"rsa_sha384,omitempty"`
}
type SignAlgorithm_RsaSha512 struct {
	RsaSha512 *schema.Empty `protobuf:"bytes,8,opt,name=rsa_sha512,json=rsaSha512,proto3,oneof" json:"rsa_sha512,omitempty"`
}

func (*SignAlgorithm_RsaSha1) isSignAlgorithm_SignAlgo()   {}
func (*SignAlgorithm_RsaSha256) isSignAlgorithm_SignAlgo() {}
func (*SignAlgorithm_RsaSha384) isSignAlgorithm_SignAlgo() {}
func (*SignAlgorithm_RsaSha512) isSignAlgorithm_SignAlgo() {}

func (m *SignAlgorithm) GetSignAlgo() isSignAlgorithm_SignAlgo {
	if m != nil {
		return m.SignAlgo
	}
	return nil
}

func (m *SignAlgorithm) GetRsaSha1() *schema.Empty {
	if x, ok := m.GetSignAlgo().(*SignAlgorithm_RsaSha1); ok {
		return x.RsaSha1
	}
	return nil
}

func (m *SignAlgorithm) GetRsaSha256() *schema.Empty {
	if x, ok := m.GetSignAlgo().(*SignAlgorithm_RsaSha256); ok {
		return x.RsaSha256
	}
	return nil
}

func (m *SignAlgorithm) GetRsaSha384() *schema.Empty {
	if x, ok := m.GetSignAlgo().(*SignAlgorithm_RsaSha384); ok {
		return x.RsaSha384
	}
	return nil
}

func (m *SignAlgorithm) GetRsaSha512() *schema.Empty {
	if x, ok := m.GetSignAlgo().(*SignAlgorithm_RsaSha512); ok {
		return x.RsaSha512
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SignAlgorithm) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SignAlgorithm_RsaSha1)(nil),
		(*SignAlgorithm_RsaSha256)(nil),
		(*SignAlgorithm_RsaSha384)(nil),
		(*SignAlgorithm_RsaSha512)(nil),
	}
}

// IDP Secuirty Properties
//
// x-displayName: "Secuirty Properties"
//
// Identity Provider's Securuty Property
type IdpSecurityProperty struct {
	// Authentication Request Must be Signed
	//
	// x-displayName: "WantAuthRequestSigned"
	// x-required
	// Option either Authentication request sent as signed or not.
	//
	// Types that are valid to be assigned to AuthRequestSigned:
	//	*IdpSecurityProperty_No
	//	*IdpSecurityProperty_Yes
	AuthRequestSigned isIdpSecurityProperty_AuthRequestSigned `protobuf_oneof:"auth_request_signed"`
}

func (m *IdpSecurityProperty) Reset()      { *m = IdpSecurityProperty{} }
func (*IdpSecurityProperty) ProtoMessage() {}
func (*IdpSecurityProperty) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{9}
}
func (m *IdpSecurityProperty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IdpSecurityProperty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IdpSecurityProperty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IdpSecurityProperty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdpSecurityProperty.Merge(m, src)
}
func (m *IdpSecurityProperty) XXX_Size() int {
	return m.Size()
}
func (m *IdpSecurityProperty) XXX_DiscardUnknown() {
	xxx_messageInfo_IdpSecurityProperty.DiscardUnknown(m)
}

var xxx_messageInfo_IdpSecurityProperty proto.InternalMessageInfo

type isIdpSecurityProperty_AuthRequestSigned interface {
	isIdpSecurityProperty_AuthRequestSigned()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type IdpSecurityProperty_No struct {
	No *schema.Empty `protobuf:"bytes,2,opt,name=no,proto3,oneof" json:"no,omitempty"`
}
type IdpSecurityProperty_Yes struct {
	Yes *SignAlgorithm `protobuf:"bytes,3,opt,name=yes,proto3,oneof" json:"yes,omitempty"`
}

func (*IdpSecurityProperty_No) isIdpSecurityProperty_AuthRequestSigned()  {}
func (*IdpSecurityProperty_Yes) isIdpSecurityProperty_AuthRequestSigned() {}

func (m *IdpSecurityProperty) GetAuthRequestSigned() isIdpSecurityProperty_AuthRequestSigned {
	if m != nil {
		return m.AuthRequestSigned
	}
	return nil
}

func (m *IdpSecurityProperty) GetNo() *schema.Empty {
	if x, ok := m.GetAuthRequestSigned().(*IdpSecurityProperty_No); ok {
		return x.No
	}
	return nil
}

func (m *IdpSecurityProperty) GetYes() *SignAlgorithm {
	if x, ok := m.GetAuthRequestSigned().(*IdpSecurityProperty_Yes); ok {
		return x.Yes
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*IdpSecurityProperty) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*IdpSecurityProperty_No)(nil),
		(*IdpSecurityProperty_Yes)(nil),
	}
}

// Identity Provider Metadata
//
// x-displayName: "Identity Provider Metadata"
// Identity Provider Metadata is an XML file containing information about your identity provider (IdP),
// including security certificates and endpoints used for single sign-on (SSO).
type IdentityProvider struct {
	// Name
	//
	// x-displayName: "Name"
	// x-example: "idp-abc34ef"
	// Filled by the internal service which is used to refer the Identity provide
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Issuer Identity URL
	//
	// x-displayName: "Issuer Identity URL"
	// x-required
	// x-example: "https://issuerentity.com"
	//  URI that is assigned to the entity,
	// and it is used to identify the entity in SAML messages
	Issuer string `protobuf:"bytes,2,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// SSO Service URL
	//
	// x-displayName: "SSO Service URL"
	// x-required
	// x-example: "https://issuersignon.com"
	//  URL required for SSO authentication
	SsoUrl string `protobuf:"bytes,3,opt,name=sso_url,json=ssoUrl,proto3" json:"sso_url,omitempty"`
	// SSO Service Binding
	//
	// x-displayName: "SSO Service Binding"
	// x-required
	// Request type of SSO service binding
	//
	// Types that are valid to be assigned to SsoServiceBinding:
	//	*IdentityProvider_Post
	//	*IdentityProvider_Redirect
	SsoServiceBinding isIdentityProvider_SsoServiceBinding `protobuf_oneof:"sso_service_binding"`
	// Identity Provider's Assertion Verification Certificate
	//
	// x-displayName: "Identity Provider's Assertion Verification Certificate"
	//
	// Used for identity provider's assertion verification
	IdpAssertVerificationCert *Certificate `protobuf:"bytes,7,opt,name=idp_assert_verification_cert,json=idpAssertVerificationCert,proto3" json:"idp_assert_verification_cert,omitempty"`
	// IDP Security Properties
	//
	// x-displayName: "Security Properties"
	// x-required
	// Identity Provider's Security Property
	IdpSecurityProperty *IdpSecurityProperty `protobuf:"bytes,8,opt,name=idp_security_property,json=idpSecurityProperty,proto3" json:"idp_security_property,omitempty"`
}

func (m *IdentityProvider) Reset()      { *m = IdentityProvider{} }
func (*IdentityProvider) ProtoMessage() {}
func (*IdentityProvider) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{10}
}
func (m *IdentityProvider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IdentityProvider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IdentityProvider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IdentityProvider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdentityProvider.Merge(m, src)
}
func (m *IdentityProvider) XXX_Size() int {
	return m.Size()
}
func (m *IdentityProvider) XXX_DiscardUnknown() {
	xxx_messageInfo_IdentityProvider.DiscardUnknown(m)
}

var xxx_messageInfo_IdentityProvider proto.InternalMessageInfo

type isIdentityProvider_SsoServiceBinding interface {
	isIdentityProvider_SsoServiceBinding()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type IdentityProvider_Post struct {
	Post *schema.Empty `protobuf:"bytes,5,opt,name=post,proto3,oneof" json:"post,omitempty"`
}
type IdentityProvider_Redirect struct {
	Redirect *schema.Empty `protobuf:"bytes,6,opt,name=redirect,proto3,oneof" json:"redirect,omitempty"`
}

func (*IdentityProvider_Post) isIdentityProvider_SsoServiceBinding()     {}
func (*IdentityProvider_Redirect) isIdentityProvider_SsoServiceBinding() {}

func (m *IdentityProvider) GetSsoServiceBinding() isIdentityProvider_SsoServiceBinding {
	if m != nil {
		return m.SsoServiceBinding
	}
	return nil
}

func (m *IdentityProvider) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *IdentityProvider) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *IdentityProvider) GetSsoUrl() string {
	if m != nil {
		return m.SsoUrl
	}
	return ""
}

func (m *IdentityProvider) GetPost() *schema.Empty {
	if x, ok := m.GetSsoServiceBinding().(*IdentityProvider_Post); ok {
		return x.Post
	}
	return nil
}

func (m *IdentityProvider) GetRedirect() *schema.Empty {
	if x, ok := m.GetSsoServiceBinding().(*IdentityProvider_Redirect); ok {
		return x.Redirect
	}
	return nil
}

func (m *IdentityProvider) GetIdpAssertVerificationCert() *Certificate {
	if m != nil {
		return m.IdpAssertVerificationCert
	}
	return nil
}

func (m *IdentityProvider) GetIdpSecurityProperty() *IdpSecurityProperty {
	if m != nil {
		return m.IdpSecurityProperty
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*IdentityProvider) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*IdentityProvider_Post)(nil),
		(*IdentityProvider_Redirect)(nil),
	}
}

// SAML Message
//
// x-displayName: "SAML Message"
//
// SAML Flow type
type SAMLMessage struct {
	// Service Provider Properties
	//
	// x-displayName: "Service Provider Properties "
	// x-required
	// Service Provider Properties
	ServiceProviderProperties *ServiceProviderProperties `protobuf:"bytes,1,opt,name=service_provider_properties,json=serviceProviderProperties,proto3" json:"service_provider_properties,omitempty"`
	// Application Tagging
	//
	// x-displayName: "Application Tagging "
	// x-required
	// Application Tagging
	ApplicationTag *ApplicationTagging `protobuf:"bytes,3,opt,name=application_tag,json=applicationTag,proto3" json:"application_tag,omitempty"`
	// Identity Provider
	//
	// x-displayName: "Identity Provider"
	// x-required
	// Identity Provider containing information about your identity provider (IdP),
	// including security certificates and endpoints used for single sign-on (SSO).
	Idp *IdentityProvider `protobuf:"bytes,4,opt,name=idp,proto3" json:"idp,omitempty"`
}

func (m *SAMLMessage) Reset()      { *m = SAMLMessage{} }
func (*SAMLMessage) ProtoMessage() {}
func (*SAMLMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b77cd57ae9845f, []int{11}
}
func (m *SAMLMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SAMLMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SAMLMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SAMLMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SAMLMessage.Merge(m, src)
}
func (m *SAMLMessage) XXX_Size() int {
	return m.Size()
}
func (m *SAMLMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_SAMLMessage.DiscardUnknown(m)
}

var xxx_messageInfo_SAMLMessage proto.InternalMessageInfo

func (m *SAMLMessage) GetServiceProviderProperties() *ServiceProviderProperties {
	if m != nil {
		return m.ServiceProviderProperties
	}
	return nil
}

func (m *SAMLMessage) GetApplicationTag() *ApplicationTagging {
	if m != nil {
		return m.ApplicationTag
	}
	return nil
}

func (m *SAMLMessage) GetIdp() *IdentityProvider {
	if m != nil {
		return m.Idp
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.uztna.uztna_flow.AssertionConsumerServiceBinding", AssertionConsumerServiceBinding_name, AssertionConsumerServiceBinding_value)
	proto.RegisterType((*Certificate)(nil), "ves.io.schema.uztna.uztna_flow.Certificate")
	proto.RegisterType((*UniformResourceName)(nil), "ves.io.schema.uztna.uztna_flow.UniformResourceName")
	proto.RegisterType((*UniformResourceLocator)(nil), "ves.io.schema.uztna.uztna_flow.UniformResourceLocator")
	proto.RegisterType((*AudienceUri)(nil), "ves.io.schema.uztna.uztna_flow.AudienceUri")
	proto.RegisterType((*SignAuthenticationRequest)(nil), "ves.io.schema.uztna.uztna_flow.SignAuthenticationRequest")
	proto.RegisterType((*WantEncryptedRequest)(nil), "ves.io.schema.uztna.uztna_flow.WantEncryptedRequest")
	proto.RegisterType((*ServiceProviderProperties)(nil), "ves.io.schema.uztna.uztna_flow.ServiceProviderProperties")
	proto.RegisterType((*ApplicationTagging)(nil), "ves.io.schema.uztna.uztna_flow.ApplicationTagging")
	proto.RegisterType((*SignAlgorithm)(nil), "ves.io.schema.uztna.uztna_flow.SignAlgorithm")
	proto.RegisterType((*IdpSecurityProperty)(nil), "ves.io.schema.uztna.uztna_flow.IdpSecurityProperty")
	proto.RegisterType((*IdentityProvider)(nil), "ves.io.schema.uztna.uztna_flow.IdentityProvider")
	proto.RegisterType((*SAMLMessage)(nil), "ves.io.schema.uztna.uztna_flow.SAMLMessage")
}

func init() {
	proto.RegisterFile("ves.io/schema/uztna/uztna_flow/saml.proto", fileDescriptor_d2b77cd57ae9845f)
}

var fileDescriptor_d2b77cd57ae9845f = []byte{
	// 1464 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0xcd, 0x6f, 0x1b, 0x45,
	0x1b, 0xf7, 0xd8, 0x9b, 0x64, 0xf3, 0x38, 0x4d, 0xfd, 0x8e, 0x93, 0xbe, 0x4e, 0x5b, 0x39, 0x7e,
	0xfd, 0x8a, 0x2a, 0x24, 0xae, 0xd3, 0x6c, 0x3e, 0x68, 0x51, 0x25, 0x14, 0x97, 0x48, 0x49, 0xd4,
	0xa6, 0xd5, 0x3a, 0x01, 0x09, 0x84, 0x56, 0x1b, 0x7b, 0xb2, 0x5e, 0xb0, 0x77, 0xb6, 0x33, 0xbb,
	0x69, 0x5d, 0x51, 0x94, 0x23, 0xe2, 0x42, 0xff, 0x09, 0x24, 0xc4, 0x01, 0xee, 0xf8, 0x92, 0x23,
	0x20, 0x24, 0x72, 0xac, 0x38, 0x51, 0xf7, 0x40, 0xb9, 0xf5, 0xc8, 0x11, 0xcd, 0xee, 0xac, 0x63,
	0x27, 0x71, 0xdd, 0x72, 0x89, 0x9c, 0x79, 0xbe, 0x9f, 0xf9, 0x3d, 0xbf, 0x67, 0x16, 0xde, 0xde,
	0x27, 0xbc, 0x68, 0xd3, 0x79, 0x5e, 0xa9, 0x91, 0x86, 0x39, 0xef, 0x3f, 0xf2, 0x1c, 0xf9, 0xd7,
	0xd8, 0xab, 0xd3, 0x07, 0xf3, 0xdc, 0x6c, 0xd4, 0x8b, 0x2e, 0xa3, 0x1e, 0xc5, 0xd9, 0x50, 0xb5,
	0x18, 0xaa, 0x16, 0x03, 0xa5, 0xe2, 0xb1, 0xea, 0xc5, 0xb9, 0x5e, 0x57, 0xa6, 0x6b, 0x1b, 0x16,
	0xa3, 0xbe, 0x6b, 0x90, 0x3a, 0x69, 0x10, 0xc7, 0x9b, 0xf7, 0x9a, 0x2e, 0xe1, 0xa1, 0xb3, 0x8b,
	0xff, 0xed, 0x55, 0x76, 0x88, 0x27, 0x05, 0x97, 0x7a, 0x05, 0xd4, 0xf5, 0x6c, 0xea, 0x44, 0x56,
	0x53, 0xbd, 0xc2, 0x6e, 0x87, 0x97, 0x7b, 0x45, 0xfb, 0x66, 0xdd, 0xae, 0x9a, 0x1e, 0x91, 0xd2,
	0xdc, 0x09, 0xa9, 0x4d, 0x1e, 0x18, 0xbd, 0xae, 0xa7, 0x4f, 0x6b, 0xf0, 0xee, 0x00, 0xf9, 0x4f,
	0x20, 0x79, 0x8b, 0x30, 0xcf, 0xde, 0xb3, 0x2b, 0xa6, 0x47, 0xf0, 0x16, 0x24, 0x2b, 0xc7, 0xff,
	0x66, 0xe2, 0xb9, 0xc4, 0x4c, 0x52, 0xbb, 0x5c, 0xec, 0xed, 0xd1, 0xdd, 0xdd, 0x4f, 0x49, 0xc5,
	0xd3, 0xc9, 0xde, 0x76, 0xd3, 0x25, 0xa5, 0xf1, 0xef, 0x1e, 0x77, 0xdb, 0xe8, 0xdd, 0xff, 0xe4,
	0x3f, 0x87, 0xf4, 0x8e, 0x63, 0xef, 0x51, 0xd6, 0xd0, 0x09, 0xa7, 0x3e, 0xab, 0x90, 0x2d, 0xb3,
	0x41, 0xf0, 0x22, 0x24, 0x7c, 0xe6, 0x64, 0x50, 0x0e, 0xcd, 0x8c, 0x96, 0xfe, 0xf7, 0x77, 0x0b,
	0xc5, 0x7f, 0xfc, 0xeb, 0x30, 0x31, 0xc4, 0x12, 0x99, 0x03, 0x24, 0x7e, 0x29, 0x2c, 0x9e, 0x42,
	0xf2, 0xe8, 0x09, 0x42, 0xba, 0xd0, 0xc6, 0xd7, 0x60, 0xb4, 0x46, 0xb9, 0x67, 0x38, 0x66, 0x43,
	0x64, 0x26, 0x4c, 0xd3, 0x52, 0xb9, 0x86, 0x3a, 0xf6, 0xaa, 0xae, 0x0a, 0x2d, 0x11, 0x26, 0x7f,
	0x03, 0x2e, 0x9c, 0x88, 0x7e, 0x9b, 0x56, 0x4c, 0x8f, 0x32, 0x3c, 0x2d, 0x12, 0xa8, 0xcb, 0x04,
	0xce, 0x09, 0x63, 0x95, 0x0d, 0xcf, 0x1c, 0xa8, 0x07, 0x43, 0x41, 0xb0, 0x7a, 0xfe, 0x9b, 0x04,
	0x24, 0x57, 0xfd, 0xaa, 0x4d, 0x9c, 0x0a, 0xd9, 0x61, 0x36, 0x66, 0x90, 0xf1, 0x43, 0x57, 0x06,
	0x93, 0xbe, 0x8c, 0x7a, 0xe8, 0x2c, 0xf0, 0x92, 0xd4, 0x56, 0x8a, 0xaf, 0x46, 0x52, 0xf1, 0xec,
	0x54, 0xd6, 0x63, 0xfa, 0x05, 0xff, 0xec, 0x24, 0x29, 0x4c, 0x9e, 0x8a, 0xd9, 0x29, 0x3e, 0xa9,
	0x2d, 0xbe, 0x61, 0x40, 0xd1, 0x92, 0x92, 0xf2, 0xa2, 0x85, 0xd0, 0x7a, 0x4c, 0x4f, 0xfb, 0xa7,
	0x85, 0xef, 0x7e, 0xf1, 0x4b, 0x0b, 0x3d, 0x82, 0x87, 0x30, 0x16, 0x55, 0x9e, 0xdb, 0xd1, 0x37,
	0x66, 0x6b, 0xb0, 0x07, 0x4b, 0xfd, 0xcb, 0xd7, 0x32, 0x32, 0x4e, 0x2e, 0xf2, 0x95, 0x93, 0x05,
	0x40, 0xb1, 0x4f, 0x01, 0xda, 0xe4, 0x29, 0x93, 0x20, 0xb9, 0x39, 0x48, 0x9b, 0x32, 0xb2, 0xe1,
	0x33, 0xdb, 0xa8, 0xd4, 0xa8, 0x5d, 0x21, 0x78, 0xe2, 0xb0, 0x85, 0xd0, 0x51, 0x0b, 0x29, 0xed,
	0x16, 0x52, 0x16, 0x0a, 0x39, 0x4d, 0x00, 0x66, 0x53, 0x51, 0x95, 0xd4, 0x50, 0xfe, 0x57, 0x04,
	0x53, 0x65, 0xdb, 0x72, 0x56, 0x7d, 0xaf, 0x46, 0x1c, 0x4f, 0xa0, 0xce, 0xa6, 0x8e, 0x4e, 0xee,
	0xfb, 0x84, 0x7b, 0x78, 0x05, 0x92, 0x0e, 0x35, 0x4c, 0xdf, 0xab, 0x19, 0x8c, 0xdc, 0x97, 0x7d,
	0x9b, 0x38, 0xd1, 0xb7, 0xb5, 0x86, 0xeb, 0x35, 0xd7, 0x63, 0xfa, 0xa8, 0x43, 0x85, 0x17, 0x9d,
	0xdc, 0xc7, 0x9b, 0x30, 0xca, 0x6d, 0xcb, 0x09, 0x2c, 0x33, 0x89, 0xc0, 0x6a, 0x6e, 0x50, 0xb7,
	0xbb, 0xc6, 0x68, 0x3d, 0xa6, 0xab, 0x5c, 0x26, 0x55, 0x7a, 0x0b, 0x26, 0x3b, 0xbe, 0x0c, 0x31,
	0x7a, 0x51, 0x59, 0x63, 0x47, 0x2d, 0x84, 0x44, 0x49, 0x5a, 0x21, 0xb7, 0xb8, 0xa9, 0xa8, 0x28,
	0x15, 0xcf, 0xff, 0x86, 0x60, 0xe2, 0x43, 0xd3, 0xf1, 0xd6, 0x9c, 0x0a, 0x6b, 0xba, 0x1e, 0xa9,
	0x46, 0x95, 0xdc, 0x84, 0x71, 0x87, 0x1a, 0x24, 0x3c, 0x7e, 0x8d, 0x62, 0xc6, 0x1c, 0x2a, 0x7d,
	0x88, 0x7a, 0xb6, 0x20, 0xd9, 0x6d, 0xfa, 0xaf, 0x2a, 0x02, 0xd2, 0xf1, 0x57, 0xfa, 0x3f, 0x5c,
	0x78, 0x60, 0x3a, 0x5e, 0x94, 0x0f, 0xa9, 0x0a, 0xb7, 0x41, 0x9e, 0xa3, 0xb2, 0x28, 0xa4, 0xc9,
	0x8a, 0x7e, 0x56, 0x60, 0xaa, 0x4c, 0xd8, 0xbe, 0x5d, 0x21, 0xf7, 0x18, 0xdd, 0xb7, 0xab, 0x84,
	0xdd, 0x63, 0xd4, 0x15, 0xae, 0x09, 0xc7, 0x5b, 0x30, 0xd6, 0x7d, 0xe3, 0x72, 0x94, 0x06, 0x66,
	0xd6, 0x35, 0x99, 0x7a, 0xd2, 0xec, 0x1a, 0xd3, 0x39, 0x48, 0x32, 0x52, 0x37, 0x9b, 0x06, 0xf7,
	0x42, 0xfe, 0x12, 0xf3, 0x0d, 0x5d, 0xe4, 0x00, 0x81, 0xb8, 0x2c, 0xa4, 0xb8, 0x0c, 0x8a, 0xb8,
	0x8f, 0xa0, 0x1d, 0xe3, 0xda, 0x7b, 0x03, 0x83, 0x72, 0x2e, 0xb2, 0xa6, 0xce, 0x2d, 0xea, 0x70,
	0xbf, 0x41, 0x98, 0x2c, 0xab, 0x64, 0x3b, 0x55, 0xdb, 0xb1, 0xf4, 0xc0, 0x19, 0x6e, 0xc2, 0xa5,
	0xce, 0x75, 0x1f, 0x03, 0x32, 0xea, 0x4f, 0x46, 0x09, 0x0a, 0xbc, 0x31, 0x28, 0x56, 0x5f, 0x48,
	0xeb, 0x53, 0xbc, 0x2f, 0xda, 0x1d, 0xc8, 0x9c, 0xb8, 0x15, 0x33, 0x4a, 0x39, 0x33, 0x14, 0xc4,
	0x5d, 0x1a, 0x14, 0xf7, 0x2c, 0xec, 0xe9, 0xc1, 0x5d, 0x77, 0x4e, 0x3b, 0x6d, 0xc0, 0x0b, 0x30,
	0xb1, 0x47, 0xc5, 0x4c, 0xf7, 0xd6, 0x9a, 0x19, 0xce, 0xa1, 0x19, 0x55, 0x4f, 0x07, 0xb2, 0xde,
	0x4c, 0xf1, 0x4d, 0x98, 0x0c, 0x52, 0x14, 0x45, 0xf4, 0xe4, 0x37, 0x22, 0x6c, 0x4a, 0xea, 0xef,
	0x2d, 0xa4, 0x78, 0xcc, 0x27, 0x7a, 0x5a, 0xa8, 0x95, 0x03, 0xad, 0x4e, 0xc0, 0x7c, 0x09, 0xf0,
	0xaa, 0xeb, 0xd6, 0xa5, 0xb3, 0x6d, 0xd3, 0xb2, 0x6c, 0xc7, 0xc2, 0x05, 0x18, 0x13, 0xfb, 0xdc,
	0x30, 0x5d, 0xd7, 0xf0, 0x4c, 0x4b, 0x92, 0x7a, 0xcf, 0xa5, 0x0b, 0xf9, 0xaa, 0xeb, 0x6e, 0x9b,
	0x56, 0xfe, 0xeb, 0x38, 0x9c, 0x0b, 0xba, 0x5b, 0xb7, 0x28, 0xb3, 0xbd, 0x5a, 0x03, 0x2f, 0x80,
	0xca, 0xb8, 0x69, 0xf0, 0x9a, 0xb9, 0x20, 0xdb, 0xd4, 0x6f, 0xa8, 0x46, 0x18, 0x37, 0xcb, 0x35,
	0x73, 0x01, 0x2f, 0x03, 0x48, 0x13, 0x6d, 0x79, 0x25, 0xa8, 0xf7, 0x15, 0xb4, 0x12, 0x1a, 0x69,
	0xcb, 0x2b, 0x5d, 0x66, 0x8b, 0xd7, 0x97, 0x82, 0x92, 0x07, 0x9a, 0x2d, 0x5e, 0x5f, 0xea, 0x32,
	0x5b, 0x5e, 0xd0, 0x32, 0xea, 0xeb, 0x98, 0x2d, 0x2f, 0x68, 0xa5, 0x5c, 0x44, 0x62, 0x75, 0x8b,
	0xe2, 0xf4, 0x61, 0x0b, 0x0d, 0x4b, 0x0e, 0x1d, 0x59, 0x2e, 0xac, 0x14, 0xde, 0x29, 0x5c, 0x97,
	0x14, 0xfa, 0x3d, 0x82, 0xf4, 0x46, 0xd5, 0x2d, 0x93, 0x8a, 0xcf, 0x6c, 0xaf, 0x29, 0xa7, 0xb3,
	0x89, 0xaf, 0x40, 0xdc, 0xa1, 0x03, 0x68, 0x26, 0xee, 0x50, 0xbc, 0x0a, 0x89, 0x26, 0xe1, 0x92,
	0x54, 0xae, 0xbe, 0x16, 0xb2, 0xa3, 0xde, 0xaf, 0xc7, 0x74, 0x61, 0x5b, 0xba, 0x22, 0x88, 0x3f,
	0x24, 0x69, 0x81, 0x38, 0x09, 0x0f, 0x7c, 0xfe, 0xb0, 0x85, 0xe2, 0x92, 0x50, 0x12, 0x8b, 0x85,
	0x88, 0x52, 0xfe, 0x4c, 0x40, 0x6a, 0xa3, 0x2a, 0x50, 0x15, 0x64, 0x1b, 0x70, 0x0a, 0xbe, 0x04,
	0x4a, 0xb0, 0x1b, 0xc3, 0xdb, 0x1f, 0x79, 0xfa, 0x18, 0x89, 0x4d, 0xa7, 0x07, 0x87, 0xb8, 0x00,
	0xc3, 0x36, 0xe7, 0x3e, 0x61, 0x92, 0x11, 0x26, 0x3a, 0xe0, 0x48, 0xc9, 0x5f, 0x5f, 0x22, 0xa4,
	0x4b, 0x1d, 0x3c, 0x0b, 0x23, 0x9c, 0x53, 0x43, 0x3c, 0x10, 0x12, 0x81, 0xfa, 0x7f, 0xa2, 0x17,
	0x4a, 0xf8, 0x48, 0x10, 0x2f, 0x92, 0x61, 0xce, 0xe9, 0x0e, 0xab, 0xe3, 0x59, 0x50, 0x5c, 0xca,
	0xbd, 0x01, 0xc0, 0x09, 0x74, 0xb0, 0x06, 0x2a, 0x23, 0x55, 0x9b, 0x91, 0x8a, 0x37, 0x00, 0x33,
	0x1d, 0x3d, 0x5c, 0x87, 0xcb, 0x76, 0xd5, 0x95, 0x83, 0x62, 0xec, 0x13, 0x16, 0x12, 0xb2, 0xa0,
	0x14, 0xf1, 0xce, 0x92, 0x20, 0x7a, 0x13, 0x2a, 0xd7, 0xa7, 0xec, 0xaa, 0x1b, 0xce, 0xd4, 0x07,
	0x5d, 0xee, 0x84, 0x06, 0xb6, 0x60, 0x52, 0x44, 0xe3, 0x12, 0x0a, 0x86, 0x2b, 0xb1, 0x20, 0x41,
	0x37, 0xf0, 0xc5, 0x71, 0x06, 0x8c, 0xf4, 0xb4, 0x7d, 0xfa, 0xb0, 0x34, 0x0d, 0x69, 0xd1, 0x62,
	0x1e, 0x32, 0xa8, 0xb1, 0x1b, 0x52, 0x28, 0x56, 0x0f, 0x5b, 0x68, 0x48, 0xa0, 0x54, 0x42, 0xf3,
	0x87, 0x38, 0x24, 0xcb, 0xab, 0x77, 0x6e, 0xdf, 0x21, 0x9c, 0x9b, 0x56, 0x48, 0xae, 0xd2, 0xc4,
	0x95, 0x17, 0x1f, 0xe5, 0x68, 0x13, 0x2e, 0xb7, 0xc7, 0x60, 0x72, 0xed, 0xb7, 0x8e, 0xf4, 0x29,
	0xde, 0x77, 0x53, 0x7d, 0x0c, 0xe7, 0xcd, 0x63, 0xee, 0x09, 0x88, 0x26, 0x44, 0xbc, 0x36, 0x70,
	0x6f, 0x9c, 0xa2, 0x2c, 0x7d, 0xdc, 0xec, 0x39, 0xc3, 0x25, 0x48, 0xd8, 0x55, 0x57, 0x2e, 0x87,
	0x6b, 0x83, 0xbb, 0xdc, 0x8b, 0x7d, 0x5d, 0x18, 0x6f, 0x2a, 0x6a, 0x3c, 0x95, 0x98, 0xbd, 0x01,
	0xd3, 0x03, 0xf6, 0x14, 0x56, 0x41, 0xb9, 0x77, 0xb7, 0xbc, 0x9d, 0x8a, 0xe1, 0x31, 0x50, 0xf5,
	0xb5, 0xf7, 0x37, 0xf4, 0xb5, 0x5b, 0xdb, 0x29, 0x54, 0xfa, 0x0a, 0x1d, 0x3d, 0xcb, 0xc6, 0x9e,
	0x3e, 0xcb, 0xc6, 0x5e, 0x3e, 0xcb, 0xa2, 0x83, 0x76, 0x16, 0x7d, 0xdb, 0xce, 0xa2, 0x9f, 0xda,
	0x59, 0x74, 0xd4, 0xce, 0xa2, 0x3f, 0xda, 0x59, 0xf4, 0xa2, 0x9d, 0x8d, 0xbd, 0x6c, 0x67, 0xd1,
	0x93, 0xe7, 0xd9, 0xd8, 0xd1, 0xf3, 0x6c, 0xec, 0xe9, 0xf3, 0x6c, 0xec, 0xa3, 0x6d, 0x8b, 0xba,
	0x9f, 0x59, 0xc5, 0x7d, 0x5a, 0xf7, 0x08, 0x63, 0x66, 0xd1, 0xe7, 0xf3, 0xc1, 0x0f, 0xf1, 0xbe,
	0xbb, 0x1a, 0xdd, 0xd2, 0xd5, 0x48, 0x3c, 0xef, 0xee, 0x5a, 0x74, 0x9e, 0x3c, 0xf4, 0xe4, 0x17,
	0x49, 0x9f, 0x2f, 0xb4, 0xdd, 0xe1, 0xe0, 0xf3, 0x64, 0xf1, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x41, 0x14, 0x7b, 0x1a, 0xca, 0x0d, 0x00, 0x00,
}

func (x AssertionConsumerServiceBinding) String() string {
	s, ok := AssertionConsumerServiceBinding_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Certificate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Certificate)
	if !ok {
		that2, ok := that.(Certificate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Certificate) != len(that1.Certificate) {
		return false
	}
	for i := range this.Certificate {
		if !this.Certificate[i].Equal(that1.Certificate[i]) {
			return false
		}
	}
	return true
}
func (this *UniformResourceName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UniformResourceName)
	if !ok {
		that2, ok := that.(UniformResourceName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Urn != that1.Urn {
		return false
	}
	if this.HostName != that1.HostName {
		return false
	}
	return true
}
func (this *UniformResourceLocator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UniformResourceLocator)
	if !ok {
		that2, ok := that.(UniformResourceLocator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	return true
}
func (this *AudienceUri) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AudienceUri)
	if !ok {
		that2, ok := that.(AudienceUri)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AudienceUriChoice == nil {
		if this.AudienceUriChoice != nil {
			return false
		}
	} else if this.AudienceUriChoice == nil {
		return false
	} else if !this.AudienceUriChoice.Equal(that1.AudienceUriChoice) {
		return false
	}
	return true
}
func (this *AudienceUri_UniformResourceLocator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AudienceUri_UniformResourceLocator)
	if !ok {
		that2, ok := that.(AudienceUri_UniformResourceLocator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UniformResourceLocator.Equal(that1.UniformResourceLocator) {
		return false
	}
	return true
}
func (this *AudienceUri_UniformResourceName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AudienceUri_UniformResourceName)
	if !ok {
		that2, ok := that.(AudienceUri_UniformResourceName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UniformResourceName.Equal(that1.UniformResourceName) {
		return false
	}
	return true
}
func (this *SignAuthenticationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SignAuthenticationRequest)
	if !ok {
		that2, ok := that.(SignAuthenticationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.SignAuthTypeChoice == nil {
		if this.SignAuthTypeChoice != nil {
			return false
		}
	} else if this.SignAuthTypeChoice == nil {
		return false
	} else if !this.SignAuthTypeChoice.Equal(that1.SignAuthTypeChoice) {
		return false
	}
	return true
}
func (this *SignAuthenticationRequest_NoAuthReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SignAuthenticationRequest_NoAuthReq)
	if !ok {
		that2, ok := that.(SignAuthenticationRequest_NoAuthReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoAuthReq.Equal(that1.NoAuthReq) {
		return false
	}
	return true
}
func (this *SignAuthenticationRequest_SignAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SignAuthenticationRequest_SignAuth)
	if !ok {
		that2, ok := that.(SignAuthenticationRequest_SignAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SignAuth.Equal(that1.SignAuth) {
		return false
	}
	return true
}
func (this *WantEncryptedRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WantEncryptedRequest)
	if !ok {
		that2, ok := that.(WantEncryptedRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.WantEncryptedRequest == nil {
		if this.WantEncryptedRequest != nil {
			return false
		}
	} else if this.WantEncryptedRequest == nil {
		return false
	} else if !this.WantEncryptedRequest.Equal(that1.WantEncryptedRequest) {
		return false
	}
	return true
}
func (this *WantEncryptedRequest_NoEncryptReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WantEncryptedRequest_NoEncryptReq)
	if !ok {
		that2, ok := that.(WantEncryptedRequest_NoEncryptReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoEncryptReq.Equal(that1.NoEncryptReq) {
		return false
	}
	return true
}
func (this *WantEncryptedRequest_EncryptReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WantEncryptedRequest_EncryptReq)
	if !ok {
		that2, ok := that.(WantEncryptedRequest_EncryptReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EncryptReq.Equal(that1.EncryptReq) {
		return false
	}
	return true
}
func (this *ServiceProviderProperties) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceProviderProperties)
	if !ok {
		that2, ok := that.(ServiceProviderProperties)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AudienceUri.Equal(that1.AudienceUri) {
		return false
	}
	if this.RelayState != that1.RelayState {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.SignAuthenticationRequest.Equal(that1.SignAuthenticationRequest) {
		return false
	}
	if !this.WantEncryptedAssertion.Equal(that1.WantEncryptedAssertion) {
		return false
	}
	if this.ForceAuthentication != that1.ForceAuthentication {
		return false
	}
	if this.WantSignedAssertion != that1.WantSignedAssertion {
		return false
	}
	return true
}
func (this *ApplicationTagging) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApplicationTagging)
	if !ok {
		that2, ok := that.(ApplicationTagging)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SamlAppTag != that1.SamlAppTag {
		return false
	}
	return true
}
func (this *SignAlgorithm) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SignAlgorithm)
	if !ok {
		that2, ok := that.(SignAlgorithm)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.SignAlgo == nil {
		if this.SignAlgo != nil {
			return false
		}
	} else if this.SignAlgo == nil {
		return false
	} else if !this.SignAlgo.Equal(that1.SignAlgo) {
		return false
	}
	return true
}
func (this *SignAlgorithm_RsaSha1) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SignAlgorithm_RsaSha1)
	if !ok {
		that2, ok := that.(SignAlgorithm_RsaSha1)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RsaSha1.Equal(that1.RsaSha1) {
		return false
	}
	return true
}
func (this *SignAlgorithm_RsaSha256) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SignAlgorithm_RsaSha256)
	if !ok {
		that2, ok := that.(SignAlgorithm_RsaSha256)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RsaSha256.Equal(that1.RsaSha256) {
		return false
	}
	return true
}
func (this *SignAlgorithm_RsaSha384) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SignAlgorithm_RsaSha384)
	if !ok {
		that2, ok := that.(SignAlgorithm_RsaSha384)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RsaSha384.Equal(that1.RsaSha384) {
		return false
	}
	return true
}
func (this *SignAlgorithm_RsaSha512) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SignAlgorithm_RsaSha512)
	if !ok {
		that2, ok := that.(SignAlgorithm_RsaSha512)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RsaSha512.Equal(that1.RsaSha512) {
		return false
	}
	return true
}
func (this *IdpSecurityProperty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IdpSecurityProperty)
	if !ok {
		that2, ok := that.(IdpSecurityProperty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthRequestSigned == nil {
		if this.AuthRequestSigned != nil {
			return false
		}
	} else if this.AuthRequestSigned == nil {
		return false
	} else if !this.AuthRequestSigned.Equal(that1.AuthRequestSigned) {
		return false
	}
	return true
}
func (this *IdpSecurityProperty_No) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IdpSecurityProperty_No)
	if !ok {
		that2, ok := that.(IdpSecurityProperty_No)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.No.Equal(that1.No) {
		return false
	}
	return true
}
func (this *IdpSecurityProperty_Yes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IdpSecurityProperty_Yes)
	if !ok {
		that2, ok := that.(IdpSecurityProperty_Yes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Yes.Equal(that1.Yes) {
		return false
	}
	return true
}
func (this *IdentityProvider) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IdentityProvider)
	if !ok {
		that2, ok := that.(IdentityProvider)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Issuer != that1.Issuer {
		return false
	}
	if this.SsoUrl != that1.SsoUrl {
		return false
	}
	if that1.SsoServiceBinding == nil {
		if this.SsoServiceBinding != nil {
			return false
		}
	} else if this.SsoServiceBinding == nil {
		return false
	} else if !this.SsoServiceBinding.Equal(that1.SsoServiceBinding) {
		return false
	}
	if !this.IdpAssertVerificationCert.Equal(that1.IdpAssertVerificationCert) {
		return false
	}
	if !this.IdpSecurityProperty.Equal(that1.IdpSecurityProperty) {
		return false
	}
	return true
}
func (this *IdentityProvider_Post) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IdentityProvider_Post)
	if !ok {
		that2, ok := that.(IdentityProvider_Post)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Post.Equal(that1.Post) {
		return false
	}
	return true
}
func (this *IdentityProvider_Redirect) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IdentityProvider_Redirect)
	if !ok {
		that2, ok := that.(IdentityProvider_Redirect)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Redirect.Equal(that1.Redirect) {
		return false
	}
	return true
}
func (this *SAMLMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SAMLMessage)
	if !ok {
		that2, ok := that.(SAMLMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServiceProviderProperties.Equal(that1.ServiceProviderProperties) {
		return false
	}
	if !this.ApplicationTag.Equal(that1.ApplicationTag) {
		return false
	}
	if !this.Idp.Equal(that1.Idp) {
		return false
	}
	return true
}
func (this *Certificate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_flow.Certificate{")
	if this.Certificate != nil {
		s = append(s, "Certificate: "+fmt.Sprintf("%#v", this.Certificate)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UniformResourceName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_flow.UniformResourceName{")
	s = append(s, "Urn: "+fmt.Sprintf("%#v", this.Urn)+",\n")
	s = append(s, "HostName: "+fmt.Sprintf("%#v", this.HostName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UniformResourceLocator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_flow.UniformResourceLocator{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AudienceUri) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_flow.AudienceUri{")
	if this.AudienceUriChoice != nil {
		s = append(s, "AudienceUriChoice: "+fmt.Sprintf("%#v", this.AudienceUriChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AudienceUri_UniformResourceLocator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.AudienceUri_UniformResourceLocator{` +
		`UniformResourceLocator:` + fmt.Sprintf("%#v", this.UniformResourceLocator) + `}`}, ", ")
	return s
}
func (this *AudienceUri_UniformResourceName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.AudienceUri_UniformResourceName{` +
		`UniformResourceName:` + fmt.Sprintf("%#v", this.UniformResourceName) + `}`}, ", ")
	return s
}
func (this *SignAuthenticationRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_flow.SignAuthenticationRequest{")
	if this.SignAuthTypeChoice != nil {
		s = append(s, "SignAuthTypeChoice: "+fmt.Sprintf("%#v", this.SignAuthTypeChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SignAuthenticationRequest_NoAuthReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.SignAuthenticationRequest_NoAuthReq{` +
		`NoAuthReq:` + fmt.Sprintf("%#v", this.NoAuthReq) + `}`}, ", ")
	return s
}
func (this *SignAuthenticationRequest_SignAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.SignAuthenticationRequest_SignAuth{` +
		`SignAuth:` + fmt.Sprintf("%#v", this.SignAuth) + `}`}, ", ")
	return s
}
func (this *WantEncryptedRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_flow.WantEncryptedRequest{")
	if this.WantEncryptedRequest != nil {
		s = append(s, "WantEncryptedRequest: "+fmt.Sprintf("%#v", this.WantEncryptedRequest)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WantEncryptedRequest_NoEncryptReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.WantEncryptedRequest_NoEncryptReq{` +
		`NoEncryptReq:` + fmt.Sprintf("%#v", this.NoEncryptReq) + `}`}, ", ")
	return s
}
func (this *WantEncryptedRequest_EncryptReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.WantEncryptedRequest_EncryptReq{` +
		`EncryptReq:` + fmt.Sprintf("%#v", this.EncryptReq) + `}`}, ", ")
	return s
}
func (this *ServiceProviderProperties) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&uztna_flow.ServiceProviderProperties{")
	if this.AudienceUri != nil {
		s = append(s, "AudienceUri: "+fmt.Sprintf("%#v", this.AudienceUri)+",\n")
	}
	s = append(s, "RelayState: "+fmt.Sprintf("%#v", this.RelayState)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.SignAuthenticationRequest != nil {
		s = append(s, "SignAuthenticationRequest: "+fmt.Sprintf("%#v", this.SignAuthenticationRequest)+",\n")
	}
	if this.WantEncryptedAssertion != nil {
		s = append(s, "WantEncryptedAssertion: "+fmt.Sprintf("%#v", this.WantEncryptedAssertion)+",\n")
	}
	s = append(s, "ForceAuthentication: "+fmt.Sprintf("%#v", this.ForceAuthentication)+",\n")
	s = append(s, "WantSignedAssertion: "+fmt.Sprintf("%#v", this.WantSignedAssertion)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ApplicationTagging) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&uztna_flow.ApplicationTagging{")
	s = append(s, "SamlAppTag: "+fmt.Sprintf("%#v", this.SamlAppTag)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SignAlgorithm) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&uztna_flow.SignAlgorithm{")
	if this.SignAlgo != nil {
		s = append(s, "SignAlgo: "+fmt.Sprintf("%#v", this.SignAlgo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SignAlgorithm_RsaSha1) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.SignAlgorithm_RsaSha1{` +
		`RsaSha1:` + fmt.Sprintf("%#v", this.RsaSha1) + `}`}, ", ")
	return s
}
func (this *SignAlgorithm_RsaSha256) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.SignAlgorithm_RsaSha256{` +
		`RsaSha256:` + fmt.Sprintf("%#v", this.RsaSha256) + `}`}, ", ")
	return s
}
func (this *SignAlgorithm_RsaSha384) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.SignAlgorithm_RsaSha384{` +
		`RsaSha384:` + fmt.Sprintf("%#v", this.RsaSha384) + `}`}, ", ")
	return s
}
func (this *SignAlgorithm_RsaSha512) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.SignAlgorithm_RsaSha512{` +
		`RsaSha512:` + fmt.Sprintf("%#v", this.RsaSha512) + `}`}, ", ")
	return s
}
func (this *IdpSecurityProperty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&uztna_flow.IdpSecurityProperty{")
	if this.AuthRequestSigned != nil {
		s = append(s, "AuthRequestSigned: "+fmt.Sprintf("%#v", this.AuthRequestSigned)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IdpSecurityProperty_No) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.IdpSecurityProperty_No{` +
		`No:` + fmt.Sprintf("%#v", this.No) + `}`}, ", ")
	return s
}
func (this *IdpSecurityProperty_Yes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.IdpSecurityProperty_Yes{` +
		`Yes:` + fmt.Sprintf("%#v", this.Yes) + `}`}, ", ")
	return s
}
func (this *IdentityProvider) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&uztna_flow.IdentityProvider{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Issuer: "+fmt.Sprintf("%#v", this.Issuer)+",\n")
	s = append(s, "SsoUrl: "+fmt.Sprintf("%#v", this.SsoUrl)+",\n")
	if this.SsoServiceBinding != nil {
		s = append(s, "SsoServiceBinding: "+fmt.Sprintf("%#v", this.SsoServiceBinding)+",\n")
	}
	if this.IdpAssertVerificationCert != nil {
		s = append(s, "IdpAssertVerificationCert: "+fmt.Sprintf("%#v", this.IdpAssertVerificationCert)+",\n")
	}
	if this.IdpSecurityProperty != nil {
		s = append(s, "IdpSecurityProperty: "+fmt.Sprintf("%#v", this.IdpSecurityProperty)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IdentityProvider_Post) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.IdentityProvider_Post{` +
		`Post:` + fmt.Sprintf("%#v", this.Post) + `}`}, ", ")
	return s
}
func (this *IdentityProvider_Redirect) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&uztna_flow.IdentityProvider_Redirect{` +
		`Redirect:` + fmt.Sprintf("%#v", this.Redirect) + `}`}, ", ")
	return s
}
func (this *SAMLMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&uztna_flow.SAMLMessage{")
	if this.ServiceProviderProperties != nil {
		s = append(s, "ServiceProviderProperties: "+fmt.Sprintf("%#v", this.ServiceProviderProperties)+",\n")
	}
	if this.ApplicationTag != nil {
		s = append(s, "ApplicationTag: "+fmt.Sprintf("%#v", this.ApplicationTag)+",\n")
	}
	if this.Idp != nil {
		s = append(s, "Idp: "+fmt.Sprintf("%#v", this.Idp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringSaml(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Certificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Certificate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Certificate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Certificate) > 0 {
		for iNdEx := len(m.Certificate) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Certificate[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSaml(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *UniformResourceName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UniformResourceName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UniformResourceName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintSaml(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Urn) > 0 {
		i -= len(m.Urn)
		copy(dAtA[i:], m.Urn)
		i = encodeVarintSaml(dAtA, i, uint64(len(m.Urn)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UniformResourceLocator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UniformResourceLocator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UniformResourceLocator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintSaml(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AudienceUri) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AudienceUri) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AudienceUri) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AudienceUriChoice != nil {
		{
			size := m.AudienceUriChoice.Size()
			i -= size
			if _, err := m.AudienceUriChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AudienceUri_UniformResourceLocator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AudienceUri_UniformResourceLocator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UniformResourceLocator != nil {
		{
			size, err := m.UniformResourceLocator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AudienceUri_UniformResourceName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AudienceUri_UniformResourceName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UniformResourceName != nil {
		{
			size, err := m.UniformResourceName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SignAuthenticationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignAuthenticationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignAuthenticationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SignAuthTypeChoice != nil {
		{
			size := m.SignAuthTypeChoice.Size()
			i -= size
			if _, err := m.SignAuthTypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SignAuthenticationRequest_NoAuthReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignAuthenticationRequest_NoAuthReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoAuthReq != nil {
		{
			size, err := m.NoAuthReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SignAuthenticationRequest_SignAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignAuthenticationRequest_SignAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SignAuth != nil {
		{
			size, err := m.SignAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *WantEncryptedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WantEncryptedRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WantEncryptedRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WantEncryptedRequest != nil {
		{
			size := m.WantEncryptedRequest.Size()
			i -= size
			if _, err := m.WantEncryptedRequest.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *WantEncryptedRequest_NoEncryptReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WantEncryptedRequest_NoEncryptReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoEncryptReq != nil {
		{
			size, err := m.NoEncryptReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *WantEncryptedRequest_EncryptReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WantEncryptedRequest_EncryptReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EncryptReq != nil {
		{
			size, err := m.EncryptReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ServiceProviderProperties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceProviderProperties) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceProviderProperties) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WantSignedAssertion {
		i--
		if m.WantSignedAssertion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.ForceAuthentication {
		i--
		if m.ForceAuthentication {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.WantEncryptedAssertion != nil {
		{
			size, err := m.WantEncryptedAssertion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.SignAuthenticationRequest != nil {
		{
			size, err := m.SignAuthenticationRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintSaml(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RelayState) > 0 {
		i -= len(m.RelayState)
		copy(dAtA[i:], m.RelayState)
		i = encodeVarintSaml(dAtA, i, uint64(len(m.RelayState)))
		i--
		dAtA[i] = 0x12
	}
	if m.AudienceUri != nil {
		{
			size, err := m.AudienceUri.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ApplicationTagging) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplicationTagging) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplicationTagging) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SamlAppTag) > 0 {
		i -= len(m.SamlAppTag)
		copy(dAtA[i:], m.SamlAppTag)
		i = encodeVarintSaml(dAtA, i, uint64(len(m.SamlAppTag)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignAlgorithm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignAlgorithm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignAlgorithm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SignAlgo != nil {
		{
			size := m.SignAlgo.Size()
			i -= size
			if _, err := m.SignAlgo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SignAlgorithm_RsaSha1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignAlgorithm_RsaSha1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RsaSha1 != nil {
		{
			size, err := m.RsaSha1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *SignAlgorithm_RsaSha256) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignAlgorithm_RsaSha256) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RsaSha256 != nil {
		{
			size, err := m.RsaSha256.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *SignAlgorithm_RsaSha384) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignAlgorithm_RsaSha384) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RsaSha384 != nil {
		{
			size, err := m.RsaSha384.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *SignAlgorithm_RsaSha512) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignAlgorithm_RsaSha512) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RsaSha512 != nil {
		{
			size, err := m.RsaSha512.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *IdpSecurityProperty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdpSecurityProperty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IdpSecurityProperty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthRequestSigned != nil {
		{
			size := m.AuthRequestSigned.Size()
			i -= size
			if _, err := m.AuthRequestSigned.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *IdpSecurityProperty_No) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IdpSecurityProperty_No) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.No != nil {
		{
			size, err := m.No.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *IdpSecurityProperty_Yes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IdpSecurityProperty_Yes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Yes != nil {
		{
			size, err := m.Yes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *IdentityProvider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdentityProvider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IdentityProvider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IdpSecurityProperty != nil {
		{
			size, err := m.IdpSecurityProperty.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.IdpAssertVerificationCert != nil {
		{
			size, err := m.IdpAssertVerificationCert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.SsoServiceBinding != nil {
		{
			size := m.SsoServiceBinding.Size()
			i -= size
			if _, err := m.SsoServiceBinding.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.SsoUrl) > 0 {
		i -= len(m.SsoUrl)
		copy(dAtA[i:], m.SsoUrl)
		i = encodeVarintSaml(dAtA, i, uint64(len(m.SsoUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintSaml(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSaml(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IdentityProvider_Post) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IdentityProvider_Post) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Post != nil {
		{
			size, err := m.Post.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *IdentityProvider_Redirect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IdentityProvider_Redirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Redirect != nil {
		{
			size, err := m.Redirect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *SAMLMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SAMLMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SAMLMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Idp != nil {
		{
			size, err := m.Idp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ApplicationTag != nil {
		{
			size, err := m.ApplicationTag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ServiceProviderProperties != nil {
		{
			size, err := m.ServiceProviderProperties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSaml(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSaml(dAtA []byte, offset int, v uint64) int {
	offset -= sovSaml(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Certificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Certificate) > 0 {
		for _, e := range m.Certificate {
			l = e.Size()
			n += 1 + l + sovSaml(uint64(l))
		}
	}
	return n
}

func (m *UniformResourceName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Urn)
	if l > 0 {
		n += 1 + l + sovSaml(uint64(l))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}

func (m *UniformResourceLocator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}

func (m *AudienceUri) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AudienceUriChoice != nil {
		n += m.AudienceUriChoice.Size()
	}
	return n
}

func (m *AudienceUri_UniformResourceLocator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UniformResourceLocator != nil {
		l = m.UniformResourceLocator.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *AudienceUri_UniformResourceName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UniformResourceName != nil {
		l = m.UniformResourceName.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *SignAuthenticationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignAuthTypeChoice != nil {
		n += m.SignAuthTypeChoice.Size()
	}
	return n
}

func (m *SignAuthenticationRequest_NoAuthReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoAuthReq != nil {
		l = m.NoAuthReq.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *SignAuthenticationRequest_SignAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignAuth != nil {
		l = m.SignAuth.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *WantEncryptedRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WantEncryptedRequest != nil {
		n += m.WantEncryptedRequest.Size()
	}
	return n
}

func (m *WantEncryptedRequest_NoEncryptReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoEncryptReq != nil {
		l = m.NoEncryptReq.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *WantEncryptedRequest_EncryptReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EncryptReq != nil {
		l = m.EncryptReq.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *ServiceProviderProperties) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AudienceUri != nil {
		l = m.AudienceUri.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	l = len(m.RelayState)
	if l > 0 {
		n += 1 + l + sovSaml(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovSaml(uint64(m.Type))
	}
	if m.SignAuthenticationRequest != nil {
		l = m.SignAuthenticationRequest.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	if m.WantEncryptedAssertion != nil {
		l = m.WantEncryptedAssertion.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	if m.ForceAuthentication {
		n += 2
	}
	if m.WantSignedAssertion {
		n += 2
	}
	return n
}

func (m *ApplicationTagging) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SamlAppTag)
	if l > 0 {
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}

func (m *SignAlgorithm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignAlgo != nil {
		n += m.SignAlgo.Size()
	}
	return n
}

func (m *SignAlgorithm_RsaSha1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RsaSha1 != nil {
		l = m.RsaSha1.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *SignAlgorithm_RsaSha256) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RsaSha256 != nil {
		l = m.RsaSha256.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *SignAlgorithm_RsaSha384) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RsaSha384 != nil {
		l = m.RsaSha384.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *SignAlgorithm_RsaSha512) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RsaSha512 != nil {
		l = m.RsaSha512.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *IdpSecurityProperty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthRequestSigned != nil {
		n += m.AuthRequestSigned.Size()
	}
	return n
}

func (m *IdpSecurityProperty_No) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.No != nil {
		l = m.No.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *IdpSecurityProperty_Yes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Yes != nil {
		l = m.Yes.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *IdentityProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSaml(uint64(l))
	}
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovSaml(uint64(l))
	}
	l = len(m.SsoUrl)
	if l > 0 {
		n += 1 + l + sovSaml(uint64(l))
	}
	if m.SsoServiceBinding != nil {
		n += m.SsoServiceBinding.Size()
	}
	if m.IdpAssertVerificationCert != nil {
		l = m.IdpAssertVerificationCert.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	if m.IdpSecurityProperty != nil {
		l = m.IdpSecurityProperty.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}

func (m *IdentityProvider_Post) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Post != nil {
		l = m.Post.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *IdentityProvider_Redirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Redirect != nil {
		l = m.Redirect.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}
func (m *SAMLMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServiceProviderProperties != nil {
		l = m.ServiceProviderProperties.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	if m.ApplicationTag != nil {
		l = m.ApplicationTag.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	if m.Idp != nil {
		l = m.Idp.Size()
		n += 1 + l + sovSaml(uint64(l))
	}
	return n
}

func sovSaml(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSaml(x uint64) (n int) {
	return sovSaml(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Certificate) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCertificate := "[]*ObjectRefType{"
	for _, f := range this.Certificate {
		repeatedStringForCertificate += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCertificate += "}"
	s := strings.Join([]string{`&Certificate{`,
		`Certificate:` + repeatedStringForCertificate + `,`,
		`}`,
	}, "")
	return s
}
func (this *UniformResourceName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UniformResourceName{`,
		`Urn:` + fmt.Sprintf("%v", this.Urn) + `,`,
		`HostName:` + fmt.Sprintf("%v", this.HostName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UniformResourceLocator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UniformResourceLocator{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AudienceUri) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AudienceUri{`,
		`AudienceUriChoice:` + fmt.Sprintf("%v", this.AudienceUriChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AudienceUri_UniformResourceLocator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AudienceUri_UniformResourceLocator{`,
		`UniformResourceLocator:` + strings.Replace(fmt.Sprintf("%v", this.UniformResourceLocator), "UniformResourceLocator", "UniformResourceLocator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AudienceUri_UniformResourceName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AudienceUri_UniformResourceName{`,
		`UniformResourceName:` + strings.Replace(fmt.Sprintf("%v", this.UniformResourceName), "UniformResourceName", "UniformResourceName", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignAuthenticationRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SignAuthenticationRequest{`,
		`SignAuthTypeChoice:` + fmt.Sprintf("%v", this.SignAuthTypeChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignAuthenticationRequest_NoAuthReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SignAuthenticationRequest_NoAuthReq{`,
		`NoAuthReq:` + strings.Replace(fmt.Sprintf("%v", this.NoAuthReq), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignAuthenticationRequest_SignAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SignAuthenticationRequest_SignAuth{`,
		`SignAuth:` + strings.Replace(fmt.Sprintf("%v", this.SignAuth), "Certificate", "Certificate", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WantEncryptedRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WantEncryptedRequest{`,
		`WantEncryptedRequest:` + fmt.Sprintf("%v", this.WantEncryptedRequest) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WantEncryptedRequest_NoEncryptReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WantEncryptedRequest_NoEncryptReq{`,
		`NoEncryptReq:` + strings.Replace(fmt.Sprintf("%v", this.NoEncryptReq), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WantEncryptedRequest_EncryptReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WantEncryptedRequest_EncryptReq{`,
		`EncryptReq:` + strings.Replace(fmt.Sprintf("%v", this.EncryptReq), "Certificate", "Certificate", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceProviderProperties) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceProviderProperties{`,
		`AudienceUri:` + strings.Replace(this.AudienceUri.String(), "AudienceUri", "AudienceUri", 1) + `,`,
		`RelayState:` + fmt.Sprintf("%v", this.RelayState) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`SignAuthenticationRequest:` + strings.Replace(this.SignAuthenticationRequest.String(), "SignAuthenticationRequest", "SignAuthenticationRequest", 1) + `,`,
		`WantEncryptedAssertion:` + strings.Replace(this.WantEncryptedAssertion.String(), "WantEncryptedRequest", "WantEncryptedRequest", 1) + `,`,
		`ForceAuthentication:` + fmt.Sprintf("%v", this.ForceAuthentication) + `,`,
		`WantSignedAssertion:` + fmt.Sprintf("%v", this.WantSignedAssertion) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ApplicationTagging) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ApplicationTagging{`,
		`SamlAppTag:` + fmt.Sprintf("%v", this.SamlAppTag) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignAlgorithm) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SignAlgorithm{`,
		`SignAlgo:` + fmt.Sprintf("%v", this.SignAlgo) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignAlgorithm_RsaSha1) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SignAlgorithm_RsaSha1{`,
		`RsaSha1:` + strings.Replace(fmt.Sprintf("%v", this.RsaSha1), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignAlgorithm_RsaSha256) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SignAlgorithm_RsaSha256{`,
		`RsaSha256:` + strings.Replace(fmt.Sprintf("%v", this.RsaSha256), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignAlgorithm_RsaSha384) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SignAlgorithm_RsaSha384{`,
		`RsaSha384:` + strings.Replace(fmt.Sprintf("%v", this.RsaSha384), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignAlgorithm_RsaSha512) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SignAlgorithm_RsaSha512{`,
		`RsaSha512:` + strings.Replace(fmt.Sprintf("%v", this.RsaSha512), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IdpSecurityProperty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IdpSecurityProperty{`,
		`AuthRequestSigned:` + fmt.Sprintf("%v", this.AuthRequestSigned) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IdpSecurityProperty_No) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IdpSecurityProperty_No{`,
		`No:` + strings.Replace(fmt.Sprintf("%v", this.No), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IdpSecurityProperty_Yes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IdpSecurityProperty_Yes{`,
		`Yes:` + strings.Replace(fmt.Sprintf("%v", this.Yes), "SignAlgorithm", "SignAlgorithm", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IdentityProvider) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IdentityProvider{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Issuer:` + fmt.Sprintf("%v", this.Issuer) + `,`,
		`SsoUrl:` + fmt.Sprintf("%v", this.SsoUrl) + `,`,
		`SsoServiceBinding:` + fmt.Sprintf("%v", this.SsoServiceBinding) + `,`,
		`IdpAssertVerificationCert:` + strings.Replace(this.IdpAssertVerificationCert.String(), "Certificate", "Certificate", 1) + `,`,
		`IdpSecurityProperty:` + strings.Replace(this.IdpSecurityProperty.String(), "IdpSecurityProperty", "IdpSecurityProperty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IdentityProvider_Post) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IdentityProvider_Post{`,
		`Post:` + strings.Replace(fmt.Sprintf("%v", this.Post), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IdentityProvider_Redirect) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IdentityProvider_Redirect{`,
		`Redirect:` + strings.Replace(fmt.Sprintf("%v", this.Redirect), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SAMLMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SAMLMessage{`,
		`ServiceProviderProperties:` + strings.Replace(this.ServiceProviderProperties.String(), "ServiceProviderProperties", "ServiceProviderProperties", 1) + `,`,
		`ApplicationTag:` + strings.Replace(this.ApplicationTag.String(), "ApplicationTagging", "ApplicationTagging", 1) + `,`,
		`Idp:` + strings.Replace(this.Idp.String(), "IdentityProvider", "IdentityProvider", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringSaml(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Certificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Certificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Certificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certificate = append(m.Certificate, &schema.ObjectRefType{})
			if err := m.Certificate[len(m.Certificate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UniformResourceName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UniformResourceName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UniformResourceName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Urn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Urn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UniformResourceLocator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UniformResourceLocator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UniformResourceLocator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AudienceUri) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AudienceUri: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AudienceUri: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniformResourceLocator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UniformResourceLocator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AudienceUriChoice = &AudienceUri_UniformResourceLocator{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniformResourceName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UniformResourceName{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AudienceUriChoice = &AudienceUri_UniformResourceName{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignAuthenticationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignAuthenticationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignAuthenticationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoAuthReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SignAuthTypeChoice = &SignAuthenticationRequest_NoAuthReq{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Certificate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SignAuthTypeChoice = &SignAuthenticationRequest_SignAuth{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WantEncryptedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WantEncryptedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WantEncryptedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoEncryptReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WantEncryptedRequest = &WantEncryptedRequest_NoEncryptReq{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Certificate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WantEncryptedRequest = &WantEncryptedRequest_EncryptReq{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceProviderProperties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceProviderProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceProviderProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudienceUri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AudienceUri == nil {
				m.AudienceUri = &AudienceUri{}
			}
			if err := m.AudienceUri.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= AssertionConsumerServiceBinding(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignAuthenticationRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignAuthenticationRequest == nil {
				m.SignAuthenticationRequest = &SignAuthenticationRequest{}
			}
			if err := m.SignAuthenticationRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WantEncryptedAssertion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WantEncryptedAssertion == nil {
				m.WantEncryptedAssertion = &WantEncryptedRequest{}
			}
			if err := m.WantEncryptedAssertion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceAuthentication", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceAuthentication = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WantSignedAssertion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WantSignedAssertion = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplicationTagging) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplicationTagging: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplicationTagging: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamlAppTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SamlAppTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignAlgorithm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignAlgorithm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignAlgorithm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RsaSha1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SignAlgo = &SignAlgorithm_RsaSha1{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RsaSha256", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SignAlgo = &SignAlgorithm_RsaSha256{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RsaSha384", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SignAlgo = &SignAlgorithm_RsaSha384{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RsaSha512", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SignAlgo = &SignAlgorithm_RsaSha512{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdpSecurityProperty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdpSecurityProperty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdpSecurityProperty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field No", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthRequestSigned = &IdpSecurityProperty_No{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SignAlgorithm{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthRequestSigned = &IdpSecurityProperty_Yes{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdentityProvider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdentityProvider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdentityProvider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SsoUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SsoUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Post", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SsoServiceBinding = &IdentityProvider_Post{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redirect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SsoServiceBinding = &IdentityProvider_Redirect{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdpAssertVerificationCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdpAssertVerificationCert == nil {
				m.IdpAssertVerificationCert = &Certificate{}
			}
			if err := m.IdpAssertVerificationCert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdpSecurityProperty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdpSecurityProperty == nil {
				m.IdpSecurityProperty = &IdpSecurityProperty{}
			}
			if err := m.IdpSecurityProperty.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SAMLMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SAMLMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SAMLMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceProviderProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceProviderProperties == nil {
				m.ServiceProviderProperties = &ServiceProviderProperties{}
			}
			if err := m.ServiceProviderProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationTag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApplicationTag == nil {
				m.ApplicationTag = &ApplicationTagging{}
			}
			if err := m.ApplicationTag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSaml
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSaml
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Idp == nil {
				m.Idp = &IdentityProvider{}
			}
			if err := m.Idp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSaml(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSaml
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSaml
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSaml
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSaml
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSaml
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSaml        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSaml          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSaml = fmt.Errorf("proto: unexpected end of group")
)
