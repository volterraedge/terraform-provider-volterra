// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package ticket_management

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *JiraIssue) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JiraIssue) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JiraIssue) DeepCopy() *JiraIssue {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JiraIssue{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JiraIssue) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JiraIssue) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JiraIssueValidator().Validate(ctx, m, opts...)
}

type ValidateJiraIssue struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJiraIssue) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JiraIssue)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JiraIssue got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["fields"]; exists {

		vOpts := append(opts, db.WithValidateField("fields"))
		if err := fv(ctx, m.GetFields(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJiraIssueValidator = func() *ValidateJiraIssue {
	v := &ValidateJiraIssue{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func JiraIssueValidator() db.Validator {
	return DefaultJiraIssueValidator
}

// augmented methods on protoc/std generated struct

func (m *JiraIssueFields) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JiraIssueFields) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JiraIssueFields) DeepCopy() *JiraIssueFields {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JiraIssueFields{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JiraIssueFields) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JiraIssueFields) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JiraIssueFieldsValidator().Validate(ctx, m, opts...)
}

type ValidateJiraIssueFields struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJiraIssueFields) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JiraIssueFields)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JiraIssueFields got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["issuetype"]; exists {

		vOpts := append(opts, db.WithValidateField("issuetype"))
		if err := fv(ctx, m.GetIssuetype(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["project"]; exists {

		vOpts := append(opts, db.WithValidateField("project"))
		if err := fv(ctx, m.GetProject(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["summary"]; exists {

		vOpts := append(opts, db.WithValidateField("summary"))
		if err := fv(ctx, m.GetSummary(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJiraIssueFieldsValidator = func() *ValidateJiraIssueFields {
	v := &ValidateJiraIssueFields{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func JiraIssueFieldsValidator() db.Validator {
	return DefaultJiraIssueFieldsValidator
}

// augmented methods on protoc/std generated struct

func (m *JiraIssueStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JiraIssueStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JiraIssueStatus) DeepCopy() *JiraIssueStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JiraIssueStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JiraIssueStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JiraIssueStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JiraIssueStatusValidator().Validate(ctx, m, opts...)
}

type ValidateJiraIssueStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJiraIssueStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JiraIssueStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JiraIssueStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["icon_url"]; exists {

		vOpts := append(opts, db.WithValidateField("icon_url"))
		if err := fv(ctx, m.GetIconUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status_category"]; exists {

		vOpts := append(opts, db.WithValidateField("status_category"))
		if err := fv(ctx, m.GetStatusCategory(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJiraIssueStatusValidator = func() *ValidateJiraIssueStatus {
	v := &ValidateJiraIssueStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func JiraIssueStatusValidator() db.Validator {
	return DefaultJiraIssueStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *JiraIssueStatusCategory) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JiraIssueStatusCategory) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JiraIssueStatusCategory) DeepCopy() *JiraIssueStatusCategory {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JiraIssueStatusCategory{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JiraIssueStatusCategory) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JiraIssueStatusCategory) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JiraIssueStatusCategoryValidator().Validate(ctx, m, opts...)
}

type ValidateJiraIssueStatusCategory struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJiraIssueStatusCategory) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JiraIssueStatusCategory)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JiraIssueStatusCategory got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["color_name"]; exists {

		vOpts := append(opts, db.WithValidateField("color_name"))
		if err := fv(ctx, m.GetColorName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJiraIssueStatusCategoryValidator = func() *ValidateJiraIssueStatusCategory {
	v := &ValidateJiraIssueStatusCategory{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func JiraIssueStatusCategoryValidator() db.Validator {
	return DefaultJiraIssueStatusCategoryValidator
}

// augmented methods on protoc/std generated struct

func (m *JiraIssueType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JiraIssueType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JiraIssueType) DeepCopy() *JiraIssueType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JiraIssueType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JiraIssueType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JiraIssueType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JiraIssueTypeValidator().Validate(ctx, m, opts...)
}

type ValidateJiraIssueType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJiraIssueType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JiraIssueType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JiraIssueType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["avatar_id"]; exists {

		vOpts := append(opts, db.WithValidateField("avatar_id"))
		if err := fv(ctx, m.GetAvatarId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["icon_url"]; exists {

		vOpts := append(opts, db.WithValidateField("icon_url"))
		if err := fv(ctx, m.GetIconUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJiraIssueTypeValidator = func() *ValidateJiraIssueType {
	v := &ValidateJiraIssueType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func JiraIssueTypeValidator() db.Validator {
	return DefaultJiraIssueTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *JiraProject) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JiraProject) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JiraProject) DeepCopy() *JiraProject {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JiraProject{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JiraProject) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JiraProject) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JiraProjectValidator().Validate(ctx, m, opts...)
}

type ValidateJiraProject struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJiraProject) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JiraProject)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JiraProject got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["issue_types"]; exists {

		vOpts := append(opts, db.WithValidateField("issue_types"))
		for idx, item := range m.GetIssueTypes() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJiraProjectValidator = func() *ValidateJiraProject {
	v := &ValidateJiraProject{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func JiraProjectValidator() db.Validator {
	return DefaultJiraProjectValidator
}
