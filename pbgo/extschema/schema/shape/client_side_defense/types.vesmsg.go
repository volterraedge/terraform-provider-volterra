// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package client_side_defense

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AddToAllowedDomains) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AddToAllowedDomains) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AddToAllowedDomains) DeepCopy() *AddToAllowedDomains {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AddToAllowedDomains{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AddToAllowedDomains) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AddToAllowedDomains) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AddToAllowedDomainsValidator().Validate(ctx, m, opts...)
}

type ValidateAddToAllowedDomains struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAddToAllowedDomains) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAddToAllowedDomains) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AddToAllowedDomains)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AddToAllowedDomains got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAddToAllowedDomainsValidator = func() *ValidateAddToAllowedDomains {
	v := &ValidateAddToAllowedDomains{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.repeated.items.string.hostname": "true",
		"ves.io.schema.rules.repeated.items.string.max_len":  "256",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AddToAllowedDomains.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	return v
}()

func AddToAllowedDomainsValidator() db.Validator {
	return DefaultAddToAllowedDomainsValidator
}

// augmented methods on protoc/std generated struct

func (m *AddToMitigatedDomains) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AddToMitigatedDomains) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AddToMitigatedDomains) DeepCopy() *AddToMitigatedDomains {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AddToMitigatedDomains{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AddToMitigatedDomains) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AddToMitigatedDomains) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AddToMitigatedDomainsValidator().Validate(ctx, m, opts...)
}

type ValidateAddToMitigatedDomains struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAddToMitigatedDomains) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAddToMitigatedDomains) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AddToMitigatedDomains)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AddToMitigatedDomains got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAddToMitigatedDomainsValidator = func() *ValidateAddToMitigatedDomains {
	v := &ValidateAddToMitigatedDomains{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.repeated.items.string.hostname": "true",
		"ves.io.schema.rules.repeated.items.string.max_len":  "256",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AddToMitigatedDomains.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	return v
}()

func AddToMitigatedDomainsValidator() db.Validator {
	return DefaultAddToMitigatedDomainsValidator
}

// augmented methods on protoc/std generated struct

func (m *AffectedUser) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AffectedUser) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AffectedUser) DeepCopy() *AffectedUser {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AffectedUser{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AffectedUser) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AffectedUser) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AffectedUserValidator().Validate(ctx, m, opts...)
}

type ValidateAffectedUser struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAffectedUser) IpAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip_address")
	}

	return validatorFn, nil
}

func (v *ValidateAffectedUser) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AffectedUser)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AffectedUser got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["channel"]; exists {

		vOpts := append(opts, db.WithValidateField("channel"))
		if err := fv(ctx, m.GetChannel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["device_id"]; exists {

		vOpts := append(opts, db.WithValidateField("device_id"))
		if err := fv(ctx, m.GetDeviceId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["geolocation"]; exists {

		vOpts := append(opts, db.WithValidateField("geolocation"))
		if err := fv(ctx, m.GetGeolocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_address"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_address"))
		if err := fv(ctx, m.GetIpAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["last_seen"]; exists {

		vOpts := append(opts, db.WithValidateField("last_seen"))
		if err := fv(ctx, m.GetLastSeen(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_agent"]; exists {

		vOpts := append(opts, db.WithValidateField("user_agent"))
		if err := fv(ctx, m.GetUserAgent(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAffectedUserValidator = func() *ValidateAffectedUser {
	v := &ValidateAffectedUser{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIpAddress := v.IpAddressValidationRuleHandler
	rulesIpAddress := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhIpAddress(rulesIpAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AffectedUser.ip_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_address"] = vFn

	return v
}()

func AffectedUserValidator() db.Validator {
	return DefaultAffectedUserValidator
}

// augmented methods on protoc/std generated struct

func (m *AffectedUserDeviceIDFilter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AffectedUserDeviceIDFilter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AffectedUserDeviceIDFilter) DeepCopy() *AffectedUserDeviceIDFilter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AffectedUserDeviceIDFilter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AffectedUserDeviceIDFilter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AffectedUserDeviceIDFilter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AffectedUserDeviceIDFilterValidator().Validate(ctx, m, opts...)
}

type ValidateAffectedUserDeviceIDFilter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAffectedUserDeviceIDFilter) OpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(FilterOperator)
		return int32(i)
	}
	// FilterOperator_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, FilterOperator_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for op")
	}

	return validatorFn, nil
}

func (v *ValidateAffectedUserDeviceIDFilter) DeviceIdsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for device_ids")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for device_ids")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated device_ids")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items device_ids")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAffectedUserDeviceIDFilter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AffectedUserDeviceIDFilter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AffectedUserDeviceIDFilter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["device_ids"]; exists {
		vOpts := append(opts, db.WithValidateField("device_ids"))
		if err := fv(ctx, m.GetDeviceIds(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["op"]; exists {

		vOpts := append(opts, db.WithValidateField("op"))
		if err := fv(ctx, m.GetOp(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAffectedUserDeviceIDFilterValidator = func() *ValidateAffectedUserDeviceIDFilter {
	v := &ValidateAffectedUserDeviceIDFilter{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOp := v.OpValidationRuleHandler
	rulesOp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOp(rulesOp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AffectedUserDeviceIDFilter.op: %s", err)
		panic(errMsg)
	}
	v.FldValidators["op"] = vFn

	vrhDeviceIds := v.DeviceIdsValidationRuleHandler
	rulesDeviceIds := map[string]string{
		"ves.io.schema.rules.message.required":              "true",
		"ves.io.schema.rules.repeated.items.string.max_len": "256",
		"ves.io.schema.rules.repeated.max_items":            "64",
		"ves.io.schema.rules.repeated.min_items":            "1",
		"ves.io.schema.rules.repeated.unique":               "true",
	}
	vFn, err = vrhDeviceIds(rulesDeviceIds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AffectedUserDeviceIDFilter.device_ids: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device_ids"] = vFn

	return v
}()

func AffectedUserDeviceIDFilterValidator() db.Validator {
	return DefaultAffectedUserDeviceIDFilterValidator
}

// augmented methods on protoc/std generated struct

func (m *AffectedUserFilters) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AffectedUserFilters) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AffectedUserFilters) DeepCopy() *AffectedUserFilters {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AffectedUserFilters{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AffectedUserFilters) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AffectedUserFilters) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AffectedUserFiltersValidator().Validate(ctx, m, opts...)
}

type ValidateAffectedUserFilters struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAffectedUserFilters) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AffectedUserFilters)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AffectedUserFilters got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["affected_user_device_id_filter"]; exists {

		vOpts := append(opts, db.WithValidateField("affected_user_device_id_filter"))
		if err := fv(ctx, m.GetAffectedUserDeviceIdFilter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["affected_user_geolocation_filter"]; exists {

		vOpts := append(opts, db.WithValidateField("affected_user_geolocation_filter"))
		if err := fv(ctx, m.GetAffectedUserGeolocationFilter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["affected_user_ip_address_filter"]; exists {

		vOpts := append(opts, db.WithValidateField("affected_user_ip_address_filter"))
		if err := fv(ctx, m.GetAffectedUserIpAddressFilter(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAffectedUserFiltersValidator = func() *ValidateAffectedUserFilters {
	v := &ValidateAffectedUserFilters{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["affected_user_ip_address_filter"] = AffectedUserIPAddressFilterValidator().Validate

	v.FldValidators["affected_user_device_id_filter"] = AffectedUserDeviceIDFilterValidator().Validate

	v.FldValidators["affected_user_geolocation_filter"] = AffectedUserGeolocationFilterValidator().Validate

	return v
}()

func AffectedUserFiltersValidator() db.Validator {
	return DefaultAffectedUserFiltersValidator
}

// augmented methods on protoc/std generated struct

func (m *AffectedUserGeolocationFilter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AffectedUserGeolocationFilter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AffectedUserGeolocationFilter) DeepCopy() *AffectedUserGeolocationFilter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AffectedUserGeolocationFilter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AffectedUserGeolocationFilter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AffectedUserGeolocationFilter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AffectedUserGeolocationFilterValidator().Validate(ctx, m, opts...)
}

type ValidateAffectedUserGeolocationFilter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAffectedUserGeolocationFilter) OpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(FilterOperator)
		return int32(i)
	}
	// FilterOperator_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, FilterOperator_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for op")
	}

	return validatorFn, nil
}

func (v *ValidateAffectedUserGeolocationFilter) GeolocationsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for geolocations")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for geolocations")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated geolocations")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items geolocations")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAffectedUserGeolocationFilter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AffectedUserGeolocationFilter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AffectedUserGeolocationFilter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["geolocations"]; exists {
		vOpts := append(opts, db.WithValidateField("geolocations"))
		if err := fv(ctx, m.GetGeolocations(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["op"]; exists {

		vOpts := append(opts, db.WithValidateField("op"))
		if err := fv(ctx, m.GetOp(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAffectedUserGeolocationFilterValidator = func() *ValidateAffectedUserGeolocationFilter {
	v := &ValidateAffectedUserGeolocationFilter{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOp := v.OpValidationRuleHandler
	rulesOp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOp(rulesOp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AffectedUserGeolocationFilter.op: %s", err)
		panic(errMsg)
	}
	v.FldValidators["op"] = vFn

	vrhGeolocations := v.GeolocationsValidationRuleHandler
	rulesGeolocations := map[string]string{
		"ves.io.schema.rules.message.required":              "true",
		"ves.io.schema.rules.repeated.items.string.max_len": "256",
		"ves.io.schema.rules.repeated.max_items":            "64",
		"ves.io.schema.rules.repeated.min_items":            "1",
		"ves.io.schema.rules.repeated.unique":               "true",
	}
	vFn, err = vrhGeolocations(rulesGeolocations)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AffectedUserGeolocationFilter.geolocations: %s", err)
		panic(errMsg)
	}
	v.FldValidators["geolocations"] = vFn

	return v
}()

func AffectedUserGeolocationFilterValidator() db.Validator {
	return DefaultAffectedUserGeolocationFilterValidator
}

// augmented methods on protoc/std generated struct

func (m *AffectedUserIPAddressFilter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AffectedUserIPAddressFilter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AffectedUserIPAddressFilter) DeepCopy() *AffectedUserIPAddressFilter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AffectedUserIPAddressFilter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AffectedUserIPAddressFilter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AffectedUserIPAddressFilter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AffectedUserIPAddressFilterValidator().Validate(ctx, m, opts...)
}

type ValidateAffectedUserIPAddressFilter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAffectedUserIPAddressFilter) OpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(FilterOperator)
		return int32(i)
	}
	// FilterOperator_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, FilterOperator_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for op")
	}

	return validatorFn, nil
}

func (v *ValidateAffectedUserIPAddressFilter) IpAddressesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for ip_addresses")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ip_addresses")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ip_addresses")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ip_addresses")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAffectedUserIPAddressFilter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AffectedUserIPAddressFilter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AffectedUserIPAddressFilter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ip_addresses"]; exists {
		vOpts := append(opts, db.WithValidateField("ip_addresses"))
		if err := fv(ctx, m.GetIpAddresses(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["op"]; exists {

		vOpts := append(opts, db.WithValidateField("op"))
		if err := fv(ctx, m.GetOp(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAffectedUserIPAddressFilterValidator = func() *ValidateAffectedUserIPAddressFilter {
	v := &ValidateAffectedUserIPAddressFilter{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOp := v.OpValidationRuleHandler
	rulesOp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOp(rulesOp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AffectedUserIPAddressFilter.op: %s", err)
		panic(errMsg)
	}
	v.FldValidators["op"] = vFn

	vrhIpAddresses := v.IpAddressesValidationRuleHandler
	rulesIpAddresses := map[string]string{
		"ves.io.schema.rules.message.required":              "true",
		"ves.io.schema.rules.repeated.items.string.ip":      "true",
		"ves.io.schema.rules.repeated.items.string.max_len": "256",
		"ves.io.schema.rules.repeated.max_items":            "64",
		"ves.io.schema.rules.repeated.min_items":            "1",
		"ves.io.schema.rules.repeated.unique":               "true",
	}
	vFn, err = vrhIpAddresses(rulesIpAddresses)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AffectedUserIPAddressFilter.ip_addresses: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_addresses"] = vFn

	return v
}()

func AffectedUserIPAddressFilterValidator() db.Validator {
	return DefaultAffectedUserIPAddressFilterValidator
}

// augmented methods on protoc/std generated struct

func (m *Analysis) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Analysis) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Analysis) DeepCopy() *Analysis {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Analysis{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Analysis) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Analysis) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AnalysisValidator().Validate(ctx, m, opts...)
}

type ValidateAnalysis struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAnalysis) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Analysis)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Analysis got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["updated_by"]; exists {

		vOpts := append(opts, db.WithValidateField("updated_by"))
		if err := fv(ctx, m.GetUpdatedBy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAnalysisValidator = func() *ValidateAnalysis {
	v := &ValidateAnalysis{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AnalysisValidator() db.Validator {
	return DefaultAnalysisValidator
}

// augmented methods on protoc/std generated struct

func (m *AssociatedScript) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AssociatedScript) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AssociatedScript) DeepCopy() *AssociatedScript {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AssociatedScript{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AssociatedScript) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AssociatedScript) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AssociatedScriptValidator().Validate(ctx, m, opts...)
}

type ValidateAssociatedScript struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAssociatedScript) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AssociatedScript)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AssociatedScript got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["count"]; exists {

		vOpts := append(opts, db.WithValidateField("count"))
		if err := fv(ctx, m.GetCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["script"]; exists {

		vOpts := append(opts, db.WithValidateField("script"))
		if err := fv(ctx, m.GetScript(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAssociatedScriptValidator = func() *ValidateAssociatedScript {
	v := &ValidateAssociatedScript{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AssociatedScriptValidator() db.Validator {
	return DefaultAssociatedScriptValidator
}

// augmented methods on protoc/std generated struct

func (m *BehaviorByScript) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BehaviorByScript) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BehaviorByScript) DeepCopy() *BehaviorByScript {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BehaviorByScript{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BehaviorByScript) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BehaviorByScript) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BehaviorByScriptValidator().Validate(ctx, m, opts...)
}

type ValidateBehaviorByScript struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBehaviorByScript) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BehaviorByScript)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BehaviorByScript got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["category"]; exists {

		vOpts := append(opts, db.WithValidateField("category"))
		if err := fv(ctx, m.GetCategory(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["first_seen"]; exists {

		vOpts := append(opts, db.WithValidateField("first_seen"))
		if err := fv(ctx, m.GetFirstSeen(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["last_seen"]; exists {

		vOpts := append(opts, db.WithValidateField("last_seen"))
		if err := fv(ctx, m.GetLastSeen(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["recommendation"]; exists {

		vOpts := append(opts, db.WithValidateField("recommendation"))
		if err := fv(ctx, m.GetRecommendation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["risk_level"]; exists {

		vOpts := append(opts, db.WithValidateField("risk_level"))
		if err := fv(ctx, m.GetRiskLevel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["users_affected"]; exists {

		vOpts := append(opts, db.WithValidateField("users_affected"))
		if err := fv(ctx, m.GetUsersAffected(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBehaviorByScriptValidator = func() *ValidateBehaviorByScript {
	v := &ValidateBehaviorByScript{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BehaviorByScriptValidator() db.Validator {
	return DefaultBehaviorByScriptValidator
}

// augmented methods on protoc/std generated struct

func (m *DeleteScriptJustificationRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeleteScriptJustificationRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeleteScriptJustificationRequest) DeepCopy() *DeleteScriptJustificationRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeleteScriptJustificationRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeleteScriptJustificationRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeleteScriptJustificationRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeleteScriptJustificationRequestValidator().Validate(ctx, m, opts...)
}

type ValidateDeleteScriptJustificationRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeleteScriptJustificationRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeleteScriptJustificationRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeleteScriptJustificationRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["justification_id"]; exists {

		vOpts := append(opts, db.WithValidateField("justification_id"))
		if err := fv(ctx, m.GetJustificationId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeleteScriptJustificationRequestValidator = func() *ValidateDeleteScriptJustificationRequest {
	v := &ValidateDeleteScriptJustificationRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DeleteScriptJustificationRequestValidator() db.Validator {
	return DefaultDeleteScriptJustificationRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *DeleteScriptJustificationResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeleteScriptJustificationResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeleteScriptJustificationResponse) DeepCopy() *DeleteScriptJustificationResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeleteScriptJustificationResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeleteScriptJustificationResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeleteScriptJustificationResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeleteScriptJustificationResponseValidator().Validate(ctx, m, opts...)
}

type ValidateDeleteScriptJustificationResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeleteScriptJustificationResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeleteScriptJustificationResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeleteScriptJustificationResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeleteScriptJustificationResponseValidator = func() *ValidateDeleteScriptJustificationResponse {
	v := &ValidateDeleteScriptJustificationResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DeleteScriptJustificationResponseValidator() db.Validator {
	return DefaultDeleteScriptJustificationResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *DeviceIDFilter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeviceIDFilter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeviceIDFilter) DeepCopy() *DeviceIDFilter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeviceIDFilter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeviceIDFilter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeviceIDFilter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeviceIDFilterValidator().Validate(ctx, m, opts...)
}

type ValidateDeviceIDFilter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeviceIDFilter) OpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(FilterOperator)
		return int32(i)
	}
	// FilterOperator_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, FilterOperator_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for op")
	}

	return validatorFn, nil
}

func (v *ValidateDeviceIDFilter) DeviceIdStringsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for device_id_strings")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for device_id_strings")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated device_id_strings")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items device_id_strings")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDeviceIDFilter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeviceIDFilter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeviceIDFilter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["device_id_strings"]; exists {
		vOpts := append(opts, db.WithValidateField("device_id_strings"))
		if err := fv(ctx, m.GetDeviceIdStrings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["op"]; exists {

		vOpts := append(opts, db.WithValidateField("op"))
		if err := fv(ctx, m.GetOp(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeviceIDFilterValidator = func() *ValidateDeviceIDFilter {
	v := &ValidateDeviceIDFilter{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOp := v.OpValidationRuleHandler
	rulesOp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOp(rulesOp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DeviceIDFilter.op: %s", err)
		panic(errMsg)
	}
	v.FldValidators["op"] = vFn

	vrhDeviceIdStrings := v.DeviceIdStringsValidationRuleHandler
	rulesDeviceIdStrings := map[string]string{
		"ves.io.schema.rules.message.required":              "true",
		"ves.io.schema.rules.repeated.items.string.max_len": "256",
		"ves.io.schema.rules.repeated.max_items":            "64",
		"ves.io.schema.rules.repeated.min_items":            "1",
		"ves.io.schema.rules.repeated.unique":               "true",
	}
	vFn, err = vrhDeviceIdStrings(rulesDeviceIdStrings)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DeviceIDFilter.device_id_strings: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device_id_strings"] = vFn

	return v
}()

func DeviceIDFilterValidator() db.Validator {
	return DefaultDeviceIDFilterValidator
}

// augmented methods on protoc/std generated struct

func (m *DomainDetails) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DomainDetails) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DomainDetails) DeepCopy() *DomainDetails {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DomainDetails{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DomainDetails) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DomainDetails) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DomainDetailsValidator().Validate(ctx, m, opts...)
}

type ValidateDomainDetails struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDomainDetails) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DomainDetails)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DomainDetails got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["actionDate"]; exists {

		vOpts := append(opts, db.WithValidateField("actionDate"))
		if err := fv(ctx, m.GetActionDate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["category"]; exists {

		vOpts := append(opts, db.WithValidateField("category"))
		if err := fv(ctx, m.GetCategory(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domain"]; exists {

		vOpts := append(opts, db.WithValidateField("domain"))
		if err := fv(ctx, m.GetDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["firstSeenDate"]; exists {

		vOpts := append(opts, db.WithValidateField("firstSeenDate"))
		if err := fv(ctx, m.GetFirstSeenDate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["latestSeenDate"]; exists {

		vOpts := append(opts, db.WithValidateField("latestSeenDate"))
		if err := fv(ctx, m.GetLatestSeenDate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["locations"]; exists {

		vOpts := append(opts, db.WithValidateField("locations"))
		for idx, item := range m.GetLocations() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["riskReason"]; exists {

		vOpts := append(opts, db.WithValidateField("riskReason"))
		for idx, item := range m.GetRiskReason() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["riskScore"]; exists {

		vOpts := append(opts, db.WithValidateField("riskScore"))
		if err := fv(ctx, m.GetRiskScore(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDomainDetailsValidator = func() *ValidateDomainDetails {
	v := &ValidateDomainDetails{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DomainDetailsValidator() db.Validator {
	return DefaultDomainDetailsValidator
}

// augmented methods on protoc/std generated struct

func (m *DomainSummary) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DomainSummary) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DomainSummary) DeepCopy() *DomainSummary {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DomainSummary{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DomainSummary) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DomainSummary) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DomainSummaryValidator().Validate(ctx, m, opts...)
}

type ValidateDomainSummary struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDomainSummary) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DomainSummary)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DomainSummary got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["actionNeededCount"]; exists {

		vOpts := append(opts, db.WithValidateField("actionNeededCount"))
		if err := fv(ctx, m.GetActionNeededCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["allowedDomains"]; exists {

		vOpts := append(opts, db.WithValidateField("allowedDomains"))
		if err := fv(ctx, m.GetAllowedDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mitigatedDomains"]; exists {

		vOpts := append(opts, db.WithValidateField("mitigatedDomains"))
		if err := fv(ctx, m.GetMitigatedDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["totalDomains"]; exists {

		vOpts := append(opts, db.WithValidateField("totalDomains"))
		if err := fv(ctx, m.GetTotalDomains(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDomainSummaryValidator = func() *ValidateDomainSummary {
	v := &ValidateDomainSummary{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DomainSummaryValidator() db.Validator {
	return DefaultDomainSummaryValidator
}

// augmented methods on protoc/std generated struct

func (m *EnterpriseInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EnterpriseInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EnterpriseInfo) DeepCopy() *EnterpriseInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EnterpriseInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EnterpriseInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EnterpriseInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EnterpriseInfoValidator().Validate(ctx, m, opts...)
}

type ValidateEnterpriseInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEnterpriseInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EnterpriseInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EnterpriseInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["transactionCount"]; exists {

		vOpts := append(opts, db.WithValidateField("transactionCount"))
		if err := fv(ctx, m.GetTransactionCount(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEnterpriseInfoValidator = func() *ValidateEnterpriseInfo {
	v := &ValidateEnterpriseInfo{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func EnterpriseInfoValidator() db.Validator {
	return DefaultEnterpriseInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *Event) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Event) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Event) DeepCopy() *Event {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Event{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Event) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Event) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EventValidator().Validate(ctx, m, opts...)
}

type ValidateEvent struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEvent) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Event)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Event got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["date"]; exists {

		vOpts := append(opts, db.WithValidateField("date"))
		if err := fv(ctx, m.GetDate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["existing_behavior"]; exists {

		vOpts := append(opts, db.WithValidateField("existing_behavior"))
		if err := fv(ctx, m.GetExistingBehavior(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["new_behavior"]; exists {

		vOpts := append(opts, db.WithValidateField("new_behavior"))
		if err := fv(ctx, m.GetNewBehavior(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEventValidator = func() *ValidateEvent {
	v := &ValidateEvent{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func EventValidator() db.Validator {
	return DefaultEventValidator
}

// augmented methods on protoc/std generated struct

func (m *Filters) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Filters) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Filters) DeepCopy() *Filters {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Filters{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Filters) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Filters) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FiltersValidator().Validate(ctx, m, opts...)
}

type ValidateFilters struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFilters) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Filters)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Filters got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["device_id_filter"]; exists {

		vOpts := append(opts, db.WithValidateField("device_id_filter"))
		if err := fv(ctx, m.GetDeviceIdFilter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_filter"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_filter"))
		if err := fv(ctx, m.GetIpFilter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["risk_level_filter"]; exists {

		vOpts := append(opts, db.WithValidateField("risk_level_filter"))
		if err := fv(ctx, m.GetRiskLevelFilter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["script_name_filter"]; exists {

		vOpts := append(opts, db.WithValidateField("script_name_filter"))
		if err := fv(ctx, m.GetScriptNameFilter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["script_status_filter"]; exists {

		vOpts := append(opts, db.WithValidateField("script_status_filter"))
		if err := fv(ctx, m.GetScriptStatusFilter(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFiltersValidator = func() *ValidateFilters {
	v := &ValidateFilters{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["script_name_filter"] = ScriptNameFilterValidator().Validate

	v.FldValidators["risk_level_filter"] = RiskLevelFilterValidator().Validate

	v.FldValidators["script_status_filter"] = ScriptStatusFilterValidator().Validate

	v.FldValidators["ip_filter"] = IPFilterValidator().Validate

	v.FldValidators["device_id_filter"] = DeviceIDFilterValidator().Validate

	return v
}()

func FiltersValidator() db.Validator {
	return DefaultFiltersValidator
}

// augmented methods on protoc/std generated struct

func (m *FormField) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FormField) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FormField) DeepCopy() *FormField {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FormField{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FormField) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FormField) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FormFieldValidator().Validate(ctx, m, opts...)
}

type ValidateFormField struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFormField) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FormField)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FormField got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["analysis"]; exists {

		vOpts := append(opts, db.WithValidateField("analysis"))
		if err := fv(ctx, m.GetAnalysis(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["associated_scripts"]; exists {

		vOpts := append(opts, db.WithValidateField("associated_scripts"))
		for idx, item := range m.GetAssociatedScripts() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["first_read"]; exists {

		vOpts := append(opts, db.WithValidateField("first_read"))
		if err := fv(ctx, m.GetFirstRead(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["last_read"]; exists {

		vOpts := append(opts, db.WithValidateField("last_read"))
		if err := fv(ctx, m.GetLastRead(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["locations"]; exists {

		vOpts := append(opts, db.WithValidateField("locations"))
		for idx, item := range m.GetLocations() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFormFieldValidator = func() *ValidateFormField {
	v := &ValidateFormField{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FormFieldValidator() db.Validator {
	return DefaultFormFieldValidator
}

// augmented methods on protoc/std generated struct

func (m *FormFieldAnalysisFilter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FormFieldAnalysisFilter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FormFieldAnalysisFilter) DeepCopy() *FormFieldAnalysisFilter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FormFieldAnalysisFilter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FormFieldAnalysisFilter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FormFieldAnalysisFilter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FormFieldAnalysisFilterValidator().Validate(ctx, m, opts...)
}

type ValidateFormFieldAnalysisFilter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFormFieldAnalysisFilter) OpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(FilterOperator)
		return int32(i)
	}
	// FilterOperator_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, FilterOperator_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for op")
	}

	return validatorFn, nil
}

func (v *ValidateFormFieldAnalysisFilter) AnalysisStringsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for analysis_strings")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for analysis_strings")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated analysis_strings")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items analysis_strings")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateFormFieldAnalysisFilter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FormFieldAnalysisFilter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FormFieldAnalysisFilter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["analysis_strings"]; exists {
		vOpts := append(opts, db.WithValidateField("analysis_strings"))
		if err := fv(ctx, m.GetAnalysisStrings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["op"]; exists {

		vOpts := append(opts, db.WithValidateField("op"))
		if err := fv(ctx, m.GetOp(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFormFieldAnalysisFilterValidator = func() *ValidateFormFieldAnalysisFilter {
	v := &ValidateFormFieldAnalysisFilter{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOp := v.OpValidationRuleHandler
	rulesOp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOp(rulesOp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FormFieldAnalysisFilter.op: %s", err)
		panic(errMsg)
	}
	v.FldValidators["op"] = vFn

	vrhAnalysisStrings := v.AnalysisStringsValidationRuleHandler
	rulesAnalysisStrings := map[string]string{
		"ves.io.schema.rules.message.required":              "true",
		"ves.io.schema.rules.repeated.items.string.max_len": "128",
		"ves.io.schema.rules.repeated.max_items":            "10",
		"ves.io.schema.rules.repeated.min_items":            "1",
		"ves.io.schema.rules.repeated.unique":               "true",
	}
	vFn, err = vrhAnalysisStrings(rulesAnalysisStrings)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FormFieldAnalysisFilter.analysis_strings: %s", err)
		panic(errMsg)
	}
	v.FldValidators["analysis_strings"] = vFn

	return v
}()

func FormFieldAnalysisFilterValidator() db.Validator {
	return DefaultFormFieldAnalysisFilterValidator
}

// augmented methods on protoc/std generated struct

func (m *FormFieldByScript) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FormFieldByScript) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FormFieldByScript) DeepCopy() *FormFieldByScript {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FormFieldByScript{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FormFieldByScript) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FormFieldByScript) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FormFieldByScriptValidator().Validate(ctx, m, opts...)
}

type ValidateFormFieldByScript struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFormFieldByScript) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FormFieldByScript)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FormFieldByScript got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["first_read"]; exists {

		vOpts := append(opts, db.WithValidateField("first_read"))
		if err := fv(ctx, m.GetFirstRead(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["last_read"]; exists {

		vOpts := append(opts, db.WithValidateField("last_read"))
		if err := fv(ctx, m.GetLastRead(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["risk_level"]; exists {

		vOpts := append(opts, db.WithValidateField("risk_level"))
		if err := fv(ctx, m.GetRiskLevel(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFormFieldByScriptValidator = func() *ValidateFormFieldByScript {
	v := &ValidateFormFieldByScript{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FormFieldByScriptValidator() db.Validator {
	return DefaultFormFieldByScriptValidator
}

// augmented methods on protoc/std generated struct

func (m *FormFieldNameFilter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FormFieldNameFilter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FormFieldNameFilter) DeepCopy() *FormFieldNameFilter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FormFieldNameFilter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FormFieldNameFilter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FormFieldNameFilter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FormFieldNameFilterValidator().Validate(ctx, m, opts...)
}

type ValidateFormFieldNameFilter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFormFieldNameFilter) OpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(FilterOperator)
		return int32(i)
	}
	// FilterOperator_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, FilterOperator_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for op")
	}

	return validatorFn, nil
}

func (v *ValidateFormFieldNameFilter) NameStringsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for name_strings")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for name_strings")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated name_strings")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items name_strings")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateFormFieldNameFilter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FormFieldNameFilter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FormFieldNameFilter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name_strings"]; exists {
		vOpts := append(opts, db.WithValidateField("name_strings"))
		if err := fv(ctx, m.GetNameStrings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["op"]; exists {

		vOpts := append(opts, db.WithValidateField("op"))
		if err := fv(ctx, m.GetOp(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFormFieldNameFilterValidator = func() *ValidateFormFieldNameFilter {
	v := &ValidateFormFieldNameFilter{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOp := v.OpValidationRuleHandler
	rulesOp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOp(rulesOp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FormFieldNameFilter.op: %s", err)
		panic(errMsg)
	}
	v.FldValidators["op"] = vFn

	vrhNameStrings := v.NameStringsValidationRuleHandler
	rulesNameStrings := map[string]string{
		"ves.io.schema.rules.message.required":              "true",
		"ves.io.schema.rules.repeated.items.string.max_len": "256",
		"ves.io.schema.rules.repeated.max_items":            "64",
		"ves.io.schema.rules.repeated.min_items":            "1",
		"ves.io.schema.rules.repeated.unique":               "true",
	}
	vFn, err = vrhNameStrings(rulesNameStrings)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FormFieldNameFilter.name_strings: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name_strings"] = vFn

	return v
}()

func FormFieldNameFilterValidator() db.Validator {
	return DefaultFormFieldNameFilterValidator
}

// augmented methods on protoc/std generated struct

func (m *FormFieldsFilters) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FormFieldsFilters) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FormFieldsFilters) DeepCopy() *FormFieldsFilters {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FormFieldsFilters{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FormFieldsFilters) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FormFieldsFilters) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FormFieldsFiltersValidator().Validate(ctx, m, opts...)
}

type ValidateFormFieldsFilters struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFormFieldsFilters) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FormFieldsFilters)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FormFieldsFilters got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["form_field_analysis_filter"]; exists {

		vOpts := append(opts, db.WithValidateField("form_field_analysis_filter"))
		if err := fv(ctx, m.GetFormFieldAnalysisFilter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["form_field_name_filter"]; exists {

		vOpts := append(opts, db.WithValidateField("form_field_name_filter"))
		if err := fv(ctx, m.GetFormFieldNameFilter(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFormFieldsFiltersValidator = func() *ValidateFormFieldsFilters {
	v := &ValidateFormFieldsFilters{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["form_field_name_filter"] = FormFieldNameFilterValidator().Validate

	v.FldValidators["form_field_analysis_filter"] = FormFieldAnalysisFilterValidator().Validate

	return v
}()

func FormFieldsFiltersValidator() db.Validator {
	return DefaultFormFieldsFiltersValidator
}

// augmented methods on protoc/std generated struct

func (m *GetDetectedDomainsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetDetectedDomainsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetDetectedDomainsRequest) DeepCopy() *GetDetectedDomainsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetDetectedDomainsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetDetectedDomainsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetDetectedDomainsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetDetectedDomainsRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetDetectedDomainsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetDetectedDomainsRequest) RiskValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for risk")
	}

	return validatorFn, nil
}

func (v *ValidateGetDetectedDomainsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetDetectedDomainsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetDetectedDomainsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["duration"]; exists {

		vOpts := append(opts, db.WithValidateField("duration"))
		if err := fv(ctx, m.GetDuration(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["locations"]; exists {

		vOpts := append(opts, db.WithValidateField("locations"))
		if err := fv(ctx, m.GetLocations(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["risk"]; exists {

		vOpts := append(opts, db.WithValidateField("risk"))
		if err := fv(ctx, m.GetRisk(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetDetectedDomainsRequestValidator = func() *ValidateGetDetectedDomainsRequest {
	v := &ValidateGetDetectedDomainsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRisk := v.RiskValidationRuleHandler
	rulesRisk := map[string]string{
		"ves.io.schema.rules.string.in": "[\"high\", \"\"]",
	}
	vFn, err = vrhRisk(rulesRisk)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetDetectedDomainsRequest.risk: %s", err)
		panic(errMsg)
	}
	v.FldValidators["risk"] = vFn

	return v
}()

func GetDetectedDomainsRequestValidator() db.Validator {
	return DefaultGetDetectedDomainsRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetDetectedDomainsResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetDetectedDomainsResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetDetectedDomainsResponse) DeepCopy() *GetDetectedDomainsResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetDetectedDomainsResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetDetectedDomainsResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetDetectedDomainsResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetDetectedDomainsResponseValidator().Validate(ctx, m, opts...)
}

type ValidateGetDetectedDomainsResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetDetectedDomainsResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetDetectedDomainsResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetDetectedDomainsResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["customer"]; exists {

		vOpts := append(opts, db.WithValidateField("customer"))
		if err := fv(ctx, m.GetCustomer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domainSummary"]; exists {

		vOpts := append(opts, db.WithValidateField("domainSummary"))
		if err := fv(ctx, m.GetDomainSummary(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domainsList"]; exists {

		vOpts := append(opts, db.WithValidateField("domainsList"))
		for idx, item := range m.GetDomainsList() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["locationList"]; exists {

		vOpts := append(opts, db.WithValidateField("locationList"))
		for key, value := range m.GetLocationList() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetDetectedDomainsResponseValidator = func() *ValidateGetDetectedDomainsResponse {
	v := &ValidateGetDetectedDomainsResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetDetectedDomainsResponseValidator() db.Validator {
	return DefaultGetDetectedDomainsResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *GetDomainDetailsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetDomainDetailsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetDomainDetailsRequest) DeepCopy() *GetDomainDetailsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetDomainDetailsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetDomainDetailsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetDomainDetailsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetDomainDetailsRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetDomainDetailsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetDomainDetailsRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateGetDomainDetailsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetDomainDetailsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetDomainDetailsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetDomainDetailsRequestValidator = func() *ValidateGetDomainDetailsRequest {
	v := &ValidateGetDomainDetailsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetDomainDetailsRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func GetDomainDetailsRequestValidator() db.Validator {
	return DefaultGetDomainDetailsRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetDomainDetailsResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetDomainDetailsResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetDomainDetailsResponse) DeepCopy() *GetDomainDetailsResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetDomainDetailsResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetDomainDetailsResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetDomainDetailsResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetDomainDetailsResponseValidator().Validate(ctx, m, opts...)
}

type ValidateGetDomainDetailsResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetDomainDetailsResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetDomainDetailsResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetDomainDetailsResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["actionDate"]; exists {

		vOpts := append(opts, db.WithValidateField("actionDate"))
		if err := fv(ctx, m.GetActionDate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["category"]; exists {

		vOpts := append(opts, db.WithValidateField("category"))
		if err := fv(ctx, m.GetCategory(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domain"]; exists {

		vOpts := append(opts, db.WithValidateField("domain"))
		if err := fv(ctx, m.GetDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["firstSeenDate"]; exists {

		vOpts := append(opts, db.WithValidateField("firstSeenDate"))
		if err := fv(ctx, m.GetFirstSeenDate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["latestSeenDate"]; exists {

		vOpts := append(opts, db.WithValidateField("latestSeenDate"))
		if err := fv(ctx, m.GetLatestSeenDate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["locations"]; exists {

		vOpts := append(opts, db.WithValidateField("locations"))
		for idx, item := range m.GetLocations() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["riskReason"]; exists {

		vOpts := append(opts, db.WithValidateField("riskReason"))
		for idx, item := range m.GetRiskReason() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["riskScore"]; exists {

		vOpts := append(opts, db.WithValidateField("riskScore"))
		if err := fv(ctx, m.GetRiskScore(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetDomainDetailsResponseValidator = func() *ValidateGetDomainDetailsResponse {
	v := &ValidateGetDomainDetailsResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetDomainDetailsResponseValidator() db.Validator {
	return DefaultGetDomainDetailsResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *GetFormFieldRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetFormFieldRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetFormFieldRequest) DeepCopy() *GetFormFieldRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetFormFieldRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetFormFieldRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetFormFieldRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetFormFieldRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetFormFieldRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetFormFieldRequest) IdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for id")
	}

	return validatorFn, nil
}

func (v *ValidateGetFormFieldRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetFormFieldRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetFormFieldRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetFormFieldRequestValidator = func() *ValidateGetFormFieldRequest {
	v := &ValidateGetFormFieldRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhId := v.IdValidationRuleHandler
	rulesId := map[string]string{
		"ves.io.schema.rules.string.max_len":   "15",
		"ves.io.schema.rules.string.not_empty": "true",
	}
	vFn, err = vrhId(rulesId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetFormFieldRequest.id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["id"] = vFn

	return v
}()

func GetFormFieldRequestValidator() db.Validator {
	return DefaultGetFormFieldRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetFormFieldResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetFormFieldResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetFormFieldResponse) DeepCopy() *GetFormFieldResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetFormFieldResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetFormFieldResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetFormFieldResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetFormFieldResponseValidator().Validate(ctx, m, opts...)
}

type ValidateGetFormFieldResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetFormFieldResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetFormFieldResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetFormFieldResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["associated_scripts"]; exists {

		vOpts := append(opts, db.WithValidateField("associated_scripts"))
		for idx, item := range m.GetAssociatedScripts() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetFormFieldResponseValidator = func() *ValidateGetFormFieldResponse {
	v := &ValidateGetFormFieldResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetFormFieldResponseValidator() db.Validator {
	return DefaultGetFormFieldResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *GetJsInjectionConfigurationRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetJsInjectionConfigurationRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetJsInjectionConfigurationRequest) DeepCopy() *GetJsInjectionConfigurationRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetJsInjectionConfigurationRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetJsInjectionConfigurationRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetJsInjectionConfigurationRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetJsInjectionConfigurationRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetJsInjectionConfigurationRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetJsInjectionConfigurationRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetJsInjectionConfigurationRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetJsInjectionConfigurationRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetJsInjectionConfigurationRequestValidator = func() *ValidateGetJsInjectionConfigurationRequest {
	v := &ValidateGetJsInjectionConfigurationRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetJsInjectionConfigurationRequestValidator() db.Validator {
	return DefaultGetJsInjectionConfigurationRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetJsInjectionConfigurationResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetJsInjectionConfigurationResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetJsInjectionConfigurationResponse) DeepCopy() *GetJsInjectionConfigurationResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetJsInjectionConfigurationResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetJsInjectionConfigurationResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetJsInjectionConfigurationResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetJsInjectionConfigurationResponseValidator().Validate(ctx, m, opts...)
}

type ValidateGetJsInjectionConfigurationResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetJsInjectionConfigurationResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetJsInjectionConfigurationResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetJsInjectionConfigurationResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["scriptTag"]; exists {

		vOpts := append(opts, db.WithValidateField("scriptTag"))
		if err := fv(ctx, m.GetScriptTag(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetJsInjectionConfigurationResponseValidator = func() *ValidateGetJsInjectionConfigurationResponse {
	v := &ValidateGetJsInjectionConfigurationResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetJsInjectionConfigurationResponseValidator() db.Validator {
	return DefaultGetJsInjectionConfigurationResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *GetScriptOverviewRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetScriptOverviewRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetScriptOverviewRequest) DeepCopy() *GetScriptOverviewRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetScriptOverviewRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetScriptOverviewRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetScriptOverviewRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetScriptOverviewRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetScriptOverviewRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetScriptOverviewRequest) IdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for id")
	}

	return validatorFn, nil
}

func (v *ValidateGetScriptOverviewRequest) TypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(BEHAVIOR_TYPE)
		return int32(i)
	}
	// BEHAVIOR_TYPE_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, BEHAVIOR_TYPE_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for type")
	}

	return validatorFn, nil
}

func (v *ValidateGetScriptOverviewRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateGetScriptOverviewRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateGetScriptOverviewRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetScriptOverviewRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetScriptOverviewRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetScriptOverviewRequestValidator = func() *ValidateGetScriptOverviewRequest {
	v := &ValidateGetScriptOverviewRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhId := v.IdValidationRuleHandler
	rulesId := map[string]string{
		"ves.io.schema.rules.string.not_empty": "true",
	}
	vFn, err = vrhId(rulesId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetScriptOverviewRequest.id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["id"] = vFn

	vrhType := v.TypeValidationRuleHandler
	rulesType := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.message.required":  "true",
	}
	vFn, err = vrhType(rulesType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetScriptOverviewRequest.type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["type"] = vFn

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetScriptOverviewRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetScriptOverviewRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	return v
}()

func GetScriptOverviewRequestValidator() db.Validator {
	return DefaultGetScriptOverviewRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetScriptOverviewResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetScriptOverviewResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetScriptOverviewResponse) DeepCopy() *GetScriptOverviewResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetScriptOverviewResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetScriptOverviewResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetScriptOverviewResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetScriptOverviewResponseValidator().Validate(ctx, m, opts...)
}

type ValidateGetScriptOverviewResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetScriptOverviewResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetScriptOverviewResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetScriptOverviewResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["events"]; exists {

		vOpts := append(opts, db.WithValidateField("events"))
		for idx, item := range m.GetEvents() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["summary"]; exists {

		vOpts := append(opts, db.WithValidateField("summary"))
		if err := fv(ctx, m.GetSummary(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetScriptOverviewResponseValidator = func() *ValidateGetScriptOverviewResponse {
	v := &ValidateGetScriptOverviewResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetScriptOverviewResponseValidator() db.Validator {
	return DefaultGetScriptOverviewResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *GetStatusRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetStatusRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetStatusRequest) DeepCopy() *GetStatusRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetStatusRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetStatusRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetStatusRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetStatusRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetStatusRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetStatusRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetStatusRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetStatusRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetStatusRequestValidator = func() *ValidateGetStatusRequest {
	v := &ValidateGetStatusRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetStatusRequestValidator() db.Validator {
	return DefaultGetStatusRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetStatusResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetStatusResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetStatusResponse) DeepCopy() *GetStatusResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetStatusResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetStatusResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetStatusResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetStatusResponseValidator().Validate(ctx, m, opts...)
}

type ValidateGetStatusResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetStatusResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetStatusResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetStatusResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["isConfigured"]; exists {

		vOpts := append(opts, db.WithValidateField("isConfigured"))
		if err := fv(ctx, m.GetIsConfigured(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["isEnabled"]; exists {

		vOpts := append(opts, db.WithValidateField("isEnabled"))
		if err := fv(ctx, m.GetIsEnabled(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetStatusResponseValidator = func() *ValidateGetStatusResponse {
	v := &ValidateGetStatusResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetStatusResponseValidator() db.Validator {
	return DefaultGetStatusResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSummaryRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSummaryRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetSummaryRequest) DeepCopy() *GetSummaryRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSummaryRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSummaryRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSummaryRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSummaryRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetSummaryRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSummaryRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSummaryRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSummaryRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSummaryRequestValidator = func() *ValidateGetSummaryRequest {
	v := &ValidateGetSummaryRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetSummaryRequestValidator() db.Validator {
	return DefaultGetSummaryRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSummaryResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSummaryResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetSummaryResponse) DeepCopy() *GetSummaryResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSummaryResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSummaryResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSummaryResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSummaryResponseValidator().Validate(ctx, m, opts...)
}

type ValidateGetSummaryResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSummaryResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSummaryResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSummaryResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["blocked_scripts"]; exists {

		vOpts := append(opts, db.WithValidateField("blocked_scripts"))
		if err := fv(ctx, m.GetBlockedScripts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mitigated_domains"]; exists {

		vOpts := append(opts, db.WithValidateField("mitigated_domains"))
		if err := fv(ctx, m.GetMitigatedDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["suspicious_scripts"]; exists {

		vOpts := append(opts, db.WithValidateField("suspicious_scripts"))
		if err := fv(ctx, m.GetSuspiciousScripts(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSummaryResponseValidator = func() *ValidateGetSummaryResponse {
	v := &ValidateGetSummaryResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetSummaryResponseValidator() db.Validator {
	return DefaultGetSummaryResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *IPFilter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IPFilter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IPFilter) DeepCopy() *IPFilter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IPFilter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IPFilter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IPFilter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IPFilterValidator().Validate(ctx, m, opts...)
}

type ValidateIPFilter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIPFilter) OpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(FilterOperator)
		return int32(i)
	}
	// FilterOperator_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, FilterOperator_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for op")
	}

	return validatorFn, nil
}

func (v *ValidateIPFilter) IpStringsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for ip_strings")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ip_strings")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ip_strings")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ip_strings")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateIPFilter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IPFilter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IPFilter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ip_strings"]; exists {
		vOpts := append(opts, db.WithValidateField("ip_strings"))
		if err := fv(ctx, m.GetIpStrings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["op"]; exists {

		vOpts := append(opts, db.WithValidateField("op"))
		if err := fv(ctx, m.GetOp(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIPFilterValidator = func() *ValidateIPFilter {
	v := &ValidateIPFilter{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOp := v.OpValidationRuleHandler
	rulesOp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOp(rulesOp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IPFilter.op: %s", err)
		panic(errMsg)
	}
	v.FldValidators["op"] = vFn

	vrhIpStrings := v.IpStringsValidationRuleHandler
	rulesIpStrings := map[string]string{
		"ves.io.schema.rules.message.required":              "true",
		"ves.io.schema.rules.repeated.items.string.ip":      "true",
		"ves.io.schema.rules.repeated.items.string.max_len": "256",
		"ves.io.schema.rules.repeated.max_items":            "64",
		"ves.io.schema.rules.repeated.min_items":            "1",
		"ves.io.schema.rules.repeated.unique":               "true",
	}
	vFn, err = vrhIpStrings(rulesIpStrings)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IPFilter.ip_strings: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_strings"] = vFn

	return v
}()

func IPFilterValidator() db.Validator {
	return DefaultIPFilterValidator
}

// augmented methods on protoc/std generated struct

func (m *InitRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InitRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InitRequest) DeepCopy() *InitRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InitRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InitRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InitRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InitRequestValidator().Validate(ctx, m, opts...)
}

type ValidateInitRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInitRequest) ServiceTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for serviceType")
	}

	return validatorFn, nil
}

func (v *ValidateInitRequest) EmailValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for email")
	}

	return validatorFn, nil
}

func (v *ValidateInitRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InitRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InitRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["email"]; exists {

		vOpts := append(opts, db.WithValidateField("email"))
		if err := fv(ctx, m.GetEmail(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["serviceType"]; exists {

		vOpts := append(opts, db.WithValidateField("serviceType"))
		if err := fv(ctx, m.GetServiceType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInitRequestValidator = func() *ValidateInitRequest {
	v := &ValidateInitRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhServiceType := v.ServiceTypeValidationRuleHandler
	rulesServiceType := map[string]string{
		"ves.io.schema.rules.string.in": "[\"csd-service\"]",
	}
	vFn, err = vrhServiceType(rulesServiceType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for InitRequest.serviceType: %s", err)
		panic(errMsg)
	}
	v.FldValidators["serviceType"] = vFn

	vrhEmail := v.EmailValidationRuleHandler
	rulesEmail := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.email":     "true",
		"ves.io.schema.rules.string.not_empty": "true",
	}
	vFn, err = vrhEmail(rulesEmail)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for InitRequest.email: %s", err)
		panic(errMsg)
	}
	v.FldValidators["email"] = vFn

	return v
}()

func InitRequestValidator() db.Validator {
	return DefaultInitRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *InitResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InitResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InitResponse) DeepCopy() *InitResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InitResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InitResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InitResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InitResponseValidator().Validate(ctx, m, opts...)
}

type ValidateInitResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInitResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InitResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InitResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["isConfigured"]; exists {

		vOpts := append(opts, db.WithValidateField("isConfigured"))
		if err := fv(ctx, m.GetIsConfigured(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInitResponseValidator = func() *ValidateInitResponse {
	v := &ValidateInitResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func InitResponseValidator() db.Validator {
	return DefaultInitResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *Justification) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Justification) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Justification) DeepCopy() *Justification {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Justification{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Justification) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Justification) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JustificationValidator().Validate(ctx, m, opts...)
}

type ValidateJustification struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJustification) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Justification)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Justification got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["create_time"]; exists {

		vOpts := append(opts, db.WithValidateField("create_time"))
		if err := fv(ctx, m.GetCreateTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["justification"]; exists {

		vOpts := append(opts, db.WithValidateField("justification"))
		if err := fv(ctx, m.GetJustification(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["justification_id"]; exists {

		vOpts := append(opts, db.WithValidateField("justification_id"))
		if err := fv(ctx, m.GetJustificationId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_id"]; exists {

		vOpts := append(opts, db.WithValidateField("user_id"))
		if err := fv(ctx, m.GetUserId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJustificationValidator = func() *ValidateJustification {
	v := &ValidateJustification{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func JustificationValidator() db.Validator {
	return DefaultJustificationValidator
}

// augmented methods on protoc/std generated struct

func (m *ListAffectedUsersRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListAffectedUsersRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListAffectedUsersRequest) DeepCopy() *ListAffectedUsersRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListAffectedUsersRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListAffectedUsersRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListAffectedUsersRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListAffectedUsersRequestValidator().Validate(ctx, m, opts...)
}

type ValidateListAffectedUsersRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListAffectedUsersRequest) ScriptIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for script_id")
	}

	return validatorFn, nil
}

func (v *ValidateListAffectedUsersRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateListAffectedUsersRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateListAffectedUsersRequest) PageSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewInt32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for page_size")
	}

	return validatorFn, nil
}

func (v *ValidateListAffectedUsersRequest) PageNumberValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewInt32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for page_number")
	}

	return validatorFn, nil
}

func (v *ValidateListAffectedUsersRequest) PageTokenValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for page_token")
	}

	return validatorFn, nil
}

func (v *ValidateListAffectedUsersRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListAffectedUsersRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListAffectedUsersRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["filters"]; exists {

		vOpts := append(opts, db.WithValidateField("filters"))
		if err := fv(ctx, m.GetFilters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_number"]; exists {

		vOpts := append(opts, db.WithValidateField("page_number"))
		if err := fv(ctx, m.GetPageNumber(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_size"]; exists {

		vOpts := append(opts, db.WithValidateField("page_size"))
		if err := fv(ctx, m.GetPageSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_token"]; exists {

		vOpts := append(opts, db.WithValidateField("page_token"))
		if err := fv(ctx, m.GetPageToken(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["script_id"]; exists {

		vOpts := append(opts, db.WithValidateField("script_id"))
		if err := fv(ctx, m.GetScriptId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sorts"]; exists {

		vOpts := append(opts, db.WithValidateField("sorts"))
		for idx, item := range m.GetSorts() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListAffectedUsersRequestValidator = func() *ValidateListAffectedUsersRequest {
	v := &ValidateListAffectedUsersRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhScriptId := v.ScriptIdValidationRuleHandler
	rulesScriptId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhScriptId(rulesScriptId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListAffectedUsersRequest.script_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["script_id"] = vFn

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.message.required":  "true",
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListAffectedUsersRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.message.required":  "true",
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListAffectedUsersRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	vrhPageSize := v.PageSizeValidationRuleHandler
	rulesPageSize := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "1000",
	}
	vFn, err = vrhPageSize(rulesPageSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListAffectedUsersRequest.page_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["page_size"] = vFn

	vrhPageNumber := v.PageNumberValidationRuleHandler
	rulesPageNumber := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
	}
	vFn, err = vrhPageNumber(rulesPageNumber)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListAffectedUsersRequest.page_number: %s", err)
		panic(errMsg)
	}
	v.FldValidators["page_number"] = vFn

	vrhPageToken := v.PageTokenValidationRuleHandler
	rulesPageToken := map[string]string{
		"ves.io.schema.rules.string.max_len": "512",
	}
	vFn, err = vrhPageToken(rulesPageToken)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListAffectedUsersRequest.page_token: %s", err)
		panic(errMsg)
	}
	v.FldValidators["page_token"] = vFn

	v.FldValidators["filters"] = AffectedUserFiltersValidator().Validate

	return v
}()

func ListAffectedUsersRequestValidator() db.Validator {
	return DefaultListAffectedUsersRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListAffectedUsersResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListAffectedUsersResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListAffectedUsersResponse) DeepCopy() *ListAffectedUsersResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListAffectedUsersResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListAffectedUsersResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListAffectedUsersResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListAffectedUsersResponseValidator().Validate(ctx, m, opts...)
}

type ValidateListAffectedUsersResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListAffectedUsersResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListAffectedUsersResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListAffectedUsersResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["affected_users"]; exists {

		vOpts := append(opts, db.WithValidateField("affected_users"))
		for idx, item := range m.GetAffectedUsers() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["next_page_token"]; exists {

		vOpts := append(opts, db.WithValidateField("next_page_token"))
		if err := fv(ctx, m.GetNextPageToken(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_number"]; exists {

		vOpts := append(opts, db.WithValidateField("page_number"))
		if err := fv(ctx, m.GetPageNumber(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_size"]; exists {

		vOpts := append(opts, db.WithValidateField("page_size"))
		if err := fv(ctx, m.GetPageSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["total_count"]; exists {

		vOpts := append(opts, db.WithValidateField("total_count"))
		if err := fv(ctx, m.GetTotalCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["total_pages"]; exists {

		vOpts := append(opts, db.WithValidateField("total_pages"))
		if err := fv(ctx, m.GetTotalPages(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListAffectedUsersResponseValidator = func() *ValidateListAffectedUsersResponse {
	v := &ValidateListAffectedUsersResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["affected_users"] = AffectedUserValidator().Validate

	return v
}()

func ListAffectedUsersResponseValidator() db.Validator {
	return DefaultListAffectedUsersResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListBehaviorsByScriptRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListBehaviorsByScriptRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListBehaviorsByScriptRequest) DeepCopy() *ListBehaviorsByScriptRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListBehaviorsByScriptRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListBehaviorsByScriptRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListBehaviorsByScriptRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListBehaviorsByScriptRequestValidator().Validate(ctx, m, opts...)
}

type ValidateListBehaviorsByScriptRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListBehaviorsByScriptRequest) IdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for id")
	}

	return validatorFn, nil
}

func (v *ValidateListBehaviorsByScriptRequest) TypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(BEHAVIOR_TYPE)
		return int32(i)
	}
	// BEHAVIOR_TYPE_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, BEHAVIOR_TYPE_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for type")
	}

	return validatorFn, nil
}

func (v *ValidateListBehaviorsByScriptRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateListBehaviorsByScriptRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateListBehaviorsByScriptRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListBehaviorsByScriptRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListBehaviorsByScriptRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListBehaviorsByScriptRequestValidator = func() *ValidateListBehaviorsByScriptRequest {
	v := &ValidateListBehaviorsByScriptRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhId := v.IdValidationRuleHandler
	rulesId := map[string]string{
		"ves.io.schema.rules.string.not_empty": "true",
	}
	vFn, err = vrhId(rulesId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListBehaviorsByScriptRequest.id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["id"] = vFn

	vrhType := v.TypeValidationRuleHandler
	rulesType := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.message.required":  "true",
	}
	vFn, err = vrhType(rulesType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListBehaviorsByScriptRequest.type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["type"] = vFn

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListBehaviorsByScriptRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListBehaviorsByScriptRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	return v
}()

func ListBehaviorsByScriptRequestValidator() db.Validator {
	return DefaultListBehaviorsByScriptRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListBehaviorsByScriptResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListBehaviorsByScriptResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListBehaviorsByScriptResponse) DeepCopy() *ListBehaviorsByScriptResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListBehaviorsByScriptResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListBehaviorsByScriptResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListBehaviorsByScriptResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListBehaviorsByScriptResponseValidator().Validate(ctx, m, opts...)
}

type ValidateListBehaviorsByScriptResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListBehaviorsByScriptResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListBehaviorsByScriptResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListBehaviorsByScriptResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["behaviors"]; exists {

		vOpts := append(opts, db.WithValidateField("behaviors"))
		for idx, item := range m.GetBehaviors() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["total_size"]; exists {

		vOpts := append(opts, db.WithValidateField("total_size"))
		if err := fv(ctx, m.GetTotalSize(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListBehaviorsByScriptResponseValidator = func() *ValidateListBehaviorsByScriptResponse {
	v := &ValidateListBehaviorsByScriptResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListBehaviorsByScriptResponseValidator() db.Validator {
	return DefaultListBehaviorsByScriptResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListFormFieldsByScriptRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListFormFieldsByScriptRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListFormFieldsByScriptRequest) DeepCopy() *ListFormFieldsByScriptRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListFormFieldsByScriptRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListFormFieldsByScriptRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListFormFieldsByScriptRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListFormFieldsByScriptRequestValidator().Validate(ctx, m, opts...)
}

type ValidateListFormFieldsByScriptRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListFormFieldsByScriptRequest) IdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for id")
	}

	return validatorFn, nil
}

func (v *ValidateListFormFieldsByScriptRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateListFormFieldsByScriptRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateListFormFieldsByScriptRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListFormFieldsByScriptRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListFormFieldsByScriptRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListFormFieldsByScriptRequestValidator = func() *ValidateListFormFieldsByScriptRequest {
	v := &ValidateListFormFieldsByScriptRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhId := v.IdValidationRuleHandler
	rulesId := map[string]string{
		"ves.io.schema.rules.string.not_empty": "true",
	}
	vFn, err = vrhId(rulesId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListFormFieldsByScriptRequest.id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["id"] = vFn

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListFormFieldsByScriptRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListFormFieldsByScriptRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	return v
}()

func ListFormFieldsByScriptRequestValidator() db.Validator {
	return DefaultListFormFieldsByScriptRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListFormFieldsByScriptResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListFormFieldsByScriptResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListFormFieldsByScriptResponse) DeepCopy() *ListFormFieldsByScriptResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListFormFieldsByScriptResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListFormFieldsByScriptResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListFormFieldsByScriptResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListFormFieldsByScriptResponseValidator().Validate(ctx, m, opts...)
}

type ValidateListFormFieldsByScriptResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListFormFieldsByScriptResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListFormFieldsByScriptResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListFormFieldsByScriptResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["form_fields"]; exists {

		vOpts := append(opts, db.WithValidateField("form_fields"))
		for idx, item := range m.GetFormFields() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["total_size"]; exists {

		vOpts := append(opts, db.WithValidateField("total_size"))
		if err := fv(ctx, m.GetTotalSize(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListFormFieldsByScriptResponseValidator = func() *ValidateListFormFieldsByScriptResponse {
	v := &ValidateListFormFieldsByScriptResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListFormFieldsByScriptResponseValidator() db.Validator {
	return DefaultListFormFieldsByScriptResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListFormFieldsGetRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListFormFieldsGetRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListFormFieldsGetRequest) DeepCopy() *ListFormFieldsGetRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListFormFieldsGetRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListFormFieldsGetRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListFormFieldsGetRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListFormFieldsGetRequestValidator().Validate(ctx, m, opts...)
}

type ValidateListFormFieldsGetRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListFormFieldsGetRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateListFormFieldsGetRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateListFormFieldsGetRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListFormFieldsGetRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListFormFieldsGetRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListFormFieldsGetRequestValidator = func() *ValidateListFormFieldsGetRequest {
	v := &ValidateListFormFieldsGetRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListFormFieldsGetRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListFormFieldsGetRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	return v
}()

func ListFormFieldsGetRequestValidator() db.Validator {
	return DefaultListFormFieldsGetRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListFormFieldsGetResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListFormFieldsGetResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListFormFieldsGetResponse) DeepCopy() *ListFormFieldsGetResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListFormFieldsGetResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListFormFieldsGetResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListFormFieldsGetResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListFormFieldsGetResponseValidator().Validate(ctx, m, opts...)
}

type ValidateListFormFieldsGetResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListFormFieldsGetResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListFormFieldsGetResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListFormFieldsGetResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["form_fields"]; exists {

		vOpts := append(opts, db.WithValidateField("form_fields"))
		for idx, item := range m.GetFormFields() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["total_size"]; exists {

		vOpts := append(opts, db.WithValidateField("total_size"))
		if err := fv(ctx, m.GetTotalSize(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListFormFieldsGetResponseValidator = func() *ValidateListFormFieldsGetResponse {
	v := &ValidateListFormFieldsGetResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListFormFieldsGetResponseValidator() db.Validator {
	return DefaultListFormFieldsGetResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListFormFieldsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListFormFieldsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListFormFieldsRequest) DeepCopy() *ListFormFieldsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListFormFieldsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListFormFieldsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListFormFieldsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListFormFieldsRequestValidator().Validate(ctx, m, opts...)
}

type ValidateListFormFieldsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListFormFieldsRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateListFormFieldsRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateListFormFieldsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListFormFieldsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListFormFieldsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["filters"]; exists {

		vOpts := append(opts, db.WithValidateField("filters"))
		if err := fv(ctx, m.GetFilters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_number"]; exists {

		vOpts := append(opts, db.WithValidateField("page_number"))
		if err := fv(ctx, m.GetPageNumber(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_size"]; exists {

		vOpts := append(opts, db.WithValidateField("page_size"))
		if err := fv(ctx, m.GetPageSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_token"]; exists {

		vOpts := append(opts, db.WithValidateField("page_token"))
		if err := fv(ctx, m.GetPageToken(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sorts"]; exists {

		vOpts := append(opts, db.WithValidateField("sorts"))
		for idx, item := range m.GetSorts() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListFormFieldsRequestValidator = func() *ValidateListFormFieldsRequest {
	v := &ValidateListFormFieldsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListFormFieldsRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListFormFieldsRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	v.FldValidators["filters"] = FormFieldsFiltersValidator().Validate

	return v
}()

func ListFormFieldsRequestValidator() db.Validator {
	return DefaultListFormFieldsRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListFormFieldsResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListFormFieldsResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListFormFieldsResponse) DeepCopy() *ListFormFieldsResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListFormFieldsResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListFormFieldsResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListFormFieldsResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListFormFieldsResponseValidator().Validate(ctx, m, opts...)
}

type ValidateListFormFieldsResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListFormFieldsResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListFormFieldsResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListFormFieldsResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["form_fields"]; exists {

		vOpts := append(opts, db.WithValidateField("form_fields"))
		for idx, item := range m.GetFormFields() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["next_page_token"]; exists {

		vOpts := append(opts, db.WithValidateField("next_page_token"))
		if err := fv(ctx, m.GetNextPageToken(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_number"]; exists {

		vOpts := append(opts, db.WithValidateField("page_number"))
		if err := fv(ctx, m.GetPageNumber(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_size"]; exists {

		vOpts := append(opts, db.WithValidateField("page_size"))
		if err := fv(ctx, m.GetPageSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["total_count"]; exists {

		vOpts := append(opts, db.WithValidateField("total_count"))
		if err := fv(ctx, m.GetTotalCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["total_pages"]; exists {

		vOpts := append(opts, db.WithValidateField("total_pages"))
		if err := fv(ctx, m.GetTotalPages(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["total_size"]; exists {

		vOpts := append(opts, db.WithValidateField("total_size"))
		if err := fv(ctx, m.GetTotalSize(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListFormFieldsResponseValidator = func() *ValidateListFormFieldsResponse {
	v := &ValidateListFormFieldsResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListFormFieldsResponseValidator() db.Validator {
	return DefaultListFormFieldsResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListNetworkInteractionsByScriptRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListNetworkInteractionsByScriptRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListNetworkInteractionsByScriptRequest) DeepCopy() *ListNetworkInteractionsByScriptRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListNetworkInteractionsByScriptRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListNetworkInteractionsByScriptRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListNetworkInteractionsByScriptRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListNetworkInteractionsByScriptRequestValidator().Validate(ctx, m, opts...)
}

type ValidateListNetworkInteractionsByScriptRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListNetworkInteractionsByScriptRequest) IdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for id")
	}

	return validatorFn, nil
}

func (v *ValidateListNetworkInteractionsByScriptRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateListNetworkInteractionsByScriptRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateListNetworkInteractionsByScriptRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListNetworkInteractionsByScriptRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListNetworkInteractionsByScriptRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListNetworkInteractionsByScriptRequestValidator = func() *ValidateListNetworkInteractionsByScriptRequest {
	v := &ValidateListNetworkInteractionsByScriptRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhId := v.IdValidationRuleHandler
	rulesId := map[string]string{
		"ves.io.schema.rules.string.not_empty": "true",
	}
	vFn, err = vrhId(rulesId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListNetworkInteractionsByScriptRequest.id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["id"] = vFn

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListNetworkInteractionsByScriptRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListNetworkInteractionsByScriptRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	return v
}()

func ListNetworkInteractionsByScriptRequestValidator() db.Validator {
	return DefaultListNetworkInteractionsByScriptRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListNetworkInteractionsByScriptResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListNetworkInteractionsByScriptResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListNetworkInteractionsByScriptResponse) DeepCopy() *ListNetworkInteractionsByScriptResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListNetworkInteractionsByScriptResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListNetworkInteractionsByScriptResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListNetworkInteractionsByScriptResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListNetworkInteractionsByScriptResponseValidator().Validate(ctx, m, opts...)
}

type ValidateListNetworkInteractionsByScriptResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListNetworkInteractionsByScriptResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListNetworkInteractionsByScriptResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListNetworkInteractionsByScriptResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["network_interactions"]; exists {

		vOpts := append(opts, db.WithValidateField("network_interactions"))
		for idx, item := range m.GetNetworkInteractions() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["total_size"]; exists {

		vOpts := append(opts, db.WithValidateField("total_size"))
		if err := fv(ctx, m.GetTotalSize(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListNetworkInteractionsByScriptResponseValidator = func() *ValidateListNetworkInteractionsByScriptResponse {
	v := &ValidateListNetworkInteractionsByScriptResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListNetworkInteractionsByScriptResponseValidator() db.Validator {
	return DefaultListNetworkInteractionsByScriptResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListScriptsLegacyRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListScriptsLegacyRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListScriptsLegacyRequest) DeepCopy() *ListScriptsLegacyRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListScriptsLegacyRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListScriptsLegacyRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListScriptsLegacyRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListScriptsLegacyRequestValidator().Validate(ctx, m, opts...)
}

type ValidateListScriptsLegacyRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListScriptsLegacyRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateListScriptsLegacyRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateListScriptsLegacyRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListScriptsLegacyRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListScriptsLegacyRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_number"]; exists {

		vOpts := append(opts, db.WithValidateField("page_number"))
		if err := fv(ctx, m.GetPageNumber(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_size"]; exists {

		vOpts := append(opts, db.WithValidateField("page_size"))
		if err := fv(ctx, m.GetPageSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_token"]; exists {

		vOpts := append(opts, db.WithValidateField("page_token"))
		if err := fv(ctx, m.GetPageToken(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListScriptsLegacyRequestValidator = func() *ValidateListScriptsLegacyRequest {
	v := &ValidateListScriptsLegacyRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListScriptsLegacyRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListScriptsLegacyRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	return v
}()

func ListScriptsLegacyRequestValidator() db.Validator {
	return DefaultListScriptsLegacyRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListScriptsLegacyResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListScriptsLegacyResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListScriptsLegacyResponse) DeepCopy() *ListScriptsLegacyResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListScriptsLegacyResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListScriptsLegacyResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListScriptsLegacyResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListScriptsLegacyResponseValidator().Validate(ctx, m, opts...)
}

type ValidateListScriptsLegacyResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListScriptsLegacyResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListScriptsLegacyResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListScriptsLegacyResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["next_page_token"]; exists {

		vOpts := append(opts, db.WithValidateField("next_page_token"))
		if err := fv(ctx, m.GetNextPageToken(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_number"]; exists {

		vOpts := append(opts, db.WithValidateField("page_number"))
		if err := fv(ctx, m.GetPageNumber(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_size"]; exists {

		vOpts := append(opts, db.WithValidateField("page_size"))
		if err := fv(ctx, m.GetPageSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scripts"]; exists {

		vOpts := append(opts, db.WithValidateField("scripts"))
		for idx, item := range m.GetScripts() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["total_count"]; exists {

		vOpts := append(opts, db.WithValidateField("total_count"))
		if err := fv(ctx, m.GetTotalCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["total_pages"]; exists {

		vOpts := append(opts, db.WithValidateField("total_pages"))
		if err := fv(ctx, m.GetTotalPages(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListScriptsLegacyResponseValidator = func() *ValidateListScriptsLegacyResponse {
	v := &ValidateListScriptsLegacyResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListScriptsLegacyResponseValidator() db.Validator {
	return DefaultListScriptsLegacyResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListScriptsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListScriptsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListScriptsRequest) DeepCopy() *ListScriptsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListScriptsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListScriptsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListScriptsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListScriptsRequestValidator().Validate(ctx, m, opts...)
}

type ValidateListScriptsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListScriptsRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateListScriptsRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateListScriptsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListScriptsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListScriptsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["filters"]; exists {

		vOpts := append(opts, db.WithValidateField("filters"))
		if err := fv(ctx, m.GetFilters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_number"]; exists {

		vOpts := append(opts, db.WithValidateField("page_number"))
		if err := fv(ctx, m.GetPageNumber(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_size"]; exists {

		vOpts := append(opts, db.WithValidateField("page_size"))
		if err := fv(ctx, m.GetPageSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_token"]; exists {

		vOpts := append(opts, db.WithValidateField("page_token"))
		if err := fv(ctx, m.GetPageToken(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sorts"]; exists {

		vOpts := append(opts, db.WithValidateField("sorts"))
		for idx, item := range m.GetSorts() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListScriptsRequestValidator = func() *ValidateListScriptsRequest {
	v := &ValidateListScriptsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListScriptsRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListScriptsRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	v.FldValidators["filters"] = FiltersValidator().Validate

	return v
}()

func ListScriptsRequestValidator() db.Validator {
	return DefaultListScriptsRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListScriptsResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListScriptsResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListScriptsResponse) DeepCopy() *ListScriptsResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListScriptsResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListScriptsResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListScriptsResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListScriptsResponseValidator().Validate(ctx, m, opts...)
}

type ValidateListScriptsResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListScriptsResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListScriptsResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListScriptsResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["next_page_token"]; exists {

		vOpts := append(opts, db.WithValidateField("next_page_token"))
		if err := fv(ctx, m.GetNextPageToken(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_number"]; exists {

		vOpts := append(opts, db.WithValidateField("page_number"))
		if err := fv(ctx, m.GetPageNumber(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page_size"]; exists {

		vOpts := append(opts, db.WithValidateField("page_size"))
		if err := fv(ctx, m.GetPageSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scripts"]; exists {

		vOpts := append(opts, db.WithValidateField("scripts"))
		for idx, item := range m.GetScripts() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["total_count"]; exists {

		vOpts := append(opts, db.WithValidateField("total_count"))
		if err := fv(ctx, m.GetTotalCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["total_pages"]; exists {

		vOpts := append(opts, db.WithValidateField("total_pages"))
		if err := fv(ctx, m.GetTotalPages(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListScriptsResponseValidator = func() *ValidateListScriptsResponse {
	v := &ValidateListScriptsResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListScriptsResponseValidator() db.Validator {
	return DefaultListScriptsResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *Location) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Location) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Location) DeepCopy() *Location {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Location{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Location) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Location) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LocationValidator().Validate(ctx, m, opts...)
}

type ValidateLocation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLocation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Location)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Location got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["associatedScripts"]; exists {

		vOpts := append(opts, db.WithValidateField("associatedScripts"))
		for idx, item := range m.GetAssociatedScripts() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["location"]; exists {

		vOpts := append(opts, db.WithValidateField("location"))
		if err := fv(ctx, m.GetLocation(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLocationValidator = func() *ValidateLocation {
	v := &ValidateLocation{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LocationValidator() db.Validator {
	return DefaultLocationValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkInteractionByScript) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkInteractionByScript) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkInteractionByScript) DeepCopy() *NetworkInteractionByScript {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkInteractionByScript{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkInteractionByScript) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkInteractionByScript) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkInteractionByScriptValidator().Validate(ctx, m, opts...)
}

type ValidateNetworkInteractionByScript struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkInteractionByScript) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkInteractionByScript)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkInteractionByScript got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["first_seen"]; exists {

		vOpts := append(opts, db.WithValidateField("first_seen"))
		if err := fv(ctx, m.GetFirstSeen(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["last_seen"]; exists {

		vOpts := append(opts, db.WithValidateField("last_seen"))
		if err := fv(ctx, m.GetLastSeen(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["risk_level"]; exists {

		vOpts := append(opts, db.WithValidateField("risk_level"))
		if err := fv(ctx, m.GetRiskLevel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkInteractionByScriptValidator = func() *ValidateNetworkInteractionByScript {
	v := &ValidateNetworkInteractionByScript{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NetworkInteractionByScriptValidator() db.Validator {
	return DefaultNetworkInteractionByScriptValidator
}

// augmented methods on protoc/std generated struct

func (m *RiskLevelFilter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RiskLevelFilter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RiskLevelFilter) DeepCopy() *RiskLevelFilter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RiskLevelFilter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RiskLevelFilter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RiskLevelFilter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RiskLevelFilterValidator().Validate(ctx, m, opts...)
}

type ValidateRiskLevelFilter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRiskLevelFilter) OpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(FilterOperator)
		return int32(i)
	}
	// FilterOperator_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, FilterOperator_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for op")
	}

	return validatorFn, nil
}

func (v *ValidateRiskLevelFilter) RiskLevelStringsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for risk_level_strings")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for risk_level_strings")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated risk_level_strings")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items risk_level_strings")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRiskLevelFilter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RiskLevelFilter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RiskLevelFilter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["op"]; exists {

		vOpts := append(opts, db.WithValidateField("op"))
		if err := fv(ctx, m.GetOp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["risk_level_strings"]; exists {
		vOpts := append(opts, db.WithValidateField("risk_level_strings"))
		if err := fv(ctx, m.GetRiskLevelStrings(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRiskLevelFilterValidator = func() *ValidateRiskLevelFilter {
	v := &ValidateRiskLevelFilter{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOp := v.OpValidationRuleHandler
	rulesOp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOp(rulesOp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RiskLevelFilter.op: %s", err)
		panic(errMsg)
	}
	v.FldValidators["op"] = vFn

	vrhRiskLevelStrings := v.RiskLevelStringsValidationRuleHandler
	rulesRiskLevelStrings := map[string]string{
		"ves.io.schema.rules.message.required":              "true",
		"ves.io.schema.rules.repeated.items.string.max_len": "32",
		"ves.io.schema.rules.repeated.max_items":            "10",
		"ves.io.schema.rules.repeated.unique":               "true",
	}
	vFn, err = vrhRiskLevelStrings(rulesRiskLevelStrings)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RiskLevelFilter.risk_level_strings: %s", err)
		panic(errMsg)
	}
	v.FldValidators["risk_level_strings"] = vFn

	return v
}()

func RiskLevelFilterValidator() db.Validator {
	return DefaultRiskLevelFilterValidator
}

// augmented methods on protoc/std generated struct

func (m *ScriptInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ScriptInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ScriptInfo) DeepCopy() *ScriptInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ScriptInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ScriptInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ScriptInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ScriptInfoValidator().Validate(ctx, m, opts...)
}

type ValidateScriptInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateScriptInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ScriptInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ScriptInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["affected_users_count"]; exists {

		vOpts := append(opts, db.WithValidateField("affected_users_count"))
		if err := fv(ctx, m.GetAffectedUsersCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["first_seen"]; exists {

		vOpts := append(opts, db.WithValidateField("first_seen"))
		if err := fv(ctx, m.GetFirstSeen(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["form_fields_read"]; exists {

		vOpts := append(opts, db.WithValidateField("form_fields_read"))
		if err := fv(ctx, m.GetFormFieldsRead(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["justifications"]; exists {

		vOpts := append(opts, db.WithValidateField("justifications"))
		for idx, item := range m.GetJustifications() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["last_seen"]; exists {

		vOpts := append(opts, db.WithValidateField("last_seen"))
		if err := fv(ctx, m.GetLastSeen(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["locations"]; exists {

		vOpts := append(opts, db.WithValidateField("locations"))
		for idx, item := range m.GetLocations() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["network_interactions"]; exists {

		vOpts := append(opts, db.WithValidateField("network_interactions"))
		if err := fv(ctx, m.GetNetworkInteractions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["new_behaviors"]; exists {

		vOpts := append(opts, db.WithValidateField("new_behaviors"))
		if err := fv(ctx, m.GetNewBehaviors(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["risk_level"]; exists {

		vOpts := append(opts, db.WithValidateField("risk_level"))
		if err := fv(ctx, m.GetRiskLevel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["script_name"]; exists {

		vOpts := append(opts, db.WithValidateField("script_name"))
		if err := fv(ctx, m.GetScriptName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultScriptInfoValidator = func() *ValidateScriptInfo {
	v := &ValidateScriptInfo{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ScriptInfoValidator() db.Validator {
	return DefaultScriptInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *ScriptNameFilter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ScriptNameFilter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ScriptNameFilter) DeepCopy() *ScriptNameFilter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ScriptNameFilter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ScriptNameFilter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ScriptNameFilter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ScriptNameFilterValidator().Validate(ctx, m, opts...)
}

type ValidateScriptNameFilter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateScriptNameFilter) OpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(FilterOperator)
		return int32(i)
	}
	// FilterOperator_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, FilterOperator_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for op")
	}

	return validatorFn, nil
}

func (v *ValidateScriptNameFilter) ScriptNameStringsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for script_name_strings")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for script_name_strings")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated script_name_strings")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items script_name_strings")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateScriptNameFilter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ScriptNameFilter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ScriptNameFilter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["op"]; exists {

		vOpts := append(opts, db.WithValidateField("op"))
		if err := fv(ctx, m.GetOp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["script_name_strings"]; exists {
		vOpts := append(opts, db.WithValidateField("script_name_strings"))
		if err := fv(ctx, m.GetScriptNameStrings(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultScriptNameFilterValidator = func() *ValidateScriptNameFilter {
	v := &ValidateScriptNameFilter{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOp := v.OpValidationRuleHandler
	rulesOp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOp(rulesOp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ScriptNameFilter.op: %s", err)
		panic(errMsg)
	}
	v.FldValidators["op"] = vFn

	vrhScriptNameStrings := v.ScriptNameStringsValidationRuleHandler
	rulesScriptNameStrings := map[string]string{
		"ves.io.schema.rules.message.required":              "true",
		"ves.io.schema.rules.repeated.items.string.max_len": "256",
		"ves.io.schema.rules.repeated.max_items":            "64",
		"ves.io.schema.rules.repeated.min_items":            "1",
		"ves.io.schema.rules.repeated.unique":               "true",
	}
	vFn, err = vrhScriptNameStrings(rulesScriptNameStrings)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ScriptNameFilter.script_name_strings: %s", err)
		panic(errMsg)
	}
	v.FldValidators["script_name_strings"] = vFn

	return v
}()

func ScriptNameFilterValidator() db.Validator {
	return DefaultScriptNameFilterValidator
}

// augmented methods on protoc/std generated struct

func (m *ScriptStatusFilter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ScriptStatusFilter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ScriptStatusFilter) DeepCopy() *ScriptStatusFilter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ScriptStatusFilter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ScriptStatusFilter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ScriptStatusFilter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ScriptStatusFilterValidator().Validate(ctx, m, opts...)
}

type ValidateScriptStatusFilter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateScriptStatusFilter) OpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(FilterOperator)
		return int32(i)
	}
	// FilterOperator_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, FilterOperator_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for op")
	}

	return validatorFn, nil
}

func (v *ValidateScriptStatusFilter) ScriptStatusStringsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for script_status_strings")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for script_status_strings")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated script_status_strings")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items script_status_strings")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateScriptStatusFilter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ScriptStatusFilter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ScriptStatusFilter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["op"]; exists {

		vOpts := append(opts, db.WithValidateField("op"))
		if err := fv(ctx, m.GetOp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["script_status_strings"]; exists {
		vOpts := append(opts, db.WithValidateField("script_status_strings"))
		if err := fv(ctx, m.GetScriptStatusStrings(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultScriptStatusFilterValidator = func() *ValidateScriptStatusFilter {
	v := &ValidateScriptStatusFilter{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOp := v.OpValidationRuleHandler
	rulesOp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOp(rulesOp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ScriptStatusFilter.op: %s", err)
		panic(errMsg)
	}
	v.FldValidators["op"] = vFn

	vrhScriptStatusStrings := v.ScriptStatusStringsValidationRuleHandler
	rulesScriptStatusStrings := map[string]string{
		"ves.io.schema.rules.message.required":              "true",
		"ves.io.schema.rules.repeated.items.string.max_len": "128",
		"ves.io.schema.rules.repeated.max_items":            "10",
		"ves.io.schema.rules.repeated.min_items":            "1",
		"ves.io.schema.rules.repeated.unique":               "true",
	}
	vFn, err = vrhScriptStatusStrings(rulesScriptStatusStrings)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ScriptStatusFilter.script_status_strings: %s", err)
		panic(errMsg)
	}
	v.FldValidators["script_status_strings"] = vFn

	return v
}()

func ScriptStatusFilterValidator() db.Validator {
	return DefaultScriptStatusFilterValidator
}

// augmented methods on protoc/std generated struct

func (m *Sort) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Sort) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Sort) DeepCopy() *Sort {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Sort{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Sort) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Sort) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SortValidator().Validate(ctx, m, opts...)
}

type ValidateSort struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSort) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Sort)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Sort got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["field"]; exists {

		vOpts := append(opts, db.WithValidateField("field"))
		if err := fv(ctx, m.GetField(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["order"]; exists {

		vOpts := append(opts, db.WithValidateField("order"))
		if err := fv(ctx, m.GetOrder(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSortValidator = func() *ValidateSort {
	v := &ValidateSort{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SortValidator() db.Validator {
	return DefaultSortValidator
}

// augmented methods on protoc/std generated struct

func (m *Summary) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Summary) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Summary) DeepCopy() *Summary {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Summary{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Summary) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Summary) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SummaryValidator().Validate(ctx, m, opts...)
}

type ValidateSummary struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSummary) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Summary)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Summary got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain"]; exists {

		vOpts := append(opts, db.WithValidateField("domain"))
		if err := fv(ctx, m.GetDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["first_seen"]; exists {

		vOpts := append(opts, db.WithValidateField("first_seen"))
		if err := fv(ctx, m.GetFirstSeen(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["last_seen"]; exists {

		vOpts := append(opts, db.WithValidateField("last_seen"))
		if err := fv(ctx, m.GetLastSeen(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["risk_level"]; exists {

		vOpts := append(opts, db.WithValidateField("risk_level"))
		if err := fv(ctx, m.GetRiskLevel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSummaryValidator = func() *ValidateSummary {
	v := &ValidateSummary{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SummaryValidator() db.Validator {
	return DefaultSummaryValidator
}

// augmented methods on protoc/std generated struct

func (m *TestJSRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TestJSRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TestJSRequest) DeepCopy() *TestJSRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TestJSRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TestJSRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TestJSRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TestJSRequestValidator().Validate(ctx, m, opts...)
}

type ValidateTestJSRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTestJSRequest) PageURLValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for pageURL")
	}

	return validatorFn, nil
}

func (v *ValidateTestJSRequest) DomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain")
	}

	return validatorFn, nil
}

func (v *ValidateTestJSRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TestJSRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TestJSRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain"]; exists {

		vOpts := append(opts, db.WithValidateField("domain"))
		if err := fv(ctx, m.GetDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pageURL"]; exists {

		vOpts := append(opts, db.WithValidateField("pageURL"))
		if err := fv(ctx, m.GetPageURL(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTestJSRequestValidator = func() *ValidateTestJSRequest {
	v := &ValidateTestJSRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPageURL := v.PageURLValidationRuleHandler
	rulesPageURL := map[string]string{
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFn, err = vrhPageURL(rulesPageURL)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TestJSRequest.pageURL: %s", err)
		panic(errMsg)
	}
	v.FldValidators["pageURL"] = vFn

	vrhDomain := v.DomainValidationRuleHandler
	rulesDomain := map[string]string{
		"ves.io.schema.rules.string.etld_plus_one": "true",
		"ves.io.schema.rules.string.max_len":       "256",
		"ves.io.schema.rules.string.not_empty":     "true",
	}
	vFn, err = vrhDomain(rulesDomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TestJSRequest.domain: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain"] = vFn

	return v
}()

func TestJSRequestValidator() db.Validator {
	return DefaultTestJSRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *TestJSResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TestJSResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TestJSResponse) DeepCopy() *TestJSResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TestJSResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TestJSResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TestJSResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TestJSResponseValidator().Validate(ctx, m, opts...)
}

type ValidateTestJSResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTestJSResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TestJSResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TestJSResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["message"]; exists {

		vOpts := append(opts, db.WithValidateField("message"))
		if err := fv(ctx, m.GetMessage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTestJSResponseValidator = func() *ValidateTestJSResponse {
	v := &ValidateTestJSResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func TestJSResponseValidator() db.Validator {
	return DefaultTestJSResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *UpdateDomainsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdateDomainsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdateDomainsRequest) DeepCopy() *UpdateDomainsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdateDomainsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdateDomainsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdateDomainsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdateDomainsRequestValidator().Validate(ctx, m, opts...)
}

type ValidateUpdateDomainsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdateDomainsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdateDomainsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdateDomainsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAllowedOrMitigatedDomains().(type) {
	case *UpdateDomainsRequest_AddToAllowedDomains:
		if fv, exists := v.FldValidators["allowed_or_mitigated_domains.add_to_allowed_domains"]; exists {
			val := m.GetAllowedOrMitigatedDomains().(*UpdateDomainsRequest_AddToAllowedDomains).AddToAllowedDomains
			vOpts := append(opts,
				db.WithValidateField("allowed_or_mitigated_domains"),
				db.WithValidateField("add_to_allowed_domains"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *UpdateDomainsRequest_AddToMitigatedDomains:
		if fv, exists := v.FldValidators["allowed_or_mitigated_domains.add_to_mitigated_domains"]; exists {
			val := m.GetAllowedOrMitigatedDomains().(*UpdateDomainsRequest_AddToMitigatedDomains).AddToMitigatedDomains
			vOpts := append(opts,
				db.WithValidateField("allowed_or_mitigated_domains"),
				db.WithValidateField("add_to_mitigated_domains"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdateDomainsRequestValidator = func() *ValidateUpdateDomainsRequest {
	v := &ValidateUpdateDomainsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["allowed_or_mitigated_domains.add_to_allowed_domains"] = AddToAllowedDomainsValidator().Validate
	v.FldValidators["allowed_or_mitigated_domains.add_to_mitigated_domains"] = AddToMitigatedDomainsValidator().Validate

	return v
}()

func UpdateDomainsRequestValidator() db.Validator {
	return DefaultUpdateDomainsRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *UpdateDomainsResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdateDomainsResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdateDomainsResponse) DeepCopy() *UpdateDomainsResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdateDomainsResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdateDomainsResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdateDomainsResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdateDomainsResponseValidator().Validate(ctx, m, opts...)
}

type ValidateUpdateDomainsResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdateDomainsResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdateDomainsResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdateDomainsResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdateDomainsResponseValidator = func() *ValidateUpdateDomainsResponse {
	v := &ValidateUpdateDomainsResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UpdateDomainsResponseValidator() db.Validator {
	return DefaultUpdateDomainsResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *UpdateFieldAnalysisRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdateFieldAnalysisRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdateFieldAnalysisRequest) DeepCopy() *UpdateFieldAnalysisRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdateFieldAnalysisRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdateFieldAnalysisRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdateFieldAnalysisRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdateFieldAnalysisRequestValidator().Validate(ctx, m, opts...)
}

type ValidateUpdateFieldAnalysisRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdateFieldAnalysisRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateUpdateFieldAnalysisRequest) TypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ANALYSIS_TYPE)
		return int32(i)
	}
	// ANALYSIS_TYPE_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ANALYSIS_TYPE_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for type")
	}

	return validatorFn, nil
}

func (v *ValidateUpdateFieldAnalysisRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdateFieldAnalysisRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdateFieldAnalysisRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdateFieldAnalysisRequestValidator = func() *ValidateUpdateFieldAnalysisRequest {
	v := &ValidateUpdateFieldAnalysisRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.not_empty": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpdateFieldAnalysisRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhType := v.TypeValidationRuleHandler
	rulesType := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.message.required":  "true",
	}
	vFn, err = vrhType(rulesType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpdateFieldAnalysisRequest.type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["type"] = vFn

	return v
}()

func UpdateFieldAnalysisRequestValidator() db.Validator {
	return DefaultUpdateFieldAnalysisRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *UpdateFieldAnalysisResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdateFieldAnalysisResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdateFieldAnalysisResponse) DeepCopy() *UpdateFieldAnalysisResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdateFieldAnalysisResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdateFieldAnalysisResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdateFieldAnalysisResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdateFieldAnalysisResponseValidator().Validate(ctx, m, opts...)
}

type ValidateUpdateFieldAnalysisResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdateFieldAnalysisResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdateFieldAnalysisResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdateFieldAnalysisResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdateFieldAnalysisResponseValidator = func() *ValidateUpdateFieldAnalysisResponse {
	v := &ValidateUpdateFieldAnalysisResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UpdateFieldAnalysisResponseValidator() db.Validator {
	return DefaultUpdateFieldAnalysisResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *UpdateScriptJustificationRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdateScriptJustificationRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdateScriptJustificationRequest) DeepCopy() *UpdateScriptJustificationRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdateScriptJustificationRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdateScriptJustificationRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdateScriptJustificationRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdateScriptJustificationRequestValidator().Validate(ctx, m, opts...)
}

type ValidateUpdateScriptJustificationRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdateScriptJustificationRequest) JustificationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for justification")
	}

	return validatorFn, nil
}

func (v *ValidateUpdateScriptJustificationRequest) UserIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for user_id")
	}

	return validatorFn, nil
}

func (v *ValidateUpdateScriptJustificationRequest) ScriptIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for script_id")
	}

	return validatorFn, nil
}

func (v *ValidateUpdateScriptJustificationRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdateScriptJustificationRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdateScriptJustificationRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["justification"]; exists {

		vOpts := append(opts, db.WithValidateField("justification"))
		if err := fv(ctx, m.GetJustification(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["script_id"]; exists {

		vOpts := append(opts, db.WithValidateField("script_id"))
		if err := fv(ctx, m.GetScriptId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_id"]; exists {

		vOpts := append(opts, db.WithValidateField("user_id"))
		if err := fv(ctx, m.GetUserId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdateScriptJustificationRequestValidator = func() *ValidateUpdateScriptJustificationRequest {
	v := &ValidateUpdateScriptJustificationRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhJustification := v.JustificationValidationRuleHandler
	rulesJustification := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhJustification(rulesJustification)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpdateScriptJustificationRequest.justification: %s", err)
		panic(errMsg)
	}
	v.FldValidators["justification"] = vFn

	vrhUserId := v.UserIdValidationRuleHandler
	rulesUserId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhUserId(rulesUserId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpdateScriptJustificationRequest.user_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user_id"] = vFn

	vrhScriptId := v.ScriptIdValidationRuleHandler
	rulesScriptId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhScriptId(rulesScriptId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpdateScriptJustificationRequest.script_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["script_id"] = vFn

	return v
}()

func UpdateScriptJustificationRequestValidator() db.Validator {
	return DefaultUpdateScriptJustificationRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *UpdateScriptJustificationResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdateScriptJustificationResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdateScriptJustificationResponse) DeepCopy() *UpdateScriptJustificationResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdateScriptJustificationResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdateScriptJustificationResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdateScriptJustificationResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdateScriptJustificationResponseValidator().Validate(ctx, m, opts...)
}

type ValidateUpdateScriptJustificationResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdateScriptJustificationResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdateScriptJustificationResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdateScriptJustificationResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["justification_id"]; exists {

		vOpts := append(opts, db.WithValidateField("justification_id"))
		if err := fv(ctx, m.GetJustificationId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdateScriptJustificationResponseValidator = func() *ValidateUpdateScriptJustificationResponse {
	v := &ValidateUpdateScriptJustificationResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UpdateScriptJustificationResponseValidator() db.Validator {
	return DefaultUpdateScriptJustificationResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *UpdateScriptReadStatusRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdateScriptReadStatusRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdateScriptReadStatusRequest) DeepCopy() *UpdateScriptReadStatusRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdateScriptReadStatusRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdateScriptReadStatusRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdateScriptReadStatusRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdateScriptReadStatusRequestValidator().Validate(ctx, m, opts...)
}

type ValidateUpdateScriptReadStatusRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdateScriptReadStatusRequest) IdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for id")
	}

	return validatorFn, nil
}

func (v *ValidateUpdateScriptReadStatusRequest) TypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ACTION_TYPE)
		return int32(i)
	}
	// ACTION_TYPE_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ACTION_TYPE_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for type")
	}

	return validatorFn, nil
}

func (v *ValidateUpdateScriptReadStatusRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdateScriptReadStatusRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdateScriptReadStatusRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdateScriptReadStatusRequestValidator = func() *ValidateUpdateScriptReadStatusRequest {
	v := &ValidateUpdateScriptReadStatusRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhId := v.IdValidationRuleHandler
	rulesId := map[string]string{
		"ves.io.schema.rules.string.not_empty": "true",
	}
	vFn, err = vrhId(rulesId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpdateScriptReadStatusRequest.id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["id"] = vFn

	vrhType := v.TypeValidationRuleHandler
	rulesType := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.message.required":  "true",
	}
	vFn, err = vrhType(rulesType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpdateScriptReadStatusRequest.type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["type"] = vFn

	return v
}()

func UpdateScriptReadStatusRequestValidator() db.Validator {
	return DefaultUpdateScriptReadStatusRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *UpdateScriptReadStatusResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdateScriptReadStatusResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdateScriptReadStatusResponse) DeepCopy() *UpdateScriptReadStatusResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdateScriptReadStatusResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdateScriptReadStatusResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdateScriptReadStatusResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdateScriptReadStatusResponseValidator().Validate(ctx, m, opts...)
}

type ValidateUpdateScriptReadStatusResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdateScriptReadStatusResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdateScriptReadStatusResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdateScriptReadStatusResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["script_name"]; exists {

		vOpts := append(opts, db.WithValidateField("script_name"))
		if err := fv(ctx, m.GetScriptName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdateScriptReadStatusResponseValidator = func() *ValidateUpdateScriptReadStatusResponse {
	v := &ValidateUpdateScriptReadStatusResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UpdateScriptReadStatusResponseValidator() db.Validator {
	return DefaultUpdateScriptReadStatusResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *UpdatedCount) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdatedCount) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdatedCount) DeepCopy() *UpdatedCount {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdatedCount{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdatedCount) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdatedCount) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdatedCountValidator().Validate(ctx, m, opts...)
}

type ValidateUpdatedCount struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdatedCount) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdatedCount)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdatedCount got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["count"]; exists {

		vOpts := append(opts, db.WithValidateField("count"))
		if err := fv(ctx, m.GetCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lastUpdated"]; exists {

		vOpts := append(opts, db.WithValidateField("lastUpdated"))
		if err := fv(ctx, m.GetLastUpdated(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdatedCountValidator = func() *ValidateUpdatedCount {
	v := &ValidateUpdatedCount{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UpdatedCountValidator() db.Validator {
	return DefaultUpdatedCountValidator
}
