// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package cloudflare

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *BlockMitigationChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BlockMitigationChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BlockMitigationChoiceType) DeepCopy() *BlockMitigationChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BlockMitigationChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BlockMitigationChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BlockMitigationChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BlockMitigationChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBlockMitigationChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBlockMitigationChoiceType) StatusValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.HttpStatusCode)
		return int32(i)
	}
	// ves_io_schema.HttpStatusCode_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.HttpStatusCode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for status")
	}

	return validatorFn, nil
}

func (v *ValidateBlockMitigationChoiceType) ContentTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for content_type")
	}

	return validatorFn, nil
}

func (v *ValidateBlockMitigationChoiceType) BodyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for body")
	}

	return validatorFn, nil
}

func (v *ValidateBlockMitigationChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BlockMitigationChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BlockMitigationChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["body"]; exists {

		vOpts := append(opts, db.WithValidateField("body"))
		if err := fv(ctx, m.GetBody(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["content_type"]; exists {

		vOpts := append(opts, db.WithValidateField("content_type"))
		if err := fv(ctx, m.GetContentType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBlockMitigationChoiceTypeValidator = func() *ValidateBlockMitigationChoiceType {
	v := &ValidateBlockMitigationChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStatus := v.StatusValidationRuleHandler
	rulesStatus := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.enum.not_in":       "[302,303,307]",
		"ves.io.schema.rules.message.required":  "true",
	}
	vFn, err = vrhStatus(rulesStatus)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BlockMitigationChoiceType.status: %s", err)
		panic(errMsg)
	}
	v.FldValidators["status"] = vFn

	vrhContentType := v.ContentTypeValidationRuleHandler
	rulesContentType := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
	}
	vFn, err = vrhContentType(rulesContentType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BlockMitigationChoiceType.content_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["content_type"] = vFn

	vrhBody := v.BodyValidationRuleHandler
	rulesBody := map[string]string{
		"ves.io.schema.rules.string.max_len": "4096",
	}
	vFn, err = vrhBody(rulesBody)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BlockMitigationChoiceType.body: %s", err)
		panic(errMsg)
	}
	v.FldValidators["body"] = vFn

	return v
}()

func BlockMitigationChoiceTypeValidator() db.Validator {
	return DefaultBlockMitigationChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *BlockMobileMitigationChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BlockMobileMitigationChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BlockMobileMitigationChoiceType) DeepCopy() *BlockMobileMitigationChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BlockMobileMitigationChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BlockMobileMitigationChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BlockMobileMitigationChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BlockMobileMitigationChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBlockMobileMitigationChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBlockMobileMitigationChoiceType) StatusValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.HttpStatusCode)
		return int32(i)
	}
	// ves_io_schema.HttpStatusCode_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.HttpStatusCode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for status")
	}

	return validatorFn, nil
}

func (v *ValidateBlockMobileMitigationChoiceType) ContentTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for content_type")
	}

	return validatorFn, nil
}

func (v *ValidateBlockMobileMitigationChoiceType) BodyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for body")
	}

	return validatorFn, nil
}

func (v *ValidateBlockMobileMitigationChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BlockMobileMitigationChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BlockMobileMitigationChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["body"]; exists {

		vOpts := append(opts, db.WithValidateField("body"))
		if err := fv(ctx, m.GetBody(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["content_type"]; exists {

		vOpts := append(opts, db.WithValidateField("content_type"))
		if err := fv(ctx, m.GetContentType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBlockMobileMitigationChoiceTypeValidator = func() *ValidateBlockMobileMitigationChoiceType {
	v := &ValidateBlockMobileMitigationChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStatus := v.StatusValidationRuleHandler
	rulesStatus := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.enum.not_in":       "[302,303,307]",
		"ves.io.schema.rules.message.required":  "true",
	}
	vFn, err = vrhStatus(rulesStatus)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BlockMobileMitigationChoiceType.status: %s", err)
		panic(errMsg)
	}
	v.FldValidators["status"] = vFn

	vrhContentType := v.ContentTypeValidationRuleHandler
	rulesContentType := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
	}
	vFn, err = vrhContentType(rulesContentType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BlockMobileMitigationChoiceType.content_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["content_type"] = vFn

	vrhBody := v.BodyValidationRuleHandler
	rulesBody := map[string]string{
		"ves.io.schema.rules.string.max_len": "4096",
	}
	vFn, err = vrhBody(rulesBody)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BlockMobileMitigationChoiceType.body: %s", err)
		panic(errMsg)
	}
	v.FldValidators["body"] = vFn

	return v
}()

func BlockMobileMitigationChoiceTypeValidator() db.Validator {
	return DefaultBlockMobileMitigationChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ClientBypassRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ClientBypassRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ClientBypassRule) DeepCopy() *ClientBypassRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ClientBypassRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ClientBypassRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ClientBypassRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ClientBypassRuleValidator().Validate(ctx, m, opts...)
}

type ValidateClientBypassRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateClientBypassRule) ClientSourceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for client_source_choice")
	}
	return validatorFn, nil
}

func (v *ValidateClientBypassRule) ClientSourceChoiceIpPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_IpPrefix, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip_prefix")
	}
	return oValidatorFn_IpPrefix, nil
}

func (v *ValidateClientBypassRule) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateClientBypassRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ClientBypassRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ClientBypassRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["client_source_choice"]; exists {
		val := m.GetClientSourceChoice()
		vOpts := append(opts,
			db.WithValidateField("client_source_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetClientSourceChoice().(type) {
	case *ClientBypassRule_IpPrefix:
		if fv, exists := v.FldValidators["client_source_choice.ip_prefix"]; exists {
			val := m.GetClientSourceChoice().(*ClientBypassRule_IpPrefix).IpPrefix
			vOpts := append(opts,
				db.WithValidateField("client_source_choice"),
				db.WithValidateField("ip_prefix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ClientBypassRule_HttpHeader:
		if fv, exists := v.FldValidators["client_source_choice.http_header"]; exists {
			val := m.GetClientSourceChoice().(*ClientBypassRule_HttpHeader).HttpHeader
			vOpts := append(opts,
				db.WithValidateField("client_source_choice"),
				db.WithValidateField("http_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultClientBypassRuleValidator = func() *ValidateClientBypassRule {
	v := &ValidateClientBypassRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhClientSourceChoice := v.ClientSourceChoiceValidationRuleHandler
	rulesClientSourceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhClientSourceChoice(rulesClientSourceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ClientBypassRule.client_source_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["client_source_choice"] = vFn

	vrhClientSourceChoiceIpPrefix := v.ClientSourceChoiceIpPrefixValidationRuleHandler
	rulesClientSourceChoiceIpPrefix := map[string]string{
		"ves.io.schema.rules.string.ip_prefix": "true",
	}
	vFnMap["client_source_choice.ip_prefix"], err = vrhClientSourceChoiceIpPrefix(rulesClientSourceChoiceIpPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ClientBypassRule.client_source_choice_ip_prefix: %s", err)
		panic(errMsg)
	}

	v.FldValidators["client_source_choice.ip_prefix"] = vFnMap["client_source_choice.ip_prefix"]

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ClientBypassRule.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	v.FldValidators["client_source_choice.http_header"] = HttpHeaderMatcherListValidator().Validate

	return v
}()

func ClientBypassRuleValidator() db.Validator {
	return DefaultClientBypassRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *CloudflareType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CloudflareType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CloudflareType) DeepCopy() *CloudflareType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CloudflareType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CloudflareType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CloudflareType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CloudflareTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCloudflareType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCloudflareType) JavaScriptChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for java_script_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCloudflareType) MobileSdkChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mobile_sdk_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCloudflareType) ProtectedEndpointsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for protected_endpoints")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ProtectedEndpointType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ProtectedEndpointTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for protected_endpoints")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ProtectedEndpointType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ProtectedEndpointType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated protected_endpoints")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items protected_endpoints")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCloudflareType) TrustedClientsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for trusted_clients")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ClientBypassRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ClientBypassRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for trusted_clients")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ClientBypassRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ClientBypassRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated trusted_clients")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items trusted_clients")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCloudflareType) TimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for timeout")
	}

	return validatorFn, nil
}

func (v *ValidateCloudflareType) ContinueMitigationActionHdrValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for continue_mitigation_action_hdr")
	}

	return validatorFn, nil
}

func (v *ValidateCloudflareType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CloudflareType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CloudflareType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["continue_mitigation_action_hdr"]; exists {

		vOpts := append(opts, db.WithValidateField("continue_mitigation_action_hdr"))
		if err := fv(ctx, m.GetContinueMitigationActionHdr(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["java_script_choice"]; exists {
		val := m.GetJavaScriptChoice()
		vOpts := append(opts,
			db.WithValidateField("java_script_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetJavaScriptChoice().(type) {
	case *CloudflareType_DisableJsInsert:
		if fv, exists := v.FldValidators["java_script_choice.disable_js_insert"]; exists {
			val := m.GetJavaScriptChoice().(*CloudflareType_DisableJsInsert).DisableJsInsert
			vOpts := append(opts,
				db.WithValidateField("java_script_choice"),
				db.WithValidateField("disable_js_insert"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CloudflareType_JsInsertAllPages:
		if fv, exists := v.FldValidators["java_script_choice.js_insert_all_pages"]; exists {
			val := m.GetJavaScriptChoice().(*CloudflareType_JsInsertAllPages).JsInsertAllPages
			vOpts := append(opts,
				db.WithValidateField("java_script_choice"),
				db.WithValidateField("js_insert_all_pages"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CloudflareType_JsInsertAllPagesExcept:
		if fv, exists := v.FldValidators["java_script_choice.js_insert_all_pages_except"]; exists {
			val := m.GetJavaScriptChoice().(*CloudflareType_JsInsertAllPagesExcept).JsInsertAllPagesExcept
			vOpts := append(opts,
				db.WithValidateField("java_script_choice"),
				db.WithValidateField("js_insert_all_pages_except"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CloudflareType_JsInsertionRules:
		if fv, exists := v.FldValidators["java_script_choice.js_insertion_rules"]; exists {
			val := m.GetJavaScriptChoice().(*CloudflareType_JsInsertionRules).JsInsertionRules
			vOpts := append(opts,
				db.WithValidateField("java_script_choice"),
				db.WithValidateField("js_insertion_rules"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CloudflareType_ManualJsInsert:
		if fv, exists := v.FldValidators["java_script_choice.manual_js_insert"]; exists {
			val := m.GetJavaScriptChoice().(*CloudflareType_ManualJsInsert).ManualJsInsert
			vOpts := append(opts,
				db.WithValidateField("java_script_choice"),
				db.WithValidateField("manual_js_insert"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["loglevel"]; exists {

		vOpts := append(opts, db.WithValidateField("loglevel"))
		if err := fv(ctx, m.GetLoglevel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mobile_sdk_choice"]; exists {
		val := m.GetMobileSdkChoice()
		vOpts := append(opts,
			db.WithValidateField("mobile_sdk_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMobileSdkChoice().(type) {
	case *CloudflareType_DisableMobileSdk:
		if fv, exists := v.FldValidators["mobile_sdk_choice.disable_mobile_sdk"]; exists {
			val := m.GetMobileSdkChoice().(*CloudflareType_DisableMobileSdk).DisableMobileSdk
			vOpts := append(opts,
				db.WithValidateField("mobile_sdk_choice"),
				db.WithValidateField("disable_mobile_sdk"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CloudflareType_MobileSdkConfig:
		if fv, exists := v.FldValidators["mobile_sdk_choice.mobile_sdk_config"]; exists {
			val := m.GetMobileSdkChoice().(*CloudflareType_MobileSdkConfig).MobileSdkConfig
			vOpts := append(opts,
				db.WithValidateField("mobile_sdk_choice"),
				db.WithValidateField("mobile_sdk_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["protected_endpoints"]; exists {
		vOpts := append(opts, db.WithValidateField("protected_endpoints"))
		if err := fv(ctx, m.GetProtectedEndpoints(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("timeout"))
		if err := fv(ctx, m.GetTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["trusted_clients"]; exists {
		vOpts := append(opts, db.WithValidateField("trusted_clients"))
		if err := fv(ctx, m.GetTrustedClients(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCloudflareTypeValidator = func() *ValidateCloudflareType {
	v := &ValidateCloudflareType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhJavaScriptChoice := v.JavaScriptChoiceValidationRuleHandler
	rulesJavaScriptChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhJavaScriptChoice(rulesJavaScriptChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CloudflareType.java_script_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["java_script_choice"] = vFn

	vrhMobileSdkChoice := v.MobileSdkChoiceValidationRuleHandler
	rulesMobileSdkChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMobileSdkChoice(rulesMobileSdkChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CloudflareType.mobile_sdk_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mobile_sdk_choice"] = vFn

	vrhProtectedEndpoints := v.ProtectedEndpointsValidationRuleHandler
	rulesProtectedEndpoints := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "128",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhProtectedEndpoints(rulesProtectedEndpoints)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CloudflareType.protected_endpoints: %s", err)
		panic(errMsg)
	}
	v.FldValidators["protected_endpoints"] = vFn

	vrhTrustedClients := v.TrustedClientsValidationRuleHandler
	rulesTrustedClients := map[string]string{
		"ves.io.schema.rules.repeated.max_items":            "256",
		"ves.io.schema.rules.repeated.unique_metadata_name": "true",
	}
	vFn, err = vrhTrustedClients(rulesTrustedClients)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CloudflareType.trusted_clients: %s", err)
		panic(errMsg)
	}
	v.FldValidators["trusted_clients"] = vFn

	vrhTimeout := v.TimeoutValidationRuleHandler
	rulesTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "60000",
	}
	vFn, err = vrhTimeout(rulesTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CloudflareType.timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["timeout"] = vFn

	vrhContinueMitigationActionHdr := v.ContinueMitigationActionHdrValidationRuleHandler
	rulesContinueMitigationActionHdr := map[string]string{
		"ves.io.schema.rules.string.http_header_field": "true",
		"ves.io.schema.rules.string.max_bytes":         "256",
	}
	vFn, err = vrhContinueMitigationActionHdr(rulesContinueMitigationActionHdr)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CloudflareType.continue_mitigation_action_hdr: %s", err)
		panic(errMsg)
	}
	v.FldValidators["continue_mitigation_action_hdr"] = vFn

	v.FldValidators["java_script_choice.js_insert_all_pages"] = JavaScriptInsertAllTypeValidator().Validate
	v.FldValidators["java_script_choice.js_insert_all_pages_except"] = JavaScriptInsertAllWithExceptionsTypeValidator().Validate
	v.FldValidators["java_script_choice.js_insertion_rules"] = JavaScriptInsertTypeValidator().Validate
	v.FldValidators["java_script_choice.manual_js_insert"] = JavaScriptInsertManualTypeValidator().Validate

	v.FldValidators["mobile_sdk_choice.mobile_sdk_config"] = MobileSDKConfigTypeValidator().Validate

	return v
}()

func CloudflareTypeValidator() db.Validator {
	return DefaultCloudflareTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ContinueMitigationChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ContinueMitigationChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ContinueMitigationChoiceType) DeepCopy() *ContinueMitigationChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ContinueMitigationChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ContinueMitigationChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ContinueMitigationChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ContinueMitigationChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateContinueMitigationChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateContinueMitigationChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ContinueMitigationChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ContinueMitigationChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAddHeaderChoice().(type) {
	case *ContinueMitigationChoiceType_NoHeader:
		if fv, exists := v.FldValidators["add_header_choice.no_header"]; exists {
			val := m.GetAddHeaderChoice().(*ContinueMitigationChoiceType_NoHeader).NoHeader
			vOpts := append(opts,
				db.WithValidateField("add_header_choice"),
				db.WithValidateField("no_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ContinueMitigationChoiceType_AddHeader:
		if fv, exists := v.FldValidators["add_header_choice.add_header"]; exists {
			val := m.GetAddHeaderChoice().(*ContinueMitigationChoiceType_AddHeader).AddHeader
			vOpts := append(opts,
				db.WithValidateField("add_header_choice"),
				db.WithValidateField("add_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultContinueMitigationChoiceTypeValidator = func() *ValidateContinueMitigationChoiceType {
	v := &ValidateContinueMitigationChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ContinueMitigationChoiceTypeValidator() db.Validator {
	return DefaultContinueMitigationChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HeaderMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HeaderMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HeaderMatcherType) DeepCopy() *HeaderMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HeaderMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HeaderMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HeaderMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HeaderMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHeaderMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHeaderMatcherType) ValueMatchExactValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Exact, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exact")
	}
	return oValidatorFn_Exact, nil
}
func (v *ValidateHeaderMatcherType) ValueMatchRegexValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Regex, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for regex")
	}
	return oValidatorFn_Regex, nil
}

func (v *ValidateHeaderMatcherType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateHeaderMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HeaderMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HeaderMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetValueMatch().(type) {
	case *HeaderMatcherType_Exact:
		if fv, exists := v.FldValidators["value_match.exact"]; exists {
			val := m.GetValueMatch().(*HeaderMatcherType_Exact).Exact
			vOpts := append(opts,
				db.WithValidateField("value_match"),
				db.WithValidateField("exact"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderMatcherType_Regex:
		if fv, exists := v.FldValidators["value_match.regex"]; exists {
			val := m.GetValueMatch().(*HeaderMatcherType_Regex).Regex
			vOpts := append(opts,
				db.WithValidateField("value_match"),
				db.WithValidateField("regex"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHeaderMatcherTypeValidator = func() *ValidateHeaderMatcherType {
	v := &ValidateHeaderMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhValueMatchExact := v.ValueMatchExactValidationRuleHandler
	rulesValueMatchExact := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "256",
		"ves.io.schema.rules.string.not_empty": "true",
	}
	vFnMap["value_match.exact"], err = vrhValueMatchExact(rulesValueMatchExact)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field HeaderMatcherType.value_match_exact: %s", err)
		panic(errMsg)
	}
	vrhValueMatchRegex := v.ValueMatchRegexValidationRuleHandler
	rulesValueMatchRegex := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "256",
		"ves.io.schema.rules.string.not_empty": "true",
		"ves.io.schema.rules.string.regex":     "true",
	}
	vFnMap["value_match.regex"], err = vrhValueMatchRegex(rulesValueMatchRegex)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field HeaderMatcherType.value_match_regex: %s", err)
		panic(errMsg)
	}

	v.FldValidators["value_match.exact"] = vFnMap["value_match.exact"]
	v.FldValidators["value_match.regex"] = vFnMap["value_match.regex"]

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.string.http_header_field": "true",
		"ves.io.schema.rules.string.max_bytes":         "256",
		"ves.io.schema.rules.string.min_bytes":         "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderMatcherType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func HeaderMatcherTypeValidator() db.Validator {
	return DefaultHeaderMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HttpHeaderMatcherList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HttpHeaderMatcherList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HttpHeaderMatcherList) DeepCopy() *HttpHeaderMatcherList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HttpHeaderMatcherList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HttpHeaderMatcherList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HttpHeaderMatcherList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HttpHeaderMatcherListValidator().Validate(ctx, m, opts...)
}

type ValidateHttpHeaderMatcherList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHttpHeaderMatcherList) HeadersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for headers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*HeaderMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := HeaderMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for headers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*HeaderMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*HeaderMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated headers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items headers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHttpHeaderMatcherList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HttpHeaderMatcherList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HttpHeaderMatcherList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["headers"]; exists {
		vOpts := append(opts, db.WithValidateField("headers"))
		if err := fv(ctx, m.GetHeaders(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHttpHeaderMatcherListValidator = func() *ValidateHttpHeaderMatcherList {
	v := &ValidateHttpHeaderMatcherList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHeaders := v.HeadersValidationRuleHandler
	rulesHeaders := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhHeaders(rulesHeaders)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HttpHeaderMatcherList.headers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["headers"] = vFn

	return v
}()

func HttpHeaderMatcherListValidator() db.Validator {
	return DefaultHttpHeaderMatcherListValidator
}

// augmented methods on protoc/std generated struct

func (m *JavaScriptExclusionRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JavaScriptExclusionRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JavaScriptExclusionRule) DeepCopy() *JavaScriptExclusionRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JavaScriptExclusionRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JavaScriptExclusionRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JavaScriptExclusionRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JavaScriptExclusionRuleValidator().Validate(ctx, m, opts...)
}

type ValidateJavaScriptExclusionRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJavaScriptExclusionRule) DomainMatcherChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_matcher_choice")
	}
	return validatorFn, nil
}

func (v *ValidateJavaScriptExclusionRule) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateJavaScriptExclusionRule) PathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for path")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.PathMatcherTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateJavaScriptExclusionRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JavaScriptExclusionRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JavaScriptExclusionRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain_matcher_choice"]; exists {
		val := m.GetDomainMatcherChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_matcher_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainMatcherChoice().(type) {
	case *JavaScriptExclusionRule_AnyDomain:
		if fv, exists := v.FldValidators["domain_matcher_choice.any_domain"]; exists {
			val := m.GetDomainMatcherChoice().(*JavaScriptExclusionRule_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_matcher_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *JavaScriptExclusionRule_Domain:
		if fv, exists := v.FldValidators["domain_matcher_choice.domain"]; exists {
			val := m.GetDomainMatcherChoice().(*JavaScriptExclusionRule_Domain).Domain
			vOpts := append(opts,
				db.WithValidateField("domain_matcher_choice"),
				db.WithValidateField("domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJavaScriptExclusionRuleValidator = func() *ValidateJavaScriptExclusionRule {
	v := &ValidateJavaScriptExclusionRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainMatcherChoice := v.DomainMatcherChoiceValidationRuleHandler
	rulesDomainMatcherChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainMatcherChoice(rulesDomainMatcherChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavaScriptExclusionRule.domain_matcher_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_matcher_choice"] = vFn

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavaScriptExclusionRule.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	vrhPath := v.PathValidationRuleHandler
	rulesPath := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPath(rulesPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavaScriptExclusionRule.path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path"] = vFn

	v.FldValidators["domain_matcher_choice.domain"] = ves_io_schema.DomainTypeValidator().Validate

	return v
}()

func JavaScriptExclusionRuleValidator() db.Validator {
	return DefaultJavaScriptExclusionRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *JavaScriptInsertAllType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JavaScriptInsertAllType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JavaScriptInsertAllType) DeepCopy() *JavaScriptInsertAllType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JavaScriptInsertAllType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JavaScriptInsertAllType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JavaScriptInsertAllType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JavaScriptInsertAllTypeValidator().Validate(ctx, m, opts...)
}

type ValidateJavaScriptInsertAllType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJavaScriptInsertAllType) JavascriptLocationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(JavaScriptLocation)
		return int32(i)
	}
	// JavaScriptLocation_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, JavaScriptLocation_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for javascript_location")
	}

	return validatorFn, nil
}

func (v *ValidateJavaScriptInsertAllType) JsDownloadPathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for js_download_path")
	}

	return validatorFn, nil
}

func (v *ValidateJavaScriptInsertAllType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JavaScriptInsertAllType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JavaScriptInsertAllType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["javascript_location"]; exists {

		vOpts := append(opts, db.WithValidateField("javascript_location"))
		if err := fv(ctx, m.GetJavascriptLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["js_download_path"]; exists {

		vOpts := append(opts, db.WithValidateField("js_download_path"))
		if err := fv(ctx, m.GetJsDownloadPath(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJavaScriptInsertAllTypeValidator = func() *ValidateJavaScriptInsertAllType {
	v := &ValidateJavaScriptInsertAllType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhJavascriptLocation := v.JavascriptLocationValidationRuleHandler
	rulesJavascriptLocation := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.enum.not_in":       "[0]",
	}
	vFn, err = vrhJavascriptLocation(rulesJavascriptLocation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavaScriptInsertAllType.javascript_location: %s", err)
		panic(errMsg)
	}
	v.FldValidators["javascript_location"] = vFn

	vrhJsDownloadPath := v.JsDownloadPathValidationRuleHandler
	rulesJsDownloadPath := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
	}
	vFn, err = vrhJsDownloadPath(rulesJsDownloadPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavaScriptInsertAllType.js_download_path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["js_download_path"] = vFn

	return v
}()

func JavaScriptInsertAllTypeValidator() db.Validator {
	return DefaultJavaScriptInsertAllTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *JavaScriptInsertAllWithExceptionsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JavaScriptInsertAllWithExceptionsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JavaScriptInsertAllWithExceptionsType) DeepCopy() *JavaScriptInsertAllWithExceptionsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JavaScriptInsertAllWithExceptionsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JavaScriptInsertAllWithExceptionsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JavaScriptInsertAllWithExceptionsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JavaScriptInsertAllWithExceptionsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateJavaScriptInsertAllWithExceptionsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJavaScriptInsertAllWithExceptionsType) JavascriptLocationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(JavaScriptLocation)
		return int32(i)
	}
	// JavaScriptLocation_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, JavaScriptLocation_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for javascript_location")
	}

	return validatorFn, nil
}

func (v *ValidateJavaScriptInsertAllWithExceptionsType) ExcludeListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for exclude_list")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*JavaScriptExclusionRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := JavaScriptExclusionRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*JavaScriptExclusionRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*JavaScriptExclusionRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateJavaScriptInsertAllWithExceptionsType) JsDownloadPathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for js_download_path")
	}

	return validatorFn, nil
}

func (v *ValidateJavaScriptInsertAllWithExceptionsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JavaScriptInsertAllWithExceptionsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JavaScriptInsertAllWithExceptionsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exclude_list"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_list"))
		if err := fv(ctx, m.GetExcludeList(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["javascript_location"]; exists {

		vOpts := append(opts, db.WithValidateField("javascript_location"))
		if err := fv(ctx, m.GetJavascriptLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["js_download_path"]; exists {

		vOpts := append(opts, db.WithValidateField("js_download_path"))
		if err := fv(ctx, m.GetJsDownloadPath(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJavaScriptInsertAllWithExceptionsTypeValidator = func() *ValidateJavaScriptInsertAllWithExceptionsType {
	v := &ValidateJavaScriptInsertAllWithExceptionsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhJavascriptLocation := v.JavascriptLocationValidationRuleHandler
	rulesJavascriptLocation := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.enum.not_in":       "[0]",
	}
	vFn, err = vrhJavascriptLocation(rulesJavascriptLocation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavaScriptInsertAllWithExceptionsType.javascript_location: %s", err)
		panic(errMsg)
	}
	v.FldValidators["javascript_location"] = vFn

	vrhExcludeList := v.ExcludeListValidationRuleHandler
	rulesExcludeList := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "128",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhExcludeList(rulesExcludeList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavaScriptInsertAllWithExceptionsType.exclude_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_list"] = vFn

	vrhJsDownloadPath := v.JsDownloadPathValidationRuleHandler
	rulesJsDownloadPath := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
	}
	vFn, err = vrhJsDownloadPath(rulesJsDownloadPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavaScriptInsertAllWithExceptionsType.js_download_path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["js_download_path"] = vFn

	return v
}()

func JavaScriptInsertAllWithExceptionsTypeValidator() db.Validator {
	return DefaultJavaScriptInsertAllWithExceptionsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *JavaScriptInsertManualType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JavaScriptInsertManualType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JavaScriptInsertManualType) DeepCopy() *JavaScriptInsertManualType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JavaScriptInsertManualType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JavaScriptInsertManualType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JavaScriptInsertManualType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JavaScriptInsertManualTypeValidator().Validate(ctx, m, opts...)
}

type ValidateJavaScriptInsertManualType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJavaScriptInsertManualType) JsDownloadPathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for js_download_path")
	}

	return validatorFn, nil
}

func (v *ValidateJavaScriptInsertManualType) JavascriptModeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(JavaScriptMode)
		return int32(i)
	}
	// JavaScriptMode_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, JavaScriptMode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for javascript_mode")
	}

	return validatorFn, nil
}

func (v *ValidateJavaScriptInsertManualType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JavaScriptInsertManualType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JavaScriptInsertManualType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["javascript_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("javascript_mode"))
		if err := fv(ctx, m.GetJavascriptMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["js_download_path"]; exists {

		vOpts := append(opts, db.WithValidateField("js_download_path"))
		if err := fv(ctx, m.GetJsDownloadPath(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJavaScriptInsertManualTypeValidator = func() *ValidateJavaScriptInsertManualType {
	v := &ValidateJavaScriptInsertManualType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhJsDownloadPath := v.JsDownloadPathValidationRuleHandler
	rulesJsDownloadPath := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
	}
	vFn, err = vrhJsDownloadPath(rulesJsDownloadPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavaScriptInsertManualType.js_download_path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["js_download_path"] = vFn

	vrhJavascriptMode := v.JavascriptModeValidationRuleHandler
	rulesJavascriptMode := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhJavascriptMode(rulesJavascriptMode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavaScriptInsertManualType.javascript_mode: %s", err)
		panic(errMsg)
	}
	v.FldValidators["javascript_mode"] = vFn

	return v
}()

func JavaScriptInsertManualTypeValidator() db.Validator {
	return DefaultJavaScriptInsertManualTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *JavaScriptInsertType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JavaScriptInsertType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JavaScriptInsertType) DeepCopy() *JavaScriptInsertType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JavaScriptInsertType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JavaScriptInsertType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JavaScriptInsertType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JavaScriptInsertTypeValidator().Validate(ctx, m, opts...)
}

type ValidateJavaScriptInsertType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJavaScriptInsertType) RulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rules")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*JavaScriptInsertionRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := JavaScriptInsertionRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rules")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*JavaScriptInsertionRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*JavaScriptInsertionRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rules")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rules")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateJavaScriptInsertType) ExcludeListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for exclude_list")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*JavaScriptExclusionRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := JavaScriptExclusionRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*JavaScriptExclusionRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*JavaScriptExclusionRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateJavaScriptInsertType) JsDownloadPathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for js_download_path")
	}

	return validatorFn, nil
}

func (v *ValidateJavaScriptInsertType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JavaScriptInsertType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JavaScriptInsertType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exclude_list"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_list"))
		if err := fv(ctx, m.GetExcludeList(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["javascript_location"]; exists {

		vOpts := append(opts, db.WithValidateField("javascript_location"))
		if err := fv(ctx, m.GetJavascriptLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["js_download_path"]; exists {

		vOpts := append(opts, db.WithValidateField("js_download_path"))
		if err := fv(ctx, m.GetJsDownloadPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rules"]; exists {
		vOpts := append(opts, db.WithValidateField("rules"))
		if err := fv(ctx, m.GetRules(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJavaScriptInsertTypeValidator = func() *ValidateJavaScriptInsertType {
	v := &ValidateJavaScriptInsertType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRules := v.RulesValidationRuleHandler
	rulesRules := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "128",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRules(rulesRules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavaScriptInsertType.rules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rules"] = vFn

	vrhExcludeList := v.ExcludeListValidationRuleHandler
	rulesExcludeList := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "128",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhExcludeList(rulesExcludeList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavaScriptInsertType.exclude_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_list"] = vFn

	vrhJsDownloadPath := v.JsDownloadPathValidationRuleHandler
	rulesJsDownloadPath := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
	}
	vFn, err = vrhJsDownloadPath(rulesJsDownloadPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavaScriptInsertType.js_download_path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["js_download_path"] = vFn

	return v
}()

func JavaScriptInsertTypeValidator() db.Validator {
	return DefaultJavaScriptInsertTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *JavaScriptInsertionRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JavaScriptInsertionRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JavaScriptInsertionRule) DeepCopy() *JavaScriptInsertionRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JavaScriptInsertionRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JavaScriptInsertionRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JavaScriptInsertionRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JavaScriptInsertionRuleValidator().Validate(ctx, m, opts...)
}

type ValidateJavaScriptInsertionRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJavaScriptInsertionRule) DomainMatcherChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_matcher_choice")
	}
	return validatorFn, nil
}

func (v *ValidateJavaScriptInsertionRule) UriPathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for uri_path")
	}
	return validatorFn, nil
}

func (v *ValidateJavaScriptInsertionRule) UriPathPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Prefix, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for prefix")
	}
	return oValidatorFn_Prefix, nil
}
func (v *ValidateJavaScriptInsertionRule) UriPathExactPathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ExactPath, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exact_path")
	}
	return oValidatorFn_ExactPath, nil
}
func (v *ValidateJavaScriptInsertionRule) UriPathGlobValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Glob, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for glob")
	}
	return oValidatorFn_Glob, nil
}

func (v *ValidateJavaScriptInsertionRule) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateJavaScriptInsertionRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JavaScriptInsertionRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JavaScriptInsertionRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain_matcher_choice"]; exists {
		val := m.GetDomainMatcherChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_matcher_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainMatcherChoice().(type) {
	case *JavaScriptInsertionRule_AnyDomain:
		if fv, exists := v.FldValidators["domain_matcher_choice.any_domain"]; exists {
			val := m.GetDomainMatcherChoice().(*JavaScriptInsertionRule_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_matcher_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *JavaScriptInsertionRule_Domain:
		if fv, exists := v.FldValidators["domain_matcher_choice.domain"]; exists {
			val := m.GetDomainMatcherChoice().(*JavaScriptInsertionRule_Domain).Domain
			vOpts := append(opts,
				db.WithValidateField("domain_matcher_choice"),
				db.WithValidateField("domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["uri_path"]; exists {
		val := m.GetUriPath()
		vOpts := append(opts,
			db.WithValidateField("uri_path"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetUriPath().(type) {
	case *JavaScriptInsertionRule_Prefix:
		if fv, exists := v.FldValidators["uri_path.prefix"]; exists {
			val := m.GetUriPath().(*JavaScriptInsertionRule_Prefix).Prefix
			vOpts := append(opts,
				db.WithValidateField("uri_path"),
				db.WithValidateField("prefix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *JavaScriptInsertionRule_ExactPath:
		if fv, exists := v.FldValidators["uri_path.exact_path"]; exists {
			val := m.GetUriPath().(*JavaScriptInsertionRule_ExactPath).ExactPath
			vOpts := append(opts,
				db.WithValidateField("uri_path"),
				db.WithValidateField("exact_path"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *JavaScriptInsertionRule_Glob:
		if fv, exists := v.FldValidators["uri_path.glob"]; exists {
			val := m.GetUriPath().(*JavaScriptInsertionRule_Glob).Glob
			vOpts := append(opts,
				db.WithValidateField("uri_path"),
				db.WithValidateField("glob"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJavaScriptInsertionRuleValidator = func() *ValidateJavaScriptInsertionRule {
	v := &ValidateJavaScriptInsertionRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainMatcherChoice := v.DomainMatcherChoiceValidationRuleHandler
	rulesDomainMatcherChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainMatcherChoice(rulesDomainMatcherChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavaScriptInsertionRule.domain_matcher_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_matcher_choice"] = vFn

	vrhUriPath := v.UriPathValidationRuleHandler
	rulesUriPath := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhUriPath(rulesUriPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavaScriptInsertionRule.uri_path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["uri_path"] = vFn

	vrhUriPathPrefix := v.UriPathPrefixValidationRuleHandler
	rulesUriPathPrefix := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFnMap["uri_path.prefix"], err = vrhUriPathPrefix(rulesUriPathPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field JavaScriptInsertionRule.uri_path_prefix: %s", err)
		panic(errMsg)
	}
	vrhUriPathExactPath := v.UriPathExactPathValidationRuleHandler
	rulesUriPathExactPath := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFnMap["uri_path.exact_path"], err = vrhUriPathExactPath(rulesUriPathExactPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field JavaScriptInsertionRule.uri_path_exact_path: %s", err)
		panic(errMsg)
	}
	vrhUriPathGlob := v.UriPathGlobValidationRuleHandler
	rulesUriPathGlob := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "256",
		"ves.io.schema.rules.string.min_bytes": "1",
		"ves.io.schema.rules.string.pattern":   "^[\\\"$&'*+./0-9:?@A-Z_a-z~-]{1,256}$",
	}
	vFnMap["uri_path.glob"], err = vrhUriPathGlob(rulesUriPathGlob)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field JavaScriptInsertionRule.uri_path_glob: %s", err)
		panic(errMsg)
	}

	v.FldValidators["uri_path.prefix"] = vFnMap["uri_path.prefix"]
	v.FldValidators["uri_path.exact_path"] = vFnMap["uri_path.exact_path"]
	v.FldValidators["uri_path.glob"] = vFnMap["uri_path.glob"]

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavaScriptInsertionRule.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	v.FldValidators["domain_matcher_choice.domain"] = ves_io_schema.DomainTypeValidator().Validate

	return v
}()

func JavaScriptInsertionRuleValidator() db.Validator {
	return DefaultJavaScriptInsertionRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *MobileClientType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MobileClientType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MobileClientType) DeepCopy() *MobileClientType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MobileClientType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MobileClientType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MobileClientType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MobileClientTypeValidator().Validate(ctx, m, opts...)
}

type ValidateMobileClientType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMobileClientType) MitigationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mitigation")
	}
	return validatorFn, nil
}

func (v *ValidateMobileClientType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MobileClientType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MobileClientType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["mitigation"]; exists {
		val := m.GetMitigation()
		vOpts := append(opts,
			db.WithValidateField("mitigation"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMitigation().(type) {
	case *MobileClientType_Continue:
		if fv, exists := v.FldValidators["mitigation.continue"]; exists {
			val := m.GetMitigation().(*MobileClientType_Continue).Continue
			vOpts := append(opts,
				db.WithValidateField("mitigation"),
				db.WithValidateField("continue"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *MobileClientType_Block:
		if fv, exists := v.FldValidators["mitigation.block"]; exists {
			val := m.GetMitigation().(*MobileClientType_Block).Block
			vOpts := append(opts,
				db.WithValidateField("mitigation"),
				db.WithValidateField("block"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMobileClientTypeValidator = func() *ValidateMobileClientType {
	v := &ValidateMobileClientType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMitigation := v.MitigationValidationRuleHandler
	rulesMitigation := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMitigation(rulesMitigation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MobileClientType.mitigation: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mitigation"] = vFn

	v.FldValidators["mitigation.block"] = BlockMobileMitigationChoiceTypeValidator().Validate

	return v
}()

func MobileClientTypeValidator() db.Validator {
	return DefaultMobileClientTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *MobileSDKConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MobileSDKConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MobileSDKConfigType) DeepCopy() *MobileSDKConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MobileSDKConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MobileSDKConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MobileSDKConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MobileSDKConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateMobileSDKConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMobileSDKConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MobileSDKConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MobileSDKConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["mobile_identifier"]; exists {

		vOpts := append(opts, db.WithValidateField("mobile_identifier"))
		if err := fv(ctx, m.GetMobileIdentifier(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMobileSDKConfigTypeValidator = func() *ValidateMobileSDKConfigType {
	v := &ValidateMobileSDKConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["mobile_identifier"] = MobileTrafficIdentifierTypeValidator().Validate

	return v
}()

func MobileSDKConfigTypeValidator() db.Validator {
	return DefaultMobileSDKConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *MobileTrafficIdentifierType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MobileTrafficIdentifierType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MobileTrafficIdentifierType) DeepCopy() *MobileTrafficIdentifierType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MobileTrafficIdentifierType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MobileTrafficIdentifierType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MobileTrafficIdentifierType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MobileTrafficIdentifierTypeValidator().Validate(ctx, m, opts...)
}

type ValidateMobileTrafficIdentifierType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMobileTrafficIdentifierType) HeadersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for headers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*HeaderMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := HeaderMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for headers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*HeaderMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*HeaderMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated headers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items headers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMobileTrafficIdentifierType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MobileTrafficIdentifierType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MobileTrafficIdentifierType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["headers"]; exists {
		vOpts := append(opts, db.WithValidateField("headers"))
		if err := fv(ctx, m.GetHeaders(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMobileTrafficIdentifierTypeValidator = func() *ValidateMobileTrafficIdentifierType {
	v := &ValidateMobileTrafficIdentifierType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHeaders := v.HeadersValidationRuleHandler
	rulesHeaders := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhHeaders(rulesHeaders)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MobileTrafficIdentifierType.headers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["headers"] = vFn

	return v
}()

func MobileTrafficIdentifierTypeValidator() db.Validator {
	return DefaultMobileTrafficIdentifierTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PathType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PathType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PathType) DeepCopy() *PathType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PathType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PathType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PathType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PathTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePathType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePathType) PathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path")
	}

	return validatorFn, nil
}

func (v *ValidatePathType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PathType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PathType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["caseinsensitive"]; exists {

		vOpts := append(opts, db.WithValidateField("caseinsensitive"))
		if err := fv(ctx, m.GetCaseinsensitive(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPathTypeValidator = func() *ValidatePathType {
	v := &ValidatePathType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPath := v.PathValidationRuleHandler
	rulesPath := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
		"ves.io.schema.rules.string.min_bytes": "1",
		"ves.io.schema.rules.string.pattern":   "^[\\\"$&'*+./0-9:?@A-Z_a-z~-]{1,999}$",
	}
	vFn, err = vrhPath(rulesPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathType.path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path"] = vFn

	return v
}()

func PathTypeValidator() db.Validator {
	return DefaultPathTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ProtectedEndpointType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ProtectedEndpointType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ProtectedEndpointType) DeepCopy() *ProtectedEndpointType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ProtectedEndpointType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ProtectedEndpointType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ProtectedEndpointType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ProtectedEndpointTypeValidator().Validate(ctx, m, opts...)
}

type ValidateProtectedEndpointType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateProtectedEndpointType) ClientTypeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for client_type_choice")
	}
	return validatorFn, nil
}

func (v *ValidateProtectedEndpointType) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateProtectedEndpointType) PathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for path")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := PathTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateProtectedEndpointType) QueryValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for query")
	}

	return validatorFn, nil
}

func (v *ValidateProtectedEndpointType) HttpMethodsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.BotHttpMethod)
		return int32(i)
	}
	// ves_io_schema.BotHttpMethod_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema.BotHttpMethod_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for http_methods")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema.BotHttpMethod, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for http_methods")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema.BotHttpMethod)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema.BotHttpMethod, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated http_methods")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items http_methods")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateProtectedEndpointType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ProtectedEndpointType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ProtectedEndpointType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["client_type_choice"]; exists {
		val := m.GetClientTypeChoice()
		vOpts := append(opts,
			db.WithValidateField("client_type_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetClientTypeChoice().(type) {
	case *ProtectedEndpointType_WebClient:
		if fv, exists := v.FldValidators["client_type_choice.web_client"]; exists {
			val := m.GetClientTypeChoice().(*ProtectedEndpointType_WebClient).WebClient
			vOpts := append(opts,
				db.WithValidateField("client_type_choice"),
				db.WithValidateField("web_client"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProtectedEndpointType_MobileClient:
		if fv, exists := v.FldValidators["client_type_choice.mobile_client"]; exists {
			val := m.GetClientTypeChoice().(*ProtectedEndpointType_MobileClient).MobileClient
			vOpts := append(opts,
				db.WithValidateField("client_type_choice"),
				db.WithValidateField("mobile_client"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProtectedEndpointType_WebMobileClient:
		if fv, exists := v.FldValidators["client_type_choice.web_mobile_client"]; exists {
			val := m.GetClientTypeChoice().(*ProtectedEndpointType_WebMobileClient).WebMobileClient
			vOpts := append(opts,
				db.WithValidateField("client_type_choice"),
				db.WithValidateField("web_mobile_client"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetDomainMatcherChoice().(type) {
	case *ProtectedEndpointType_AnyDomain:
		if fv, exists := v.FldValidators["domain_matcher_choice.any_domain"]; exists {
			val := m.GetDomainMatcherChoice().(*ProtectedEndpointType_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_matcher_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProtectedEndpointType_Domain:
		if fv, exists := v.FldValidators["domain_matcher_choice.domain"]; exists {
			val := m.GetDomainMatcherChoice().(*ProtectedEndpointType_Domain).Domain
			vOpts := append(opts,
				db.WithValidateField("domain_matcher_choice"),
				db.WithValidateField("domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["http_methods"]; exists {
		vOpts := append(opts, db.WithValidateField("http_methods"))
		if err := fv(ctx, m.GetHttpMethods(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultProtectedEndpointTypeValidator = func() *ValidateProtectedEndpointType {
	v := &ValidateProtectedEndpointType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhClientTypeChoice := v.ClientTypeChoiceValidationRuleHandler
	rulesClientTypeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhClientTypeChoice(rulesClientTypeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedEndpointType.client_type_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["client_type_choice"] = vFn

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedEndpointType.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	vrhPath := v.PathValidationRuleHandler
	rulesPath := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPath(rulesPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedEndpointType.path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path"] = vFn

	vrhQuery := v.QueryValidationRuleHandler
	rulesQuery := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "256",
		"ves.io.schema.rules.string.regex":     "true",
	}
	vFn, err = vrhQuery(rulesQuery)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedEndpointType.query: %s", err)
		panic(errMsg)
	}
	v.FldValidators["query"] = vFn

	vrhHttpMethods := v.HttpMethodsValidationRuleHandler
	rulesHttpMethods := map[string]string{
		"ves.io.schema.rules.message.required":                 "true",
		"ves.io.schema.rules.repeated.items.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.items.enum.in":           "[1,3,4]",
		"ves.io.schema.rules.repeated.max_items":               "4",
		"ves.io.schema.rules.repeated.min_items":               "1",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhHttpMethods(rulesHttpMethods)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedEndpointType.http_methods: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_methods"] = vFn

	v.FldValidators["client_type_choice.web_client"] = WebClientTypeValidator().Validate
	v.FldValidators["client_type_choice.mobile_client"] = MobileClientTypeValidator().Validate
	v.FldValidators["client_type_choice.web_mobile_client"] = WebMobileClientTypeValidator().Validate

	v.FldValidators["domain_matcher_choice.domain"] = ves_io_schema.DomainTypeValidator().Validate

	return v
}()

func ProtectedEndpointTypeValidator() db.Validator {
	return DefaultProtectedEndpointTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RedirectMitigationChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RedirectMitigationChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RedirectMitigationChoiceType) DeepCopy() *RedirectMitigationChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RedirectMitigationChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RedirectMitigationChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RedirectMitigationChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RedirectMitigationChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateRedirectMitigationChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRedirectMitigationChoiceType) StatusValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.HttpStatusCode)
		return int32(i)
	}
	// ves_io_schema.HttpStatusCode_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.HttpStatusCode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for status")
	}

	return validatorFn, nil
}

func (v *ValidateRedirectMitigationChoiceType) LocationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for location")
	}

	return validatorFn, nil
}

func (v *ValidateRedirectMitigationChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RedirectMitigationChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RedirectMitigationChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["location"]; exists {

		vOpts := append(opts, db.WithValidateField("location"))
		if err := fv(ctx, m.GetLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRedirectMitigationChoiceTypeValidator = func() *ValidateRedirectMitigationChoiceType {
	v := &ValidateRedirectMitigationChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStatus := v.StatusValidationRuleHandler
	rulesStatus := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.enum.in":           "[302,303,307]",
		"ves.io.schema.rules.message.required":  "true",
	}
	vFn, err = vrhStatus(rulesStatus)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RedirectMitigationChoiceType.status: %s", err)
		panic(errMsg)
	}
	v.FldValidators["status"] = vFn

	vrhLocation := v.LocationValidationRuleHandler
	rulesLocation := map[string]string{
		"ves.io.schema.rules.message.required":      "true",
		"ves.io.schema.rules.string.max_bytes":      "512",
		"ves.io.schema.rules.string.url_or_uri_ref": "true",
	}
	vFn, err = vrhLocation(rulesLocation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RedirectMitigationChoiceType.location: %s", err)
		panic(errMsg)
	}
	v.FldValidators["location"] = vFn

	return v
}()

func RedirectMitigationChoiceTypeValidator() db.Validator {
	return DefaultRedirectMitigationChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *WebClientType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WebClientType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WebClientType) DeepCopy() *WebClientType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WebClientType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WebClientType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WebClientType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WebClientTypeValidator().Validate(ctx, m, opts...)
}

type ValidateWebClientType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWebClientType) MitigationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mitigation")
	}
	return validatorFn, nil
}

func (v *ValidateWebClientType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WebClientType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WebClientType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["mitigation"]; exists {
		val := m.GetMitigation()
		vOpts := append(opts,
			db.WithValidateField("mitigation"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMitigation().(type) {
	case *WebClientType_Continue:
		if fv, exists := v.FldValidators["mitigation.continue"]; exists {
			val := m.GetMitigation().(*WebClientType_Continue).Continue
			vOpts := append(opts,
				db.WithValidateField("mitigation"),
				db.WithValidateField("continue"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WebClientType_Redirect:
		if fv, exists := v.FldValidators["mitigation.redirect"]; exists {
			val := m.GetMitigation().(*WebClientType_Redirect).Redirect
			vOpts := append(opts,
				db.WithValidateField("mitigation"),
				db.WithValidateField("redirect"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WebClientType_Block:
		if fv, exists := v.FldValidators["mitigation.block"]; exists {
			val := m.GetMitigation().(*WebClientType_Block).Block
			vOpts := append(opts,
				db.WithValidateField("mitigation"),
				db.WithValidateField("block"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWebClientTypeValidator = func() *ValidateWebClientType {
	v := &ValidateWebClientType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMitigation := v.MitigationValidationRuleHandler
	rulesMitigation := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMitigation(rulesMitigation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WebClientType.mitigation: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mitigation"] = vFn

	v.FldValidators["mitigation.redirect"] = RedirectMitigationChoiceTypeValidator().Validate
	v.FldValidators["mitigation.block"] = BlockMitigationChoiceTypeValidator().Validate

	return v
}()

func WebClientTypeValidator() db.Validator {
	return DefaultWebClientTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *WebMobileClientType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WebMobileClientType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WebMobileClientType) DeepCopy() *WebMobileClientType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WebMobileClientType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WebMobileClientType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WebMobileClientType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WebMobileClientTypeValidator().Validate(ctx, m, opts...)
}

type ValidateWebMobileClientType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWebMobileClientType) MobileMitigationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mobile_mitigation")
	}
	return validatorFn, nil
}

func (v *ValidateWebMobileClientType) WebMitigationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for web_mitigation")
	}
	return validatorFn, nil
}

func (v *ValidateWebMobileClientType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WebMobileClientType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WebMobileClientType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["mobile_mitigation"]; exists {
		val := m.GetMobileMitigation()
		vOpts := append(opts,
			db.WithValidateField("mobile_mitigation"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMobileMitigation().(type) {
	case *WebMobileClientType_ContinueMobile:
		if fv, exists := v.FldValidators["mobile_mitigation.continue_mobile"]; exists {
			val := m.GetMobileMitigation().(*WebMobileClientType_ContinueMobile).ContinueMobile
			vOpts := append(opts,
				db.WithValidateField("mobile_mitigation"),
				db.WithValidateField("continue_mobile"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WebMobileClientType_BlockMobile:
		if fv, exists := v.FldValidators["mobile_mitigation.block_mobile"]; exists {
			val := m.GetMobileMitigation().(*WebMobileClientType_BlockMobile).BlockMobile
			vOpts := append(opts,
				db.WithValidateField("mobile_mitigation"),
				db.WithValidateField("block_mobile"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["web_mitigation"]; exists {
		val := m.GetWebMitigation()
		vOpts := append(opts,
			db.WithValidateField("web_mitigation"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetWebMitigation().(type) {
	case *WebMobileClientType_ContinueWeb:
		if fv, exists := v.FldValidators["web_mitigation.continue_web"]; exists {
			val := m.GetWebMitigation().(*WebMobileClientType_ContinueWeb).ContinueWeb
			vOpts := append(opts,
				db.WithValidateField("web_mitigation"),
				db.WithValidateField("continue_web"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WebMobileClientType_RedirectWeb:
		if fv, exists := v.FldValidators["web_mitigation.redirect_web"]; exists {
			val := m.GetWebMitigation().(*WebMobileClientType_RedirectWeb).RedirectWeb
			vOpts := append(opts,
				db.WithValidateField("web_mitigation"),
				db.WithValidateField("redirect_web"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WebMobileClientType_BlockWeb:
		if fv, exists := v.FldValidators["web_mitigation.block_web"]; exists {
			val := m.GetWebMitigation().(*WebMobileClientType_BlockWeb).BlockWeb
			vOpts := append(opts,
				db.WithValidateField("web_mitigation"),
				db.WithValidateField("block_web"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWebMobileClientTypeValidator = func() *ValidateWebMobileClientType {
	v := &ValidateWebMobileClientType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMobileMitigation := v.MobileMitigationValidationRuleHandler
	rulesMobileMitigation := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMobileMitigation(rulesMobileMitigation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WebMobileClientType.mobile_mitigation: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mobile_mitigation"] = vFn

	vrhWebMitigation := v.WebMitigationValidationRuleHandler
	rulesWebMitigation := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhWebMitigation(rulesWebMitigation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WebMobileClientType.web_mitigation: %s", err)
		panic(errMsg)
	}
	v.FldValidators["web_mitigation"] = vFn

	v.FldValidators["mobile_mitigation.block_mobile"] = BlockMobileMitigationChoiceTypeValidator().Validate

	v.FldValidators["web_mitigation.redirect_web"] = RedirectMitigationChoiceTypeValidator().Validate
	v.FldValidators["web_mitigation.block_web"] = BlockMitigationChoiceTypeValidator().Validate

	return v
}()

func WebMobileClientTypeValidator() db.Validator {
	return DefaultWebMobileClientTypeValidator
}
