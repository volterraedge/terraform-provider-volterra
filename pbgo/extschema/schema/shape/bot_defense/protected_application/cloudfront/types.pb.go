// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/shape/bot_defense/protected_application/cloudfront/types.proto

package cloudfront

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	_ "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// loglevel
//
// x-displayName: "Log Level"
// Select the level of logging desired. Levels are cumulative
// (e.g. Debug includes Error, Warning, and Informational)
type LogLevel int32

const (
	// Undefined
	//
	// x-displayName: "Undefined"
	LOG_UNDEFINED LogLevel = 0
	// Error
	//
	// x-displayName: "Error"
	// Log only errors
	LOG_ERROR LogLevel = 1
	// Warning
	//
	// x-displayName: "Warning"
	// Log malicious requests
	LOG_WARNING LogLevel = 2
	// Info
	//
	// x-displayName: "Informational"
	// Log all requests
	LOG_INFO LogLevel = 3
	// Debug
	//
	// x-displayName: "Debug"
	// Log debugging data
	LOG_DEBUG LogLevel = 4
)

var LogLevel_name = map[int32]string{
	0: "LOG_UNDEFINED",
	1: "LOG_ERROR",
	2: "LOG_WARNING",
	3: "LOG_INFO",
	4: "LOG_DEBUG",
}

var LogLevel_value = map[string]int32{
	"LOG_UNDEFINED": 0,
	"LOG_ERROR":     1,
	"LOG_WARNING":   2,
	"LOG_INFO":      3,
	"LOG_DEBUG":     4,
}

func (LogLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{0}
}

// JavaScript Mode
//
// x-displayName: "Web Client JavaScript Mode"
// Web Client JavaScript Mode.
type JavaScriptMode int32

const (
	// x-displayName: "Async JS with no Caching"
	// Bot Defense JavaScript for telemetry collection is requested asynchronously, and it is non-cacheable
	ASYNC_JS_NO_CACHING JavaScriptMode = 0
	// x-displayName: "Async JS with Caching"
	// Bot Defense JavaScript for telemetry collection is requested asynchronously, and it is cacheable
	ASYNC_JS_CACHING JavaScriptMode = 1
	// x-displayName: "Sync JS with no Caching"
	// Bot Defense JavaScript for telemetry collection is requested synchronously, and it is non-cacheable
	SYNC_JS_NO_CACHING JavaScriptMode = 2
	// x-displayName: "Sync JS with Caching"
	// Bot Defense JavaScript for telemetry collection is requested synchronously, and it is cacheable
	SYNC_JS_CACHING JavaScriptMode = 3
)

var JavaScriptMode_name = map[int32]string{
	0: "ASYNC_JS_NO_CACHING",
	1: "ASYNC_JS_CACHING",
	2: "SYNC_JS_NO_CACHING",
	3: "SYNC_JS_CACHING",
}

var JavaScriptMode_value = map[string]int32{
	"ASYNC_JS_NO_CACHING": 0,
	"ASYNC_JS_CACHING":    1,
	"SYNC_JS_NO_CACHING":  2,
	"SYNC_JS_CACHING":     3,
}

func (JavaScriptMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{1}
}

// JavaScriptLocation
//
// x-displayName: "JavaScript Location"
// All inside networks.
type JavaScriptLocation int32

const (
	// JAVA_SCRIPT_LOCATION_UNDEFINED
	//
	// x-displayName: "Undefined"
	// Undefined
	JAVA_SCRIPT_LOCATION_UNDEFINED JavaScriptLocation = 0
	// x-displayName: "After <head> tag"
	// Insert JavaScript after <head> tag
	AFTER_HEAD JavaScriptLocation = 1
	// x-displayName: "After </title> tag"
	// Insert JavaScript after </title> tag.
	AFTER_TITLE_END JavaScriptLocation = 2
	// x-displayName: "Before <script> tag"
	// Insert JavaScript before first <script> tag
	BEFORE_SCRIPT JavaScriptLocation = 3
)

var JavaScriptLocation_name = map[int32]string{
	0: "JAVA_SCRIPT_LOCATION_UNDEFINED",
	1: "AFTER_HEAD",
	2: "AFTER_TITLE_END",
	3: "BEFORE_SCRIPT",
}

var JavaScriptLocation_value = map[string]int32{
	"JAVA_SCRIPT_LOCATION_UNDEFINED": 0,
	"AFTER_HEAD":                     1,
	"AFTER_TITLE_END":                2,
	"BEFORE_SCRIPT":                  3,
}

func (JavaScriptLocation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{2}
}

// CloudfrontType
//
// x-displayName: "Cloudfront"
// Bot Defense policy configuration for AWS Cloudfront
type CloudfrontType struct {
	// protected_endpoints
	//
	// x-displayName: "Protected Endpoints"
	// x-required
	// List of protected endpoints (max 128 items)
	ProtectedEndpoints []*ProtectedEndpointType `protobuf:"bytes,1,rep,name=protected_endpoints,json=protectedEndpoints,proto3" json:"protected_endpoints,omitempty"`
	// js_download_path
	//
	// x-displayName: "Web Client JavaScript Path"
	// x-example: "/common.js"
	// Web client will fetch F5 Client Java Script from this path.
	// This path must not conflict with any other website/application paths.
	//
	// If not specified, default to ‘/common.js’.
	JsDownloadPath string `protobuf:"bytes,2,opt,name=js_download_path,json=jsDownloadPath,proto3" json:"js_download_path,omitempty"` // Deprecated: Do not use.
	// JavaScript Choice
	//
	// x-displayName: "Web Client JavaScript Insertion Settings"
	// x-required
	// For Manual JavaScript Insertion, add the JS tags to one of the recommended locations:
	// Immediately After <Head>, Immediately After </title>, Before <script> (first script tag on the page).
	// JS tags provided in documentation.
	//
	// Types that are valid to be assigned to JavaScriptChoice:
	//	*CloudfrontType_DisableJsInsert
	//	*CloudfrontType_ManualJsInsert
	//	*CloudfrontType_JsInsertAllPages
	//	*CloudfrontType_JsInsertAllPagesExcept
	//	*CloudfrontType_JsInsertionRules
	JavaScriptChoice isCloudfrontType_JavaScriptChoice `protobuf_oneof:"java_script_choice"`
	// Mobile SDK Choice
	//
	// x-displayName: "Activate Mobile SDK"
	// x-required
	// Configure Mobile SDK parameters to protect native mobile app endpoints. If you have selected client type as
	// 'Mobile' or 'Web And Mobile' please Enable Mobile SDK. In the event that there is at least one protected
	// endpoint marked with a client type of 'Web And Mobile', then also define Mobile Request Identifier(s) in
	// advanced setting.
	//
	// Types that are valid to be assigned to MobileSdkChoice:
	//	*CloudfrontType_DisableMobileSdk
	//	*CloudfrontType_MobileSdkConfig
	MobileSdkChoice isCloudfrontType_MobileSdkChoice `protobuf_oneof:"mobile_sdk_choice"`
	// AWS Account Number
	//
	// x-displayName: "AWS Account Number"
	// x-example: "123456789012"
	// We need your AWS account number to provide you access to the F5 solution from your AWS account
	AwsAccountNo string `protobuf:"bytes,19,opt,name=aws_account_no,json=awsAccountNo,proto3" json:"aws_account_no,omitempty"` // Deprecated: Do not use.
	// AWS Configuration Choice
	//
	// x-displayName: "AWS Configuration"
	// x-required
	// AWS Configuration options
	//
	// Types that are valid to be assigned to AwsConfigurationTypeChoice:
	//	*CloudfrontType_DisableAwsConfiguration
	//	*CloudfrontType_AwsConfigurationIdSelector
	//	*CloudfrontType_AwsConfigurationTagSelector
	AwsConfigurationTypeChoice isCloudfrontType_AwsConfigurationTypeChoice `protobuf_oneof:"aws_configuration_type_choice"`
	// Trusted Client Rules
	//
	// x-displayName: "Trusted Client Rules"
	// Define your allowlists to skip Bot Defense inference processing
	TrustedClients []*ClientBypassRule `protobuf:"bytes,35,rep,name=trusted_clients,json=trustedClients,proto3" json:"trusted_clients,omitempty"`
	// timeout
	//
	// x-displayName: "Timeout"
	// x-example: "300"
	// The timeout for the inference check, in milliseconds
	Timeout uint32 `protobuf:"varint,100,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// DataSample
	//
	// x-displayName: "Body Sample Size Limit"
	// x-example: "1024"
	// Limit on amount of request-body data (other than f5 telemetry) to send
	// for analysis (limit 1,048,576 == 1 MiByte)
	DataSample uint32 `protobuf:"varint,101,opt,name=data_sample,json=dataSample,proto3" json:"data_sample,omitempty"`
	// Continue Header name
	//
	// x-displayName: "Header Name For Continue Mitigation Action"
	// x-example: "x-f5-bot-inference"
	// A case-insensitive HTTP header name for Continue Mitigation Action when add header selected.
	ContinueMitigationActionHdr string `protobuf:"bytes,102,opt,name=continue_mitigation_action_hdr,json=continueMitigationActionHdr,proto3" json:"continue_mitigation_action_hdr,omitempty"`
	// loglevel
	//
	// x-displayName: "Log Level"
	// Select the level of logging desired. Levels are cumulative
	// (e.g. Debug includes Error, Warning, and Informational)
	Loglevel LogLevel `protobuf:"varint,103,opt,name=loglevel,proto3,enum=ves.io.schema.shape.bot_defense.protected_application.cloudfront.LogLevel" json:"loglevel,omitempty"`
}

func (m *CloudfrontType) Reset()      { *m = CloudfrontType{} }
func (*CloudfrontType) ProtoMessage() {}
func (*CloudfrontType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{0}
}
func (m *CloudfrontType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudfrontType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloudfrontType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudfrontType.Merge(m, src)
}
func (m *CloudfrontType) XXX_Size() int {
	return m.Size()
}
func (m *CloudfrontType) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudfrontType.DiscardUnknown(m)
}

var xxx_messageInfo_CloudfrontType proto.InternalMessageInfo

type isCloudfrontType_JavaScriptChoice interface {
	isCloudfrontType_JavaScriptChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCloudfrontType_MobileSdkChoice interface {
	isCloudfrontType_MobileSdkChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCloudfrontType_AwsConfigurationTypeChoice interface {
	isCloudfrontType_AwsConfigurationTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CloudfrontType_DisableJsInsert struct {
	DisableJsInsert *schema.Empty `protobuf:"bytes,4,opt,name=disable_js_insert,json=disableJsInsert,proto3,oneof" json:"disable_js_insert,omitempty"`
}
type CloudfrontType_ManualJsInsert struct {
	ManualJsInsert *JavaScriptInsertManualType `protobuf:"bytes,104,opt,name=manual_js_insert,json=manualJsInsert,proto3,oneof" json:"manual_js_insert,omitempty"`
}
type CloudfrontType_JsInsertAllPages struct {
	JsInsertAllPages *JavaScriptInsertAllType `protobuf:"bytes,5,opt,name=js_insert_all_pages,json=jsInsertAllPages,proto3,oneof" json:"js_insert_all_pages,omitempty"`
}
type CloudfrontType_JsInsertAllPagesExcept struct {
	JsInsertAllPagesExcept *JavaScriptInsertAllWithExceptionsType `protobuf:"bytes,6,opt,name=js_insert_all_pages_except,json=jsInsertAllPagesExcept,proto3,oneof" json:"js_insert_all_pages_except,omitempty"`
}
type CloudfrontType_JsInsertionRules struct {
	JsInsertionRules *JavaScriptInsertType `protobuf:"bytes,7,opt,name=js_insertion_rules,json=jsInsertionRules,proto3,oneof" json:"js_insertion_rules,omitempty"`
}
type CloudfrontType_DisableMobileSdk struct {
	DisableMobileSdk *schema.Empty `protobuf:"bytes,25,opt,name=disable_mobile_sdk,json=disableMobileSdk,proto3,oneof" json:"disable_mobile_sdk,omitempty"`
}
type CloudfrontType_MobileSdkConfig struct {
	MobileSdkConfig *MobileSDKConfigType `protobuf:"bytes,26,opt,name=mobile_sdk_config,json=mobileSdkConfig,proto3,oneof" json:"mobile_sdk_config,omitempty"`
}
type CloudfrontType_DisableAwsConfiguration struct {
	DisableAwsConfiguration *schema.Empty `protobuf:"bytes,21,opt,name=disable_aws_configuration,json=disableAwsConfiguration,proto3,oneof" json:"disable_aws_configuration,omitempty"`
}
type CloudfrontType_AwsConfigurationIdSelector struct {
	AwsConfigurationIdSelector *DistributionIDList `protobuf:"bytes,22,opt,name=aws_configuration_id_selector,json=awsConfigurationIdSelector,proto3,oneof" json:"aws_configuration_id_selector,omitempty"`
}
type CloudfrontType_AwsConfigurationTagSelector struct {
	AwsConfigurationTagSelector *DistributionTagList `protobuf:"bytes,23,opt,name=aws_configuration_tag_selector,json=awsConfigurationTagSelector,proto3,oneof" json:"aws_configuration_tag_selector,omitempty"`
}

func (*CloudfrontType_DisableJsInsert) isCloudfrontType_JavaScriptChoice()                       {}
func (*CloudfrontType_ManualJsInsert) isCloudfrontType_JavaScriptChoice()                        {}
func (*CloudfrontType_JsInsertAllPages) isCloudfrontType_JavaScriptChoice()                      {}
func (*CloudfrontType_JsInsertAllPagesExcept) isCloudfrontType_JavaScriptChoice()                {}
func (*CloudfrontType_JsInsertionRules) isCloudfrontType_JavaScriptChoice()                      {}
func (*CloudfrontType_DisableMobileSdk) isCloudfrontType_MobileSdkChoice()                       {}
func (*CloudfrontType_MobileSdkConfig) isCloudfrontType_MobileSdkChoice()                        {}
func (*CloudfrontType_DisableAwsConfiguration) isCloudfrontType_AwsConfigurationTypeChoice()     {}
func (*CloudfrontType_AwsConfigurationIdSelector) isCloudfrontType_AwsConfigurationTypeChoice()  {}
func (*CloudfrontType_AwsConfigurationTagSelector) isCloudfrontType_AwsConfigurationTypeChoice() {}

func (m *CloudfrontType) GetJavaScriptChoice() isCloudfrontType_JavaScriptChoice {
	if m != nil {
		return m.JavaScriptChoice
	}
	return nil
}
func (m *CloudfrontType) GetMobileSdkChoice() isCloudfrontType_MobileSdkChoice {
	if m != nil {
		return m.MobileSdkChoice
	}
	return nil
}
func (m *CloudfrontType) GetAwsConfigurationTypeChoice() isCloudfrontType_AwsConfigurationTypeChoice {
	if m != nil {
		return m.AwsConfigurationTypeChoice
	}
	return nil
}

func (m *CloudfrontType) GetProtectedEndpoints() []*ProtectedEndpointType {
	if m != nil {
		return m.ProtectedEndpoints
	}
	return nil
}

// Deprecated: Do not use.
func (m *CloudfrontType) GetJsDownloadPath() string {
	if m != nil {
		return m.JsDownloadPath
	}
	return ""
}

func (m *CloudfrontType) GetDisableJsInsert() *schema.Empty {
	if x, ok := m.GetJavaScriptChoice().(*CloudfrontType_DisableJsInsert); ok {
		return x.DisableJsInsert
	}
	return nil
}

func (m *CloudfrontType) GetManualJsInsert() *JavaScriptInsertManualType {
	if x, ok := m.GetJavaScriptChoice().(*CloudfrontType_ManualJsInsert); ok {
		return x.ManualJsInsert
	}
	return nil
}

func (m *CloudfrontType) GetJsInsertAllPages() *JavaScriptInsertAllType {
	if x, ok := m.GetJavaScriptChoice().(*CloudfrontType_JsInsertAllPages); ok {
		return x.JsInsertAllPages
	}
	return nil
}

func (m *CloudfrontType) GetJsInsertAllPagesExcept() *JavaScriptInsertAllWithExceptionsType {
	if x, ok := m.GetJavaScriptChoice().(*CloudfrontType_JsInsertAllPagesExcept); ok {
		return x.JsInsertAllPagesExcept
	}
	return nil
}

func (m *CloudfrontType) GetJsInsertionRules() *JavaScriptInsertType {
	if x, ok := m.GetJavaScriptChoice().(*CloudfrontType_JsInsertionRules); ok {
		return x.JsInsertionRules
	}
	return nil
}

func (m *CloudfrontType) GetDisableMobileSdk() *schema.Empty {
	if x, ok := m.GetMobileSdkChoice().(*CloudfrontType_DisableMobileSdk); ok {
		return x.DisableMobileSdk
	}
	return nil
}

func (m *CloudfrontType) GetMobileSdkConfig() *MobileSDKConfigType {
	if x, ok := m.GetMobileSdkChoice().(*CloudfrontType_MobileSdkConfig); ok {
		return x.MobileSdkConfig
	}
	return nil
}

// Deprecated: Do not use.
func (m *CloudfrontType) GetAwsAccountNo() string {
	if m != nil {
		return m.AwsAccountNo
	}
	return ""
}

func (m *CloudfrontType) GetDisableAwsConfiguration() *schema.Empty {
	if x, ok := m.GetAwsConfigurationTypeChoice().(*CloudfrontType_DisableAwsConfiguration); ok {
		return x.DisableAwsConfiguration
	}
	return nil
}

func (m *CloudfrontType) GetAwsConfigurationIdSelector() *DistributionIDList {
	if x, ok := m.GetAwsConfigurationTypeChoice().(*CloudfrontType_AwsConfigurationIdSelector); ok {
		return x.AwsConfigurationIdSelector
	}
	return nil
}

func (m *CloudfrontType) GetAwsConfigurationTagSelector() *DistributionTagList {
	if x, ok := m.GetAwsConfigurationTypeChoice().(*CloudfrontType_AwsConfigurationTagSelector); ok {
		return x.AwsConfigurationTagSelector
	}
	return nil
}

func (m *CloudfrontType) GetTrustedClients() []*ClientBypassRule {
	if m != nil {
		return m.TrustedClients
	}
	return nil
}

func (m *CloudfrontType) GetTimeout() uint32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *CloudfrontType) GetDataSample() uint32 {
	if m != nil {
		return m.DataSample
	}
	return 0
}

func (m *CloudfrontType) GetContinueMitigationActionHdr() string {
	if m != nil {
		return m.ContinueMitigationActionHdr
	}
	return ""
}

func (m *CloudfrontType) GetLoglevel() LogLevel {
	if m != nil {
		return m.Loglevel
	}
	return LOG_UNDEFINED
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CloudfrontType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CloudfrontType_DisableJsInsert)(nil),
		(*CloudfrontType_ManualJsInsert)(nil),
		(*CloudfrontType_JsInsertAllPages)(nil),
		(*CloudfrontType_JsInsertAllPagesExcept)(nil),
		(*CloudfrontType_JsInsertionRules)(nil),
		(*CloudfrontType_DisableMobileSdk)(nil),
		(*CloudfrontType_MobileSdkConfig)(nil),
		(*CloudfrontType_DisableAwsConfiguration)(nil),
		(*CloudfrontType_AwsConfigurationIdSelector)(nil),
		(*CloudfrontType_AwsConfigurationTagSelector)(nil),
	}
}

// ClientBypassRule
//
// x-displayName: "Client Bypass Rule"
// Client source rule specifies the sources to be trusted
type ClientBypassRule struct {
	// metadata
	//
	// x-displayName: "Metadata"
	// x-required
	// Common attributes for the rule including name and description.
	Metadata *schema.MessageMetaType `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Client Identifier
	//
	// x-displayName: "Client Identifier"
	// x-required
	// Client identifier that should be used for the client rule
	//
	// Types that are valid to be assigned to ClientSourceChoice:
	//	*ClientBypassRule_IpPrefix
	//	*ClientBypassRule_HttpHeader
	ClientSourceChoice isClientBypassRule_ClientSourceChoice `protobuf_oneof:"client_source_choice"`
}

func (m *ClientBypassRule) Reset()      { *m = ClientBypassRule{} }
func (*ClientBypassRule) ProtoMessage() {}
func (*ClientBypassRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{1}
}
func (m *ClientBypassRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientBypassRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ClientBypassRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientBypassRule.Merge(m, src)
}
func (m *ClientBypassRule) XXX_Size() int {
	return m.Size()
}
func (m *ClientBypassRule) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientBypassRule.DiscardUnknown(m)
}

var xxx_messageInfo_ClientBypassRule proto.InternalMessageInfo

type isClientBypassRule_ClientSourceChoice interface {
	isClientBypassRule_ClientSourceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientBypassRule_IpPrefix struct {
	IpPrefix string `protobuf:"bytes,4,opt,name=ip_prefix,json=ipPrefix,proto3,oneof" json:"ip_prefix,omitempty"`
}
type ClientBypassRule_HttpHeader struct {
	HttpHeader *HttpHeaderMatcherList `protobuf:"bytes,5,opt,name=http_header,json=httpHeader,proto3,oneof" json:"http_header,omitempty"`
}

func (*ClientBypassRule_IpPrefix) isClientBypassRule_ClientSourceChoice()   {}
func (*ClientBypassRule_HttpHeader) isClientBypassRule_ClientSourceChoice() {}

func (m *ClientBypassRule) GetClientSourceChoice() isClientBypassRule_ClientSourceChoice {
	if m != nil {
		return m.ClientSourceChoice
	}
	return nil
}

func (m *ClientBypassRule) GetMetadata() *schema.MessageMetaType {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *ClientBypassRule) GetIpPrefix() string {
	if x, ok := m.GetClientSourceChoice().(*ClientBypassRule_IpPrefix); ok {
		return x.IpPrefix
	}
	return ""
}

func (m *ClientBypassRule) GetHttpHeader() *HttpHeaderMatcherList {
	if x, ok := m.GetClientSourceChoice().(*ClientBypassRule_HttpHeader); ok {
		return x.HttpHeader
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ClientBypassRule) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ClientBypassRule_IpPrefix)(nil),
		(*ClientBypassRule_HttpHeader)(nil),
	}
}

// HeaderMatcherType
//
// x-displayName: "Header To Match"
// Header match is done using the name of the header and its value.
// The value match is done using one of the following
//
//	regex match on value
//	exact match of value
//	presence of header
type HeaderMatcherType struct {
	// name
	//
	// x-displayName: "Name"
	// x-required
	// x-example: "Content-Type"
	// Name of the header
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// value_match
	//
	// x-displayName: "Value"
	// The variants of matching a header value
	//
	// Types that are valid to be assigned to ValueMatch:
	//	*HeaderMatcherType_Exact
	//	*HeaderMatcherType_Regex
	ValueMatch isHeaderMatcherType_ValueMatch `protobuf_oneof:"value_match"`
}

func (m *HeaderMatcherType) Reset()      { *m = HeaderMatcherType{} }
func (*HeaderMatcherType) ProtoMessage() {}
func (*HeaderMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{2}
}
func (m *HeaderMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeaderMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HeaderMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderMatcherType.Merge(m, src)
}
func (m *HeaderMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *HeaderMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderMatcherType proto.InternalMessageInfo

type isHeaderMatcherType_ValueMatch interface {
	isHeaderMatcherType_ValueMatch()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HeaderMatcherType_Exact struct {
	Exact string `protobuf:"bytes,2,opt,name=exact,proto3,oneof" json:"exact,omitempty"`
}
type HeaderMatcherType_Regex struct {
	Regex string `protobuf:"bytes,3,opt,name=regex,proto3,oneof" json:"regex,omitempty"`
}

func (*HeaderMatcherType_Exact) isHeaderMatcherType_ValueMatch() {}
func (*HeaderMatcherType_Regex) isHeaderMatcherType_ValueMatch() {}

func (m *HeaderMatcherType) GetValueMatch() isHeaderMatcherType_ValueMatch {
	if m != nil {
		return m.ValueMatch
	}
	return nil
}

func (m *HeaderMatcherType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeaderMatcherType) GetExact() string {
	if x, ok := m.GetValueMatch().(*HeaderMatcherType_Exact); ok {
		return x.Exact
	}
	return ""
}

func (m *HeaderMatcherType) GetRegex() string {
	if x, ok := m.GetValueMatch().(*HeaderMatcherType_Regex); ok {
		return x.Regex
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HeaderMatcherType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HeaderMatcherType_Exact)(nil),
		(*HeaderMatcherType_Regex)(nil),
	}
}

// HTTP Header
//
// x-displayName: "HTTP Header"
// Request header name and value pairs
type HttpHeaderMatcherList struct {
	// headers
	//
	// x-displayName: "HTTP Headers"
	// x-required
	// List of HTTP header name and value pairs
	Headers []*HeaderMatcherType `protobuf:"bytes,1,rep,name=headers,proto3" json:"headers,omitempty"`
}

func (m *HttpHeaderMatcherList) Reset()      { *m = HttpHeaderMatcherList{} }
func (*HttpHeaderMatcherList) ProtoMessage() {}
func (*HttpHeaderMatcherList) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{3}
}
func (m *HttpHeaderMatcherList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpHeaderMatcherList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HttpHeaderMatcherList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpHeaderMatcherList.Merge(m, src)
}
func (m *HttpHeaderMatcherList) XXX_Size() int {
	return m.Size()
}
func (m *HttpHeaderMatcherList) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpHeaderMatcherList.DiscardUnknown(m)
}

var xxx_messageInfo_HttpHeaderMatcherList proto.InternalMessageInfo

func (m *HttpHeaderMatcherList) GetHeaders() []*HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

// ProtectedEndpointType
//
// x-displayName: "Protected Endpoint"
// Add the name and description for the protected endpoint
type ProtectedEndpointType struct {
	// metadata
	//
	// x-displayName: "Metadata"
	// x-required
	// Add the name and description for the protected endpoint.
	// Name and description are for administrative convenience and do no impact the way the endpoint works
	Metadata *schema.MessageMetaType `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Domain Matcher
	//
	// x-displayName: "Domain Matcher"
	// This defines domain matcher.
	//
	// Types that are valid to be assigned to DomainMatcherChoice:
	//	*ProtectedEndpointType_AnyDomain
	//	*ProtectedEndpointType_Domain
	DomainMatcherChoice isProtectedEndpointType_DomainMatcherChoice `protobuf_oneof:"domain_matcher_choice"`
	// Path
	//
	// x-displayName: "Path"
	// x-required
	// x-example: "/id/1"
	// x-example: "/id/*"
	// x-example: "*login"
	// Accepts wildcards * to match multiple characters or ? to match a single character
	Path string `protobuf:"bytes,5,opt,name=path,proto3" json:"path,omitempty"`
	// Query
	//
	// x-displayName: "Query"
	// x-example: "(^|[^\\w])action=login([^\\w]|$)"
	// Enter a regular expression to match your query parameters of interest
	Query string `protobuf:"bytes,6,opt,name=query,proto3" json:"query,omitempty"`
	// HTTP Methods
	//
	// x-displayName: "HTTP Methods"
	// x-required
	// List of HTTP methods.
	HttpMethods []schema.BotHttpMethod `protobuf:"varint,7,rep,packed,name=http_methods,json=httpMethods,proto3,enum=ves.io.schema.BotHttpMethod" json:"http_methods,omitempty"`
	// Client Type
	//
	// x-displayName: "Client type"
	// x-required
	// Select type of client(s) that will access this endpoint
	//
	// Types that are valid to be assigned to ClientTypeChoice:
	//	*ProtectedEndpointType_WebClient
	//	*ProtectedEndpointType_MobileClient
	//	*ProtectedEndpointType_WebMobileClient
	ClientTypeChoice isProtectedEndpointType_ClientTypeChoice `protobuf_oneof:"client_type_choice"`
	// Flow label
	//
	// x-displayName: "Endpoint Label"
	// Endpoint label category
	//
	// Types that are valid to be assigned to FlowLabelChoice:
	//	*ProtectedEndpointType_UndefinedFlowLabel
	//	*ProtectedEndpointType_FlowLabel
	FlowLabelChoice isProtectedEndpointType_FlowLabelChoice `protobuf_oneof:"flow_label_choice"`
}

func (m *ProtectedEndpointType) Reset()      { *m = ProtectedEndpointType{} }
func (*ProtectedEndpointType) ProtoMessage() {}
func (*ProtectedEndpointType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{4}
}
func (m *ProtectedEndpointType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtectedEndpointType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProtectedEndpointType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtectedEndpointType.Merge(m, src)
}
func (m *ProtectedEndpointType) XXX_Size() int {
	return m.Size()
}
func (m *ProtectedEndpointType) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtectedEndpointType.DiscardUnknown(m)
}

var xxx_messageInfo_ProtectedEndpointType proto.InternalMessageInfo

type isProtectedEndpointType_DomainMatcherChoice interface {
	isProtectedEndpointType_DomainMatcherChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isProtectedEndpointType_ClientTypeChoice interface {
	isProtectedEndpointType_ClientTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isProtectedEndpointType_FlowLabelChoice interface {
	isProtectedEndpointType_FlowLabelChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProtectedEndpointType_AnyDomain struct {
	AnyDomain *schema.Empty `protobuf:"bytes,3,opt,name=any_domain,json=anyDomain,proto3,oneof" json:"any_domain,omitempty"`
}
type ProtectedEndpointType_Domain struct {
	Domain *schema.DomainType `protobuf:"bytes,4,opt,name=domain,proto3,oneof" json:"domain,omitempty"`
}
type ProtectedEndpointType_WebClient struct {
	WebClient *WebClientType `protobuf:"bytes,9,opt,name=web_client,json=webClient,proto3,oneof" json:"web_client,omitempty"`
}
type ProtectedEndpointType_MobileClient struct {
	MobileClient *MobileClientType `protobuf:"bytes,10,opt,name=mobile_client,json=mobileClient,proto3,oneof" json:"mobile_client,omitempty"`
}
type ProtectedEndpointType_WebMobileClient struct {
	WebMobileClient *WebMobileClientType `protobuf:"bytes,11,opt,name=web_mobile_client,json=webMobileClient,proto3,oneof" json:"web_mobile_client,omitempty"`
}
type ProtectedEndpointType_UndefinedFlowLabel struct {
	UndefinedFlowLabel *schema.Empty `protobuf:"bytes,13,opt,name=undefined_flow_label,json=undefinedFlowLabel,proto3,oneof" json:"undefined_flow_label,omitempty"`
}
type ProtectedEndpointType_FlowLabel struct {
	FlowLabel *schema.BotDefenseFlowLabelCategoriesChoiceType `protobuf:"bytes,14,opt,name=flow_label,json=flowLabel,proto3,oneof" json:"flow_label,omitempty"`
}

func (*ProtectedEndpointType_AnyDomain) isProtectedEndpointType_DomainMatcherChoice()      {}
func (*ProtectedEndpointType_Domain) isProtectedEndpointType_DomainMatcherChoice()         {}
func (*ProtectedEndpointType_WebClient) isProtectedEndpointType_ClientTypeChoice()         {}
func (*ProtectedEndpointType_MobileClient) isProtectedEndpointType_ClientTypeChoice()      {}
func (*ProtectedEndpointType_WebMobileClient) isProtectedEndpointType_ClientTypeChoice()   {}
func (*ProtectedEndpointType_UndefinedFlowLabel) isProtectedEndpointType_FlowLabelChoice() {}
func (*ProtectedEndpointType_FlowLabel) isProtectedEndpointType_FlowLabelChoice()          {}

func (m *ProtectedEndpointType) GetDomainMatcherChoice() isProtectedEndpointType_DomainMatcherChoice {
	if m != nil {
		return m.DomainMatcherChoice
	}
	return nil
}
func (m *ProtectedEndpointType) GetClientTypeChoice() isProtectedEndpointType_ClientTypeChoice {
	if m != nil {
		return m.ClientTypeChoice
	}
	return nil
}
func (m *ProtectedEndpointType) GetFlowLabelChoice() isProtectedEndpointType_FlowLabelChoice {
	if m != nil {
		return m.FlowLabelChoice
	}
	return nil
}

func (m *ProtectedEndpointType) GetMetadata() *schema.MessageMetaType {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *ProtectedEndpointType) GetAnyDomain() *schema.Empty {
	if x, ok := m.GetDomainMatcherChoice().(*ProtectedEndpointType_AnyDomain); ok {
		return x.AnyDomain
	}
	return nil
}

func (m *ProtectedEndpointType) GetDomain() *schema.DomainType {
	if x, ok := m.GetDomainMatcherChoice().(*ProtectedEndpointType_Domain); ok {
		return x.Domain
	}
	return nil
}

func (m *ProtectedEndpointType) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ProtectedEndpointType) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *ProtectedEndpointType) GetHttpMethods() []schema.BotHttpMethod {
	if m != nil {
		return m.HttpMethods
	}
	return nil
}

func (m *ProtectedEndpointType) GetWebClient() *WebClientType {
	if x, ok := m.GetClientTypeChoice().(*ProtectedEndpointType_WebClient); ok {
		return x.WebClient
	}
	return nil
}

func (m *ProtectedEndpointType) GetMobileClient() *MobileClientType {
	if x, ok := m.GetClientTypeChoice().(*ProtectedEndpointType_MobileClient); ok {
		return x.MobileClient
	}
	return nil
}

func (m *ProtectedEndpointType) GetWebMobileClient() *WebMobileClientType {
	if x, ok := m.GetClientTypeChoice().(*ProtectedEndpointType_WebMobileClient); ok {
		return x.WebMobileClient
	}
	return nil
}

func (m *ProtectedEndpointType) GetUndefinedFlowLabel() *schema.Empty {
	if x, ok := m.GetFlowLabelChoice().(*ProtectedEndpointType_UndefinedFlowLabel); ok {
		return x.UndefinedFlowLabel
	}
	return nil
}

func (m *ProtectedEndpointType) GetFlowLabel() *schema.BotDefenseFlowLabelCategoriesChoiceType {
	if x, ok := m.GetFlowLabelChoice().(*ProtectedEndpointType_FlowLabel); ok {
		return x.FlowLabel
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ProtectedEndpointType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ProtectedEndpointType_AnyDomain)(nil),
		(*ProtectedEndpointType_Domain)(nil),
		(*ProtectedEndpointType_WebClient)(nil),
		(*ProtectedEndpointType_MobileClient)(nil),
		(*ProtectedEndpointType_WebMobileClient)(nil),
		(*ProtectedEndpointType_UndefinedFlowLabel)(nil),
		(*ProtectedEndpointType_FlowLabel)(nil),
	}
}

// WebClientType
//
// x-displayName: "Web Client"
// Web client configuration options
type WebClientType struct {
	// Bot Traffic Mitigation
	//
	// x-displayName: "Mitigation"
	// x-required
	// This defines mitigation actions to take for bot traffic
	//
	// Types that are valid to be assigned to Mitigation:
	//	*WebClientType_Continue
	//	*WebClientType_Redirect
	//	*WebClientType_Block
	Mitigation isWebClientType_Mitigation `protobuf_oneof:"mitigation"`
}

func (m *WebClientType) Reset()      { *m = WebClientType{} }
func (*WebClientType) ProtoMessage() {}
func (*WebClientType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{5}
}
func (m *WebClientType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebClientType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WebClientType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebClientType.Merge(m, src)
}
func (m *WebClientType) XXX_Size() int {
	return m.Size()
}
func (m *WebClientType) XXX_DiscardUnknown() {
	xxx_messageInfo_WebClientType.DiscardUnknown(m)
}

var xxx_messageInfo_WebClientType proto.InternalMessageInfo

type isWebClientType_Mitigation interface {
	isWebClientType_Mitigation()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type WebClientType_Continue struct {
	Continue *ContinueMitigationChoiceType `protobuf:"bytes,2,opt,name=continue,proto3,oneof" json:"continue,omitempty"`
}
type WebClientType_Redirect struct {
	Redirect *RedirectMitigationChoiceType `protobuf:"bytes,3,opt,name=redirect,proto3,oneof" json:"redirect,omitempty"`
}
type WebClientType_Block struct {
	Block *BlockMitigationChoiceType `protobuf:"bytes,4,opt,name=block,proto3,oneof" json:"block,omitempty"`
}

func (*WebClientType_Continue) isWebClientType_Mitigation() {}
func (*WebClientType_Redirect) isWebClientType_Mitigation() {}
func (*WebClientType_Block) isWebClientType_Mitigation()    {}

func (m *WebClientType) GetMitigation() isWebClientType_Mitigation {
	if m != nil {
		return m.Mitigation
	}
	return nil
}

func (m *WebClientType) GetContinue() *ContinueMitigationChoiceType {
	if x, ok := m.GetMitigation().(*WebClientType_Continue); ok {
		return x.Continue
	}
	return nil
}

func (m *WebClientType) GetRedirect() *RedirectMitigationChoiceType {
	if x, ok := m.GetMitigation().(*WebClientType_Redirect); ok {
		return x.Redirect
	}
	return nil
}

func (m *WebClientType) GetBlock() *BlockMitigationChoiceType {
	if x, ok := m.GetMitigation().(*WebClientType_Block); ok {
		return x.Block
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*WebClientType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*WebClientType_Continue)(nil),
		(*WebClientType_Redirect)(nil),
		(*WebClientType_Block)(nil),
	}
}

// MobileClientType
//
// x-displayName: "Mobile Client"
// Mobile client configuration options
type MobileClientType struct {
	// Bot Traffic Mitigation
	//
	// x-displayName: "Mitigation"
	// x-required
	// This defines mitigation actions to take for bot traffic
	//
	// Types that are valid to be assigned to Mitigation:
	//	*MobileClientType_Continue
	//	*MobileClientType_Block
	Mitigation isMobileClientType_Mitigation `protobuf_oneof:"mitigation"`
}

func (m *MobileClientType) Reset()      { *m = MobileClientType{} }
func (*MobileClientType) ProtoMessage() {}
func (*MobileClientType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{6}
}
func (m *MobileClientType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MobileClientType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MobileClientType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MobileClientType.Merge(m, src)
}
func (m *MobileClientType) XXX_Size() int {
	return m.Size()
}
func (m *MobileClientType) XXX_DiscardUnknown() {
	xxx_messageInfo_MobileClientType.DiscardUnknown(m)
}

var xxx_messageInfo_MobileClientType proto.InternalMessageInfo

type isMobileClientType_Mitigation interface {
	isMobileClientType_Mitigation()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type MobileClientType_Continue struct {
	Continue *ContinueMitigationChoiceType `protobuf:"bytes,2,opt,name=continue,proto3,oneof" json:"continue,omitempty"`
}
type MobileClientType_Block struct {
	Block *BlockMobileMitigationChoiceType `protobuf:"bytes,3,opt,name=block,proto3,oneof" json:"block,omitempty"`
}

func (*MobileClientType_Continue) isMobileClientType_Mitigation() {}
func (*MobileClientType_Block) isMobileClientType_Mitigation()    {}

func (m *MobileClientType) GetMitigation() isMobileClientType_Mitigation {
	if m != nil {
		return m.Mitigation
	}
	return nil
}

func (m *MobileClientType) GetContinue() *ContinueMitigationChoiceType {
	if x, ok := m.GetMitigation().(*MobileClientType_Continue); ok {
		return x.Continue
	}
	return nil
}

func (m *MobileClientType) GetBlock() *BlockMobileMitigationChoiceType {
	if x, ok := m.GetMitigation().(*MobileClientType_Block); ok {
		return x.Block
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MobileClientType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MobileClientType_Continue)(nil),
		(*MobileClientType_Block)(nil),
	}
}

// WebMobileClientType
//
// x-displayName: "Web and Mobile Client"
// Web and Mobile client configuration options
type WebMobileClientType struct {
	// Bot Traffic Mitigation
	//
	// x-displayName: "Mitigation for Web"
	// x-required
	// This defines mitigation actions to take for bot traffic
	//
	// Types that are valid to be assigned to WebMitigation:
	//	*WebMobileClientType_ContinueWeb
	//	*WebMobileClientType_RedirectWeb
	//	*WebMobileClientType_BlockWeb
	WebMitigation isWebMobileClientType_WebMitigation `protobuf_oneof:"web_mitigation"`
	// Bot Traffic Mitigation
	//
	// x-displayName: "Mitigation For Mobile"
	// x-required
	// This defines mitigation actions to take for bot traffic
	//
	// Types that are valid to be assigned to MobileMitigation:
	//	*WebMobileClientType_ContinueMobile
	//	*WebMobileClientType_BlockMobile
	MobileMitigation isWebMobileClientType_MobileMitigation `protobuf_oneof:"mobile_mitigation"`
}

func (m *WebMobileClientType) Reset()      { *m = WebMobileClientType{} }
func (*WebMobileClientType) ProtoMessage() {}
func (*WebMobileClientType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{7}
}
func (m *WebMobileClientType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebMobileClientType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WebMobileClientType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebMobileClientType.Merge(m, src)
}
func (m *WebMobileClientType) XXX_Size() int {
	return m.Size()
}
func (m *WebMobileClientType) XXX_DiscardUnknown() {
	xxx_messageInfo_WebMobileClientType.DiscardUnknown(m)
}

var xxx_messageInfo_WebMobileClientType proto.InternalMessageInfo

type isWebMobileClientType_WebMitigation interface {
	isWebMobileClientType_WebMitigation()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isWebMobileClientType_MobileMitigation interface {
	isWebMobileClientType_MobileMitigation()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type WebMobileClientType_ContinueWeb struct {
	ContinueWeb *ContinueMitigationChoiceType `protobuf:"bytes,2,opt,name=continue_web,json=continueWeb,proto3,oneof" json:"continue_web,omitempty"`
}
type WebMobileClientType_RedirectWeb struct {
	RedirectWeb *RedirectMitigationChoiceType `protobuf:"bytes,3,opt,name=redirect_web,json=redirectWeb,proto3,oneof" json:"redirect_web,omitempty"`
}
type WebMobileClientType_BlockWeb struct {
	BlockWeb *BlockMitigationChoiceType `protobuf:"bytes,4,opt,name=block_web,json=blockWeb,proto3,oneof" json:"block_web,omitempty"`
}
type WebMobileClientType_ContinueMobile struct {
	ContinueMobile *ContinueMitigationChoiceType `protobuf:"bytes,6,opt,name=continue_mobile,json=continueMobile,proto3,oneof" json:"continue_mobile,omitempty"`
}
type WebMobileClientType_BlockMobile struct {
	BlockMobile *BlockMobileMitigationChoiceType `protobuf:"bytes,7,opt,name=block_mobile,json=blockMobile,proto3,oneof" json:"block_mobile,omitempty"`
}

func (*WebMobileClientType_ContinueWeb) isWebMobileClientType_WebMitigation()       {}
func (*WebMobileClientType_RedirectWeb) isWebMobileClientType_WebMitigation()       {}
func (*WebMobileClientType_BlockWeb) isWebMobileClientType_WebMitigation()          {}
func (*WebMobileClientType_ContinueMobile) isWebMobileClientType_MobileMitigation() {}
func (*WebMobileClientType_BlockMobile) isWebMobileClientType_MobileMitigation()    {}

func (m *WebMobileClientType) GetWebMitigation() isWebMobileClientType_WebMitigation {
	if m != nil {
		return m.WebMitigation
	}
	return nil
}
func (m *WebMobileClientType) GetMobileMitigation() isWebMobileClientType_MobileMitigation {
	if m != nil {
		return m.MobileMitigation
	}
	return nil
}

func (m *WebMobileClientType) GetContinueWeb() *ContinueMitigationChoiceType {
	if x, ok := m.GetWebMitigation().(*WebMobileClientType_ContinueWeb); ok {
		return x.ContinueWeb
	}
	return nil
}

func (m *WebMobileClientType) GetRedirectWeb() *RedirectMitigationChoiceType {
	if x, ok := m.GetWebMitigation().(*WebMobileClientType_RedirectWeb); ok {
		return x.RedirectWeb
	}
	return nil
}

func (m *WebMobileClientType) GetBlockWeb() *BlockMitigationChoiceType {
	if x, ok := m.GetWebMitigation().(*WebMobileClientType_BlockWeb); ok {
		return x.BlockWeb
	}
	return nil
}

func (m *WebMobileClientType) GetContinueMobile() *ContinueMitigationChoiceType {
	if x, ok := m.GetMobileMitigation().(*WebMobileClientType_ContinueMobile); ok {
		return x.ContinueMobile
	}
	return nil
}

func (m *WebMobileClientType) GetBlockMobile() *BlockMobileMitigationChoiceType {
	if x, ok := m.GetMobileMitigation().(*WebMobileClientType_BlockMobile); ok {
		return x.BlockMobile
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*WebMobileClientType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*WebMobileClientType_ContinueWeb)(nil),
		(*WebMobileClientType_RedirectWeb)(nil),
		(*WebMobileClientType_BlockWeb)(nil),
		(*WebMobileClientType_ContinueMobile)(nil),
		(*WebMobileClientType_BlockMobile)(nil),
	}
}

// ShapeBotFlagMitigationActionChoiceType
//
// x-displayName: "Select Continue Bot Mitigation Action"
// Continue mitigation action.
type ContinueMitigationChoiceType struct {
	// send_headers_choice
	//
	// x-displayName: "Include Automation Info"
	// Select either to include a header with automation information to the origin
	//
	// Types that are valid to be assigned to AddHeaderChoice:
	//	*ContinueMitigationChoiceType_NoHeader
	//	*ContinueMitigationChoiceType_AddHeader
	AddHeaderChoice isContinueMitigationChoiceType_AddHeaderChoice `protobuf_oneof:"add_header_choice"`
}

func (m *ContinueMitigationChoiceType) Reset()      { *m = ContinueMitigationChoiceType{} }
func (*ContinueMitigationChoiceType) ProtoMessage() {}
func (*ContinueMitigationChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{8}
}
func (m *ContinueMitigationChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContinueMitigationChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ContinueMitigationChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContinueMitigationChoiceType.Merge(m, src)
}
func (m *ContinueMitigationChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *ContinueMitigationChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_ContinueMitigationChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_ContinueMitigationChoiceType proto.InternalMessageInfo

type isContinueMitigationChoiceType_AddHeaderChoice interface {
	isContinueMitigationChoiceType_AddHeaderChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ContinueMitigationChoiceType_NoHeader struct {
	NoHeader *schema.Empty `protobuf:"bytes,2,opt,name=no_header,json=noHeader,proto3,oneof" json:"no_header,omitempty"`
}
type ContinueMitigationChoiceType_AddHeader struct {
	AddHeader *schema.Empty `protobuf:"bytes,3,opt,name=add_header,json=addHeader,proto3,oneof" json:"add_header,omitempty"`
}

func (*ContinueMitigationChoiceType_NoHeader) isContinueMitigationChoiceType_AddHeaderChoice()  {}
func (*ContinueMitigationChoiceType_AddHeader) isContinueMitigationChoiceType_AddHeaderChoice() {}

func (m *ContinueMitigationChoiceType) GetAddHeaderChoice() isContinueMitigationChoiceType_AddHeaderChoice {
	if m != nil {
		return m.AddHeaderChoice
	}
	return nil
}

func (m *ContinueMitigationChoiceType) GetNoHeader() *schema.Empty {
	if x, ok := m.GetAddHeaderChoice().(*ContinueMitigationChoiceType_NoHeader); ok {
		return x.NoHeader
	}
	return nil
}

func (m *ContinueMitigationChoiceType) GetAddHeader() *schema.Empty {
	if x, ok := m.GetAddHeaderChoice().(*ContinueMitigationChoiceType_AddHeader); ok {
		return x.AddHeader
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ContinueMitigationChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ContinueMitigationChoiceType_NoHeader)(nil),
		(*ContinueMitigationChoiceType_AddHeader)(nil),
	}
}

// BlockMitigationChoiceType
//
// x-displayName: "Block Response"
// Block Response.
type BlockMitigationChoiceType struct {
	// Status
	//
	// x-displayName: "Status"
	// x-required
	// HTTP Status code to respond with
	Status schema.HttpStatusCode `protobuf:"varint,2,opt,name=status,proto3,enum=ves.io.schema.HttpStatusCode" json:"status,omitempty"`
	// content_type
	//
	// x-displayName: "Content Type"
	// x-example: "text/html"
	// Content type to use in a block response
	ContentType string `protobuf:"bytes,3,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	// body
	//
	// x-displayName: "Body"
	// x-example: "<p> Your request was blocked </p>"
	// Custom body message
	Body string `protobuf:"bytes,4,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *BlockMitigationChoiceType) Reset()      { *m = BlockMitigationChoiceType{} }
func (*BlockMitigationChoiceType) ProtoMessage() {}
func (*BlockMitigationChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{9}
}
func (m *BlockMitigationChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockMitigationChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BlockMitigationChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockMitigationChoiceType.Merge(m, src)
}
func (m *BlockMitigationChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *BlockMitigationChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockMitigationChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_BlockMitigationChoiceType proto.InternalMessageInfo

func (m *BlockMitigationChoiceType) GetStatus() schema.HttpStatusCode {
	if m != nil {
		return m.Status
	}
	return schema.EmptyStatusCode
}

func (m *BlockMitigationChoiceType) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *BlockMitigationChoiceType) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

// BlockMobileMitigationChoiceType
//
// x-displayName: "Block Response for Mobile"
// Block Response.
type BlockMobileMitigationChoiceType struct {
	// Status
	//
	// x-displayName: "Status"
	// x-required
	// HTTP Status code to respond with
	Status schema.HttpStatusCode `protobuf:"varint,2,opt,name=status,proto3,enum=ves.io.schema.HttpStatusCode" json:"status,omitempty"`
	// content_type
	//
	// x-displayName: "Content Type"
	// x-example: "text/html"
	// Content type to use in a block response
	ContentType string `protobuf:"bytes,3,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	// body
	//
	// x-displayName: "Body"
	// x-example: "<p> Your request was blocked </p>"
	// Custom body message
	Body string `protobuf:"bytes,4,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *BlockMobileMitigationChoiceType) Reset()      { *m = BlockMobileMitigationChoiceType{} }
func (*BlockMobileMitigationChoiceType) ProtoMessage() {}
func (*BlockMobileMitigationChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{10}
}
func (m *BlockMobileMitigationChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockMobileMitigationChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BlockMobileMitigationChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockMobileMitigationChoiceType.Merge(m, src)
}
func (m *BlockMobileMitigationChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *BlockMobileMitigationChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockMobileMitigationChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_BlockMobileMitigationChoiceType proto.InternalMessageInfo

func (m *BlockMobileMitigationChoiceType) GetStatus() schema.HttpStatusCode {
	if m != nil {
		return m.Status
	}
	return schema.EmptyStatusCode
}

func (m *BlockMobileMitigationChoiceType) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *BlockMobileMitigationChoiceType) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

// RedirectMitigationChoiceType
//
// x-displayName: "Redirect"
// Redirect.
type RedirectMitigationChoiceType struct {
	// Status
	//
	// x-displayName: "Status"
	// x-required
	// HTTP Status code to respond with
	Status schema.HttpStatusCode `protobuf:"varint,1,opt,name=status,proto3,enum=ves.io.schema.HttpStatusCode" json:"status,omitempty"`
	// URI
	//
	// x-displayName: "Location"
	// x-example: "https://example.com/landing/page"
	// x-example: "/not-found"
	// x-required
	// URI location for redirect reponse
	Location string `protobuf:"bytes,2,opt,name=location,proto3" json:"location,omitempty"`
}

func (m *RedirectMitigationChoiceType) Reset()      { *m = RedirectMitigationChoiceType{} }
func (*RedirectMitigationChoiceType) ProtoMessage() {}
func (*RedirectMitigationChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{11}
}
func (m *RedirectMitigationChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedirectMitigationChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RedirectMitigationChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedirectMitigationChoiceType.Merge(m, src)
}
func (m *RedirectMitigationChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *RedirectMitigationChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_RedirectMitigationChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_RedirectMitigationChoiceType proto.InternalMessageInfo

func (m *RedirectMitigationChoiceType) GetStatus() schema.HttpStatusCode {
	if m != nil {
		return m.Status
	}
	return schema.EmptyStatusCode
}

func (m *RedirectMitigationChoiceType) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

// JavaScriptInsertType
//
// x-displayName: "JavaScript Custom Insertion Rules"
// This defines custom JavaScript insertion rules for Bot Defense Policy.
type JavaScriptInsertType struct {
	// js_download_path
	//
	// x-displayName: "Web Client JavaScript Path"
	// x-example: "/common.js"
	// Web client will fetch F5 Client Java Script from this path.
	// This path must not conflict with any other website/application paths.
	//
	// If not specified, default to ‘/common.js’.
	JsDownloadPath string `protobuf:"bytes,5,opt,name=js_download_path,json=jsDownloadPath,proto3" json:"js_download_path,omitempty"`
	// javascript_mode
	//
	// x-displayName: "Web Client JavaScript Mode"
	// x-required
	// Determine the mode in which the JavaScript is loaded into the entry page.
	// The JavaScript is split into 2 chunks.
	// The larger chunk can be loaded asynchronously or synchronously. It can also be cacheable or non-cacheable on the browser.
	JavascriptMode JavaScriptMode `protobuf:"varint,6,opt,name=javascript_mode,json=javascriptMode,proto3,enum=ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptMode" json:"javascript_mode,omitempty"`
	// javascript_location
	//
	// x-displayName: "JavaScript Location"
	// x-required
	// Defines where to insert Bot Defense JavaScript in HTML page.
	JavascriptLocation JavaScriptLocation `protobuf:"varint,4,opt,name=javascript_location,json=javascriptLocation,proto3,enum=ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptLocation" json:"javascript_location,omitempty"`
	// rules
	//
	// x-displayName: "JavaScript Insertion Paths"
	// x-required
	// Required list of pages to insert Bot Defense client JavaScript.
	Rules []*JavaScriptInsertionRule `protobuf:"bytes,2,rep,name=rules,proto3" json:"rules,omitempty"`
	// exclude_list
	//
	// x-displayName: "JavaScript Exclude Paths"
	// Optional JavaScript insertions exclude list of domain and path matchers.
	ExcludeList []*JavaScriptExclusionRule `protobuf:"bytes,3,rep,name=exclude_list,json=excludeList,proto3" json:"exclude_list,omitempty"`
}

func (m *JavaScriptInsertType) Reset()      { *m = JavaScriptInsertType{} }
func (*JavaScriptInsertType) ProtoMessage() {}
func (*JavaScriptInsertType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{12}
}
func (m *JavaScriptInsertType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JavaScriptInsertType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JavaScriptInsertType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JavaScriptInsertType.Merge(m, src)
}
func (m *JavaScriptInsertType) XXX_Size() int {
	return m.Size()
}
func (m *JavaScriptInsertType) XXX_DiscardUnknown() {
	xxx_messageInfo_JavaScriptInsertType.DiscardUnknown(m)
}

var xxx_messageInfo_JavaScriptInsertType proto.InternalMessageInfo

func (m *JavaScriptInsertType) GetJsDownloadPath() string {
	if m != nil {
		return m.JsDownloadPath
	}
	return ""
}

func (m *JavaScriptInsertType) GetJavascriptMode() JavaScriptMode {
	if m != nil {
		return m.JavascriptMode
	}
	return ASYNC_JS_NO_CACHING
}

func (m *JavaScriptInsertType) GetJavascriptLocation() JavaScriptLocation {
	if m != nil {
		return m.JavascriptLocation
	}
	return JAVA_SCRIPT_LOCATION_UNDEFINED
}

func (m *JavaScriptInsertType) GetRules() []*JavaScriptInsertionRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *JavaScriptInsertType) GetExcludeList() []*JavaScriptExclusionRule {
	if m != nil {
		return m.ExcludeList
	}
	return nil
}

// JavaScriptInsertAllWithExceptionsType
//
// x-displayName: "Insert JavaScript In All Pages With The Exceptions"
// Insert Bot Defense JavaScript in all pages  with the exceptions
type JavaScriptInsertAllWithExceptionsType struct {
	// js_download_path
	//
	// x-displayName: "Web Client JavaScript Path"
	// x-example: "/common.js"
	// Web client will fetch F5 Client Java Script from this path.
	// This path must not conflict with any other website/application paths.
	//
	// If not specified, default to ‘/common.js’.
	JsDownloadPath string `protobuf:"bytes,5,opt,name=js_download_path,json=jsDownloadPath,proto3" json:"js_download_path,omitempty"`
	// javascript_location
	//
	// x-displayName: "JavaScript Location"
	// Defines where to insert Bot Defense JavaScript in HTML page.
	JavascriptLocation JavaScriptLocation `protobuf:"varint,1,opt,name=javascript_location,json=javascriptLocation,proto3,enum=ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptLocation" json:"javascript_location,omitempty"`
	// exclude_list
	//
	// x-displayName: "Exclude Pages"
	// Optional JavaScript insertions exclude list of domain and path matchers.
	ExcludeList []*JavaScriptExclusionRule `protobuf:"bytes,2,rep,name=exclude_list,json=excludeList,proto3" json:"exclude_list,omitempty"`
}

func (m *JavaScriptInsertAllWithExceptionsType) Reset()      { *m = JavaScriptInsertAllWithExceptionsType{} }
func (*JavaScriptInsertAllWithExceptionsType) ProtoMessage() {}
func (*JavaScriptInsertAllWithExceptionsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{13}
}
func (m *JavaScriptInsertAllWithExceptionsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JavaScriptInsertAllWithExceptionsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JavaScriptInsertAllWithExceptionsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JavaScriptInsertAllWithExceptionsType.Merge(m, src)
}
func (m *JavaScriptInsertAllWithExceptionsType) XXX_Size() int {
	return m.Size()
}
func (m *JavaScriptInsertAllWithExceptionsType) XXX_DiscardUnknown() {
	xxx_messageInfo_JavaScriptInsertAllWithExceptionsType.DiscardUnknown(m)
}

var xxx_messageInfo_JavaScriptInsertAllWithExceptionsType proto.InternalMessageInfo

func (m *JavaScriptInsertAllWithExceptionsType) GetJsDownloadPath() string {
	if m != nil {
		return m.JsDownloadPath
	}
	return ""
}

func (m *JavaScriptInsertAllWithExceptionsType) GetJavascriptLocation() JavaScriptLocation {
	if m != nil {
		return m.JavascriptLocation
	}
	return JAVA_SCRIPT_LOCATION_UNDEFINED
}

func (m *JavaScriptInsertAllWithExceptionsType) GetExcludeList() []*JavaScriptExclusionRule {
	if m != nil {
		return m.ExcludeList
	}
	return nil
}

// manual_js_insert
//
// x-displayName: "Insert JavaScript Manually"
// Insert JavaScript manually
type JavaScriptInsertManualType struct {
	// javascript_mode
	//
	// x-displayName: "Web Client JavaScript Mode"
	// x-required
	// Determine the mode in which the JavaScript is loaded into the entry page.
	// The JavaScript is split into 2 chunks.
	// The larger chunk can be loaded asynchronously or synchronously. It can also be cacheable or non-cacheable on the browser.
	JavascriptMode JavaScriptMode `protobuf:"varint,2,opt,name=javascript_mode,json=javascriptMode,proto3,enum=ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptMode" json:"javascript_mode,omitempty"`
	// js_download_path
	//
	// x-displayName: "Web Client JavaScript Path"
	// x-example: "/common.js"
	// Web client will fetch F5 Client Java Script from this path.
	// This path must not conflict with any other website/application paths.
	//
	// If not specified, default to ‘/common.js’.
	JsDownloadPath string `protobuf:"bytes,1,opt,name=js_download_path,json=jsDownloadPath,proto3" json:"js_download_path,omitempty"`
}

func (m *JavaScriptInsertManualType) Reset()      { *m = JavaScriptInsertManualType{} }
func (*JavaScriptInsertManualType) ProtoMessage() {}
func (*JavaScriptInsertManualType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{14}
}
func (m *JavaScriptInsertManualType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JavaScriptInsertManualType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JavaScriptInsertManualType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JavaScriptInsertManualType.Merge(m, src)
}
func (m *JavaScriptInsertManualType) XXX_Size() int {
	return m.Size()
}
func (m *JavaScriptInsertManualType) XXX_DiscardUnknown() {
	xxx_messageInfo_JavaScriptInsertManualType.DiscardUnknown(m)
}

var xxx_messageInfo_JavaScriptInsertManualType proto.InternalMessageInfo

func (m *JavaScriptInsertManualType) GetJavascriptMode() JavaScriptMode {
	if m != nil {
		return m.JavascriptMode
	}
	return ASYNC_JS_NO_CACHING
}

func (m *JavaScriptInsertManualType) GetJsDownloadPath() string {
	if m != nil {
		return m.JsDownloadPath
	}
	return ""
}

// JavaScriptInsertAllType
//
// x-displayName: "Insert Bot Defense JavaScript In All Pages"
// Insert Bot Defense JavaScript in all pages
type JavaScriptInsertAllType struct {
	// js_download_path
	//
	// x-displayName: "Web Client JavaScript Path"
	// x-example: "/common.js"
	// Web client will fetch F5 Client Java Script from this path.
	// This path must not conflict with any other website/application paths.
	//
	// If not specified, default to ‘/common.js’.
	JsDownloadPath string `protobuf:"bytes,5,opt,name=js_download_path,json=jsDownloadPath,proto3" json:"js_download_path,omitempty"`
	// javascript_location
	//
	// x-displayName: "JavaScript Location"
	// Defines where to insert Bot Defense JavaScript in HTML page.
	JavascriptLocation JavaScriptLocation `protobuf:"varint,1,opt,name=javascript_location,json=javascriptLocation,proto3,enum=ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptLocation" json:"javascript_location,omitempty"`
}

func (m *JavaScriptInsertAllType) Reset()      { *m = JavaScriptInsertAllType{} }
func (*JavaScriptInsertAllType) ProtoMessage() {}
func (*JavaScriptInsertAllType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{15}
}
func (m *JavaScriptInsertAllType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JavaScriptInsertAllType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JavaScriptInsertAllType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JavaScriptInsertAllType.Merge(m, src)
}
func (m *JavaScriptInsertAllType) XXX_Size() int {
	return m.Size()
}
func (m *JavaScriptInsertAllType) XXX_DiscardUnknown() {
	xxx_messageInfo_JavaScriptInsertAllType.DiscardUnknown(m)
}

var xxx_messageInfo_JavaScriptInsertAllType proto.InternalMessageInfo

func (m *JavaScriptInsertAllType) GetJsDownloadPath() string {
	if m != nil {
		return m.JsDownloadPath
	}
	return ""
}

func (m *JavaScriptInsertAllType) GetJavascriptLocation() JavaScriptLocation {
	if m != nil {
		return m.JavascriptLocation
	}
	return JAVA_SCRIPT_LOCATION_UNDEFINED
}

// JavaScriptInsertionRule
//
// x-displayName: "JavaScript Insertion Rule"
// This defines a rule for Bot Defense JavaScript insertion.
type JavaScriptInsertionRule struct {
	// metadata
	//
	// x-displayName: "Metadata"
	// x-required
	// Common attributes for the rule including name and description.
	Metadata *schema.MessageMetaType `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Domain Matcher
	//
	// x-displayName: "Domain Matcher"
	// x-required
	// This defines domain matcher.
	//
	// Types that are valid to be assigned to DomainMatcherChoice:
	//	*JavaScriptInsertionRule_AnyDomain
	//	*JavaScriptInsertionRule_Domain
	DomainMatcherChoice isJavaScriptInsertionRule_DomainMatcherChoice `protobuf_oneof:"domain_matcher_choice"`
	// Path
	//
	// x-displayName: "Path"
	// x-example: "/id/1"
	// x-example: "/id/*"
	// x-example: "*login"
	// Accepts wildcards * to match multiple characters or ? to match a single character
	Path string `protobuf:"bytes,6,opt,name=path,proto3" json:"path,omitempty"` // Deprecated: Do not use.
	// Path
	//
	// x-displayName: "Path"
	// x-required
	// URI path matcher.
	//
	// Types that are valid to be assigned to UriPath:
	//	*JavaScriptInsertionRule_Prefix
	//	*JavaScriptInsertionRule_ExactPath
	//	*JavaScriptInsertionRule_Glob
	UriPath isJavaScriptInsertionRule_UriPath `protobuf_oneof:"uri_path"`
}

func (m *JavaScriptInsertionRule) Reset()      { *m = JavaScriptInsertionRule{} }
func (*JavaScriptInsertionRule) ProtoMessage() {}
func (*JavaScriptInsertionRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{16}
}
func (m *JavaScriptInsertionRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JavaScriptInsertionRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JavaScriptInsertionRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JavaScriptInsertionRule.Merge(m, src)
}
func (m *JavaScriptInsertionRule) XXX_Size() int {
	return m.Size()
}
func (m *JavaScriptInsertionRule) XXX_DiscardUnknown() {
	xxx_messageInfo_JavaScriptInsertionRule.DiscardUnknown(m)
}

var xxx_messageInfo_JavaScriptInsertionRule proto.InternalMessageInfo

type isJavaScriptInsertionRule_DomainMatcherChoice interface {
	isJavaScriptInsertionRule_DomainMatcherChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isJavaScriptInsertionRule_UriPath interface {
	isJavaScriptInsertionRule_UriPath()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type JavaScriptInsertionRule_AnyDomain struct {
	AnyDomain *schema.Empty `protobuf:"bytes,3,opt,name=any_domain,json=anyDomain,proto3,oneof" json:"any_domain,omitempty"`
}
type JavaScriptInsertionRule_Domain struct {
	Domain *schema.DomainType `protobuf:"bytes,4,opt,name=domain,proto3,oneof" json:"domain,omitempty"`
}
type JavaScriptInsertionRule_Prefix struct {
	Prefix string `protobuf:"bytes,8,opt,name=prefix,proto3,oneof" json:"prefix,omitempty"`
}
type JavaScriptInsertionRule_ExactPath struct {
	ExactPath string `protobuf:"bytes,9,opt,name=exact_path,json=exactPath,proto3,oneof" json:"exact_path,omitempty"`
}
type JavaScriptInsertionRule_Glob struct {
	Glob string `protobuf:"bytes,10,opt,name=glob,proto3,oneof" json:"glob,omitempty"`
}

func (*JavaScriptInsertionRule_AnyDomain) isJavaScriptInsertionRule_DomainMatcherChoice() {}
func (*JavaScriptInsertionRule_Domain) isJavaScriptInsertionRule_DomainMatcherChoice()    {}
func (*JavaScriptInsertionRule_Prefix) isJavaScriptInsertionRule_UriPath()                {}
func (*JavaScriptInsertionRule_ExactPath) isJavaScriptInsertionRule_UriPath()             {}
func (*JavaScriptInsertionRule_Glob) isJavaScriptInsertionRule_UriPath()                  {}

func (m *JavaScriptInsertionRule) GetDomainMatcherChoice() isJavaScriptInsertionRule_DomainMatcherChoice {
	if m != nil {
		return m.DomainMatcherChoice
	}
	return nil
}
func (m *JavaScriptInsertionRule) GetUriPath() isJavaScriptInsertionRule_UriPath {
	if m != nil {
		return m.UriPath
	}
	return nil
}

func (m *JavaScriptInsertionRule) GetMetadata() *schema.MessageMetaType {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *JavaScriptInsertionRule) GetAnyDomain() *schema.Empty {
	if x, ok := m.GetDomainMatcherChoice().(*JavaScriptInsertionRule_AnyDomain); ok {
		return x.AnyDomain
	}
	return nil
}

func (m *JavaScriptInsertionRule) GetDomain() *schema.DomainType {
	if x, ok := m.GetDomainMatcherChoice().(*JavaScriptInsertionRule_Domain); ok {
		return x.Domain
	}
	return nil
}

// Deprecated: Do not use.
func (m *JavaScriptInsertionRule) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *JavaScriptInsertionRule) GetPrefix() string {
	if x, ok := m.GetUriPath().(*JavaScriptInsertionRule_Prefix); ok {
		return x.Prefix
	}
	return ""
}

func (m *JavaScriptInsertionRule) GetExactPath() string {
	if x, ok := m.GetUriPath().(*JavaScriptInsertionRule_ExactPath); ok {
		return x.ExactPath
	}
	return ""
}

func (m *JavaScriptInsertionRule) GetGlob() string {
	if x, ok := m.GetUriPath().(*JavaScriptInsertionRule_Glob); ok {
		return x.Glob
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*JavaScriptInsertionRule) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*JavaScriptInsertionRule_AnyDomain)(nil),
		(*JavaScriptInsertionRule_Domain)(nil),
		(*JavaScriptInsertionRule_Prefix)(nil),
		(*JavaScriptInsertionRule_ExactPath)(nil),
		(*JavaScriptInsertionRule_Glob)(nil),
	}
}

// JavaScriptExclusionRule
//
// x-displayName: "JavaScript Insertion Exclusion Rule"
// Define JavaScript insertion exclusion rule
type JavaScriptExclusionRule struct {
	// metadata
	//
	// x-displayName: "Metadata"
	// x-required
	// Common attributes for the rule including name and description.
	Metadata *schema.MessageMetaType `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Domain Matcher
	//
	// x-displayName: "Domain Matcher"
	// x-required
	// This defines domain matcher.
	//
	// Types that are valid to be assigned to DomainMatcherChoice:
	//	*JavaScriptExclusionRule_AnyDomain
	//	*JavaScriptExclusionRule_Domain
	DomainMatcherChoice isJavaScriptExclusionRule_DomainMatcherChoice `protobuf_oneof:"domain_matcher_choice"`
	// Path
	//
	// x-displayName: "Path"
	// x-required
	// URI path matcher.
	Path *schema.PathMatcherType `protobuf:"bytes,5,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *JavaScriptExclusionRule) Reset()      { *m = JavaScriptExclusionRule{} }
func (*JavaScriptExclusionRule) ProtoMessage() {}
func (*JavaScriptExclusionRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{17}
}
func (m *JavaScriptExclusionRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JavaScriptExclusionRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JavaScriptExclusionRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JavaScriptExclusionRule.Merge(m, src)
}
func (m *JavaScriptExclusionRule) XXX_Size() int {
	return m.Size()
}
func (m *JavaScriptExclusionRule) XXX_DiscardUnknown() {
	xxx_messageInfo_JavaScriptExclusionRule.DiscardUnknown(m)
}

var xxx_messageInfo_JavaScriptExclusionRule proto.InternalMessageInfo

type isJavaScriptExclusionRule_DomainMatcherChoice interface {
	isJavaScriptExclusionRule_DomainMatcherChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type JavaScriptExclusionRule_AnyDomain struct {
	AnyDomain *schema.Empty `protobuf:"bytes,3,opt,name=any_domain,json=anyDomain,proto3,oneof" json:"any_domain,omitempty"`
}
type JavaScriptExclusionRule_Domain struct {
	Domain *schema.DomainType `protobuf:"bytes,4,opt,name=domain,proto3,oneof" json:"domain,omitempty"`
}

func (*JavaScriptExclusionRule_AnyDomain) isJavaScriptExclusionRule_DomainMatcherChoice() {}
func (*JavaScriptExclusionRule_Domain) isJavaScriptExclusionRule_DomainMatcherChoice()    {}

func (m *JavaScriptExclusionRule) GetDomainMatcherChoice() isJavaScriptExclusionRule_DomainMatcherChoice {
	if m != nil {
		return m.DomainMatcherChoice
	}
	return nil
}

func (m *JavaScriptExclusionRule) GetMetadata() *schema.MessageMetaType {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *JavaScriptExclusionRule) GetAnyDomain() *schema.Empty {
	if x, ok := m.GetDomainMatcherChoice().(*JavaScriptExclusionRule_AnyDomain); ok {
		return x.AnyDomain
	}
	return nil
}

func (m *JavaScriptExclusionRule) GetDomain() *schema.DomainType {
	if x, ok := m.GetDomainMatcherChoice().(*JavaScriptExclusionRule_Domain); ok {
		return x.Domain
	}
	return nil
}

func (m *JavaScriptExclusionRule) GetPath() *schema.PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*JavaScriptExclusionRule) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*JavaScriptExclusionRule_AnyDomain)(nil),
		(*JavaScriptExclusionRule_Domain)(nil),
	}
}

// MobileSDKConfigType
//
// x-displayName: "Mobile SDK Configuration"
// Mobile SDK configuration.
type MobileSDKConfigType struct {
	// Mobile Traffic Identifier Type
	//
	// x-displayName: "Mobile Request Identifier"
	// Provide Header(s) name-value pair to distinguish native mobile app endpoints from web endpoints.
	// To be used if web and native mobile app endpoints share same FQDN and URL path.
	MobileIdentifier *MobileTrafficIdentifierType `protobuf:"bytes,1,opt,name=mobile_identifier,json=mobileIdentifier,proto3" json:"mobile_identifier,omitempty"`
}

func (m *MobileSDKConfigType) Reset()      { *m = MobileSDKConfigType{} }
func (*MobileSDKConfigType) ProtoMessage() {}
func (*MobileSDKConfigType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{18}
}
func (m *MobileSDKConfigType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MobileSDKConfigType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MobileSDKConfigType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MobileSDKConfigType.Merge(m, src)
}
func (m *MobileSDKConfigType) XXX_Size() int {
	return m.Size()
}
func (m *MobileSDKConfigType) XXX_DiscardUnknown() {
	xxx_messageInfo_MobileSDKConfigType.DiscardUnknown(m)
}

var xxx_messageInfo_MobileSDKConfigType proto.InternalMessageInfo

func (m *MobileSDKConfigType) GetMobileIdentifier() *MobileTrafficIdentifierType {
	if m != nil {
		return m.MobileIdentifier
	}
	return nil
}

// MobileTrafficIdentifierType
//
// x-displayName: "Mobile Traffic Identifier"
// Mobile traffic identifier type.
type MobileTrafficIdentifierType struct {
	// Mobile headers
	//
	// x-displayName: "Mobile Request Identifier Headers"
	// A list of headers that can be used to identify mobile traffic.
	Headers []*HeaderMatcherType `protobuf:"bytes,1,rep,name=headers,proto3" json:"headers,omitempty"`
}

func (m *MobileTrafficIdentifierType) Reset()      { *m = MobileTrafficIdentifierType{} }
func (*MobileTrafficIdentifierType) ProtoMessage() {}
func (*MobileTrafficIdentifierType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{19}
}
func (m *MobileTrafficIdentifierType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MobileTrafficIdentifierType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MobileTrafficIdentifierType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MobileTrafficIdentifierType.Merge(m, src)
}
func (m *MobileTrafficIdentifierType) XXX_Size() int {
	return m.Size()
}
func (m *MobileTrafficIdentifierType) XXX_DiscardUnknown() {
	xxx_messageInfo_MobileTrafficIdentifierType.DiscardUnknown(m)
}

var xxx_messageInfo_MobileTrafficIdentifierType proto.InternalMessageInfo

func (m *MobileTrafficIdentifierType) GetHeaders() []*HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

// DistributionTagList
//
// x-displayName: "Distribution Tag List"
// CloudFront distribution tag list
type DistributionTagList struct {
	// tags
	//
	// x-displayName: "Tags"
	// x-example: "{"env": ".*"}"
	// x-required
	// List contains the Cloudfront distribution selection by tags
	// key is a AWS tag name, and the value is regular expression to match
	Tags map[string]string `protobuf:"bytes,1,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *DistributionTagList) Reset()      { *m = DistributionTagList{} }
func (*DistributionTagList) ProtoMessage() {}
func (*DistributionTagList) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{20}
}
func (m *DistributionTagList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DistributionTagList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DistributionTagList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DistributionTagList.Merge(m, src)
}
func (m *DistributionTagList) XXX_Size() int {
	return m.Size()
}
func (m *DistributionTagList) XXX_DiscardUnknown() {
	xxx_messageInfo_DistributionTagList.DiscardUnknown(m)
}

var xxx_messageInfo_DistributionTagList proto.InternalMessageInfo

func (m *DistributionTagList) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// DistributionIDList
//
// x-displayName: "ID List"
// x-example: "ABCDEFGHI0JKLM"
// List of CloudFront distributions
type DistributionIDList struct {
	// ids
	//
	// x-displayName: "ID"
	// x-example: "ABCDEFGHI0JKLM"
	// x-required
	// Add AWS CloudFront distribution ID, e.g. ABCDEFGHI0JKLM
	Ids []string `protobuf:"bytes,2,rep,name=ids,proto3" json:"ids,omitempty"`
}

func (m *DistributionIDList) Reset()      { *m = DistributionIDList{} }
func (*DistributionIDList) ProtoMessage() {}
func (*DistributionIDList) Descriptor() ([]byte, []int) {
	return fileDescriptor_a98a494ad7678110, []int{21}
}
func (m *DistributionIDList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DistributionIDList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DistributionIDList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DistributionIDList.Merge(m, src)
}
func (m *DistributionIDList) XXX_Size() int {
	return m.Size()
}
func (m *DistributionIDList) XXX_DiscardUnknown() {
	xxx_messageInfo_DistributionIDList.DiscardUnknown(m)
}

var xxx_messageInfo_DistributionIDList proto.InternalMessageInfo

func (m *DistributionIDList) GetIds() []string {
	if m != nil {
		return m.Ids
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.shape.bot_defense.protected_application.cloudfront.LogLevel", LogLevel_name, LogLevel_value)
	golang_proto.RegisterEnum("ves.io.schema.shape.bot_defense.protected_application.cloudfront.LogLevel", LogLevel_name, LogLevel_value)
	proto.RegisterEnum("ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptMode", JavaScriptMode_name, JavaScriptMode_value)
	golang_proto.RegisterEnum("ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptMode", JavaScriptMode_name, JavaScriptMode_value)
	proto.RegisterEnum("ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptLocation", JavaScriptLocation_name, JavaScriptLocation_value)
	golang_proto.RegisterEnum("ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptLocation", JavaScriptLocation_name, JavaScriptLocation_value)
	proto.RegisterType((*CloudfrontType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.CloudfrontType")
	golang_proto.RegisterType((*CloudfrontType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.CloudfrontType")
	proto.RegisterType((*ClientBypassRule)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.ClientBypassRule")
	golang_proto.RegisterType((*ClientBypassRule)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.ClientBypassRule")
	proto.RegisterType((*HeaderMatcherType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.HeaderMatcherType")
	golang_proto.RegisterType((*HeaderMatcherType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.HeaderMatcherType")
	proto.RegisterType((*HttpHeaderMatcherList)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.HttpHeaderMatcherList")
	golang_proto.RegisterType((*HttpHeaderMatcherList)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.HttpHeaderMatcherList")
	proto.RegisterType((*ProtectedEndpointType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.ProtectedEndpointType")
	golang_proto.RegisterType((*ProtectedEndpointType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.ProtectedEndpointType")
	proto.RegisterType((*WebClientType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.WebClientType")
	golang_proto.RegisterType((*WebClientType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.WebClientType")
	proto.RegisterType((*MobileClientType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.MobileClientType")
	golang_proto.RegisterType((*MobileClientType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.MobileClientType")
	proto.RegisterType((*WebMobileClientType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.WebMobileClientType")
	golang_proto.RegisterType((*WebMobileClientType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.WebMobileClientType")
	proto.RegisterType((*ContinueMitigationChoiceType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.ContinueMitigationChoiceType")
	golang_proto.RegisterType((*ContinueMitigationChoiceType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.ContinueMitigationChoiceType")
	proto.RegisterType((*BlockMitigationChoiceType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.BlockMitigationChoiceType")
	golang_proto.RegisterType((*BlockMitigationChoiceType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.BlockMitigationChoiceType")
	proto.RegisterType((*BlockMobileMitigationChoiceType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.BlockMobileMitigationChoiceType")
	golang_proto.RegisterType((*BlockMobileMitigationChoiceType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.BlockMobileMitigationChoiceType")
	proto.RegisterType((*RedirectMitigationChoiceType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.RedirectMitigationChoiceType")
	golang_proto.RegisterType((*RedirectMitigationChoiceType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.RedirectMitigationChoiceType")
	proto.RegisterType((*JavaScriptInsertType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptInsertType")
	golang_proto.RegisterType((*JavaScriptInsertType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptInsertType")
	proto.RegisterType((*JavaScriptInsertAllWithExceptionsType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptInsertAllWithExceptionsType")
	golang_proto.RegisterType((*JavaScriptInsertAllWithExceptionsType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptInsertAllWithExceptionsType")
	proto.RegisterType((*JavaScriptInsertManualType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptInsertManualType")
	golang_proto.RegisterType((*JavaScriptInsertManualType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptInsertManualType")
	proto.RegisterType((*JavaScriptInsertAllType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptInsertAllType")
	golang_proto.RegisterType((*JavaScriptInsertAllType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptInsertAllType")
	proto.RegisterType((*JavaScriptInsertionRule)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptInsertionRule")
	golang_proto.RegisterType((*JavaScriptInsertionRule)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptInsertionRule")
	proto.RegisterType((*JavaScriptExclusionRule)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptExclusionRule")
	golang_proto.RegisterType((*JavaScriptExclusionRule)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.JavaScriptExclusionRule")
	proto.RegisterType((*MobileSDKConfigType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.MobileSDKConfigType")
	golang_proto.RegisterType((*MobileSDKConfigType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.MobileSDKConfigType")
	proto.RegisterType((*MobileTrafficIdentifierType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.MobileTrafficIdentifierType")
	golang_proto.RegisterType((*MobileTrafficIdentifierType)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.MobileTrafficIdentifierType")
	proto.RegisterType((*DistributionTagList)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.DistributionTagList")
	golang_proto.RegisterType((*DistributionTagList)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.DistributionTagList")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.DistributionTagList.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.DistributionTagList.TagsEntry")
	proto.RegisterType((*DistributionIDList)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.DistributionIDList")
	golang_proto.RegisterType((*DistributionIDList)(nil), "ves.io.schema.shape.bot_defense.protected_application.cloudfront.DistributionIDList")
}

func init() {
	proto.RegisterFile("ves.io/schema/shape/bot_defense/protected_application/cloudfront/types.proto", fileDescriptor_a98a494ad7678110)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/shape/bot_defense/protected_application/cloudfront/types.proto", fileDescriptor_a98a494ad7678110)
}

var fileDescriptor_a98a494ad7678110 = []byte{
	// 3823 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x5a, 0x5d, 0x6c, 0x1b, 0x57,
	0x76, 0xd6, 0x1d, 0xfe, 0x88, 0x3c, 0x94, 0xa8, 0xd1, 0x95, 0x64, 0xd1, 0xb4, 0xcd, 0x70, 0x19,
	0xef, 0x5a, 0xab, 0x50, 0x94, 0x44, 0xd9, 0x8e, 0xed, 0x7a, 0x9d, 0x88, 0x92, 0x6c, 0x49, 0x91,
	0x25, 0x67, 0x24, 0x47, 0xd8, 0x64, 0x93, 0xe9, 0x90, 0x73, 0x45, 0x8e, 0x3d, 0xe4, 0x70, 0x67,
	0x86, 0xfa, 0xf1, 0x36, 0x85, 0x9a, 0xa2, 0x45, 0x1b, 0x6c, 0x8b, 0xc0, 0xdb, 0x87, 0x45, 0x9a,
	0xb6, 0x8b, 0xf4, 0x65, 0x8b, 0x16, 0x2d, 0x8a, 0xfe, 0xa0, 0xe8, 0xf8, 0x41, 0x58, 0x60, 0x81,
	0xac, 0x81, 0x02, 0x7a, 0x28, 0x0a, 0xc3, 0x4f, 0x89, 0xf2, 0xe2, 0xee, 0x53, 0x10, 0xb4, 0xc0,
	0xf6, 0xa9, 0xc5, 0xbd, 0x77, 0xf8, 0x2b, 0x4a, 0x49, 0x2a, 0x39, 0xe9, 0x76, 0x9f, 0x38, 0xbc,
	0xf7, 0xfc, 0x7c, 0xe7, 0x9e, 0x73, 0xcf, 0x3d, 0xf7, 0x07, 0x16, 0xd6, 0x89, 0x95, 0xd2, 0x8c,
	0x51, 0x2b, 0x57, 0x20, 0x45, 0x65, 0xd4, 0x2a, 0x28, 0x65, 0x32, 0x9a, 0x35, 0x6c, 0x59, 0x25,
	0x6b, 0xa4, 0x64, 0x91, 0xd1, 0xb2, 0x69, 0xd8, 0x24, 0x67, 0x13, 0x55, 0x56, 0xca, 0x65, 0x5d,
	0xcb, 0x29, 0xb6, 0x66, 0x94, 0x46, 0x73, 0xba, 0x51, 0x51, 0xd7, 0x4c, 0xa3, 0x64, 0x8f, 0xda,
	0x5b, 0x65, 0x62, 0xa5, 0x28, 0x99, 0x81, 0x5f, 0xe4, 0xd2, 0x52, 0x5c, 0x5a, 0x8a, 0x49, 0x4b,
	0x35, 0x48, 0x4b, 0xb5, 0x95, 0x96, 0xaa, 0x4b, 0x8b, 0x8e, 0xe4, 0x35, 0xbb, 0x50, 0xc9, 0xa6,
	0x72, 0x46, 0x71, 0x34, 0x6f, 0xe4, 0x0d, 0xa6, 0xdf, 0xc8, 0x56, 0xd6, 0xd8, 0x3f, 0xf6, 0x87,
	0x7d, 0x71, 0x85, 0xd1, 0x93, 0x79, 0xc3, 0xc8, 0xeb, 0xa4, 0x4e, 0xa5, 0x94, 0xb6, 0xdc, 0xae,
	0x53, 0xcd, 0x96, 0x19, 0x65, 0xaa, 0xca, 0x05, 0x1a, 0x8d, 0x37, 0x77, 0x96, 0x0d, 0x5d, 0xcb,
	0x6d, 0x35, 0x9a, 0x12, 0x3d, 0xd9, 0x4c, 0xd1, 0xd8, 0x75, 0xba, 0xb9, 0x6b, 0x5d, 0xd1, 0x35,
	0x55, 0xb1, 0x49, 0x7b, 0xd1, 0xeb, 0x1a, 0xd9, 0x90, 0x9b, 0x95, 0x3f, 0xb3, 0x9f, 0xc2, 0x6a,
	0x54, 0x90, 0x78, 0xaf, 0x0f, 0xc2, 0x53, 0xb5, 0x31, 0x59, 0xd9, 0x2a, 0x13, 0xfc, 0x4f, 0x08,
	0xfa, 0xea, 0x83, 0x47, 0x4a, 0x6a, 0xd9, 0xd0, 0x4a, 0xb6, 0x15, 0x41, 0x71, 0xcf, 0x50, 0x28,
	0xbd, 0x9a, 0x3a, 0xea, 0xc0, 0xa7, 0x6e, 0x55, 0x09, 0x66, 0x5c, 0xd9, 0x54, 0x6d, 0x26, 0xb5,
	0xeb, 0x20, 0xf4, 0xcf, 0xff, 0xbe, 0xe3, 0xf1, 0xdf, 0x47, 0x1e, 0x71, 0x9b, 0x7d, 0xfa, 0xee,
	0x23, 0x21, 0x50, 0xfb, 0x8a, 0xa0, 0xbd, 0x0f, 0x7f, 0xea, 0xf1, 0xdf, 0x7f, 0x80, 0x04, 0x11,
	0x49, 0xb8, 0xdc, 0x2a, 0xc6, 0xc2, 0x13, 0x20, 0xde, 0xb1, 0x64, 0xd5, 0xd8, 0x28, 0xe9, 0x86,
	0xa2, 0xca, 0x65, 0xc5, 0x2e, 0x44, 0x84, 0x38, 0x1a, 0x0a, 0x66, 0x82, 0x8f, 0xde, 0x44, 0x4f,
	0x1c, 0x84, 0x22, 0x48, 0x0a, 0xdf, 0xb1, 0xa6, 0x5d, 0x8a, 0x5b, 0x8a, 0x5d, 0xc0, 0x19, 0xe8,
	0x55, 0x35, 0x4b, 0xc9, 0xea, 0x44, 0xbe, 0x63, 0xc9, 0x5a, 0xc9, 0x22, 0xa6, 0x1d, 0xf1, 0xc6,
	0xd1, 0x50, 0x28, 0xdd, 0xdf, 0x62, 0xec, 0x4c, 0xb1, 0x6c, 0x6f, 0xcd, 0x76, 0x48, 0x3d, 0x2e,
	0xc3, 0xbc, 0x35, 0xc7, 0xc8, 0xf1, 0x1f, 0x22, 0x10, 0x8b, 0x4a, 0xa9, 0xa2, 0xe8, 0x0d, 0x32,
	0x0a, 0x4c, 0xc6, 0x77, 0x8e, 0x3e, 0x60, 0xf3, 0xca, 0xba, 0xb2, 0x9c, 0x33, 0xb5, 0xb2, 0xcd,
	0xd5, 0xdd, 0x64, 0x9a, 0xd8, 0xa8, 0x79, 0x77, 0x1c, 0x84, 0x66, 0x3b, 0xa4, 0x30, 0xd7, 0x5e,
	0x03, 0xf4, 0x0e, 0x82, 0xbe, 0x1a, 0x12, 0x59, 0xd1, 0x75, 0xb9, 0xac, 0xe4, 0x89, 0x15, 0xf1,
	0x31, 0x4c, 0xdf, 0x3e, 0x7e, 0x4c, 0x93, 0xba, 0x0b, 0xe8, 0x09, 0x07, 0x24, 0xde, 0xb1, 0x6a,
	0x1d, 0xb7, 0xa8, 0x6a, 0xfc, 0x97, 0x08, 0xa2, 0x6d, 0x20, 0xc9, 0x64, 0x33, 0x47, 0xca, 0x76,
	0xc4, 0xcf, 0x90, 0xe5, 0x9f, 0x0a, 0xb2, 0x55, 0xcd, 0x2e, 0xcc, 0x30, 0x35, 0x74, 0x6e, 0x34,
	0xe1, 0x3c, 0xd1, 0x8a, 0x93, 0xd3, 0xe1, 0xef, 0x23, 0xc0, 0x35, 0xb4, 0x9a, 0x51, 0x92, 0xcd,
	0x8a, 0x4e, 0xac, 0x48, 0x27, 0x43, 0xf9, 0xca, 0xf1, 0xa3, 0xe4, 0xa0, 0x76, 0x5b, 0x06, 0x4f,
	0x33, 0x4a, 0x12, 0xd5, 0x8b, 0xa7, 0x01, 0x57, 0x83, 0xb4, 0x68, 0x64, 0x35, 0x9d, 0xc8, 0x96,
	0x7a, 0x37, 0x72, 0xf2, 0x90, 0x28, 0x45, 0x92, 0xe8, 0x72, 0xdc, 0x64, 0x0c, 0xcb, 0xea, 0x5d,
	0xfc, 0xdb, 0x08, 0x7a, 0xeb, 0xec, 0x72, 0xce, 0x28, 0xad, 0x69, 0xf9, 0x48, 0x94, 0x49, 0xb9,
	0x7d, 0x74, 0x9b, 0x5c, 0x45, 0xd3, 0x2f, 0x4d, 0x31, 0xc1, 0xd4, 0xa4, 0x59, 0x24, 0xf5, 0x14,
	0xab, 0xfa, 0x79, 0x33, 0x1e, 0x85, 0xb0, 0xb2, 0x61, 0xc9, 0x4a, 0x2e, 0x67, 0x54, 0x4a, 0xb6,
	0x5c, 0x32, 0x22, 0x7d, 0xad, 0x73, 0xb4, 0x4b, 0xd9, 0xb0, 0x26, 0x79, 0xff, 0xa2, 0x81, 0x25,
	0x38, 0x59, 0x35, 0x9e, 0x32, 0x72, 0xd8, 0x15, 0x93, 0xe9, 0x8f, 0x0c, 0x1c, 0x32, 0x06, 0x82,
	0x34, 0xe8, 0x32, 0x4e, 0x6e, 0x58, 0x53, 0x8d, 0x6c, 0xf8, 0xcf, 0x10, 0x9c, 0xd9, 0x27, 0x4c,
	0xd6, 0x54, 0xd9, 0x22, 0x3a, 0xc9, 0xd9, 0x86, 0x19, 0x39, 0xc1, 0x04, 0xaf, 0x1c, 0x7d, 0x58,
	0xa6, 0x35, 0xcb, 0x36, 0xb5, 0x6c, 0x85, 0xb6, 0xcf, 0x4d, 0x2f, 0x68, 0x96, 0xed, 0x3a, 0x5a,
	0x90, 0xa2, 0x4a, 0x0b, 0xae, 0x39, 0x75, 0xd9, 0xd5, 0x8f, 0xdf, 0x47, 0x10, 0xdb, 0x8f, 0xd0,
	0x56, 0xf2, 0x75, 0x88, 0x83, 0xc7, 0xe5, 0xb9, 0x46, 0x88, 0x2b, 0x4a, 0xbe, 0x09, 0xe3, 0xa9,
	0x56, 0x8c, 0x2b, 0x4a, 0xbe, 0x06, 0xf2, 0x4f, 0x10, 0xf4, 0xd8, 0x66, 0xc5, 0xa2, 0xb2, 0x73,
	0xba, 0x46, 0xe8, 0x42, 0xf1, 0x2c, 0x5b, 0x28, 0xa4, 0xa3, 0xa3, 0x9a, 0x62, 0x02, 0x33, 0x5b,
	0x65, 0xc5, 0xb2, 0xe8, 0x34, 0xc8, 0xc4, 0xeb, 0xeb, 0x83, 0x50, 0x5d, 0x15, 0xc6, 0x9a, 0x56,
	0x85, 0xb0, 0x0b, 0x86, 0xb3, 0x5a, 0xf8, 0x12, 0x74, 0xda, 0x5a, 0x91, 0x18, 0x15, 0x3b, 0xa2,
	0xc6, 0xd1, 0x50, 0x77, 0x26, 0x46, 0x13, 0xe6, 0x63, 0x07, 0x79, 0x9e, 0x1f, 0x1b, 0xfb, 0x85,
	0x83, 0x3a, 0x7e, 0xef, 0x01, 0xea, 0x60, 0x52, 0x87, 0xbd, 0x91, 0x0f, 0xff, 0xd5, 0x23, 0x55,
	0xc9, 0xf1, 0x05, 0x08, 0xa9, 0x8a, 0xad, 0xc8, 0x96, 0x52, 0x2c, 0xeb, 0x24, 0x42, 0x18, 0x77,
	0xbf, 0xcb, 0x8d, 0xc6, 0xaa, 0x3c, 0xdb, 0xdb, 0x2f, 0x4a, 0x40, 0x09, 0x97, 0x19, 0x1d, 0xde,
	0x84, 0x58, 0xce, 0x28, 0xd9, 0x5a, 0xa9, 0x42, 0xe4, 0xa2, 0x66, 0x6b, 0x79, 0xee, 0x36, 0x25,
	0xc7, 0x7e, 0x0a, 0xaa, 0x19, 0x59, 0x63, 0xc1, 0x3e, 0xe1, 0x4a, 0xea, 0xdb, 0x1c, 0x59, 0xbb,
	0x30, 0x92, 0x35, 0xec, 0x11, 0xa5, 0x62, 0x1b, 0x45, 0x46, 0x4d, 0x71, 0x31, 0xf3, 0x4c, 0xcf,
	0x07, 0x7c, 0x4d, 0xf4, 0x99, 0x9e, 0xa1, 0x6d, 0x41, 0x3a, 0x55, 0x15, 0x7d, 0xb3, 0x26, 0x79,
	0x92, 0x09, 0x9e, 0x55, 0x4d, 0xac, 0x43, 0x40, 0xa7, 0x15, 0xca, 0x3a, 0xd1, 0x23, 0xf9, 0x38,
	0x1a, 0x0a, 0xa7, 0xe7, 0x8f, 0xee, 0x82, 0x05, 0x23, 0xbf, 0x40, 0x25, 0xf2, 0x85, 0x46, 0xaa,
	0x69, 0xb8, 0xf2, 0x33, 0xf4, 0xe9, 0xb5, 0xaf, 0x8d, 0x5f, 0x4e, 0xa6, 0xc7, 0x92, 0xe3, 0xc9,
	0x74, 0x72, 0x22, 0x99, 0x3e, 0x9f, 0x9c, 0xb8, 0x90, 0x1c, 0x1f, 0x9b, 0x48, 0x8e, 0x8f, 0xa5,
	0x93, 0xe3, 0x63, 0x63, 0xc9, 0xf1, 0xb1, 0xf1, 0x9f, 0x38, 0xe8, 0x47, 0x08, 0x12, 0x70, 0x7a,
	0xb2, 0xa8, 0xdc, 0x33, 0x4a, 0x71, 0x89, 0xac, 0x11, 0x93, 0x94, 0x72, 0x24, 0x3e, 0x57, 0x5a,
	0x33, 0x4c, 0x6e, 0x2e, 0x16, 0xd2, 0x63, 0x10, 0x85, 0xbe, 0x5a, 0x5d, 0x10, 0xaf, 0xaf, 0xe8,
	0x68, 0x7c, 0x08, 0xc1, 0xb3, 0x10, 0x5b, 0x25, 0xd9, 0x38, 0xf7, 0x69, 0xbc, 0x9e, 0x39, 0xe3,
	0xcb, 0xc4, 0xb6, 0xb5, 0x52, 0xde, 0xc2, 0x68, 0x02, 0x06, 0xa0, 0x87, 0xe7, 0x9f, 0x7a, 0xab,
	0x90, 0x3e, 0x0f, 0x09, 0xe8, 0xba, 0x69, 0x98, 0x24, 0xbe, 0xc4, 0x73, 0x3f, 0xc6, 0xfb, 0x41,
	0x66, 0x46, 0x00, 0xdf, 0x51, 0xd6, 0x15, 0xd9, 0x62, 0x52, 0xe5, 0x5c, 0xc1, 0xd0, 0x72, 0x04,
	0x0f, 0xee, 0x38, 0xa8, 0x73, 0xd7, 0x41, 0x9e, 0x3d, 0x07, 0x85, 0x2e, 0x24, 0x2f, 0x26, 0x9f,
	0x4f, 0x9e, 0x4f, 0x8e, 0x8f, 0x9d, 0xcf, 0x7c, 0xa3, 0x39, 0x89, 0x72, 0xea, 0xde, 0x1d, 0x07,
	0x9d, 0xdc, 0x75, 0x50, 0x64, 0xcf, 0x41, 0xbe, 0xf4, 0x85, 0x64, 0xfa, 0x62, 0xe6, 0x9b, 0xed,
	0x32, 0x0c, 0x2d, 0xbe, 0xaa, 0x3c, 0x81, 0x1d, 0x07, 0x9d, 0xd8, 0x75, 0x50, 0xff, 0xbc, 0x37,
	0xe0, 0x11, 0xbd, 0xf3, 0xde, 0x40, 0x44, 0x3c, 0x39, 0xef, 0x0d, 0x04, 0xc4, 0xe0, 0xbc, 0x37,
	0xd0, 0x2f, 0x0e, 0x24, 0xde, 0xf1, 0x80, 0xd8, 0x3a, 0x0b, 0xf0, 0x15, 0x08, 0x14, 0x89, 0xad,
	0xd0, 0xa0, 0x8b, 0x20, 0x96, 0x01, 0x62, 0x2d, 0x8e, 0xbe, 0x49, 0x2c, 0x4b, 0xc9, 0x93, 0x9b,
	0xc4, 0x56, 0x68, 0x12, 0x96, 0x6a, 0xf4, 0xf8, 0x9b, 0x10, 0xd4, 0xca, 0x72, 0xd9, 0x24, 0x6b,
	0xda, 0x26, 0x2b, 0x72, 0x82, 0x19, 0x70, 0x03, 0xec, 0xc7, 0x6c, 0xe9, 0x09, 0x68, 0xe5, 0x5b,
	0xac, 0x17, 0xdf, 0x83, 0x50, 0xc1, 0xb6, 0xcb, 0x72, 0x81, 0x28, 0x2a, 0x31, 0xdd, 0xca, 0xe1,
	0x18, 0xca, 0xbf, 0x59, 0xdb, 0x2e, 0xcf, 0x32, 0x99, 0x37, 0x15, 0x3b, 0x57, 0x20, 0x26, 0xcd,
	0x36, 0xb3, 0x1d, 0x12, 0x14, 0x6a, 0x1d, 0x57, 0xee, 0x7c, 0x7a, 0xcd, 0x33, 0x9e, 0x9c, 0x78,
	0xe8, 0xa0, 0x5f, 0x87, 0x41, 0xf0, 0x2e, 0x2a, 0x45, 0x12, 0xed, 0x81, 0xee, 0xaa, 0x19, 0xa9,
	0x92, 0x52, 0x24, 0x30, 0x03, 0xbd, 0x6e, 0x48, 0xcc, 0xa9, 0xa4, 0x64, 0x6b, 0x6b, 0x1a, 0x31,
	0x87, 0xc7, 0x20, 0x05, 0xa1, 0x06, 0x23, 0xe1, 0x19, 0xe8, 0x6b, 0x30, 0x23, 0xc5, 0x7f, 0xac,
	0x44, 0x40, 0xf4, 0x26, 0xbc, 0x54, 0x4c, 0xe6, 0x1c, 0xf4, 0xf3, 0xcc, 0x25, 0x5b, 0x46, 0xc5,
	0xcc, 0xd5, 0xbc, 0xd3, 0xb3, 0xe3, 0x20, 0xaf, 0xeb, 0x7f, 0xcf, 0xf9, 0xe4, 0x05, 0xee, 0xa4,
	0xc4, 0xbf, 0x09, 0xd0, 0xdb, 0x04, 0x9f, 0x15, 0xcd, 0xe3, 0xc0, 0x84, 0x31, 0x7f, 0x04, 0x33,
	0x67, 0xda, 0xcd, 0x5e, 0xfa, 0xe5, 0x35, 0x85, 0x38, 0x92, 0x18, 0x29, 0x4e, 0x82, 0x8f, 0x6c,
	0x2a, 0x39, 0xdb, 0xad, 0x50, 0xfb, 0x9b, 0x29, 0x7d, 0xa6, 0xe7, 0x11, 0x73, 0x08, 0x27, 0xc2,
	0x17, 0xc1, 0x67, 0x92, 0x3c, 0xd9, 0x8c, 0x78, 0x18, 0x75, 0xac, 0x1d, 0xb5, 0xfb, 0xb5, 0xc3,
	0xf9, 0x18, 0xf9, 0x95, 0xdf, 0x42, 0x3f, 0x71, 0x50, 0x04, 0x4e, 0x40, 0x0f, 0x07, 0x1d, 0xb7,
	0x8d, 0x38, 0x03, 0x8e, 0x3d, 0xe3, 0xc9, 0x8b, 0x0f, 0x1d, 0xa4, 0x40, 0xd8, 0x1d, 0x60, 0x3f,
	0xb7, 0x01, 0xc6, 0x00, 0x18, 0x45, 0x9c, 0x5a, 0x36, 0x9c, 0x80, 0x38, 0x84, 0x5d, 0xa8, 0x69,
	0xdf, 0x0c, 0xfd, 0xa1, 0xff, 0x99, 0xf4, 0xb4, 0x4f, 0xa2, 0x3f, 0x70, 0x06, 0x42, 0x9c, 0xe3,
	0x15, 0x45, 0xaf, 0x90, 0x74, 0x95, 0xdc, 0xa5, 0xca, 0xc4, 0x20, 0xb4, 0x4e, 0x3b, 0xe4, 0x22,
	0x53, 0x4c, 0x07, 0x56, 0xd8, 0x75, 0x90, 0x9f, 0x0e, 0x6c, 0x3a, 0x39, 0x31, 0xef, 0x0d, 0xf8,
	0xc5, 0xce, 0xc4, 0x7d, 0x04, 0x03, 0x6d, 0x63, 0x03, 0x6f, 0x41, 0xa7, 0xeb, 0x36, 0x77, 0x13,
	0xb2, 0x7c, 0x0c, 0x51, 0xd8, 0xea, 0x42, 0x77, 0x1e, 0xdc, 0x47, 0x82, 0x28, 0x4a, 0x55, 0x7d,
	0x89, 0xf7, 0x42, 0x30, 0xd0, 0x76, 0xbf, 0x72, 0xa4, 0x59, 0x78, 0x01, 0x40, 0x29, 0x6d, 0xc9,
	0xaa, 0x51, 0x54, 0xb4, 0x12, 0xf3, 0xe8, 0xc1, 0x7b, 0x8d, 0xa0, 0x52, 0xda, 0x9a, 0x66, 0x84,
	0xf8, 0x32, 0xf8, 0x5d, 0x16, 0xbe, 0x3d, 0x39, 0xd9, 0xc2, 0xc2, 0xc9, 0x78, 0x25, 0xf9, 0x09,
	0xaf, 0x24, 0x5d, 0x06, 0xbc, 0x0c, 0x5e, 0xb6, 0x1b, 0xf2, 0xb1, 0xe8, 0x79, 0xa1, 0x4d, 0x54,
	0xd2, 0x8f, 0x73, 0xe6, 0xd7, 0xd3, 0xcf, 0xbe, 0xf1, 0xda, 0x77, 0x12, 0x67, 0xbf, 0x71, 0x6e,
	0xf8, 0xb9, 0xd4, 0xe8, 0xd8, 0xc8, 0xe5, 0x2b, 0x2f, 0xbc, 0x38, 0x39, 0xf2, 0xaa, 0xac, 0x8c,
	0xdc, 0xfb, 0xcd, 0x91, 0xd7, 0xbf, 0x37, 0x9e, 0xbc, 0x7c, 0xf9, 0xf2, 0x9b, 0x67, 0x25, 0x26,
	0x0c, 0x0f, 0x83, 0xef, 0xbb, 0x15, 0x62, 0x6e, 0xb1, 0xda, 0xbd, 0x5d, 0x04, 0xef, 0x20, 0x24,
	0x71, 0x12, 0x6c, 0x41, 0x17, 0x9b, 0x86, 0x45, 0x62, 0x17, 0x0c, 0x95, 0x16, 0xd2, 0x9e, 0xa1,
	0x70, 0xfa, 0x74, 0x8b, 0x05, 0x19, 0xc3, 0xa6, 0x21, 0x70, 0x93, 0x11, 0x65, 0xd2, 0x54, 0x4c,
	0xcf, 0x7d, 0xd4, 0x95, 0x80, 0xb7, 0x50, 0xa7, 0x88, 0xa2, 0x1e, 0xe4, 0xf1, 0xd6, 0xbc, 0xe4,
	0x6d, 0xb7, 0x43, 0x94, 0x58, 0xce, 0xe2, 0xfc, 0x16, 0x2e, 0x03, 0x6c, 0x90, 0xac, 0x5b, 0x98,
	0x44, 0x82, 0x6c, 0xd0, 0x96, 0x8e, 0x1e, 0x3b, 0xab, 0x24, 0xcb, 0x13, 0x8f, 0x5b, 0xe1, 0x06,
	0x37, 0xaa, 0x0d, 0x78, 0x0b, 0xba, 0xdd, 0xb5, 0xc1, 0x55, 0x0a, 0x4c, 0xa9, 0x74, 0x5c, 0xc5,
	0x75, 0x93, 0xde, 0xae, 0x62, 0x43, 0x1b, 0x2b, 0xee, 0xa9, 0xb5, 0xcd, 0xfa, 0x43, 0xc7, 0x55,
	0x22, 0xae, 0x92, 0x6c, 0x1b, 0x08, 0x3d, 0x1b, 0xcd, 0xcd, 0x78, 0x16, 0xfa, 0x2b, 0x25, 0x95,
	0xac, 0x69, 0x25, 0xa2, 0xca, 0x6b, 0xba, 0xb1, 0x21, 0xeb, 0x4a, 0x96, 0xe8, 0x91, 0xee, 0x43,
	0xcb, 0x74, 0x5c, 0xe3, 0xb9, 0xae, 0x1b, 0x1b, 0x0b, 0x94, 0x03, 0xaf, 0x02, 0x34, 0xf0, 0x87,
	0x19, 0xff, 0xc5, 0xfd, 0xf1, 0x32, 0xcd, 0x0d, 0xa8, 0xf1, 0x4d, 0x29, 0x36, 0xc9, 0x1b, 0xa6,
	0x46, 0xac, 0x29, 0x96, 0xc7, 0x19, 0x50, 0x41, 0x0a, 0xae, 0x55, 0x09, 0xae, 0xfc, 0x83, 0xf0,
	0xe9, 0x35, 0xcc, 0x8b, 0x96, 0xf3, 0x49, 0xbe, 0xb0, 0x8f, 0xa7, 0x93, 0x97, 0x1e, 0x3a, 0xe8,
	0x8f, 0x85, 0x83, 0x57, 0x9b, 0x15, 0xf0, 0xf3, 0xf9, 0x35, 0x3c, 0x0f, 0xb3, 0xd0, 0xdb, 0x38,
	0x83, 0xd3, 0x9e, 0xc9, 0xd2, 0x16, 0xf4, 0x03, 0xe6, 0x7f, 0x53, 0x2c, 0xf9, 0xc9, 0x2c, 0xe5,
	0xc1, 0x99, 0x5a, 0x2b, 0xcb, 0x85, 0xbc, 0x15, 0x77, 0x46, 0xdd, 0xcc, 0x19, 0x06, 0xef, 0x2d,
	0xc5, 0x2e, 0xd0, 0xdc, 0x4b, 0xa7, 0x14, 0x0c, 0x82, 0xef, 0x65, 0x3a, 0x5f, 0xa2, 0x61, 0x77,
	0x6e, 0x45, 0x6b, 0x29, 0xb6, 0xd3, 0x8d, 0xea, 0x0c, 0x6e, 0x9e, 0x4a, 0xa2, 0x77, 0x0c, 0x41,
	0x16, 0x42, 0xee, 0x5a, 0xc8, 0x92, 0xf6, 0x32, 0xbc, 0x4c, 0x21, 0xd6, 0x83, 0x3f, 0xed, 0x59,
	0x25, 0x59, 0x18, 0x6c, 0x89, 0xce, 0xb4, 0x9f, 0xfb, 0x0e, 0x9e, 0x6d, 0x13, 0x3a, 0xe9, 0x30,
	0x2d, 0xba, 0x94, 0x92, 0x1a, 0xe7, 0x44, 0x99, 0x21, 0x18, 0xe0, 0xa6, 0xf0, 0x3c, 0x4e, 0xcc,
	0xc6, 0x95, 0xd2, 0xb3, 0xeb, 0x20, 0x81, 0x26, 0xf4, 0x89, 0xe4, 0xf9, 0x4c, 0x0c, 0xb0, 0xbb,
	0xa4, 0xb6, 0x96, 0x3b, 0xc1, 0x5d, 0x07, 0x05, 0x32, 0x67, 0xa0, 0xb7, 0xee, 0xda, 0xc6, 0xee,
	0xee, 0x5d, 0x07, 0x75, 0xcd, 0x7b, 0x03, 0x82, 0xe8, 0xa9, 0xd5, 0x41, 0x5d, 0x62, 0xf7, 0xbc,
	0x37, 0xd0, 0x2b, 0xe2, 0x79, 0x6f, 0xa0, 0x47, 0x14, 0xe7, 0xbd, 0x01, 0x51, 0xec, 0x9d, 0xf7,
	0x06, 0xb0, 0xd8, 0x97, 0xf8, 0x53, 0x0f, 0x74, 0x37, 0xcd, 0x46, 0xfc, 0x1b, 0x10, 0xa8, 0x16,
	0xc9, 0x6c, 0x61, 0x0d, 0xa5, 0xdf, 0x38, 0x86, 0x8d, 0xc8, 0xbe, 0xb2, 0xbb, 0x21, 0xb6, 0x3a,
	0xa4, 0x9a, 0x46, 0xaa, 0xdd, 0x24, 0xaa, 0x66, 0x92, 0x9c, 0xed, 0xa6, 0xf5, 0x63, 0xd0, 0x2e,
	0xb9, 0x12, 0x0f, 0xd2, 0x5e, 0xd5, 0x88, 0x2d, 0xf0, 0x65, 0x75, 0x23, 0x77, 0xd7, 0x5d, 0x1e,
	0x5e, 0x3b, 0xba, 0xea, 0x0c, 0x15, 0x77, 0x80, 0x5e, 0xae, 0x2b, 0x73, 0x02, 0xa0, 0xbe, 0xcf,
	0x61, 0x4e, 0xa4, 0x6b, 0x3b, 0x9a, 0xf7, 0x06, 0x90, 0x28, 0x24, 0xfe, 0x42, 0x00, 0xb1, 0x35,
	0x6d, 0x7c, 0xc5, 0x3e, 0xda, 0xaa, 0x8e, 0x12, 0x77, 0x90, 0x72, 0x5c, 0xa3, 0xc4, 0xac, 0x3c,
	0xca, 0x58, 0xfd, 0x97, 0x0f, 0xfa, 0xda, 0x64, 0x59, 0x9a, 0xd8, 0xbb, 0x6a, 0x7b, 0xca, 0x0d,
	0x92, 0xfd, 0xd2, 0xc6, 0x2c, 0x54, 0xd5, 0xba, 0x4a, 0xb2, 0x0c, 0x45, 0x35, 0xd2, 0x18, 0x8a,
	0x2f, 0x2b, 0xbe, 0x43, 0x55, 0xad, 0x14, 0xc5, 0x3d, 0x08, 0xb2, 0xa1, 0x64, 0x08, 0xbe, 0x94,
	0x30, 0x0f, 0x30, 0x7d, 0x54, 0xf7, 0xef, 0x23, 0xe8, 0xa9, 0xef, 0xed, 0x99, 0x97, 0xdc, 0x53,
	0xcb, 0xa7, 0xed, 0x0a, 0x24, 0x85, 0x6b, 0x3b, 0x7f, 0xa6, 0x17, 0xff, 0x2e, 0x82, 0x2e, 0x3e,
	0x10, 0x2e, 0x90, 0xce, 0x2f, 0x2b, 0x98, 0x91, 0x14, 0xca, 0xd6, 0x49, 0x32, 0x51, 0x08, 0xb3,
	0x95, 0xa3, 0x4d, 0x58, 0xd3, 0x34, 0xef, 0xae, 0x28, 0x2d, 0xdd, 0xfe, 0x5d, 0x07, 0xf9, 0x78,
	0xd4, 0xcf, 0x7b, 0x03, 0x3e, 0xd1, 0x9f, 0xf8, 0x47, 0x04, 0xa7, 0x0f, 0x1b, 0x02, 0x3c, 0x01,
	0xc1, 0x92, 0x51, 0xdd, 0x8b, 0x0a, 0x87, 0x56, 0xcc, 0x81, 0x92, 0xc1, 0xab, 0x7b, 0x56, 0x67,
	0xab, 0x6a, 0x95, 0xeb, 0xb3, 0xea, 0x6c, 0x55, 0xe5, 0x6c, 0x99, 0xb3, 0xd0, 0x5b, 0x67, 0x6b,
	0x5c, 0xe4, 0x98, 0x59, 0xf5, 0x5d, 0x0b, 0x9d, 0xb4, 0xef, 0x79, 0xe1, 0xe4, 0x81, 0xe1, 0x83,
	0x97, 0xc0, 0x6f, 0xd9, 0x8a, 0x5d, 0xb1, 0x18, 0xe4, 0x70, 0xfa, 0x4c, 0x8b, 0x72, 0x5a, 0xec,
	0x2e, 0x33, 0x82, 0x29, 0x43, 0x25, 0x99, 0xc8, 0x63, 0x07, 0x09, 0x4b, 0x2f, 0xd1, 0x72, 0xb6,
	0xfb, 0x2d, 0x04, 0x22, 0x4a, 0xf8, 0xff, 0x5a, 0xf8, 0x1b, 0xe1, 0xef, 0x04, 0xc9, 0x15, 0x83,
	0xff, 0x56, 0xe0, 0xb9, 0xa0, 0xba, 0xb6, 0xba, 0xdb, 0xc1, 0x3f, 0x10, 0x1e, 0x3b, 0x28, 0x62,
	0x93, 0x4d, 0x7b, 0xb4, 0x60, 0x17, 0xf5, 0x5f, 0x8b, 0xe7, 0x0a, 0x8a, 0x69, 0x11, 0xfb, 0x5b,
	0xb7, 0x57, 0xae, 0x8f, 0x5c, 0xba, 0xff, 0x00, 0xed, 0x21, 0x38, 0x0f, 0x07, 0x12, 0xe0, 0x03,
	0x7b, 0xe0, 0x2c, 0x88, 0x8d, 0xb7, 0x71, 0x77, 0x2c, 0xa3, 0x84, 0xf7, 0xb5, 0x40, 0x02, 0x7a,
	0x1a, 0xdb, 0x36, 0x8b, 0x3a, 0x6e, 0x6d, 0x80, 0x08, 0x00, 0xd3, 0x52, 0xd6, 0xe9, 0x86, 0xa4,
	0xe1, 0x1b, 0xae, 0xc3, 0xd7, 0x9a, 0x88, 0x47, 0x36, 0x36, 0x36, 0x46, 0xd6, 0x0c, 0xb3, 0x38,
	0x52, 0x31, 0x75, 0x52, 0xca, 0x19, 0x2a, 0x51, 0xf1, 0x67, 0x93, 0xb8, 0x9b, 0x8e, 0xc8, 0x36,
	0xe2, 0x99, 0xab, 0x9a, 0x3f, 0xef, 0x81, 0x37, 0x6b, 0xa8, 0x5b, 0xee, 0x71, 0xc7, 0xda, 0x63,
	0x07, 0xbd, 0x74, 0x95, 0x9a, 0x7a, 0xed, 0x2a, 0xf5, 0xf0, 0xb5, 0xab, 0xb6, 0x66, 0xeb, 0xe4,
	0xda, 0x75, 0x45, 0xd3, 0x89, 0x7a, 0x75, 0x94, 0xff, 0xbb, 0x3a, 0xca, 0xfb, 0x28, 0xe3, 0xb5,
	0xab, 0x85, 0x89, 0x5a, 0x77, 0x61, 0xe2, 0xda, 0xd5, 0x51, 0xde, 0xca, 0xc6, 0xeb, 0xda, 0x2f,
	0x1c, 0xe4, 0x79, 0xff, 0x01, 0xf2, 0x29, 0x56, 0x4e, 0xd3, 0x6a, 0x10, 0xe2, 0x12, 0xd3, 0x99,
	0xf8, 0x17, 0x0f, 0x3c, 0xf3, 0x19, 0x33, 0x0a, 0xaf, 0x7e, 0xb1, 0x20, 0x89, 0x3f, 0x76, 0x10,
	0x64, 0x14, 0x55, 0x22, 0xdf, 0xad, 0x10, 0xcb, 0x3e, 0x24, 0x58, 0xfe, 0xbc, 0x7d, 0xb0, 0xfc,
	0x37, 0xa2, 0x12, 0xea, 0xe3, 0xff, 0x2b, 0x1e, 0x1e, 0xcf, 0x35, 0x85, 0xc7, 0xe0, 0xe1, 0xfe,
	0x7c, 0x1f, 0xc1, 0xe9, 0xc3, 0xd6, 0x2b, 0x2c, 0xd5, 0x9c, 0x89, 0x3e, 0x8f, 0x33, 0x4f, 0x3d,
	0x76, 0x90, 0xef, 0xba, 0x51, 0x29, 0xa9, 0x75, 0x3f, 0x46, 0x5b, 0xfd, 0x98, 0x82, 0x80, 0x6e,
	0x70, 0xd3, 0xdc, 0xc3, 0x22, 0xfc, 0xd8, 0x41, 0x68, 0x94, 0xb2, 0x04, 0x4c, 0xff, 0xd0, 0xb6,
	0x77, 0xdb, 0xc7, 0xce, 0x66, 0x39, 0x4d, 0xe2, 0x47, 0x3e, 0xe8, 0x6f, 0x77, 0xbf, 0x84, 0x33,
	0x6d, 0xee, 0x47, 0xf9, 0x89, 0x00, 0xcd, 0x3c, 0x30, 0x9a, 0x33, 0x8a, 0x45, 0xa3, 0x94, 0xba,
	0x63, 0xb9, 0x76, 0x3f, 0x11, 0xf6, 0x5f, 0x97, 0xde, 0x47, 0xd0, 0x73, 0x47, 0x59, 0x57, 0xdc,
	0xc3, 0xd2, 0xa2, 0xa1, 0xf2, 0x55, 0x30, 0x9c, 0xbe, 0x75, 0x9c, 0xb7, 0x62, 0x37, 0xe9, 0xe8,
	0x0c, 0x3e, 0x76, 0x50, 0xdf, 0xe4, 0xf2, 0xb7, 0x17, 0xa7, 0xe4, 0xf9, 0x65, 0x79, 0x71, 0x49,
	0x9e, 0x9a, 0x9c, 0x9a, 0x9d, 0x5b, 0xbc, 0x21, 0x85, 0xeb, 0x08, 0x28, 0x21, 0xfe, 0x1d, 0x04,
	0x7d, 0x0d, 0xa0, 0x6a, 0xa3, 0xe5, 0x65, 0xc0, 0x56, 0x8e, 0x13, 0xd8, 0x82, 0x2b, 0x5b, 0xc2,
	0x75, 0x85, 0xd5, 0x36, 0xfc, 0x0e, 0x02, 0x1f, 0xbf, 0x28, 0x14, 0xd8, 0x41, 0xd5, 0x53, 0xb8,
	0x68, 0x75, 0xaf, 0x04, 0x33, 0xcf, 0x7c, 0xc6, 0x5d, 0xb9, 0xc4, 0x81, 0xe0, 0x1f, 0x20, 0xe8,
	0x22, 0x9b, 0x39, 0xbd, 0xa2, 0x12, 0x59, 0xd7, 0x2c, 0xba, 0x2f, 0x39, 0x76, 0x64, 0x33, 0x54,
	0xbe, 0x55, 0x45, 0x36, 0xd0, 0x06, 0x59, 0x04, 0x49, 0x21, 0x17, 0xc5, 0x82, 0x66, 0xd9, 0x89,
	0x1f, 0x7a, 0xe0, 0xeb, 0x9f, 0xeb, 0xa2, 0xf6, 0x58, 0x62, 0xf6, 0x8f, 0x0e, 0x08, 0x0f, 0xf4,
	0xf4, 0xc2, 0x23, 0xd3, 0xcd, 0x66, 0xe7, 0x5b, 0xc8, 0x27, 0xa2, 0x04, 0xea, 0x68, 0x1b, 0x2d,
	0xfb, 0x5c, 0x23, 0xfc, 0x5f, 0x70, 0xcd, 0x7f, 0x22, 0x88, 0x1e, 0xfc, 0xe2, 0xa0, 0xed, 0xfc,
	0x17, 0xbe, 0xea, 0xf9, 0xdf, 0x2e, 0x48, 0xd0, 0x17, 0x0b, 0x92, 0xc4, 0x7f, 0x20, 0x18, 0x3c,
	0xe0, 0x55, 0xc3, 0xff, 0xe3, 0x20, 0x4c, 0xfc, 0xcc, 0xbb, 0xdf, 0x6c, 0x37, 0x5c, 0x7e, 0xc9,
	0xce, 0xb8, 0xcf, 0xb8, 0x67, 0xdc, 0xfe, 0xd6, 0xd7, 0x04, 0xfc, 0xb4, 0xfa, 0x1c, 0xf8, 0xdd,
	0x7b, 0xaf, 0x00, 0x23, 0xe8, 0x76, 0x97, 0xcf, 0xc8, 0xb6, 0xf0, 0x44, 0x40, 0xb3, 0x48, 0x72,
	0xbb, 0x71, 0x0a, 0x80, 0x9f, 0xe0, 0x31, 0x69, 0xc1, 0xf6, 0xc4, 0x41, 0x46, 0xc2, 0x1c, 0x7b,
	0x1b, 0xbc, 0x79, 0xdd, 0xc8, 0xb2, 0xa3, 0xde, 0x23, 0x9d, 0xad, 0xa7, 0x2f, 0x5c, 0x7c, 0xf3,
	0xec, 0x2c, 0x92, 0x98, 0xb8, 0x2b, 0xaf, 0x3d, 0x74, 0xd0, 0xea, 0xc1, 0xe7, 0x91, 0x57, 0xf9,
	0xc9, 0xe1, 0xf0, 0x79, 0x48, 0x03, 0xae, 0x9a, 0x86, 0x03, 0x51, 0x3f, 0xbf, 0xbe, 0x83, 0xae,
	0x46, 0x2b, 0x20, 0xcc, 0x31, 0x62, 0x7f, 0xd4, 0x7b, 0x43, 0x37, 0xb2, 0x5f, 0xe8, 0x2c, 0x2f,
	0x50, 0x31, 0x35, 0x26, 0x05, 0xe3, 0x1d, 0x07, 0x05, 0x76, 0x1d, 0xd4, 0xb9, 0xe7, 0x20, 0xff,
	0xa5, 0xe4, 0xe5, 0xe4, 0xf8, 0x58, 0xed, 0xb0, 0xae, 0x53, 0x0c, 0x24, 0x7e, 0xe0, 0x69, 0x8c,
	0xa5, 0xa6, 0xd4, 0xf3, 0x4b, 0x16, 0x4b, 0xe9, 0x86, 0xfb, 0x92, 0xfd, 0x48, 0xe9, 0xc0, 0x37,
	0x5c, 0x1d, 0xf1, 0x00, 0xbb, 0xb2, 0xf6, 0xd0, 0x41, 0xd9, 0x83, 0x1d, 0x76, 0xc3, 0x75, 0xd8,
	0x0b, 0xf0, 0x2d, 0x18, 0x84, 0x10, 0x65, 0x49, 0xed, 0xf3, 0x5a, 0x08, 0x82, 0xbc, 0x83, 0x3a,
	0x6d, 0x00, 0x80, 0xfd, 0x61, 0x27, 0xc7, 0xb5, 0x33, 0xe3, 0xcf, 0xef, 0x3b, 0xee, 0x9b, 0xc4,
	0x5f, 0x21, 0xe8, 0x6b, 0xf3, 0x34, 0x87, 0x26, 0xa4, 0xea, 0xfe, 0x5c, 0xab, 0x5d, 0xa0, 0xba,
	0xbe, 0x79, 0xfd, 0xb8, 0x2e, 0x2c, 0x56, 0x4c, 0x65, 0x6d, 0x4d, 0xcb, 0xd5, 0x6f, 0x68, 0xd9,
	0x70, 0x07, 0x76, 0x1c, 0x84, 0xe8, 0x90, 0x4b, 0x22, 0x47, 0x50, 0xef, 0x4f, 0xfc, 0x10, 0xc1,
	0xa9, 0x43, 0x78, 0xbf, 0xca, 0xdb, 0xc0, 0xef, 0x7b, 0xa0, 0xaf, 0xcd, 0x53, 0x19, 0xec, 0x08,
	0xe0, 0xb5, 0x95, 0x7c, 0x15, 0x90, 0xfc, 0x54, 0x1e, 0xe4, 0xa4, 0x56, 0x94, 0xbc, 0x35, 0x53,
	0xb2, 0xcd, 0xad, 0xcc, 0x4f, 0x59, 0x46, 0x09, 0xbd, 0x8b, 0x02, 0x09, 0xbf, 0xe9, 0x15, 0x51,
	0xe4, 0x45, 0x86, 0xf6, 0x5d, 0x24, 0x88, 0xfd, 0xd5, 0x2f, 0x5e, 0x0b, 0xf6, 0xbc, 0x8b, 0xba,
	0x86, 0xc1, 0x0c, 0x88, 0x28, 0xb2, 0x2d, 0xec, 0x20, 0xf6, 0x56, 0xa6, 0xfb, 0xed, 0x07, 0x28,
	0x88, 0x3b, 0x7f, 0xee, 0x20, 0xcf, 0x8a, 0x92, 0x6f, 0x68, 0xd9, 0xab, 0xb7, 0xc0, 0xdb, 0x0f,
	0x90, 0x1f, 0x7b, 0x3f, 0x70, 0x50, 0x07, 0x7b, 0x5e, 0xf3, 0xf6, 0x03, 0x2a, 0x91, 0x7e, 0x9e,
	0x7a, 0xfb, 0x01, 0x1a, 0x8c, 0x0e, 0xfc, 0xdc, 0x41, 0xbd, 0x2c, 0x1c, 0xe3, 0x0d, 0x37, 0xbf,
	0x0d, 0xfd, 0x7b, 0x07, 0xf5, 0x33, 0xc9, 0x51, 0x2a, 0x19, 0x49, 0x6c, 0xd0, 0xa2, 0xcf, 0x43,
	0xb0, 0x66, 0x1a, 0x16, 0xc1, 0x73, 0x97, 0x6c, 0xf1, 0xc5, 0x5b, 0xa2, 0x9f, 0xb8, 0x1f, 0x7c,
	0xec, 0xd2, 0x84, 0x6f, 0x7d, 0x24, 0xfe, 0xe7, 0x8a, 0x70, 0x09, 0x25, 0xf2, 0x80, 0xf7, 0xbf,
	0xad, 0xc2, 0x2f, 0x83, 0x47, 0x53, 0x79, 0x01, 0x1e, 0xcc, 0xbc, 0x50, 0x7d, 0x4b, 0x13, 0xb9,
	0x8f, 0x06, 0x12, 0x7d, 0x66, 0xaf, 0x88, 0x22, 0xf1, 0x74, 0xe8, 0x8d, 0xd7, 0x26, 0x47, 0x5e,
	0x1d, 0x1b, 0xb9, 0xfc, 0xfa, 0x73, 0x67, 0xeb, 0x7e, 0x6e, 0x5b, 0x45, 0x53, 0x59, 0xc3, 0x04,
	0x02, 0xd5, 0x87, 0x30, 0xf8, 0x04, 0x74, 0x2f, 0x2c, 0xdd, 0x90, 0x6f, 0x2f, 0x4e, 0xcf, 0x5c,
	0x9f, 0x5b, 0x9c, 0x99, 0x16, 0x3b, 0xa2, 0x9e, 0xed, 0x37, 0x11, 0xee, 0x86, 0x20, 0x6d, 0x9f,
	0x91, 0xa4, 0x25, 0x49, 0x44, 0xb8, 0x07, 0x42, 0xf4, 0xef, 0xea, 0xa4, 0xb4, 0x38, 0xb7, 0x78,
	0x43, 0x14, 0x70, 0x17, 0x04, 0x68, 0xc3, 0xdc, 0xe2, 0xf5, 0x25, 0xd1, 0x53, 0xa5, 0x9e, 0x9e,
	0xc9, 0xdc, 0xbe, 0x21, 0x7a, 0xa3, 0xec, 0x75, 0xcd, 0xb0, 0x0e, 0xe1, 0xe6, 0x02, 0x08, 0x0f,
	0x42, 0xbb, 0xf2, 0x47, 0xec, 0xc0, 0xfd, 0x20, 0xd6, 0x3a, 0xaa, 0xad, 0x08, 0x9f, 0x00, 0xdc,
	0x86, 0x5a, 0xc0, 0x7d, 0xd0, 0xd3, 0x4a, 0xec, 0x19, 0xfe, 0x1e, 0xe0, 0xfd, 0x15, 0x03, 0x3e,
	0x07, 0xb1, 0xf9, 0xc9, 0x57, 0x26, 0xe5, 0xe5, 0x29, 0x69, 0xee, 0xd6, 0x8a, 0xbc, 0xb0, 0x34,
	0x35, 0xb9, 0x32, 0xb7, 0xb4, 0xb8, 0xdf, 0xde, 0x30, 0xc0, 0xe4, 0xf5, 0x95, 0x19, 0x49, 0x9e,
	0x9d, 0x99, 0x9c, 0x16, 0x11, 0xd5, 0xc1, 0xff, 0xaf, 0xcc, 0xad, 0x2c, 0xcc, 0xc8, 0x33, 0x8b,
	0xd3, 0xa2, 0x80, 0x7b, 0xa1, 0x3b, 0x33, 0x73, 0x7d, 0x49, 0x9a, 0x71, 0xe5, 0x89, 0x1e, 0x6e,
	0x6a, 0xe6, 0xef, 0xd1, 0xee, 0x47, 0xb1, 0x8e, 0x47, 0x1f, 0xc5, 0x3a, 0x3e, 0xf9, 0x28, 0x86,
	0xb6, 0xf7, 0x62, 0xe8, 0xc7, 0x7b, 0x31, 0xf4, 0xc1, 0x5e, 0x0c, 0xed, 0xee, 0xc5, 0xd0, 0xa3,
	0xbd, 0x18, 0xfa, 0x70, 0x2f, 0x86, 0x9e, 0xec, 0xc5, 0x3a, 0x3e, 0xd9, 0x8b, 0xa1, 0x77, 0x3e,
	0x8e, 0x75, 0xec, 0x7c, 0x1c, 0x43, 0xbb, 0x1f, 0xc7, 0x3a, 0x1e, 0x7d, 0x1c, 0xeb, 0x78, 0x75,
	0x3d, 0x6f, 0x94, 0xef, 0xe6, 0x53, 0xeb, 0x86, 0x6e, 0x13, 0xd3, 0x54, 0x52, 0x15, 0x6b, 0x94,
	0x7d, 0xb0, 0x2d, 0x7f, 0xd9, 0x34, 0xd6, 0x35, 0x95, 0x98, 0x23, 0xd5, 0xee, 0xd1, 0x72, 0x36,
	0x6f, 0x8c, 0x92, 0x4d, 0xbb, 0xfa, 0xf4, 0xfc, 0x7f, 0xfb, 0x02, 0x3d, 0xeb, 0x67, 0xaf, 0xa6,
	0x27, 0xfe, 0x27, 0x00, 0x00, 0xff, 0xff, 0x35, 0x89, 0x40, 0x1a, 0xcc, 0x2e, 0x00, 0x00,
}

func (x LogLevel) String() string {
	s, ok := LogLevel_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x JavaScriptMode) String() string {
	s, ok := JavaScriptMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x JavaScriptLocation) String() string {
	s, ok := JavaScriptLocation_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *CloudfrontType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudfrontType)
	if !ok {
		that2, ok := that.(CloudfrontType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ProtectedEndpoints) != len(that1.ProtectedEndpoints) {
		return false
	}
	for i := range this.ProtectedEndpoints {
		if !this.ProtectedEndpoints[i].Equal(that1.ProtectedEndpoints[i]) {
			return false
		}
	}
	if this.JsDownloadPath != that1.JsDownloadPath {
		return false
	}
	if that1.JavaScriptChoice == nil {
		if this.JavaScriptChoice != nil {
			return false
		}
	} else if this.JavaScriptChoice == nil {
		return false
	} else if !this.JavaScriptChoice.Equal(that1.JavaScriptChoice) {
		return false
	}
	if that1.MobileSdkChoice == nil {
		if this.MobileSdkChoice != nil {
			return false
		}
	} else if this.MobileSdkChoice == nil {
		return false
	} else if !this.MobileSdkChoice.Equal(that1.MobileSdkChoice) {
		return false
	}
	if this.AwsAccountNo != that1.AwsAccountNo {
		return false
	}
	if that1.AwsConfigurationTypeChoice == nil {
		if this.AwsConfigurationTypeChoice != nil {
			return false
		}
	} else if this.AwsConfigurationTypeChoice == nil {
		return false
	} else if !this.AwsConfigurationTypeChoice.Equal(that1.AwsConfigurationTypeChoice) {
		return false
	}
	if len(this.TrustedClients) != len(that1.TrustedClients) {
		return false
	}
	for i := range this.TrustedClients {
		if !this.TrustedClients[i].Equal(that1.TrustedClients[i]) {
			return false
		}
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if this.DataSample != that1.DataSample {
		return false
	}
	if this.ContinueMitigationActionHdr != that1.ContinueMitigationActionHdr {
		return false
	}
	if this.Loglevel != that1.Loglevel {
		return false
	}
	return true
}
func (this *CloudfrontType_DisableJsInsert) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudfrontType_DisableJsInsert)
	if !ok {
		that2, ok := that.(CloudfrontType_DisableJsInsert)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableJsInsert.Equal(that1.DisableJsInsert) {
		return false
	}
	return true
}
func (this *CloudfrontType_ManualJsInsert) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudfrontType_ManualJsInsert)
	if !ok {
		that2, ok := that.(CloudfrontType_ManualJsInsert)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ManualJsInsert.Equal(that1.ManualJsInsert) {
		return false
	}
	return true
}
func (this *CloudfrontType_JsInsertAllPages) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudfrontType_JsInsertAllPages)
	if !ok {
		that2, ok := that.(CloudfrontType_JsInsertAllPages)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.JsInsertAllPages.Equal(that1.JsInsertAllPages) {
		return false
	}
	return true
}
func (this *CloudfrontType_JsInsertAllPagesExcept) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudfrontType_JsInsertAllPagesExcept)
	if !ok {
		that2, ok := that.(CloudfrontType_JsInsertAllPagesExcept)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.JsInsertAllPagesExcept.Equal(that1.JsInsertAllPagesExcept) {
		return false
	}
	return true
}
func (this *CloudfrontType_JsInsertionRules) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudfrontType_JsInsertionRules)
	if !ok {
		that2, ok := that.(CloudfrontType_JsInsertionRules)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.JsInsertionRules.Equal(that1.JsInsertionRules) {
		return false
	}
	return true
}
func (this *CloudfrontType_DisableMobileSdk) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudfrontType_DisableMobileSdk)
	if !ok {
		that2, ok := that.(CloudfrontType_DisableMobileSdk)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableMobileSdk.Equal(that1.DisableMobileSdk) {
		return false
	}
	return true
}
func (this *CloudfrontType_MobileSdkConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudfrontType_MobileSdkConfig)
	if !ok {
		that2, ok := that.(CloudfrontType_MobileSdkConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MobileSdkConfig.Equal(that1.MobileSdkConfig) {
		return false
	}
	return true
}
func (this *CloudfrontType_DisableAwsConfiguration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudfrontType_DisableAwsConfiguration)
	if !ok {
		that2, ok := that.(CloudfrontType_DisableAwsConfiguration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableAwsConfiguration.Equal(that1.DisableAwsConfiguration) {
		return false
	}
	return true
}
func (this *CloudfrontType_AwsConfigurationIdSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudfrontType_AwsConfigurationIdSelector)
	if !ok {
		that2, ok := that.(CloudfrontType_AwsConfigurationIdSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsConfigurationIdSelector.Equal(that1.AwsConfigurationIdSelector) {
		return false
	}
	return true
}
func (this *CloudfrontType_AwsConfigurationTagSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudfrontType_AwsConfigurationTagSelector)
	if !ok {
		that2, ok := that.(CloudfrontType_AwsConfigurationTagSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsConfigurationTagSelector.Equal(that1.AwsConfigurationTagSelector) {
		return false
	}
	return true
}
func (this *ClientBypassRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClientBypassRule)
	if !ok {
		that2, ok := that.(ClientBypassRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if that1.ClientSourceChoice == nil {
		if this.ClientSourceChoice != nil {
			return false
		}
	} else if this.ClientSourceChoice == nil {
		return false
	} else if !this.ClientSourceChoice.Equal(that1.ClientSourceChoice) {
		return false
	}
	return true
}
func (this *ClientBypassRule_IpPrefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClientBypassRule_IpPrefix)
	if !ok {
		that2, ok := that.(ClientBypassRule_IpPrefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IpPrefix != that1.IpPrefix {
		return false
	}
	return true
}
func (this *ClientBypassRule_HttpHeader) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClientBypassRule_HttpHeader)
	if !ok {
		that2, ok := that.(ClientBypassRule_HttpHeader)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HttpHeader.Equal(that1.HttpHeader) {
		return false
	}
	return true
}
func (this *HeaderMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType)
	if !ok {
		that2, ok := that.(HeaderMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.ValueMatch == nil {
		if this.ValueMatch != nil {
			return false
		}
	} else if this.ValueMatch == nil {
		return false
	} else if !this.ValueMatch.Equal(that1.ValueMatch) {
		return false
	}
	return true
}
func (this *HeaderMatcherType_Exact) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_Exact)
	if !ok {
		that2, ok := that.(HeaderMatcherType_Exact)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Exact != that1.Exact {
		return false
	}
	return true
}
func (this *HeaderMatcherType_Regex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_Regex)
	if !ok {
		that2, ok := that.(HeaderMatcherType_Regex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Regex != that1.Regex {
		return false
	}
	return true
}
func (this *HttpHeaderMatcherList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HttpHeaderMatcherList)
	if !ok {
		that2, ok := that.(HttpHeaderMatcherList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	return true
}
func (this *ProtectedEndpointType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtectedEndpointType)
	if !ok {
		that2, ok := that.(ProtectedEndpointType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if that1.DomainMatcherChoice == nil {
		if this.DomainMatcherChoice != nil {
			return false
		}
	} else if this.DomainMatcherChoice == nil {
		return false
	} else if !this.DomainMatcherChoice.Equal(that1.DomainMatcherChoice) {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if len(this.HttpMethods) != len(that1.HttpMethods) {
		return false
	}
	for i := range this.HttpMethods {
		if this.HttpMethods[i] != that1.HttpMethods[i] {
			return false
		}
	}
	if that1.ClientTypeChoice == nil {
		if this.ClientTypeChoice != nil {
			return false
		}
	} else if this.ClientTypeChoice == nil {
		return false
	} else if !this.ClientTypeChoice.Equal(that1.ClientTypeChoice) {
		return false
	}
	if that1.FlowLabelChoice == nil {
		if this.FlowLabelChoice != nil {
			return false
		}
	} else if this.FlowLabelChoice == nil {
		return false
	} else if !this.FlowLabelChoice.Equal(that1.FlowLabelChoice) {
		return false
	}
	return true
}
func (this *ProtectedEndpointType_AnyDomain) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtectedEndpointType_AnyDomain)
	if !ok {
		that2, ok := that.(ProtectedEndpointType_AnyDomain)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDomain.Equal(that1.AnyDomain) {
		return false
	}
	return true
}
func (this *ProtectedEndpointType_Domain) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtectedEndpointType_Domain)
	if !ok {
		that2, ok := that.(ProtectedEndpointType_Domain)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Domain.Equal(that1.Domain) {
		return false
	}
	return true
}
func (this *ProtectedEndpointType_WebClient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtectedEndpointType_WebClient)
	if !ok {
		that2, ok := that.(ProtectedEndpointType_WebClient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WebClient.Equal(that1.WebClient) {
		return false
	}
	return true
}
func (this *ProtectedEndpointType_MobileClient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtectedEndpointType_MobileClient)
	if !ok {
		that2, ok := that.(ProtectedEndpointType_MobileClient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MobileClient.Equal(that1.MobileClient) {
		return false
	}
	return true
}
func (this *ProtectedEndpointType_WebMobileClient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtectedEndpointType_WebMobileClient)
	if !ok {
		that2, ok := that.(ProtectedEndpointType_WebMobileClient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WebMobileClient.Equal(that1.WebMobileClient) {
		return false
	}
	return true
}
func (this *ProtectedEndpointType_UndefinedFlowLabel) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtectedEndpointType_UndefinedFlowLabel)
	if !ok {
		that2, ok := that.(ProtectedEndpointType_UndefinedFlowLabel)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UndefinedFlowLabel.Equal(that1.UndefinedFlowLabel) {
		return false
	}
	return true
}
func (this *ProtectedEndpointType_FlowLabel) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtectedEndpointType_FlowLabel)
	if !ok {
		that2, ok := that.(ProtectedEndpointType_FlowLabel)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FlowLabel.Equal(that1.FlowLabel) {
		return false
	}
	return true
}
func (this *WebClientType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WebClientType)
	if !ok {
		that2, ok := that.(WebClientType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Mitigation == nil {
		if this.Mitigation != nil {
			return false
		}
	} else if this.Mitigation == nil {
		return false
	} else if !this.Mitigation.Equal(that1.Mitigation) {
		return false
	}
	return true
}
func (this *WebClientType_Continue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WebClientType_Continue)
	if !ok {
		that2, ok := that.(WebClientType_Continue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Continue.Equal(that1.Continue) {
		return false
	}
	return true
}
func (this *WebClientType_Redirect) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WebClientType_Redirect)
	if !ok {
		that2, ok := that.(WebClientType_Redirect)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Redirect.Equal(that1.Redirect) {
		return false
	}
	return true
}
func (this *WebClientType_Block) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WebClientType_Block)
	if !ok {
		that2, ok := that.(WebClientType_Block)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Block.Equal(that1.Block) {
		return false
	}
	return true
}
func (this *MobileClientType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MobileClientType)
	if !ok {
		that2, ok := that.(MobileClientType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Mitigation == nil {
		if this.Mitigation != nil {
			return false
		}
	} else if this.Mitigation == nil {
		return false
	} else if !this.Mitigation.Equal(that1.Mitigation) {
		return false
	}
	return true
}
func (this *MobileClientType_Continue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MobileClientType_Continue)
	if !ok {
		that2, ok := that.(MobileClientType_Continue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Continue.Equal(that1.Continue) {
		return false
	}
	return true
}
func (this *MobileClientType_Block) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MobileClientType_Block)
	if !ok {
		that2, ok := that.(MobileClientType_Block)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Block.Equal(that1.Block) {
		return false
	}
	return true
}
func (this *WebMobileClientType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WebMobileClientType)
	if !ok {
		that2, ok := that.(WebMobileClientType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.WebMitigation == nil {
		if this.WebMitigation != nil {
			return false
		}
	} else if this.WebMitigation == nil {
		return false
	} else if !this.WebMitigation.Equal(that1.WebMitigation) {
		return false
	}
	if that1.MobileMitigation == nil {
		if this.MobileMitigation != nil {
			return false
		}
	} else if this.MobileMitigation == nil {
		return false
	} else if !this.MobileMitigation.Equal(that1.MobileMitigation) {
		return false
	}
	return true
}
func (this *WebMobileClientType_ContinueWeb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WebMobileClientType_ContinueWeb)
	if !ok {
		that2, ok := that.(WebMobileClientType_ContinueWeb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ContinueWeb.Equal(that1.ContinueWeb) {
		return false
	}
	return true
}
func (this *WebMobileClientType_RedirectWeb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WebMobileClientType_RedirectWeb)
	if !ok {
		that2, ok := that.(WebMobileClientType_RedirectWeb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RedirectWeb.Equal(that1.RedirectWeb) {
		return false
	}
	return true
}
func (this *WebMobileClientType_BlockWeb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WebMobileClientType_BlockWeb)
	if !ok {
		that2, ok := that.(WebMobileClientType_BlockWeb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BlockWeb.Equal(that1.BlockWeb) {
		return false
	}
	return true
}
func (this *WebMobileClientType_ContinueMobile) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WebMobileClientType_ContinueMobile)
	if !ok {
		that2, ok := that.(WebMobileClientType_ContinueMobile)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ContinueMobile.Equal(that1.ContinueMobile) {
		return false
	}
	return true
}
func (this *WebMobileClientType_BlockMobile) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WebMobileClientType_BlockMobile)
	if !ok {
		that2, ok := that.(WebMobileClientType_BlockMobile)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BlockMobile.Equal(that1.BlockMobile) {
		return false
	}
	return true
}
func (this *ContinueMitigationChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContinueMitigationChoiceType)
	if !ok {
		that2, ok := that.(ContinueMitigationChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AddHeaderChoice == nil {
		if this.AddHeaderChoice != nil {
			return false
		}
	} else if this.AddHeaderChoice == nil {
		return false
	} else if !this.AddHeaderChoice.Equal(that1.AddHeaderChoice) {
		return false
	}
	return true
}
func (this *ContinueMitigationChoiceType_NoHeader) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContinueMitigationChoiceType_NoHeader)
	if !ok {
		that2, ok := that.(ContinueMitigationChoiceType_NoHeader)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoHeader.Equal(that1.NoHeader) {
		return false
	}
	return true
}
func (this *ContinueMitigationChoiceType_AddHeader) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContinueMitigationChoiceType_AddHeader)
	if !ok {
		that2, ok := that.(ContinueMitigationChoiceType_AddHeader)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AddHeader.Equal(that1.AddHeader) {
		return false
	}
	return true
}
func (this *BlockMitigationChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BlockMitigationChoiceType)
	if !ok {
		that2, ok := that.(BlockMitigationChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.ContentType != that1.ContentType {
		return false
	}
	if this.Body != that1.Body {
		return false
	}
	return true
}
func (this *BlockMobileMitigationChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BlockMobileMitigationChoiceType)
	if !ok {
		that2, ok := that.(BlockMobileMitigationChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.ContentType != that1.ContentType {
		return false
	}
	if this.Body != that1.Body {
		return false
	}
	return true
}
func (this *RedirectMitigationChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RedirectMitigationChoiceType)
	if !ok {
		that2, ok := that.(RedirectMitigationChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Location != that1.Location {
		return false
	}
	return true
}
func (this *JavaScriptInsertType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JavaScriptInsertType)
	if !ok {
		that2, ok := that.(JavaScriptInsertType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.JsDownloadPath != that1.JsDownloadPath {
		return false
	}
	if this.JavascriptMode != that1.JavascriptMode {
		return false
	}
	if this.JavascriptLocation != that1.JavascriptLocation {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	if len(this.ExcludeList) != len(that1.ExcludeList) {
		return false
	}
	for i := range this.ExcludeList {
		if !this.ExcludeList[i].Equal(that1.ExcludeList[i]) {
			return false
		}
	}
	return true
}
func (this *JavaScriptInsertAllWithExceptionsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JavaScriptInsertAllWithExceptionsType)
	if !ok {
		that2, ok := that.(JavaScriptInsertAllWithExceptionsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.JsDownloadPath != that1.JsDownloadPath {
		return false
	}
	if this.JavascriptLocation != that1.JavascriptLocation {
		return false
	}
	if len(this.ExcludeList) != len(that1.ExcludeList) {
		return false
	}
	for i := range this.ExcludeList {
		if !this.ExcludeList[i].Equal(that1.ExcludeList[i]) {
			return false
		}
	}
	return true
}
func (this *JavaScriptInsertManualType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JavaScriptInsertManualType)
	if !ok {
		that2, ok := that.(JavaScriptInsertManualType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.JavascriptMode != that1.JavascriptMode {
		return false
	}
	if this.JsDownloadPath != that1.JsDownloadPath {
		return false
	}
	return true
}
func (this *JavaScriptInsertAllType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JavaScriptInsertAllType)
	if !ok {
		that2, ok := that.(JavaScriptInsertAllType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.JsDownloadPath != that1.JsDownloadPath {
		return false
	}
	if this.JavascriptLocation != that1.JavascriptLocation {
		return false
	}
	return true
}
func (this *JavaScriptInsertionRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JavaScriptInsertionRule)
	if !ok {
		that2, ok := that.(JavaScriptInsertionRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if that1.DomainMatcherChoice == nil {
		if this.DomainMatcherChoice != nil {
			return false
		}
	} else if this.DomainMatcherChoice == nil {
		return false
	} else if !this.DomainMatcherChoice.Equal(that1.DomainMatcherChoice) {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if that1.UriPath == nil {
		if this.UriPath != nil {
			return false
		}
	} else if this.UriPath == nil {
		return false
	} else if !this.UriPath.Equal(that1.UriPath) {
		return false
	}
	return true
}
func (this *JavaScriptInsertionRule_AnyDomain) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JavaScriptInsertionRule_AnyDomain)
	if !ok {
		that2, ok := that.(JavaScriptInsertionRule_AnyDomain)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDomain.Equal(that1.AnyDomain) {
		return false
	}
	return true
}
func (this *JavaScriptInsertionRule_Domain) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JavaScriptInsertionRule_Domain)
	if !ok {
		that2, ok := that.(JavaScriptInsertionRule_Domain)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Domain.Equal(that1.Domain) {
		return false
	}
	return true
}
func (this *JavaScriptInsertionRule_Prefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JavaScriptInsertionRule_Prefix)
	if !ok {
		that2, ok := that.(JavaScriptInsertionRule_Prefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Prefix != that1.Prefix {
		return false
	}
	return true
}
func (this *JavaScriptInsertionRule_ExactPath) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JavaScriptInsertionRule_ExactPath)
	if !ok {
		that2, ok := that.(JavaScriptInsertionRule_ExactPath)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExactPath != that1.ExactPath {
		return false
	}
	return true
}
func (this *JavaScriptInsertionRule_Glob) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JavaScriptInsertionRule_Glob)
	if !ok {
		that2, ok := that.(JavaScriptInsertionRule_Glob)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Glob != that1.Glob {
		return false
	}
	return true
}
func (this *JavaScriptExclusionRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JavaScriptExclusionRule)
	if !ok {
		that2, ok := that.(JavaScriptExclusionRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if that1.DomainMatcherChoice == nil {
		if this.DomainMatcherChoice != nil {
			return false
		}
	} else if this.DomainMatcherChoice == nil {
		return false
	} else if !this.DomainMatcherChoice.Equal(that1.DomainMatcherChoice) {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	return true
}
func (this *JavaScriptExclusionRule_AnyDomain) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JavaScriptExclusionRule_AnyDomain)
	if !ok {
		that2, ok := that.(JavaScriptExclusionRule_AnyDomain)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDomain.Equal(that1.AnyDomain) {
		return false
	}
	return true
}
func (this *JavaScriptExclusionRule_Domain) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JavaScriptExclusionRule_Domain)
	if !ok {
		that2, ok := that.(JavaScriptExclusionRule_Domain)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Domain.Equal(that1.Domain) {
		return false
	}
	return true
}
func (this *MobileSDKConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MobileSDKConfigType)
	if !ok {
		that2, ok := that.(MobileSDKConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MobileIdentifier.Equal(that1.MobileIdentifier) {
		return false
	}
	return true
}
func (this *MobileTrafficIdentifierType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MobileTrafficIdentifierType)
	if !ok {
		that2, ok := that.(MobileTrafficIdentifierType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	return true
}
func (this *DistributionTagList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DistributionTagList)
	if !ok {
		that2, ok := that.(DistributionTagList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	return true
}
func (this *DistributionIDList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DistributionIDList)
	if !ok {
		that2, ok := that.(DistributionIDList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ids) != len(that1.Ids) {
		return false
	}
	for i := range this.Ids {
		if this.Ids[i] != that1.Ids[i] {
			return false
		}
	}
	return true
}
func (this *CloudfrontType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 22)
	s = append(s, "&cloudfront.CloudfrontType{")
	if this.ProtectedEndpoints != nil {
		s = append(s, "ProtectedEndpoints: "+fmt.Sprintf("%#v", this.ProtectedEndpoints)+",\n")
	}
	s = append(s, "JsDownloadPath: "+fmt.Sprintf("%#v", this.JsDownloadPath)+",\n")
	if this.JavaScriptChoice != nil {
		s = append(s, "JavaScriptChoice: "+fmt.Sprintf("%#v", this.JavaScriptChoice)+",\n")
	}
	if this.MobileSdkChoice != nil {
		s = append(s, "MobileSdkChoice: "+fmt.Sprintf("%#v", this.MobileSdkChoice)+",\n")
	}
	s = append(s, "AwsAccountNo: "+fmt.Sprintf("%#v", this.AwsAccountNo)+",\n")
	if this.AwsConfigurationTypeChoice != nil {
		s = append(s, "AwsConfigurationTypeChoice: "+fmt.Sprintf("%#v", this.AwsConfigurationTypeChoice)+",\n")
	}
	if this.TrustedClients != nil {
		s = append(s, "TrustedClients: "+fmt.Sprintf("%#v", this.TrustedClients)+",\n")
	}
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "DataSample: "+fmt.Sprintf("%#v", this.DataSample)+",\n")
	s = append(s, "ContinueMitigationActionHdr: "+fmt.Sprintf("%#v", this.ContinueMitigationActionHdr)+",\n")
	s = append(s, "Loglevel: "+fmt.Sprintf("%#v", this.Loglevel)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudfrontType_DisableJsInsert) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.CloudfrontType_DisableJsInsert{` +
		`DisableJsInsert:` + fmt.Sprintf("%#v", this.DisableJsInsert) + `}`}, ", ")
	return s
}
func (this *CloudfrontType_ManualJsInsert) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.CloudfrontType_ManualJsInsert{` +
		`ManualJsInsert:` + fmt.Sprintf("%#v", this.ManualJsInsert) + `}`}, ", ")
	return s
}
func (this *CloudfrontType_JsInsertAllPages) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.CloudfrontType_JsInsertAllPages{` +
		`JsInsertAllPages:` + fmt.Sprintf("%#v", this.JsInsertAllPages) + `}`}, ", ")
	return s
}
func (this *CloudfrontType_JsInsertAllPagesExcept) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.CloudfrontType_JsInsertAllPagesExcept{` +
		`JsInsertAllPagesExcept:` + fmt.Sprintf("%#v", this.JsInsertAllPagesExcept) + `}`}, ", ")
	return s
}
func (this *CloudfrontType_JsInsertionRules) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.CloudfrontType_JsInsertionRules{` +
		`JsInsertionRules:` + fmt.Sprintf("%#v", this.JsInsertionRules) + `}`}, ", ")
	return s
}
func (this *CloudfrontType_DisableMobileSdk) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.CloudfrontType_DisableMobileSdk{` +
		`DisableMobileSdk:` + fmt.Sprintf("%#v", this.DisableMobileSdk) + `}`}, ", ")
	return s
}
func (this *CloudfrontType_MobileSdkConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.CloudfrontType_MobileSdkConfig{` +
		`MobileSdkConfig:` + fmt.Sprintf("%#v", this.MobileSdkConfig) + `}`}, ", ")
	return s
}
func (this *CloudfrontType_DisableAwsConfiguration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.CloudfrontType_DisableAwsConfiguration{` +
		`DisableAwsConfiguration:` + fmt.Sprintf("%#v", this.DisableAwsConfiguration) + `}`}, ", ")
	return s
}
func (this *CloudfrontType_AwsConfigurationIdSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.CloudfrontType_AwsConfigurationIdSelector{` +
		`AwsConfigurationIdSelector:` + fmt.Sprintf("%#v", this.AwsConfigurationIdSelector) + `}`}, ", ")
	return s
}
func (this *CloudfrontType_AwsConfigurationTagSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.CloudfrontType_AwsConfigurationTagSelector{` +
		`AwsConfigurationTagSelector:` + fmt.Sprintf("%#v", this.AwsConfigurationTagSelector) + `}`}, ", ")
	return s
}
func (this *ClientBypassRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudfront.ClientBypassRule{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.ClientSourceChoice != nil {
		s = append(s, "ClientSourceChoice: "+fmt.Sprintf("%#v", this.ClientSourceChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ClientBypassRule_IpPrefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.ClientBypassRule_IpPrefix{` +
		`IpPrefix:` + fmt.Sprintf("%#v", this.IpPrefix) + `}`}, ", ")
	return s
}
func (this *ClientBypassRule_HttpHeader) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.ClientBypassRule_HttpHeader{` +
		`HttpHeader:` + fmt.Sprintf("%#v", this.HttpHeader) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudfront.HeaderMatcherType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.ValueMatch != nil {
		s = append(s, "ValueMatch: "+fmt.Sprintf("%#v", this.ValueMatch)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HeaderMatcherType_Exact) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.HeaderMatcherType_Exact{` +
		`Exact:` + fmt.Sprintf("%#v", this.Exact) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType_Regex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.HeaderMatcherType_Regex{` +
		`Regex:` + fmt.Sprintf("%#v", this.Regex) + `}`}, ", ")
	return s
}
func (this *HttpHeaderMatcherList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudfront.HttpHeaderMatcherList{")
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtectedEndpointType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&cloudfront.ProtectedEndpointType{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.DomainMatcherChoice != nil {
		s = append(s, "DomainMatcherChoice: "+fmt.Sprintf("%#v", this.DomainMatcherChoice)+",\n")
	}
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "HttpMethods: "+fmt.Sprintf("%#v", this.HttpMethods)+",\n")
	if this.ClientTypeChoice != nil {
		s = append(s, "ClientTypeChoice: "+fmt.Sprintf("%#v", this.ClientTypeChoice)+",\n")
	}
	if this.FlowLabelChoice != nil {
		s = append(s, "FlowLabelChoice: "+fmt.Sprintf("%#v", this.FlowLabelChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtectedEndpointType_AnyDomain) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.ProtectedEndpointType_AnyDomain{` +
		`AnyDomain:` + fmt.Sprintf("%#v", this.AnyDomain) + `}`}, ", ")
	return s
}
func (this *ProtectedEndpointType_Domain) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.ProtectedEndpointType_Domain{` +
		`Domain:` + fmt.Sprintf("%#v", this.Domain) + `}`}, ", ")
	return s
}
func (this *ProtectedEndpointType_WebClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.ProtectedEndpointType_WebClient{` +
		`WebClient:` + fmt.Sprintf("%#v", this.WebClient) + `}`}, ", ")
	return s
}
func (this *ProtectedEndpointType_MobileClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.ProtectedEndpointType_MobileClient{` +
		`MobileClient:` + fmt.Sprintf("%#v", this.MobileClient) + `}`}, ", ")
	return s
}
func (this *ProtectedEndpointType_WebMobileClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.ProtectedEndpointType_WebMobileClient{` +
		`WebMobileClient:` + fmt.Sprintf("%#v", this.WebMobileClient) + `}`}, ", ")
	return s
}
func (this *ProtectedEndpointType_UndefinedFlowLabel) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.ProtectedEndpointType_UndefinedFlowLabel{` +
		`UndefinedFlowLabel:` + fmt.Sprintf("%#v", this.UndefinedFlowLabel) + `}`}, ", ")
	return s
}
func (this *ProtectedEndpointType_FlowLabel) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.ProtectedEndpointType_FlowLabel{` +
		`FlowLabel:` + fmt.Sprintf("%#v", this.FlowLabel) + `}`}, ", ")
	return s
}
func (this *WebClientType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudfront.WebClientType{")
	if this.Mitigation != nil {
		s = append(s, "Mitigation: "+fmt.Sprintf("%#v", this.Mitigation)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WebClientType_Continue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.WebClientType_Continue{` +
		`Continue:` + fmt.Sprintf("%#v", this.Continue) + `}`}, ", ")
	return s
}
func (this *WebClientType_Redirect) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.WebClientType_Redirect{` +
		`Redirect:` + fmt.Sprintf("%#v", this.Redirect) + `}`}, ", ")
	return s
}
func (this *WebClientType_Block) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.WebClientType_Block{` +
		`Block:` + fmt.Sprintf("%#v", this.Block) + `}`}, ", ")
	return s
}
func (this *MobileClientType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloudfront.MobileClientType{")
	if this.Mitigation != nil {
		s = append(s, "Mitigation: "+fmt.Sprintf("%#v", this.Mitigation)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MobileClientType_Continue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.MobileClientType_Continue{` +
		`Continue:` + fmt.Sprintf("%#v", this.Continue) + `}`}, ", ")
	return s
}
func (this *MobileClientType_Block) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.MobileClientType_Block{` +
		`Block:` + fmt.Sprintf("%#v", this.Block) + `}`}, ", ")
	return s
}
func (this *WebMobileClientType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&cloudfront.WebMobileClientType{")
	if this.WebMitigation != nil {
		s = append(s, "WebMitigation: "+fmt.Sprintf("%#v", this.WebMitigation)+",\n")
	}
	if this.MobileMitigation != nil {
		s = append(s, "MobileMitigation: "+fmt.Sprintf("%#v", this.MobileMitigation)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WebMobileClientType_ContinueWeb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.WebMobileClientType_ContinueWeb{` +
		`ContinueWeb:` + fmt.Sprintf("%#v", this.ContinueWeb) + `}`}, ", ")
	return s
}
func (this *WebMobileClientType_RedirectWeb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.WebMobileClientType_RedirectWeb{` +
		`RedirectWeb:` + fmt.Sprintf("%#v", this.RedirectWeb) + `}`}, ", ")
	return s
}
func (this *WebMobileClientType_BlockWeb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.WebMobileClientType_BlockWeb{` +
		`BlockWeb:` + fmt.Sprintf("%#v", this.BlockWeb) + `}`}, ", ")
	return s
}
func (this *WebMobileClientType_ContinueMobile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.WebMobileClientType_ContinueMobile{` +
		`ContinueMobile:` + fmt.Sprintf("%#v", this.ContinueMobile) + `}`}, ", ")
	return s
}
func (this *WebMobileClientType_BlockMobile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.WebMobileClientType_BlockMobile{` +
		`BlockMobile:` + fmt.Sprintf("%#v", this.BlockMobile) + `}`}, ", ")
	return s
}
func (this *ContinueMitigationChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloudfront.ContinueMitigationChoiceType{")
	if this.AddHeaderChoice != nil {
		s = append(s, "AddHeaderChoice: "+fmt.Sprintf("%#v", this.AddHeaderChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContinueMitigationChoiceType_NoHeader) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.ContinueMitigationChoiceType_NoHeader{` +
		`NoHeader:` + fmt.Sprintf("%#v", this.NoHeader) + `}`}, ", ")
	return s
}
func (this *ContinueMitigationChoiceType_AddHeader) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.ContinueMitigationChoiceType_AddHeader{` +
		`AddHeader:` + fmt.Sprintf("%#v", this.AddHeader) + `}`}, ", ")
	return s
}
func (this *BlockMitigationChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudfront.BlockMitigationChoiceType{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "ContentType: "+fmt.Sprintf("%#v", this.ContentType)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BlockMobileMitigationChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudfront.BlockMobileMitigationChoiceType{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "ContentType: "+fmt.Sprintf("%#v", this.ContentType)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RedirectMitigationChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloudfront.RedirectMitigationChoiceType{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *JavaScriptInsertType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&cloudfront.JavaScriptInsertType{")
	s = append(s, "JsDownloadPath: "+fmt.Sprintf("%#v", this.JsDownloadPath)+",\n")
	s = append(s, "JavascriptMode: "+fmt.Sprintf("%#v", this.JavascriptMode)+",\n")
	s = append(s, "JavascriptLocation: "+fmt.Sprintf("%#v", this.JavascriptLocation)+",\n")
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	if this.ExcludeList != nil {
		s = append(s, "ExcludeList: "+fmt.Sprintf("%#v", this.ExcludeList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *JavaScriptInsertAllWithExceptionsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloudfront.JavaScriptInsertAllWithExceptionsType{")
	s = append(s, "JsDownloadPath: "+fmt.Sprintf("%#v", this.JsDownloadPath)+",\n")
	s = append(s, "JavascriptLocation: "+fmt.Sprintf("%#v", this.JavascriptLocation)+",\n")
	if this.ExcludeList != nil {
		s = append(s, "ExcludeList: "+fmt.Sprintf("%#v", this.ExcludeList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *JavaScriptInsertManualType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloudfront.JavaScriptInsertManualType{")
	s = append(s, "JavascriptMode: "+fmt.Sprintf("%#v", this.JavascriptMode)+",\n")
	s = append(s, "JsDownloadPath: "+fmt.Sprintf("%#v", this.JsDownloadPath)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *JavaScriptInsertAllType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloudfront.JavaScriptInsertAllType{")
	s = append(s, "JsDownloadPath: "+fmt.Sprintf("%#v", this.JsDownloadPath)+",\n")
	s = append(s, "JavascriptLocation: "+fmt.Sprintf("%#v", this.JavascriptLocation)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *JavaScriptInsertionRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&cloudfront.JavaScriptInsertionRule{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.DomainMatcherChoice != nil {
		s = append(s, "DomainMatcherChoice: "+fmt.Sprintf("%#v", this.DomainMatcherChoice)+",\n")
	}
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	if this.UriPath != nil {
		s = append(s, "UriPath: "+fmt.Sprintf("%#v", this.UriPath)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *JavaScriptInsertionRule_AnyDomain) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.JavaScriptInsertionRule_AnyDomain{` +
		`AnyDomain:` + fmt.Sprintf("%#v", this.AnyDomain) + `}`}, ", ")
	return s
}
func (this *JavaScriptInsertionRule_Domain) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.JavaScriptInsertionRule_Domain{` +
		`Domain:` + fmt.Sprintf("%#v", this.Domain) + `}`}, ", ")
	return s
}
func (this *JavaScriptInsertionRule_Prefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.JavaScriptInsertionRule_Prefix{` +
		`Prefix:` + fmt.Sprintf("%#v", this.Prefix) + `}`}, ", ")
	return s
}
func (this *JavaScriptInsertionRule_ExactPath) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.JavaScriptInsertionRule_ExactPath{` +
		`ExactPath:` + fmt.Sprintf("%#v", this.ExactPath) + `}`}, ", ")
	return s
}
func (this *JavaScriptInsertionRule_Glob) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.JavaScriptInsertionRule_Glob{` +
		`Glob:` + fmt.Sprintf("%#v", this.Glob) + `}`}, ", ")
	return s
}
func (this *JavaScriptExclusionRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cloudfront.JavaScriptExclusionRule{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.DomainMatcherChoice != nil {
		s = append(s, "DomainMatcherChoice: "+fmt.Sprintf("%#v", this.DomainMatcherChoice)+",\n")
	}
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *JavaScriptExclusionRule_AnyDomain) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.JavaScriptExclusionRule_AnyDomain{` +
		`AnyDomain:` + fmt.Sprintf("%#v", this.AnyDomain) + `}`}, ", ")
	return s
}
func (this *JavaScriptExclusionRule_Domain) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloudfront.JavaScriptExclusionRule_Domain{` +
		`Domain:` + fmt.Sprintf("%#v", this.Domain) + `}`}, ", ")
	return s
}
func (this *MobileSDKConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudfront.MobileSDKConfigType{")
	if this.MobileIdentifier != nil {
		s = append(s, "MobileIdentifier: "+fmt.Sprintf("%#v", this.MobileIdentifier)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MobileTrafficIdentifierType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudfront.MobileTrafficIdentifierType{")
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DistributionTagList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudfront.DistributionTagList{")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DistributionIDList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloudfront.DistributionIDList{")
	s = append(s, "Ids: "+fmt.Sprintf("%#v", this.Ids)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *CloudfrontType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudfrontType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudfrontType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.JavaScriptChoice != nil {
		{
			size := m.JavaScriptChoice.Size()
			i -= size
			if _, err := m.JavaScriptChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Loglevel != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Loglevel))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb8
	}
	if len(m.ContinueMitigationActionHdr) > 0 {
		i -= len(m.ContinueMitigationActionHdr)
		copy(dAtA[i:], m.ContinueMitigationActionHdr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ContinueMitigationActionHdr)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb2
	}
	if m.DataSample != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DataSample))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.Timeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.TrustedClients) > 0 {
		for iNdEx := len(m.TrustedClients) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrustedClients[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.MobileSdkChoice != nil {
		{
			size := m.MobileSdkChoice.Size()
			i -= size
			if _, err := m.MobileSdkChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AwsConfigurationTypeChoice != nil {
		{
			size := m.AwsConfigurationTypeChoice.Size()
			i -= size
			if _, err := m.AwsConfigurationTypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.AwsAccountNo) > 0 {
		i -= len(m.AwsAccountNo)
		copy(dAtA[i:], m.AwsAccountNo)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AwsAccountNo)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.JsDownloadPath) > 0 {
		i -= len(m.JsDownloadPath)
		copy(dAtA[i:], m.JsDownloadPath)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.JsDownloadPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProtectedEndpoints) > 0 {
		for iNdEx := len(m.ProtectedEndpoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProtectedEndpoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CloudfrontType_DisableJsInsert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudfrontType_DisableJsInsert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableJsInsert != nil {
		{
			size, err := m.DisableJsInsert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CloudfrontType_JsInsertAllPages) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudfrontType_JsInsertAllPages) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JsInsertAllPages != nil {
		{
			size, err := m.JsInsertAllPages.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CloudfrontType_JsInsertAllPagesExcept) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudfrontType_JsInsertAllPagesExcept) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JsInsertAllPagesExcept != nil {
		{
			size, err := m.JsInsertAllPagesExcept.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *CloudfrontType_JsInsertionRules) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudfrontType_JsInsertionRules) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JsInsertionRules != nil {
		{
			size, err := m.JsInsertionRules.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *CloudfrontType_DisableAwsConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudfrontType_DisableAwsConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableAwsConfiguration != nil {
		{
			size, err := m.DisableAwsConfiguration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *CloudfrontType_AwsConfigurationIdSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudfrontType_AwsConfigurationIdSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsConfigurationIdSelector != nil {
		{
			size, err := m.AwsConfigurationIdSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *CloudfrontType_AwsConfigurationTagSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudfrontType_AwsConfigurationTagSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsConfigurationTagSelector != nil {
		{
			size, err := m.AwsConfigurationTagSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *CloudfrontType_DisableMobileSdk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudfrontType_DisableMobileSdk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableMobileSdk != nil {
		{
			size, err := m.DisableMobileSdk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *CloudfrontType_MobileSdkConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudfrontType_MobileSdkConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MobileSdkConfig != nil {
		{
			size, err := m.MobileSdkConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *CloudfrontType_ManualJsInsert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudfrontType_ManualJsInsert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ManualJsInsert != nil {
		{
			size, err := m.ManualJsInsert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ClientBypassRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientBypassRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientBypassRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClientSourceChoice != nil {
		{
			size := m.ClientSourceChoice.Size()
			i -= size
			if _, err := m.ClientSourceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientBypassRule_IpPrefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientBypassRule_IpPrefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.IpPrefix)
	copy(dAtA[i:], m.IpPrefix)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.IpPrefix)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *ClientBypassRule_HttpHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientBypassRule_HttpHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HttpHeader != nil {
		{
			size, err := m.HttpHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValueMatch != nil {
		{
			size := m.ValueMatch.Size()
			i -= size
			if _, err := m.ValueMatch.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeaderMatcherType_Exact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType_Exact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Exact)
	copy(dAtA[i:], m.Exact)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Exact)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherType_Regex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType_Regex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Regex)
	copy(dAtA[i:], m.Regex)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Regex)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *HttpHeaderMatcherList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpHeaderMatcherList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpHeaderMatcherList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProtectedEndpointType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtectedEndpointType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtectedEndpointType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FlowLabelChoice != nil {
		{
			size := m.FlowLabelChoice.Size()
			i -= size
			if _, err := m.FlowLabelChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ClientTypeChoice != nil {
		{
			size := m.ClientTypeChoice.Size()
			i -= size
			if _, err := m.ClientTypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.HttpMethods) > 0 {
		dAtA14 := make([]byte, len(m.HttpMethods)*10)
		var j13 int
		for _, num := range m.HttpMethods {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintTypes(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DomainMatcherChoice != nil {
		{
			size := m.DomainMatcherChoice.Size()
			i -= size
			if _, err := m.DomainMatcherChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProtectedEndpointType_AnyDomain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtectedEndpointType_AnyDomain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyDomain != nil {
		{
			size, err := m.AnyDomain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ProtectedEndpointType_Domain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtectedEndpointType_Domain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Domain != nil {
		{
			size, err := m.Domain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ProtectedEndpointType_WebClient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtectedEndpointType_WebClient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WebClient != nil {
		{
			size, err := m.WebClient.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *ProtectedEndpointType_MobileClient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtectedEndpointType_MobileClient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MobileClient != nil {
		{
			size, err := m.MobileClient.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *ProtectedEndpointType_WebMobileClient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtectedEndpointType_WebMobileClient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WebMobileClient != nil {
		{
			size, err := m.WebMobileClient.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *ProtectedEndpointType_UndefinedFlowLabel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtectedEndpointType_UndefinedFlowLabel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UndefinedFlowLabel != nil {
		{
			size, err := m.UndefinedFlowLabel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *ProtectedEndpointType_FlowLabel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtectedEndpointType_FlowLabel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FlowLabel != nil {
		{
			size, err := m.FlowLabel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *WebClientType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebClientType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebClientType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mitigation != nil {
		{
			size := m.Mitigation.Size()
			i -= size
			if _, err := m.Mitigation.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *WebClientType_Continue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebClientType_Continue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Continue != nil {
		{
			size, err := m.Continue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *WebClientType_Redirect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebClientType_Redirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Redirect != nil {
		{
			size, err := m.Redirect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *WebClientType_Block) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebClientType_Block) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *MobileClientType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MobileClientType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MobileClientType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mitigation != nil {
		{
			size := m.Mitigation.Size()
			i -= size
			if _, err := m.Mitigation.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MobileClientType_Continue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MobileClientType_Continue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Continue != nil {
		{
			size, err := m.Continue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MobileClientType_Block) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MobileClientType_Block) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *WebMobileClientType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebMobileClientType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebMobileClientType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MobileMitigation != nil {
		{
			size := m.MobileMitigation.Size()
			i -= size
			if _, err := m.MobileMitigation.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.WebMitigation != nil {
		{
			size := m.WebMitigation.Size()
			i -= size
			if _, err := m.WebMitigation.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *WebMobileClientType_ContinueWeb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebMobileClientType_ContinueWeb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ContinueWeb != nil {
		{
			size, err := m.ContinueWeb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *WebMobileClientType_RedirectWeb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebMobileClientType_RedirectWeb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RedirectWeb != nil {
		{
			size, err := m.RedirectWeb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *WebMobileClientType_BlockWeb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebMobileClientType_BlockWeb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BlockWeb != nil {
		{
			size, err := m.BlockWeb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *WebMobileClientType_ContinueMobile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebMobileClientType_ContinueMobile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ContinueMobile != nil {
		{
			size, err := m.ContinueMobile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *WebMobileClientType_BlockMobile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebMobileClientType_BlockMobile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BlockMobile != nil {
		{
			size, err := m.BlockMobile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *ContinueMitigationChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContinueMitigationChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContinueMitigationChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AddHeaderChoice != nil {
		{
			size := m.AddHeaderChoice.Size()
			i -= size
			if _, err := m.AddHeaderChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ContinueMitigationChoiceType_NoHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContinueMitigationChoiceType_NoHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoHeader != nil {
		{
			size, err := m.NoHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ContinueMitigationChoiceType_AddHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContinueMitigationChoiceType_AddHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddHeader != nil {
		{
			size, err := m.AddHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *BlockMitigationChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockMitigationChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockMitigationChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *BlockMobileMitigationChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockMobileMitigationChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockMobileMitigationChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *RedirectMitigationChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedirectMitigationChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RedirectMitigationChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *JavaScriptInsertType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JavaScriptInsertType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JavaScriptInsertType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.JavascriptMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.JavascriptMode))
		i--
		dAtA[i] = 0x30
	}
	if len(m.JsDownloadPath) > 0 {
		i -= len(m.JsDownloadPath)
		copy(dAtA[i:], m.JsDownloadPath)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.JsDownloadPath)))
		i--
		dAtA[i] = 0x2a
	}
	if m.JavascriptLocation != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.JavascriptLocation))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ExcludeList) > 0 {
		for iNdEx := len(m.ExcludeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExcludeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *JavaScriptInsertAllWithExceptionsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JavaScriptInsertAllWithExceptionsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JavaScriptInsertAllWithExceptionsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JsDownloadPath) > 0 {
		i -= len(m.JsDownloadPath)
		copy(dAtA[i:], m.JsDownloadPath)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.JsDownloadPath)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ExcludeList) > 0 {
		for iNdEx := len(m.ExcludeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExcludeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.JavascriptLocation != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.JavascriptLocation))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *JavaScriptInsertManualType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JavaScriptInsertManualType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JavaScriptInsertManualType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.JavascriptMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.JavascriptMode))
		i--
		dAtA[i] = 0x10
	}
	if len(m.JsDownloadPath) > 0 {
		i -= len(m.JsDownloadPath)
		copy(dAtA[i:], m.JsDownloadPath)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.JsDownloadPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JavaScriptInsertAllType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JavaScriptInsertAllType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JavaScriptInsertAllType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JsDownloadPath) > 0 {
		i -= len(m.JsDownloadPath)
		copy(dAtA[i:], m.JsDownloadPath)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.JsDownloadPath)))
		i--
		dAtA[i] = 0x2a
	}
	if m.JavascriptLocation != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.JavascriptLocation))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *JavaScriptInsertionRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JavaScriptInsertionRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JavaScriptInsertionRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UriPath != nil {
		{
			size := m.UriPath.Size()
			i -= size
			if _, err := m.UriPath.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x32
	}
	if m.DomainMatcherChoice != nil {
		{
			size := m.DomainMatcherChoice.Size()
			i -= size
			if _, err := m.DomainMatcherChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JavaScriptInsertionRule_AnyDomain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JavaScriptInsertionRule_AnyDomain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyDomain != nil {
		{
			size, err := m.AnyDomain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *JavaScriptInsertionRule_Domain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JavaScriptInsertionRule_Domain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Domain != nil {
		{
			size, err := m.Domain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *JavaScriptInsertionRule_Prefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JavaScriptInsertionRule_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Prefix)
	copy(dAtA[i:], m.Prefix)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Prefix)))
	i--
	dAtA[i] = 0x42
	return len(dAtA) - i, nil
}
func (m *JavaScriptInsertionRule_ExactPath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JavaScriptInsertionRule_ExactPath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ExactPath)
	copy(dAtA[i:], m.ExactPath)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ExactPath)))
	i--
	dAtA[i] = 0x4a
	return len(dAtA) - i, nil
}
func (m *JavaScriptInsertionRule_Glob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JavaScriptInsertionRule_Glob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Glob)
	copy(dAtA[i:], m.Glob)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Glob)))
	i--
	dAtA[i] = 0x52
	return len(dAtA) - i, nil
}
func (m *JavaScriptExclusionRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JavaScriptExclusionRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JavaScriptExclusionRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Path != nil {
		{
			size, err := m.Path.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DomainMatcherChoice != nil {
		{
			size := m.DomainMatcherChoice.Size()
			i -= size
			if _, err := m.DomainMatcherChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JavaScriptExclusionRule_AnyDomain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JavaScriptExclusionRule_AnyDomain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyDomain != nil {
		{
			size, err := m.AnyDomain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *JavaScriptExclusionRule_Domain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JavaScriptExclusionRule_Domain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Domain != nil {
		{
			size, err := m.Domain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *MobileSDKConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MobileSDKConfigType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MobileSDKConfigType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MobileIdentifier != nil {
		{
			size, err := m.MobileIdentifier.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MobileTrafficIdentifierType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MobileTrafficIdentifierType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MobileTrafficIdentifierType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DistributionTagList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistributionTagList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DistributionTagList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		keysForTags := make([]string, 0, len(m.Tags))
		for k := range m.Tags {
			keysForTags = append(keysForTags, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
		for iNdEx := len(keysForTags) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tags[string(keysForTags[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTags[iNdEx])
			copy(dAtA[i:], keysForTags[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForTags[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DistributionIDList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistributionIDList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DistributionIDList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ids) > 0 {
		for iNdEx := len(m.Ids) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ids[iNdEx])
			copy(dAtA[i:], m.Ids[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Ids[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CloudfrontType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ProtectedEndpoints) > 0 {
		for _, e := range m.ProtectedEndpoints {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.JsDownloadPath)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.JavaScriptChoice != nil {
		n += m.JavaScriptChoice.Size()
	}
	l = len(m.AwsAccountNo)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AwsConfigurationTypeChoice != nil {
		n += m.AwsConfigurationTypeChoice.Size()
	}
	if m.MobileSdkChoice != nil {
		n += m.MobileSdkChoice.Size()
	}
	if len(m.TrustedClients) > 0 {
		for _, e := range m.TrustedClients {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.Timeout != 0 {
		n += 2 + sovTypes(uint64(m.Timeout))
	}
	if m.DataSample != 0 {
		n += 2 + sovTypes(uint64(m.DataSample))
	}
	l = len(m.ContinueMitigationActionHdr)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.Loglevel != 0 {
		n += 2 + sovTypes(uint64(m.Loglevel))
	}
	return n
}

func (m *CloudfrontType_DisableJsInsert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableJsInsert != nil {
		l = m.DisableJsInsert.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CloudfrontType_JsInsertAllPages) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JsInsertAllPages != nil {
		l = m.JsInsertAllPages.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CloudfrontType_JsInsertAllPagesExcept) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JsInsertAllPagesExcept != nil {
		l = m.JsInsertAllPagesExcept.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CloudfrontType_JsInsertionRules) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JsInsertionRules != nil {
		l = m.JsInsertionRules.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CloudfrontType_DisableAwsConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableAwsConfiguration != nil {
		l = m.DisableAwsConfiguration.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CloudfrontType_AwsConfigurationIdSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsConfigurationIdSelector != nil {
		l = m.AwsConfigurationIdSelector.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CloudfrontType_AwsConfigurationTagSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsConfigurationTagSelector != nil {
		l = m.AwsConfigurationTagSelector.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CloudfrontType_DisableMobileSdk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableMobileSdk != nil {
		l = m.DisableMobileSdk.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CloudfrontType_MobileSdkConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MobileSdkConfig != nil {
		l = m.MobileSdkConfig.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CloudfrontType_ManualJsInsert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ManualJsInsert != nil {
		l = m.ManualJsInsert.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ClientBypassRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ClientSourceChoice != nil {
		n += m.ClientSourceChoice.Size()
	}
	return n
}

func (m *ClientBypassRule_IpPrefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IpPrefix)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ClientBypassRule_HttpHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpHeader != nil {
		l = m.HttpHeader.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ValueMatch != nil {
		n += m.ValueMatch.Size()
	}
	return n
}

func (m *HeaderMatcherType_Exact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Exact)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *HeaderMatcherType_Regex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Regex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *HttpHeaderMatcherList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ProtectedEndpointType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DomainMatcherChoice != nil {
		n += m.DomainMatcherChoice.Size()
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.HttpMethods) > 0 {
		l = 0
		for _, e := range m.HttpMethods {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.ClientTypeChoice != nil {
		n += m.ClientTypeChoice.Size()
	}
	if m.FlowLabelChoice != nil {
		n += m.FlowLabelChoice.Size()
	}
	return n
}

func (m *ProtectedEndpointType_AnyDomain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyDomain != nil {
		l = m.AnyDomain.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProtectedEndpointType_Domain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Domain != nil {
		l = m.Domain.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProtectedEndpointType_WebClient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WebClient != nil {
		l = m.WebClient.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProtectedEndpointType_MobileClient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MobileClient != nil {
		l = m.MobileClient.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProtectedEndpointType_WebMobileClient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WebMobileClient != nil {
		l = m.WebMobileClient.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProtectedEndpointType_UndefinedFlowLabel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UndefinedFlowLabel != nil {
		l = m.UndefinedFlowLabel.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProtectedEndpointType_FlowLabel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlowLabel != nil {
		l = m.FlowLabel.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WebClientType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mitigation != nil {
		n += m.Mitigation.Size()
	}
	return n
}

func (m *WebClientType_Continue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Continue != nil {
		l = m.Continue.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WebClientType_Redirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Redirect != nil {
		l = m.Redirect.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WebClientType_Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *MobileClientType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mitigation != nil {
		n += m.Mitigation.Size()
	}
	return n
}

func (m *MobileClientType_Continue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Continue != nil {
		l = m.Continue.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *MobileClientType_Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WebMobileClientType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WebMitigation != nil {
		n += m.WebMitigation.Size()
	}
	if m.MobileMitigation != nil {
		n += m.MobileMitigation.Size()
	}
	return n
}

func (m *WebMobileClientType_ContinueWeb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContinueWeb != nil {
		l = m.ContinueWeb.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WebMobileClientType_RedirectWeb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RedirectWeb != nil {
		l = m.RedirectWeb.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WebMobileClientType_BlockWeb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockWeb != nil {
		l = m.BlockWeb.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WebMobileClientType_ContinueMobile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContinueMobile != nil {
		l = m.ContinueMobile.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WebMobileClientType_BlockMobile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockMobile != nil {
		l = m.BlockMobile.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ContinueMitigationChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddHeaderChoice != nil {
		n += m.AddHeaderChoice.Size()
	}
	return n
}

func (m *ContinueMitigationChoiceType_NoHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoHeader != nil {
		l = m.NoHeader.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ContinueMitigationChoiceType_AddHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddHeader != nil {
		l = m.AddHeader.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BlockMitigationChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *BlockMobileMitigationChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RedirectMitigationChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *JavaScriptInsertType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ExcludeList) > 0 {
		for _, e := range m.ExcludeList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.JavascriptLocation != 0 {
		n += 1 + sovTypes(uint64(m.JavascriptLocation))
	}
	l = len(m.JsDownloadPath)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.JavascriptMode != 0 {
		n += 1 + sovTypes(uint64(m.JavascriptMode))
	}
	return n
}

func (m *JavaScriptInsertAllWithExceptionsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JavascriptLocation != 0 {
		n += 1 + sovTypes(uint64(m.JavascriptLocation))
	}
	if len(m.ExcludeList) > 0 {
		for _, e := range m.ExcludeList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.JsDownloadPath)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *JavaScriptInsertManualType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JsDownloadPath)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.JavascriptMode != 0 {
		n += 1 + sovTypes(uint64(m.JavascriptMode))
	}
	return n
}

func (m *JavaScriptInsertAllType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JavascriptLocation != 0 {
		n += 1 + sovTypes(uint64(m.JavascriptLocation))
	}
	l = len(m.JsDownloadPath)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *JavaScriptInsertionRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DomainMatcherChoice != nil {
		n += m.DomainMatcherChoice.Size()
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.UriPath != nil {
		n += m.UriPath.Size()
	}
	return n
}

func (m *JavaScriptInsertionRule_AnyDomain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyDomain != nil {
		l = m.AnyDomain.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *JavaScriptInsertionRule_Domain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Domain != nil {
		l = m.Domain.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *JavaScriptInsertionRule_Prefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Prefix)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *JavaScriptInsertionRule_ExactPath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExactPath)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *JavaScriptInsertionRule_Glob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Glob)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *JavaScriptExclusionRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DomainMatcherChoice != nil {
		n += m.DomainMatcherChoice.Size()
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *JavaScriptExclusionRule_AnyDomain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyDomain != nil {
		l = m.AnyDomain.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *JavaScriptExclusionRule_Domain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Domain != nil {
		l = m.Domain.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *MobileSDKConfigType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MobileIdentifier != nil {
		l = m.MobileIdentifier.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MobileTrafficIdentifierType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DistributionTagList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DistributionIDList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ids) > 0 {
		for _, s := range m.Ids {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *CloudfrontType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForProtectedEndpoints := "[]*ProtectedEndpointType{"
	for _, f := range this.ProtectedEndpoints {
		repeatedStringForProtectedEndpoints += strings.Replace(f.String(), "ProtectedEndpointType", "ProtectedEndpointType", 1) + ","
	}
	repeatedStringForProtectedEndpoints += "}"
	repeatedStringForTrustedClients := "[]*ClientBypassRule{"
	for _, f := range this.TrustedClients {
		repeatedStringForTrustedClients += strings.Replace(f.String(), "ClientBypassRule", "ClientBypassRule", 1) + ","
	}
	repeatedStringForTrustedClients += "}"
	s := strings.Join([]string{`&CloudfrontType{`,
		`ProtectedEndpoints:` + repeatedStringForProtectedEndpoints + `,`,
		`JsDownloadPath:` + fmt.Sprintf("%v", this.JsDownloadPath) + `,`,
		`JavaScriptChoice:` + fmt.Sprintf("%v", this.JavaScriptChoice) + `,`,
		`AwsAccountNo:` + fmt.Sprintf("%v", this.AwsAccountNo) + `,`,
		`AwsConfigurationTypeChoice:` + fmt.Sprintf("%v", this.AwsConfigurationTypeChoice) + `,`,
		`MobileSdkChoice:` + fmt.Sprintf("%v", this.MobileSdkChoice) + `,`,
		`TrustedClients:` + repeatedStringForTrustedClients + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`DataSample:` + fmt.Sprintf("%v", this.DataSample) + `,`,
		`ContinueMitigationActionHdr:` + fmt.Sprintf("%v", this.ContinueMitigationActionHdr) + `,`,
		`Loglevel:` + fmt.Sprintf("%v", this.Loglevel) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudfrontType_DisableJsInsert) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudfrontType_DisableJsInsert{`,
		`DisableJsInsert:` + strings.Replace(fmt.Sprintf("%v", this.DisableJsInsert), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudfrontType_JsInsertAllPages) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudfrontType_JsInsertAllPages{`,
		`JsInsertAllPages:` + strings.Replace(fmt.Sprintf("%v", this.JsInsertAllPages), "JavaScriptInsertAllType", "JavaScriptInsertAllType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudfrontType_JsInsertAllPagesExcept) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudfrontType_JsInsertAllPagesExcept{`,
		`JsInsertAllPagesExcept:` + strings.Replace(fmt.Sprintf("%v", this.JsInsertAllPagesExcept), "JavaScriptInsertAllWithExceptionsType", "JavaScriptInsertAllWithExceptionsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudfrontType_JsInsertionRules) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudfrontType_JsInsertionRules{`,
		`JsInsertionRules:` + strings.Replace(fmt.Sprintf("%v", this.JsInsertionRules), "JavaScriptInsertType", "JavaScriptInsertType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudfrontType_DisableAwsConfiguration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudfrontType_DisableAwsConfiguration{`,
		`DisableAwsConfiguration:` + strings.Replace(fmt.Sprintf("%v", this.DisableAwsConfiguration), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudfrontType_AwsConfigurationIdSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudfrontType_AwsConfigurationIdSelector{`,
		`AwsConfigurationIdSelector:` + strings.Replace(fmt.Sprintf("%v", this.AwsConfigurationIdSelector), "DistributionIDList", "DistributionIDList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudfrontType_AwsConfigurationTagSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudfrontType_AwsConfigurationTagSelector{`,
		`AwsConfigurationTagSelector:` + strings.Replace(fmt.Sprintf("%v", this.AwsConfigurationTagSelector), "DistributionTagList", "DistributionTagList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudfrontType_DisableMobileSdk) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudfrontType_DisableMobileSdk{`,
		`DisableMobileSdk:` + strings.Replace(fmt.Sprintf("%v", this.DisableMobileSdk), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudfrontType_MobileSdkConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudfrontType_MobileSdkConfig{`,
		`MobileSdkConfig:` + strings.Replace(fmt.Sprintf("%v", this.MobileSdkConfig), "MobileSDKConfigType", "MobileSDKConfigType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudfrontType_ManualJsInsert) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudfrontType_ManualJsInsert{`,
		`ManualJsInsert:` + strings.Replace(fmt.Sprintf("%v", this.ManualJsInsert), "JavaScriptInsertManualType", "JavaScriptInsertManualType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClientBypassRule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClientBypassRule{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "MessageMetaType", "schema.MessageMetaType", 1) + `,`,
		`ClientSourceChoice:` + fmt.Sprintf("%v", this.ClientSourceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClientBypassRule_IpPrefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClientBypassRule_IpPrefix{`,
		`IpPrefix:` + fmt.Sprintf("%v", this.IpPrefix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClientBypassRule_HttpHeader) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClientBypassRule_HttpHeader{`,
		`HttpHeader:` + strings.Replace(fmt.Sprintf("%v", this.HttpHeader), "HttpHeaderMatcherList", "HttpHeaderMatcherList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ValueMatch:` + fmt.Sprintf("%v", this.ValueMatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_Exact) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_Exact{`,
		`Exact:` + fmt.Sprintf("%v", this.Exact) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_Regex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_Regex{`,
		`Regex:` + fmt.Sprintf("%v", this.Regex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HttpHeaderMatcherList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHeaders := "[]*HeaderMatcherType{"
	for _, f := range this.Headers {
		repeatedStringForHeaders += strings.Replace(f.String(), "HeaderMatcherType", "HeaderMatcherType", 1) + ","
	}
	repeatedStringForHeaders += "}"
	s := strings.Join([]string{`&HttpHeaderMatcherList{`,
		`Headers:` + repeatedStringForHeaders + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtectedEndpointType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtectedEndpointType{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "MessageMetaType", "schema.MessageMetaType", 1) + `,`,
		`DomainMatcherChoice:` + fmt.Sprintf("%v", this.DomainMatcherChoice) + `,`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`HttpMethods:` + fmt.Sprintf("%v", this.HttpMethods) + `,`,
		`ClientTypeChoice:` + fmt.Sprintf("%v", this.ClientTypeChoice) + `,`,
		`FlowLabelChoice:` + fmt.Sprintf("%v", this.FlowLabelChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtectedEndpointType_AnyDomain) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtectedEndpointType_AnyDomain{`,
		`AnyDomain:` + strings.Replace(fmt.Sprintf("%v", this.AnyDomain), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtectedEndpointType_Domain) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtectedEndpointType_Domain{`,
		`Domain:` + strings.Replace(fmt.Sprintf("%v", this.Domain), "DomainType", "schema.DomainType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtectedEndpointType_WebClient) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtectedEndpointType_WebClient{`,
		`WebClient:` + strings.Replace(fmt.Sprintf("%v", this.WebClient), "WebClientType", "WebClientType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtectedEndpointType_MobileClient) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtectedEndpointType_MobileClient{`,
		`MobileClient:` + strings.Replace(fmt.Sprintf("%v", this.MobileClient), "MobileClientType", "MobileClientType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtectedEndpointType_WebMobileClient) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtectedEndpointType_WebMobileClient{`,
		`WebMobileClient:` + strings.Replace(fmt.Sprintf("%v", this.WebMobileClient), "WebMobileClientType", "WebMobileClientType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtectedEndpointType_UndefinedFlowLabel) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtectedEndpointType_UndefinedFlowLabel{`,
		`UndefinedFlowLabel:` + strings.Replace(fmt.Sprintf("%v", this.UndefinedFlowLabel), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtectedEndpointType_FlowLabel) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtectedEndpointType_FlowLabel{`,
		`FlowLabel:` + strings.Replace(fmt.Sprintf("%v", this.FlowLabel), "BotDefenseFlowLabelCategoriesChoiceType", "schema.BotDefenseFlowLabelCategoriesChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WebClientType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WebClientType{`,
		`Mitigation:` + fmt.Sprintf("%v", this.Mitigation) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WebClientType_Continue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WebClientType_Continue{`,
		`Continue:` + strings.Replace(fmt.Sprintf("%v", this.Continue), "ContinueMitigationChoiceType", "ContinueMitigationChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WebClientType_Redirect) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WebClientType_Redirect{`,
		`Redirect:` + strings.Replace(fmt.Sprintf("%v", this.Redirect), "RedirectMitigationChoiceType", "RedirectMitigationChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WebClientType_Block) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WebClientType_Block{`,
		`Block:` + strings.Replace(fmt.Sprintf("%v", this.Block), "BlockMitigationChoiceType", "BlockMitigationChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MobileClientType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MobileClientType{`,
		`Mitigation:` + fmt.Sprintf("%v", this.Mitigation) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MobileClientType_Continue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MobileClientType_Continue{`,
		`Continue:` + strings.Replace(fmt.Sprintf("%v", this.Continue), "ContinueMitigationChoiceType", "ContinueMitigationChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MobileClientType_Block) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MobileClientType_Block{`,
		`Block:` + strings.Replace(fmt.Sprintf("%v", this.Block), "BlockMobileMitigationChoiceType", "BlockMobileMitigationChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WebMobileClientType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WebMobileClientType{`,
		`WebMitigation:` + fmt.Sprintf("%v", this.WebMitigation) + `,`,
		`MobileMitigation:` + fmt.Sprintf("%v", this.MobileMitigation) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WebMobileClientType_ContinueWeb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WebMobileClientType_ContinueWeb{`,
		`ContinueWeb:` + strings.Replace(fmt.Sprintf("%v", this.ContinueWeb), "ContinueMitigationChoiceType", "ContinueMitigationChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WebMobileClientType_RedirectWeb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WebMobileClientType_RedirectWeb{`,
		`RedirectWeb:` + strings.Replace(fmt.Sprintf("%v", this.RedirectWeb), "RedirectMitigationChoiceType", "RedirectMitigationChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WebMobileClientType_BlockWeb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WebMobileClientType_BlockWeb{`,
		`BlockWeb:` + strings.Replace(fmt.Sprintf("%v", this.BlockWeb), "BlockMitigationChoiceType", "BlockMitigationChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WebMobileClientType_ContinueMobile) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WebMobileClientType_ContinueMobile{`,
		`ContinueMobile:` + strings.Replace(fmt.Sprintf("%v", this.ContinueMobile), "ContinueMitigationChoiceType", "ContinueMitigationChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WebMobileClientType_BlockMobile) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WebMobileClientType_BlockMobile{`,
		`BlockMobile:` + strings.Replace(fmt.Sprintf("%v", this.BlockMobile), "BlockMobileMitigationChoiceType", "BlockMobileMitigationChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContinueMitigationChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContinueMitigationChoiceType{`,
		`AddHeaderChoice:` + fmt.Sprintf("%v", this.AddHeaderChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContinueMitigationChoiceType_NoHeader) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContinueMitigationChoiceType_NoHeader{`,
		`NoHeader:` + strings.Replace(fmt.Sprintf("%v", this.NoHeader), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContinueMitigationChoiceType_AddHeader) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContinueMitigationChoiceType_AddHeader{`,
		`AddHeader:` + strings.Replace(fmt.Sprintf("%v", this.AddHeader), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BlockMitigationChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BlockMitigationChoiceType{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`ContentType:` + fmt.Sprintf("%v", this.ContentType) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BlockMobileMitigationChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BlockMobileMitigationChoiceType{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`ContentType:` + fmt.Sprintf("%v", this.ContentType) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RedirectMitigationChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RedirectMitigationChoiceType{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Location:` + fmt.Sprintf("%v", this.Location) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JavaScriptInsertType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRules := "[]*JavaScriptInsertionRule{"
	for _, f := range this.Rules {
		repeatedStringForRules += strings.Replace(f.String(), "JavaScriptInsertionRule", "JavaScriptInsertionRule", 1) + ","
	}
	repeatedStringForRules += "}"
	repeatedStringForExcludeList := "[]*JavaScriptExclusionRule{"
	for _, f := range this.ExcludeList {
		repeatedStringForExcludeList += strings.Replace(f.String(), "JavaScriptExclusionRule", "JavaScriptExclusionRule", 1) + ","
	}
	repeatedStringForExcludeList += "}"
	s := strings.Join([]string{`&JavaScriptInsertType{`,
		`Rules:` + repeatedStringForRules + `,`,
		`ExcludeList:` + repeatedStringForExcludeList + `,`,
		`JavascriptLocation:` + fmt.Sprintf("%v", this.JavascriptLocation) + `,`,
		`JsDownloadPath:` + fmt.Sprintf("%v", this.JsDownloadPath) + `,`,
		`JavascriptMode:` + fmt.Sprintf("%v", this.JavascriptMode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JavaScriptInsertAllWithExceptionsType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForExcludeList := "[]*JavaScriptExclusionRule{"
	for _, f := range this.ExcludeList {
		repeatedStringForExcludeList += strings.Replace(f.String(), "JavaScriptExclusionRule", "JavaScriptExclusionRule", 1) + ","
	}
	repeatedStringForExcludeList += "}"
	s := strings.Join([]string{`&JavaScriptInsertAllWithExceptionsType{`,
		`JavascriptLocation:` + fmt.Sprintf("%v", this.JavascriptLocation) + `,`,
		`ExcludeList:` + repeatedStringForExcludeList + `,`,
		`JsDownloadPath:` + fmt.Sprintf("%v", this.JsDownloadPath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JavaScriptInsertManualType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JavaScriptInsertManualType{`,
		`JsDownloadPath:` + fmt.Sprintf("%v", this.JsDownloadPath) + `,`,
		`JavascriptMode:` + fmt.Sprintf("%v", this.JavascriptMode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JavaScriptInsertAllType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JavaScriptInsertAllType{`,
		`JavascriptLocation:` + fmt.Sprintf("%v", this.JavascriptLocation) + `,`,
		`JsDownloadPath:` + fmt.Sprintf("%v", this.JsDownloadPath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JavaScriptInsertionRule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JavaScriptInsertionRule{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "MessageMetaType", "schema.MessageMetaType", 1) + `,`,
		`DomainMatcherChoice:` + fmt.Sprintf("%v", this.DomainMatcherChoice) + `,`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`UriPath:` + fmt.Sprintf("%v", this.UriPath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JavaScriptInsertionRule_AnyDomain) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JavaScriptInsertionRule_AnyDomain{`,
		`AnyDomain:` + strings.Replace(fmt.Sprintf("%v", this.AnyDomain), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JavaScriptInsertionRule_Domain) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JavaScriptInsertionRule_Domain{`,
		`Domain:` + strings.Replace(fmt.Sprintf("%v", this.Domain), "DomainType", "schema.DomainType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JavaScriptInsertionRule_Prefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JavaScriptInsertionRule_Prefix{`,
		`Prefix:` + fmt.Sprintf("%v", this.Prefix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JavaScriptInsertionRule_ExactPath) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JavaScriptInsertionRule_ExactPath{`,
		`ExactPath:` + fmt.Sprintf("%v", this.ExactPath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JavaScriptInsertionRule_Glob) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JavaScriptInsertionRule_Glob{`,
		`Glob:` + fmt.Sprintf("%v", this.Glob) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JavaScriptExclusionRule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JavaScriptExclusionRule{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "MessageMetaType", "schema.MessageMetaType", 1) + `,`,
		`DomainMatcherChoice:` + fmt.Sprintf("%v", this.DomainMatcherChoice) + `,`,
		`Path:` + strings.Replace(fmt.Sprintf("%v", this.Path), "PathMatcherType", "schema.PathMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JavaScriptExclusionRule_AnyDomain) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JavaScriptExclusionRule_AnyDomain{`,
		`AnyDomain:` + strings.Replace(fmt.Sprintf("%v", this.AnyDomain), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JavaScriptExclusionRule_Domain) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JavaScriptExclusionRule_Domain{`,
		`Domain:` + strings.Replace(fmt.Sprintf("%v", this.Domain), "DomainType", "schema.DomainType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MobileSDKConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MobileSDKConfigType{`,
		`MobileIdentifier:` + strings.Replace(this.MobileIdentifier.String(), "MobileTrafficIdentifierType", "MobileTrafficIdentifierType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MobileTrafficIdentifierType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHeaders := "[]*HeaderMatcherType{"
	for _, f := range this.Headers {
		repeatedStringForHeaders += strings.Replace(f.String(), "HeaderMatcherType", "HeaderMatcherType", 1) + ","
	}
	repeatedStringForHeaders += "}"
	s := strings.Join([]string{`&MobileTrafficIdentifierType{`,
		`Headers:` + repeatedStringForHeaders + `,`,
		`}`,
	}, "")
	return s
}
func (this *DistributionTagList) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&DistributionTagList{`,
		`Tags:` + mapStringForTags + `,`,
		`}`,
	}, "")
	return s
}
func (this *DistributionIDList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DistributionIDList{`,
		`Ids:` + fmt.Sprintf("%v", this.Ids) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *CloudfrontType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudfrontType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudfrontType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectedEndpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtectedEndpoints = append(m.ProtectedEndpoints, &ProtectedEndpointType{})
			if err := m.ProtectedEndpoints[len(m.ProtectedEndpoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsDownloadPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JsDownloadPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableJsInsert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.JavaScriptChoice = &CloudfrontType_DisableJsInsert{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsInsertAllPages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JavaScriptInsertAllType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.JavaScriptChoice = &CloudfrontType_JsInsertAllPages{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsInsertAllPagesExcept", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JavaScriptInsertAllWithExceptionsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.JavaScriptChoice = &CloudfrontType_JsInsertAllPagesExcept{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsInsertionRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JavaScriptInsertType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.JavaScriptChoice = &CloudfrontType_JsInsertionRules{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsAccountNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsAccountNo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAwsConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AwsConfigurationTypeChoice = &CloudfrontType_DisableAwsConfiguration{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsConfigurationIdSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DistributionIDList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AwsConfigurationTypeChoice = &CloudfrontType_AwsConfigurationIdSelector{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsConfigurationTagSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DistributionTagList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AwsConfigurationTypeChoice = &CloudfrontType_AwsConfigurationTagSelector{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableMobileSdk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MobileSdkChoice = &CloudfrontType_DisableMobileSdk{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MobileSdkConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MobileSDKConfigType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MobileSdkChoice = &CloudfrontType_MobileSdkConfig{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedClients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedClients = append(m.TrustedClients, &ClientBypassRule{})
			if err := m.TrustedClients[len(m.TrustedClients)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSample", wireType)
			}
			m.DataSample = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSample |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContinueMitigationActionHdr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContinueMitigationActionHdr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 103:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loglevel", wireType)
			}
			m.Loglevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Loglevel |= LogLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 104:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualJsInsert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JavaScriptInsertManualType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.JavaScriptChoice = &CloudfrontType_ManualJsInsert{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientBypassRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientBypassRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientBypassRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &schema.MessageMetaType{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientSourceChoice = &ClientBypassRule_IpPrefix{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HttpHeaderMatcherList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientSourceChoice = &ClientBypassRule_HttpHeader{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueMatch = &HeaderMatcherType_Exact{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueMatch = &HeaderMatcherType_Regex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpHeaderMatcherList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpHeaderMatcherList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpHeaderMatcherList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtectedEndpointType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtectedEndpointType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtectedEndpointType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &schema.MessageMetaType{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDomain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainMatcherChoice = &ProtectedEndpointType_AnyDomain{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.DomainType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainMatcherChoice = &ProtectedEndpointType_Domain{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v schema.BotHttpMethod
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.BotHttpMethod(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.HttpMethods = append(m.HttpMethods, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.HttpMethods) == 0 {
					m.HttpMethods = make([]schema.BotHttpMethod, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.BotHttpMethod
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.BotHttpMethod(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.HttpMethods = append(m.HttpMethods, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethods", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebClient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WebClientType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientTypeChoice = &ProtectedEndpointType_WebClient{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MobileClient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MobileClientType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientTypeChoice = &ProtectedEndpointType_MobileClient{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebMobileClient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WebMobileClientType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientTypeChoice = &ProtectedEndpointType_WebMobileClient{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndefinedFlowLabel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FlowLabelChoice = &ProtectedEndpointType_UndefinedFlowLabel{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowLabel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.BotDefenseFlowLabelCategoriesChoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FlowLabelChoice = &ProtectedEndpointType_FlowLabel{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebClientType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebClientType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebClientType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Continue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContinueMitigationChoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Mitigation = &WebClientType_Continue{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redirect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RedirectMitigationChoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Mitigation = &WebClientType_Redirect{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockMitigationChoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Mitigation = &WebClientType_Block{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MobileClientType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MobileClientType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MobileClientType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Continue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContinueMitigationChoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Mitigation = &MobileClientType_Continue{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockMobileMitigationChoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Mitigation = &MobileClientType_Block{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebMobileClientType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebMobileClientType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebMobileClientType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContinueWeb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContinueMitigationChoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WebMitigation = &WebMobileClientType_ContinueWeb{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectWeb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RedirectMitigationChoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WebMitigation = &WebMobileClientType_RedirectWeb{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockWeb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockMitigationChoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WebMitigation = &WebMobileClientType_BlockWeb{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContinueMobile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContinueMitigationChoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MobileMitigation = &WebMobileClientType_ContinueMobile{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockMobile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockMobileMitigationChoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MobileMitigation = &WebMobileClientType_BlockMobile{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContinueMitigationChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContinueMitigationChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContinueMitigationChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AddHeaderChoice = &ContinueMitigationChoiceType_NoHeader{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AddHeaderChoice = &ContinueMitigationChoiceType_AddHeader{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockMitigationChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockMitigationChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockMitigationChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= schema.HttpStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockMobileMitigationChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockMobileMitigationChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockMobileMitigationChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= schema.HttpStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedirectMitigationChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedirectMitigationChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedirectMitigationChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= schema.HttpStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JavaScriptInsertType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JavaScriptInsertType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JavaScriptInsertType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &JavaScriptInsertionRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludeList = append(m.ExcludeList, &JavaScriptExclusionRule{})
			if err := m.ExcludeList[len(m.ExcludeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavascriptLocation", wireType)
			}
			m.JavascriptLocation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JavascriptLocation |= JavaScriptLocation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsDownloadPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JsDownloadPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavascriptMode", wireType)
			}
			m.JavascriptMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JavascriptMode |= JavaScriptMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JavaScriptInsertAllWithExceptionsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JavaScriptInsertAllWithExceptionsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JavaScriptInsertAllWithExceptionsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavascriptLocation", wireType)
			}
			m.JavascriptLocation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JavascriptLocation |= JavaScriptLocation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludeList = append(m.ExcludeList, &JavaScriptExclusionRule{})
			if err := m.ExcludeList[len(m.ExcludeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsDownloadPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JsDownloadPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JavaScriptInsertManualType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JavaScriptInsertManualType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JavaScriptInsertManualType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsDownloadPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JsDownloadPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavascriptMode", wireType)
			}
			m.JavascriptMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JavascriptMode |= JavaScriptMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JavaScriptInsertAllType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JavaScriptInsertAllType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JavaScriptInsertAllType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavascriptLocation", wireType)
			}
			m.JavascriptLocation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JavascriptLocation |= JavaScriptLocation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsDownloadPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JsDownloadPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JavaScriptInsertionRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JavaScriptInsertionRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JavaScriptInsertionRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &schema.MessageMetaType{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDomain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainMatcherChoice = &JavaScriptInsertionRule_AnyDomain{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.DomainType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainMatcherChoice = &JavaScriptInsertionRule_Domain{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UriPath = &JavaScriptInsertionRule_Prefix{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UriPath = &JavaScriptInsertionRule_ExactPath{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Glob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UriPath = &JavaScriptInsertionRule_Glob{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JavaScriptExclusionRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JavaScriptExclusionRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JavaScriptExclusionRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &schema.MessageMetaType{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDomain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainMatcherChoice = &JavaScriptExclusionRule_AnyDomain{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.DomainType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainMatcherChoice = &JavaScriptExclusionRule_Domain{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &schema.PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MobileSDKConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MobileSDKConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MobileSDKConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MobileIdentifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MobileIdentifier == nil {
				m.MobileIdentifier = &MobileTrafficIdentifierType{}
			}
			if err := m.MobileIdentifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MobileTrafficIdentifierType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MobileTrafficIdentifierType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MobileTrafficIdentifierType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistributionTagList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistributionTagList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistributionTagList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistributionIDList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistributionIDList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistributionIDList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ids = append(m.Ids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
