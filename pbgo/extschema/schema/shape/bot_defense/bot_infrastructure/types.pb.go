// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/shape/bot_defense/bot_infrastructure/types.proto

package bot_infrastructure

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/shape/bot_defense/bot_allowlist_policy"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/shape/bot_defense/bot_endpoint_policy"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/shape/bot_defense/bot_network_policy"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Hosted/On Prem Cluster State
//
// x-displayName: "F5 On Premises or F5 Hosted Cluster State"
// The selection for cluster state
type ClusterState int32

const (
	// x-displayName: "Active"
	// State is Active
	ACTIVE ClusterState = 0
	// x-displayName: "Inactive"
	// State is Inactive
	INACTIVE ClusterState = 1
	// x-displayName: "Passive Proxy"
	// State is Passive Proxy
	PASSIVE_PROXY ClusterState = 2
	// x-displayName: "Emergency Stop"
	// State is Emergency Stop
	EMERGENCY_STOP ClusterState = 3
	// x-displayName: "N/A"
	// State is unavailable
	UNAVAILABLE ClusterState = 4
	// x-displayName: "Reconcile"
	// State is reconcile
	RECONCILE ClusterState = 5
	// x-displayName: "Starting Active"
	// State is starting active
	STARTING_ACTIVE ClusterState = 6
	// x-displayName: "Stopping Active"
	// State is stopping active
	STOPPING_ACTIVE ClusterState = 7
	// x-displayName: "Updating Firmware"
	// State is updating firmware
	UPDATING_FIRMWARE ClusterState = 8
	// x-displayName: "Updating Policy"
	// State is updating policy
	UPDATING_POLICY ClusterState = 9
	// x-displayName: "Waiting for All Active"
	// State is waiting for all active
	WAITING_ACTIVE ClusterState = 10
	// x-displayName: "Waiting for Start Timeout"
	// State is waiting for start timeout
	WAITING_START_TIMEOUT ClusterState = 11
)

var ClusterState_name = map[int32]string{
	0:  "ACTIVE",
	1:  "INACTIVE",
	2:  "PASSIVE_PROXY",
	3:  "EMERGENCY_STOP",
	4:  "UNAVAILABLE",
	5:  "RECONCILE",
	6:  "STARTING_ACTIVE",
	7:  "STOPPING_ACTIVE",
	8:  "UPDATING_FIRMWARE",
	9:  "UPDATING_POLICY",
	10: "WAITING_ACTIVE",
	11: "WAITING_START_TIMEOUT",
}

var ClusterState_value = map[string]int32{
	"ACTIVE":                0,
	"INACTIVE":              1,
	"PASSIVE_PROXY":         2,
	"EMERGENCY_STOP":        3,
	"UNAVAILABLE":           4,
	"RECONCILE":             5,
	"STARTING_ACTIVE":       6,
	"STOPPING_ACTIVE":       7,
	"UPDATING_FIRMWARE":     8,
	"UPDATING_POLICY":       9,
	"WAITING_ACTIVE":        10,
	"WAITING_START_TIMEOUT": 11,
}

func (ClusterState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{0}
}

// EnvironmentType
//
// x-displayName: "Environment Type"
// Identifies the environment as either Production or Testing. Production environments have two infrastructure regions in an Active-Active configuration where traffic is routed equally between the two regions. Test environments have a single infrastructure region.
type EnvironmentType int32

const (
	// x-displayName: "Production"
	// Production Protect live production applications and services from automated attacks.
	PRODUCTION EnvironmentType = 0
	// x-displayName: "Testing"
	// Test Evaluate new features, settings, and system performance.
	TESTING EnvironmentType = 1
)

var EnvironmentType_name = map[int32]string{
	0: "PRODUCTION",
	1: "TESTING",
}

var EnvironmentType_value = map[string]int32{
	"PRODUCTION": 0,
	"TESTING":    1,
}

func (EnvironmentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{1}
}

// TrafficType
//
// x-displayName: "Traffic Type"
// The type of traffic that is routed to and processed by this infrastructure (Web or Mobile).
type TrafficType int32

const (
	// x-displayName: "Web"
	// Only web traffic, including browser-based traffic from mobile devices, is routed through this Bot Defense infrastructure.
	WEB TrafficType = 0
	// x-displayName: "Mobile"
	// Only mobile traffic from native mobile apps with the Bot Defense SDK are routed through this Bot Defense infrastructure.
	MOBILE TrafficType = 1
)

var TrafficType_name = map[int32]string{
	0: "WEB",
	1: "MOBILE",
}

var TrafficType_value = map[string]int32{
	"WEB":    0,
	"MOBILE": 1,
}

func (TrafficType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{2}
}

// InfraType
//
// x-displayName: "Infra Type"
// Infra Type
type InfraType int32

const (
	// x-displayName: "F5 Cloud Hosted"
	// Your application are on the internet using the F5 Cloud Hosted
	F5_CLOUD_HOSTED InfraType = 0
)

var InfraType_name = map[int32]string{
	0: "F5_CLOUD_HOSTED",
}

var InfraType_value = map[string]int32{
	"F5_CLOUD_HOSTED": 0,
}

func (InfraType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{3}
}

// Location
//
// x-displayName: "Location"
// Region location
type Location int32

const (
	// x-displayName: "ap-northeast-1"
	// AP_NORTHEAST_1
	AP_NORTHEAST_1 Location = 0
	// x-displayName: "ap-northeast-3"
	// AP_NORTHEAST_3
	AP_NORTHEAST_3 Location = 1
	// x-displayName: "ap-south-1"
	// AP_SOUTH_1
	AP_SOUTH_1 Location = 2
	// x-displayName: "ap-south-2"
	// AP_SOUTH_2
	AP_SOUTH_2 Location = 3
	// x-displayName: "ap-southeast-1"
	// AP_SOUTHEAST_1
	AP_SOUTHEAST_1 Location = 4
	// x-displayName: "ap-southeast-2"
	// AP_SOUTHEAST_2
	AP_SOUTHEAST_2 Location = 5
	// x-displayName: "ap-southeast-3"
	// AP_SOUTHEAST_3
	AP_SOUTHEAST_3 Location = 6
	// x-displayName: "eu-central-1"
	// EU_CENTRAL_1
	EU_CENTRAL_1 Location = 7
	// x-displayName: "eu-north-1"
	// EU_NORTH_1
	EU_NORTH_1 Location = 8
	// x-displayName: "eu-west-1"
	// EU_WEST_1
	EU_WEST_1 Location = 9
	// x-displayName: "me-south-1"
	// ME_SOUTH_1
	ME_SOUTH_1 Location = 10
	// x-displayName: "me-central-1"
	// ME_CENTRAL_1
	ME_CENTRAL_1 Location = 11
	// x-displayName: "sa-east-1"
	// SA_EAST_1
	SA_EAST_1 Location = 12
	// x-displayName: "us-east-1"
	// US_EAST_1
	US_EAST_1 Location = 13
	// x-displayName: "us-east-2"
	// US_EAST_2
	US_EAST_2 Location = 14
	// x-displayName: "us-west-1"
	// US_WEST_1
	US_WEST_1 Location = 15
	// x-displayName: "us-west-2"
	// US_WEST_2
	US_WEST_2 Location = 16
	// x-displayName: "af-south-1"
	// AF_SOUTH_1
	AF_SOUTH_1 Location = 17
	// x-displayName: "asia-east1"
	// ASIA_EAST1
	GCP_ASIA_EAST1 Location = 18
	// x-displayName: "asia-east2"
	// ASIA_EAST2
	GCP_ASIA_EAST2 Location = 19
	// x-displayName: "asia-northeast1"
	// ASIA_NORTHEAST1
	GCP_ASIA_NORTHEAST1 Location = 20
	// x-displayName: "asia-northeast2"
	// ASIA_NORTHEAST2
	GCP_ASIA_NORTHEAST2 Location = 21
	// x-displayName: "asia-northeast3"
	// ASIA_NORTHEAST3
	GCP_ASIA_NORTHEAST3 Location = 22
	// x-displayName: "asia-south1"
	// ASIA_SOUTH1
	GCP_ASIA_SOUTH1 Location = 23
	// x-displayName: "asia-southeast1"
	// ASIA_SOUTHEAST1
	GCP_ASIA_SOUTHEAST1 Location = 24
	// x-displayName: "asia-southeast2"
	// ASIA_SOUTHEAST2
	GCP_ASIA_SOUTHEAST2 Location = 25
	// x-displayName: "australia-southeast1"
	// AUSTRALIA_SOUTHEAST1
	GCP_AUSTRALIA_SOUTHEAST1 Location = 26
	// x-displayName: "europe-west1"
	// EUROPE_WEST1
	GCP_EUROPE_WEST1 Location = 27
	// x-displayName: "europe-west2"
	// EUROPE_WEST2
	GCP_EUROPE_WEST2 Location = 28
	// x-displayName: "europe-west3"
	// EUROPE_WEST3
	GCP_EUROPE_WEST3 Location = 29
	// x-displayName: "northamerica-northeast1"
	// NORTHAMERICA_NORTHEAST1
	GCP_NORTHAMERICA_NORTHEAST1 Location = 30
	// x-displayName: "northamerica-northeast2"
	// NORTHAMERICA_NORTHEAST2
	GCP_NORTHAMERICA_NORTHEAST2 Location = 31
	// x-displayName: "southamerica-east1"
	// SOUTHAMERICA_EAST1
	GCP_SOUTHAMERICA_EAST1 Location = 32
	// x-displayName: "southamerica-west1"
	// SOUTHAMERICA_WEST1
	GCP_SOUTHAMERICA_WEST1 Location = 33
	// x-displayName: "us-central1"
	// US_CENTRAL1
	GCP_US_CENTRAL1 Location = 34
	// x-displayName: "us-east1"
	// US_EAST1
	GCP_US_EAST1 Location = 35
	// x-displayName: "us-east4"
	// US_EAST4
	GCP_US_EAST4 Location = 36
	// x-displayName: "us-west1"
	// US_WEST1
	GCP_US_WEST1 Location = 37
	// x-displayName: "us-west2"
	// US_WEST2
	GCP_US_WEST2 Location = 38
)

var Location_name = map[int32]string{
	0:  "AP_NORTHEAST_1",
	1:  "AP_NORTHEAST_3",
	2:  "AP_SOUTH_1",
	3:  "AP_SOUTH_2",
	4:  "AP_SOUTHEAST_1",
	5:  "AP_SOUTHEAST_2",
	6:  "AP_SOUTHEAST_3",
	7:  "EU_CENTRAL_1",
	8:  "EU_NORTH_1",
	9:  "EU_WEST_1",
	10: "ME_SOUTH_1",
	11: "ME_CENTRAL_1",
	12: "SA_EAST_1",
	13: "US_EAST_1",
	14: "US_EAST_2",
	15: "US_WEST_1",
	16: "US_WEST_2",
	17: "AF_SOUTH_1",
	18: "GCP_ASIA_EAST1",
	19: "GCP_ASIA_EAST2",
	20: "GCP_ASIA_NORTHEAST1",
	21: "GCP_ASIA_NORTHEAST2",
	22: "GCP_ASIA_NORTHEAST3",
	23: "GCP_ASIA_SOUTH1",
	24: "GCP_ASIA_SOUTHEAST1",
	25: "GCP_ASIA_SOUTHEAST2",
	26: "GCP_AUSTRALIA_SOUTHEAST1",
	27: "GCP_EUROPE_WEST1",
	28: "GCP_EUROPE_WEST2",
	29: "GCP_EUROPE_WEST3",
	30: "GCP_NORTHAMERICA_NORTHEAST1",
	31: "GCP_NORTHAMERICA_NORTHEAST2",
	32: "GCP_SOUTHAMERICA_EAST1",
	33: "GCP_SOUTHAMERICA_WEST1",
	34: "GCP_US_CENTRAL1",
	35: "GCP_US_EAST1",
	36: "GCP_US_EAST4",
	37: "GCP_US_WEST1",
	38: "GCP_US_WEST2",
}

var Location_value = map[string]int32{
	"AP_NORTHEAST_1":              0,
	"AP_NORTHEAST_3":              1,
	"AP_SOUTH_1":                  2,
	"AP_SOUTH_2":                  3,
	"AP_SOUTHEAST_1":              4,
	"AP_SOUTHEAST_2":              5,
	"AP_SOUTHEAST_3":              6,
	"EU_CENTRAL_1":                7,
	"EU_NORTH_1":                  8,
	"EU_WEST_1":                   9,
	"ME_SOUTH_1":                  10,
	"ME_CENTRAL_1":                11,
	"SA_EAST_1":                   12,
	"US_EAST_1":                   13,
	"US_EAST_2":                   14,
	"US_WEST_1":                   15,
	"US_WEST_2":                   16,
	"AF_SOUTH_1":                  17,
	"GCP_ASIA_EAST1":              18,
	"GCP_ASIA_EAST2":              19,
	"GCP_ASIA_NORTHEAST1":         20,
	"GCP_ASIA_NORTHEAST2":         21,
	"GCP_ASIA_NORTHEAST3":         22,
	"GCP_ASIA_SOUTH1":             23,
	"GCP_ASIA_SOUTHEAST1":         24,
	"GCP_ASIA_SOUTHEAST2":         25,
	"GCP_AUSTRALIA_SOUTHEAST1":    26,
	"GCP_EUROPE_WEST1":            27,
	"GCP_EUROPE_WEST2":            28,
	"GCP_EUROPE_WEST3":            29,
	"GCP_NORTHAMERICA_NORTHEAST1": 30,
	"GCP_NORTHAMERICA_NORTHEAST2": 31,
	"GCP_SOUTHAMERICA_EAST1":      32,
	"GCP_SOUTHAMERICA_WEST1":      33,
	"GCP_US_CENTRAL1":             34,
	"GCP_US_EAST1":                35,
	"GCP_US_EAST4":                36,
	"GCP_US_WEST1":                37,
	"GCP_US_WEST2":                38,
}

func (Location) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{4}
}

// GlobalSpecType
//
// x-displayName: "Global Specification"
// Configures Bot Infrastructure by Bot Defense
type GlobalSpecType struct {
	// Endpoint Policy
	//
	// x-displayName: "Endpoint Policy"
	// Reference to Endpoint Policy object
	BotEndpointPolicy *views.ObjectRefType `protobuf:"bytes,1,opt,name=bot_endpoint_policy,json=botEndpointPolicy,proto3" json:"bot_endpoint_policy,omitempty"`
	// Bot Network Policy Metadata
	//
	// x-displayName: "Bot Endpoint Policy Metadata"
	BotEndpointPolicyMetadata *EndpointPolicyMetadata `protobuf:"bytes,2,opt,name=bot_endpoint_policy_metadata,json=botEndpointPolicyMetadata,proto3" json:"bot_endpoint_policy_metadata,omitempty"`
	// Allowlist Policy
	//
	// x-displayName: "Allowlist Policy"
	// Reference to Allowlist Policy object
	BotAllowlistPolicy *views.ObjectRefType `protobuf:"bytes,3,opt,name=bot_allowlist_policy,json=botAllowlistPolicy,proto3" json:"bot_allowlist_policy,omitempty"`
	// Bot Allowlist Policy Metadata
	//
	// x-displayName: "Bot Allowlist Policy Metadata"
	BotAllowlistPolicyMetadata *PolicyMetadata `protobuf:"bytes,4,opt,name=bot_allowlist_policy_metadata,json=botAllowlistPolicyMetadata,proto3" json:"bot_allowlist_policy_metadata,omitempty"`
	// Network Policy
	//
	// x-displayName: "Network Policy"
	// Reference to Network Policy object
	BotNetworkPolicy *views.ObjectRefType `protobuf:"bytes,5,opt,name=bot_network_policy,json=botNetworkPolicy,proto3" json:"bot_network_policy,omitempty"`
	// Bot Network Policy Metadata
	//
	// x-displayName: "Bot Network Policy Metadata"
	BotNetworkPolicyMetadata *PolicyMetadata `protobuf:"bytes,6,opt,name=bot_network_policy_metadata,json=botNetworkPolicyMetadata,proto3" json:"bot_network_policy_metadata,omitempty"`
	// Environment Type
	//
	// x-displayName: "Environment Type"
	// x-example: "Production"
	// Identifies the environment as either Production or Testing. Production environments have two infrastructure regions in an Active-Active configuration where traffic is routed equally between the two regions. Test environments have a single infrastructure region.
	EnvironmentType EnvironmentType `protobuf:"varint,7,opt,name=environment_type,json=environmentType,proto3,enum=ves.io.schema.shape.bot_defense.bot_infrastructure.EnvironmentType" json:"environment_type,omitempty"`
	// Traffic Type
	//
	// x-displayName: "Traffic Type"
	// x-example: "web"
	// The type of traffic that is routed to and processed by this infrastructure (Web or Mobile).
	TrafficType TrafficType `protobuf:"varint,8,opt,name=traffic_type,json=trafficType,proto3,enum=ves.io.schema.shape.bot_defense.bot_infrastructure.TrafficType" json:"traffic_type,omitempty"`
	// Infra Type
	//
	// x-displayName: "Infra Type"
	InfraType InfraType `protobuf:"varint,9,opt,name=infra_type,json=infraType,proto3,enum=ves.io.schema.shape.bot_defense.bot_infrastructure.InfraType" json:"infra_type,omitempty"`
	// Infra Host Name
	//
	// x-displayName: "Infra Host Name"
	// x-example: "www.example.com"
	// Infra Host Name
	InfraHostName string `protobuf:"bytes,10,opt,name=infra_host_name,json=infraHostName,proto3" json:"infra_host_name,omitempty"`
	// Ingress
	//
	// x-displayName: "Ingress"
	// Ingress
	Ingress []*Ingress `protobuf:"bytes,11,rep,name=ingress,proto3" json:"ingress,omitempty"`
	// Egress
	//
	// x-displayName: "Egress"
	// Egress
	Egress []*Egress `protobuf:"bytes,12,rep,name=egress,proto3" json:"egress,omitempty"`
	// Host Names
	//
	// x-displayName: "Name"
	// Host Names
	HostNames []string `protobuf:"bytes,13,rep,name=host_names,json=hostNames,proto3" json:"host_names,omitempty"`
	// IP addresses
	//
	// x-displayName: "IP Address"
	// IP addresses
	IpAddresses []string `protobuf:"bytes,14,rep,name=ip_addresses,json=ipAddresses,proto3" json:"ip_addresses,omitempty"`
	// Bot Infrastructure Regions
	//
	// x-displayName: "Region"
	// Bot Infrastructure Regions
	InfraRegion []Location `protobuf:"varint,15,rep,packed,name=infra_region,json=infraRegion,proto3,enum=ves.io.schema.shape.bot_defense.bot_infrastructure.Location" json:"infra_region,omitempty"`
	// Bot Infrastructure firmware release id
	//
	// x-displayName: "Firmware Release ID"
	// firmware release id pulled from SPM
	FirmwareReleaseId string `protobuf:"bytes,16,opt,name=firmware_release_id,json=firmwareReleaseId,proto3" json:"firmware_release_id,omitempty"`
	// Bot Infrastructure Id in SPM
	//
	// x-displayName: "SPM Cluster ID"
	// The id pulled from SPM to identify the cluster
	SpmClusterId string `protobuf:"bytes,17,opt,name=spm_cluster_id,json=spmClusterId,proto3" json:"spm_cluster_id,omitempty"`
	// Bot TI Policy Metadata
	//
	// x-displayName: "Bot TI Policy"
	// the metadata for TI policy
	BotThreatIntelligencePolicyMetadata *PolicyMetadata `protobuf:"bytes,18,opt,name=bot_threat_intelligence_policy_metadata,json=botThreatIntelligencePolicyMetadata,proto3" json:"bot_threat_intelligence_policy_metadata,omitempty"`
	// choice
	//
	// x-displayName: "Infra Type"
	// x-required
	// Identifies if this is an F5 Cloud Hosted, F5 Hosted or On-Premises infrastructure.
	//
	// Types that are valid to be assigned to BotInfraChoice:
	//	*GlobalSpecType_CloudHosted
	//	*GlobalSpecType_PhysicalHosted
	//	*GlobalSpecType_OnPrem
	BotInfraChoice isGlobalSpecType_BotInfraChoice `protobuf_oneof:"bot_infra_choice"`
	// Cluster State
	//
	// x-displayName: "Cluster State"
	// The state of cluster
	ClusterState ClusterState `protobuf:"varint,23,opt,name=cluster_state,json=clusterState,proto3,enum=ves.io.schema.shape.bot_defense.bot_infrastructure.ClusterState" json:"cluster_state,omitempty"`
	// choice
	//
	// x-displayName: "Infra Type"
	// Identifies if this is an F5 Cloud Hosted infrastructure.
	//
	// Types that are valid to be assigned to CreateBotInfraChoice:
	//	*GlobalSpecType_CreateCloudHosted
	CreateBotInfraChoice isGlobalSpecType_CreateBotInfraChoice `protobuf_oneof:"create_bot_infra_choice"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{0}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_BotInfraChoice interface {
	isGlobalSpecType_BotInfraChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_CreateBotInfraChoice interface {
	isGlobalSpecType_CreateBotInfraChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_CloudHosted struct {
	CloudHosted *InfraCloudHosted `protobuf:"bytes,20,opt,name=cloud_hosted,json=cloudHosted,proto3,oneof" json:"cloud_hosted,omitempty"`
}
type GlobalSpecType_PhysicalHosted struct {
	PhysicalHosted *InfraF5HostedOnPrem `protobuf:"bytes,21,opt,name=physical_hosted,json=physicalHosted,proto3,oneof" json:"physical_hosted,omitempty"`
}
type GlobalSpecType_OnPrem struct {
	OnPrem *InfraF5HostedOnPrem `protobuf:"bytes,22,opt,name=on_prem,json=onPrem,proto3,oneof" json:"on_prem,omitempty"`
}
type GlobalSpecType_CreateCloudHosted struct {
	CreateCloudHosted *CreateSpecInfraCloudHosted `protobuf:"bytes,25,opt,name=create_cloud_hosted,json=createCloudHosted,proto3,oneof" json:"create_cloud_hosted,omitempty"`
}

func (*GlobalSpecType_CloudHosted) isGlobalSpecType_BotInfraChoice()             {}
func (*GlobalSpecType_PhysicalHosted) isGlobalSpecType_BotInfraChoice()          {}
func (*GlobalSpecType_OnPrem) isGlobalSpecType_BotInfraChoice()                  {}
func (*GlobalSpecType_CreateCloudHosted) isGlobalSpecType_CreateBotInfraChoice() {}

func (m *GlobalSpecType) GetBotInfraChoice() isGlobalSpecType_BotInfraChoice {
	if m != nil {
		return m.BotInfraChoice
	}
	return nil
}
func (m *GlobalSpecType) GetCreateBotInfraChoice() isGlobalSpecType_CreateBotInfraChoice {
	if m != nil {
		return m.CreateBotInfraChoice
	}
	return nil
}

func (m *GlobalSpecType) GetBotEndpointPolicy() *views.ObjectRefType {
	if m != nil {
		return m.BotEndpointPolicy
	}
	return nil
}

func (m *GlobalSpecType) GetBotEndpointPolicyMetadata() *EndpointPolicyMetadata {
	if m != nil {
		return m.BotEndpointPolicyMetadata
	}
	return nil
}

func (m *GlobalSpecType) GetBotAllowlistPolicy() *views.ObjectRefType {
	if m != nil {
		return m.BotAllowlistPolicy
	}
	return nil
}

func (m *GlobalSpecType) GetBotAllowlistPolicyMetadata() *PolicyMetadata {
	if m != nil {
		return m.BotAllowlistPolicyMetadata
	}
	return nil
}

func (m *GlobalSpecType) GetBotNetworkPolicy() *views.ObjectRefType {
	if m != nil {
		return m.BotNetworkPolicy
	}
	return nil
}

func (m *GlobalSpecType) GetBotNetworkPolicyMetadata() *PolicyMetadata {
	if m != nil {
		return m.BotNetworkPolicyMetadata
	}
	return nil
}

func (m *GlobalSpecType) GetEnvironmentType() EnvironmentType {
	if m != nil {
		return m.EnvironmentType
	}
	return PRODUCTION
}

func (m *GlobalSpecType) GetTrafficType() TrafficType {
	if m != nil {
		return m.TrafficType
	}
	return WEB
}

func (m *GlobalSpecType) GetInfraType() InfraType {
	if m != nil {
		return m.InfraType
	}
	return F5_CLOUD_HOSTED
}

func (m *GlobalSpecType) GetInfraHostName() string {
	if m != nil {
		return m.InfraHostName
	}
	return ""
}

func (m *GlobalSpecType) GetIngress() []*Ingress {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *GlobalSpecType) GetEgress() []*Egress {
	if m != nil {
		return m.Egress
	}
	return nil
}

func (m *GlobalSpecType) GetHostNames() []string {
	if m != nil {
		return m.HostNames
	}
	return nil
}

func (m *GlobalSpecType) GetIpAddresses() []string {
	if m != nil {
		return m.IpAddresses
	}
	return nil
}

func (m *GlobalSpecType) GetInfraRegion() []Location {
	if m != nil {
		return m.InfraRegion
	}
	return nil
}

func (m *GlobalSpecType) GetFirmwareReleaseId() string {
	if m != nil {
		return m.FirmwareReleaseId
	}
	return ""
}

func (m *GlobalSpecType) GetSpmClusterId() string {
	if m != nil {
		return m.SpmClusterId
	}
	return ""
}

func (m *GlobalSpecType) GetBotThreatIntelligencePolicyMetadata() *PolicyMetadata {
	if m != nil {
		return m.BotThreatIntelligencePolicyMetadata
	}
	return nil
}

func (m *GlobalSpecType) GetCloudHosted() *InfraCloudHosted {
	if x, ok := m.GetBotInfraChoice().(*GlobalSpecType_CloudHosted); ok {
		return x.CloudHosted
	}
	return nil
}

func (m *GlobalSpecType) GetPhysicalHosted() *InfraF5HostedOnPrem {
	if x, ok := m.GetBotInfraChoice().(*GlobalSpecType_PhysicalHosted); ok {
		return x.PhysicalHosted
	}
	return nil
}

func (m *GlobalSpecType) GetOnPrem() *InfraF5HostedOnPrem {
	if x, ok := m.GetBotInfraChoice().(*GlobalSpecType_OnPrem); ok {
		return x.OnPrem
	}
	return nil
}

func (m *GlobalSpecType) GetClusterState() ClusterState {
	if m != nil {
		return m.ClusterState
	}
	return ACTIVE
}

func (m *GlobalSpecType) GetCreateCloudHosted() *CreateSpecInfraCloudHosted {
	if x, ok := m.GetCreateBotInfraChoice().(*GlobalSpecType_CreateCloudHosted); ok {
		return x.CreateCloudHosted
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_CloudHosted)(nil),
		(*GlobalSpecType_PhysicalHosted)(nil),
		(*GlobalSpecType_OnPrem)(nil),
		(*GlobalSpecType_CreateCloudHosted)(nil),
	}
}

// F5 Cloud Hosted
//
// x-displayName: "F5 Cloud Hosted"
type InfraCloudHosted struct {
	// Infra host name
	//
	// x-displayName: "Infra Host Name"
	// x-example: "www.example.com"
	InfraHostName string `protobuf:"bytes,1,opt,name=infra_host_name,json=infraHostName,proto3" json:"infra_host_name,omitempty"`
	// Firmware Version
	//
	// x-displayName: "Firmware Version"
	// The version of firmware for the cluster
	FirmwareVersion string `protobuf:"bytes,2,opt,name=firmware_version,json=firmwareVersion,proto3" json:"firmware_version,omitempty"`
	// Ingress
	//
	// x-displayName: "Ingress"
	// Ingress Host Names or IP Addresses
	Ingress []*Ingress `protobuf:"bytes,3,rep,name=ingress,proto3" json:"ingress,omitempty"`
	// Egress
	//
	// x-displayName: "Egress"
	// Egress IP Addresses
	Egress []*Egress `protobuf:"bytes,4,rep,name=egress,proto3" json:"egress,omitempty"`
	// Allowed Host Names
	//
	// x-displayName: "Allowed Host Names"
	// Only traffic from machines with these host names is allowed to access this Bot Defense infrastructure
	HostNames []string `protobuf:"bytes,5,rep,name=host_names,json=hostNames,proto3" json:"host_names,omitempty"`
	// IP Allowlist
	//
	// x-displayName: "Ingress IP Access Control List"
	// Only traffic from these IP addresses is allowed to access this Bot Defense infrastructure.
	IpAddresses []string `protobuf:"bytes,6,rep,name=ip_addresses,json=ipAddresses,proto3" json:"ip_addresses,omitempty"`
	// Bot Infrastructure Regions
	//
	// x-displayName: "Region"
	// x-required
	// Bot Infrastructure Regions
	InfraRegion []Location `protobuf:"varint,7,rep,packed,name=infra_region,json=infraRegion,proto3,enum=ves.io.schema.shape.bot_defense.bot_infrastructure.Location" json:"infra_region,omitempty"`
}

func (m *InfraCloudHosted) Reset()      { *m = InfraCloudHosted{} }
func (*InfraCloudHosted) ProtoMessage() {}
func (*InfraCloudHosted) Descriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{1}
}
func (m *InfraCloudHosted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InfraCloudHosted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InfraCloudHosted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfraCloudHosted.Merge(m, src)
}
func (m *InfraCloudHosted) XXX_Size() int {
	return m.Size()
}
func (m *InfraCloudHosted) XXX_DiscardUnknown() {
	xxx_messageInfo_InfraCloudHosted.DiscardUnknown(m)
}

var xxx_messageInfo_InfraCloudHosted proto.InternalMessageInfo

func (m *InfraCloudHosted) GetInfraHostName() string {
	if m != nil {
		return m.InfraHostName
	}
	return ""
}

func (m *InfraCloudHosted) GetFirmwareVersion() string {
	if m != nil {
		return m.FirmwareVersion
	}
	return ""
}

func (m *InfraCloudHosted) GetIngress() []*Ingress {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *InfraCloudHosted) GetEgress() []*Egress {
	if m != nil {
		return m.Egress
	}
	return nil
}

func (m *InfraCloudHosted) GetHostNames() []string {
	if m != nil {
		return m.HostNames
	}
	return nil
}

func (m *InfraCloudHosted) GetIpAddresses() []string {
	if m != nil {
		return m.IpAddresses
	}
	return nil
}

func (m *InfraCloudHosted) GetInfraRegion() []Location {
	if m != nil {
		return m.InfraRegion
	}
	return nil
}

// F5 Cloud Hosted - for creating a new object
//
// x-displayName: "F5 Cloud Hosted"
type CreateSpecInfraCloudHosted struct {
	// Type Choice
	//
	// x-displayName: "Environment Type"
	// x-required
	// Identifies the environment as either Production or Testing. Production environments have two infrastructure regions in an Active-Active configuration where traffic is routed equally between the two regions. Test environments have a single infrastructure region.
	//
	// Types that are valid to be assigned to TypeChoice:
	//	*CreateSpecInfraCloudHosted_Production
	//	*CreateSpecInfraCloudHosted_Testing
	TypeChoice isCreateSpecInfraCloudHosted_TypeChoice `protobuf_oneof:"type_choice"`
	// IP Allowlist
	//
	// x-displayName: "Ingress IP Access Control List"
	// Only traffic from these IP addresses is allowed to access this Bot Defense infrastructure.
	IpAddresses []string `protobuf:"bytes,4,rep,name=ip_addresses,json=ipAddresses,proto3" json:"ip_addresses,omitempty"`
}

func (m *CreateSpecInfraCloudHosted) Reset()      { *m = CreateSpecInfraCloudHosted{} }
func (*CreateSpecInfraCloudHosted) ProtoMessage() {}
func (*CreateSpecInfraCloudHosted) Descriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{2}
}
func (m *CreateSpecInfraCloudHosted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecInfraCloudHosted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecInfraCloudHosted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecInfraCloudHosted.Merge(m, src)
}
func (m *CreateSpecInfraCloudHosted) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecInfraCloudHosted) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecInfraCloudHosted.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecInfraCloudHosted proto.InternalMessageInfo

type isCreateSpecInfraCloudHosted_TypeChoice interface {
	isCreateSpecInfraCloudHosted_TypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecInfraCloudHosted_Production struct {
	Production *Production `protobuf:"bytes,2,opt,name=production,proto3,oneof" json:"production,omitempty"`
}
type CreateSpecInfraCloudHosted_Testing struct {
	Testing *Testing `protobuf:"bytes,3,opt,name=testing,proto3,oneof" json:"testing,omitempty"`
}

func (*CreateSpecInfraCloudHosted_Production) isCreateSpecInfraCloudHosted_TypeChoice() {}
func (*CreateSpecInfraCloudHosted_Testing) isCreateSpecInfraCloudHosted_TypeChoice()    {}

func (m *CreateSpecInfraCloudHosted) GetTypeChoice() isCreateSpecInfraCloudHosted_TypeChoice {
	if m != nil {
		return m.TypeChoice
	}
	return nil
}

func (m *CreateSpecInfraCloudHosted) GetProduction() *Production {
	if x, ok := m.GetTypeChoice().(*CreateSpecInfraCloudHosted_Production); ok {
		return x.Production
	}
	return nil
}

func (m *CreateSpecInfraCloudHosted) GetTesting() *Testing {
	if x, ok := m.GetTypeChoice().(*CreateSpecInfraCloudHosted_Testing); ok {
		return x.Testing
	}
	return nil
}

func (m *CreateSpecInfraCloudHosted) GetIpAddresses() []string {
	if m != nil {
		return m.IpAddresses
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecInfraCloudHosted) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecInfraCloudHosted_Production)(nil),
		(*CreateSpecInfraCloudHosted_Testing)(nil),
	}
}

// F5 On Premises or F5 Physical Hosted
//
// x-displayName: "F5 On Premises or F5 Hosted"
// Bot infra type is F5 Hosted/F5 On Premises
type InfraF5HostedOnPrem struct {
	// Infra host name
	//
	// x-displayName: "Infra Host Name"
	// Infra host name should be "N/A"
	InfraHostName string `protobuf:"bytes,3,opt,name=infra_host_name,json=infraHostName,proto3" json:"infra_host_name,omitempty"`
	// Firmware Version
	//
	// x-displayName: "Firmware Version"
	// The version of firmware for the cluster
	FirmwareVersion string `protobuf:"bytes,1,opt,name=firmware_version,json=firmwareVersion,proto3" json:"firmware_version,omitempty"`
	// Devices
	//
	// x-displayName: "Devices"
	// The devices assgined to the cluster
	Devices []*Device `protobuf:"bytes,2,rep,name=devices,proto3" json:"devices,omitempty"`
}

func (m *InfraF5HostedOnPrem) Reset()      { *m = InfraF5HostedOnPrem{} }
func (*InfraF5HostedOnPrem) ProtoMessage() {}
func (*InfraF5HostedOnPrem) Descriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{3}
}
func (m *InfraF5HostedOnPrem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InfraF5HostedOnPrem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InfraF5HostedOnPrem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfraF5HostedOnPrem.Merge(m, src)
}
func (m *InfraF5HostedOnPrem) XXX_Size() int {
	return m.Size()
}
func (m *InfraF5HostedOnPrem) XXX_DiscardUnknown() {
	xxx_messageInfo_InfraF5HostedOnPrem.DiscardUnknown(m)
}

var xxx_messageInfo_InfraF5HostedOnPrem proto.InternalMessageInfo

func (m *InfraF5HostedOnPrem) GetInfraHostName() string {
	if m != nil {
		return m.InfraHostName
	}
	return ""
}

func (m *InfraF5HostedOnPrem) GetFirmwareVersion() string {
	if m != nil {
		return m.FirmwareVersion
	}
	return ""
}

func (m *InfraF5HostedOnPrem) GetDevices() []*Device {
	if m != nil {
		return m.Devices
	}
	return nil
}

// Devices
//
// x-displayName: "Device"
// The device details
type Device struct {
	// Device name
	//
	// x-displayName: "Device Name"
	// The name for the device
	DeviceName string `protobuf:"bytes,1,opt,name=device_name,json=deviceName,proto3" json:"device_name,omitempty"`
	// Device Firmware version
	//
	// x-displayName: "Firmware Version"
	// The firmware version in device
	DeviceFirmwareVersion string `protobuf:"bytes,2,opt,name=device_firmware_version,json=deviceFirmwareVersion,proto3" json:"device_firmware_version,omitempty"`
	// IP infomation
	//
	// x-displayName: "IP Address"
	// The IP address information for the device
	IpInfo *IPInfo `protobuf:"bytes,3,opt,name=ip_info,json=ipInfo,proto3" json:"ip_info,omitempty"`
	// Certification status
	//
	// x-displayName: "Certification Status"
	// The status of certification in device
	CertificationStatus string `protobuf:"bytes,4,opt,name=certification_status,json=certificationStatus,proto3" json:"certification_status,omitempty"`
}

func (m *Device) Reset()      { *m = Device{} }
func (*Device) ProtoMessage() {}
func (*Device) Descriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{4}
}
func (m *Device) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Device) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Device) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Device.Merge(m, src)
}
func (m *Device) XXX_Size() int {
	return m.Size()
}
func (m *Device) XXX_DiscardUnknown() {
	xxx_messageInfo_Device.DiscardUnknown(m)
}

var xxx_messageInfo_Device proto.InternalMessageInfo

func (m *Device) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *Device) GetDeviceFirmwareVersion() string {
	if m != nil {
		return m.DeviceFirmwareVersion
	}
	return ""
}

func (m *Device) GetIpInfo() *IPInfo {
	if m != nil {
		return m.IpInfo
	}
	return nil
}

func (m *Device) GetCertificationStatus() string {
	if m != nil {
		return m.CertificationStatus
	}
	return ""
}

// IP infomation
//
// x-displayName: "IP Address"
// The IP address information for the device
type IPInfo struct {
	// Traffic
	//
	// x-displayName: "Traffic"
	// traffic address
	Traffic string `protobuf:"bytes,1,opt,name=traffic,proto3" json:"traffic,omitempty"`
	// WAN
	//
	// x-displayName: "WAN"
	// WAN address
	Wan string `protobuf:"bytes,2,opt,name=wan,proto3" json:"wan,omitempty"`
	// Local
	//
	// x-displayName: "Local"
	// local IP address
	Local string `protobuf:"bytes,3,opt,name=local,proto3" json:"local,omitempty"`
}

func (m *IPInfo) Reset()      { *m = IPInfo{} }
func (*IPInfo) ProtoMessage() {}
func (*IPInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{5}
}
func (m *IPInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IPInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPInfo.Merge(m, src)
}
func (m *IPInfo) XXX_Size() int {
	return m.Size()
}
func (m *IPInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_IPInfo.DiscardUnknown(m)
}

var xxx_messageInfo_IPInfo proto.InternalMessageInfo

func (m *IPInfo) GetTraffic() string {
	if m != nil {
		return m.Traffic
	}
	return ""
}

func (m *IPInfo) GetWan() string {
	if m != nil {
		return m.Wan
	}
	return ""
}

func (m *IPInfo) GetLocal() string {
	if m != nil {
		return m.Local
	}
	return ""
}

// Bot Endpoint Policy Metadata
//
// x-displayName: "Bot Endpoint Policy"
// on associated endpoint policy object.
type EndpointPolicyMetadata struct {
	// Policy Name
	//
	// x-displayName: "Policy"
	// Policy Name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Policy Version
	//
	// x-displayName: "Version"
	// Policy Version
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Policy Type
	//
	// x-displayName: "Type"
	// Policy Type
	Type TrafficType `protobuf:"varint,3,opt,name=type,proto3,enum=ves.io.schema.shape.bot_defense.bot_infrastructure.TrafficType" json:"type,omitempty"`
}

func (m *EndpointPolicyMetadata) Reset()      { *m = EndpointPolicyMetadata{} }
func (*EndpointPolicyMetadata) ProtoMessage() {}
func (*EndpointPolicyMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{6}
}
func (m *EndpointPolicyMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EndpointPolicyMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EndpointPolicyMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndpointPolicyMetadata.Merge(m, src)
}
func (m *EndpointPolicyMetadata) XXX_Size() int {
	return m.Size()
}
func (m *EndpointPolicyMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_EndpointPolicyMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_EndpointPolicyMetadata proto.InternalMessageInfo

func (m *EndpointPolicyMetadata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EndpointPolicyMetadata) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *EndpointPolicyMetadata) GetType() TrafficType {
	if m != nil {
		return m.Type
	}
	return WEB
}

// Policy Metadata
//
// x-displayName: "Policy"
// on associated Policy object.
type PolicyMetadata struct {
	// Policy Name
	//
	// x-displayName: "Policy"
	// Policy Name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Policy Version
	//
	// x-displayName: "Version"
	// Policy Version
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *PolicyMetadata) Reset()      { *m = PolicyMetadata{} }
func (*PolicyMetadata) ProtoMessage() {}
func (*PolicyMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{7}
}
func (m *PolicyMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PolicyMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyMetadata.Merge(m, src)
}
func (m *PolicyMetadata) XXX_Size() int {
	return m.Size()
}
func (m *PolicyMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyMetadata proto.InternalMessageInfo

func (m *PolicyMetadata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PolicyMetadata) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

// Ingress
//
// x-displayName: "Ingress"
// Ingress
type Ingress struct {
	// Type Choice
	//
	// x-displayName: "Type"
	// x-required
	// Hostname or IP
	//
	// Types that are valid to be assigned to TypeChoice:
	//	*Ingress_HostName
	//	*Ingress_IpAddress
	TypeChoice isIngress_TypeChoice `protobuf_oneof:"type_choice"`
	// Location
	//
	// x-displayName: "Location"
	// x-required
	// x-example: "US_WEST"
	// Bot infrastructure region
	Region Location `protobuf:"varint,6,opt,name=region,proto3,enum=ves.io.schema.shape.bot_defense.bot_infrastructure.Location" json:"region,omitempty"`
}

func (m *Ingress) Reset()      { *m = Ingress{} }
func (*Ingress) ProtoMessage() {}
func (*Ingress) Descriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{8}
}
func (m *Ingress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ingress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Ingress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ingress.Merge(m, src)
}
func (m *Ingress) XXX_Size() int {
	return m.Size()
}
func (m *Ingress) XXX_DiscardUnknown() {
	xxx_messageInfo_Ingress.DiscardUnknown(m)
}

var xxx_messageInfo_Ingress proto.InternalMessageInfo

type isIngress_TypeChoice interface {
	isIngress_TypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Ingress_HostName struct {
	HostName string `protobuf:"bytes,2,opt,name=host_name,json=hostName,proto3,oneof" json:"host_name,omitempty"`
}
type Ingress_IpAddress struct {
	IpAddress string `protobuf:"bytes,3,opt,name=ip_address,json=ipAddress,proto3,oneof" json:"ip_address,omitempty"`
}

func (*Ingress_HostName) isIngress_TypeChoice()  {}
func (*Ingress_IpAddress) isIngress_TypeChoice() {}

func (m *Ingress) GetTypeChoice() isIngress_TypeChoice {
	if m != nil {
		return m.TypeChoice
	}
	return nil
}

func (m *Ingress) GetHostName() string {
	if x, ok := m.GetTypeChoice().(*Ingress_HostName); ok {
		return x.HostName
	}
	return ""
}

func (m *Ingress) GetIpAddress() string {
	if x, ok := m.GetTypeChoice().(*Ingress_IpAddress); ok {
		return x.IpAddress
	}
	return ""
}

func (m *Ingress) GetRegion() Location {
	if m != nil {
		return m.Region
	}
	return AP_NORTHEAST_1
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Ingress) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Ingress_HostName)(nil),
		(*Ingress_IpAddress)(nil),
	}
}

// Egress
//
// x-displayName: "Egress"
// Egress
type Egress struct {
	// IP Address
	//
	// x-displayName: "IP Address"
	// x-required
	// x-example: "101.0.0.101"
	// Egress IP address
	IpAddress string `protobuf:"bytes,1,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	// Location
	//
	// x-displayName: "Location"
	// x-required
	// x-example: "US_WEST"
	// Region location
	Region Location `protobuf:"varint,4,opt,name=region,proto3,enum=ves.io.schema.shape.bot_defense.bot_infrastructure.Location" json:"region,omitempty"`
}

func (m *Egress) Reset()      { *m = Egress{} }
func (*Egress) ProtoMessage() {}
func (*Egress) Descriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{9}
}
func (m *Egress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Egress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Egress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Egress.Merge(m, src)
}
func (m *Egress) XXX_Size() int {
	return m.Size()
}
func (m *Egress) XXX_DiscardUnknown() {
	xxx_messageInfo_Egress.DiscardUnknown(m)
}

var xxx_messageInfo_Egress proto.InternalMessageInfo

func (m *Egress) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *Egress) GetRegion() Location {
	if m != nil {
		return m.Region
	}
	return AP_NORTHEAST_1
}

// Production
//
// x-displayName: "Production"
type Production struct {
	// Bot Infrastructure Regions
	//
	// x-displayName: "Ingress Region 1"
	// x-required
	// This is an Active-Active Infrastructure configuration where traffic is routed equally between the two regions.
	Region_1 string `protobuf:"bytes,1,opt,name=region_1,json=region1,proto3" json:"region_1,omitempty"`
	// Bot Infrastructure Regions
	//
	// x-displayName: "Ingress Region 2"
	// x-required
	// This is an Active-Active Infrastructure configuration where traffic is routed equally between the two regions.
	Region_2 string `protobuf:"bytes,2,opt,name=region_2,json=region2,proto3" json:"region_2,omitempty"`
}

func (m *Production) Reset()      { *m = Production{} }
func (*Production) ProtoMessage() {}
func (*Production) Descriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{10}
}
func (m *Production) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Production) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Production) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Production.Merge(m, src)
}
func (m *Production) XXX_Size() int {
	return m.Size()
}
func (m *Production) XXX_DiscardUnknown() {
	xxx_messageInfo_Production.DiscardUnknown(m)
}

var xxx_messageInfo_Production proto.InternalMessageInfo

func (m *Production) GetRegion_1() string {
	if m != nil {
		return m.Region_1
	}
	return ""
}

func (m *Production) GetRegion_2() string {
	if m != nil {
		return m.Region_2
	}
	return ""
}

// Testing
//
// x-displayName: "Testing"
type Testing struct {
	// Bot Infrastructure Regions
	//
	// x-displayName: "Ingress Region 1"
	// x-required
	// This is an Active-Passive Infrastructure configuration where traffic is routed to a single region.
	Region_1 string `protobuf:"bytes,1,opt,name=region_1,json=region1,proto3" json:"region_1,omitempty"`
}

func (m *Testing) Reset()      { *m = Testing{} }
func (*Testing) ProtoMessage() {}
func (*Testing) Descriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{11}
}
func (m *Testing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Testing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Testing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Testing.Merge(m, src)
}
func (m *Testing) XXX_Size() int {
	return m.Size()
}
func (m *Testing) XXX_DiscardUnknown() {
	xxx_messageInfo_Testing.DiscardUnknown(m)
}

var xxx_messageInfo_Testing proto.InternalMessageInfo

func (m *Testing) GetRegion_1() string {
	if m != nil {
		return m.Region_1
	}
	return ""
}

// Get Bot Infrastructure
//
// x-displayName: "Get Bot Infrastructure"
// Get Bot Infrastructure
type GetSpecType struct {
	BotEndpointPolicyMetadata  *EndpointPolicyMetadata `protobuf:"bytes,2,opt,name=bot_endpoint_policy_metadata,json=botEndpointPolicyMetadata,proto3" json:"bot_endpoint_policy_metadata,omitempty"`
	BotAllowlistPolicyMetadata *PolicyMetadata         `protobuf:"bytes,4,opt,name=bot_allowlist_policy_metadata,json=botAllowlistPolicyMetadata,proto3" json:"bot_allowlist_policy_metadata,omitempty"`
	BotNetworkPolicyMetadata   *PolicyMetadata         `protobuf:"bytes,6,opt,name=bot_network_policy_metadata,json=botNetworkPolicyMetadata,proto3" json:"bot_network_policy_metadata,omitempty"`
	EnvironmentType            EnvironmentType         `protobuf:"varint,7,opt,name=environment_type,json=environmentType,proto3,enum=ves.io.schema.shape.bot_defense.bot_infrastructure.EnvironmentType" json:"environment_type,omitempty"`
	TrafficType                TrafficType             `protobuf:"varint,8,opt,name=traffic_type,json=trafficType,proto3,enum=ves.io.schema.shape.bot_defense.bot_infrastructure.TrafficType" json:"traffic_type,omitempty"`
	InfraType                  InfraType               `protobuf:"varint,9,opt,name=infra_type,json=infraType,proto3,enum=ves.io.schema.shape.bot_defense.bot_infrastructure.InfraType" json:"infra_type,omitempty"`
	InfraHostName              string                  `protobuf:"bytes,10,opt,name=infra_host_name,json=infraHostName,proto3" json:"infra_host_name,omitempty"`
	Ingress                    []*Ingress              `protobuf:"bytes,11,rep,name=ingress,proto3" json:"ingress,omitempty"`
	Egress                     []*Egress               `protobuf:"bytes,12,rep,name=egress,proto3" json:"egress,omitempty"`
	HostNames                  []string                `protobuf:"bytes,13,rep,name=host_names,json=hostNames,proto3" json:"host_names,omitempty"`
	IpAddresses                []string                `protobuf:"bytes,14,rep,name=ip_addresses,json=ipAddresses,proto3" json:"ip_addresses,omitempty"`
	InfraRegion                []Location              `protobuf:"varint,15,rep,packed,name=infra_region,json=infraRegion,proto3,enum=ves.io.schema.shape.bot_defense.bot_infrastructure.Location" json:"infra_region,omitempty"`
	// Types that are valid to be assigned to BotInfraChoice:
	//	*GetSpecType_CloudHosted
	//	*GetSpecType_PhysicalHosted
	//	*GetSpecType_OnPrem
	BotInfraChoice isGetSpecType_BotInfraChoice `protobuf_oneof:"bot_infra_choice"`
	ClusterState   ClusterState                 `protobuf:"varint,23,opt,name=cluster_state,json=clusterState,proto3,enum=ves.io.schema.shape.bot_defense.bot_infrastructure.ClusterState" json:"cluster_state,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{12}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_BotInfraChoice interface {
	isGetSpecType_BotInfraChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_CloudHosted struct {
	CloudHosted *InfraCloudHosted `protobuf:"bytes,20,opt,name=cloud_hosted,json=cloudHosted,proto3,oneof" json:"cloud_hosted,omitempty"`
}
type GetSpecType_PhysicalHosted struct {
	PhysicalHosted *InfraF5HostedOnPrem `protobuf:"bytes,21,opt,name=physical_hosted,json=physicalHosted,proto3,oneof" json:"physical_hosted,omitempty"`
}
type GetSpecType_OnPrem struct {
	OnPrem *InfraF5HostedOnPrem `protobuf:"bytes,22,opt,name=on_prem,json=onPrem,proto3,oneof" json:"on_prem,omitempty"`
}

func (*GetSpecType_CloudHosted) isGetSpecType_BotInfraChoice()    {}
func (*GetSpecType_PhysicalHosted) isGetSpecType_BotInfraChoice() {}
func (*GetSpecType_OnPrem) isGetSpecType_BotInfraChoice()         {}

func (m *GetSpecType) GetBotInfraChoice() isGetSpecType_BotInfraChoice {
	if m != nil {
		return m.BotInfraChoice
	}
	return nil
}

func (m *GetSpecType) GetBotEndpointPolicyMetadata() *EndpointPolicyMetadata {
	if m != nil {
		return m.BotEndpointPolicyMetadata
	}
	return nil
}

func (m *GetSpecType) GetBotAllowlistPolicyMetadata() *PolicyMetadata {
	if m != nil {
		return m.BotAllowlistPolicyMetadata
	}
	return nil
}

func (m *GetSpecType) GetBotNetworkPolicyMetadata() *PolicyMetadata {
	if m != nil {
		return m.BotNetworkPolicyMetadata
	}
	return nil
}

func (m *GetSpecType) GetEnvironmentType() EnvironmentType {
	if m != nil {
		return m.EnvironmentType
	}
	return PRODUCTION
}

func (m *GetSpecType) GetTrafficType() TrafficType {
	if m != nil {
		return m.TrafficType
	}
	return WEB
}

func (m *GetSpecType) GetInfraType() InfraType {
	if m != nil {
		return m.InfraType
	}
	return F5_CLOUD_HOSTED
}

func (m *GetSpecType) GetInfraHostName() string {
	if m != nil {
		return m.InfraHostName
	}
	return ""
}

func (m *GetSpecType) GetIngress() []*Ingress {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *GetSpecType) GetEgress() []*Egress {
	if m != nil {
		return m.Egress
	}
	return nil
}

func (m *GetSpecType) GetHostNames() []string {
	if m != nil {
		return m.HostNames
	}
	return nil
}

func (m *GetSpecType) GetIpAddresses() []string {
	if m != nil {
		return m.IpAddresses
	}
	return nil
}

func (m *GetSpecType) GetInfraRegion() []Location {
	if m != nil {
		return m.InfraRegion
	}
	return nil
}

func (m *GetSpecType) GetCloudHosted() *InfraCloudHosted {
	if x, ok := m.GetBotInfraChoice().(*GetSpecType_CloudHosted); ok {
		return x.CloudHosted
	}
	return nil
}

func (m *GetSpecType) GetPhysicalHosted() *InfraF5HostedOnPrem {
	if x, ok := m.GetBotInfraChoice().(*GetSpecType_PhysicalHosted); ok {
		return x.PhysicalHosted
	}
	return nil
}

func (m *GetSpecType) GetOnPrem() *InfraF5HostedOnPrem {
	if x, ok := m.GetBotInfraChoice().(*GetSpecType_OnPrem); ok {
		return x.OnPrem
	}
	return nil
}

func (m *GetSpecType) GetClusterState() ClusterState {
	if m != nil {
		return m.ClusterState
	}
	return ACTIVE
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_CloudHosted)(nil),
		(*GetSpecType_PhysicalHosted)(nil),
		(*GetSpecType_OnPrem)(nil),
	}
}

// Create Bot Infrastructure
//
// x-displayName: "Create Bot Infrastructure"
// Create Bot Infrastructure
type CreateSpecType struct {
	TrafficType TrafficType `protobuf:"varint,8,opt,name=traffic_type,json=trafficType,proto3,enum=ves.io.schema.shape.bot_defense.bot_infrastructure.TrafficType" json:"traffic_type,omitempty"`
	// Types that are valid to be assigned to CreateBotInfraChoice:
	//	*CreateSpecType_CreateCloudHosted
	CreateBotInfraChoice isCreateSpecType_CreateBotInfraChoice `protobuf_oneof:"create_bot_infra_choice"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{13}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_CreateBotInfraChoice interface {
	isCreateSpecType_CreateBotInfraChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_CreateCloudHosted struct {
	CreateCloudHosted *CreateSpecInfraCloudHosted `protobuf:"bytes,25,opt,name=create_cloud_hosted,json=createCloudHosted,proto3,oneof" json:"create_cloud_hosted,omitempty"`
}

func (*CreateSpecType_CreateCloudHosted) isCreateSpecType_CreateBotInfraChoice() {}

func (m *CreateSpecType) GetCreateBotInfraChoice() isCreateSpecType_CreateBotInfraChoice {
	if m != nil {
		return m.CreateBotInfraChoice
	}
	return nil
}

func (m *CreateSpecType) GetTrafficType() TrafficType {
	if m != nil {
		return m.TrafficType
	}
	return WEB
}

func (m *CreateSpecType) GetCreateCloudHosted() *CreateSpecInfraCloudHosted {
	if x, ok := m.GetCreateBotInfraChoice().(*CreateSpecType_CreateCloudHosted); ok {
		return x.CreateCloudHosted
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_CreateCloudHosted)(nil),
	}
}

// Replace Bot Infrastructure
//
// x-displayName: "Replace Bot Infrastructure"
// Replace Bot Infrastructure
type ReplaceSpecType struct {
	EnvironmentType EnvironmentType `protobuf:"varint,7,opt,name=environment_type,json=environmentType,proto3,enum=ves.io.schema.shape.bot_defense.bot_infrastructure.EnvironmentType" json:"environment_type,omitempty"`
	TrafficType     TrafficType     `protobuf:"varint,8,opt,name=traffic_type,json=trafficType,proto3,enum=ves.io.schema.shape.bot_defense.bot_infrastructure.TrafficType" json:"traffic_type,omitempty"`
	// Types that are valid to be assigned to BotInfraChoice:
	//	*ReplaceSpecType_CloudHosted
	//	*ReplaceSpecType_PhysicalHosted
	//	*ReplaceSpecType_OnPrem
	BotInfraChoice isReplaceSpecType_BotInfraChoice `protobuf_oneof:"bot_infra_choice"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_841e8f848b141fd8, []int{14}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_BotInfraChoice interface {
	isReplaceSpecType_BotInfraChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_CloudHosted struct {
	CloudHosted *InfraCloudHosted `protobuf:"bytes,20,opt,name=cloud_hosted,json=cloudHosted,proto3,oneof" json:"cloud_hosted,omitempty"`
}
type ReplaceSpecType_PhysicalHosted struct {
	PhysicalHosted *InfraF5HostedOnPrem `protobuf:"bytes,21,opt,name=physical_hosted,json=physicalHosted,proto3,oneof" json:"physical_hosted,omitempty"`
}
type ReplaceSpecType_OnPrem struct {
	OnPrem *InfraF5HostedOnPrem `protobuf:"bytes,22,opt,name=on_prem,json=onPrem,proto3,oneof" json:"on_prem,omitempty"`
}

func (*ReplaceSpecType_CloudHosted) isReplaceSpecType_BotInfraChoice()    {}
func (*ReplaceSpecType_PhysicalHosted) isReplaceSpecType_BotInfraChoice() {}
func (*ReplaceSpecType_OnPrem) isReplaceSpecType_BotInfraChoice()         {}

func (m *ReplaceSpecType) GetBotInfraChoice() isReplaceSpecType_BotInfraChoice {
	if m != nil {
		return m.BotInfraChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetEnvironmentType() EnvironmentType {
	if m != nil {
		return m.EnvironmentType
	}
	return PRODUCTION
}

func (m *ReplaceSpecType) GetTrafficType() TrafficType {
	if m != nil {
		return m.TrafficType
	}
	return WEB
}

func (m *ReplaceSpecType) GetCloudHosted() *InfraCloudHosted {
	if x, ok := m.GetBotInfraChoice().(*ReplaceSpecType_CloudHosted); ok {
		return x.CloudHosted
	}
	return nil
}

func (m *ReplaceSpecType) GetPhysicalHosted() *InfraF5HostedOnPrem {
	if x, ok := m.GetBotInfraChoice().(*ReplaceSpecType_PhysicalHosted); ok {
		return x.PhysicalHosted
	}
	return nil
}

func (m *ReplaceSpecType) GetOnPrem() *InfraF5HostedOnPrem {
	if x, ok := m.GetBotInfraChoice().(*ReplaceSpecType_OnPrem); ok {
		return x.OnPrem
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_CloudHosted)(nil),
		(*ReplaceSpecType_PhysicalHosted)(nil),
		(*ReplaceSpecType_OnPrem)(nil),
	}
}

func init() {
	proto.RegisterEnum("ves.io.schema.shape.bot_defense.bot_infrastructure.ClusterState", ClusterState_name, ClusterState_value)
	golang_proto.RegisterEnum("ves.io.schema.shape.bot_defense.bot_infrastructure.ClusterState", ClusterState_name, ClusterState_value)
	proto.RegisterEnum("ves.io.schema.shape.bot_defense.bot_infrastructure.EnvironmentType", EnvironmentType_name, EnvironmentType_value)
	golang_proto.RegisterEnum("ves.io.schema.shape.bot_defense.bot_infrastructure.EnvironmentType", EnvironmentType_name, EnvironmentType_value)
	proto.RegisterEnum("ves.io.schema.shape.bot_defense.bot_infrastructure.TrafficType", TrafficType_name, TrafficType_value)
	golang_proto.RegisterEnum("ves.io.schema.shape.bot_defense.bot_infrastructure.TrafficType", TrafficType_name, TrafficType_value)
	proto.RegisterEnum("ves.io.schema.shape.bot_defense.bot_infrastructure.InfraType", InfraType_name, InfraType_value)
	golang_proto.RegisterEnum("ves.io.schema.shape.bot_defense.bot_infrastructure.InfraType", InfraType_name, InfraType_value)
	proto.RegisterEnum("ves.io.schema.shape.bot_defense.bot_infrastructure.Location", Location_name, Location_value)
	golang_proto.RegisterEnum("ves.io.schema.shape.bot_defense.bot_infrastructure.Location", Location_name, Location_value)
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.GlobalSpecType")
	proto.RegisterType((*InfraCloudHosted)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.InfraCloudHosted")
	golang_proto.RegisterType((*InfraCloudHosted)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.InfraCloudHosted")
	proto.RegisterType((*CreateSpecInfraCloudHosted)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.CreateSpecInfraCloudHosted")
	golang_proto.RegisterType((*CreateSpecInfraCloudHosted)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.CreateSpecInfraCloudHosted")
	proto.RegisterType((*InfraF5HostedOnPrem)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.InfraF5HostedOnPrem")
	golang_proto.RegisterType((*InfraF5HostedOnPrem)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.InfraF5HostedOnPrem")
	proto.RegisterType((*Device)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.Device")
	golang_proto.RegisterType((*Device)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.Device")
	proto.RegisterType((*IPInfo)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.IPInfo")
	golang_proto.RegisterType((*IPInfo)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.IPInfo")
	proto.RegisterType((*EndpointPolicyMetadata)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.EndpointPolicyMetadata")
	golang_proto.RegisterType((*EndpointPolicyMetadata)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.EndpointPolicyMetadata")
	proto.RegisterType((*PolicyMetadata)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.PolicyMetadata")
	golang_proto.RegisterType((*PolicyMetadata)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.PolicyMetadata")
	proto.RegisterType((*Ingress)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.Ingress")
	golang_proto.RegisterType((*Ingress)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.Ingress")
	proto.RegisterType((*Egress)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.Egress")
	golang_proto.RegisterType((*Egress)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.Egress")
	proto.RegisterType((*Production)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.Production")
	golang_proto.RegisterType((*Production)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.Production")
	proto.RegisterType((*Testing)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.Testing")
	golang_proto.RegisterType((*Testing)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.Testing")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.GetSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.shape.bot_defense.bot_infrastructure.ReplaceSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/shape/bot_defense/bot_infrastructure/types.proto", fileDescriptor_841e8f848b141fd8)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/shape/bot_defense/bot_infrastructure/types.proto", fileDescriptor_841e8f848b141fd8)
}

var fileDescriptor_841e8f848b141fd8 = []byte{
	// 2700 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xe7, 0x88, 0x14, 0x3f, 0x1e, 0x29, 0x6a, 0x34, 0xfa, 0xa2, 0x68, 0x87, 0x66, 0xe8, 0x36,
	0x56, 0x04, 0x99, 0x0a, 0x57, 0xce, 0x47, 0x95, 0xd4, 0x09, 0x49, 0xd1, 0x16, 0x05, 0x49, 0x64,
	0x97, 0x94, 0x9d, 0x14, 0x45, 0xb6, 0x4b, 0x72, 0x24, 0x6d, 0x43, 0x71, 0xd9, 0xdd, 0x95, 0x14,
	0x01, 0x11, 0x9a, 0x04, 0x28, 0x5a, 0x20, 0x97, 0xb4, 0xb7, 0x1e, 0x7b, 0x09, 0x5a, 0x17, 0xfd,
	0x07, 0xc2, 0xb4, 0x70, 0x73, 0x0a, 0x7c, 0xd2, 0xa5, 0x80, 0x81, 0x5e, 0x1a, 0xf9, 0x92, 0xf6,
	0xe4, 0x43, 0x0f, 0x45, 0x7a, 0x29, 0x76, 0x76, 0x97, 0x5a, 0x92, 0x2b, 0x47, 0xa2, 0x65, 0x03,
	0x45, 0x73, 0x32, 0xe7, 0x7d, 0xbf, 0x37, 0x33, 0xef, 0xb7, 0xf3, 0x2c, 0xb8, 0xbe, 0x4b, 0xd5,
	0xa4, 0x24, 0xcf, 0xa9, 0xd5, 0x2d, 0xba, 0x2d, 0xce, 0xa9, 0x5b, 0x62, 0x93, 0xce, 0x55, 0x64,
	0x4d, 0xa8, 0xd1, 0x0d, 0xda, 0x50, 0x8d, 0xdf, 0x52, 0x63, 0x43, 0x11, 0x55, 0x4d, 0xd9, 0xa9,
	0x6a, 0x3b, 0x0a, 0x9d, 0xd3, 0xf6, 0x9b, 0x54, 0x4d, 0x36, 0x15, 0x59, 0x93, 0x09, 0x67, 0xe8,
	0x27, 0x0d, 0xfd, 0x24, 0xd3, 0x4f, 0xda, 0xf4, 0x93, 0xbd, 0xfa, 0xd1, 0xab, 0x9b, 0x92, 0xb6,
	0xb5, 0x53, 0x49, 0x56, 0xe5, 0xed, 0xb9, 0x4d, 0x79, 0x53, 0x9e, 0x63, 0xa6, 0x2a, 0x3b, 0x1b,
	0x6c, 0xc5, 0x16, 0xec, 0x97, 0xe1, 0x22, 0x3a, 0xb5, 0x29, 0xcb, 0x9b, 0x75, 0x7a, 0x2c, 0x25,
	0x36, 0xf6, 0x4d, 0xd6, 0x85, 0xce, 0xe8, 0xe5, 0xa6, 0x26, 0xc9, 0x0d, 0x33, 0xb4, 0xe8, 0x1b,
	0xa7, 0x49, 0x4d, 0xac, 0xd7, 0xe5, 0xbd, 0xba, 0xa4, 0x6a, 0x42, 0x53, 0xae, 0x4b, 0xd5, 0x7d,
	0x7b, 0x72, 0xd1, 0xd7, 0x4f, 0x63, 0x81, 0x36, 0x6a, 0x4d, 0x59, 0x6a, 0x38, 0x1a, 0x38, 0x55,
	0x75, 0x1b, 0x54, 0xdb, 0x93, 0x95, 0x77, 0x9c, 0xf4, 0xa7, 0x3a, 0xf5, 0xed, 0xac, 0x8b, 0x9d,
	0xac, 0x5d, 0xb1, 0x2e, 0xd5, 0x44, 0x8d, 0x9a, 0xdc, 0x78, 0x17, 0x57, 0xa2, 0x7b, 0x42, 0x67,
	0x75, 0x2e, 0xf5, 0x4a, 0xa8, 0x76, 0x07, 0x89, 0x87, 0xe3, 0x10, 0xbe, 0x59, 0x97, 0x2b, 0x62,
	0xbd, 0xd4, 0xa4, 0xd5, 0xf2, 0x7e, 0x93, 0x92, 0x9f, 0xc2, 0xa8, 0x43, 0xc6, 0x11, 0x14, 0x47,
	0xd3, 0x41, 0x2e, 0x91, 0xec, 0x3c, 0x0a, 0xcc, 0x62, 0xb2, 0x50, 0xf9, 0x09, 0xad, 0x6a, 0x3c,
	0xdd, 0xd0, 0x0d, 0x64, 0x9e, 0xb9, 0x73, 0xe0, 0x64, 0xe1, 0xfe, 0x01, 0xfa, 0xaa, 0x85, 0x10,
	0x3f, 0x52, 0x91, 0xb5, 0x9c, 0xc9, 0x2a, 0x32, 0x0e, 0xf9, 0x15, 0x82, 0x8b, 0x0e, 0x1a, 0xc2,
	0x36, 0xd5, 0xc4, 0x9a, 0xa8, 0x89, 0x91, 0x01, 0xe6, 0x7c, 0x39, 0x79, 0xf6, 0x73, 0x98, 0xec,
	0x74, 0xb5, 0x6a, 0x5a, 0xcc, 0x78, 0x1e, 0xea, 0xb1, 0x4c, 0xf5, 0xc4, 0x62, 0x09, 0x10, 0x0d,
	0xc6, 0x9c, 0x8e, 0x4e, 0xc4, 0x7d, 0xea, 0x3a, 0xc4, 0xee, 0x1c, 0x38, 0x9a, 0xb0, 0x0a, 0x41,
	0x2a, 0xb2, 0x96, 0xb6, 0x78, 0x66, 0x25, 0x3e, 0x42, 0xf0, 0x8c, 0x93, 0xce, 0x71, 0x29, 0x3c,
	0xcc, 0x7f, 0xa6, 0x9f, 0x52, 0x38, 0x96, 0x20, 0xda, 0x1b, 0x45, 0xbb, 0x06, 0x0d, 0x20, 0xbd,
	0x67, 0x37, 0x32, 0x78, 0xea, 0x0a, 0x5c, 0xbc, 0x73, 0xe0, 0x60, 0xc0, 0xca, 0x1f, 0x57, 0x64,
	0x6d, 0xcd, 0xe0, 0x98, 0xd9, 0xff, 0x02, 0xc1, 0x85, 0x5e, 0xf9, 0xe3, 0xdc, 0xbd, 0xe7, 0x9c,
	0x7b, 0xa4, 0x3b, 0x02, 0x5b, 0xe6, 0x98, 0x36, 0x76, 0x25, 0x45, 0x6e, 0x6c, 0xd3, 0x86, 0x26,
	0xe8, 0x57, 0x26, 0xe2, 0x8b, 0xa3, 0xe9, 0x30, 0x97, 0xed, 0xef, 0x10, 0xb6, 0x6d, 0xe9, 0x85,
	0xe1, 0x87, 0x69, 0x27, 0x81, 0x54, 0x20, 0xa4, 0x29, 0xe2, 0xc6, 0x86, 0x54, 0x35, 0x7c, 0xf9,
	0x99, 0xaf, 0xd7, 0xfb, 0xf1, 0x55, 0x36, 0xec, 0x30, 0x3f, 0x41, 0xed, 0x78, 0x41, 0x7e, 0x89,
	0x00, 0x98, 0xac, 0xe1, 0x22, 0xc0, 0x5c, 0x7c, 0xbf, 0x1f, 0x17, 0x79, 0x7d, 0xc9, 0x76, 0x78,
	0xe6, 0xe8, 0xe0, 0x32, 0x4f, 0x9b, 0x75, 0xb1, 0x4a, 0x6b, 0xf1, 0xca, 0x7e, 0xfc, 0x4a, 0x5b,
	0x9a, 0x39, 0x11, 0xaa, 0x5b, 0xb2, 0x54, 0xa5, 0x57, 0xd8, 0x7e, 0x07, 0x24, 0x4b, 0x8d, 0x14,
	0x60, 0xd8, 0x10, 0xda, 0x92, 0x55, 0x4d, 0x68, 0x88, 0xdb, 0x34, 0x02, 0x71, 0x34, 0x1d, 0xc8,
	0x5c, 0x39, 0x3a, 0x98, 0x5c, 0x95, 0x77, 0x69, 0x2d, 0xae, 0xc9, 0xf1, 0x2b, 0xd5, 0xba, 0xbc,
	0x53, 0x63, 0x32, 0xb4, 0xc6, 0x6c, 0x7c, 0xfa, 0x8f, 0xbb, 0x6e, 0x8f, 0x32, 0xb0, 0x85, 0xf8,
	0x21, 0xa6, 0xbf, 0x24, 0xab, 0xda, 0x9a, 0xb8, 0x4d, 0xc9, 0xcf, 0xc0, 0x27, 0x35, 0x36, 0x15,
	0xaa, 0xaa, 0x91, 0x60, 0xdc, 0x3d, 0x1d, 0xe4, 0x5e, 0xed, 0x2f, 0x2f, 0x66, 0x22, 0x33, 0xfd,
	0xcd, 0x51, 0x0c, 0xfe, 0x1a, 0x0d, 0x44, 0x10, 0x6f, 0x79, 0x25, 0xef, 0x81, 0x97, 0x1a, 0xfe,
	0x43, 0xcc, 0xff, 0x42, 0x5f, 0xc7, 0xe4, 0xac, 0xee, 0x4d, 0x9f, 0xe4, 0x06, 0x40, 0xbb, 0x92,
	0x6a, 0x64, 0x28, 0xee, 0x3e, 0x4b, 0x29, 0x03, 0x5b, 0x66, 0x15, 0x55, 0xb2, 0x0c, 0x21, 0xa9,
	0x29, 0x88, 0xb5, 0x9a, 0x6e, 0x95, 0xaa, 0x91, 0xf0, 0x19, 0x2c, 0x35, 0x11, 0x1f, 0x94, 0x9a,
	0x69, 0x4b, 0x97, 0x7c, 0x88, 0x20, 0x64, 0x6c, 0xb2, 0x42, 0x37, 0x25, 0xb9, 0x11, 0x19, 0x8e,
	0xbb, 0xa7, 0xc3, 0xdc, 0x6b, 0xfd, 0x14, 0x66, 0x45, 0xae, 0x8a, 0x3a, 0xae, 0x65, 0x9e, 0xbd,
	0x7f, 0x80, 0x1e, 0x1d, 0x0d, 0x1f, 0x64, 0xba, 0x3c, 0xf3, 0x49, 0x5e, 0x86, 0xd1, 0x0d, 0x49,
	0xd9, 0xde, 0x13, 0x15, 0x2a, 0x28, 0xb4, 0x4e, 0x45, 0x95, 0x0a, 0x52, 0x2d, 0x82, 0xd9, 0x61,
	0xf3, 0xb5, 0x21, 0xc9, 0x92, 0xe1, 0x0d, 0x91, 0x7c, 0x8d, 0x5c, 0x85, 0xb0, 0xda, 0xdc, 0x16,
	0xaa, 0xf5, 0x1d, 0x55, 0xa3, 0x8a, 0xae, 0x33, 0xd2, 0xa9, 0x13, 0x52, 0x9b, 0xdb, 0x59, 0x83,
	0x9b, 0xaf, 0x91, 0xdf, 0x22, 0x60, 0x47, 0x5f, 0xdb, 0x52, 0xa8, 0xa8, 0x87, 0xaf, 0xd1, 0x7a,
	0x5d, 0xda, 0xa4, 0x8d, 0x2a, 0xed, 0xe9, 0x62, 0xe4, 0xdc, 0xba, 0x58, 0x3b, 0x98, 0xcb, 0x15,
	0x59, 0x2b, 0x33, 0xd7, 0x79, 0x9b, 0xe7, 0xae, 0x9e, 0x26, 0x41, 0xc8, 0x5e, 0xad, 0xc8, 0x18,
	0x8b, 0x63, 0xb1, 0xef, 0x06, 0x90, 0xd5, 0x8d, 0x2d, 0x31, 0x5b, 0x4b, 0x2e, 0x3e, 0x58, 0x3d,
	0x5e, 0x12, 0x05, 0x86, 0x9b, 0x5b, 0xfb, 0xaa, 0x54, 0x15, 0xeb, 0x96, 0xb7, 0x71, 0xe6, 0xed,
	0x66, 0xdf, 0xde, 0x6e, 0xbc, 0x68, 0xd8, 0x2e, 0x34, 0x8a, 0x0a, 0xdd, 0x5e, 0x72, 0xf1, 0x61,
	0xcb, 0x83, 0xe9, 0xb3, 0x02, 0x3e, 0xb9, 0x21, 0x34, 0x15, 0xba, 0x1d, 0x99, 0x38, 0x6f, 0x5f,
	0x5e, 0x99, 0xfd, 0x22, 0x14, 0x86, 0xac, 0x13, 0xa1, 0x6a, 0xa2, 0x46, 0x23, 0x93, 0xac, 0x89,
	0xbe, 0xd1, 0x8f, 0x27, 0xf3, 0xf0, 0x94, 0x74, 0x3b, 0x7c, 0xa8, 0x6a, 0x5b, 0x91, 0xf7, 0x11,
	0x8c, 0x56, 0xf5, 0xdd, 0xa4, 0x42, 0xc7, 0x8e, 0x4d, 0xb1, 0xbc, 0xd6, 0xfa, 0xf2, 0xc6, 0xcc,
	0xe9, 0x1f, 0x79, 0x3d, 0x7b, 0x87, 0xf8, 0x11, 0xc3, 0x99, 0x8d, 0xb8, 0xb0, 0xf7, 0x79, 0x0b,
	0xa9, 0x10, 0x81, 0xd1, 0x8c, 0xac, 0xc5, 0xad, 0x4f, 0xa4, 0xb8, 0x89, 0xd3, 0x88, 0x83, 0x29,
	0x18, 0xd3, 0x39, 0xed, 0x2f, 0x87, 0x36, 0xeb, 0x1a, 0x4c, 0x02, 0xd1, 0x59, 0x26, 0xb0, 0xb6,
	0x19, 0x2f, 0xc1, 0x65, 0x18, 0xcd, 0x77, 0x44, 0x15, 0x67, 0x60, 0x10, 0x7a, 0x79, 0x36, 0xfe,
	0xca, 0x6c, 0x9c, 0x9b, 0x9f, 0x8d, 0xa7, 0xbe, 0x97, 0x99, 0x06, 0x7c, 0x8c, 0x21, 0x06, 0x7c,
	0x90, 0xb1, 0xbb, 0x2d, 0x34, 0x76, 0xd8, 0x42, 0xa3, 0x47, 0x2d, 0xe4, 0xe7, 0x5e, 0x98, 0xe5,
	0x52, 0xb3, 0x1c, 0x97, 0x79, 0x1e, 0x26, 0xcd, 0x22, 0xf5, 0x28, 0x84, 0xef, 0xb6, 0xd0, 0xd4,
	0x61, 0x0b, 0x45, 0x8e, 0x5a, 0x68, 0x80, 0x7b, 0x71, 0xd9, 0xe3, 0x1f, 0xc5, 0x63, 0xcb, 0x1e,
	0x7f, 0x04, 0x4f, 0x25, 0x7e, 0xe3, 0x05, 0xdc, 0x5d, 0x03, 0xb2, 0xdf, 0x0b, 0x48, 0x88, 0xdd,
	0xf7, 0x1f, 0xdc, 0xf9, 0x0c, 0x2d, 0x92, 0x4c, 0x1f, 0x15, 0x37, 0x61, 0xd1, 0xfa, 0xae, 0x3e,
	0x11, 0xba, 0x54, 0xc0, 0xed, 0x16, 0xb5, 0x4b, 0x15, 0x55, 0x6f, 0x95, 0x03, 0xcc, 0xf7, 0xd2,
	0x79, 0xf9, 0xe6, 0x87, 0x2d, 0x0f, 0xb7, 0x0c, 0x07, 0xe4, 0xf7, 0xe8, 0x18, 0x30, 0xdd, 0x8f,
	0x0f, 0x98, 0xfc, 0x79, 0x56, 0xa9, 0x1b, 0x5a, 0x3f, 0x41, 0x6d, 0x6c, 0xf5, 0x3c, 0x36, 0xb6,
	0x3e, 0x89, 0x48, 0x2d, 0x14, 0x9e, 0xee, 0x40, 0xe1, 0x41, 0x86, 0x9d, 0x01, 0x47, 0x9c, 0x9d,
	0xed, 0xc2, 0x59, 0x6f, 0x87, 0x6c, 0x37, 0x92, 0x6e, 0x75, 0x01, 0xa9, 0xef, 0x1c, 0x80, 0xb4,
	0x0d, 0x1d, 0x76, 0xb8, 0x4c, 0xfc, 0x61, 0x00, 0xa2, 0x27, 0x77, 0x0a, 0xf2, 0x63, 0x80, 0xa6,
	0x22, 0xd7, 0x76, 0xaa, 0x9a, 0x75, 0x48, 0x83, 0xdc, 0xf5, 0xbe, 0x70, 0xac, 0x6d, 0x65, 0xc9,
	0xc5, 0xdb, 0x6c, 0x92, 0xdb, 0xe0, 0xd3, 0xa8, 0xaa, 0x49, 0x8d, 0x4d, 0xf3, 0xa1, 0xd5, 0xd7,
	0xb1, 0x2c, 0x1b, 0x26, 0x96, 0x5c, 0xbc, 0x65, 0xad, 0xa7, 0xe2, 0x9e, 0x47, 0x55, 0x3c, 0x13,
	0x83, 0xa0, 0xed, 0xf3, 0x95, 0x0c, 0xdf, 0x6d, 0xa1, 0x81, 0xc3, 0x16, 0x42, 0x47, 0x2d, 0xe4,
	0xe6, 0x66, 0xe7, 0x97, 0x3d, 0x7e, 0x84, 0x07, 0x12, 0x7f, 0x46, 0x66, 0x43, 0xeb, 0xc4, 0x0b,
	0xf2, 0x5c, 0x6f, 0x33, 0xd1, 0x93, 0x09, 0x74, 0xdf, 0xfc, 0xe7, 0x1d, 0x6e, 0x3e, 0xeb, 0x3a,
	0xbd, 0xf7, 0xb5, 0x0c, 0xbe, 0x1a, 0xdd, 0x95, 0xaa, 0x54, 0x8d, 0x0c, 0xf4, 0x7f, 0x07, 0x16,
	0x99, 0x09, 0xde, 0x32, 0x95, 0xf8, 0x8b, 0x1b, 0xbc, 0x06, 0x8d, 0x5c, 0x82, 0xa0, 0x41, 0xb5,
	0x35, 0x3f, 0x1e, 0x0c, 0x12, 0x0b, 0xf6, 0x25, 0x98, 0x34, 0x05, 0x9c, 0xbb, 0x15, 0x3f, 0x6e,
	0xb0, 0x6f, 0x74, 0x45, 0x5e, 0x02, 0x9f, 0xd4, 0xd4, 0x03, 0x91, 0xcd, 0x1d, 0xed, 0x2b, 0xf2,
	0x7c, 0x31, 0xdf, 0xd8, 0x90, 0x79, 0xaf, 0xd4, 0xd4, 0xff, 0x25, 0x29, 0x18, 0xab, 0x52, 0x45,
	0x93, 0x36, 0x24, 0xe3, 0x38, 0x33, 0x34, 0xde, 0x51, 0xd9, 0xe3, 0x38, 0xc0, 0x8f, 0x76, 0xf0,
	0x4a, 0x8c, 0xb5, 0xf0, 0x57, 0x74, 0xaf, 0x85, 0x0e, 0x11, 0x8c, 0x83, 0x47, 0xcf, 0x27, 0x3a,
	0xd4, 0x91, 0x30, 0x5c, 0x05, 0x6c, 0x45, 0x1e, 0x37, 0x43, 0x8f, 0x4e, 0x9d, 0x98, 0x32, 0xbc,
	0x09, 0xa1, 0x7c, 0x31, 0xde, 0x3e, 0x30, 0xfc, 0x12, 0x44, 0xc9, 0xb0, 0x99, 0x67, 0xd2, 0x7c,
	0x74, 0x45, 0x7d, 0xe6, 0x53, 0x0c, 0x08, 0x09, 0x5a, 0xbc, 0x3d, 0xb1, 0x11, 0x75, 0xdf, 0x4e,
	0xaf, 0xc1, 0x04, 0x19, 0xb2, 0x68, 0x75, 0xb9, 0x2a, 0xd6, 0xa3, 0x83, 0xfa, 0xdd, 0xac, 0x43,
	0x12, 0xc6, 0xb2, 0xf6, 0xf0, 0xe3, 0x46, 0xfc, 0xd1, 0x09, 0xe7, 0x94, 0x13, 0xef, 0x80, 0xd7,
	0x28, 0x0e, 0xb9, 0x0c, 0x3e, 0xd3, 0xb3, 0x89, 0x5d, 0xb6, 0xd3, 0x6d, 0x71, 0xc8, 0x05, 0x70,
	0xef, 0x89, 0x16, 0xc0, 0xd8, 0x04, 0x74, 0x2a, 0xb9, 0x04, 0x83, 0x2c, 0x16, 0xe3, 0xb8, 0xda,
	0xd9, 0x06, 0x3d, 0xd1, 0x42, 0x30, 0x71, 0xc2, 0xbc, 0x24, 0x01, 0x1e, 0x1b, 0x6c, 0x86, 0xff,
	0xdd, 0x42, 0x2e, 0xd6, 0x22, 0x15, 0xf7, 0x7d, 0x84, 0x78, 0xc6, 0x23, 0xd3, 0xe0, 0xeb, 0x44,
	0xb8, 0x6e, 0x31, 0x8b, 0x4d, 0x4a, 0xe0, 0x61, 0x8f, 0x54, 0xf7, 0xf9, 0xbc, 0x83, 0x99, 0xb1,
	0xc4, 0xdb, 0x10, 0x7e, 0x92, 0x41, 0x27, 0xfe, 0x36, 0x00, 0x3e, 0x13, 0x11, 0xc9, 0x34, 0x04,
	0x8e, 0x6f, 0x7f, 0x67, 0xb5, 0xb7, 0xd0, 0x92, 0x8b, 0xf7, 0x5b, 0x60, 0x40, 0x66, 0x00, 0x8e,
	0x3b, 0x53, 0x4f, 0xe5, 0x97, 0x5c, 0x7c, 0xa0, 0xdd, 0x99, 0x48, 0x19, 0xbc, 0x26, 0x06, 0x78,
	0x59, 0x61, 0x1e, 0x0b, 0x03, 0x78, 0xd3, 0xd6, 0xc2, 0x7b, 0xf7, 0x5a, 0xe8, 0x5d, 0x78, 0xcd,
	0xb8, 0x18, 0x33, 0xd7, 0x80, 0x83, 0x09, 0x5b, 0xf4, 0x5c, 0x40, 0x6f, 0x58, 0x71, 0x9d, 0x07,
	0x11, 0x7b, 0xac, 0x1c, 0x1c, 0x5f, 0x01, 0x88, 0xc3, 0xe0, 0x2d, 0xb1, 0xbe, 0x43, 0xb9, 0x49,
	0x9b, 0xaa, 0x5d, 0x1a, 0x26, 0xc0, 0x6f, 0x79, 0x8e, 0x82, 0x95, 0x47, 0x1c, 0x65, 0xa2, 0x9d,
	0xbd, 0x36, 0xd8, 0xd3, 0x67, 0x97, 0x3d, 0xfe, 0x41, 0xec, 0x4d, 0x7c, 0x81, 0xc0, 0x9b, 0x6b,
	0x03, 0xad, 0xad, 0x64, 0x3d, 0x87, 0xdd, 0xb1, 0x60, 0x9e, 0x73, 0x2c, 0xd8, 0x2b, 0xf7, 0x5a,
	0xe8, 0x1a, 0x44, 0xc1, 0x56, 0x80, 0x68, 0xe8, 0x34, 0xc9, 0x2e, 0x7b, 0xfc, 0x6e, 0xec, 0x49,
	0x34, 0x01, 0x8e, 0x11, 0x90, 0xbc, 0x00, 0x7e, 0x83, 0x2f, 0xa4, 0xcc, 0x5c, 0xc6, 0x3f, 0xfd,
	0x0c, 0x8d, 0xf8, 0xd1, 0x34, 0x7a, 0x01, 0x2d, 0x04, 0xda, 0xf3, 0x64, 0xde, 0x67, 0x88, 0xa5,
	0x6c, 0x1a, 0x9c, 0x79, 0xb6, 0x1e, 0xad, 0xc1, 0x25, 0x5e, 0x05, 0x9f, 0x09, 0x8a, 0x67, 0x77,
	0x97, 0xf8, 0x60, 0x08, 0x82, 0x37, 0xa9, 0xd6, 0x9e, 0x10, 0x7f, 0xf4, 0xd4, 0xc7, 0xb5, 0x8f,
	0x1a, 0xd4, 0xfe, 0xfc, 0xe9, 0x8d, 0x4c, 0x1f, 0x39, 0x2c, 0xfd, 0xe0, 0x69, 0x0d, 0x2f, 0xff,
	0xcf, 0xc6, 0x96, 0x3f, 0x3a, 0xf7, 0xa9, 0xa5, 0x7d, 0x12, 0x99, 0x3a, 0x69, 0x12, 0x19, 0x38,
	0xf1, 0xc1, 0x26, 0x9e, 0xeb, 0xac, 0x11, 0x9c, 0x9e, 0x3c, 0x6f, 0x9f, 0xe3, 0x34, 0x11, 0xbe,
	0xf1, 0xa5, 0x32, 0x74, 0x86, 0x97, 0x4a, 0xf8, 0x4c, 0x2f, 0x95, 0xe1, 0x27, 0xf5, 0x52, 0xf9,
	0x76, 0x98, 0xf5, 0xbf, 0x32, 0xcc, 0x5a, 0x18, 0xbb, 0x77, 0xbd, 0xeb, 0xbf, 0x18, 0xbf, 0xba,
	0x8e, 0x9c, 0xc7, 0x3c, 0x1f, 0x7e, 0x8d, 0x7a, 0xa8, 0xc6, 0xec, 0x26, 0xf1, 0xcf, 0x01, 0x08,
	0x1f, 0xbf, 0x4c, 0x9f, 0x5a, 0xf3, 0x79, 0xba, 0x93, 0x38, 0x97, 0xd3, 0x24, 0x6e, 0xbe, 0xa7,
	0x7e, 0x9f, 0xb7, 0x50, 0x0c, 0x2e, 0x3a, 0x0f, 0xd3, 0x06, 0x5f, 0x99, 0x8d, 0x73, 0xd7, 0x32,
	0x2f, 0x9d, 0x3c, 0x1b, 0xbb, 0xf0, 0xe1, 0xd7, 0xe8, 0x24, 0xa6, 0x39, 0x22, 0xfb, 0x8f, 0x07,
	0x86, 0xbb, 0xc6, 0x1d, 0x44, 0x7b, 0xa2, 0xd0, 0x92, 0xf1, 0x7c, 0xfc, 0x27, 0x84, 0x7a, 0x01,
	0x66, 0xeb, 0x89, 0xec, 0xb1, 0xe9, 0xad, 0x63, 0xa7, 0xbf, 0x6d, 0x28, 0x8f, 0xdb, 0x50, 0x16,
	0x46, 0x7a, 0x4e, 0x6a, 0x66, 0xd6, 0xe1, 0x9a, 0x47, 0xf4, 0x6e, 0x7e, 0xf2, 0x55, 0x9f, 0xf9,
	0x17, 0x82, 0x90, 0xbd, 0x9f, 0x10, 0x00, 0x6f, 0x3a, 0x5b, 0xce, 0xdf, 0xca, 0x61, 0x17, 0x09,
	0x81, 0x3f, 0xbf, 0x66, 0xae, 0x10, 0x19, 0x81, 0xa1, 0x62, 0xba, 0x54, 0xca, 0xdf, 0xca, 0x09,
	0x45, 0xbe, 0xf0, 0xe6, 0x5b, 0x78, 0x80, 0x10, 0x08, 0xe7, 0x56, 0x73, 0xfc, 0xcd, 0xdc, 0x5a,
	0xf6, 0x2d, 0xa1, 0x54, 0x2e, 0x14, 0xb1, 0x9b, 0x0c, 0x43, 0x70, 0x7d, 0x2d, 0x7d, 0x2b, 0x9d,
	0x5f, 0x49, 0x67, 0x56, 0x72, 0xd8, 0x43, 0x86, 0x20, 0xc0, 0xe7, 0xb2, 0x85, 0xb5, 0x6c, 0x7e,
	0x25, 0x87, 0x07, 0xc9, 0x28, 0x0c, 0x97, 0xca, 0x69, 0xbe, 0x9c, 0x5f, 0xbb, 0x29, 0x98, 0xb6,
	0xbd, 0x06, 0xb1, 0x50, 0x2c, 0xda, 0x88, 0x3e, 0x32, 0x0e, 0x23, 0xeb, 0xc5, 0xc5, 0x34, 0x93,
	0xbc, 0x91, 0xe7, 0x57, 0x6f, 0xa7, 0xf9, 0x1c, 0xf6, 0xeb, 0xb2, 0x6d, 0x72, 0xb1, 0xb0, 0x92,
	0xcf, 0xbe, 0x85, 0x03, 0x7a, 0x24, 0xb7, 0xd3, 0x79, 0xbb, 0x51, 0x20, 0x53, 0x30, 0x6e, 0xd1,
	0x98, 0x47, 0xa1, 0x9c, 0x5f, 0xcd, 0x15, 0xd6, 0xcb, 0x38, 0x38, 0x93, 0x84, 0xe1, 0xae, 0x4b,
	0x41, 0xc2, 0x00, 0x45, 0xbe, 0xb0, 0xb8, 0x9e, 0x2d, 0xe7, 0x0b, 0x6b, 0xd8, 0x45, 0x82, 0xe0,
	0x2b, 0xe7, 0x4a, 0xba, 0x36, 0x46, 0x33, 0xd3, 0x10, 0xb4, 0x1d, 0x69, 0xe2, 0x03, 0xf7, 0xed,
	0x5c, 0x06, 0xbb, 0xf4, 0x6a, 0xad, 0x16, 0x32, 0x7a, 0x62, 0x28, 0xea, 0xb9, 0xdb, 0x42, 0xae,
	0x99, 0xe7, 0x20, 0xd0, 0xfe, 0xf6, 0xd1, 0x43, 0xbd, 0xf1, 0xa2, 0x90, 0x5d, 0x29, 0xac, 0x2f,
	0x0a, 0x4b, 0x85, 0x52, 0x39, 0xb7, 0x88, 0x5d, 0xa6, 0xdc, 0x1f, 0xbd, 0xc7, 0xaf, 0x16, 0x3d,
	0xfa, 0x74, 0x51, 0x58, 0x2b, 0xf0, 0xe5, 0xa5, 0x5c, 0xba, 0x54, 0x16, 0x52, 0xd8, 0xd5, 0x43,
	0x9b, 0xc7, 0x48, 0x8f, 0x31, 0x5d, 0x14, 0x4a, 0x85, 0xf5, 0xf2, 0x92, 0x90, 0xc2, 0x03, 0x1d,
	0x6b, 0x0e, 0xbb, 0x4d, 0x1d, 0xb6, 0x36, 0xed, 0x78, 0x7a, 0x68, 0x1c, 0x1e, 0xec, 0xa1, 0xcd,
	0x63, 0x2f, 0xc1, 0x10, 0xca, 0xad, 0x0b, 0xd9, 0xdc, 0x5a, 0x99, 0x4f, 0xaf, 0x08, 0x29, 0xec,
	0xd3, 0xad, 0xe7, 0xd6, 0x8d, 0x08, 0x84, 0x14, 0xf6, 0xeb, 0x1b, 0x99, 0x5b, 0x17, 0x6e, 0xe7,
	0x98, 0xe1, 0x80, 0xce, 0x5e, 0xcd, 0xb5, 0x83, 0x01, 0xdd, 0xc0, 0x6a, 0xce, 0x66, 0x20, 0xa8,
	0x2b, 0x94, 0xd2, 0x82, 0x19, 0x49, 0x48, 0x5f, 0xae, 0x97, 0xac, 0xe5, 0x90, 0x7d, 0xc9, 0xe1,
	0xb0, 0xb9, 0x34, 0xad, 0x0f, 0xdb, 0x97, 0x1c, 0xc6, 0x2c, 0xd3, 0x1b, 0x6d, 0x67, 0x23, 0x7a,
	0x06, 0x37, 0xb3, 0x45, 0x21, 0x5d, 0xca, 0x1b, 0x0e, 0x52, 0x98, 0xf4, 0xd0, 0x38, 0x3c, 0x4a,
	0x26, 0x61, 0xb4, 0x4d, 0x6b, 0xd7, 0x32, 0x85, 0xc7, 0x9c, 0x19, 0x1c, 0x1e, 0x77, 0x66, 0xcc,
	0xe3, 0x09, 0x7d, 0x33, 0xdb, 0x0c, 0x16, 0x48, 0x0a, 0x4f, 0x76, 0x48, 0xb7, 0xeb, 0x99, 0xc2,
	0x11, 0x67, 0x06, 0x87, 0xa7, 0xc8, 0x45, 0x88, 0x30, 0xc6, 0x7a, 0x49, 0xaf, 0x53, 0xa7, 0x5a,
	0x94, 0x8c, 0x01, 0xd6, 0xb9, 0xb9, 0x75, 0xbe, 0x50, 0xcc, 0xb1, 0xf4, 0x53, 0xf8, 0x82, 0x03,
	0x95, 0xc3, 0x17, 0x1d, 0xa8, 0xf3, 0xf8, 0x19, 0x72, 0x09, 0x2e, 0xe8, 0x54, 0x16, 0x7a, 0x7a,
	0x35, 0xc7, 0xe7, 0xb3, 0x1d, 0x99, 0xc7, 0x1e, 0x2d, 0xc0, 0xe1, 0x4b, 0x24, 0x0a, 0x13, 0xba,
	0x00, 0x8b, 0xcb, 0x12, 0x30, 0x94, 0xe3, 0x8e, 0x3c, 0x23, 0xca, 0x67, 0xad, 0x02, 0xad, 0x97,
	0xac, 0x43, 0x90, 0xc2, 0x09, 0xfd, 0x54, 0x98, 0x44, 0xc3, 0xc4, 0xe5, 0x2e, 0xca, 0x35, 0xfc,
	0x1d, 0x1b, 0xc5, 0x30, 0xf5, 0xdd, 0x2e, 0x0a, 0x87, 0x9f, 0xcb, 0x7c, 0x82, 0x0e, 0xbf, 0x8c,
	0xb9, 0xee, 0x7f, 0x19, 0x73, 0x3d, 0xfc, 0x32, 0x86, 0xde, 0x3f, 0x8a, 0xa1, 0xdf, 0x1d, 0xc5,
	0xd0, 0x17, 0x47, 0x31, 0x74, 0x78, 0x14, 0x43, 0xf7, 0x8f, 0x62, 0xe8, 0xef, 0x47, 0x31, 0xf4,
	0xd5, 0x51, 0xcc, 0xf5, 0xf0, 0x28, 0x86, 0x3e, 0x7e, 0x10, 0x73, 0xdd, 0x7d, 0x10, 0x43, 0x87,
	0x0f, 0x62, 0xae, 0xfb, 0x0f, 0x62, 0xae, 0x1f, 0x6e, 0x6d, 0xca, 0xcd, 0x77, 0x36, 0x93, 0xbb,
	0x72, 0x5d, 0xa3, 0x8a, 0x22, 0x26, 0x77, 0xd4, 0x39, 0xf6, 0x63, 0x43, 0x56, 0xb6, 0xaf, 0x36,
	0x15, 0x79, 0x57, 0xaa, 0x51, 0xe5, 0xaa, 0xc5, 0x9e, 0x6b, 0x56, 0x36, 0xe5, 0x39, 0xfa, 0xae,
	0x66, 0xfd, 0x99, 0xd9, 0xe9, 0xff, 0x96, 0xaf, 0xe2, 0x65, 0x7f, 0xec, 0x35, 0xff, 0xdf, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xe1, 0xfa, 0x27, 0xc1, 0x08, 0x28, 0x00, 0x00,
}

func (x ClusterState) String() string {
	s, ok := ClusterState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x EnvironmentType) String() string {
	s, ok := EnvironmentType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TrafficType) String() string {
	s, ok := TrafficType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x InfraType) String() string {
	s, ok := InfraType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Location) String() string {
	s, ok := Location_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BotEndpointPolicy.Equal(that1.BotEndpointPolicy) {
		return false
	}
	if !this.BotEndpointPolicyMetadata.Equal(that1.BotEndpointPolicyMetadata) {
		return false
	}
	if !this.BotAllowlistPolicy.Equal(that1.BotAllowlistPolicy) {
		return false
	}
	if !this.BotAllowlistPolicyMetadata.Equal(that1.BotAllowlistPolicyMetadata) {
		return false
	}
	if !this.BotNetworkPolicy.Equal(that1.BotNetworkPolicy) {
		return false
	}
	if !this.BotNetworkPolicyMetadata.Equal(that1.BotNetworkPolicyMetadata) {
		return false
	}
	if this.EnvironmentType != that1.EnvironmentType {
		return false
	}
	if this.TrafficType != that1.TrafficType {
		return false
	}
	if this.InfraType != that1.InfraType {
		return false
	}
	if this.InfraHostName != that1.InfraHostName {
		return false
	}
	if len(this.Ingress) != len(that1.Ingress) {
		return false
	}
	for i := range this.Ingress {
		if !this.Ingress[i].Equal(that1.Ingress[i]) {
			return false
		}
	}
	if len(this.Egress) != len(that1.Egress) {
		return false
	}
	for i := range this.Egress {
		if !this.Egress[i].Equal(that1.Egress[i]) {
			return false
		}
	}
	if len(this.HostNames) != len(that1.HostNames) {
		return false
	}
	for i := range this.HostNames {
		if this.HostNames[i] != that1.HostNames[i] {
			return false
		}
	}
	if len(this.IpAddresses) != len(that1.IpAddresses) {
		return false
	}
	for i := range this.IpAddresses {
		if this.IpAddresses[i] != that1.IpAddresses[i] {
			return false
		}
	}
	if len(this.InfraRegion) != len(that1.InfraRegion) {
		return false
	}
	for i := range this.InfraRegion {
		if this.InfraRegion[i] != that1.InfraRegion[i] {
			return false
		}
	}
	if this.FirmwareReleaseId != that1.FirmwareReleaseId {
		return false
	}
	if this.SpmClusterId != that1.SpmClusterId {
		return false
	}
	if !this.BotThreatIntelligencePolicyMetadata.Equal(that1.BotThreatIntelligencePolicyMetadata) {
		return false
	}
	if that1.BotInfraChoice == nil {
		if this.BotInfraChoice != nil {
			return false
		}
	} else if this.BotInfraChoice == nil {
		return false
	} else if !this.BotInfraChoice.Equal(that1.BotInfraChoice) {
		return false
	}
	if this.ClusterState != that1.ClusterState {
		return false
	}
	if that1.CreateBotInfraChoice == nil {
		if this.CreateBotInfraChoice != nil {
			return false
		}
	} else if this.CreateBotInfraChoice == nil {
		return false
	} else if !this.CreateBotInfraChoice.Equal(that1.CreateBotInfraChoice) {
		return false
	}
	return true
}
func (this *GlobalSpecType_CloudHosted) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_CloudHosted)
	if !ok {
		that2, ok := that.(GlobalSpecType_CloudHosted)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CloudHosted.Equal(that1.CloudHosted) {
		return false
	}
	return true
}
func (this *GlobalSpecType_PhysicalHosted) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_PhysicalHosted)
	if !ok {
		that2, ok := that.(GlobalSpecType_PhysicalHosted)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PhysicalHosted.Equal(that1.PhysicalHosted) {
		return false
	}
	return true
}
func (this *GlobalSpecType_OnPrem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_OnPrem)
	if !ok {
		that2, ok := that.(GlobalSpecType_OnPrem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OnPrem.Equal(that1.OnPrem) {
		return false
	}
	return true
}
func (this *GlobalSpecType_CreateCloudHosted) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_CreateCloudHosted)
	if !ok {
		that2, ok := that.(GlobalSpecType_CreateCloudHosted)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CreateCloudHosted.Equal(that1.CreateCloudHosted) {
		return false
	}
	return true
}
func (this *InfraCloudHosted) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InfraCloudHosted)
	if !ok {
		that2, ok := that.(InfraCloudHosted)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.InfraHostName != that1.InfraHostName {
		return false
	}
	if this.FirmwareVersion != that1.FirmwareVersion {
		return false
	}
	if len(this.Ingress) != len(that1.Ingress) {
		return false
	}
	for i := range this.Ingress {
		if !this.Ingress[i].Equal(that1.Ingress[i]) {
			return false
		}
	}
	if len(this.Egress) != len(that1.Egress) {
		return false
	}
	for i := range this.Egress {
		if !this.Egress[i].Equal(that1.Egress[i]) {
			return false
		}
	}
	if len(this.HostNames) != len(that1.HostNames) {
		return false
	}
	for i := range this.HostNames {
		if this.HostNames[i] != that1.HostNames[i] {
			return false
		}
	}
	if len(this.IpAddresses) != len(that1.IpAddresses) {
		return false
	}
	for i := range this.IpAddresses {
		if this.IpAddresses[i] != that1.IpAddresses[i] {
			return false
		}
	}
	if len(this.InfraRegion) != len(that1.InfraRegion) {
		return false
	}
	for i := range this.InfraRegion {
		if this.InfraRegion[i] != that1.InfraRegion[i] {
			return false
		}
	}
	return true
}
func (this *CreateSpecInfraCloudHosted) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecInfraCloudHosted)
	if !ok {
		that2, ok := that.(CreateSpecInfraCloudHosted)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.TypeChoice == nil {
		if this.TypeChoice != nil {
			return false
		}
	} else if this.TypeChoice == nil {
		return false
	} else if !this.TypeChoice.Equal(that1.TypeChoice) {
		return false
	}
	if len(this.IpAddresses) != len(that1.IpAddresses) {
		return false
	}
	for i := range this.IpAddresses {
		if this.IpAddresses[i] != that1.IpAddresses[i] {
			return false
		}
	}
	return true
}
func (this *CreateSpecInfraCloudHosted_Production) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecInfraCloudHosted_Production)
	if !ok {
		that2, ok := that.(CreateSpecInfraCloudHosted_Production)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Production.Equal(that1.Production) {
		return false
	}
	return true
}
func (this *CreateSpecInfraCloudHosted_Testing) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecInfraCloudHosted_Testing)
	if !ok {
		that2, ok := that.(CreateSpecInfraCloudHosted_Testing)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Testing.Equal(that1.Testing) {
		return false
	}
	return true
}
func (this *InfraF5HostedOnPrem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InfraF5HostedOnPrem)
	if !ok {
		that2, ok := that.(InfraF5HostedOnPrem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.InfraHostName != that1.InfraHostName {
		return false
	}
	if this.FirmwareVersion != that1.FirmwareVersion {
		return false
	}
	if len(this.Devices) != len(that1.Devices) {
		return false
	}
	for i := range this.Devices {
		if !this.Devices[i].Equal(that1.Devices[i]) {
			return false
		}
	}
	return true
}
func (this *Device) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Device)
	if !ok {
		that2, ok := that.(Device)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DeviceName != that1.DeviceName {
		return false
	}
	if this.DeviceFirmwareVersion != that1.DeviceFirmwareVersion {
		return false
	}
	if !this.IpInfo.Equal(that1.IpInfo) {
		return false
	}
	if this.CertificationStatus != that1.CertificationStatus {
		return false
	}
	return true
}
func (this *IPInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPInfo)
	if !ok {
		that2, ok := that.(IPInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Traffic != that1.Traffic {
		return false
	}
	if this.Wan != that1.Wan {
		return false
	}
	if this.Local != that1.Local {
		return false
	}
	return true
}
func (this *EndpointPolicyMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EndpointPolicyMetadata)
	if !ok {
		that2, ok := that.(EndpointPolicyMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *PolicyMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PolicyMetadata)
	if !ok {
		that2, ok := that.(PolicyMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	return true
}
func (this *Ingress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ingress)
	if !ok {
		that2, ok := that.(Ingress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.TypeChoice == nil {
		if this.TypeChoice != nil {
			return false
		}
	} else if this.TypeChoice == nil {
		return false
	} else if !this.TypeChoice.Equal(that1.TypeChoice) {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	return true
}
func (this *Ingress_HostName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ingress_HostName)
	if !ok {
		that2, ok := that.(Ingress_HostName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HostName != that1.HostName {
		return false
	}
	return true
}
func (this *Ingress_IpAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ingress_IpAddress)
	if !ok {
		that2, ok := that.(Ingress_IpAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IpAddress != that1.IpAddress {
		return false
	}
	return true
}
func (this *Egress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Egress)
	if !ok {
		that2, ok := that.(Egress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IpAddress != that1.IpAddress {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	return true
}
func (this *Production) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Production)
	if !ok {
		that2, ok := that.(Production)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Region_1 != that1.Region_1 {
		return false
	}
	if this.Region_2 != that1.Region_2 {
		return false
	}
	return true
}
func (this *Testing) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Testing)
	if !ok {
		that2, ok := that.(Testing)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Region_1 != that1.Region_1 {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BotEndpointPolicyMetadata.Equal(that1.BotEndpointPolicyMetadata) {
		return false
	}
	if !this.BotAllowlistPolicyMetadata.Equal(that1.BotAllowlistPolicyMetadata) {
		return false
	}
	if !this.BotNetworkPolicyMetadata.Equal(that1.BotNetworkPolicyMetadata) {
		return false
	}
	if this.EnvironmentType != that1.EnvironmentType {
		return false
	}
	if this.TrafficType != that1.TrafficType {
		return false
	}
	if this.InfraType != that1.InfraType {
		return false
	}
	if this.InfraHostName != that1.InfraHostName {
		return false
	}
	if len(this.Ingress) != len(that1.Ingress) {
		return false
	}
	for i := range this.Ingress {
		if !this.Ingress[i].Equal(that1.Ingress[i]) {
			return false
		}
	}
	if len(this.Egress) != len(that1.Egress) {
		return false
	}
	for i := range this.Egress {
		if !this.Egress[i].Equal(that1.Egress[i]) {
			return false
		}
	}
	if len(this.HostNames) != len(that1.HostNames) {
		return false
	}
	for i := range this.HostNames {
		if this.HostNames[i] != that1.HostNames[i] {
			return false
		}
	}
	if len(this.IpAddresses) != len(that1.IpAddresses) {
		return false
	}
	for i := range this.IpAddresses {
		if this.IpAddresses[i] != that1.IpAddresses[i] {
			return false
		}
	}
	if len(this.InfraRegion) != len(that1.InfraRegion) {
		return false
	}
	for i := range this.InfraRegion {
		if this.InfraRegion[i] != that1.InfraRegion[i] {
			return false
		}
	}
	if that1.BotInfraChoice == nil {
		if this.BotInfraChoice != nil {
			return false
		}
	} else if this.BotInfraChoice == nil {
		return false
	} else if !this.BotInfraChoice.Equal(that1.BotInfraChoice) {
		return false
	}
	if this.ClusterState != that1.ClusterState {
		return false
	}
	return true
}
func (this *GetSpecType_CloudHosted) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_CloudHosted)
	if !ok {
		that2, ok := that.(GetSpecType_CloudHosted)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CloudHosted.Equal(that1.CloudHosted) {
		return false
	}
	return true
}
func (this *GetSpecType_PhysicalHosted) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_PhysicalHosted)
	if !ok {
		that2, ok := that.(GetSpecType_PhysicalHosted)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PhysicalHosted.Equal(that1.PhysicalHosted) {
		return false
	}
	return true
}
func (this *GetSpecType_OnPrem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_OnPrem)
	if !ok {
		that2, ok := that.(GetSpecType_OnPrem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OnPrem.Equal(that1.OnPrem) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TrafficType != that1.TrafficType {
		return false
	}
	if that1.CreateBotInfraChoice == nil {
		if this.CreateBotInfraChoice != nil {
			return false
		}
	} else if this.CreateBotInfraChoice == nil {
		return false
	} else if !this.CreateBotInfraChoice.Equal(that1.CreateBotInfraChoice) {
		return false
	}
	return true
}
func (this *CreateSpecType_CreateCloudHosted) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_CreateCloudHosted)
	if !ok {
		that2, ok := that.(CreateSpecType_CreateCloudHosted)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CreateCloudHosted.Equal(that1.CreateCloudHosted) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EnvironmentType != that1.EnvironmentType {
		return false
	}
	if this.TrafficType != that1.TrafficType {
		return false
	}
	if that1.BotInfraChoice == nil {
		if this.BotInfraChoice != nil {
			return false
		}
	} else if this.BotInfraChoice == nil {
		return false
	} else if !this.BotInfraChoice.Equal(that1.BotInfraChoice) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_CloudHosted) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_CloudHosted)
	if !ok {
		that2, ok := that.(ReplaceSpecType_CloudHosted)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CloudHosted.Equal(that1.CloudHosted) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_PhysicalHosted) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_PhysicalHosted)
	if !ok {
		that2, ok := that.(ReplaceSpecType_PhysicalHosted)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PhysicalHosted.Equal(that1.PhysicalHosted) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_OnPrem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_OnPrem)
	if !ok {
		that2, ok := that.(ReplaceSpecType_OnPrem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OnPrem.Equal(that1.OnPrem) {
		return false
	}
	return true
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 27)
	s = append(s, "&bot_infrastructure.GlobalSpecType{")
	if this.BotEndpointPolicy != nil {
		s = append(s, "BotEndpointPolicy: "+fmt.Sprintf("%#v", this.BotEndpointPolicy)+",\n")
	}
	if this.BotEndpointPolicyMetadata != nil {
		s = append(s, "BotEndpointPolicyMetadata: "+fmt.Sprintf("%#v", this.BotEndpointPolicyMetadata)+",\n")
	}
	if this.BotAllowlistPolicy != nil {
		s = append(s, "BotAllowlistPolicy: "+fmt.Sprintf("%#v", this.BotAllowlistPolicy)+",\n")
	}
	if this.BotAllowlistPolicyMetadata != nil {
		s = append(s, "BotAllowlistPolicyMetadata: "+fmt.Sprintf("%#v", this.BotAllowlistPolicyMetadata)+",\n")
	}
	if this.BotNetworkPolicy != nil {
		s = append(s, "BotNetworkPolicy: "+fmt.Sprintf("%#v", this.BotNetworkPolicy)+",\n")
	}
	if this.BotNetworkPolicyMetadata != nil {
		s = append(s, "BotNetworkPolicyMetadata: "+fmt.Sprintf("%#v", this.BotNetworkPolicyMetadata)+",\n")
	}
	s = append(s, "EnvironmentType: "+fmt.Sprintf("%#v", this.EnvironmentType)+",\n")
	s = append(s, "TrafficType: "+fmt.Sprintf("%#v", this.TrafficType)+",\n")
	s = append(s, "InfraType: "+fmt.Sprintf("%#v", this.InfraType)+",\n")
	s = append(s, "InfraHostName: "+fmt.Sprintf("%#v", this.InfraHostName)+",\n")
	if this.Ingress != nil {
		s = append(s, "Ingress: "+fmt.Sprintf("%#v", this.Ingress)+",\n")
	}
	if this.Egress != nil {
		s = append(s, "Egress: "+fmt.Sprintf("%#v", this.Egress)+",\n")
	}
	s = append(s, "HostNames: "+fmt.Sprintf("%#v", this.HostNames)+",\n")
	s = append(s, "IpAddresses: "+fmt.Sprintf("%#v", this.IpAddresses)+",\n")
	s = append(s, "InfraRegion: "+fmt.Sprintf("%#v", this.InfraRegion)+",\n")
	s = append(s, "FirmwareReleaseId: "+fmt.Sprintf("%#v", this.FirmwareReleaseId)+",\n")
	s = append(s, "SpmClusterId: "+fmt.Sprintf("%#v", this.SpmClusterId)+",\n")
	if this.BotThreatIntelligencePolicyMetadata != nil {
		s = append(s, "BotThreatIntelligencePolicyMetadata: "+fmt.Sprintf("%#v", this.BotThreatIntelligencePolicyMetadata)+",\n")
	}
	if this.BotInfraChoice != nil {
		s = append(s, "BotInfraChoice: "+fmt.Sprintf("%#v", this.BotInfraChoice)+",\n")
	}
	s = append(s, "ClusterState: "+fmt.Sprintf("%#v", this.ClusterState)+",\n")
	if this.CreateBotInfraChoice != nil {
		s = append(s, "CreateBotInfraChoice: "+fmt.Sprintf("%#v", this.CreateBotInfraChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_CloudHosted) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&bot_infrastructure.GlobalSpecType_CloudHosted{` +
		`CloudHosted:` + fmt.Sprintf("%#v", this.CloudHosted) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_PhysicalHosted) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&bot_infrastructure.GlobalSpecType_PhysicalHosted{` +
		`PhysicalHosted:` + fmt.Sprintf("%#v", this.PhysicalHosted) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_OnPrem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&bot_infrastructure.GlobalSpecType_OnPrem{` +
		`OnPrem:` + fmt.Sprintf("%#v", this.OnPrem) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_CreateCloudHosted) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&bot_infrastructure.GlobalSpecType_CreateCloudHosted{` +
		`CreateCloudHosted:` + fmt.Sprintf("%#v", this.CreateCloudHosted) + `}`}, ", ")
	return s
}
func (this *InfraCloudHosted) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&bot_infrastructure.InfraCloudHosted{")
	s = append(s, "InfraHostName: "+fmt.Sprintf("%#v", this.InfraHostName)+",\n")
	s = append(s, "FirmwareVersion: "+fmt.Sprintf("%#v", this.FirmwareVersion)+",\n")
	if this.Ingress != nil {
		s = append(s, "Ingress: "+fmt.Sprintf("%#v", this.Ingress)+",\n")
	}
	if this.Egress != nil {
		s = append(s, "Egress: "+fmt.Sprintf("%#v", this.Egress)+",\n")
	}
	s = append(s, "HostNames: "+fmt.Sprintf("%#v", this.HostNames)+",\n")
	s = append(s, "IpAddresses: "+fmt.Sprintf("%#v", this.IpAddresses)+",\n")
	s = append(s, "InfraRegion: "+fmt.Sprintf("%#v", this.InfraRegion)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecInfraCloudHosted) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&bot_infrastructure.CreateSpecInfraCloudHosted{")
	if this.TypeChoice != nil {
		s = append(s, "TypeChoice: "+fmt.Sprintf("%#v", this.TypeChoice)+",\n")
	}
	s = append(s, "IpAddresses: "+fmt.Sprintf("%#v", this.IpAddresses)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecInfraCloudHosted_Production) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&bot_infrastructure.CreateSpecInfraCloudHosted_Production{` +
		`Production:` + fmt.Sprintf("%#v", this.Production) + `}`}, ", ")
	return s
}
func (this *CreateSpecInfraCloudHosted_Testing) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&bot_infrastructure.CreateSpecInfraCloudHosted_Testing{` +
		`Testing:` + fmt.Sprintf("%#v", this.Testing) + `}`}, ", ")
	return s
}
func (this *InfraF5HostedOnPrem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&bot_infrastructure.InfraF5HostedOnPrem{")
	s = append(s, "InfraHostName: "+fmt.Sprintf("%#v", this.InfraHostName)+",\n")
	s = append(s, "FirmwareVersion: "+fmt.Sprintf("%#v", this.FirmwareVersion)+",\n")
	if this.Devices != nil {
		s = append(s, "Devices: "+fmt.Sprintf("%#v", this.Devices)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Device) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&bot_infrastructure.Device{")
	s = append(s, "DeviceName: "+fmt.Sprintf("%#v", this.DeviceName)+",\n")
	s = append(s, "DeviceFirmwareVersion: "+fmt.Sprintf("%#v", this.DeviceFirmwareVersion)+",\n")
	if this.IpInfo != nil {
		s = append(s, "IpInfo: "+fmt.Sprintf("%#v", this.IpInfo)+",\n")
	}
	s = append(s, "CertificationStatus: "+fmt.Sprintf("%#v", this.CertificationStatus)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IPInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&bot_infrastructure.IPInfo{")
	s = append(s, "Traffic: "+fmt.Sprintf("%#v", this.Traffic)+",\n")
	s = append(s, "Wan: "+fmt.Sprintf("%#v", this.Wan)+",\n")
	s = append(s, "Local: "+fmt.Sprintf("%#v", this.Local)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EndpointPolicyMetadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&bot_infrastructure.EndpointPolicyMetadata{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PolicyMetadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&bot_infrastructure.PolicyMetadata{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Ingress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&bot_infrastructure.Ingress{")
	if this.TypeChoice != nil {
		s = append(s, "TypeChoice: "+fmt.Sprintf("%#v", this.TypeChoice)+",\n")
	}
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Ingress_HostName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&bot_infrastructure.Ingress_HostName{` +
		`HostName:` + fmt.Sprintf("%#v", this.HostName) + `}`}, ", ")
	return s
}
func (this *Ingress_IpAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&bot_infrastructure.Ingress_IpAddress{` +
		`IpAddress:` + fmt.Sprintf("%#v", this.IpAddress) + `}`}, ", ")
	return s
}
func (this *Egress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&bot_infrastructure.Egress{")
	s = append(s, "IpAddress: "+fmt.Sprintf("%#v", this.IpAddress)+",\n")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Production) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&bot_infrastructure.Production{")
	s = append(s, "Region_1: "+fmt.Sprintf("%#v", this.Region_1)+",\n")
	s = append(s, "Region_2: "+fmt.Sprintf("%#v", this.Region_2)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Testing) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&bot_infrastructure.Testing{")
	s = append(s, "Region_1: "+fmt.Sprintf("%#v", this.Region_1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&bot_infrastructure.GetSpecType{")
	if this.BotEndpointPolicyMetadata != nil {
		s = append(s, "BotEndpointPolicyMetadata: "+fmt.Sprintf("%#v", this.BotEndpointPolicyMetadata)+",\n")
	}
	if this.BotAllowlistPolicyMetadata != nil {
		s = append(s, "BotAllowlistPolicyMetadata: "+fmt.Sprintf("%#v", this.BotAllowlistPolicyMetadata)+",\n")
	}
	if this.BotNetworkPolicyMetadata != nil {
		s = append(s, "BotNetworkPolicyMetadata: "+fmt.Sprintf("%#v", this.BotNetworkPolicyMetadata)+",\n")
	}
	s = append(s, "EnvironmentType: "+fmt.Sprintf("%#v", this.EnvironmentType)+",\n")
	s = append(s, "TrafficType: "+fmt.Sprintf("%#v", this.TrafficType)+",\n")
	s = append(s, "InfraType: "+fmt.Sprintf("%#v", this.InfraType)+",\n")
	s = append(s, "InfraHostName: "+fmt.Sprintf("%#v", this.InfraHostName)+",\n")
	if this.Ingress != nil {
		s = append(s, "Ingress: "+fmt.Sprintf("%#v", this.Ingress)+",\n")
	}
	if this.Egress != nil {
		s = append(s, "Egress: "+fmt.Sprintf("%#v", this.Egress)+",\n")
	}
	s = append(s, "HostNames: "+fmt.Sprintf("%#v", this.HostNames)+",\n")
	s = append(s, "IpAddresses: "+fmt.Sprintf("%#v", this.IpAddresses)+",\n")
	s = append(s, "InfraRegion: "+fmt.Sprintf("%#v", this.InfraRegion)+",\n")
	if this.BotInfraChoice != nil {
		s = append(s, "BotInfraChoice: "+fmt.Sprintf("%#v", this.BotInfraChoice)+",\n")
	}
	s = append(s, "ClusterState: "+fmt.Sprintf("%#v", this.ClusterState)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_CloudHosted) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&bot_infrastructure.GetSpecType_CloudHosted{` +
		`CloudHosted:` + fmt.Sprintf("%#v", this.CloudHosted) + `}`}, ", ")
	return s
}
func (this *GetSpecType_PhysicalHosted) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&bot_infrastructure.GetSpecType_PhysicalHosted{` +
		`PhysicalHosted:` + fmt.Sprintf("%#v", this.PhysicalHosted) + `}`}, ", ")
	return s
}
func (this *GetSpecType_OnPrem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&bot_infrastructure.GetSpecType_OnPrem{` +
		`OnPrem:` + fmt.Sprintf("%#v", this.OnPrem) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&bot_infrastructure.CreateSpecType{")
	s = append(s, "TrafficType: "+fmt.Sprintf("%#v", this.TrafficType)+",\n")
	if this.CreateBotInfraChoice != nil {
		s = append(s, "CreateBotInfraChoice: "+fmt.Sprintf("%#v", this.CreateBotInfraChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_CreateCloudHosted) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&bot_infrastructure.CreateSpecType_CreateCloudHosted{` +
		`CreateCloudHosted:` + fmt.Sprintf("%#v", this.CreateCloudHosted) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&bot_infrastructure.ReplaceSpecType{")
	s = append(s, "EnvironmentType: "+fmt.Sprintf("%#v", this.EnvironmentType)+",\n")
	s = append(s, "TrafficType: "+fmt.Sprintf("%#v", this.TrafficType)+",\n")
	if this.BotInfraChoice != nil {
		s = append(s, "BotInfraChoice: "+fmt.Sprintf("%#v", this.BotInfraChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_CloudHosted) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&bot_infrastructure.ReplaceSpecType_CloudHosted{` +
		`CloudHosted:` + fmt.Sprintf("%#v", this.CloudHosted) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_PhysicalHosted) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&bot_infrastructure.ReplaceSpecType_PhysicalHosted{` +
		`PhysicalHosted:` + fmt.Sprintf("%#v", this.PhysicalHosted) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_OnPrem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&bot_infrastructure.ReplaceSpecType_OnPrem{` +
		`OnPrem:` + fmt.Sprintf("%#v", this.OnPrem) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreateBotInfraChoice != nil {
		{
			size := m.CreateBotInfraChoice.Size()
			i -= size
			if _, err := m.CreateBotInfraChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ClusterState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ClusterState))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.BotInfraChoice != nil {
		{
			size := m.BotInfraChoice.Size()
			i -= size
			if _, err := m.BotInfraChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.BotThreatIntelligencePolicyMetadata != nil {
		{
			size, err := m.BotThreatIntelligencePolicyMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.SpmClusterId) > 0 {
		i -= len(m.SpmClusterId)
		copy(dAtA[i:], m.SpmClusterId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SpmClusterId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.FirmwareReleaseId) > 0 {
		i -= len(m.FirmwareReleaseId)
		copy(dAtA[i:], m.FirmwareReleaseId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FirmwareReleaseId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.InfraRegion) > 0 {
		dAtA3 := make([]byte, len(m.InfraRegion)*10)
		var j2 int
		for _, num := range m.InfraRegion {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintTypes(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.IpAddresses) > 0 {
		for iNdEx := len(m.IpAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IpAddresses[iNdEx])
			copy(dAtA[i:], m.IpAddresses[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.IpAddresses[iNdEx])))
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.HostNames) > 0 {
		for iNdEx := len(m.HostNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.HostNames[iNdEx])
			copy(dAtA[i:], m.HostNames[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.HostNames[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.Egress) > 0 {
		for iNdEx := len(m.Egress) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Egress[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.Ingress) > 0 {
		for iNdEx := len(m.Ingress) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ingress[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.InfraHostName) > 0 {
		i -= len(m.InfraHostName)
		copy(dAtA[i:], m.InfraHostName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InfraHostName)))
		i--
		dAtA[i] = 0x52
	}
	if m.InfraType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.InfraType))
		i--
		dAtA[i] = 0x48
	}
	if m.TrafficType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TrafficType))
		i--
		dAtA[i] = 0x40
	}
	if m.EnvironmentType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EnvironmentType))
		i--
		dAtA[i] = 0x38
	}
	if m.BotNetworkPolicyMetadata != nil {
		{
			size, err := m.BotNetworkPolicyMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.BotNetworkPolicy != nil {
		{
			size, err := m.BotNetworkPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.BotAllowlistPolicyMetadata != nil {
		{
			size, err := m.BotAllowlistPolicyMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.BotAllowlistPolicy != nil {
		{
			size, err := m.BotAllowlistPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BotEndpointPolicyMetadata != nil {
		{
			size, err := m.BotEndpointPolicyMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BotEndpointPolicy != nil {
		{
			size, err := m.BotEndpointPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_CloudHosted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_CloudHosted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CloudHosted != nil {
		{
			size, err := m.CloudHosted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_PhysicalHosted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_PhysicalHosted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PhysicalHosted != nil {
		{
			size, err := m.PhysicalHosted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_OnPrem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_OnPrem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OnPrem != nil {
		{
			size, err := m.OnPrem.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_CreateCloudHosted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_CreateCloudHosted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateCloudHosted != nil {
		{
			size, err := m.CreateCloudHosted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *InfraCloudHosted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfraCloudHosted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InfraCloudHosted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InfraRegion) > 0 {
		dAtA15 := make([]byte, len(m.InfraRegion)*10)
		var j14 int
		for _, num := range m.InfraRegion {
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintTypes(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.IpAddresses) > 0 {
		for iNdEx := len(m.IpAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IpAddresses[iNdEx])
			copy(dAtA[i:], m.IpAddresses[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.IpAddresses[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.HostNames) > 0 {
		for iNdEx := len(m.HostNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.HostNames[iNdEx])
			copy(dAtA[i:], m.HostNames[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.HostNames[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Egress) > 0 {
		for iNdEx := len(m.Egress) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Egress[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Ingress) > 0 {
		for iNdEx := len(m.Ingress) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ingress[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.FirmwareVersion) > 0 {
		i -= len(m.FirmwareVersion)
		copy(dAtA[i:], m.FirmwareVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FirmwareVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.InfraHostName) > 0 {
		i -= len(m.InfraHostName)
		copy(dAtA[i:], m.InfraHostName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InfraHostName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecInfraCloudHosted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecInfraCloudHosted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecInfraCloudHosted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IpAddresses) > 0 {
		for iNdEx := len(m.IpAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IpAddresses[iNdEx])
			copy(dAtA[i:], m.IpAddresses[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.IpAddresses[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.TypeChoice != nil {
		{
			size := m.TypeChoice.Size()
			i -= size
			if _, err := m.TypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecInfraCloudHosted_Production) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecInfraCloudHosted_Production) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Production != nil {
		{
			size, err := m.Production.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecInfraCloudHosted_Testing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecInfraCloudHosted_Testing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Testing != nil {
		{
			size, err := m.Testing.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *InfraF5HostedOnPrem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfraF5HostedOnPrem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InfraF5HostedOnPrem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InfraHostName) > 0 {
		i -= len(m.InfraHostName)
		copy(dAtA[i:], m.InfraHostName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InfraHostName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Devices) > 0 {
		for iNdEx := len(m.Devices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Devices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.FirmwareVersion) > 0 {
		i -= len(m.FirmwareVersion)
		copy(dAtA[i:], m.FirmwareVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FirmwareVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Device) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Device) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Device) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CertificationStatus) > 0 {
		i -= len(m.CertificationStatus)
		copy(dAtA[i:], m.CertificationStatus)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CertificationStatus)))
		i--
		dAtA[i] = 0x22
	}
	if m.IpInfo != nil {
		{
			size, err := m.IpInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeviceFirmwareVersion) > 0 {
		i -= len(m.DeviceFirmwareVersion)
		copy(dAtA[i:], m.DeviceFirmwareVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DeviceFirmwareVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IPInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Local) > 0 {
		i -= len(m.Local)
		copy(dAtA[i:], m.Local)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Local)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Wan) > 0 {
		i -= len(m.Wan)
		copy(dAtA[i:], m.Wan)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Wan)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Traffic) > 0 {
		i -= len(m.Traffic)
		copy(dAtA[i:], m.Traffic)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Traffic)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EndpointPolicyMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointPolicyMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndpointPolicyMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PolicyMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Ingress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ingress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ingress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Region != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Region))
		i--
		dAtA[i] = 0x30
	}
	if m.TypeChoice != nil {
		{
			size := m.TypeChoice.Size()
			i -= size
			if _, err := m.TypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Ingress_HostName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ingress_HostName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.HostName)
	copy(dAtA[i:], m.HostName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.HostName)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *Ingress_IpAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ingress_IpAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.IpAddress)
	copy(dAtA[i:], m.IpAddress)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.IpAddress)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *Egress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Egress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Egress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Region != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Region))
		i--
		dAtA[i] = 0x20
	}
	if len(m.IpAddress) > 0 {
		i -= len(m.IpAddress)
		copy(dAtA[i:], m.IpAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IpAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Production) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Production) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Production) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Region_2) > 0 {
		i -= len(m.Region_2)
		copy(dAtA[i:], m.Region_2)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region_2)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Region_1) > 0 {
		i -= len(m.Region_1)
		copy(dAtA[i:], m.Region_1)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region_1)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Testing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Testing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Testing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Region_1) > 0 {
		i -= len(m.Region_1)
		copy(dAtA[i:], m.Region_1)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region_1)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClusterState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ClusterState))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.BotInfraChoice != nil {
		{
			size := m.BotInfraChoice.Size()
			i -= size
			if _, err := m.BotInfraChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.InfraRegion) > 0 {
		dAtA20 := make([]byte, len(m.InfraRegion)*10)
		var j19 int
		for _, num := range m.InfraRegion {
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		i -= j19
		copy(dAtA[i:], dAtA20[:j19])
		i = encodeVarintTypes(dAtA, i, uint64(j19))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.IpAddresses) > 0 {
		for iNdEx := len(m.IpAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IpAddresses[iNdEx])
			copy(dAtA[i:], m.IpAddresses[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.IpAddresses[iNdEx])))
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.HostNames) > 0 {
		for iNdEx := len(m.HostNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.HostNames[iNdEx])
			copy(dAtA[i:], m.HostNames[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.HostNames[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.Egress) > 0 {
		for iNdEx := len(m.Egress) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Egress[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.Ingress) > 0 {
		for iNdEx := len(m.Ingress) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ingress[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.InfraHostName) > 0 {
		i -= len(m.InfraHostName)
		copy(dAtA[i:], m.InfraHostName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InfraHostName)))
		i--
		dAtA[i] = 0x52
	}
	if m.InfraType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.InfraType))
		i--
		dAtA[i] = 0x48
	}
	if m.TrafficType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TrafficType))
		i--
		dAtA[i] = 0x40
	}
	if m.EnvironmentType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EnvironmentType))
		i--
		dAtA[i] = 0x38
	}
	if m.BotNetworkPolicyMetadata != nil {
		{
			size, err := m.BotNetworkPolicyMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.BotAllowlistPolicyMetadata != nil {
		{
			size, err := m.BotAllowlistPolicyMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.BotEndpointPolicyMetadata != nil {
		{
			size, err := m.BotEndpointPolicyMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_CloudHosted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_CloudHosted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CloudHosted != nil {
		{
			size, err := m.CloudHosted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_PhysicalHosted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_PhysicalHosted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PhysicalHosted != nil {
		{
			size, err := m.PhysicalHosted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_OnPrem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_OnPrem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OnPrem != nil {
		{
			size, err := m.OnPrem.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreateBotInfraChoice != nil {
		{
			size := m.CreateBotInfraChoice.Size()
			i -= size
			if _, err := m.CreateBotInfraChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TrafficType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TrafficType))
		i--
		dAtA[i] = 0x40
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_CreateCloudHosted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_CreateCloudHosted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateCloudHosted != nil {
		{
			size, err := m.CreateCloudHosted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BotInfraChoice != nil {
		{
			size := m.BotInfraChoice.Size()
			i -= size
			if _, err := m.BotInfraChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TrafficType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TrafficType))
		i--
		dAtA[i] = 0x40
	}
	if m.EnvironmentType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EnvironmentType))
		i--
		dAtA[i] = 0x38
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_CloudHosted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_CloudHosted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CloudHosted != nil {
		{
			size, err := m.CloudHosted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_PhysicalHosted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_PhysicalHosted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PhysicalHosted != nil {
		{
			size, err := m.PhysicalHosted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_OnPrem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_OnPrem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OnPrem != nil {
		{
			size, err := m.OnPrem.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BotEndpointPolicy != nil {
		l = m.BotEndpointPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BotEndpointPolicyMetadata != nil {
		l = m.BotEndpointPolicyMetadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BotAllowlistPolicy != nil {
		l = m.BotAllowlistPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BotAllowlistPolicyMetadata != nil {
		l = m.BotAllowlistPolicyMetadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BotNetworkPolicy != nil {
		l = m.BotNetworkPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BotNetworkPolicyMetadata != nil {
		l = m.BotNetworkPolicyMetadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EnvironmentType != 0 {
		n += 1 + sovTypes(uint64(m.EnvironmentType))
	}
	if m.TrafficType != 0 {
		n += 1 + sovTypes(uint64(m.TrafficType))
	}
	if m.InfraType != 0 {
		n += 1 + sovTypes(uint64(m.InfraType))
	}
	l = len(m.InfraHostName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Ingress) > 0 {
		for _, e := range m.Ingress {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Egress) > 0 {
		for _, e := range m.Egress {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.HostNames) > 0 {
		for _, s := range m.HostNames {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.IpAddresses) > 0 {
		for _, s := range m.IpAddresses {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.InfraRegion) > 0 {
		l = 0
		for _, e := range m.InfraRegion {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	l = len(m.FirmwareReleaseId)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.SpmClusterId)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.BotThreatIntelligencePolicyMetadata != nil {
		l = m.BotThreatIntelligencePolicyMetadata.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.BotInfraChoice != nil {
		n += m.BotInfraChoice.Size()
	}
	if m.ClusterState != 0 {
		n += 2 + sovTypes(uint64(m.ClusterState))
	}
	if m.CreateBotInfraChoice != nil {
		n += m.CreateBotInfraChoice.Size()
	}
	return n
}

func (m *GlobalSpecType_CloudHosted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudHosted != nil {
		l = m.CloudHosted.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_PhysicalHosted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PhysicalHosted != nil {
		l = m.PhysicalHosted.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_OnPrem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OnPrem != nil {
		l = m.OnPrem.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_CreateCloudHosted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateCloudHosted != nil {
		l = m.CreateCloudHosted.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *InfraCloudHosted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InfraHostName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.FirmwareVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Ingress) > 0 {
		for _, e := range m.Ingress {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Egress) > 0 {
		for _, e := range m.Egress {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.HostNames) > 0 {
		for _, s := range m.HostNames {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.IpAddresses) > 0 {
		for _, s := range m.IpAddresses {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.InfraRegion) > 0 {
		l = 0
		for _, e := range m.InfraRegion {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *CreateSpecInfraCloudHosted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeChoice != nil {
		n += m.TypeChoice.Size()
	}
	if len(m.IpAddresses) > 0 {
		for _, s := range m.IpAddresses {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreateSpecInfraCloudHosted_Production) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Production != nil {
		l = m.Production.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecInfraCloudHosted_Testing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Testing != nil {
		l = m.Testing.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *InfraF5HostedOnPrem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FirmwareVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.InfraHostName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Device) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DeviceFirmwareVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IpInfo != nil {
		l = m.IpInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CertificationStatus)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *IPInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Traffic)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Wan)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Local)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *EndpointPolicyMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	return n
}

func (m *PolicyMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Ingress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeChoice != nil {
		n += m.TypeChoice.Size()
	}
	if m.Region != 0 {
		n += 1 + sovTypes(uint64(m.Region))
	}
	return n
}

func (m *Ingress_HostName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *Ingress_IpAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IpAddress)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *Egress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Region != 0 {
		n += 1 + sovTypes(uint64(m.Region))
	}
	return n
}

func (m *Production) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Region_1)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Region_2)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Testing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Region_1)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BotEndpointPolicyMetadata != nil {
		l = m.BotEndpointPolicyMetadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BotAllowlistPolicyMetadata != nil {
		l = m.BotAllowlistPolicyMetadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BotNetworkPolicyMetadata != nil {
		l = m.BotNetworkPolicyMetadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EnvironmentType != 0 {
		n += 1 + sovTypes(uint64(m.EnvironmentType))
	}
	if m.TrafficType != 0 {
		n += 1 + sovTypes(uint64(m.TrafficType))
	}
	if m.InfraType != 0 {
		n += 1 + sovTypes(uint64(m.InfraType))
	}
	l = len(m.InfraHostName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Ingress) > 0 {
		for _, e := range m.Ingress {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Egress) > 0 {
		for _, e := range m.Egress {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.HostNames) > 0 {
		for _, s := range m.HostNames {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.IpAddresses) > 0 {
		for _, s := range m.IpAddresses {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.InfraRegion) > 0 {
		l = 0
		for _, e := range m.InfraRegion {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.BotInfraChoice != nil {
		n += m.BotInfraChoice.Size()
	}
	if m.ClusterState != 0 {
		n += 2 + sovTypes(uint64(m.ClusterState))
	}
	return n
}

func (m *GetSpecType_CloudHosted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudHosted != nil {
		l = m.CloudHosted.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_PhysicalHosted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PhysicalHosted != nil {
		l = m.PhysicalHosted.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_OnPrem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OnPrem != nil {
		l = m.OnPrem.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrafficType != 0 {
		n += 1 + sovTypes(uint64(m.TrafficType))
	}
	if m.CreateBotInfraChoice != nil {
		n += m.CreateBotInfraChoice.Size()
	}
	return n
}

func (m *CreateSpecType_CreateCloudHosted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateCloudHosted != nil {
		l = m.CreateCloudHosted.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnvironmentType != 0 {
		n += 1 + sovTypes(uint64(m.EnvironmentType))
	}
	if m.TrafficType != 0 {
		n += 1 + sovTypes(uint64(m.TrafficType))
	}
	if m.BotInfraChoice != nil {
		n += m.BotInfraChoice.Size()
	}
	return n
}

func (m *ReplaceSpecType_CloudHosted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudHosted != nil {
		l = m.CloudHosted.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_PhysicalHosted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PhysicalHosted != nil {
		l = m.PhysicalHosted.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_OnPrem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OnPrem != nil {
		l = m.OnPrem.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForIngress := "[]*Ingress{"
	for _, f := range this.Ingress {
		repeatedStringForIngress += strings.Replace(f.String(), "Ingress", "Ingress", 1) + ","
	}
	repeatedStringForIngress += "}"
	repeatedStringForEgress := "[]*Egress{"
	for _, f := range this.Egress {
		repeatedStringForEgress += strings.Replace(f.String(), "Egress", "Egress", 1) + ","
	}
	repeatedStringForEgress += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`BotEndpointPolicy:` + strings.Replace(fmt.Sprintf("%v", this.BotEndpointPolicy), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`BotEndpointPolicyMetadata:` + strings.Replace(this.BotEndpointPolicyMetadata.String(), "EndpointPolicyMetadata", "EndpointPolicyMetadata", 1) + `,`,
		`BotAllowlistPolicy:` + strings.Replace(fmt.Sprintf("%v", this.BotAllowlistPolicy), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`BotAllowlistPolicyMetadata:` + strings.Replace(this.BotAllowlistPolicyMetadata.String(), "PolicyMetadata", "PolicyMetadata", 1) + `,`,
		`BotNetworkPolicy:` + strings.Replace(fmt.Sprintf("%v", this.BotNetworkPolicy), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`BotNetworkPolicyMetadata:` + strings.Replace(this.BotNetworkPolicyMetadata.String(), "PolicyMetadata", "PolicyMetadata", 1) + `,`,
		`EnvironmentType:` + fmt.Sprintf("%v", this.EnvironmentType) + `,`,
		`TrafficType:` + fmt.Sprintf("%v", this.TrafficType) + `,`,
		`InfraType:` + fmt.Sprintf("%v", this.InfraType) + `,`,
		`InfraHostName:` + fmt.Sprintf("%v", this.InfraHostName) + `,`,
		`Ingress:` + repeatedStringForIngress + `,`,
		`Egress:` + repeatedStringForEgress + `,`,
		`HostNames:` + fmt.Sprintf("%v", this.HostNames) + `,`,
		`IpAddresses:` + fmt.Sprintf("%v", this.IpAddresses) + `,`,
		`InfraRegion:` + fmt.Sprintf("%v", this.InfraRegion) + `,`,
		`FirmwareReleaseId:` + fmt.Sprintf("%v", this.FirmwareReleaseId) + `,`,
		`SpmClusterId:` + fmt.Sprintf("%v", this.SpmClusterId) + `,`,
		`BotThreatIntelligencePolicyMetadata:` + strings.Replace(this.BotThreatIntelligencePolicyMetadata.String(), "PolicyMetadata", "PolicyMetadata", 1) + `,`,
		`BotInfraChoice:` + fmt.Sprintf("%v", this.BotInfraChoice) + `,`,
		`ClusterState:` + fmt.Sprintf("%v", this.ClusterState) + `,`,
		`CreateBotInfraChoice:` + fmt.Sprintf("%v", this.CreateBotInfraChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_CloudHosted) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_CloudHosted{`,
		`CloudHosted:` + strings.Replace(fmt.Sprintf("%v", this.CloudHosted), "InfraCloudHosted", "InfraCloudHosted", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_PhysicalHosted) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_PhysicalHosted{`,
		`PhysicalHosted:` + strings.Replace(fmt.Sprintf("%v", this.PhysicalHosted), "InfraF5HostedOnPrem", "InfraF5HostedOnPrem", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_OnPrem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_OnPrem{`,
		`OnPrem:` + strings.Replace(fmt.Sprintf("%v", this.OnPrem), "InfraF5HostedOnPrem", "InfraF5HostedOnPrem", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_CreateCloudHosted) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_CreateCloudHosted{`,
		`CreateCloudHosted:` + strings.Replace(fmt.Sprintf("%v", this.CreateCloudHosted), "CreateSpecInfraCloudHosted", "CreateSpecInfraCloudHosted", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InfraCloudHosted) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForIngress := "[]*Ingress{"
	for _, f := range this.Ingress {
		repeatedStringForIngress += strings.Replace(f.String(), "Ingress", "Ingress", 1) + ","
	}
	repeatedStringForIngress += "}"
	repeatedStringForEgress := "[]*Egress{"
	for _, f := range this.Egress {
		repeatedStringForEgress += strings.Replace(f.String(), "Egress", "Egress", 1) + ","
	}
	repeatedStringForEgress += "}"
	s := strings.Join([]string{`&InfraCloudHosted{`,
		`InfraHostName:` + fmt.Sprintf("%v", this.InfraHostName) + `,`,
		`FirmwareVersion:` + fmt.Sprintf("%v", this.FirmwareVersion) + `,`,
		`Ingress:` + repeatedStringForIngress + `,`,
		`Egress:` + repeatedStringForEgress + `,`,
		`HostNames:` + fmt.Sprintf("%v", this.HostNames) + `,`,
		`IpAddresses:` + fmt.Sprintf("%v", this.IpAddresses) + `,`,
		`InfraRegion:` + fmt.Sprintf("%v", this.InfraRegion) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecInfraCloudHosted) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecInfraCloudHosted{`,
		`TypeChoice:` + fmt.Sprintf("%v", this.TypeChoice) + `,`,
		`IpAddresses:` + fmt.Sprintf("%v", this.IpAddresses) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecInfraCloudHosted_Production) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecInfraCloudHosted_Production{`,
		`Production:` + strings.Replace(fmt.Sprintf("%v", this.Production), "Production", "Production", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecInfraCloudHosted_Testing) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecInfraCloudHosted_Testing{`,
		`Testing:` + strings.Replace(fmt.Sprintf("%v", this.Testing), "Testing", "Testing", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InfraF5HostedOnPrem) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDevices := "[]*Device{"
	for _, f := range this.Devices {
		repeatedStringForDevices += strings.Replace(f.String(), "Device", "Device", 1) + ","
	}
	repeatedStringForDevices += "}"
	s := strings.Join([]string{`&InfraF5HostedOnPrem{`,
		`FirmwareVersion:` + fmt.Sprintf("%v", this.FirmwareVersion) + `,`,
		`Devices:` + repeatedStringForDevices + `,`,
		`InfraHostName:` + fmt.Sprintf("%v", this.InfraHostName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Device) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Device{`,
		`DeviceName:` + fmt.Sprintf("%v", this.DeviceName) + `,`,
		`DeviceFirmwareVersion:` + fmt.Sprintf("%v", this.DeviceFirmwareVersion) + `,`,
		`IpInfo:` + strings.Replace(this.IpInfo.String(), "IPInfo", "IPInfo", 1) + `,`,
		`CertificationStatus:` + fmt.Sprintf("%v", this.CertificationStatus) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IPInfo{`,
		`Traffic:` + fmt.Sprintf("%v", this.Traffic) + `,`,
		`Wan:` + fmt.Sprintf("%v", this.Wan) + `,`,
		`Local:` + fmt.Sprintf("%v", this.Local) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EndpointPolicyMetadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EndpointPolicyMetadata{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PolicyMetadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PolicyMetadata{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Ingress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Ingress{`,
		`TypeChoice:` + fmt.Sprintf("%v", this.TypeChoice) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Ingress_HostName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Ingress_HostName{`,
		`HostName:` + fmt.Sprintf("%v", this.HostName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Ingress_IpAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Ingress_IpAddress{`,
		`IpAddress:` + fmt.Sprintf("%v", this.IpAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Egress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Egress{`,
		`IpAddress:` + fmt.Sprintf("%v", this.IpAddress) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Production) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Production{`,
		`Region_1:` + fmt.Sprintf("%v", this.Region_1) + `,`,
		`Region_2:` + fmt.Sprintf("%v", this.Region_2) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Testing) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Testing{`,
		`Region_1:` + fmt.Sprintf("%v", this.Region_1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForIngress := "[]*Ingress{"
	for _, f := range this.Ingress {
		repeatedStringForIngress += strings.Replace(f.String(), "Ingress", "Ingress", 1) + ","
	}
	repeatedStringForIngress += "}"
	repeatedStringForEgress := "[]*Egress{"
	for _, f := range this.Egress {
		repeatedStringForEgress += strings.Replace(f.String(), "Egress", "Egress", 1) + ","
	}
	repeatedStringForEgress += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`BotEndpointPolicyMetadata:` + strings.Replace(this.BotEndpointPolicyMetadata.String(), "EndpointPolicyMetadata", "EndpointPolicyMetadata", 1) + `,`,
		`BotAllowlistPolicyMetadata:` + strings.Replace(this.BotAllowlistPolicyMetadata.String(), "PolicyMetadata", "PolicyMetadata", 1) + `,`,
		`BotNetworkPolicyMetadata:` + strings.Replace(this.BotNetworkPolicyMetadata.String(), "PolicyMetadata", "PolicyMetadata", 1) + `,`,
		`EnvironmentType:` + fmt.Sprintf("%v", this.EnvironmentType) + `,`,
		`TrafficType:` + fmt.Sprintf("%v", this.TrafficType) + `,`,
		`InfraType:` + fmt.Sprintf("%v", this.InfraType) + `,`,
		`InfraHostName:` + fmt.Sprintf("%v", this.InfraHostName) + `,`,
		`Ingress:` + repeatedStringForIngress + `,`,
		`Egress:` + repeatedStringForEgress + `,`,
		`HostNames:` + fmt.Sprintf("%v", this.HostNames) + `,`,
		`IpAddresses:` + fmt.Sprintf("%v", this.IpAddresses) + `,`,
		`InfraRegion:` + fmt.Sprintf("%v", this.InfraRegion) + `,`,
		`BotInfraChoice:` + fmt.Sprintf("%v", this.BotInfraChoice) + `,`,
		`ClusterState:` + fmt.Sprintf("%v", this.ClusterState) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_CloudHosted) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_CloudHosted{`,
		`CloudHosted:` + strings.Replace(fmt.Sprintf("%v", this.CloudHosted), "InfraCloudHosted", "InfraCloudHosted", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_PhysicalHosted) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_PhysicalHosted{`,
		`PhysicalHosted:` + strings.Replace(fmt.Sprintf("%v", this.PhysicalHosted), "InfraF5HostedOnPrem", "InfraF5HostedOnPrem", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_OnPrem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_OnPrem{`,
		`OnPrem:` + strings.Replace(fmt.Sprintf("%v", this.OnPrem), "InfraF5HostedOnPrem", "InfraF5HostedOnPrem", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`TrafficType:` + fmt.Sprintf("%v", this.TrafficType) + `,`,
		`CreateBotInfraChoice:` + fmt.Sprintf("%v", this.CreateBotInfraChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_CreateCloudHosted) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_CreateCloudHosted{`,
		`CreateCloudHosted:` + strings.Replace(fmt.Sprintf("%v", this.CreateCloudHosted), "CreateSpecInfraCloudHosted", "CreateSpecInfraCloudHosted", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`EnvironmentType:` + fmt.Sprintf("%v", this.EnvironmentType) + `,`,
		`TrafficType:` + fmt.Sprintf("%v", this.TrafficType) + `,`,
		`BotInfraChoice:` + fmt.Sprintf("%v", this.BotInfraChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_CloudHosted) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_CloudHosted{`,
		`CloudHosted:` + strings.Replace(fmt.Sprintf("%v", this.CloudHosted), "InfraCloudHosted", "InfraCloudHosted", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_PhysicalHosted) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_PhysicalHosted{`,
		`PhysicalHosted:` + strings.Replace(fmt.Sprintf("%v", this.PhysicalHosted), "InfraF5HostedOnPrem", "InfraF5HostedOnPrem", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_OnPrem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_OnPrem{`,
		`OnPrem:` + strings.Replace(fmt.Sprintf("%v", this.OnPrem), "InfraF5HostedOnPrem", "InfraF5HostedOnPrem", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotEndpointPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BotEndpointPolicy == nil {
				m.BotEndpointPolicy = &views.ObjectRefType{}
			}
			if err := m.BotEndpointPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotEndpointPolicyMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BotEndpointPolicyMetadata == nil {
				m.BotEndpointPolicyMetadata = &EndpointPolicyMetadata{}
			}
			if err := m.BotEndpointPolicyMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotAllowlistPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BotAllowlistPolicy == nil {
				m.BotAllowlistPolicy = &views.ObjectRefType{}
			}
			if err := m.BotAllowlistPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotAllowlistPolicyMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BotAllowlistPolicyMetadata == nil {
				m.BotAllowlistPolicyMetadata = &PolicyMetadata{}
			}
			if err := m.BotAllowlistPolicyMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotNetworkPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BotNetworkPolicy == nil {
				m.BotNetworkPolicy = &views.ObjectRefType{}
			}
			if err := m.BotNetworkPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotNetworkPolicyMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BotNetworkPolicyMetadata == nil {
				m.BotNetworkPolicyMetadata = &PolicyMetadata{}
			}
			if err := m.BotNetworkPolicyMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvironmentType", wireType)
			}
			m.EnvironmentType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnvironmentType |= EnvironmentType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficType", wireType)
			}
			m.TrafficType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrafficType |= TrafficType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraType", wireType)
			}
			m.InfraType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InfraType |= InfraType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraHostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InfraHostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ingress = append(m.Ingress, &Ingress{})
			if err := m.Ingress[len(m.Ingress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Egress = append(m.Egress, &Egress{})
			if err := m.Egress[len(m.Egress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostNames = append(m.HostNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddresses = append(m.IpAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType == 0 {
				var v Location
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Location(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InfraRegion = append(m.InfraRegion, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.InfraRegion) == 0 {
					m.InfraRegion = make([]Location, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Location
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Location(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InfraRegion = append(m.InfraRegion, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraRegion", wireType)
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirmwareReleaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirmwareReleaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpmClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpmClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotThreatIntelligencePolicyMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BotThreatIntelligencePolicyMetadata == nil {
				m.BotThreatIntelligencePolicyMetadata = &PolicyMetadata{}
			}
			if err := m.BotThreatIntelligencePolicyMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudHosted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InfraCloudHosted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BotInfraChoice = &GlobalSpecType_CloudHosted{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalHosted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InfraF5HostedOnPrem{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BotInfraChoice = &GlobalSpecType_PhysicalHosted{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnPrem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InfraF5HostedOnPrem{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BotInfraChoice = &GlobalSpecType_OnPrem{v}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterState", wireType)
			}
			m.ClusterState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterState |= ClusterState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateCloudHosted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateSpecInfraCloudHosted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CreateBotInfraChoice = &GlobalSpecType_CreateCloudHosted{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfraCloudHosted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfraCloudHosted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfraCloudHosted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraHostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InfraHostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirmwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirmwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ingress = append(m.Ingress, &Ingress{})
			if err := m.Ingress[len(m.Ingress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Egress = append(m.Egress, &Egress{})
			if err := m.Egress[len(m.Egress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostNames = append(m.HostNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddresses = append(m.IpAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v Location
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Location(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InfraRegion = append(m.InfraRegion, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.InfraRegion) == 0 {
					m.InfraRegion = make([]Location, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Location
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Location(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InfraRegion = append(m.InfraRegion, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraRegion", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecInfraCloudHosted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecInfraCloudHosted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecInfraCloudHosted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Production", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Production{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TypeChoice = &CreateSpecInfraCloudHosted_Production{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Testing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Testing{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TypeChoice = &CreateSpecInfraCloudHosted_Testing{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddresses = append(m.IpAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfraF5HostedOnPrem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfraF5HostedOnPrem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfraF5HostedOnPrem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirmwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirmwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &Device{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraHostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InfraHostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Device) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Device: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Device: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceFirmwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceFirmwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpInfo == nil {
				m.IpInfo = &IPInfo{}
			}
			if err := m.IpInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificationStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificationStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traffic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Traffic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wan = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Local = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointPolicyMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointPolicyMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointPolicyMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TrafficType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ingress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ingress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ingress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeChoice = &Ingress_HostName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeChoice = &Ingress_IpAddress{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			m.Region = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Region |= Location(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Egress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Egress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Egress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			m.Region = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Region |= Location(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Production) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Production: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Production: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region_1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region_1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region_2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region_2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Testing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Testing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Testing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region_1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region_1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotEndpointPolicyMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BotEndpointPolicyMetadata == nil {
				m.BotEndpointPolicyMetadata = &EndpointPolicyMetadata{}
			}
			if err := m.BotEndpointPolicyMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotAllowlistPolicyMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BotAllowlistPolicyMetadata == nil {
				m.BotAllowlistPolicyMetadata = &PolicyMetadata{}
			}
			if err := m.BotAllowlistPolicyMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotNetworkPolicyMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BotNetworkPolicyMetadata == nil {
				m.BotNetworkPolicyMetadata = &PolicyMetadata{}
			}
			if err := m.BotNetworkPolicyMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvironmentType", wireType)
			}
			m.EnvironmentType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnvironmentType |= EnvironmentType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficType", wireType)
			}
			m.TrafficType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrafficType |= TrafficType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraType", wireType)
			}
			m.InfraType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InfraType |= InfraType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraHostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InfraHostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ingress = append(m.Ingress, &Ingress{})
			if err := m.Ingress[len(m.Ingress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Egress = append(m.Egress, &Egress{})
			if err := m.Egress[len(m.Egress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostNames = append(m.HostNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddresses = append(m.IpAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType == 0 {
				var v Location
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Location(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InfraRegion = append(m.InfraRegion, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.InfraRegion) == 0 {
					m.InfraRegion = make([]Location, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Location
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Location(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InfraRegion = append(m.InfraRegion, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraRegion", wireType)
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudHosted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InfraCloudHosted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BotInfraChoice = &GetSpecType_CloudHosted{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalHosted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InfraF5HostedOnPrem{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BotInfraChoice = &GetSpecType_PhysicalHosted{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnPrem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InfraF5HostedOnPrem{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BotInfraChoice = &GetSpecType_OnPrem{v}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterState", wireType)
			}
			m.ClusterState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterState |= ClusterState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficType", wireType)
			}
			m.TrafficType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrafficType |= TrafficType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateCloudHosted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateSpecInfraCloudHosted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CreateBotInfraChoice = &CreateSpecType_CreateCloudHosted{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvironmentType", wireType)
			}
			m.EnvironmentType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnvironmentType |= EnvironmentType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficType", wireType)
			}
			m.TrafficType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrafficType |= TrafficType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudHosted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InfraCloudHosted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BotInfraChoice = &ReplaceSpecType_CloudHosted{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalHosted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InfraF5HostedOnPrem{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BotInfraChoice = &ReplaceSpecType_PhysicalHosted{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnPrem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InfraF5HostedOnPrem{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BotInfraChoice = &ReplaceSpecType_OnPrem{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
