// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package bot_defense

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *BotInfraWithVersion) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotInfraWithVersion) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotInfraWithVersion) DeepCopy() *BotInfraWithVersion {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotInfraWithVersion{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotInfraWithVersion) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotInfraWithVersion) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotInfraWithVersionValidator().Validate(ctx, m, opts...)
}

type ValidateBotInfraWithVersion struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotInfraWithVersion) BotInfraNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bot_infra_name")
	}

	return validatorFn, nil
}

func (v *ValidateBotInfraWithVersion) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotInfraWithVersion)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotInfraWithVersion got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["bot_infra_name"]; exists {

		vOpts := append(opts, db.WithValidateField("bot_infra_name"))
		if err := fv(ctx, m.GetBotInfraName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["in_use_version"]; exists {

		vOpts := append(opts, db.WithValidateField("in_use_version"))
		if err := fv(ctx, m.GetInUseVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotInfraWithVersionValidator = func() *ValidateBotInfraWithVersion {
	v := &ValidateBotInfraWithVersion{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBotInfraName := v.BotInfraNameValidationRuleHandler
	rulesBotInfraName := map[string]string{
		"ves.io.schema.rules.string.min_len":         "1",
		"ves.io.schema.rules.string.ves_object_name": "true",
	}
	vFn, err = vrhBotInfraName(rulesBotInfraName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotInfraWithVersion.bot_infra_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bot_infra_name"] = vFn

	return v
}()

func BotInfraWithVersionValidator() db.Validator {
	return DefaultBotInfraWithVersionValidator
}

// augmented methods on protoc/std generated struct

func (m *Cookie) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Cookie) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Cookie) DeepCopy() *Cookie {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Cookie{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Cookie) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Cookie) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CookieValidator().Validate(ctx, m, opts...)
}

type ValidateCookie struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCookie) CookieChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for CookieChoice")
	}
	return validatorFn, nil
}

func (v *ValidateCookie) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateCookie) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Cookie)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Cookie got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["CookieChoice"]; exists {
		val := m.GetCookieChoice()
		vOpts := append(opts,
			db.WithValidateField("CookieChoice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCookieChoice().(type) {
	case *Cookie_CookieAll:
		if fv, exists := v.FldValidators["CookieChoice.cookie_all"]; exists {
			val := m.GetCookieChoice().(*Cookie_CookieAll).CookieAll
			vOpts := append(opts,
				db.WithValidateField("CookieChoice"),
				db.WithValidateField("cookie_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Cookie_CookieOr:
		if fv, exists := v.FldValidators["CookieChoice.cookie_or"]; exists {
			val := m.GetCookieChoice().(*Cookie_CookieOr).CookieOr
			vOpts := append(opts,
				db.WithValidateField("CookieChoice"),
				db.WithValidateField("cookie_or"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Cookie_CookieAnd:
		if fv, exists := v.FldValidators["CookieChoice.cookie_and"]; exists {
			val := m.GetCookieChoice().(*Cookie_CookieAnd).CookieAnd
			vOpts := append(opts,
				db.WithValidateField("CookieChoice"),
				db.WithValidateField("cookie_and"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Cookie_CookieNone:
		if fv, exists := v.FldValidators["CookieChoice.cookie_none"]; exists {
			val := m.GetCookieChoice().(*Cookie_CookieNone).CookieNone
			vOpts := append(opts,
				db.WithValidateField("CookieChoice"),
				db.WithValidateField("cookie_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Cookie_NotPresentCookie:
		if fv, exists := v.FldValidators["CookieChoice.not_present_cookie"]; exists {
			val := m.GetCookieChoice().(*Cookie_NotPresentCookie).NotPresentCookie
			vOpts := append(opts,
				db.WithValidateField("CookieChoice"),
				db.WithValidateField("not_present_cookie"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCookieValidator = func() *ValidateCookie {
	v := &ValidateCookie{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCookieChoice := v.CookieChoiceValidationRuleHandler
	rulesCookieChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCookieChoice(rulesCookieChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Cookie.CookieChoice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["CookieChoice"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Cookie.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["CookieChoice.cookie_or"] = CookieMatcherValidator().Validate
	v.FldValidators["CookieChoice.cookie_and"] = CookieMatcherValidator().Validate
	v.FldValidators["CookieChoice.cookie_none"] = CookieMatcherValidator().Validate

	return v
}()

func CookieValidator() db.Validator {
	return DefaultCookieValidator
}

// augmented methods on protoc/std generated struct

func (m *CookieMatcher) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CookieMatcher) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CookieMatcher) DeepCopy() *CookieMatcher {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CookieMatcher{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CookieMatcher) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CookieMatcher) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CookieMatcherValidator().Validate(ctx, m, opts...)
}

type ValidateCookieMatcher struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCookieMatcher) CookieMatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cookie_match")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CookieMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CookieMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cookie_match")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CookieMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CookieMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cookie_match")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cookie_match")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCookieMatcher) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CookieMatcher)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CookieMatcher got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cookie_match"]; exists {
		vOpts := append(opts, db.WithValidateField("cookie_match"))
		if err := fv(ctx, m.GetCookieMatch(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCookieMatcherValidator = func() *ValidateCookieMatcher {
	v := &ValidateCookieMatcher{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCookieMatch := v.CookieMatchValidationRuleHandler
	rulesCookieMatch := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.repeated.unique":  "true",
	}
	vFn, err = vrhCookieMatch(rulesCookieMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CookieMatcher.cookie_match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookie_match"] = vFn

	return v
}()

func CookieMatcherValidator() db.Validator {
	return DefaultCookieMatcherValidator
}

// augmented methods on protoc/std generated struct

func (m *CookieMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CookieMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CookieMatcherType) DeepCopy() *CookieMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CookieMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CookieMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CookieMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CookieMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCookieMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCookieMatcherType) CompareTypeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for compare_type_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCookieMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CookieMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CookieMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["compare_type_choice"]; exists {
		val := m.GetCompareTypeChoice()
		vOpts := append(opts,
			db.WithValidateField("compare_type_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCompareTypeChoice().(type) {
	case *CookieMatcherType_Equals:
		if fv, exists := v.FldValidators["compare_type_choice.equals"]; exists {
			val := m.GetCompareTypeChoice().(*CookieMatcherType_Equals).Equals
			vOpts := append(opts,
				db.WithValidateField("compare_type_choice"),
				db.WithValidateField("equals"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieMatcherType_StartsWith:
		if fv, exists := v.FldValidators["compare_type_choice.starts_with"]; exists {
			val := m.GetCompareTypeChoice().(*CookieMatcherType_StartsWith).StartsWith
			vOpts := append(opts,
				db.WithValidateField("compare_type_choice"),
				db.WithValidateField("starts_with"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieMatcherType_Contains:
		if fv, exists := v.FldValidators["compare_type_choice.contains"]; exists {
			val := m.GetCompareTypeChoice().(*CookieMatcherType_Contains).Contains
			vOpts := append(opts,
				db.WithValidateField("compare_type_choice"),
				db.WithValidateField("contains"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieMatcherType_EndsWith:
		if fv, exists := v.FldValidators["compare_type_choice.ends_with"]; exists {
			val := m.GetCompareTypeChoice().(*CookieMatcherType_EndsWith).EndsWith
			vOpts := append(opts,
				db.WithValidateField("compare_type_choice"),
				db.WithValidateField("ends_with"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCookieMatcherTypeValidator = func() *ValidateCookieMatcherType {
	v := &ValidateCookieMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCompareTypeChoice := v.CompareTypeChoiceValidationRuleHandler
	rulesCompareTypeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCompareTypeChoice(rulesCompareTypeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CookieMatcherType.compare_type_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["compare_type_choice"] = vFn

	v.FldValidators["compare_type_choice.equals"] = CookieMatcherValueValidator().Validate
	v.FldValidators["compare_type_choice.starts_with"] = CookieMatcherValueValidator().Validate
	v.FldValidators["compare_type_choice.contains"] = CookieMatcherValueValidator().Validate
	v.FldValidators["compare_type_choice.ends_with"] = CookieMatcherValueValidator().Validate

	return v
}()

func CookieMatcherTypeValidator() db.Validator {
	return DefaultCookieMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CookieMatcherValue) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CookieMatcherValue) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CookieMatcherValue) DeepCopy() *CookieMatcherValue {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CookieMatcherValue{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CookieMatcherValue) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CookieMatcherValue) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CookieMatcherValueValidator().Validate(ctx, m, opts...)
}

type ValidateCookieMatcherValue struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCookieMatcherValue) ValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for value")
	}

	return validatorFn, nil
}

func (v *ValidateCookieMatcherValue) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CookieMatcherValue)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CookieMatcherValue got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["case_sensitive"]; exists {

		vOpts := append(opts, db.WithValidateField("case_sensitive"))
		if err := fv(ctx, m.GetCaseSensitive(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_value"]; exists {

		vOpts := append(opts, db.WithValidateField("not_value"))
		if err := fv(ctx, m.GetNotValue(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCookieMatcherValueValidator = func() *ValidateCookieMatcherValue {
	v := &ValidateCookieMatcherValue{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhValue := v.ValueValidationRuleHandler
	rulesValue := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhValue(rulesValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CookieMatcherValue.value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["value"] = vFn

	return v
}()

func CookieMatcherValueValidator() db.Validator {
	return DefaultCookieMatcherValueValidator
}

// augmented methods on protoc/std generated struct

func (m *DomainField) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DomainField) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DomainField) DeepCopy() *DomainField {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DomainField{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DomainField) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DomainField) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DomainFieldValidator().Validate(ctx, m, opts...)
}

type ValidateDomainField struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDomainField) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateDomainField) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DomainField)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DomainField got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain_operator"]; exists {

		vOpts := append(opts, db.WithValidateField("domain_operator"))
		if err := fv(ctx, m.GetDomainOperator(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDomainFieldValidator = func() *ValidateDomainField {
	v := &ValidateDomainField{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.string.not_empty": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DomainField.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["domain_operator"] = DomainOperatorValidator().Validate

	return v
}()

func DomainFieldValidator() db.Validator {
	return DefaultDomainFieldValidator
}

// augmented methods on protoc/std generated struct

func (m *DomainMatcher) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DomainMatcher) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DomainMatcher) DeepCopy() *DomainMatcher {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DomainMatcher{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DomainMatcher) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DomainMatcher) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DomainMatcherValidator().Validate(ctx, m, opts...)
}

type ValidateDomainMatcher struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDomainMatcher) DomainMatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for domain_match")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*DomainMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := DomainMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domain_match")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*DomainMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*DomainMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domain_match")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domain_match")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDomainMatcher) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DomainMatcher)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DomainMatcher got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain_match"]; exists {
		vOpts := append(opts, db.WithValidateField("domain_match"))
		if err := fv(ctx, m.GetDomainMatch(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDomainMatcherValidator = func() *ValidateDomainMatcher {
	v := &ValidateDomainMatcher{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainMatch := v.DomainMatchValidationRuleHandler
	rulesDomainMatch := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.repeated.unique":  "true",
	}
	vFn, err = vrhDomainMatch(rulesDomainMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DomainMatcher.domain_match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_match"] = vFn

	return v
}()

func DomainMatcherValidator() db.Validator {
	return DefaultDomainMatcherValidator
}

// augmented methods on protoc/std generated struct

func (m *DomainMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DomainMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DomainMatcherType) DeepCopy() *DomainMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DomainMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DomainMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DomainMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DomainMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDomainMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDomainMatcherType) OperatorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ComparisonOperator)
		return int32(i)
	}
	// ComparisonOperator_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ComparisonOperator_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operator")
	}

	return validatorFn, nil
}

func (v *ValidateDomainMatcherType) ValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for value")
	}

	return validatorFn, nil
}

func (v *ValidateDomainMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DomainMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DomainMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["negation"]; exists {

		vOpts := append(opts, db.WithValidateField("negation"))
		if err := fv(ctx, m.GetNegation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operator"]; exists {

		vOpts := append(opts, db.WithValidateField("operator"))
		if err := fv(ctx, m.GetOperator(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDomainMatcherTypeValidator = func() *ValidateDomainMatcherType {
	v := &ValidateDomainMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOperator := v.OperatorValidationRuleHandler
	rulesOperator := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOperator(rulesOperator)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DomainMatcherType.operator: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operator"] = vFn

	vrhValue := v.ValueValidationRuleHandler
	rulesValue := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhValue(rulesValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DomainMatcherType.value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["value"] = vFn

	return v
}()

func DomainMatcherTypeValidator() db.Validator {
	return DefaultDomainMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DomainOperator) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DomainOperator) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DomainOperator) DeepCopy() *DomainOperator {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DomainOperator{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DomainOperator) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DomainOperator) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DomainOperatorValidator().Validate(ctx, m, opts...)
}

type ValidateDomainOperator struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDomainOperator) DomainOperatorChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for Domain_operator_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDomainOperator) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DomainOperator)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DomainOperator got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["Domain_operator_choice"]; exists {
		val := m.GetDomainOperatorChoice()
		vOpts := append(opts,
			db.WithValidateField("Domain_operator_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainOperatorChoice().(type) {
	case *DomainOperator_AllDomain:
		if fv, exists := v.FldValidators["Domain_operator_choice.all_domain"]; exists {
			val := m.GetDomainOperatorChoice().(*DomainOperator_AllDomain).AllDomain
			vOpts := append(opts,
				db.WithValidateField("Domain_operator_choice"),
				db.WithValidateField("all_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DomainOperator_DomainOr:
		if fv, exists := v.FldValidators["Domain_operator_choice.domain_or"]; exists {
			val := m.GetDomainOperatorChoice().(*DomainOperator_DomainOr).DomainOr
			vOpts := append(opts,
				db.WithValidateField("Domain_operator_choice"),
				db.WithValidateField("domain_or"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DomainOperator_DomainAnd:
		if fv, exists := v.FldValidators["Domain_operator_choice.domain_and"]; exists {
			val := m.GetDomainOperatorChoice().(*DomainOperator_DomainAnd).DomainAnd
			vOpts := append(opts,
				db.WithValidateField("Domain_operator_choice"),
				db.WithValidateField("domain_and"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DomainOperator_DomainNone:
		if fv, exists := v.FldValidators["Domain_operator_choice.domain_none"]; exists {
			val := m.GetDomainOperatorChoice().(*DomainOperator_DomainNone).DomainNone
			vOpts := append(opts,
				db.WithValidateField("Domain_operator_choice"),
				db.WithValidateField("domain_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDomainOperatorValidator = func() *ValidateDomainOperator {
	v := &ValidateDomainOperator{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainOperatorChoice := v.DomainOperatorChoiceValidationRuleHandler
	rulesDomainOperatorChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainOperatorChoice(rulesDomainOperatorChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DomainOperator.Domain_operator_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["Domain_operator_choice"] = vFn

	v.FldValidators["Domain_operator_choice.domain_or"] = DomainMatcherValidator().Validate
	v.FldValidators["Domain_operator_choice.domain_and"] = DomainMatcherValidator().Validate
	v.FldValidators["Domain_operator_choice.domain_none"] = DomainMatcherValidator().Validate

	return v
}()

func DomainOperatorValidator() db.Validator {
	return DefaultDomainOperatorValidator
}

// augmented methods on protoc/std generated struct

func (m *GenericEmptyType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GenericEmptyType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GenericEmptyType) DeepCopy() *GenericEmptyType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GenericEmptyType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GenericEmptyType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GenericEmptyType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GenericEmptyTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGenericEmptyType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGenericEmptyType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GenericEmptyType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GenericEmptyType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGenericEmptyTypeValidator = func() *ValidateGenericEmptyType {
	v := &ValidateGenericEmptyType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GenericEmptyTypeValidator() db.Validator {
	return DefaultGenericEmptyTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GoodBotDetectionSetting) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GoodBotDetectionSetting) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GoodBotDetectionSetting) DeepCopy() *GoodBotDetectionSetting {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GoodBotDetectionSetting{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GoodBotDetectionSetting) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GoodBotDetectionSetting) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GoodBotDetectionSettingValidator().Validate(ctx, m, opts...)
}

type ValidateGoodBotDetectionSetting struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGoodBotDetectionSetting) GoodbotChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for goodbot_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGoodBotDetectionSetting) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GoodBotDetectionSetting)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GoodBotDetectionSetting got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["goodbot_choice"]; exists {
		val := m.GetGoodbotChoice()
		vOpts := append(opts,
			db.WithValidateField("goodbot_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetGoodbotChoice().(type) {
	case *GoodBotDetectionSetting_AllowGoodBots:
		if fv, exists := v.FldValidators["goodbot_choice.allow_good_bots"]; exists {
			val := m.GetGoodbotChoice().(*GoodBotDetectionSetting_AllowGoodBots).AllowGoodBots
			vOpts := append(opts,
				db.WithValidateField("goodbot_choice"),
				db.WithValidateField("allow_good_bots"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GoodBotDetectionSetting_MitigateGoodBots:
		if fv, exists := v.FldValidators["goodbot_choice.mitigate_good_bots"]; exists {
			val := m.GetGoodbotChoice().(*GoodBotDetectionSetting_MitigateGoodBots).MitigateGoodBots
			vOpts := append(opts,
				db.WithValidateField("goodbot_choice"),
				db.WithValidateField("mitigate_good_bots"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGoodBotDetectionSettingValidator = func() *ValidateGoodBotDetectionSetting {
	v := &ValidateGoodBotDetectionSetting{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhGoodbotChoice := v.GoodbotChoiceValidationRuleHandler
	rulesGoodbotChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhGoodbotChoice(rulesGoodbotChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GoodBotDetectionSetting.goodbot_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["goodbot_choice"] = vFn

	return v
}()

func GoodBotDetectionSettingValidator() db.Validator {
	return DefaultGoodBotDetectionSettingValidator
}

// augmented methods on protoc/std generated struct

func (m *HeaderMatcher) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HeaderMatcher) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HeaderMatcher) DeepCopy() *HeaderMatcher {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HeaderMatcher{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HeaderMatcher) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HeaderMatcher) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HeaderMatcherValidator().Validate(ctx, m, opts...)
}

type ValidateHeaderMatcher struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHeaderMatcher) HeaderMatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for header_match")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*MatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := MatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for header_match")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*MatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*MatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated header_match")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items header_match")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHeaderMatcher) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HeaderMatcher)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HeaderMatcher got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["header_match"]; exists {
		vOpts := append(opts, db.WithValidateField("header_match"))
		if err := fv(ctx, m.GetHeaderMatch(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHeaderMatcherValidator = func() *ValidateHeaderMatcher {
	v := &ValidateHeaderMatcher{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHeaderMatch := v.HeaderMatchValidationRuleHandler
	rulesHeaderMatch := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.repeated.unique":  "true",
	}
	vFn, err = vrhHeaderMatch(rulesHeaderMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderMatcher.header_match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["header_match"] = vFn

	return v
}()

func HeaderMatcherValidator() db.Validator {
	return DefaultHeaderMatcherValidator
}

// augmented methods on protoc/std generated struct

func (m *HeaderNameValuePair) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HeaderNameValuePair) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HeaderNameValuePair) DeepCopy() *HeaderNameValuePair {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HeaderNameValuePair{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HeaderNameValuePair) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HeaderNameValuePair) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HeaderNameValuePairValidator().Validate(ctx, m, opts...)
}

type ValidateHeaderNameValuePair struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHeaderNameValuePair) HeaderNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for header_name")
	}

	return validatorFn, nil
}

func (v *ValidateHeaderNameValuePair) HeaderValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for header_value")
	}

	return validatorFn, nil
}

func (v *ValidateHeaderNameValuePair) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HeaderNameValuePair)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HeaderNameValuePair got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["header_name"]; exists {

		vOpts := append(opts, db.WithValidateField("header_name"))
		if err := fv(ctx, m.GetHeaderName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header_value"]; exists {

		vOpts := append(opts, db.WithValidateField("header_value"))
		if err := fv(ctx, m.GetHeaderValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHeaderNameValuePairValidator = func() *ValidateHeaderNameValuePair {
	v := &ValidateHeaderNameValuePair{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHeaderName := v.HeaderNameValidationRuleHandler
	rulesHeaderName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhHeaderName(rulesHeaderName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderNameValuePair.header_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["header_name"] = vFn

	vrhHeaderValue := v.HeaderValueValidationRuleHandler
	rulesHeaderValue := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhHeaderValue(rulesHeaderValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderNameValuePair.header_value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["header_value"] = vFn

	return v
}()

func HeaderNameValuePairValidator() db.Validator {
	return DefaultHeaderNameValuePairValidator
}

// augmented methods on protoc/std generated struct

func (m *HeaderOperator) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HeaderOperator) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HeaderOperator) DeepCopy() *HeaderOperator {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HeaderOperator{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HeaderOperator) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HeaderOperator) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HeaderOperatorValidator().Validate(ctx, m, opts...)
}

type ValidateHeaderOperator struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHeaderOperator) HeaderOperatorChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for header_operator_choice")
	}
	return validatorFn, nil
}

func (v *ValidateHeaderOperator) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateHeaderOperator) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HeaderOperator)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HeaderOperator got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["header_operator_choice"]; exists {
		val := m.GetHeaderOperatorChoice()
		vOpts := append(opts,
			db.WithValidateField("header_operator_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetHeaderOperatorChoice().(type) {
	case *HeaderOperator_AllHeader:
		if fv, exists := v.FldValidators["header_operator_choice.all_header"]; exists {
			val := m.GetHeaderOperatorChoice().(*HeaderOperator_AllHeader).AllHeader
			vOpts := append(opts,
				db.WithValidateField("header_operator_choice"),
				db.WithValidateField("all_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderOperator_HeaderOr:
		if fv, exists := v.FldValidators["header_operator_choice.header_or"]; exists {
			val := m.GetHeaderOperatorChoice().(*HeaderOperator_HeaderOr).HeaderOr
			vOpts := append(opts,
				db.WithValidateField("header_operator_choice"),
				db.WithValidateField("header_or"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderOperator_HeaderAnd:
		if fv, exists := v.FldValidators["header_operator_choice.header_and"]; exists {
			val := m.GetHeaderOperatorChoice().(*HeaderOperator_HeaderAnd).HeaderAnd
			vOpts := append(opts,
				db.WithValidateField("header_operator_choice"),
				db.WithValidateField("header_and"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderOperator_HeaderNone:
		if fv, exists := v.FldValidators["header_operator_choice.header_none"]; exists {
			val := m.GetHeaderOperatorChoice().(*HeaderOperator_HeaderNone).HeaderNone
			vOpts := append(opts,
				db.WithValidateField("header_operator_choice"),
				db.WithValidateField("header_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderOperator_NotPresentHeader:
		if fv, exists := v.FldValidators["header_operator_choice.not_present_header"]; exists {
			val := m.GetHeaderOperatorChoice().(*HeaderOperator_NotPresentHeader).NotPresentHeader
			vOpts := append(opts,
				db.WithValidateField("header_operator_choice"),
				db.WithValidateField("not_present_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHeaderOperatorValidator = func() *ValidateHeaderOperator {
	v := &ValidateHeaderOperator{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHeaderOperatorChoice := v.HeaderOperatorChoiceValidationRuleHandler
	rulesHeaderOperatorChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhHeaderOperatorChoice(rulesHeaderOperatorChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderOperator.header_operator_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["header_operator_choice"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderOperator.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["header_operator_choice.header_or"] = HeaderMatcherValidator().Validate
	v.FldValidators["header_operator_choice.header_and"] = HeaderMatcherValidator().Validate
	v.FldValidators["header_operator_choice.header_none"] = HeaderMatcherValidator().Validate

	return v
}()

func HeaderOperatorValidator() db.Validator {
	return DefaultHeaderOperatorValidator
}

// augmented methods on protoc/std generated struct

func (m *HeaderOperatorEmptyType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HeaderOperatorEmptyType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HeaderOperatorEmptyType) DeepCopy() *HeaderOperatorEmptyType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HeaderOperatorEmptyType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HeaderOperatorEmptyType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HeaderOperatorEmptyType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HeaderOperatorEmptyTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHeaderOperatorEmptyType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHeaderOperatorEmptyType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HeaderOperatorEmptyType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HeaderOperatorEmptyType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHeaderOperatorEmptyTypeValidator = func() *ValidateHeaderOperatorEmptyType {
	v := &ValidateHeaderOperatorEmptyType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func HeaderOperatorEmptyTypeValidator() db.Validator {
	return DefaultHeaderOperatorEmptyTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *IPAllowlistDetail) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IPAllowlistDetail) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IPAllowlistDetail) DeepCopy() *IPAllowlistDetail {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IPAllowlistDetail{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IPAllowlistDetail) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IPAllowlistDetail) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IPAllowlistDetailValidator().Validate(ctx, m, opts...)
}

type ValidateIPAllowlistDetail struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIPAllowlistDetail) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IPAllowlistDetail)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IPAllowlistDetail got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetClientIdentifierChoice().(type) {
	case *IPAllowlistDetail_IpDetail:
		if fv, exists := v.FldValidators["client_identifier_choice.ip_detail"]; exists {
			val := m.GetClientIdentifierChoice().(*IPAllowlistDetail_IpDetail).IpDetail
			vOpts := append(opts,
				db.WithValidateField("client_identifier_choice"),
				db.WithValidateField("ip_detail"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *IPAllowlistDetail_IpPrefixDetail:
		if fv, exists := v.FldValidators["client_identifier_choice.ip_prefix_detail"]; exists {
			val := m.GetClientIdentifierChoice().(*IPAllowlistDetail_IpPrefixDetail).IpPrefixDetail
			vOpts := append(opts,
				db.WithValidateField("client_identifier_choice"),
				db.WithValidateField("ip_prefix_detail"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIPAllowlistDetailValidator = func() *ValidateIPAllowlistDetail {
	v := &ValidateIPAllowlistDetail{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["client_identifier_choice.ip_detail"] = IPDetailValidator().Validate
	v.FldValidators["client_identifier_choice.ip_prefix_detail"] = IPPrefixDetailValidator().Validate

	return v
}()

func IPAllowlistDetailValidator() db.Validator {
	return DefaultIPAllowlistDetailValidator
}

// augmented methods on protoc/std generated struct

func (m *IPAllowlists) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IPAllowlists) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IPAllowlists) DeepCopy() *IPAllowlists {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IPAllowlists{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IPAllowlists) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IPAllowlists) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IPAllowlistsValidator().Validate(ctx, m, opts...)
}

type ValidateIPAllowlists struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIPAllowlists) IpAllowlistValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for ip_allowlist")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*IPAllowlistDetail, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := IPAllowlistDetailValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ip_allowlist")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*IPAllowlistDetail)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*IPAllowlistDetail, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ip_allowlist")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ip_allowlist")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateIPAllowlists) IpRangeAllowlistValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for ip_range_allowlist")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*IPRangeAllowlistDetail, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := IPRangeAllowlistDetailValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ip_range_allowlist")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*IPRangeAllowlistDetail)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*IPRangeAllowlistDetail, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ip_range_allowlist")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ip_range_allowlist")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateIPAllowlists) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IPAllowlists)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IPAllowlists got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ip_allowlist"]; exists {
		vOpts := append(opts, db.WithValidateField("ip_allowlist"))
		if err := fv(ctx, m.GetIpAllowlist(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_range_allowlist"]; exists {
		vOpts := append(opts, db.WithValidateField("ip_range_allowlist"))
		if err := fv(ctx, m.GetIpRangeAllowlist(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIPAllowlistsValidator = func() *ValidateIPAllowlists {
	v := &ValidateIPAllowlists{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIpAllowlist := v.IpAllowlistValidationRuleHandler
	rulesIpAllowlist := map[string]string{
		"ves.io.schema.rules.repeated.unique": "true",
	}
	vFn, err = vrhIpAllowlist(rulesIpAllowlist)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IPAllowlists.ip_allowlist: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_allowlist"] = vFn

	vrhIpRangeAllowlist := v.IpRangeAllowlistValidationRuleHandler
	rulesIpRangeAllowlist := map[string]string{
		"ves.io.schema.rules.repeated.unique": "true",
	}
	vFn, err = vrhIpRangeAllowlist(rulesIpRangeAllowlist)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IPAllowlists.ip_range_allowlist: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_range_allowlist"] = vFn

	return v
}()

func IPAllowlistsValidator() db.Validator {
	return DefaultIPAllowlistsValidator
}

// augmented methods on protoc/std generated struct

func (m *IPDetail) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IPDetail) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IPDetail) DeepCopy() *IPDetail {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IPDetail{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IPDetail) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IPDetail) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IPDetailValidator().Validate(ctx, m, opts...)
}

type ValidateIPDetail struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIPDetail) IpValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip_value")
	}

	return validatorFn, nil
}

func (v *ValidateIPDetail) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IPDetail)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IPDetail got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ip_description"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_description"))
		if err := fv(ctx, m.GetIpDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_value"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_value"))
		if err := fv(ctx, m.GetIpValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIPDetailValidator = func() *ValidateIPDetail {
	v := &ValidateIPDetail{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIpValue := v.IpValueValidationRuleHandler
	rulesIpValue := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.ipv4":      "true",
		"ves.io.schema.rules.string.not_empty": "true",
	}
	vFn, err = vrhIpValue(rulesIpValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IPDetail.ip_value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_value"] = vFn

	return v
}()

func IPDetailValidator() db.Validator {
	return DefaultIPDetailValidator
}

// augmented methods on protoc/std generated struct

func (m *IPPrefixDetail) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IPPrefixDetail) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IPPrefixDetail) DeepCopy() *IPPrefixDetail {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IPPrefixDetail{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IPPrefixDetail) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IPPrefixDetail) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IPPrefixDetailValidator().Validate(ctx, m, opts...)
}

type ValidateIPPrefixDetail struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIPPrefixDetail) IpValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip_value")
	}

	return validatorFn, nil
}

func (v *ValidateIPPrefixDetail) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IPPrefixDetail)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IPPrefixDetail got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ip_description"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_description"))
		if err := fv(ctx, m.GetIpDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_value"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_value"))
		if err := fv(ctx, m.GetIpValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIPPrefixDetailValidator = func() *ValidateIPPrefixDetail {
	v := &ValidateIPPrefixDetail{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIpValue := v.IpValueValidationRuleHandler
	rulesIpValue := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.string.ipv4_prefix": "true",
		"ves.io.schema.rules.string.not_empty":   "true",
	}
	vFn, err = vrhIpValue(rulesIpValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IPPrefixDetail.ip_value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_value"] = vFn

	return v
}()

func IPPrefixDetailValidator() db.Validator {
	return DefaultIPPrefixDetailValidator
}

// augmented methods on protoc/std generated struct

func (m *IPRangeAllowlistDetail) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IPRangeAllowlistDetail) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IPRangeAllowlistDetail) DeepCopy() *IPRangeAllowlistDetail {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IPRangeAllowlistDetail{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IPRangeAllowlistDetail) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IPRangeAllowlistDetail) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IPRangeAllowlistDetailValidator().Validate(ctx, m, opts...)
}

type ValidateIPRangeAllowlistDetail struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIPRangeAllowlistDetail) StartWithValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_with")
	}

	return validatorFn, nil
}

func (v *ValidateIPRangeAllowlistDetail) EndWithValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_with")
	}

	return validatorFn, nil
}

func (v *ValidateIPRangeAllowlistDetail) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IPRangeAllowlistDetail)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IPRangeAllowlistDetail got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_with"]; exists {

		vOpts := append(opts, db.WithValidateField("end_with"))
		if err := fv(ctx, m.GetEndWith(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_description"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_description"))
		if err := fv(ctx, m.GetIpDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_with"]; exists {

		vOpts := append(opts, db.WithValidateField("start_with"))
		if err := fv(ctx, m.GetStartWith(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIPRangeAllowlistDetailValidator = func() *ValidateIPRangeAllowlistDetail {
	v := &ValidateIPRangeAllowlistDetail{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStartWith := v.StartWithValidationRuleHandler
	rulesStartWith := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.ipv4":      "true",
		"ves.io.schema.rules.string.not_empty": "true",
	}
	vFn, err = vrhStartWith(rulesStartWith)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IPRangeAllowlistDetail.start_with: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_with"] = vFn

	vrhEndWith := v.EndWithValidationRuleHandler
	rulesEndWith := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.ipv4":      "true",
		"ves.io.schema.rules.string.not_empty": "true",
	}
	vFn, err = vrhEndWith(rulesEndWith)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IPRangeAllowlistDetail.end_with: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_with"] = vFn

	return v
}()

func IPRangeAllowlistDetailValidator() db.Validator {
	return DefaultIPRangeAllowlistDetailValidator
}

// augmented methods on protoc/std generated struct

func (m *ManualRoutingDetail) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ManualRoutingDetail) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ManualRoutingDetail) DeepCopy() *ManualRoutingDetail {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ManualRoutingDetail{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ManualRoutingDetail) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ManualRoutingDetail) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ManualRoutingDetailValidator().Validate(ctx, m, opts...)
}

type ValidateManualRoutingDetail struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateManualRoutingDetail) DomainOperatorChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for Domain_operator_choice")
	}
	return validatorFn, nil
}

func (v *ValidateManualRoutingDetail) OutboundOperatorChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outbound_operator_choice")
	}
	return validatorFn, nil
}

func (v *ValidateManualRoutingDetail) DomainNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_name")
	}

	return validatorFn, nil
}

func (v *ValidateManualRoutingDetail) PortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port")
	}

	return validatorFn, nil
}

func (v *ValidateManualRoutingDetail) OutboundDomainNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outbound_domain_name")
	}

	return validatorFn, nil
}

func (v *ValidateManualRoutingDetail) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ManualRoutingDetail)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ManualRoutingDetail got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["Domain_operator_choice"]; exists {
		val := m.GetDomainOperatorChoice()
		vOpts := append(opts,
			db.WithValidateField("Domain_operator_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainOperatorChoice().(type) {
	case *ManualRoutingDetail_Http:
		if fv, exists := v.FldValidators["Domain_operator_choice.http"]; exists {
			val := m.GetDomainOperatorChoice().(*ManualRoutingDetail_Http).Http
			vOpts := append(opts,
				db.WithValidateField("Domain_operator_choice"),
				db.WithValidateField("http"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ManualRoutingDetail_Https:
		if fv, exists := v.FldValidators["Domain_operator_choice.https"]; exists {
			val := m.GetDomainOperatorChoice().(*ManualRoutingDetail_Https).Https
			vOpts := append(opts,
				db.WithValidateField("Domain_operator_choice"),
				db.WithValidateField("https"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domain_name"]; exists {

		vOpts := append(opts, db.WithValidateField("domain_name"))
		if err := fv(ctx, m.GetDomainName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outbound_domain_name"]; exists {

		vOpts := append(opts, db.WithValidateField("outbound_domain_name"))
		if err := fv(ctx, m.GetOutboundDomainName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outbound_operator_choice"]; exists {
		val := m.GetOutboundOperatorChoice()
		vOpts := append(opts,
			db.WithValidateField("outbound_operator_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetOutboundOperatorChoice().(type) {
	case *ManualRoutingDetail_ProtocolHttp:
		if fv, exists := v.FldValidators["outbound_operator_choice.protocol_http"]; exists {
			val := m.GetOutboundOperatorChoice().(*ManualRoutingDetail_ProtocolHttp).ProtocolHttp
			vOpts := append(opts,
				db.WithValidateField("outbound_operator_choice"),
				db.WithValidateField("protocol_http"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ManualRoutingDetail_ProtocolHttps:
		if fv, exists := v.FldValidators["outbound_operator_choice.protocol_https"]; exists {
			val := m.GetOutboundOperatorChoice().(*ManualRoutingDetail_ProtocolHttps).ProtocolHttps
			vOpts := append(opts,
				db.WithValidateField("outbound_operator_choice"),
				db.WithValidateField("protocol_https"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["port"]; exists {

		vOpts := append(opts, db.WithValidateField("port"))
		if err := fv(ctx, m.GetPort(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultManualRoutingDetailValidator = func() *ValidateManualRoutingDetail {
	v := &ValidateManualRoutingDetail{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainOperatorChoice := v.DomainOperatorChoiceValidationRuleHandler
	rulesDomainOperatorChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainOperatorChoice(rulesDomainOperatorChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ManualRoutingDetail.Domain_operator_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["Domain_operator_choice"] = vFn

	vrhOutboundOperatorChoice := v.OutboundOperatorChoiceValidationRuleHandler
	rulesOutboundOperatorChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhOutboundOperatorChoice(rulesOutboundOperatorChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ManualRoutingDetail.outbound_operator_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outbound_operator_choice"] = vFn

	vrhDomainName := v.DomainNameValidationRuleHandler
	rulesDomainName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.hostname":  "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.not_empty": "true",
	}
	vFn, err = vrhDomainName(rulesDomainName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ManualRoutingDetail.domain_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_name"] = vFn

	vrhPort := v.PortValidationRuleHandler
	rulesPort := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFn, err = vrhPort(rulesPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ManualRoutingDetail.port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port"] = vFn

	vrhOutboundDomainName := v.OutboundDomainNameValidationRuleHandler
	rulesOutboundDomainName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.not_empty": "true",
	}
	vFn, err = vrhOutboundDomainName(rulesOutboundDomainName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ManualRoutingDetail.outbound_domain_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outbound_domain_name"] = vFn

	return v
}()

func ManualRoutingDetailValidator() db.Validator {
	return DefaultManualRoutingDetailValidator
}

// augmented methods on protoc/std generated struct

func (m *ManualRoutings) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ManualRoutings) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ManualRoutings) DeepCopy() *ManualRoutings {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ManualRoutings{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ManualRoutings) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ManualRoutings) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ManualRoutingsValidator().Validate(ctx, m, opts...)
}

type ValidateManualRoutings struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateManualRoutings) ManualRoutingValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for manual_routing")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ManualRoutingDetail, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ManualRoutingDetailValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for manual_routing")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ManualRoutingDetail)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ManualRoutingDetail, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated manual_routing")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items manual_routing")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateManualRoutings) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ManualRoutings)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ManualRoutings got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["manual_routing"]; exists {
		vOpts := append(opts, db.WithValidateField("manual_routing"))
		if err := fv(ctx, m.GetManualRouting(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultManualRoutingsValidator = func() *ValidateManualRoutings {
	v := &ValidateManualRoutings{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhManualRouting := v.ManualRoutingValidationRuleHandler
	rulesManualRouting := map[string]string{
		"ves.io.schema.rules.repeated.unique": "true",
	}
	vFn, err = vrhManualRouting(rulesManualRouting)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ManualRoutings.manual_routing: %s", err)
		panic(errMsg)
	}
	v.FldValidators["manual_routing"] = vFn

	return v
}()

func ManualRoutingsValidator() db.Validator {
	return DefaultManualRoutingsValidator
}

// augmented methods on protoc/std generated struct

func (m *MatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MatcherType) DeepCopy() *MatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMatcherType) MatchTypeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match_type_choice")
	}
	return validatorFn, nil
}

func (v *ValidateMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["match_type_choice"]; exists {
		val := m.GetMatchTypeChoice()
		vOpts := append(opts,
			db.WithValidateField("match_type_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMatchTypeChoice().(type) {
	case *MatcherType_ExactValue:
		if fv, exists := v.FldValidators["match_type_choice.exact_value"]; exists {
			val := m.GetMatchTypeChoice().(*MatcherType_ExactValue).ExactValue
			vOpts := append(opts,
				db.WithValidateField("match_type_choice"),
				db.WithValidateField("exact_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *MatcherType_ContainValue:
		if fv, exists := v.FldValidators["match_type_choice.contain_value"]; exists {
			val := m.GetMatchTypeChoice().(*MatcherType_ContainValue).ContainValue
			vOpts := append(opts,
				db.WithValidateField("match_type_choice"),
				db.WithValidateField("contain_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *MatcherType_StartWithValue:
		if fv, exists := v.FldValidators["match_type_choice.start_with_value"]; exists {
			val := m.GetMatchTypeChoice().(*MatcherType_StartWithValue).StartWithValue
			vOpts := append(opts,
				db.WithValidateField("match_type_choice"),
				db.WithValidateField("start_with_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *MatcherType_EndWithValue:
		if fv, exists := v.FldValidators["match_type_choice.end_with_value"]; exists {
			val := m.GetMatchTypeChoice().(*MatcherType_EndWithValue).EndWithValue
			vOpts := append(opts,
				db.WithValidateField("match_type_choice"),
				db.WithValidateField("end_with_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMatcherTypeValidator = func() *ValidateMatcherType {
	v := &ValidateMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatchTypeChoice := v.MatchTypeChoiceValidationRuleHandler
	rulesMatchTypeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMatchTypeChoice(rulesMatchTypeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatcherType.match_type_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match_type_choice"] = vFn

	v.FldValidators["match_type_choice.exact_value"] = MatcherValueValidator().Validate
	v.FldValidators["match_type_choice.contain_value"] = MatcherValueValidator().Validate
	v.FldValidators["match_type_choice.start_with_value"] = MatcherValueValidator().Validate
	v.FldValidators["match_type_choice.end_with_value"] = MatcherValueValidator().Validate

	return v
}()

func MatcherTypeValidator() db.Validator {
	return DefaultMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *MatcherValue) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MatcherValue) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MatcherValue) DeepCopy() *MatcherValue {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MatcherValue{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MatcherValue) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MatcherValue) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MatcherValueValidator().Validate(ctx, m, opts...)
}

type ValidateMatcherValue struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMatcherValue) ValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for value")
	}

	return validatorFn, nil
}

func (v *ValidateMatcherValue) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MatcherValue)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MatcherValue got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["case_insensitive"]; exists {

		vOpts := append(opts, db.WithValidateField("case_insensitive"))
		if err := fv(ctx, m.GetCaseInsensitive(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not"]; exists {

		vOpts := append(opts, db.WithValidateField("not"))
		if err := fv(ctx, m.GetNot(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMatcherValueValidator = func() *ValidateMatcherValue {
	v := &ValidateMatcherValue{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhValue := v.ValueValidationRuleHandler
	rulesValue := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhValue(rulesValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatcherValue.value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["value"] = vFn

	return v
}()

func MatcherValueValidator() db.Validator {
	return DefaultMatcherValueValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkPolicyContent) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkPolicyContent) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkPolicyContent) DeepCopy() *NetworkPolicyContent {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkPolicyContent{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkPolicyContent) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkPolicyContent) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkPolicyContentValidator().Validate(ctx, m, opts...)
}

type ValidateNetworkPolicyContent struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkPolicyContent) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkPolicyContent)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkPolicyContent got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["manual_routing_list"]; exists {

		vOpts := append(opts, db.WithValidateField("manual_routing_list"))
		if err := fv(ctx, m.GetManualRoutingList(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["upstream_routing_list"]; exists {

		vOpts := append(opts, db.WithValidateField("upstream_routing_list"))
		if err := fv(ctx, m.GetUpstreamRoutingList(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkPolicyContentValidator = func() *ValidateNetworkPolicyContent {
	v := &ValidateNetworkPolicyContent{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["upstream_routing_list"] = UpstreamRoutingsValidator().Validate

	v.FldValidators["manual_routing_list"] = ManualRoutingsValidator().Validate

	return v
}()

func NetworkPolicyContentValidator() db.Validator {
	return DefaultNetworkPolicyContentValidator
}

// augmented methods on protoc/std generated struct

func (m *PathMatcher) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PathMatcher) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PathMatcher) DeepCopy() *PathMatcher {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PathMatcher{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PathMatcher) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PathMatcher) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PathMatcherValidator().Validate(ctx, m, opts...)
}

type ValidatePathMatcher struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePathMatcher) PathMatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for path_match")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*PathMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := PathMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for path_match")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*PathMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*PathMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated path_match")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items path_match")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePathMatcher) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PathMatcher)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PathMatcher got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["path_match"]; exists {
		vOpts := append(opts, db.WithValidateField("path_match"))
		if err := fv(ctx, m.GetPathMatch(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPathMatcherValidator = func() *ValidatePathMatcher {
	v := &ValidatePathMatcher{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPathMatch := v.PathMatchValidationRuleHandler
	rulesPathMatch := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.repeated.unique":  "true",
	}
	vFn, err = vrhPathMatch(rulesPathMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathMatcher.path_match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path_match"] = vFn

	return v
}()

func PathMatcherValidator() db.Validator {
	return DefaultPathMatcherValidator
}

// augmented methods on protoc/std generated struct

func (m *PathMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PathMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PathMatcherType) DeepCopy() *PathMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PathMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PathMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PathMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PathMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePathMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePathMatcherType) MatchTypeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match_type_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePathMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PathMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PathMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["match_type_choice"]; exists {
		val := m.GetMatchTypeChoice()
		vOpts := append(opts,
			db.WithValidateField("match_type_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMatchTypeChoice().(type) {
	case *PathMatcherType_ExactValue:
		if fv, exists := v.FldValidators["match_type_choice.exact_value"]; exists {
			val := m.GetMatchTypeChoice().(*PathMatcherType_ExactValue).ExactValue
			vOpts := append(opts,
				db.WithValidateField("match_type_choice"),
				db.WithValidateField("exact_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PathMatcherType_ContainValue:
		if fv, exists := v.FldValidators["match_type_choice.contain_value"]; exists {
			val := m.GetMatchTypeChoice().(*PathMatcherType_ContainValue).ContainValue
			vOpts := append(opts,
				db.WithValidateField("match_type_choice"),
				db.WithValidateField("contain_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PathMatcherType_StartWithValue:
		if fv, exists := v.FldValidators["match_type_choice.start_with_value"]; exists {
			val := m.GetMatchTypeChoice().(*PathMatcherType_StartWithValue).StartWithValue
			vOpts := append(opts,
				db.WithValidateField("match_type_choice"),
				db.WithValidateField("start_with_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PathMatcherType_EndWithValue:
		if fv, exists := v.FldValidators["match_type_choice.end_with_value"]; exists {
			val := m.GetMatchTypeChoice().(*PathMatcherType_EndWithValue).EndWithValue
			vOpts := append(opts,
				db.WithValidateField("match_type_choice"),
				db.WithValidateField("end_with_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPathMatcherTypeValidator = func() *ValidatePathMatcherType {
	v := &ValidatePathMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatchTypeChoice := v.MatchTypeChoiceValidationRuleHandler
	rulesMatchTypeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMatchTypeChoice(rulesMatchTypeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathMatcherType.match_type_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match_type_choice"] = vFn

	v.FldValidators["match_type_choice.exact_value"] = PathMatcherValueValidator().Validate
	v.FldValidators["match_type_choice.contain_value"] = PathMatcherValueValidator().Validate
	v.FldValidators["match_type_choice.start_with_value"] = PathMatcherValueValidator().Validate
	v.FldValidators["match_type_choice.end_with_value"] = PathMatcherValueValidator().Validate

	return v
}()

func PathMatcherTypeValidator() db.Validator {
	return DefaultPathMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PathMatcherValue) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PathMatcherValue) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PathMatcherValue) DeepCopy() *PathMatcherValue {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PathMatcherValue{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PathMatcherValue) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PathMatcherValue) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PathMatcherValueValidator().Validate(ctx, m, opts...)
}

type ValidatePathMatcherValue struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePathMatcherValue) ValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for value")
	}

	return validatorFn, nil
}

func (v *ValidatePathMatcherValue) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PathMatcherValue)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PathMatcherValue got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["case_insensitive"]; exists {

		vOpts := append(opts, db.WithValidateField("case_insensitive"))
		if err := fv(ctx, m.GetCaseInsensitive(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not"]; exists {

		vOpts := append(opts, db.WithValidateField("not"))
		if err := fv(ctx, m.GetNot(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPathMatcherValueValidator = func() *ValidatePathMatcherValue {
	v := &ValidatePathMatcherValue{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhValue := v.ValueValidationRuleHandler
	rulesValue := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "2048",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhValue(rulesValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathMatcherValue.value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["value"] = vFn

	return v
}()

func PathMatcherValueValidator() db.Validator {
	return DefaultPathMatcherValueValidator
}

// augmented methods on protoc/std generated struct

func (m *PathOperator) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PathOperator) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PathOperator) DeepCopy() *PathOperator {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PathOperator{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PathOperator) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PathOperator) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PathOperatorValidator().Validate(ctx, m, opts...)
}

type ValidatePathOperator struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePathOperator) PathOperatorChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path_operator_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePathOperator) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PathOperator)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PathOperator got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["path_operator_choice"]; exists {
		val := m.GetPathOperatorChoice()
		vOpts := append(opts,
			db.WithValidateField("path_operator_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPathOperatorChoice().(type) {
	case *PathOperator_AllPath:
		if fv, exists := v.FldValidators["path_operator_choice.all_path"]; exists {
			val := m.GetPathOperatorChoice().(*PathOperator_AllPath).AllPath
			vOpts := append(opts,
				db.WithValidateField("path_operator_choice"),
				db.WithValidateField("all_path"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PathOperator_PathOr:
		if fv, exists := v.FldValidators["path_operator_choice.path_or"]; exists {
			val := m.GetPathOperatorChoice().(*PathOperator_PathOr).PathOr
			vOpts := append(opts,
				db.WithValidateField("path_operator_choice"),
				db.WithValidateField("path_or"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PathOperator_PathAnd:
		if fv, exists := v.FldValidators["path_operator_choice.path_and"]; exists {
			val := m.GetPathOperatorChoice().(*PathOperator_PathAnd).PathAnd
			vOpts := append(opts,
				db.WithValidateField("path_operator_choice"),
				db.WithValidateField("path_and"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PathOperator_PathNone:
		if fv, exists := v.FldValidators["path_operator_choice.path_none"]; exists {
			val := m.GetPathOperatorChoice().(*PathOperator_PathNone).PathNone
			vOpts := append(opts,
				db.WithValidateField("path_operator_choice"),
				db.WithValidateField("path_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPathOperatorValidator = func() *ValidatePathOperator {
	v := &ValidatePathOperator{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPathOperatorChoice := v.PathOperatorChoiceValidationRuleHandler
	rulesPathOperatorChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPathOperatorChoice(rulesPathOperatorChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathOperator.path_operator_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path_operator_choice"] = vFn

	v.FldValidators["path_operator_choice.path_or"] = PathMatcherValidator().Validate
	v.FldValidators["path_operator_choice.path_and"] = PathMatcherValidator().Validate
	v.FldValidators["path_operator_choice.path_none"] = PathMatcherValidator().Validate

	return v
}()

func PathOperatorValidator() db.Validator {
	return DefaultPathOperatorValidator
}

// augmented methods on protoc/std generated struct

func (m *PolicyVersion) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PolicyVersion) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PolicyVersion) DeepCopy() *PolicyVersion {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PolicyVersion{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PolicyVersion) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PolicyVersion) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PolicyVersionValidator().Validate(ctx, m, opts...)
}

type ValidatePolicyVersion struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePolicyVersion) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PolicyVersion)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PolicyVersion got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["bot_infras_name"]; exists {

		vOpts := append(opts, db.WithValidateField("bot_infras_name"))
		for idx, item := range m.GetBotInfrasName() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["update_time"]; exists {

		vOpts := append(opts, db.WithValidateField("update_time"))
		if err := fv(ctx, m.GetUpdateTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["update_user"]; exists {

		vOpts := append(opts, db.WithValidateField("update_user"))
		if err := fv(ctx, m.GetUpdateUser(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version_number"]; exists {

		vOpts := append(opts, db.WithValidateField("version_number"))
		if err := fv(ctx, m.GetVersionNumber(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version_status"]; exists {

		vOpts := append(opts, db.WithValidateField("version_status"))
		if err := fv(ctx, m.GetVersionStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPolicyVersionValidator = func() *ValidatePolicyVersion {
	v := &ValidatePolicyVersion{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PolicyVersionValidator() db.Validator {
	return DefaultPolicyVersionValidator
}

// augmented methods on protoc/std generated struct

func (m *ProtectedEndpoints) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ProtectedEndpoints) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ProtectedEndpoints) DeepCopy() *ProtectedEndpoints {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ProtectedEndpoints{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ProtectedEndpoints) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ProtectedEndpoints) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ProtectedEndpointsValidator().Validate(ctx, m, opts...)
}

type ValidateProtectedEndpoints struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateProtectedEndpoints) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ProtectedEndpoints)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ProtectedEndpoints got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetEndpointTypeChoice().(type) {
	case *ProtectedEndpoints_ProtectedMobileEndpoints:
		if fv, exists := v.FldValidators["endpoint_type_choice.protected_mobile_endpoints"]; exists {
			val := m.GetEndpointTypeChoice().(*ProtectedEndpoints_ProtectedMobileEndpoints).ProtectedMobileEndpoints
			vOpts := append(opts,
				db.WithValidateField("endpoint_type_choice"),
				db.WithValidateField("protected_mobile_endpoints"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProtectedEndpoints_ProtectedWebEndpoints:
		if fv, exists := v.FldValidators["endpoint_type_choice.protected_web_endpoints"]; exists {
			val := m.GetEndpointTypeChoice().(*ProtectedEndpoints_ProtectedWebEndpoints).ProtectedWebEndpoints
			vOpts := append(opts,
				db.WithValidateField("endpoint_type_choice"),
				db.WithValidateField("protected_web_endpoints"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["js_download_path"]; exists {

		vOpts := append(opts, db.WithValidateField("js_download_path"))
		if err := fv(ctx, m.GetJsDownloadPath(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultProtectedEndpointsValidator = func() *ValidateProtectedEndpoints {
	v := &ValidateProtectedEndpoints{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["endpoint_type_choice.protected_mobile_endpoints"] = ProtectedMobileEndpointListValidator().Validate
	v.FldValidators["endpoint_type_choice.protected_web_endpoints"] = ProtectedWebEndpointListValidator().Validate

	return v
}()

func ProtectedEndpointsValidator() db.Validator {
	return DefaultProtectedEndpointsValidator
}

// augmented methods on protoc/std generated struct

func (m *ProtectedMobileEndpoint) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ProtectedMobileEndpoint) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ProtectedMobileEndpoint) DeepCopy() *ProtectedMobileEndpoint {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ProtectedMobileEndpoint{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ProtectedMobileEndpoint) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ProtectedMobileEndpoint) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ProtectedMobileEndpointValidator().Validate(ctx, m, opts...)
}

type ValidateProtectedMobileEndpoint struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateProtectedMobileEndpoint) MobileClientActionTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mobile_client_action_type")
	}
	return validatorFn, nil
}

func (v *ValidateProtectedMobileEndpoint) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateProtectedMobileEndpoint) FlowLabelChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for flow_label_choice")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.BotPolicyFlowLabelCategoriesChoiceTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateProtectedMobileEndpoint) HttpMethodsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.BotPolicyHttpMethod)
		return int32(i)
	}
	// ves_io_schema.BotPolicyHttpMethod_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema.BotPolicyHttpMethod_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for http_methods")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema.BotPolicyHttpMethod, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for http_methods")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema.BotPolicyHttpMethod)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema.BotPolicyHttpMethod, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated http_methods")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items http_methods")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateProtectedMobileEndpoint) UsernamesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for usernames")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*UserNameType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := UserNameTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for usernames")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*UserNameType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*UserNameType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated usernames")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items usernames")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateProtectedMobileEndpoint) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ProtectedMobileEndpoint)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ProtectedMobileEndpoint got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain"]; exists {

		vOpts := append(opts, db.WithValidateField("domain"))
		if err := fv(ctx, m.GetDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["flow_label_choice"]; exists {

		vOpts := append(opts, db.WithValidateField("flow_label_choice"))
		if err := fv(ctx, m.GetFlowLabelChoice(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header"]; exists {

		vOpts := append(opts, db.WithValidateField("header"))
		for idx, item := range m.GetHeader() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["http_methods"]; exists {
		vOpts := append(opts, db.WithValidateField("http_methods"))
		if err := fv(ctx, m.GetHttpMethods(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mobile_client_action_type"]; exists {
		val := m.GetMobileClientActionType()
		vOpts := append(opts,
			db.WithValidateField("mobile_client_action_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMobileClientActionType().(type) {
	case *ProtectedMobileEndpoint_Continue:
		if fv, exists := v.FldValidators["mobile_client_action_type.continue"]; exists {
			val := m.GetMobileClientActionType().(*ProtectedMobileEndpoint_Continue).Continue
			vOpts := append(opts,
				db.WithValidateField("mobile_client_action_type"),
				db.WithValidateField("continue"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProtectedMobileEndpoint_Transform:
		if fv, exists := v.FldValidators["mobile_client_action_type.transform"]; exists {
			val := m.GetMobileClientActionType().(*ProtectedMobileEndpoint_Transform).Transform
			vOpts := append(opts,
				db.WithValidateField("mobile_client_action_type"),
				db.WithValidateField("transform"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProtectedMobileEndpoint_Block:
		if fv, exists := v.FldValidators["mobile_client_action_type.block"]; exists {
			val := m.GetMobileClientActionType().(*ProtectedMobileEndpoint_Block).Block
			vOpts := append(opts,
				db.WithValidateField("mobile_client_action_type"),
				db.WithValidateField("block"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_body"]; exists {

		vOpts := append(opts, db.WithValidateField("request_body"))
		if err := fv(ctx, m.GetRequestBody(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["transaction_result_criteria"]; exists {

		vOpts := append(opts, db.WithValidateField("transaction_result_criteria"))
		if err := fv(ctx, m.GetTransactionResultCriteria(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["usernames"]; exists {
		vOpts := append(opts, db.WithValidateField("usernames"))
		if err := fv(ctx, m.GetUsernames(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultProtectedMobileEndpointValidator = func() *ValidateProtectedMobileEndpoint {
	v := &ValidateProtectedMobileEndpoint{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMobileClientActionType := v.MobileClientActionTypeValidationRuleHandler
	rulesMobileClientActionType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMobileClientActionType(rulesMobileClientActionType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedMobileEndpoint.mobile_client_action_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mobile_client_action_type"] = vFn

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedMobileEndpoint.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	vrhFlowLabelChoice := v.FlowLabelChoiceValidationRuleHandler
	rulesFlowLabelChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhFlowLabelChoice(rulesFlowLabelChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedMobileEndpoint.flow_label_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["flow_label_choice"] = vFn

	vrhHttpMethods := v.HttpMethodsValidationRuleHandler
	rulesHttpMethods := map[string]string{
		"ves.io.schema.rules.message.required":                 "true",
		"ves.io.schema.rules.repeated.items.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.max_items":               "9",
		"ves.io.schema.rules.repeated.min_items":               "1",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhHttpMethods(rulesHttpMethods)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedMobileEndpoint.http_methods: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_methods"] = vFn

	vrhUsernames := v.UsernamesValidationRuleHandler
	rulesUsernames := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhUsernames(rulesUsernames)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedMobileEndpoint.usernames: %s", err)
		panic(errMsg)
	}
	v.FldValidators["usernames"] = vFn

	v.FldValidators["mobile_client_action_type.continue"] = WebClientContinueMitigationActionTypeValidator().Validate
	v.FldValidators["mobile_client_action_type.transform"] = WebClientTransformMitigationActionChoiceTypeValidator().Validate
	v.FldValidators["mobile_client_action_type.block"] = WebClientBlockMitigationActionTypeValidator().Validate

	v.FldValidators["path"] = PathOperatorValidator().Validate

	v.FldValidators["query"] = QueryOperatorValidator().Validate

	v.FldValidators["request_body"] = RequestBodyOperatorValidator().Validate

	v.FldValidators["domain"] = DomainOperatorValidator().Validate

	v.FldValidators["header"] = HeaderOperatorValidator().Validate

	v.FldValidators["transaction_result_criteria"] = TransactionResultValidator().Validate

	return v
}()

func ProtectedMobileEndpointValidator() db.Validator {
	return DefaultProtectedMobileEndpointValidator
}

// augmented methods on protoc/std generated struct

func (m *ProtectedMobileEndpointList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ProtectedMobileEndpointList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ProtectedMobileEndpointList) DeepCopy() *ProtectedMobileEndpointList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ProtectedMobileEndpointList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ProtectedMobileEndpointList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ProtectedMobileEndpointList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ProtectedMobileEndpointListValidator().Validate(ctx, m, opts...)
}

type ValidateProtectedMobileEndpointList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateProtectedMobileEndpointList) ProtectedMobileEndpointsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for protected_mobile_endpoints")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ProtectedMobileEndpoint, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ProtectedMobileEndpointValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for protected_mobile_endpoints")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ProtectedMobileEndpoint)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ProtectedMobileEndpoint, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated protected_mobile_endpoints")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items protected_mobile_endpoints")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateProtectedMobileEndpointList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ProtectedMobileEndpointList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ProtectedMobileEndpointList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["protected_mobile_endpoints"]; exists {
		vOpts := append(opts, db.WithValidateField("protected_mobile_endpoints"))
		if err := fv(ctx, m.GetProtectedMobileEndpoints(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultProtectedMobileEndpointListValidator = func() *ValidateProtectedMobileEndpointList {
	v := &ValidateProtectedMobileEndpointList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhProtectedMobileEndpoints := v.ProtectedMobileEndpointsValidationRuleHandler
	rulesProtectedMobileEndpoints := map[string]string{
		"ves.io.schema.rules.repeated.unique":               "true",
		"ves.io.schema.rules.repeated.unique_metadata_name": "true",
	}
	vFn, err = vrhProtectedMobileEndpoints(rulesProtectedMobileEndpoints)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedMobileEndpointList.protected_mobile_endpoints: %s", err)
		panic(errMsg)
	}
	v.FldValidators["protected_mobile_endpoints"] = vFn

	return v
}()

func ProtectedMobileEndpointListValidator() db.Validator {
	return DefaultProtectedMobileEndpointListValidator
}

// augmented methods on protoc/std generated struct

func (m *ProtectedWebEndpoint) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ProtectedWebEndpoint) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ProtectedWebEndpoint) DeepCopy() *ProtectedWebEndpoint {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ProtectedWebEndpoint{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ProtectedWebEndpoint) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ProtectedWebEndpoint) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ProtectedWebEndpointValidator().Validate(ctx, m, opts...)
}

type ValidateProtectedWebEndpoint struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateProtectedWebEndpoint) WebClientActionTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for web_client_action_type")
	}
	return validatorFn, nil
}

func (v *ValidateProtectedWebEndpoint) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateProtectedWebEndpoint) HttpMethodsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.BotPolicyHttpMethod)
		return int32(i)
	}
	// ves_io_schema.BotPolicyHttpMethod_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema.BotPolicyHttpMethod_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for http_methods")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema.BotPolicyHttpMethod, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for http_methods")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema.BotPolicyHttpMethod)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema.BotPolicyHttpMethod, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated http_methods")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items http_methods")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateProtectedWebEndpoint) UsernamesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for usernames")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*UserNameType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := UserNameTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for usernames")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*UserNameType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*UserNameType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated usernames")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items usernames")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateProtectedWebEndpoint) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ProtectedWebEndpoint)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ProtectedWebEndpoint got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain"]; exists {

		vOpts := append(opts, db.WithValidateField("domain"))
		if err := fv(ctx, m.GetDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["flow_label_choice"]; exists {

		vOpts := append(opts, db.WithValidateField("flow_label_choice"))
		if err := fv(ctx, m.GetFlowLabelChoice(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header"]; exists {

		vOpts := append(opts, db.WithValidateField("header"))
		for idx, item := range m.GetHeader() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["http_methods"]; exists {
		vOpts := append(opts, db.WithValidateField("http_methods"))
		if err := fv(ctx, m.GetHttpMethods(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_body"]; exists {

		vOpts := append(opts, db.WithValidateField("request_body"))
		if err := fv(ctx, m.GetRequestBody(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["transaction_result_criteria"]; exists {

		vOpts := append(opts, db.WithValidateField("transaction_result_criteria"))
		if err := fv(ctx, m.GetTransactionResultCriteria(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["usernames"]; exists {
		vOpts := append(opts, db.WithValidateField("usernames"))
		if err := fv(ctx, m.GetUsernames(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["web_client_action_type"]; exists {
		val := m.GetWebClientActionType()
		vOpts := append(opts,
			db.WithValidateField("web_client_action_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetWebClientActionType().(type) {
	case *ProtectedWebEndpoint_Continue:
		if fv, exists := v.FldValidators["web_client_action_type.continue"]; exists {
			val := m.GetWebClientActionType().(*ProtectedWebEndpoint_Continue).Continue
			vOpts := append(opts,
				db.WithValidateField("web_client_action_type"),
				db.WithValidateField("continue"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProtectedWebEndpoint_Block:
		if fv, exists := v.FldValidators["web_client_action_type.block"]; exists {
			val := m.GetWebClientActionType().(*ProtectedWebEndpoint_Block).Block
			vOpts := append(opts,
				db.WithValidateField("web_client_action_type"),
				db.WithValidateField("block"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProtectedWebEndpoint_Redirect:
		if fv, exists := v.FldValidators["web_client_action_type.redirect"]; exists {
			val := m.GetWebClientActionType().(*ProtectedWebEndpoint_Redirect).Redirect
			vOpts := append(opts,
				db.WithValidateField("web_client_action_type"),
				db.WithValidateField("redirect"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProtectedWebEndpoint_Transform:
		if fv, exists := v.FldValidators["web_client_action_type.transform"]; exists {
			val := m.GetWebClientActionType().(*ProtectedWebEndpoint_Transform).Transform
			vOpts := append(opts,
				db.WithValidateField("web_client_action_type"),
				db.WithValidateField("transform"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultProtectedWebEndpointValidator = func() *ValidateProtectedWebEndpoint {
	v := &ValidateProtectedWebEndpoint{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhWebClientActionType := v.WebClientActionTypeValidationRuleHandler
	rulesWebClientActionType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhWebClientActionType(rulesWebClientActionType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedWebEndpoint.web_client_action_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["web_client_action_type"] = vFn

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedWebEndpoint.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	vrhHttpMethods := v.HttpMethodsValidationRuleHandler
	rulesHttpMethods := map[string]string{
		"ves.io.schema.rules.message.required":                 "true",
		"ves.io.schema.rules.repeated.items.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.max_items":               "9",
		"ves.io.schema.rules.repeated.min_items":               "1",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhHttpMethods(rulesHttpMethods)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedWebEndpoint.http_methods: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_methods"] = vFn

	vrhUsernames := v.UsernamesValidationRuleHandler
	rulesUsernames := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhUsernames(rulesUsernames)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedWebEndpoint.usernames: %s", err)
		panic(errMsg)
	}
	v.FldValidators["usernames"] = vFn

	v.FldValidators["web_client_action_type.continue"] = WebClientContinueMitigationActionTypeValidator().Validate
	v.FldValidators["web_client_action_type.block"] = WebClientBlockMitigationActionTypeValidator().Validate
	v.FldValidators["web_client_action_type.redirect"] = WebClientRedirectMitigationActionTypeValidator().Validate
	v.FldValidators["web_client_action_type.transform"] = WebClientTransformMitigationActionChoiceTypeValidator().Validate

	v.FldValidators["path"] = PathOperatorValidator().Validate

	v.FldValidators["query"] = QueryOperatorValidator().Validate

	v.FldValidators["request_body"] = RequestBodyOperatorValidator().Validate

	v.FldValidators["flow_label_choice"] = ves_io_schema.BotPolicyFlowLabelCategoriesChoiceTypeValidator().Validate

	v.FldValidators["domain"] = DomainOperatorValidator().Validate

	v.FldValidators["header"] = HeaderOperatorValidator().Validate

	v.FldValidators["transaction_result_criteria"] = TransactionResultValidator().Validate

	return v
}()

func ProtectedWebEndpointValidator() db.Validator {
	return DefaultProtectedWebEndpointValidator
}

// augmented methods on protoc/std generated struct

func (m *ProtectedWebEndpointList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ProtectedWebEndpointList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ProtectedWebEndpointList) DeepCopy() *ProtectedWebEndpointList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ProtectedWebEndpointList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ProtectedWebEndpointList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ProtectedWebEndpointList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ProtectedWebEndpointListValidator().Validate(ctx, m, opts...)
}

type ValidateProtectedWebEndpointList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateProtectedWebEndpointList) ProtectedWebEndpointsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for protected_web_endpoints")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ProtectedWebEndpoint, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ProtectedWebEndpointValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for protected_web_endpoints")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ProtectedWebEndpoint)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ProtectedWebEndpoint, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated protected_web_endpoints")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items protected_web_endpoints")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateProtectedWebEndpointList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ProtectedWebEndpointList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ProtectedWebEndpointList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["protected_web_endpoints"]; exists {
		vOpts := append(opts, db.WithValidateField("protected_web_endpoints"))
		if err := fv(ctx, m.GetProtectedWebEndpoints(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultProtectedWebEndpointListValidator = func() *ValidateProtectedWebEndpointList {
	v := &ValidateProtectedWebEndpointList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhProtectedWebEndpoints := v.ProtectedWebEndpointsValidationRuleHandler
	rulesProtectedWebEndpoints := map[string]string{
		"ves.io.schema.rules.repeated.unique":               "true",
		"ves.io.schema.rules.repeated.unique_metadata_name": "true",
	}
	vFn, err = vrhProtectedWebEndpoints(rulesProtectedWebEndpoints)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedWebEndpointList.protected_web_endpoints: %s", err)
		panic(errMsg)
	}
	v.FldValidators["protected_web_endpoints"] = vFn

	return v
}()

func ProtectedWebEndpointListValidator() db.Validator {
	return DefaultProtectedWebEndpointListValidator
}

// augmented methods on protoc/std generated struct

func (m *QueryMatcher) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *QueryMatcher) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *QueryMatcher) DeepCopy() *QueryMatcher {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &QueryMatcher{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *QueryMatcher) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *QueryMatcher) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return QueryMatcherValidator().Validate(ctx, m, opts...)
}

type ValidateQueryMatcher struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateQueryMatcher) QueryMatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for query_match")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*MatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := MatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for query_match")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*MatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*MatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated query_match")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items query_match")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateQueryMatcher) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*QueryMatcher)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *QueryMatcher got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["query_match"]; exists {
		vOpts := append(opts, db.WithValidateField("query_match"))
		if err := fv(ctx, m.GetQueryMatch(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultQueryMatcherValidator = func() *ValidateQueryMatcher {
	v := &ValidateQueryMatcher{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhQueryMatch := v.QueryMatchValidationRuleHandler
	rulesQueryMatch := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.repeated.unique":  "true",
	}
	vFn, err = vrhQueryMatch(rulesQueryMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for QueryMatcher.query_match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["query_match"] = vFn

	return v
}()

func QueryMatcherValidator() db.Validator {
	return DefaultQueryMatcherValidator
}

// augmented methods on protoc/std generated struct

func (m *QueryOperator) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *QueryOperator) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *QueryOperator) DeepCopy() *QueryOperator {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &QueryOperator{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *QueryOperator) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *QueryOperator) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return QueryOperatorValidator().Validate(ctx, m, opts...)
}

type ValidateQueryOperator struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateQueryOperator) QueryOperatorChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for query_operator_choice")
	}
	return validatorFn, nil
}

func (v *ValidateQueryOperator) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*QueryOperator)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *QueryOperator got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["query_operator_choice"]; exists {
		val := m.GetQueryOperatorChoice()
		vOpts := append(opts,
			db.WithValidateField("query_operator_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetQueryOperatorChoice().(type) {
	case *QueryOperator_AllQuery:
		if fv, exists := v.FldValidators["query_operator_choice.all_query"]; exists {
			val := m.GetQueryOperatorChoice().(*QueryOperator_AllQuery).AllQuery
			vOpts := append(opts,
				db.WithValidateField("query_operator_choice"),
				db.WithValidateField("all_query"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *QueryOperator_QueryOr:
		if fv, exists := v.FldValidators["query_operator_choice.query_or"]; exists {
			val := m.GetQueryOperatorChoice().(*QueryOperator_QueryOr).QueryOr
			vOpts := append(opts,
				db.WithValidateField("query_operator_choice"),
				db.WithValidateField("query_or"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *QueryOperator_QueryAnd:
		if fv, exists := v.FldValidators["query_operator_choice.query_and"]; exists {
			val := m.GetQueryOperatorChoice().(*QueryOperator_QueryAnd).QueryAnd
			vOpts := append(opts,
				db.WithValidateField("query_operator_choice"),
				db.WithValidateField("query_and"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *QueryOperator_QueryNone:
		if fv, exists := v.FldValidators["query_operator_choice.query_none"]; exists {
			val := m.GetQueryOperatorChoice().(*QueryOperator_QueryNone).QueryNone
			vOpts := append(opts,
				db.WithValidateField("query_operator_choice"),
				db.WithValidateField("query_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultQueryOperatorValidator = func() *ValidateQueryOperator {
	v := &ValidateQueryOperator{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhQueryOperatorChoice := v.QueryOperatorChoiceValidationRuleHandler
	rulesQueryOperatorChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhQueryOperatorChoice(rulesQueryOperatorChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for QueryOperator.query_operator_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["query_operator_choice"] = vFn

	v.FldValidators["query_operator_choice.query_or"] = QueryMatcherValidator().Validate
	v.FldValidators["query_operator_choice.query_and"] = QueryMatcherValidator().Validate
	v.FldValidators["query_operator_choice.query_none"] = QueryMatcherValidator().Validate

	return v
}()

func QueryOperatorValidator() db.Validator {
	return DefaultQueryOperatorValidator
}

// augmented methods on protoc/std generated struct

func (m *RequestBodyMatcher) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RequestBodyMatcher) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RequestBodyMatcher) DeepCopy() *RequestBodyMatcher {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RequestBodyMatcher{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RequestBodyMatcher) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RequestBodyMatcher) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RequestBodyMatcherValidator().Validate(ctx, m, opts...)
}

type ValidateRequestBodyMatcher struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRequestBodyMatcher) RequestBodyMatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for request_body_match")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*MatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := MatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_body_match")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*MatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*MatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_body_match")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_body_match")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRequestBodyMatcher) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RequestBodyMatcher)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RequestBodyMatcher got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["request_body_match"]; exists {
		vOpts := append(opts, db.WithValidateField("request_body_match"))
		if err := fv(ctx, m.GetRequestBodyMatch(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRequestBodyMatcherValidator = func() *ValidateRequestBodyMatcher {
	v := &ValidateRequestBodyMatcher{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRequestBodyMatch := v.RequestBodyMatchValidationRuleHandler
	rulesRequestBodyMatch := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.repeated.unique":  "true",
	}
	vFn, err = vrhRequestBodyMatch(rulesRequestBodyMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestBodyMatcher.request_body_match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_body_match"] = vFn

	return v
}()

func RequestBodyMatcherValidator() db.Validator {
	return DefaultRequestBodyMatcherValidator
}

// augmented methods on protoc/std generated struct

func (m *RequestBodyOperator) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RequestBodyOperator) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RequestBodyOperator) DeepCopy() *RequestBodyOperator {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RequestBodyOperator{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RequestBodyOperator) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RequestBodyOperator) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RequestBodyOperatorValidator().Validate(ctx, m, opts...)
}

type ValidateRequestBodyOperator struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRequestBodyOperator) RequestBodyOperatorChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for request_body_operator_choice")
	}
	return validatorFn, nil
}

func (v *ValidateRequestBodyOperator) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RequestBodyOperator)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RequestBodyOperator got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["request_body_operator_choice"]; exists {
		val := m.GetRequestBodyOperatorChoice()
		vOpts := append(opts,
			db.WithValidateField("request_body_operator_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetRequestBodyOperatorChoice().(type) {
	case *RequestBodyOperator_AllRequestBody:
		if fv, exists := v.FldValidators["request_body_operator_choice.all_request_body"]; exists {
			val := m.GetRequestBodyOperatorChoice().(*RequestBodyOperator_AllRequestBody).AllRequestBody
			vOpts := append(opts,
				db.WithValidateField("request_body_operator_choice"),
				db.WithValidateField("all_request_body"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RequestBodyOperator_RequestBodyOr:
		if fv, exists := v.FldValidators["request_body_operator_choice.request_body_or"]; exists {
			val := m.GetRequestBodyOperatorChoice().(*RequestBodyOperator_RequestBodyOr).RequestBodyOr
			vOpts := append(opts,
				db.WithValidateField("request_body_operator_choice"),
				db.WithValidateField("request_body_or"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RequestBodyOperator_RequestBodyAnd:
		if fv, exists := v.FldValidators["request_body_operator_choice.request_body_and"]; exists {
			val := m.GetRequestBodyOperatorChoice().(*RequestBodyOperator_RequestBodyAnd).RequestBodyAnd
			vOpts := append(opts,
				db.WithValidateField("request_body_operator_choice"),
				db.WithValidateField("request_body_and"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RequestBodyOperator_RequestBodyNone:
		if fv, exists := v.FldValidators["request_body_operator_choice.request_body_none"]; exists {
			val := m.GetRequestBodyOperatorChoice().(*RequestBodyOperator_RequestBodyNone).RequestBodyNone
			vOpts := append(opts,
				db.WithValidateField("request_body_operator_choice"),
				db.WithValidateField("request_body_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRequestBodyOperatorValidator = func() *ValidateRequestBodyOperator {
	v := &ValidateRequestBodyOperator{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRequestBodyOperatorChoice := v.RequestBodyOperatorChoiceValidationRuleHandler
	rulesRequestBodyOperatorChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhRequestBodyOperatorChoice(rulesRequestBodyOperatorChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestBodyOperator.request_body_operator_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_body_operator_choice"] = vFn

	v.FldValidators["request_body_operator_choice.request_body_or"] = RequestBodyMatcherValidator().Validate
	v.FldValidators["request_body_operator_choice.request_body_and"] = RequestBodyMatcherValidator().Validate
	v.FldValidators["request_body_operator_choice.request_body_none"] = RequestBodyMatcherValidator().Validate

	return v
}()

func RequestBodyOperatorValidator() db.Validator {
	return DefaultRequestBodyOperatorValidator
}

// augmented methods on protoc/std generated struct

func (m *ResponseBody) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ResponseBody) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ResponseBody) DeepCopy() *ResponseBody {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ResponseBody{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ResponseBody) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ResponseBody) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ResponseBodyValidator().Validate(ctx, m, opts...)
}

type ValidateResponseBody struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateResponseBody) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ResponseBody)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ResponseBody got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetResponseBodyChoice().(type) {
	case *ResponseBody_ResponseBodyAll:
		if fv, exists := v.FldValidators["ResponseBodyChoice.responseBody_all"]; exists {
			val := m.GetResponseBodyChoice().(*ResponseBody_ResponseBodyAll).ResponseBodyAll
			vOpts := append(opts,
				db.WithValidateField("ResponseBodyChoice"),
				db.WithValidateField("responseBody_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ResponseBody_ResponseBodyOr:
		if fv, exists := v.FldValidators["ResponseBodyChoice.responseBody_or"]; exists {
			val := m.GetResponseBodyChoice().(*ResponseBody_ResponseBodyOr).ResponseBodyOr
			vOpts := append(opts,
				db.WithValidateField("ResponseBodyChoice"),
				db.WithValidateField("responseBody_or"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ResponseBody_ResponseBodyAnd:
		if fv, exists := v.FldValidators["ResponseBodyChoice.responseBody_and"]; exists {
			val := m.GetResponseBodyChoice().(*ResponseBody_ResponseBodyAnd).ResponseBodyAnd
			vOpts := append(opts,
				db.WithValidateField("ResponseBodyChoice"),
				db.WithValidateField("responseBody_and"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ResponseBody_ResponseBodyNone:
		if fv, exists := v.FldValidators["ResponseBodyChoice.responseBody_none"]; exists {
			val := m.GetResponseBodyChoice().(*ResponseBody_ResponseBodyNone).ResponseBodyNone
			vOpts := append(opts,
				db.WithValidateField("ResponseBodyChoice"),
				db.WithValidateField("responseBody_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultResponseBodyValidator = func() *ValidateResponseBody {
	v := &ValidateResponseBody{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["ResponseBodyChoice.responseBody_or"] = ResponseBodyMatcherValidator().Validate
	v.FldValidators["ResponseBodyChoice.responseBody_and"] = ResponseBodyMatcherValidator().Validate
	v.FldValidators["ResponseBodyChoice.responseBody_none"] = ResponseBodyMatcherValidator().Validate

	return v
}()

func ResponseBodyValidator() db.Validator {
	return DefaultResponseBodyValidator
}

// augmented methods on protoc/std generated struct

func (m *ResponseBodyMatcher) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ResponseBodyMatcher) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ResponseBodyMatcher) DeepCopy() *ResponseBodyMatcher {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ResponseBodyMatcher{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ResponseBodyMatcher) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ResponseBodyMatcher) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ResponseBodyMatcherValidator().Validate(ctx, m, opts...)
}

type ValidateResponseBodyMatcher struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateResponseBodyMatcher) ResponseBodyMatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for responseBody_match")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ResponseBodyMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ResponseBodyMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for responseBody_match")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ResponseBodyMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ResponseBodyMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated responseBody_match")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items responseBody_match")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateResponseBodyMatcher) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ResponseBodyMatcher)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ResponseBodyMatcher got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["responseBody_match"]; exists {
		vOpts := append(opts, db.WithValidateField("responseBody_match"))
		if err := fv(ctx, m.GetResponseBodyMatch(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultResponseBodyMatcherValidator = func() *ValidateResponseBodyMatcher {
	v := &ValidateResponseBodyMatcher{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhResponseBodyMatch := v.ResponseBodyMatchValidationRuleHandler
	rulesResponseBodyMatch := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.repeated.unique":  "true",
	}
	vFn, err = vrhResponseBodyMatch(rulesResponseBodyMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ResponseBodyMatcher.responseBody_match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["responseBody_match"] = vFn

	return v
}()

func ResponseBodyMatcherValidator() db.Validator {
	return DefaultResponseBodyMatcherValidator
}

// augmented methods on protoc/std generated struct

func (m *ResponseBodyMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ResponseBodyMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ResponseBodyMatcherType) DeepCopy() *ResponseBodyMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ResponseBodyMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ResponseBodyMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ResponseBodyMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ResponseBodyMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateResponseBodyMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateResponseBodyMatcherType) CompareTypeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for compare_type_choice")
	}
	return validatorFn, nil
}

func (v *ValidateResponseBodyMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ResponseBodyMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ResponseBodyMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["compare_type_choice"]; exists {
		val := m.GetCompareTypeChoice()
		vOpts := append(opts,
			db.WithValidateField("compare_type_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCompareTypeChoice().(type) {
	case *ResponseBodyMatcherType_Equals:
		if fv, exists := v.FldValidators["compare_type_choice.equals"]; exists {
			val := m.GetCompareTypeChoice().(*ResponseBodyMatcherType_Equals).Equals
			vOpts := append(opts,
				db.WithValidateField("compare_type_choice"),
				db.WithValidateField("equals"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ResponseBodyMatcherType_StartsWith:
		if fv, exists := v.FldValidators["compare_type_choice.starts_with"]; exists {
			val := m.GetCompareTypeChoice().(*ResponseBodyMatcherType_StartsWith).StartsWith
			vOpts := append(opts,
				db.WithValidateField("compare_type_choice"),
				db.WithValidateField("starts_with"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ResponseBodyMatcherType_Contains:
		if fv, exists := v.FldValidators["compare_type_choice.contains"]; exists {
			val := m.GetCompareTypeChoice().(*ResponseBodyMatcherType_Contains).Contains
			vOpts := append(opts,
				db.WithValidateField("compare_type_choice"),
				db.WithValidateField("contains"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ResponseBodyMatcherType_EndsWith:
		if fv, exists := v.FldValidators["compare_type_choice.ends_with"]; exists {
			val := m.GetCompareTypeChoice().(*ResponseBodyMatcherType_EndsWith).EndsWith
			vOpts := append(opts,
				db.WithValidateField("compare_type_choice"),
				db.WithValidateField("ends_with"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultResponseBodyMatcherTypeValidator = func() *ValidateResponseBodyMatcherType {
	v := &ValidateResponseBodyMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCompareTypeChoice := v.CompareTypeChoiceValidationRuleHandler
	rulesCompareTypeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCompareTypeChoice(rulesCompareTypeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ResponseBodyMatcherType.compare_type_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["compare_type_choice"] = vFn

	v.FldValidators["compare_type_choice.equals"] = ResponseBodyMatcherValueValidator().Validate
	v.FldValidators["compare_type_choice.starts_with"] = ResponseBodyMatcherValueValidator().Validate
	v.FldValidators["compare_type_choice.contains"] = ResponseBodyMatcherValueValidator().Validate
	v.FldValidators["compare_type_choice.ends_with"] = ResponseBodyMatcherValueValidator().Validate

	return v
}()

func ResponseBodyMatcherTypeValidator() db.Validator {
	return DefaultResponseBodyMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ResponseBodyMatcherValue) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ResponseBodyMatcherValue) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ResponseBodyMatcherValue) DeepCopy() *ResponseBodyMatcherValue {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ResponseBodyMatcherValue{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ResponseBodyMatcherValue) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ResponseBodyMatcherValue) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ResponseBodyMatcherValueValidator().Validate(ctx, m, opts...)
}

type ValidateResponseBodyMatcherValue struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateResponseBodyMatcherValue) ValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for value")
	}

	return validatorFn, nil
}

func (v *ValidateResponseBodyMatcherValue) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ResponseBodyMatcherValue)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ResponseBodyMatcherValue got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["case_sensitive"]; exists {

		vOpts := append(opts, db.WithValidateField("case_sensitive"))
		if err := fv(ctx, m.GetCaseSensitive(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_value"]; exists {

		vOpts := append(opts, db.WithValidateField("not_value"))
		if err := fv(ctx, m.GetNotValue(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultResponseBodyMatcherValueValidator = func() *ValidateResponseBodyMatcherValue {
	v := &ValidateResponseBodyMatcherValue{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhValue := v.ValueValidationRuleHandler
	rulesValue := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhValue(rulesValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ResponseBodyMatcherValue.value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["value"] = vFn

	return v
}()

func ResponseBodyMatcherValueValidator() db.Validator {
	return DefaultResponseBodyMatcherValueValidator
}

// augmented methods on protoc/std generated struct

func (m *ResponseCode) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ResponseCode) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ResponseCode) DeepCopy() *ResponseCode {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ResponseCode{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ResponseCode) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ResponseCode) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ResponseCodeValidator().Validate(ctx, m, opts...)
}

type ValidateResponseCode struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateResponseCode) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ResponseCode)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ResponseCode got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetResponseCodeChoice().(type) {
	case *ResponseCode_ResponseCodeAll:
		if fv, exists := v.FldValidators["ResponseCodeChoice.responseCode_all"]; exists {
			val := m.GetResponseCodeChoice().(*ResponseCode_ResponseCodeAll).ResponseCodeAll
			vOpts := append(opts,
				db.WithValidateField("ResponseCodeChoice"),
				db.WithValidateField("responseCode_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ResponseCode_ResponseCodeOr:
		if fv, exists := v.FldValidators["ResponseCodeChoice.responseCode_or"]; exists {
			val := m.GetResponseCodeChoice().(*ResponseCode_ResponseCodeOr).ResponseCodeOr
			vOpts := append(opts,
				db.WithValidateField("ResponseCodeChoice"),
				db.WithValidateField("responseCode_or"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ResponseCode_ResponseCodeAnd:
		if fv, exists := v.FldValidators["ResponseCodeChoice.responseCode_and"]; exists {
			val := m.GetResponseCodeChoice().(*ResponseCode_ResponseCodeAnd).ResponseCodeAnd
			vOpts := append(opts,
				db.WithValidateField("ResponseCodeChoice"),
				db.WithValidateField("responseCode_and"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ResponseCode_ResponseCodeNone:
		if fv, exists := v.FldValidators["ResponseCodeChoice.responseCode_none"]; exists {
			val := m.GetResponseCodeChoice().(*ResponseCode_ResponseCodeNone).ResponseCodeNone
			vOpts := append(opts,
				db.WithValidateField("ResponseCodeChoice"),
				db.WithValidateField("responseCode_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultResponseCodeValidator = func() *ValidateResponseCode {
	v := &ValidateResponseCode{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["ResponseCodeChoice.responseCode_or"] = ResponseCodeMatcherValidator().Validate
	v.FldValidators["ResponseCodeChoice.responseCode_and"] = ResponseCodeMatcherValidator().Validate
	v.FldValidators["ResponseCodeChoice.responseCode_none"] = ResponseCodeMatcherValidator().Validate

	return v
}()

func ResponseCodeValidator() db.Validator {
	return DefaultResponseCodeValidator
}

// augmented methods on protoc/std generated struct

func (m *ResponseCodeMatcher) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ResponseCodeMatcher) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ResponseCodeMatcher) DeepCopy() *ResponseCodeMatcher {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ResponseCodeMatcher{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ResponseCodeMatcher) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ResponseCodeMatcher) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ResponseCodeMatcherValidator().Validate(ctx, m, opts...)
}

type ValidateResponseCodeMatcher struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateResponseCodeMatcher) ResponseCodeMatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for responseCode_match")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ResponseCodeMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ResponseCodeMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for responseCode_match")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ResponseCodeMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ResponseCodeMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated responseCode_match")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items responseCode_match")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateResponseCodeMatcher) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ResponseCodeMatcher)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ResponseCodeMatcher got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["responseCode_match"]; exists {
		vOpts := append(opts, db.WithValidateField("responseCode_match"))
		if err := fv(ctx, m.GetResponseCodeMatch(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultResponseCodeMatcherValidator = func() *ValidateResponseCodeMatcher {
	v := &ValidateResponseCodeMatcher{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhResponseCodeMatch := v.ResponseCodeMatchValidationRuleHandler
	rulesResponseCodeMatch := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.repeated.unique":  "true",
	}
	vFn, err = vrhResponseCodeMatch(rulesResponseCodeMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ResponseCodeMatcher.responseCode_match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["responseCode_match"] = vFn

	return v
}()

func ResponseCodeMatcherValidator() db.Validator {
	return DefaultResponseCodeMatcherValidator
}

// augmented methods on protoc/std generated struct

func (m *ResponseCodeMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ResponseCodeMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ResponseCodeMatcherType) DeepCopy() *ResponseCodeMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ResponseCodeMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ResponseCodeMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ResponseCodeMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ResponseCodeMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateResponseCodeMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateResponseCodeMatcherType) OperatorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ResponseCodeOperator)
		return int32(i)
	}
	// ResponseCodeOperator_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ResponseCodeOperator_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operator")
	}

	return validatorFn, nil
}

func (v *ValidateResponseCodeMatcherType) ValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for value")
	}

	return validatorFn, nil
}

func (v *ValidateResponseCodeMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ResponseCodeMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ResponseCodeMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["operator"]; exists {

		vOpts := append(opts, db.WithValidateField("operator"))
		if err := fv(ctx, m.GetOperator(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultResponseCodeMatcherTypeValidator = func() *ValidateResponseCodeMatcherType {
	v := &ValidateResponseCodeMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOperator := v.OperatorValidationRuleHandler
	rulesOperator := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOperator(rulesOperator)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ResponseCodeMatcherType.operator: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operator"] = vFn

	vrhValue := v.ValueValidationRuleHandler
	rulesValue := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "0",
	}
	vFn, err = vrhValue(rulesValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ResponseCodeMatcherType.value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["value"] = vFn

	return v
}()

func ResponseCodeMatcherTypeValidator() db.Validator {
	return DefaultResponseCodeMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ResponseHeader) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ResponseHeader) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ResponseHeader) DeepCopy() *ResponseHeader {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ResponseHeader{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ResponseHeader) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ResponseHeader) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ResponseHeaderValidator().Validate(ctx, m, opts...)
}

type ValidateResponseHeader struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateResponseHeader) HeaderOperatorChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for header_operator_choice")
	}
	return validatorFn, nil
}

func (v *ValidateResponseHeader) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateResponseHeader) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ResponseHeader)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ResponseHeader got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["header_operator_choice"]; exists {
		val := m.GetHeaderOperatorChoice()
		vOpts := append(opts,
			db.WithValidateField("header_operator_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetHeaderOperatorChoice().(type) {
	case *ResponseHeader_HeaderAll:
		if fv, exists := v.FldValidators["header_operator_choice.header_all"]; exists {
			val := m.GetHeaderOperatorChoice().(*ResponseHeader_HeaderAll).HeaderAll
			vOpts := append(opts,
				db.WithValidateField("header_operator_choice"),
				db.WithValidateField("header_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ResponseHeader_HeaderOr:
		if fv, exists := v.FldValidators["header_operator_choice.header_or"]; exists {
			val := m.GetHeaderOperatorChoice().(*ResponseHeader_HeaderOr).HeaderOr
			vOpts := append(opts,
				db.WithValidateField("header_operator_choice"),
				db.WithValidateField("header_or"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ResponseHeader_HeaderAnd:
		if fv, exists := v.FldValidators["header_operator_choice.header_and"]; exists {
			val := m.GetHeaderOperatorChoice().(*ResponseHeader_HeaderAnd).HeaderAnd
			vOpts := append(opts,
				db.WithValidateField("header_operator_choice"),
				db.WithValidateField("header_and"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ResponseHeader_HeaderNone:
		if fv, exists := v.FldValidators["header_operator_choice.header_none"]; exists {
			val := m.GetHeaderOperatorChoice().(*ResponseHeader_HeaderNone).HeaderNone
			vOpts := append(opts,
				db.WithValidateField("header_operator_choice"),
				db.WithValidateField("header_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ResponseHeader_NotPresentHeader:
		if fv, exists := v.FldValidators["header_operator_choice.not_present_header"]; exists {
			val := m.GetHeaderOperatorChoice().(*ResponseHeader_NotPresentHeader).NotPresentHeader
			vOpts := append(opts,
				db.WithValidateField("header_operator_choice"),
				db.WithValidateField("not_present_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultResponseHeaderValidator = func() *ValidateResponseHeader {
	v := &ValidateResponseHeader{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHeaderOperatorChoice := v.HeaderOperatorChoiceValidationRuleHandler
	rulesHeaderOperatorChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhHeaderOperatorChoice(rulesHeaderOperatorChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ResponseHeader.header_operator_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["header_operator_choice"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ResponseHeader.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["header_operator_choice.header_or"] = ResponseHeaderMatcherValidator().Validate
	v.FldValidators["header_operator_choice.header_and"] = ResponseHeaderMatcherValidator().Validate
	v.FldValidators["header_operator_choice.header_none"] = ResponseHeaderMatcherValidator().Validate

	return v
}()

func ResponseHeaderValidator() db.Validator {
	return DefaultResponseHeaderValidator
}

// augmented methods on protoc/std generated struct

func (m *ResponseHeaderMatcher) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ResponseHeaderMatcher) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ResponseHeaderMatcher) DeepCopy() *ResponseHeaderMatcher {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ResponseHeaderMatcher{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ResponseHeaderMatcher) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ResponseHeaderMatcher) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ResponseHeaderMatcherValidator().Validate(ctx, m, opts...)
}

type ValidateResponseHeaderMatcher struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateResponseHeaderMatcher) ResponseHeaderMatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for responseHeader_match")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ResponseHeaderMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ResponseHeaderMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for responseHeader_match")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ResponseHeaderMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ResponseHeaderMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated responseHeader_match")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items responseHeader_match")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateResponseHeaderMatcher) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ResponseHeaderMatcher)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ResponseHeaderMatcher got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["responseHeader_match"]; exists {
		vOpts := append(opts, db.WithValidateField("responseHeader_match"))
		if err := fv(ctx, m.GetResponseHeaderMatch(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultResponseHeaderMatcherValidator = func() *ValidateResponseHeaderMatcher {
	v := &ValidateResponseHeaderMatcher{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhResponseHeaderMatch := v.ResponseHeaderMatchValidationRuleHandler
	rulesResponseHeaderMatch := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.repeated.unique":  "true",
	}
	vFn, err = vrhResponseHeaderMatch(rulesResponseHeaderMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ResponseHeaderMatcher.responseHeader_match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["responseHeader_match"] = vFn

	return v
}()

func ResponseHeaderMatcherValidator() db.Validator {
	return DefaultResponseHeaderMatcherValidator
}

// augmented methods on protoc/std generated struct

func (m *ResponseHeaderMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ResponseHeaderMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ResponseHeaderMatcherType) DeepCopy() *ResponseHeaderMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ResponseHeaderMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ResponseHeaderMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ResponseHeaderMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ResponseHeaderMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateResponseHeaderMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateResponseHeaderMatcherType) CompareTypeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for compare_type_choice")
	}
	return validatorFn, nil
}

func (v *ValidateResponseHeaderMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ResponseHeaderMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ResponseHeaderMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["compare_type_choice"]; exists {
		val := m.GetCompareTypeChoice()
		vOpts := append(opts,
			db.WithValidateField("compare_type_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCompareTypeChoice().(type) {
	case *ResponseHeaderMatcherType_Equals:
		if fv, exists := v.FldValidators["compare_type_choice.equals"]; exists {
			val := m.GetCompareTypeChoice().(*ResponseHeaderMatcherType_Equals).Equals
			vOpts := append(opts,
				db.WithValidateField("compare_type_choice"),
				db.WithValidateField("equals"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ResponseHeaderMatcherType_StartsWith:
		if fv, exists := v.FldValidators["compare_type_choice.starts_with"]; exists {
			val := m.GetCompareTypeChoice().(*ResponseHeaderMatcherType_StartsWith).StartsWith
			vOpts := append(opts,
				db.WithValidateField("compare_type_choice"),
				db.WithValidateField("starts_with"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ResponseHeaderMatcherType_Contains:
		if fv, exists := v.FldValidators["compare_type_choice.contains"]; exists {
			val := m.GetCompareTypeChoice().(*ResponseHeaderMatcherType_Contains).Contains
			vOpts := append(opts,
				db.WithValidateField("compare_type_choice"),
				db.WithValidateField("contains"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ResponseHeaderMatcherType_EndsWith:
		if fv, exists := v.FldValidators["compare_type_choice.ends_with"]; exists {
			val := m.GetCompareTypeChoice().(*ResponseHeaderMatcherType_EndsWith).EndsWith
			vOpts := append(opts,
				db.WithValidateField("compare_type_choice"),
				db.WithValidateField("ends_with"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultResponseHeaderMatcherTypeValidator = func() *ValidateResponseHeaderMatcherType {
	v := &ValidateResponseHeaderMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCompareTypeChoice := v.CompareTypeChoiceValidationRuleHandler
	rulesCompareTypeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCompareTypeChoice(rulesCompareTypeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ResponseHeaderMatcherType.compare_type_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["compare_type_choice"] = vFn

	v.FldValidators["compare_type_choice.equals"] = ResponseHeaderMatcherValueValidator().Validate
	v.FldValidators["compare_type_choice.starts_with"] = ResponseHeaderMatcherValueValidator().Validate
	v.FldValidators["compare_type_choice.contains"] = ResponseHeaderMatcherValueValidator().Validate
	v.FldValidators["compare_type_choice.ends_with"] = ResponseHeaderMatcherValueValidator().Validate

	return v
}()

func ResponseHeaderMatcherTypeValidator() db.Validator {
	return DefaultResponseHeaderMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ResponseHeaderMatcherValue) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ResponseHeaderMatcherValue) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ResponseHeaderMatcherValue) DeepCopy() *ResponseHeaderMatcherValue {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ResponseHeaderMatcherValue{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ResponseHeaderMatcherValue) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ResponseHeaderMatcherValue) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ResponseHeaderMatcherValueValidator().Validate(ctx, m, opts...)
}

type ValidateResponseHeaderMatcherValue struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateResponseHeaderMatcherValue) ValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for value")
	}

	return validatorFn, nil
}

func (v *ValidateResponseHeaderMatcherValue) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ResponseHeaderMatcherValue)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ResponseHeaderMatcherValue got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["case_sensitive"]; exists {

		vOpts := append(opts, db.WithValidateField("case_sensitive"))
		if err := fv(ctx, m.GetCaseSensitive(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_value"]; exists {

		vOpts := append(opts, db.WithValidateField("not_value"))
		if err := fv(ctx, m.GetNotValue(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultResponseHeaderMatcherValueValidator = func() *ValidateResponseHeaderMatcherValue {
	v := &ValidateResponseHeaderMatcherValue{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhValue := v.ValueValidationRuleHandler
	rulesValue := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhValue(rulesValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ResponseHeaderMatcherValue.value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["value"] = vFn

	return v
}()

func ResponseHeaderMatcherValueValidator() db.Validator {
	return DefaultResponseHeaderMatcherValueValidator
}

// augmented methods on protoc/std generated struct

func (m *TransactionResult) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TransactionResult) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TransactionResult) DeepCopy() *TransactionResult {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TransactionResult{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TransactionResult) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TransactionResult) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TransactionResultValidator().Validate(ctx, m, opts...)
}

type ValidateTransactionResult struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTransactionResult) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TransactionResult)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TransactionResult got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["transaction_result_failure"]; exists {

		vOpts := append(opts, db.WithValidateField("transaction_result_failure"))
		if err := fv(ctx, m.GetTransactionResultFailure(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["transaction_result_success"]; exists {

		vOpts := append(opts, db.WithValidateField("transaction_result_success"))
		if err := fv(ctx, m.GetTransactionResultSuccess(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTransactionResultValidator = func() *ValidateTransactionResult {
	v := &ValidateTransactionResult{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["transaction_result_success"] = TransactionResultTypeValidator().Validate

	v.FldValidators["transaction_result_failure"] = TransactionResultTypeValidator().Validate

	return v
}()

func TransactionResultValidator() db.Validator {
	return DefaultTransactionResultValidator
}

// augmented methods on protoc/std generated struct

func (m *TransactionResultType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TransactionResultType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TransactionResultType) DeepCopy() *TransactionResultType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TransactionResultType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TransactionResultType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TransactionResultType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TransactionResultTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTransactionResultType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTransactionResultType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TransactionResultType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TransactionResultType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cookie"]; exists {

		vOpts := append(opts, db.WithValidateField("cookie"))
		for idx, item := range m.GetCookie() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["responseBody"]; exists {

		vOpts := append(opts, db.WithValidateField("responseBody"))
		if err := fv(ctx, m.GetResponseBody(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["responseCode"]; exists {

		vOpts := append(opts, db.WithValidateField("responseCode"))
		if err := fv(ctx, m.GetResponseCode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["responseHeader"]; exists {

		vOpts := append(opts, db.WithValidateField("responseHeader"))
		for idx, item := range m.GetResponseHeader() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTransactionResultTypeValidator = func() *ValidateTransactionResultType {
	v := &ValidateTransactionResultType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["responseCode"] = ResponseCodeValidator().Validate

	v.FldValidators["responseBody"] = ResponseBodyValidator().Validate

	v.FldValidators["responseHeader"] = ResponseHeaderValidator().Validate

	v.FldValidators["cookie"] = CookieValidator().Validate

	return v
}()

func TransactionResultTypeValidator() db.Validator {
	return DefaultTransactionResultTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *UpstreamRoutingDetail) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpstreamRoutingDetail) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpstreamRoutingDetail) DeepCopy() *UpstreamRoutingDetail {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpstreamRoutingDetail{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpstreamRoutingDetail) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpstreamRoutingDetail) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpstreamRoutingDetailValidator().Validate(ctx, m, opts...)
}

type ValidateUpstreamRoutingDetail struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpstreamRoutingDetail) DomainNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_name")
	}

	return validatorFn, nil
}

func (v *ValidateUpstreamRoutingDetail) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpstreamRoutingDetail)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpstreamRoutingDetail got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain_name"]; exists {

		vOpts := append(opts, db.WithValidateField("domain_name"))
		if err := fv(ctx, m.GetDomainName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpstreamRoutingDetailValidator = func() *ValidateUpstreamRoutingDetail {
	v := &ValidateUpstreamRoutingDetail{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainName := v.DomainNameValidationRuleHandler
	rulesDomainName := map[string]string{
		"ves.io.schema.rules.string.hostname":  "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.not_empty": "true",
	}
	vFn, err = vrhDomainName(rulesDomainName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpstreamRoutingDetail.domain_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_name"] = vFn

	return v
}()

func UpstreamRoutingDetailValidator() db.Validator {
	return DefaultUpstreamRoutingDetailValidator
}

// augmented methods on protoc/std generated struct

func (m *UpstreamRoutings) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpstreamRoutings) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpstreamRoutings) DeepCopy() *UpstreamRoutings {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpstreamRoutings{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpstreamRoutings) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpstreamRoutings) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpstreamRoutingsValidator().Validate(ctx, m, opts...)
}

type ValidateUpstreamRoutings struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpstreamRoutings) UpstreamRoutingValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for upstream_routing")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*UpstreamRoutingDetail, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := UpstreamRoutingDetailValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for upstream_routing")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*UpstreamRoutingDetail)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*UpstreamRoutingDetail, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated upstream_routing")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items upstream_routing")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateUpstreamRoutings) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpstreamRoutings)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpstreamRoutings got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["upstream_routing"]; exists {
		vOpts := append(opts, db.WithValidateField("upstream_routing"))
		if err := fv(ctx, m.GetUpstreamRouting(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpstreamRoutingsValidator = func() *ValidateUpstreamRoutings {
	v := &ValidateUpstreamRoutings{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhUpstreamRouting := v.UpstreamRoutingValidationRuleHandler
	rulesUpstreamRouting := map[string]string{
		"ves.io.schema.rules.repeated.unique": "true",
	}
	vFn, err = vrhUpstreamRouting(rulesUpstreamRouting)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpstreamRoutings.upstream_routing: %s", err)
		panic(errMsg)
	}
	v.FldValidators["upstream_routing"] = vFn

	return v
}()

func UpstreamRoutingsValidator() db.Validator {
	return DefaultUpstreamRoutingsValidator
}

// augmented methods on protoc/std generated struct

func (m *UserNameType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UserNameType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UserNameType) DeepCopy() *UserNameType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UserNameType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UserNameType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UserNameType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UserNameTypeValidator().Validate(ctx, m, opts...)
}

type ValidateUserNameType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUserNameType) UsernameReportingValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for username_reporting")
	}

	return validatorFn, nil
}

func (v *ValidateUserNameType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UserNameType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UserNameType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["username_reporting"]; exists {

		vOpts := append(opts, db.WithValidateField("username_reporting"))
		if err := fv(ctx, m.GetUsernameReporting(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUserNameTypeValidator = func() *ValidateUserNameType {
	v := &ValidateUserNameType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhUsernameReporting := v.UsernameReportingValidationRuleHandler
	rulesUsernameReporting := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhUsernameReporting(rulesUsernameReporting)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UserNameType.username_reporting: %s", err)
		panic(errMsg)
	}
	v.FldValidators["username_reporting"] = vFn

	return v
}()

func UserNameTypeValidator() db.Validator {
	return DefaultUserNameTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *WebClientAddHeaderToRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WebClientAddHeaderToRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WebClientAddHeaderToRequest) DeepCopy() *WebClientAddHeaderToRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WebClientAddHeaderToRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WebClientAddHeaderToRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WebClientAddHeaderToRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WebClientAddHeaderToRequestValidator().Validate(ctx, m, opts...)
}

type ValidateWebClientAddHeaderToRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWebClientAddHeaderToRequest) NameValuePairValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for name_value_pair")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*HeaderNameValuePair, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := HeaderNameValuePairValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for name_value_pair")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*HeaderNameValuePair)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*HeaderNameValuePair, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated name_value_pair")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items name_value_pair")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWebClientAddHeaderToRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WebClientAddHeaderToRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WebClientAddHeaderToRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name_value_pair"]; exists {
		vOpts := append(opts, db.WithValidateField("name_value_pair"))
		if err := fv(ctx, m.GetNameValuePair(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWebClientAddHeaderToRequestValidator = func() *ValidateWebClientAddHeaderToRequest {
	v := &ValidateWebClientAddHeaderToRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNameValuePair := v.NameValuePairValidationRuleHandler
	rulesNameValuePair := map[string]string{
		"ves.io.schema.rules.repeated.unique": "true",
	}
	vFn, err = vrhNameValuePair(rulesNameValuePair)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WebClientAddHeaderToRequest.name_value_pair: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name_value_pair"] = vFn

	return v
}()

func WebClientAddHeaderToRequestValidator() db.Validator {
	return DefaultWebClientAddHeaderToRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *WebClientBlockMitigationActionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WebClientBlockMitigationActionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WebClientBlockMitigationActionType) DeepCopy() *WebClientBlockMitigationActionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WebClientBlockMitigationActionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WebClientBlockMitigationActionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WebClientBlockMitigationActionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WebClientBlockMitigationActionTypeValidator().Validate(ctx, m, opts...)
}

type ValidateWebClientBlockMitigationActionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWebClientBlockMitigationActionType) NameValuePairValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for name_value_pair")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*HeaderNameValuePair, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := HeaderNameValuePairValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for name_value_pair")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*HeaderNameValuePair)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*HeaderNameValuePair, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated name_value_pair")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items name_value_pair")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWebClientBlockMitigationActionType) BodyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for body")
	}

	return validatorFn, nil
}

func (v *ValidateWebClientBlockMitigationActionType) StatusValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(BlockActionHttpStatusCode)
		return int32(i)
	}
	// BlockActionHttpStatusCode_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, BlockActionHttpStatusCode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for status")
	}

	return validatorFn, nil
}

func (v *ValidateWebClientBlockMitigationActionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WebClientBlockMitigationActionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WebClientBlockMitigationActionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["body"]; exists {

		vOpts := append(opts, db.WithValidateField("body"))
		if err := fv(ctx, m.GetBody(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name_value_pair"]; exists {
		vOpts := append(opts, db.WithValidateField("name_value_pair"))
		if err := fv(ctx, m.GetNameValuePair(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWebClientBlockMitigationActionTypeValidator = func() *ValidateWebClientBlockMitigationActionType {
	v := &ValidateWebClientBlockMitigationActionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNameValuePair := v.NameValuePairValidationRuleHandler
	rulesNameValuePair := map[string]string{
		"ves.io.schema.rules.repeated.unique": "true",
	}
	vFn, err = vrhNameValuePair(rulesNameValuePair)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WebClientBlockMitigationActionType.name_value_pair: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name_value_pair"] = vFn

	vrhBody := v.BodyValidationRuleHandler
	rulesBody := map[string]string{
		"ves.io.schema.rules.string.max_len": "4096",
	}
	vFn, err = vrhBody(rulesBody)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WebClientBlockMitigationActionType.body: %s", err)
		panic(errMsg)
	}
	v.FldValidators["body"] = vFn

	vrhStatus := v.StatusValidationRuleHandler
	rulesStatus := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.enum.not_in":       "[0]",
		"ves.io.schema.rules.message.required":  "true",
	}
	vFn, err = vrhStatus(rulesStatus)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WebClientBlockMitigationActionType.status: %s", err)
		panic(errMsg)
	}
	v.FldValidators["status"] = vFn

	return v
}()

func WebClientBlockMitigationActionTypeValidator() db.Validator {
	return DefaultWebClientBlockMitigationActionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *WebClientContinueMitigationActionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WebClientContinueMitigationActionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WebClientContinueMitigationActionType) DeepCopy() *WebClientContinueMitigationActionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WebClientContinueMitigationActionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WebClientContinueMitigationActionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WebClientContinueMitigationActionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WebClientContinueMitigationActionTypeValidator().Validate(ctx, m, opts...)
}

type ValidateWebClientContinueMitigationActionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWebClientContinueMitigationActionType) SendHeadersChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for send_headers_choice")
	}
	return validatorFn, nil
}

func (v *ValidateWebClientContinueMitigationActionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WebClientContinueMitigationActionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WebClientContinueMitigationActionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["send_headers_choice"]; exists {
		val := m.GetSendHeadersChoice()
		vOpts := append(opts,
			db.WithValidateField("send_headers_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSendHeadersChoice().(type) {
	case *WebClientContinueMitigationActionType_NoHeaders:
		if fv, exists := v.FldValidators["send_headers_choice.no_headers"]; exists {
			val := m.GetSendHeadersChoice().(*WebClientContinueMitigationActionType_NoHeaders).NoHeaders
			vOpts := append(opts,
				db.WithValidateField("send_headers_choice"),
				db.WithValidateField("no_headers"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WebClientContinueMitigationActionType_AppendHeaders:
		if fv, exists := v.FldValidators["send_headers_choice.append_headers"]; exists {
			val := m.GetSendHeadersChoice().(*WebClientContinueMitigationActionType_AppendHeaders).AppendHeaders
			vOpts := append(opts,
				db.WithValidateField("send_headers_choice"),
				db.WithValidateField("append_headers"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWebClientContinueMitigationActionTypeValidator = func() *ValidateWebClientContinueMitigationActionType {
	v := &ValidateWebClientContinueMitigationActionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSendHeadersChoice := v.SendHeadersChoiceValidationRuleHandler
	rulesSendHeadersChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSendHeadersChoice(rulesSendHeadersChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WebClientContinueMitigationActionType.send_headers_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["send_headers_choice"] = vFn

	v.FldValidators["send_headers_choice.append_headers"] = WebClientContinueMitigationHeaderValidator().Validate

	return v
}()

func WebClientContinueMitigationActionTypeValidator() db.Validator {
	return DefaultWebClientContinueMitigationActionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *WebClientContinueMitigationHeader) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WebClientContinueMitigationHeader) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WebClientContinueMitigationHeader) DeepCopy() *WebClientContinueMitigationHeader {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WebClientContinueMitigationHeader{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WebClientContinueMitigationHeader) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WebClientContinueMitigationHeader) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WebClientContinueMitigationHeaderValidator().Validate(ctx, m, opts...)
}

type ValidateWebClientContinueMitigationHeader struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWebClientContinueMitigationHeader) AutoTypeHeaderNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for auto_type_header_name")
	}

	return validatorFn, nil
}

func (v *ValidateWebClientContinueMitigationHeader) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WebClientContinueMitigationHeader)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WebClientContinueMitigationHeader got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["auto_type_header_name"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_type_header_name"))
		if err := fv(ctx, m.GetAutoTypeHeaderName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWebClientContinueMitigationHeaderValidator = func() *ValidateWebClientContinueMitigationHeader {
	v := &ValidateWebClientContinueMitigationHeader{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAutoTypeHeaderName := v.AutoTypeHeaderNameValidationRuleHandler
	rulesAutoTypeHeaderName := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.string.http_header_field": "true",
		"ves.io.schema.rules.string.max_bytes":         "256",
	}
	vFn, err = vrhAutoTypeHeaderName(rulesAutoTypeHeaderName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WebClientContinueMitigationHeader.auto_type_header_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["auto_type_header_name"] = vFn

	return v
}()

func WebClientContinueMitigationHeaderValidator() db.Validator {
	return DefaultWebClientContinueMitigationHeaderValidator
}

// augmented methods on protoc/std generated struct

func (m *WebClientRedirectMitigationActionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WebClientRedirectMitigationActionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WebClientRedirectMitigationActionType) DeepCopy() *WebClientRedirectMitigationActionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WebClientRedirectMitigationActionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WebClientRedirectMitigationActionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WebClientRedirectMitigationActionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WebClientRedirectMitigationActionTypeValidator().Validate(ctx, m, opts...)
}

type ValidateWebClientRedirectMitigationActionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWebClientRedirectMitigationActionType) StatusValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.HttpStatusCode)
		return int32(i)
	}
	// ves_io_schema.HttpStatusCode_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.HttpStatusCode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for status")
	}

	return validatorFn, nil
}

func (v *ValidateWebClientRedirectMitigationActionType) UriValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for uri")
	}

	return validatorFn, nil
}

func (v *ValidateWebClientRedirectMitigationActionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WebClientRedirectMitigationActionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WebClientRedirectMitigationActionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["uri"]; exists {

		vOpts := append(opts, db.WithValidateField("uri"))
		if err := fv(ctx, m.GetUri(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWebClientRedirectMitigationActionTypeValidator = func() *ValidateWebClientRedirectMitigationActionType {
	v := &ValidateWebClientRedirectMitigationActionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStatus := v.StatusValidationRuleHandler
	rulesStatus := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.enum.in":           "[302]",
		"ves.io.schema.rules.message.required":  "true",
	}
	vFn, err = vrhStatus(rulesStatus)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WebClientRedirectMitigationActionType.status: %s", err)
		panic(errMsg)
	}
	v.FldValidators["status"] = vFn

	vrhUri := v.UriValidationRuleHandler
	rulesUri := map[string]string{
		"ves.io.schema.rules.message.required":      "true",
		"ves.io.schema.rules.string.url_or_uri_ref": "true",
	}
	vFn, err = vrhUri(rulesUri)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WebClientRedirectMitigationActionType.uri: %s", err)
		panic(errMsg)
	}
	v.FldValidators["uri"] = vFn

	return v
}()

func WebClientRedirectMitigationActionTypeValidator() db.Validator {
	return DefaultWebClientRedirectMitigationActionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *WebClientTransformMitigationActionChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WebClientTransformMitigationActionChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WebClientTransformMitigationActionChoiceType) DeepCopy() *WebClientTransformMitigationActionChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WebClientTransformMitigationActionChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WebClientTransformMitigationActionChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WebClientTransformMitigationActionChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WebClientTransformMitigationActionChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateWebClientTransformMitigationActionChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWebClientTransformMitigationActionChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WebClientTransformMitigationActionChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WebClientTransformMitigationActionChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAddHeadersChoice().(type) {
	case *WebClientTransformMitigationActionChoiceType_NoHeaders:
		if fv, exists := v.FldValidators["add_headers_choice.no_headers"]; exists {
			val := m.GetAddHeadersChoice().(*WebClientTransformMitigationActionChoiceType_NoHeaders).NoHeaders
			vOpts := append(opts,
				db.WithValidateField("add_headers_choice"),
				db.WithValidateField("no_headers"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WebClientTransformMitigationActionChoiceType_AddHeaders:
		if fv, exists := v.FldValidators["add_headers_choice.add_headers"]; exists {
			val := m.GetAddHeadersChoice().(*WebClientTransformMitigationActionChoiceType_AddHeaders).AddHeaders
			vOpts := append(opts,
				db.WithValidateField("add_headers_choice"),
				db.WithValidateField("add_headers"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWebClientTransformMitigationActionChoiceTypeValidator = func() *ValidateWebClientTransformMitigationActionChoiceType {
	v := &ValidateWebClientTransformMitigationActionChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["add_headers_choice.add_headers"] = WebClientAddHeaderToRequestValidator().Validate

	return v
}()

func WebClientTransformMitigationActionChoiceTypeValidator() db.Validator {
	return DefaultWebClientTransformMitigationActionChoiceTypeValidator
}
