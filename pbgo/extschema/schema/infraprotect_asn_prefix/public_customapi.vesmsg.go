// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package infraprotect_asn_prefix

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *UpdateASNPrefixIRROverrideRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdateASNPrefixIRROverrideRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdateASNPrefixIRROverrideRequest) DeepCopy() *UpdateASNPrefixIRROverrideRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdateASNPrefixIRROverrideRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdateASNPrefixIRROverrideRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdateASNPrefixIRROverrideRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdateASNPrefixIRROverrideRequestValidator().Validate(ctx, m, opts...)
}

type ValidateUpdateASNPrefixIRROverrideRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdateASNPrefixIRROverrideRequest) IrrOverrideValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for irr_override")
	}
	return validatorFn, nil
}

func (v *ValidateUpdateASNPrefixIRROverrideRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateUpdateASNPrefixIRROverrideRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdateASNPrefixIRROverrideRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdateASNPrefixIRROverrideRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["irr_override"]; exists {
		val := m.GetIrrOverride()
		vOpts := append(opts,
			db.WithValidateField("irr_override"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetIrrOverride().(type) {
	case *UpdateASNPrefixIRROverrideRequest_IrrOverrideFalse:
		if fv, exists := v.FldValidators["irr_override.irr_override_false"]; exists {
			val := m.GetIrrOverride().(*UpdateASNPrefixIRROverrideRequest_IrrOverrideFalse).IrrOverrideFalse
			vOpts := append(opts,
				db.WithValidateField("irr_override"),
				db.WithValidateField("irr_override_false"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *UpdateASNPrefixIRROverrideRequest_IrrOverrideTrue:
		if fv, exists := v.FldValidators["irr_override.irr_override_true"]; exists {
			val := m.GetIrrOverride().(*UpdateASNPrefixIRROverrideRequest_IrrOverrideTrue).IrrOverrideTrue
			vOpts := append(opts,
				db.WithValidateField("irr_override"),
				db.WithValidateField("irr_override_true"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdateASNPrefixIRROverrideRequestValidator = func() *ValidateUpdateASNPrefixIRROverrideRequest {
	v := &ValidateUpdateASNPrefixIRROverrideRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIrrOverride := v.IrrOverrideValidationRuleHandler
	rulesIrrOverride := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhIrrOverride(rulesIrrOverride)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpdateASNPrefixIRROverrideRequest.irr_override: %s", err)
		panic(errMsg)
	}
	v.FldValidators["irr_override"] = vFn

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpdateASNPrefixIRROverrideRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	return v
}()

func UpdateASNPrefixIRROverrideRequestValidator() db.Validator {
	return DefaultUpdateASNPrefixIRROverrideRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *UpdateASNPrefixIRROverrideResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdateASNPrefixIRROverrideResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdateASNPrefixIRROverrideResponse) DeepCopy() *UpdateASNPrefixIRROverrideResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdateASNPrefixIRROverrideResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdateASNPrefixIRROverrideResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdateASNPrefixIRROverrideResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdateASNPrefixIRROverrideResponseValidator().Validate(ctx, m, opts...)
}

type ValidateUpdateASNPrefixIRROverrideResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdateASNPrefixIRROverrideResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdateASNPrefixIRROverrideResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdateASNPrefixIRROverrideResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdateASNPrefixIRROverrideResponseValidator = func() *ValidateUpdateASNPrefixIRROverrideResponse {
	v := &ValidateUpdateASNPrefixIRROverrideResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UpdateASNPrefixIRROverrideResponseValidator() db.Validator {
	return DefaultUpdateASNPrefixIRROverrideResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *UpdateASNPrefixReviewStatusRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdateASNPrefixReviewStatusRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdateASNPrefixReviewStatusRequest) DeepCopy() *UpdateASNPrefixReviewStatusRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdateASNPrefixReviewStatusRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdateASNPrefixReviewStatusRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdateASNPrefixReviewStatusRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdateASNPrefixReviewStatusRequestValidator().Validate(ctx, m, opts...)
}

type ValidateUpdateASNPrefixReviewStatusRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdateASNPrefixReviewStatusRequest) ReviewTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for review_type")
	}
	return validatorFn, nil
}

func (v *ValidateUpdateASNPrefixReviewStatusRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateUpdateASNPrefixReviewStatusRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdateASNPrefixReviewStatusRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdateASNPrefixReviewStatusRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["review_type"]; exists {
		val := m.GetReviewType()
		vOpts := append(opts,
			db.WithValidateField("review_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetReviewType().(type) {
	case *UpdateASNPrefixReviewStatusRequest_ReviewTypePending:
		if fv, exists := v.FldValidators["review_type.review_type_pending"]; exists {
			val := m.GetReviewType().(*UpdateASNPrefixReviewStatusRequest_ReviewTypePending).ReviewTypePending
			vOpts := append(opts,
				db.WithValidateField("review_type"),
				db.WithValidateField("review_type_pending"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *UpdateASNPrefixReviewStatusRequest_ReviewTypeApproved:
		if fv, exists := v.FldValidators["review_type.review_type_approved"]; exists {
			val := m.GetReviewType().(*UpdateASNPrefixReviewStatusRequest_ReviewTypeApproved).ReviewTypeApproved
			vOpts := append(opts,
				db.WithValidateField("review_type"),
				db.WithValidateField("review_type_approved"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *UpdateASNPrefixReviewStatusRequest_ReviewTypeRejected:
		if fv, exists := v.FldValidators["review_type.review_type_rejected"]; exists {
			val := m.GetReviewType().(*UpdateASNPrefixReviewStatusRequest_ReviewTypeRejected).ReviewTypeRejected
			vOpts := append(opts,
				db.WithValidateField("review_type"),
				db.WithValidateField("review_type_rejected"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdateASNPrefixReviewStatusRequestValidator = func() *ValidateUpdateASNPrefixReviewStatusRequest {
	v := &ValidateUpdateASNPrefixReviewStatusRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhReviewType := v.ReviewTypeValidationRuleHandler
	rulesReviewType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhReviewType(rulesReviewType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpdateASNPrefixReviewStatusRequest.review_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["review_type"] = vFn

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpdateASNPrefixReviewStatusRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	return v
}()

func UpdateASNPrefixReviewStatusRequestValidator() db.Validator {
	return DefaultUpdateASNPrefixReviewStatusRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *UpdateASNPrefixReviewStatusResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdateASNPrefixReviewStatusResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdateASNPrefixReviewStatusResponse) DeepCopy() *UpdateASNPrefixReviewStatusResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdateASNPrefixReviewStatusResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdateASNPrefixReviewStatusResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdateASNPrefixReviewStatusResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdateASNPrefixReviewStatusResponseValidator().Validate(ctx, m, opts...)
}

type ValidateUpdateASNPrefixReviewStatusResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdateASNPrefixReviewStatusResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdateASNPrefixReviewStatusResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdateASNPrefixReviewStatusResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdateASNPrefixReviewStatusResponseValidator = func() *ValidateUpdateASNPrefixReviewStatusResponse {
	v := &ValidateUpdateASNPrefixReviewStatusResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UpdateASNPrefixReviewStatusResponseValidator() db.Validator {
	return DefaultUpdateASNPrefixReviewStatusResponseValidator
}
