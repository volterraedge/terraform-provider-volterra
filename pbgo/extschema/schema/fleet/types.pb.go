// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/fleet/types.proto

package fleet

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	_ "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	bgp "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/bgp"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Etcd Clustering Network
//
// x-displayName: "Etcd Clustering Network"
// Decided which network is used for etcd clustering
type EtcdClusterNetworkType int32

const (
	// x-displayName: "Site Local (Outside) Network"
	// Etcd clustering happens over Site local network
	ETCD_CLUSTER_SITE_LOCAL_NETWORK EtcdClusterNetworkType = 0
	// x-displayName: "Site Local Inside Network"
	// Etcd clustering happens over Site local inside network
	ETCD_CLUSTER_SITE_LOCAL_INSIDE_NETWORK EtcdClusterNetworkType = 1
	// x-displayName: "Site Management Network"
	// Etcd clustering happens over Site management network, requires redundant dedicated management interfaces
	ETCD_CLUSTER_SITE_MANAGEMENT_NETWORK EtcdClusterNetworkType = 2
)

var EtcdClusterNetworkType_name = map[int32]string{
	0: "ETCD_CLUSTER_SITE_LOCAL_NETWORK",
	1: "ETCD_CLUSTER_SITE_LOCAL_INSIDE_NETWORK",
	2: "ETCD_CLUSTER_SITE_MANAGEMENT_NETWORK",
}

var EtcdClusterNetworkType_value = map[string]int32{
	"ETCD_CLUSTER_SITE_LOCAL_NETWORK":        0,
	"ETCD_CLUSTER_SITE_LOCAL_INSIDE_NETWORK": 1,
	"ETCD_CLUSTER_SITE_MANAGEMENT_NETWORK":   2,
}

func (EtcdClusterNetworkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{0}
}

// Device Owner Type
//
// x-displayName: "Device Owner Type"
// Defines ownership for a device.
type DeviceOwnerType int32

const (
	// x-displayName: "Owner Invalid"
	// Device owner is invalid
	DEVICE_OWNER_INVALID DeviceOwnerType = 0
	// x-displayName: "Owner VER"
	// Device is owned by VER pod. usually it will be network interface device or accelerator like crypto engine.
	DEVICE_OWNER_VER DeviceOwnerType = 1
	// x-displayName: "Owner vK8s Workload"
	// Device is available to be owned by vK8s workload on the site, like camera GPU etc.
	DEVICE_OWNER_VK8S_WORK_LOAD DeviceOwnerType = 2
	// x-displayName: "Owner Host"
	// Device is not available to be owned by vK8s or VER. Can be exposed via some other service. Like TPM.
	DEVICE_OWNER_HOST DeviceOwnerType = 3
)

var DeviceOwnerType_name = map[int32]string{
	0: "DEVICE_OWNER_INVALID",
	1: "DEVICE_OWNER_VER",
	2: "DEVICE_OWNER_VK8S_WORK_LOAD",
	3: "DEVICE_OWNER_HOST",
}

var DeviceOwnerType_value = map[string]int32{
	"DEVICE_OWNER_INVALID":        0,
	"DEVICE_OWNER_VER":            1,
	"DEVICE_OWNER_VK8S_WORK_LOAD": 2,
	"DEVICE_OWNER_HOST":           3,
}

func (DeviceOwnerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{1}
}

// Fleet Type
//
// x-displayName: "Fleet Type"
// Defines fleet type. We have different constraints per each type.
type FleetType int32

const (
	// x-displayName: "Multiple Site Fleet"
	// Default fleet type.
	MULTIPLE_SITE FleetType = 0
	// x-displayName: "Single Site Fleet"
	// Internally created site by single fleet such as AWS/Azure/GCP etc.
	SINGLE_SITE FleetType = 1
)

var FleetType_name = map[int32]string{
	0: "MULTIPLE_SITE",
	1: "SINGLE_SITE",
}

var FleetType_value = map[string]int32{
	"MULTIPLE_SITE": 0,
	"SINGLE_SITE":   1,
}

func (FleetType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{2}
}

// Network Device Use
//
// x-displayName: "Network Device Use"
// Defines how the device is used
type NetworkingDeviceInstanceUseType int32

const (
	// x-displayName: "Regular Interface"
	// If networking device is owned by VER, it is available for users to configure as required
	NETWORK_INTERFACE_USE_REGULAR NetworkingDeviceInstanceUseType = 0
	// x-displayName: "Outside Interface"
	// If networking device is owned by VER, it is included in bootstrap config and member of outside network.
	NETWORK_INTERFACE_USE_OUTSIDE NetworkingDeviceInstanceUseType = 1
	// x-displayName: "Inside Interface"
	// If networking device is owned by VER, it is included in bootstrap config and member of inside network.
	NETWORK_INTERFACE_USE_INSIDE NetworkingDeviceInstanceUseType = 2
)

var NetworkingDeviceInstanceUseType_name = map[int32]string{
	0: "NETWORK_INTERFACE_USE_REGULAR",
	1: "NETWORK_INTERFACE_USE_OUTSIDE",
	2: "NETWORK_INTERFACE_USE_INSIDE",
}

var NetworkingDeviceInstanceUseType_value = map[string]int32{
	"NETWORK_INTERFACE_USE_REGULAR": 0,
	"NETWORK_INTERFACE_USE_OUTSIDE": 1,
	"NETWORK_INTERFACE_USE_INSIDE":  2,
}

func (NetworkingDeviceInstanceUseType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{3}
}

// vGPU Feature Type
//
// x-displayName: "Feature Type"
// Set feature to be enabled
type VGPUFeatureType int32

const (
	// x-displayName: "Unlicensed"
	// Operate with a degraded vGPU performance
	UNLICENSED VGPUFeatureType = 0
	// x-displayName: "NVIDIA vGPU"
	// Enable NVIDIA vGPU
	VGPU VGPUFeatureType = 1
	// x-displayName: "NVIDIA RTX Virtual Workstation"
	// Enable NVIDIA RTX Virtual Workstation
	VWS VGPUFeatureType = 2
	// x-displayName: "NVIDIA Virtual Compute Server"
	// Enable NVIDIA Virtual Compute Server
	VCS VGPUFeatureType = 4
)

var VGPUFeatureType_name = map[int32]string{
	0: "UNLICENSED",
	1: "VGPU",
	2: "VWS",
	4: "VCS",
}

var VGPUFeatureType_value = map[string]int32{
	"UNLICENSED": 0,
	"VGPU":       1,
	"VWS":        2,
	"VCS":        4,
}

func (VGPUFeatureType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{4}
}

// Network Device Type
//
// x-displayName: "Network Device Type"
// Represents physical network interface.
// The 'interface' reference points to a Network Interface object. Attributes such as Labels, MTU from
// Network Interface must be applied to the device.
//
// Device mapping to nodes
//
// A fleet can have many devices and nodes in VER customer edge site can have many interfaces.
// An interface in node inherits configuration from a device by matching,
//   - device_name in Network Interface for the device
//   - device name for physical-interface in the node
type NetworkingDeviceInstanceType struct {
	// Network Interface
	//
	// x-displayName: "Network Interface"
	// x-required
	// Network Interface attributes for the device.
	// User network interface configuration for this network device.
	// Attributes like labels, MTU from the 'interface' are applied to corresponding interface in VER node
	// If network interface refers to a virtual-network, the virtual-netowrk type must be consistent with use attribute given below
	// If use is NETWORK_INTERFACE_USE_REGULAR, the virtual-network must be of type VIRTUAL_NETWORK_SITE_LOCAL or VIRTUAL_NETWORK_SITE_LOCAL_INSIDE
	// if use is NETWORK_INTERFACE_USE_OUTSIDE, the virtual-network must of type VIRTUAL_NETWORK_SITE_LOCAL
	// if use is NETWORK_INTERFACE_USE_INSIDE, the virtual-network must of type VIRTUAL_NETWORK_SITE_LOCAL_INSIDE
	Interface []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=interface,proto3" json:"interface,omitempty"`
	// Use
	//
	// x-displayName: "Use"
	// x-required
	// Defines how the device is used.
	// 'use' specifies how the device is used in node
	// Specifies if the network interface is connected to inside network or outside network.
	Use NetworkingDeviceInstanceUseType `protobuf:"varint,3,opt,name=use,proto3,enum=ves.io.schema.fleet.NetworkingDeviceInstanceUseType" json:"use,omitempty"`
}

func (m *NetworkingDeviceInstanceType) Reset()      { *m = NetworkingDeviceInstanceType{} }
func (*NetworkingDeviceInstanceType) ProtoMessage() {}
func (*NetworkingDeviceInstanceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{0}
}
func (m *NetworkingDeviceInstanceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkingDeviceInstanceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkingDeviceInstanceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkingDeviceInstanceType.Merge(m, src)
}
func (m *NetworkingDeviceInstanceType) XXX_Size() int {
	return m.Size()
}
func (m *NetworkingDeviceInstanceType) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkingDeviceInstanceType.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkingDeviceInstanceType proto.InternalMessageInfo

func (m *NetworkingDeviceInstanceType) GetInterface() []*schema.ObjectRefType {
	if m != nil {
		return m.Interface
	}
	return nil
}

func (m *NetworkingDeviceInstanceType) GetUse() NetworkingDeviceInstanceUseType {
	if m != nil {
		return m.Use
	}
	return NETWORK_INTERFACE_USE_REGULAR
}

// Generic Device
//
// x-displayName: "Generic Device"
// Represent a generic device
// This is not yet supported
type GenericDeviceInstanceType struct {
}

func (m *GenericDeviceInstanceType) Reset()      { *m = GenericDeviceInstanceType{} }
func (*GenericDeviceInstanceType) ProtoMessage() {}
func (*GenericDeviceInstanceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{1}
}
func (m *GenericDeviceInstanceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenericDeviceInstanceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GenericDeviceInstanceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenericDeviceInstanceType.Merge(m, src)
}
func (m *GenericDeviceInstanceType) XXX_Size() int {
	return m.Size()
}
func (m *GenericDeviceInstanceType) XXX_DiscardUnknown() {
	xxx_messageInfo_GenericDeviceInstanceType.DiscardUnknown(m)
}

var xxx_messageInfo_GenericDeviceInstanceType proto.InternalMessageInfo

// Device Instance
//
// x-displayName: "Device Instance"
// Device Instance describes a single device in fleet
// A device can be of type network interface, camera, scanner etc. A device instance is created for each instance of device.
// If there are 2 network interfaces(eth0, eth1...), then 2 DeviceInstanceType are created one for eth0 and another for eth1
type DeviceInstanceType struct {
	// Name
	//
	// x-displayName: "Device Name"
	// Name of the device including the unit number (e.g. eth0 or disk1). The name must match name of device in host-os of node
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Owner
	//
	// x-displayName: "Device Owner"
	// x-required
	// Defines ownership of the device. A device can be owned by,
	//   * VER : Devices like ethernet are owned by VER
	//   * VK8S Workload : The devices is available for VK8S workload use.
	//                     This option is not yet supported
	//   * HOST : Device is owned by host-os. The devices can be exposed via some other services like TPM.
	//            This option is not yet supported
	Owner DeviceOwnerType `protobuf:"varint,3,opt,name=owner,proto3,enum=ves.io.schema.fleet.DeviceOwnerType" json:"owner,omitempty"`
	// Device Instance
	//
	// x-displayName: "Device Instance"
	// x-required
	// Device Instance specifies the type of interface and its characteristics
	//
	// Types that are valid to be assigned to DeviceInstance:
	//	*DeviceInstanceType_NetworkDevice
	DeviceInstance isDeviceInstanceType_DeviceInstance `protobuf_oneof:"device_instance"`
}

func (m *DeviceInstanceType) Reset()      { *m = DeviceInstanceType{} }
func (*DeviceInstanceType) ProtoMessage() {}
func (*DeviceInstanceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{2}
}
func (m *DeviceInstanceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceInstanceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeviceInstanceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceInstanceType.Merge(m, src)
}
func (m *DeviceInstanceType) XXX_Size() int {
	return m.Size()
}
func (m *DeviceInstanceType) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceInstanceType.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceInstanceType proto.InternalMessageInfo

type isDeviceInstanceType_DeviceInstance interface {
	isDeviceInstanceType_DeviceInstance()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DeviceInstanceType_NetworkDevice struct {
	NetworkDevice *NetworkingDeviceInstanceType `protobuf:"bytes,4,opt,name=network_device,json=networkDevice,proto3,oneof" json:"network_device,omitempty"`
}

func (*DeviceInstanceType_NetworkDevice) isDeviceInstanceType_DeviceInstance() {}

func (m *DeviceInstanceType) GetDeviceInstance() isDeviceInstanceType_DeviceInstance {
	if m != nil {
		return m.DeviceInstance
	}
	return nil
}

func (m *DeviceInstanceType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeviceInstanceType) GetOwner() DeviceOwnerType {
	if m != nil {
		return m.Owner
	}
	return DEVICE_OWNER_INVALID
}

func (m *DeviceInstanceType) GetNetworkDevice() *NetworkingDeviceInstanceType {
	if x, ok := m.GetDeviceInstance().(*DeviceInstanceType_NetworkDevice); ok {
		return x.NetworkDevice
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DeviceInstanceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DeviceInstanceType_NetworkDevice)(nil),
	}
}

// List of Interfaces
//
// x-displayName: "List of Interfaces"
// Add all interfaces belonging to this fleet
type FleetInterfaceListType struct {
	// List of Interfaces
	//
	// x-displayName: "List of Interfaces"
	// x-required
	// Add all interfaces belonging to this fleet
	Interfaces []*views.ObjectRefType `protobuf:"bytes,1,rep,name=interfaces,proto3" json:"interfaces,omitempty"`
}

func (m *FleetInterfaceListType) Reset()      { *m = FleetInterfaceListType{} }
func (*FleetInterfaceListType) ProtoMessage() {}
func (*FleetInterfaceListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{3}
}
func (m *FleetInterfaceListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FleetInterfaceListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FleetInterfaceListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FleetInterfaceListType.Merge(m, src)
}
func (m *FleetInterfaceListType) XXX_Size() int {
	return m.Size()
}
func (m *FleetInterfaceListType) XXX_DiscardUnknown() {
	xxx_messageInfo_FleetInterfaceListType.DiscardUnknown(m)
}

var xxx_messageInfo_FleetInterfaceListType proto.InternalMessageInfo

func (m *FleetInterfaceListType) GetInterfaces() []*views.ObjectRefType {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

// List of Devices
//
// x-displayName: "List of Devices"
// Add device for all interfaces belonging to this fleet
type FleetDeviceListType struct {
	// Add device for all interfaces belonging to this fleet
	//
	// x-displayName: "Devices"
	// Configuration for all devices in the fleet.
	// Examples of devices are - network interfaces, cameras, scanners etc.
	// Configuration a device is applied on VER node if the VER node is member of this fleet and
	// has an corresponding interface/device. The mapping from device configured in fleet with
	// interface/device in VER node depends on the type of device and is documented in
	// device instance specific sections
	Devices []*DeviceInstanceType `protobuf:"bytes,3,rep,name=devices,proto3" json:"devices,omitempty"`
}

func (m *FleetDeviceListType) Reset()      { *m = FleetDeviceListType{} }
func (*FleetDeviceListType) ProtoMessage() {}
func (*FleetDeviceListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{4}
}
func (m *FleetDeviceListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FleetDeviceListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FleetDeviceListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FleetDeviceListType.Merge(m, src)
}
func (m *FleetDeviceListType) XXX_Size() int {
	return m.Size()
}
func (m *FleetDeviceListType) XXX_DiscardUnknown() {
	xxx_messageInfo_FleetDeviceListType.DiscardUnknown(m)
}

var xxx_messageInfo_FleetDeviceListType proto.InternalMessageInfo

func (m *FleetDeviceListType) GetDevices() []*DeviceInstanceType {
	if m != nil {
		return m.Devices
	}
	return nil
}

// OpenEBS Enterprise
//
// x-displayName: "OpenEBS Enterprise"
// Device configuration for OpenEBS Enterprise
type StorageDeviceOpenebsEnterpriseType struct {
	// List of  Mayastor Pools
	//
	// x-displayName: "List of  Mayastor Pools"
	// List of  Mayastor Pools. When a Mayastor Node (MSN) allocates storage capacity for a Persistent Volume (PV) it does so from a construct named a Mayastor Pool (MSP).
	// Each MSN may have zero, one, or more such pools associated with it.  The ownership of a pool by a MSN is exclusive.
	// In the current version of Mayastor, a pool may have only a single block device member, which constitutes the entire data persistence layer for that pool.
	// Each MSP include a unique name for the pool, the host name of the MSN on which it is hosted and a reference to a disk device which is accessible from that node (for inclusion within the pool).
	// The pool definition allows the reference to its member disk to adhere to one of a number of possible schemes, each associated with a specific access
	// mechanism/transport/device type and differentiated by corresponding performance and/or attachment locality.
	MayastorPools []*OpenebsMayastorPoolType `protobuf:"bytes,1,rep,name=mayastor_pools,json=mayastorPools,proto3" json:"mayastor_pools,omitempty"`
}

func (m *StorageDeviceOpenebsEnterpriseType) Reset()      { *m = StorageDeviceOpenebsEnterpriseType{} }
func (*StorageDeviceOpenebsEnterpriseType) ProtoMessage() {}
func (*StorageDeviceOpenebsEnterpriseType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{5}
}
func (m *StorageDeviceOpenebsEnterpriseType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageDeviceOpenebsEnterpriseType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StorageDeviceOpenebsEnterpriseType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageDeviceOpenebsEnterpriseType.Merge(m, src)
}
func (m *StorageDeviceOpenebsEnterpriseType) XXX_Size() int {
	return m.Size()
}
func (m *StorageDeviceOpenebsEnterpriseType) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageDeviceOpenebsEnterpriseType.DiscardUnknown(m)
}

var xxx_messageInfo_StorageDeviceOpenebsEnterpriseType proto.InternalMessageInfo

func (m *StorageDeviceOpenebsEnterpriseType) GetMayastorPools() []*OpenebsMayastorPoolType {
	if m != nil {
		return m.MayastorPools
	}
	return nil
}

// OpenEBS Mayastor Pool
//
// x-displayName: "OpenEBS Mayastor Pool"
// Configuration for OpenEBS Mayastor Pool. When a Mayastor Node (MSN) allocates storage capacity for a Persistent Volume (PV) it does so from a construct named a Mayastor Pool (MSP).
// Each MSN may have zero, one, or more such pools associated with it.  The ownership of a pool by a MSN is exclusive.
// In the current version of Mayastor, a pool may have only a single block device member, which constitutes the entire data persistence layer for that pool.
// Each MSP include a unique name for the pool, the host name of the MSN on which it is hosted and a reference to a disk device which is accessible from that node (for inclusion within the pool).
// The pool definition allows the reference to its member disk to adhere to one of a number of possible schemes, each associated with a specific access
// mechanism/transport/device type and differentiated by corresponding performance and/or attachment locality.
type OpenebsMayastorPoolType struct {
	// Mayastor Pool Name
	//
	// x-displayName: "Mayastor Pool Name"
	// x-example: "maya-pool-01"
	// x-required
	// Enter Mayastor Pool Name
	PoolName string `protobuf:"bytes,1,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty"`
	// Node Name
	//
	// x-displayName: "Node Name"
	// x-required
	// x-example: "master-0"
	// Enter k8s node name of Mayastor Node (MSN) where this pool is or going to be located.
	Node string `protobuf:"bytes,2,opt,name=node,proto3" json:"node,omitempty"`
	// List of Disk Devices
	//
	// x-displayName: "List of  Disk Devices"
	// x-required
	// x-example: "/dev/sdb"
	// List of Disk Devices on Mayastore Node (MSN). Once Mayastor has created a pool it is assumed that it henceforth has exclusive use of the associated
	// disk device; it should not be partitioned, formatted, or shared with another application or process.  Any existing data on the device will be destroyed.
	// It supports various types such as "/dev/sdb", "nvme://nqn.2014-08.com.vendor:nvme:nvm-subsystem-sn-d78432" or "iscsi://iqn.2000-08.com.datacore.com:cloudvm41-2".
	PoolDiskDevices []string `protobuf:"bytes,3,rep,name=pool_disk_devices,json=poolDiskDevices,proto3" json:"pool_disk_devices,omitempty"`
}

func (m *OpenebsMayastorPoolType) Reset()      { *m = OpenebsMayastorPoolType{} }
func (*OpenebsMayastorPoolType) ProtoMessage() {}
func (*OpenebsMayastorPoolType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{6}
}
func (m *OpenebsMayastorPoolType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenebsMayastorPoolType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OpenebsMayastorPoolType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenebsMayastorPoolType.Merge(m, src)
}
func (m *OpenebsMayastorPoolType) XXX_Size() int {
	return m.Size()
}
func (m *OpenebsMayastorPoolType) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenebsMayastorPoolType.DiscardUnknown(m)
}

var xxx_messageInfo_OpenebsMayastorPoolType proto.InternalMessageInfo

func (m *OpenebsMayastorPoolType) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

func (m *OpenebsMayastorPoolType) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

func (m *OpenebsMayastorPoolType) GetPoolDiskDevices() []string {
	if m != nil {
		return m.PoolDiskDevices
	}
	return nil
}

// Dell EMC isilon F800
//
// x-displayName: "Dell EMC isilon F800"
// Device configuration for Dell EMC isilon F800
type StorageDeviceDellIsilonF800Type struct {
	// Username
	//
	// x-displayName: "Username"
	// x-example: "string:///YWRtaW4="
	// x-required
	// Base64 encoded username
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	// Password
	//
	// x-displayName: "Password"
	// Please Enter you password.
	Password *schema.SecretType `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	//  Select Network Security Mode
	//
	// x-displayName: "Select Network Security mode"
	// x-required
	// Select if network is secure or insecure, if insecure use https
	//
	// Types that are valid to be assigned to HttpsChoice:
	//	*StorageDeviceDellIsilonF800Type_SecureNetwork
	//	*StorageDeviceDellIsilonF800Type_TrustedCaUrl
	HttpsChoice isStorageDeviceDellIsilonF800Type_HttpsChoice `protobuf_oneof:"https_choice"`
	//  Select Storage server address
	//
	// x-displayName: "Select Storage server address"
	// x-required
	// Select how to reach API server.
	//
	// Types that are valid to be assigned to AddressChoice:
	//	*StorageDeviceDellIsilonF800Type_ApiServerName
	//	*StorageDeviceDellIsilonF800Type_ApiServerIpAddress
	AddressChoice isStorageDeviceDellIsilonF800Type_AddressChoice `protobuf_oneof:"address_choice"`
	// Storage server Port
	//
	// x-displayName: "Storage server Port"
	// x-example: "8080"
	// Enter Storage Server Port
	ApiServerPort uint32 `protobuf:"varint,9,opt,name=api_server_port,json=apiServerPort,proto3" json:"api_server_port,omitempty"`
	// iSCSI Access Zone
	//
	// x-displayName: "iSCSI Access Zone"
	// x-example: "System"
	// The name of the access zone, a volume can be created in
	IscsiAccessZone string `protobuf:"bytes,10,opt,name=iscsi_access_zone,json=iscsiAccessZone,proto3" json:"iscsi_access_zone,omitempty"`
	// Volume Prefix
	//
	// x-displayName: "Volume Prefix"
	// x-example: "k8s"
	// Volume prefix is a string prepended to each volume created by the CSI driver
	VolumePrefix string `protobuf:"bytes,11,opt,name=volume_prefix,json=volumePrefix,proto3" json:"volume_prefix,omitempty"`
	// Base Path
	//
	// x-displayName: "Base Path
	// x-example: "/ifs/data/csi"
	//The default base path for the volumes to be created, this will be used if a storage class does not have the IsiPath parameter specified Ensure that this path exists on Isilon.
	BasePath string `protobuf:"bytes,12,opt,name=base_path,json=basePath,proto3" json:"base_path,omitempty"`
}

func (m *StorageDeviceDellIsilonF800Type) Reset()      { *m = StorageDeviceDellIsilonF800Type{} }
func (*StorageDeviceDellIsilonF800Type) ProtoMessage() {}
func (*StorageDeviceDellIsilonF800Type) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{7}
}
func (m *StorageDeviceDellIsilonF800Type) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageDeviceDellIsilonF800Type) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StorageDeviceDellIsilonF800Type) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageDeviceDellIsilonF800Type.Merge(m, src)
}
func (m *StorageDeviceDellIsilonF800Type) XXX_Size() int {
	return m.Size()
}
func (m *StorageDeviceDellIsilonF800Type) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageDeviceDellIsilonF800Type.DiscardUnknown(m)
}

var xxx_messageInfo_StorageDeviceDellIsilonF800Type proto.InternalMessageInfo

type isStorageDeviceDellIsilonF800Type_HttpsChoice interface {
	isStorageDeviceDellIsilonF800Type_HttpsChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isStorageDeviceDellIsilonF800Type_AddressChoice interface {
	isStorageDeviceDellIsilonF800Type_AddressChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type StorageDeviceDellIsilonF800Type_SecureNetwork struct {
	SecureNetwork *schema.Empty `protobuf:"bytes,4,opt,name=secure_network,json=secureNetwork,proto3,oneof" json:"secure_network,omitempty"`
}
type StorageDeviceDellIsilonF800Type_TrustedCaUrl struct {
	TrustedCaUrl string `protobuf:"bytes,5,opt,name=trusted_ca_url,json=trustedCaUrl,proto3,oneof" json:"trusted_ca_url,omitempty"`
}
type StorageDeviceDellIsilonF800Type_ApiServerName struct {
	ApiServerName string `protobuf:"bytes,7,opt,name=api_server_name,json=apiServerName,proto3,oneof" json:"api_server_name,omitempty"`
}
type StorageDeviceDellIsilonF800Type_ApiServerIpAddress struct {
	ApiServerIpAddress string `protobuf:"bytes,8,opt,name=api_server_ip_address,json=apiServerIpAddress,proto3,oneof" json:"api_server_ip_address,omitempty"`
}

func (*StorageDeviceDellIsilonF800Type_SecureNetwork) isStorageDeviceDellIsilonF800Type_HttpsChoice() {
}
func (*StorageDeviceDellIsilonF800Type_TrustedCaUrl) isStorageDeviceDellIsilonF800Type_HttpsChoice() {
}
func (*StorageDeviceDellIsilonF800Type_ApiServerName) isStorageDeviceDellIsilonF800Type_AddressChoice() {
}
func (*StorageDeviceDellIsilonF800Type_ApiServerIpAddress) isStorageDeviceDellIsilonF800Type_AddressChoice() {
}

func (m *StorageDeviceDellIsilonF800Type) GetHttpsChoice() isStorageDeviceDellIsilonF800Type_HttpsChoice {
	if m != nil {
		return m.HttpsChoice
	}
	return nil
}
func (m *StorageDeviceDellIsilonF800Type) GetAddressChoice() isStorageDeviceDellIsilonF800Type_AddressChoice {
	if m != nil {
		return m.AddressChoice
	}
	return nil
}

func (m *StorageDeviceDellIsilonF800Type) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *StorageDeviceDellIsilonF800Type) GetPassword() *schema.SecretType {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *StorageDeviceDellIsilonF800Type) GetSecureNetwork() *schema.Empty {
	if x, ok := m.GetHttpsChoice().(*StorageDeviceDellIsilonF800Type_SecureNetwork); ok {
		return x.SecureNetwork
	}
	return nil
}

func (m *StorageDeviceDellIsilonF800Type) GetTrustedCaUrl() string {
	if x, ok := m.GetHttpsChoice().(*StorageDeviceDellIsilonF800Type_TrustedCaUrl); ok {
		return x.TrustedCaUrl
	}
	return ""
}

func (m *StorageDeviceDellIsilonF800Type) GetApiServerName() string {
	if x, ok := m.GetAddressChoice().(*StorageDeviceDellIsilonF800Type_ApiServerName); ok {
		return x.ApiServerName
	}
	return ""
}

func (m *StorageDeviceDellIsilonF800Type) GetApiServerIpAddress() string {
	if x, ok := m.GetAddressChoice().(*StorageDeviceDellIsilonF800Type_ApiServerIpAddress); ok {
		return x.ApiServerIpAddress
	}
	return ""
}

func (m *StorageDeviceDellIsilonF800Type) GetApiServerPort() uint32 {
	if m != nil {
		return m.ApiServerPort
	}
	return 0
}

func (m *StorageDeviceDellIsilonF800Type) GetIscsiAccessZone() string {
	if m != nil {
		return m.IscsiAccessZone
	}
	return ""
}

func (m *StorageDeviceDellIsilonF800Type) GetVolumePrefix() string {
	if m != nil {
		return m.VolumePrefix
	}
	return ""
}

func (m *StorageDeviceDellIsilonF800Type) GetBasePath() string {
	if m != nil {
		return m.BasePath
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StorageDeviceDellIsilonF800Type) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StorageDeviceDellIsilonF800Type_SecureNetwork)(nil),
		(*StorageDeviceDellIsilonF800Type_TrustedCaUrl)(nil),
		(*StorageDeviceDellIsilonF800Type_ApiServerName)(nil),
		(*StorageDeviceDellIsilonF800Type_ApiServerIpAddress)(nil),
	}
}

// HPE Nimbus Storage AF40
//
// x-displayName: "HPE Nimbus Storage AF40"
// Device configuration for HPE Nimbus Storage AF40
type StorageDeviceHPENimbusStorageAf40Type struct {
	// Storage Server Name
	//
	// x-displayName: "Storage Server Name"
	// Enter storage server Name
	StorageServerName string `protobuf:"bytes,1,opt,name=storage_server_name,json=storageServerName,proto3" json:"storage_server_name,omitempty"`
	// Storage Server IP address
	//
	// x-displayName: "Storage Server IP address"
	// Enter storage server IP address
	StorageServerIpAddress string `protobuf:"bytes,2,opt,name=storage_server_ip_address,json=storageServerIpAddress,proto3" json:"storage_server_ip_address,omitempty"`
	// Storage server Port
	//
	// x-displayName: "Storage server Port"
	// x-example: "8080"
	// Enter Storage Server Port
	ApiServerPort uint32 `protobuf:"varint,3,opt,name=api_server_port,json=apiServerPort,proto3" json:"api_server_port,omitempty"`
	// Username
	//
	// x-displayName: "Username"
	// x-example: "string:///YWRtaW4="
	// x-required
	// Base64 encoded username
	Username string `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
	// Password
	//
	// x-displayName: "Password"
	// Please Enter you password.
	Password *schema.SecretType `protobuf:"bytes,5,opt,name=password,proto3" json:"password,omitempty"`
	// Performance Policy
	//
	// x-displayName: "Performance Policy"
	// x-example: "Other"
	// Performance Policy for this storage Class
	PerfPolicy string `protobuf:"bytes,6,opt,name=perf_policy,json=perfPolicy,proto3" json:"perf_policy,omitempty"`
	// IOP Limit
	//
	// x-displayName: "IOP Limit"
	// x-example: "76800"
	// I/O operations per second limit for this storage class
	LimitIops uint32 `protobuf:"varint,7,opt,name=limit_iops,json=limitIops,proto3" json:"limit_iops,omitempty"`
	// MBPS Limit
	//
	// x-displayName: "MBPS Limit"
	// x-example: "10000"
	// Mega Byte per second data thruput limit.
	LimitMbps uint32 `protobuf:"varint,8,opt,name=limit_mbps,json=limitMbps,proto3" json:"limit_mbps,omitempty"`
}

func (m *StorageDeviceHPENimbusStorageAf40Type) Reset()      { *m = StorageDeviceHPENimbusStorageAf40Type{} }
func (*StorageDeviceHPENimbusStorageAf40Type) ProtoMessage() {}
func (*StorageDeviceHPENimbusStorageAf40Type) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{8}
}
func (m *StorageDeviceHPENimbusStorageAf40Type) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageDeviceHPENimbusStorageAf40Type) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StorageDeviceHPENimbusStorageAf40Type) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageDeviceHPENimbusStorageAf40Type.Merge(m, src)
}
func (m *StorageDeviceHPENimbusStorageAf40Type) XXX_Size() int {
	return m.Size()
}
func (m *StorageDeviceHPENimbusStorageAf40Type) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageDeviceHPENimbusStorageAf40Type.DiscardUnknown(m)
}

var xxx_messageInfo_StorageDeviceHPENimbusStorageAf40Type proto.InternalMessageInfo

func (m *StorageDeviceHPENimbusStorageAf40Type) GetStorageServerName() string {
	if m != nil {
		return m.StorageServerName
	}
	return ""
}

func (m *StorageDeviceHPENimbusStorageAf40Type) GetStorageServerIpAddress() string {
	if m != nil {
		return m.StorageServerIpAddress
	}
	return ""
}

func (m *StorageDeviceHPENimbusStorageAf40Type) GetApiServerPort() uint32 {
	if m != nil {
		return m.ApiServerPort
	}
	return 0
}

func (m *StorageDeviceHPENimbusStorageAf40Type) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *StorageDeviceHPENimbusStorageAf40Type) GetPassword() *schema.SecretType {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *StorageDeviceHPENimbusStorageAf40Type) GetPerfPolicy() string {
	if m != nil {
		return m.PerfPolicy
	}
	return ""
}

func (m *StorageDeviceHPENimbusStorageAf40Type) GetLimitIops() uint32 {
	if m != nil {
		return m.LimitIops
	}
	return 0
}

func (m *StorageDeviceHPENimbusStorageAf40Type) GetLimitMbps() uint32 {
	if m != nil {
		return m.LimitMbps
	}
	return 0
}

// Pure Storage Service Orchestrator
//
// x-displayName: "Pure Storage Service Orchestrator"
// Device configuration for Pure Storage Service Orchestrator
type StorageDevicePureStorageServiceOrchestratorType struct {
	// Cluster ID
	//
	// x-displayName: "Cluster ID"
	// x-required
	// x-example: "cluster1"
	// clusterID is added as a prefix for all volumes created by this PSO installation.
	// clusterID is also used to identify the volumes used by the datastore, pso-db.
	// clusterID MUST BE UNIQUE for multiple K8s clusters running on top of the same storage arrays.
	// characters allowed: alphanumeric and underscores
	ClusterId string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// Enable Storage Topology
	//
	// x-displayName: "Enable Storage Topology"
	// This option is to enable/disable the csi topology feature for pso-csi
	EnableStorageTopology bool `protobuf:"varint,2,opt,name=enable_storage_topology,json=enableStorageTopology,proto3" json:"enable_storage_topology,omitempty"`
	// Enable Strict Topology
	//
	// x-displayName: "Enable Strict Topology"
	// This option is to enable/disable the strict csi topology feature for pso-csi
	EnableStrictTopology bool `protobuf:"varint,3,opt,name=enable_strict_topology,json=enableStrictTopology,proto3" json:"enable_strict_topology,omitempty"`
	// Arrays Configuration
	//
	// x-displayName: "Arrays Configuration"
	// x-required
	// This section configure PSO storage arrays
	Arrays *PsoArrayConfiguration `protobuf:"bytes,4,opt,name=arrays,proto3" json:"arrays,omitempty"`
}

func (m *StorageDevicePureStorageServiceOrchestratorType) Reset() {
	*m = StorageDevicePureStorageServiceOrchestratorType{}
}
func (*StorageDevicePureStorageServiceOrchestratorType) ProtoMessage() {}
func (*StorageDevicePureStorageServiceOrchestratorType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{9}
}
func (m *StorageDevicePureStorageServiceOrchestratorType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageDevicePureStorageServiceOrchestratorType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StorageDevicePureStorageServiceOrchestratorType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageDevicePureStorageServiceOrchestratorType.Merge(m, src)
}
func (m *StorageDevicePureStorageServiceOrchestratorType) XXX_Size() int {
	return m.Size()
}
func (m *StorageDevicePureStorageServiceOrchestratorType) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageDevicePureStorageServiceOrchestratorType.DiscardUnknown(m)
}

var xxx_messageInfo_StorageDevicePureStorageServiceOrchestratorType proto.InternalMessageInfo

func (m *StorageDevicePureStorageServiceOrchestratorType) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *StorageDevicePureStorageServiceOrchestratorType) GetEnableStorageTopology() bool {
	if m != nil {
		return m.EnableStorageTopology
	}
	return false
}

func (m *StorageDevicePureStorageServiceOrchestratorType) GetEnableStrictTopology() bool {
	if m != nil {
		return m.EnableStrictTopology
	}
	return false
}

func (m *StorageDevicePureStorageServiceOrchestratorType) GetArrays() *PsoArrayConfiguration {
	if m != nil {
		return m.Arrays
	}
	return nil
}

// Arrays Configuration
//
// x-displayName: "Arrays Configuration"
// Device configuration for PSO Arrays
type PsoArrayConfiguration struct {
	// Flash Arrays
	//
	// x-displayName: "Flash Arrays"
	// Specify what storage flash arrays should be managed the plugin
	// For FlashArrays you must set the "mgmt_endpoint" and "api_token"
	FlashArray *FlashArrayType `protobuf:"bytes,1,opt,name=flash_array,json=flashArray,proto3" json:"flash_array,omitempty"`
	// Flash Blade
	//
	// x-displayName: "Flash Blade"
	// Specify what storage flash blades should be managed the plugin
	FlashBlade *FlashBladeType `protobuf:"bytes,2,opt,name=flash_blade,json=flashBlade,proto3" json:"flash_blade,omitempty"`
}

func (m *PsoArrayConfiguration) Reset()      { *m = PsoArrayConfiguration{} }
func (*PsoArrayConfiguration) ProtoMessage() {}
func (*PsoArrayConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{10}
}
func (m *PsoArrayConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PsoArrayConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PsoArrayConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PsoArrayConfiguration.Merge(m, src)
}
func (m *PsoArrayConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *PsoArrayConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_PsoArrayConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_PsoArrayConfiguration proto.InternalMessageInfo

func (m *PsoArrayConfiguration) GetFlashArray() *FlashArrayType {
	if m != nil {
		return m.FlashArray
	}
	return nil
}

func (m *PsoArrayConfiguration) GetFlashBlade() *FlashBladeType {
	if m != nil {
		return m.FlashBlade
	}
	return nil
}

// Flash Blades
//
// x-displayName: "Flash Blades"
// Specify what storage flash blades should be managed the plugin
type FlashBladeType struct {
	// Enable Snapshot Directory
	//
	// x-displayName: "Enable Snapshot Directory"
	// Enable/Disable FlashBlade snapshots
	EnableSnapshotDirectory bool `protobuf:"varint,1,opt,name=enable_snapshot_directory,json=enableSnapshotDirectory,proto3" json:"enable_snapshot_directory,omitempty"`
	// NFS Export Rules
	//
	// x-displayName: "NFS Export Rules"
	// x-example: "*(rw,no_root_squash)"
	// NFS Export rules
	ExportRules string `protobuf:"bytes,2,opt,name=export_rules,json=exportRules,proto3" json:"export_rules,omitempty"`
	// Flash Blades
	//
	// x-displayName: "Flash Blades"
	// x-required
	// For FlashBlades you must set the "mgmt_endpoint", "api_token" and nfs_endpoint
	FlashBlades []*FlashBladeEndpoint `protobuf:"bytes,3,rep,name=flash_blades,json=flashBlades,proto3" json:"flash_blades,omitempty"`
}

func (m *FlashBladeType) Reset()      { *m = FlashBladeType{} }
func (*FlashBladeType) ProtoMessage() {}
func (*FlashBladeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{11}
}
func (m *FlashBladeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlashBladeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FlashBladeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlashBladeType.Merge(m, src)
}
func (m *FlashBladeType) XXX_Size() int {
	return m.Size()
}
func (m *FlashBladeType) XXX_DiscardUnknown() {
	xxx_messageInfo_FlashBladeType.DiscardUnknown(m)
}

var xxx_messageInfo_FlashBladeType proto.InternalMessageInfo

func (m *FlashBladeType) GetEnableSnapshotDirectory() bool {
	if m != nil {
		return m.EnableSnapshotDirectory
	}
	return false
}

func (m *FlashBladeType) GetExportRules() string {
	if m != nil {
		return m.ExportRules
	}
	return ""
}

func (m *FlashBladeType) GetFlashBlades() []*FlashBladeEndpoint {
	if m != nil {
		return m.FlashBlades
	}
	return nil
}

// Flash Blade Endpoint
//
// x-displayName: "Flash Blade Endpoint"
// For FlashBlades you must set the "mgmt_endpoint", "api_token" and nfs_endpoint
type FlashBladeEndpoint struct {
	// Management Endpoint
	//
	// x-displayName: "Management Endpoint"
	// x-required
	// FQDN or IP address of PSO Management endpoint
	//
	// Types that are valid to be assigned to MgmtEndpoint:
	//	*FlashBladeEndpoint_MgmtIp
	//	*FlashBladeEndpoint_MgmtDnsName
	MgmtEndpoint isFlashBladeEndpoint_MgmtEndpoint `protobuf_oneof:"mgmt_endpoint"`
	// API Token
	//
	// x-displayName: "API Token"
	// Please Enter API TOken. Token to connect to management interface
	ApiToken *schema.SecretType `protobuf:"bytes,4,opt,name=api_token,json=apiToken,proto3" json:"api_token,omitempty"`
	// NFS Endpoint
	//
	// x-displayName: "NFS Endpoint"
	// x-required
	// x-example: "192.168.10.10"
	// FQDN or IP address of PSO NFS endpoint
	//
	// Types that are valid to be assigned to NfsEndpoint:
	//	*FlashBladeEndpoint_NfsEndpointIp
	//	*FlashBladeEndpoint_NfsEndpointDnsName
	NfsEndpoint isFlashBladeEndpoint_NfsEndpoint `protobuf_oneof:"nfs_endpoint"`
	// Labels
	//
	// x-displayName: "Labels"
	// x-example: "{"rack": "22"}"
	// The labels are optional, and can be any key-value pair for use with the PSO "fleet" provisioner.
	Lables map[string]string `protobuf:"bytes,8,rep,name=lables,proto3" json:"lables,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FlashBladeEndpoint) Reset()      { *m = FlashBladeEndpoint{} }
func (*FlashBladeEndpoint) ProtoMessage() {}
func (*FlashBladeEndpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{12}
}
func (m *FlashBladeEndpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlashBladeEndpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FlashBladeEndpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlashBladeEndpoint.Merge(m, src)
}
func (m *FlashBladeEndpoint) XXX_Size() int {
	return m.Size()
}
func (m *FlashBladeEndpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_FlashBladeEndpoint.DiscardUnknown(m)
}

var xxx_messageInfo_FlashBladeEndpoint proto.InternalMessageInfo

type isFlashBladeEndpoint_MgmtEndpoint interface {
	isFlashBladeEndpoint_MgmtEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isFlashBladeEndpoint_NfsEndpoint interface {
	isFlashBladeEndpoint_NfsEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type FlashBladeEndpoint_MgmtIp struct {
	MgmtIp string `protobuf:"bytes,2,opt,name=mgmt_ip,json=mgmtIp,proto3,oneof" json:"mgmt_ip,omitempty"`
}
type FlashBladeEndpoint_MgmtDnsName struct {
	MgmtDnsName string `protobuf:"bytes,3,opt,name=mgmt_dns_name,json=mgmtDnsName,proto3,oneof" json:"mgmt_dns_name,omitempty"`
}
type FlashBladeEndpoint_NfsEndpointIp struct {
	NfsEndpointIp string `protobuf:"bytes,6,opt,name=nfs_endpoint_ip,json=nfsEndpointIp,proto3,oneof" json:"nfs_endpoint_ip,omitempty"`
}
type FlashBladeEndpoint_NfsEndpointDnsName struct {
	NfsEndpointDnsName string `protobuf:"bytes,7,opt,name=nfs_endpoint_dns_name,json=nfsEndpointDnsName,proto3,oneof" json:"nfs_endpoint_dns_name,omitempty"`
}

func (*FlashBladeEndpoint_MgmtIp) isFlashBladeEndpoint_MgmtEndpoint()            {}
func (*FlashBladeEndpoint_MgmtDnsName) isFlashBladeEndpoint_MgmtEndpoint()       {}
func (*FlashBladeEndpoint_NfsEndpointIp) isFlashBladeEndpoint_NfsEndpoint()      {}
func (*FlashBladeEndpoint_NfsEndpointDnsName) isFlashBladeEndpoint_NfsEndpoint() {}

func (m *FlashBladeEndpoint) GetMgmtEndpoint() isFlashBladeEndpoint_MgmtEndpoint {
	if m != nil {
		return m.MgmtEndpoint
	}
	return nil
}
func (m *FlashBladeEndpoint) GetNfsEndpoint() isFlashBladeEndpoint_NfsEndpoint {
	if m != nil {
		return m.NfsEndpoint
	}
	return nil
}

func (m *FlashBladeEndpoint) GetMgmtIp() string {
	if x, ok := m.GetMgmtEndpoint().(*FlashBladeEndpoint_MgmtIp); ok {
		return x.MgmtIp
	}
	return ""
}

func (m *FlashBladeEndpoint) GetMgmtDnsName() string {
	if x, ok := m.GetMgmtEndpoint().(*FlashBladeEndpoint_MgmtDnsName); ok {
		return x.MgmtDnsName
	}
	return ""
}

func (m *FlashBladeEndpoint) GetApiToken() *schema.SecretType {
	if m != nil {
		return m.ApiToken
	}
	return nil
}

func (m *FlashBladeEndpoint) GetNfsEndpointIp() string {
	if x, ok := m.GetNfsEndpoint().(*FlashBladeEndpoint_NfsEndpointIp); ok {
		return x.NfsEndpointIp
	}
	return ""
}

func (m *FlashBladeEndpoint) GetNfsEndpointDnsName() string {
	if x, ok := m.GetNfsEndpoint().(*FlashBladeEndpoint_NfsEndpointDnsName); ok {
		return x.NfsEndpointDnsName
	}
	return ""
}

func (m *FlashBladeEndpoint) GetLables() map[string]string {
	if m != nil {
		return m.Lables
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FlashBladeEndpoint) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FlashBladeEndpoint_MgmtIp)(nil),
		(*FlashBladeEndpoint_MgmtDnsName)(nil),
		(*FlashBladeEndpoint_NfsEndpointIp)(nil),
		(*FlashBladeEndpoint_NfsEndpointDnsName)(nil),
	}
}

// Flash Arrays
//
// x-displayName: "Flash Arrays"
// Specify what storage flash arrays should be managed the plugin
type FlashArrayType struct {
	// SAN Type
	//
	// x-displayName: "SAN Type"
	// x-required
	// x-example: "ISCSI"
	// Block volume access protocol, either ISCSI or FC
	SanType string `protobuf:"bytes,1,opt,name=san_type,json=sanType,proto3" json:"san_type,omitempty"`
	// Default Filesystem Type
	//
	// x-displayName: "Default Filesystem Type"
	// x-required
	// x-example: "xfs"
	// Block volume default filesystem type. Not recommended to change!
	DefaultFsType string `protobuf:"bytes,2,opt,name=default_fs_type,json=defaultFsType,proto3" json:"default_fs_type,omitempty"`
	// Default Filesystem Options
	//
	// x-displayName: "Default Filesystem Options"
	// x-example: "-q"
	// Block volume default mkfs options. Not recommended to change!
	DefaultFsOpt string `protobuf:"bytes,3,opt,name=default_fs_opt,json=defaultFsOpt,proto3" json:"default_fs_opt,omitempty"`
	// Default Mount Options
	//
	// x-displayName: "Default Mount Options"
	// x-example: "[- discart]"
	// Block volume default filesystem mount options. Not recommended to change!
	DefaultMountOpts []string `protobuf:"bytes,4,rep,name=default_mount_opts,json=defaultMountOpts,proto3" json:"default_mount_opts,omitempty"`
	// Disable Preempt Attachments
	//
	// x-displayName: "Disable Preempt Attachments"
	// Enable/Disable attachment preemption!
	DisablePreemptAttachments bool `protobuf:"varint,5,opt,name=disable_preempt_attachments,json=disablePreemptAttachments,proto3" json:"disable_preempt_attachments,omitempty"`
	// iSCSI Login Timeout
	//
	// x-displayName: "iSCSI Login Timeout"
	// x-required
	// x-exmple: "20"
	// iSCSI login timeout in seconds. Not recommended to change!
	IscsiLoginTimeout int32 `protobuf:"varint,6,opt,name=iscsi_login_timeout,json=iscsiLoginTimeout,proto3" json:"iscsi_login_timeout,omitempty"`
	// Flash Arrays
	//
	// x-displayName: "Flash Arrays"
	// x-required
	// For FlashArrays you must set the "mgmt_endpoint" and "api_token"
	FlashArrays []*FlashArrayEndpoint `protobuf:"bytes,7,rep,name=flash_arrays,json=flashArrays,proto3" json:"flash_arrays,omitempty"`
}

func (m *FlashArrayType) Reset()      { *m = FlashArrayType{} }
func (*FlashArrayType) ProtoMessage() {}
func (*FlashArrayType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{13}
}
func (m *FlashArrayType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlashArrayType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FlashArrayType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlashArrayType.Merge(m, src)
}
func (m *FlashArrayType) XXX_Size() int {
	return m.Size()
}
func (m *FlashArrayType) XXX_DiscardUnknown() {
	xxx_messageInfo_FlashArrayType.DiscardUnknown(m)
}

var xxx_messageInfo_FlashArrayType proto.InternalMessageInfo

func (m *FlashArrayType) GetSanType() string {
	if m != nil {
		return m.SanType
	}
	return ""
}

func (m *FlashArrayType) GetDefaultFsType() string {
	if m != nil {
		return m.DefaultFsType
	}
	return ""
}

func (m *FlashArrayType) GetDefaultFsOpt() string {
	if m != nil {
		return m.DefaultFsOpt
	}
	return ""
}

func (m *FlashArrayType) GetDefaultMountOpts() []string {
	if m != nil {
		return m.DefaultMountOpts
	}
	return nil
}

func (m *FlashArrayType) GetDisablePreemptAttachments() bool {
	if m != nil {
		return m.DisablePreemptAttachments
	}
	return false
}

func (m *FlashArrayType) GetIscsiLoginTimeout() int32 {
	if m != nil {
		return m.IscsiLoginTimeout
	}
	return 0
}

func (m *FlashArrayType) GetFlashArrays() []*FlashArrayEndpoint {
	if m != nil {
		return m.FlashArrays
	}
	return nil
}

// Flash Array Endpoint
//
// x-displayName: "Flash Array Endpoint"
// For FlashArrays you must set the "mgmt_endpoint" and "api_token"
type FlashArrayEndpoint struct {
	// Management Endpoint
	//
	// x-displayName: "Management Endpoint"
	// x-required
	// FQDN or IP address of PSO Management endpoint
	//
	// Types that are valid to be assigned to MgmtEndpoint:
	//	*FlashArrayEndpoint_MgmtIp
	//	*FlashArrayEndpoint_MgmtDnsName
	MgmtEndpoint isFlashArrayEndpoint_MgmtEndpoint `protobuf_oneof:"mgmt_endpoint"`
	// API Token
	//
	// x-displayName: "API Token"
	// Please Enter API TOken. Token to connect to management interface
	ApiToken *schema.SecretType `protobuf:"bytes,4,opt,name=api_token,json=apiToken,proto3" json:"api_token,omitempty"`
	// Labels
	//
	// x-displayName: "Labels"
	// x-example: "{"rack": "22"}"
	// The labels are optional, and can be any key-value pair for use with the PSO "fleet" provisioner.
	Labels map[string]string `protobuf:"bytes,5,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FlashArrayEndpoint) Reset()      { *m = FlashArrayEndpoint{} }
func (*FlashArrayEndpoint) ProtoMessage() {}
func (*FlashArrayEndpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{14}
}
func (m *FlashArrayEndpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlashArrayEndpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FlashArrayEndpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlashArrayEndpoint.Merge(m, src)
}
func (m *FlashArrayEndpoint) XXX_Size() int {
	return m.Size()
}
func (m *FlashArrayEndpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_FlashArrayEndpoint.DiscardUnknown(m)
}

var xxx_messageInfo_FlashArrayEndpoint proto.InternalMessageInfo

type isFlashArrayEndpoint_MgmtEndpoint interface {
	isFlashArrayEndpoint_MgmtEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type FlashArrayEndpoint_MgmtIp struct {
	MgmtIp string `protobuf:"bytes,2,opt,name=mgmt_ip,json=mgmtIp,proto3,oneof" json:"mgmt_ip,omitempty"`
}
type FlashArrayEndpoint_MgmtDnsName struct {
	MgmtDnsName string `protobuf:"bytes,3,opt,name=mgmt_dns_name,json=mgmtDnsName,proto3,oneof" json:"mgmt_dns_name,omitempty"`
}

func (*FlashArrayEndpoint_MgmtIp) isFlashArrayEndpoint_MgmtEndpoint()      {}
func (*FlashArrayEndpoint_MgmtDnsName) isFlashArrayEndpoint_MgmtEndpoint() {}

func (m *FlashArrayEndpoint) GetMgmtEndpoint() isFlashArrayEndpoint_MgmtEndpoint {
	if m != nil {
		return m.MgmtEndpoint
	}
	return nil
}

func (m *FlashArrayEndpoint) GetMgmtIp() string {
	if x, ok := m.GetMgmtEndpoint().(*FlashArrayEndpoint_MgmtIp); ok {
		return x.MgmtIp
	}
	return ""
}

func (m *FlashArrayEndpoint) GetMgmtDnsName() string {
	if x, ok := m.GetMgmtEndpoint().(*FlashArrayEndpoint_MgmtDnsName); ok {
		return x.MgmtDnsName
	}
	return ""
}

func (m *FlashArrayEndpoint) GetApiToken() *schema.SecretType {
	if m != nil {
		return m.ApiToken
	}
	return nil
}

func (m *FlashArrayEndpoint) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FlashArrayEndpoint) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FlashArrayEndpoint_MgmtIp)(nil),
		(*FlashArrayEndpoint_MgmtDnsName)(nil),
	}
}

// NetApp Trident
//
// x-displayName: "NetApp Trident"
// Device configuration for NetApp Trident Storage
type StorageDeviceNetappTridentType struct {
	// Select NetApp Trident Backend
	//
	// x-displayName: "Select NetApp Trident Backend"
	// x-required
	// Select type of backend to configure
	//
	// Types that are valid to be assigned to BackendChoice:
	//	*StorageDeviceNetappTridentType_NetappBackendOntapNas
	//	*StorageDeviceNetappTridentType_NetappBackendOntapSan
	BackendChoice isStorageDeviceNetappTridentType_BackendChoice `protobuf_oneof:"backend_choice"`
}

func (m *StorageDeviceNetappTridentType) Reset()      { *m = StorageDeviceNetappTridentType{} }
func (*StorageDeviceNetappTridentType) ProtoMessage() {}
func (*StorageDeviceNetappTridentType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{15}
}
func (m *StorageDeviceNetappTridentType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageDeviceNetappTridentType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StorageDeviceNetappTridentType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageDeviceNetappTridentType.Merge(m, src)
}
func (m *StorageDeviceNetappTridentType) XXX_Size() int {
	return m.Size()
}
func (m *StorageDeviceNetappTridentType) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageDeviceNetappTridentType.DiscardUnknown(m)
}

var xxx_messageInfo_StorageDeviceNetappTridentType proto.InternalMessageInfo

type isStorageDeviceNetappTridentType_BackendChoice interface {
	isStorageDeviceNetappTridentType_BackendChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type StorageDeviceNetappTridentType_NetappBackendOntapNas struct {
	NetappBackendOntapNas *StorageDeviceNetappBackendOntapNasType `protobuf:"bytes,2,opt,name=netapp_backend_ontap_nas,json=netappBackendOntapNas,proto3,oneof" json:"netapp_backend_ontap_nas,omitempty"`
}
type StorageDeviceNetappTridentType_NetappBackendOntapSan struct {
	NetappBackendOntapSan *StorageDeviceNetappBackendOntapSanType `protobuf:"bytes,3,opt,name=netapp_backend_ontap_san,json=netappBackendOntapSan,proto3,oneof" json:"netapp_backend_ontap_san,omitempty"`
}

func (*StorageDeviceNetappTridentType_NetappBackendOntapNas) isStorageDeviceNetappTridentType_BackendChoice() {
}
func (*StorageDeviceNetappTridentType_NetappBackendOntapSan) isStorageDeviceNetappTridentType_BackendChoice() {
}

func (m *StorageDeviceNetappTridentType) GetBackendChoice() isStorageDeviceNetappTridentType_BackendChoice {
	if m != nil {
		return m.BackendChoice
	}
	return nil
}

func (m *StorageDeviceNetappTridentType) GetNetappBackendOntapNas() *StorageDeviceNetappBackendOntapNasType {
	if x, ok := m.GetBackendChoice().(*StorageDeviceNetappTridentType_NetappBackendOntapNas); ok {
		return x.NetappBackendOntapNas
	}
	return nil
}

func (m *StorageDeviceNetappTridentType) GetNetappBackendOntapSan() *StorageDeviceNetappBackendOntapSanType {
	if x, ok := m.GetBackendChoice().(*StorageDeviceNetappTridentType_NetappBackendOntapSan); ok {
		return x.NetappBackendOntapSan
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StorageDeviceNetappTridentType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StorageDeviceNetappTridentType_NetappBackendOntapNas)(nil),
		(*StorageDeviceNetappTridentType_NetappBackendOntapSan)(nil),
	}
}

// Storage Backend NetApp ONTAP SAN
//
// x-displayName: "Storage Backend NetApp ONTAP SAN"
// Configuration of storage backend for NetApp ONTAP SAN
type StorageDeviceNetappBackendOntapSanType struct {
	// Storage Backend Driver
	//
	// x-displayName: "Storage Backend Driver"
	// x-required
	// x-example: "ontap-nas"
	// Configuration of Backend Name
	StorageDriverName string `protobuf:"bytes,1,opt,name=storage_driver_name,json=storageDriverName,proto3" json:"storage_driver_name,omitempty"`
	// Backend Management LIF
	//
	// x-displayName: "Backend Management LIF"
	// x-required
	// FQDN or IP address of a cluster or SVM management LIF
	//
	// Types that are valid to be assigned to ManagementLif:
	//	*StorageDeviceNetappBackendOntapSanType_ManagementLifIp
	//	*StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName
	ManagementLif isStorageDeviceNetappBackendOntapSanType_ManagementLif `protobuf_oneof:"management_lif"`
	// Backend Data LIF
	//
	// x-displayName: "Backend Data LIF"
	// x-example: "192.168.10.10"
	// FQDN or IP address of protocol LIF. Use square brackets for IPv6. Once set this cannot be updated. Derived by the SVM unless specified.
	//
	// Types that are valid to be assigned to DataLif:
	//	*StorageDeviceNetappBackendOntapSanType_DataLifIp
	//	*StorageDeviceNetappBackendOntapSanType_DataLifDnsName
	DataLif isStorageDeviceNetappBackendOntapSanType_DataLif `protobuf_oneof:"data_lif"`
	// Backend SVM
	//
	// x-displayName: "Backend SVM"
	// x-example: "trident_svm"
	// Storage virtual machine to use. Derived if an SVM managementLIF is specified
	Svm string `protobuf:"bytes,9,opt,name=svm,proto3" json:"svm,omitempty"`
	// Username
	//
	// x-displayName: "Username"
	// x-example: "cluster-admin"
	// x-required
	// Username to connect to the cluster/SVM
	Username string `protobuf:"bytes,10,opt,name=username,proto3" json:"username,omitempty"`
	// Password
	//
	// x-displayName: "Password"
	// Please Enter you password. Password to connect to the cluster/SVM
	Password *schema.SecretType `protobuf:"bytes,11,opt,name=password,proto3" json:"password,omitempty"`
	// Use CHAP
	//
	// x-displayName: "Use CHAP"
	// Use CHAP to authenticate iSCSI for ONTAP SAN drivers.
	//
	// Types that are valid to be assigned to ChapChoice:
	//	*StorageDeviceNetappBackendOntapSanType_NoChap
	//	*StorageDeviceNetappBackendOntapSanType_UseChap
	ChapChoice isStorageDeviceNetappBackendOntapSanType_ChapChoice `protobuf_oneof:"chap_choice"`
	// iGroup Name
	//
	// x-displayName: "iGroup Name"
	// Name of the igroup for SAN volumes to use
	IgroupName string `protobuf:"bytes,17,opt,name=igroup_name,json=igroupName,proto3" json:"igroup_name,omitempty"`
	// Storage Prefix
	//
	// x-displayName: "Storage Prefix"
	// x-example: "trident"
	// Prefix used when provisioning new volumes in the SVM. Once set this cannot be updated
	StoragePrefix string `protobuf:"bytes,18,opt,name=storage_prefix,json=storagePrefix,proto3" json:"storage_prefix,omitempty"`
	// Limit Aggregate Usage
	//
	// x-displayName: "Limit Aggregate Usage"
	// x-example: "80"
	// Fail provisioning if usage is above this percentage. Not enforced by default.
	LimitAggregateUsage uint32 `protobuf:"varint,19,opt,name=limit_aggregate_usage,json=limitAggregateUsage,proto3" json:"limit_aggregate_usage,omitempty"`
	// Limit Volume Size
	//
	// x-displayName: "Limit Volume Size"
	// x-example: "50"
	// Fail provisioning if requested volume size in GBi is above this value. Not enforced by default.
	LimitVolumeSize int32 `protobuf:"varint,20,opt,name=limit_volume_size,json=limitVolumeSize,proto3" json:"limit_volume_size,omitempty"`
	// Backend Volume Defaults
	//
	// x-displayName: "Backend Volume Defaults"
	// List of QoS volume defaults types
	VolumeDefaults *OntapVolumeDefaults `protobuf:"bytes,21,opt,name=volume_defaults,json=volumeDefaults,proto3" json:"volume_defaults,omitempty"`
	// Backend Labels
	//
	// x-displayName: "Backend Labels"
	// x-example: "{"store":"nas_store"}"
	// List of labels for Storage Device used in NetApp ONTAP. It is used for storage class selection.
	Labels map[string]string `protobuf:"bytes,22,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Backend Region
	//
	// x-displayName: "Backend Region"
	// x-example: "us_east_1b"
	// Virtual Pool Region
	Region string `protobuf:"bytes,23,opt,name=region,proto3" json:"region,omitempty"`
	// Virtual Storage Pools
	//
	// x-displayName: "Virtual Storage Pools"
	// List of Virtual Storage Pool definitions which are referred back by Storage Class label match selection.
	Storage []*OntapVirtualStoragePoolType `protobuf:"bytes,24,rep,name=storage,proto3" json:"storage,omitempty"`
	// Client Certificate
	//
	// x-displayName: "Client Certificate"
	// Please Enter Base64-encoded value of client certificate. Used for certificate-based auth.
	ClientCertificate string `protobuf:"bytes,25,opt,name=client_certificate,json=clientCertificate,proto3" json:"client_certificate,omitempty"`
	// Client Private Key
	//
	// x-displayName: "Client Private Key"
	// Please Enter value of client private key. Used for certificate-based auth.
	ClientPrivateKey *schema.SecretType `protobuf:"bytes,26,opt,name=client_private_key,json=clientPrivateKey,proto3" json:"client_private_key,omitempty"`
	// Trusted CA Certificate
	//
	// x-displayName: "Trusted CA Certificate"
	// Please Enter Base64-encoded value of trusted CA certificate. Optional. Used for certificate-based auth..
	TrustedCaCertificate string `protobuf:"bytes,27,opt,name=trusted_ca_certificate,json=trustedCaCertificate,proto3" json:"trusted_ca_certificate,omitempty"`
}

func (m *StorageDeviceNetappBackendOntapSanType) Reset() {
	*m = StorageDeviceNetappBackendOntapSanType{}
}
func (*StorageDeviceNetappBackendOntapSanType) ProtoMessage() {}
func (*StorageDeviceNetappBackendOntapSanType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{16}
}
func (m *StorageDeviceNetappBackendOntapSanType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageDeviceNetappBackendOntapSanType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StorageDeviceNetappBackendOntapSanType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageDeviceNetappBackendOntapSanType.Merge(m, src)
}
func (m *StorageDeviceNetappBackendOntapSanType) XXX_Size() int {
	return m.Size()
}
func (m *StorageDeviceNetappBackendOntapSanType) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageDeviceNetappBackendOntapSanType.DiscardUnknown(m)
}

var xxx_messageInfo_StorageDeviceNetappBackendOntapSanType proto.InternalMessageInfo

type isStorageDeviceNetappBackendOntapSanType_ManagementLif interface {
	isStorageDeviceNetappBackendOntapSanType_ManagementLif()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isStorageDeviceNetappBackendOntapSanType_DataLif interface {
	isStorageDeviceNetappBackendOntapSanType_DataLif()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isStorageDeviceNetappBackendOntapSanType_ChapChoice interface {
	isStorageDeviceNetappBackendOntapSanType_ChapChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type StorageDeviceNetappBackendOntapSanType_ManagementLifIp struct {
	ManagementLifIp string `protobuf:"bytes,4,opt,name=management_lif_ip,json=managementLifIp,proto3,oneof" json:"management_lif_ip,omitempty"`
}
type StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName struct {
	ManagementLifDnsName string `protobuf:"bytes,5,opt,name=management_lif_dns_name,json=managementLifDnsName,proto3,oneof" json:"management_lif_dns_name,omitempty"`
}
type StorageDeviceNetappBackendOntapSanType_DataLifIp struct {
	DataLifIp string `protobuf:"bytes,7,opt,name=data_lif_ip,json=dataLifIp,proto3,oneof" json:"data_lif_ip,omitempty"`
}
type StorageDeviceNetappBackendOntapSanType_DataLifDnsName struct {
	DataLifDnsName string `protobuf:"bytes,8,opt,name=data_lif_dns_name,json=dataLifDnsName,proto3,oneof" json:"data_lif_dns_name,omitempty"`
}
type StorageDeviceNetappBackendOntapSanType_NoChap struct {
	NoChap *schema.Empty `protobuf:"bytes,13,opt,name=no_chap,json=noChap,proto3,oneof" json:"no_chap,omitempty"`
}
type StorageDeviceNetappBackendOntapSanType_UseChap struct {
	UseChap *DeviceNetappBackendOntapSanChapType `protobuf:"bytes,14,opt,name=use_chap,json=useChap,proto3,oneof" json:"use_chap,omitempty"`
}

func (*StorageDeviceNetappBackendOntapSanType_ManagementLifIp) isStorageDeviceNetappBackendOntapSanType_ManagementLif() {
}
func (*StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName) isStorageDeviceNetappBackendOntapSanType_ManagementLif() {
}
func (*StorageDeviceNetappBackendOntapSanType_DataLifIp) isStorageDeviceNetappBackendOntapSanType_DataLif() {
}
func (*StorageDeviceNetappBackendOntapSanType_DataLifDnsName) isStorageDeviceNetappBackendOntapSanType_DataLif() {
}
func (*StorageDeviceNetappBackendOntapSanType_NoChap) isStorageDeviceNetappBackendOntapSanType_ChapChoice() {
}
func (*StorageDeviceNetappBackendOntapSanType_UseChap) isStorageDeviceNetappBackendOntapSanType_ChapChoice() {
}

func (m *StorageDeviceNetappBackendOntapSanType) GetManagementLif() isStorageDeviceNetappBackendOntapSanType_ManagementLif {
	if m != nil {
		return m.ManagementLif
	}
	return nil
}
func (m *StorageDeviceNetappBackendOntapSanType) GetDataLif() isStorageDeviceNetappBackendOntapSanType_DataLif {
	if m != nil {
		return m.DataLif
	}
	return nil
}
func (m *StorageDeviceNetappBackendOntapSanType) GetChapChoice() isStorageDeviceNetappBackendOntapSanType_ChapChoice {
	if m != nil {
		return m.ChapChoice
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapSanType) GetStorageDriverName() string {
	if m != nil {
		return m.StorageDriverName
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetManagementLifIp() string {
	if x, ok := m.GetManagementLif().(*StorageDeviceNetappBackendOntapSanType_ManagementLifIp); ok {
		return x.ManagementLifIp
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetManagementLifDnsName() string {
	if x, ok := m.GetManagementLif().(*StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName); ok {
		return x.ManagementLifDnsName
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetDataLifIp() string {
	if x, ok := m.GetDataLif().(*StorageDeviceNetappBackendOntapSanType_DataLifIp); ok {
		return x.DataLifIp
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetDataLifDnsName() string {
	if x, ok := m.GetDataLif().(*StorageDeviceNetappBackendOntapSanType_DataLifDnsName); ok {
		return x.DataLifDnsName
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetSvm() string {
	if m != nil {
		return m.Svm
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetPassword() *schema.SecretType {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapSanType) GetNoChap() *schema.Empty {
	if x, ok := m.GetChapChoice().(*StorageDeviceNetappBackendOntapSanType_NoChap); ok {
		return x.NoChap
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapSanType) GetUseChap() *DeviceNetappBackendOntapSanChapType {
	if x, ok := m.GetChapChoice().(*StorageDeviceNetappBackendOntapSanType_UseChap); ok {
		return x.UseChap
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapSanType) GetIgroupName() string {
	if m != nil {
		return m.IgroupName
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetStoragePrefix() string {
	if m != nil {
		return m.StoragePrefix
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetLimitAggregateUsage() uint32 {
	if m != nil {
		return m.LimitAggregateUsage
	}
	return 0
}

func (m *StorageDeviceNetappBackendOntapSanType) GetLimitVolumeSize() int32 {
	if m != nil {
		return m.LimitVolumeSize
	}
	return 0
}

func (m *StorageDeviceNetappBackendOntapSanType) GetVolumeDefaults() *OntapVolumeDefaults {
	if m != nil {
		return m.VolumeDefaults
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapSanType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapSanType) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetStorage() []*OntapVirtualStoragePoolType {
	if m != nil {
		return m.Storage
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapSanType) GetClientCertificate() string {
	if m != nil {
		return m.ClientCertificate
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetClientPrivateKey() *schema.SecretType {
	if m != nil {
		return m.ClientPrivateKey
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapSanType) GetTrustedCaCertificate() string {
	if m != nil {
		return m.TrustedCaCertificate
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StorageDeviceNetappBackendOntapSanType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StorageDeviceNetappBackendOntapSanType_ManagementLifIp)(nil),
		(*StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName)(nil),
		(*StorageDeviceNetappBackendOntapSanType_DataLifIp)(nil),
		(*StorageDeviceNetappBackendOntapSanType_DataLifDnsName)(nil),
		(*StorageDeviceNetappBackendOntapSanType_NoChap)(nil),
		(*StorageDeviceNetappBackendOntapSanType_UseChap)(nil),
	}
}

// Device NetApp Backend ONTAP SAN CHAP configuration
//
// x-displayName: "Device NetApp Backend ONTAP SAN CHAP Configuration"
// Device NetApp Backend ONTAP SAN CHAP configuration options for enabled CHAP
type DeviceNetappBackendOntapSanChapType struct {
	// CHAP Username
	//
	// x-displayName: "CHAP Username"
	// Inbound username. Required if useCHAP=true
	ChapUsername string `protobuf:"bytes,1,opt,name=chap_username,json=chapUsername,proto3" json:"chap_username,omitempty"`
	// CHAP Target Username
	//
	// x-displayName: "CHAP Target Username"
	// Target username. Required if useCHAP=true
	ChapTargetUsername string `protobuf:"bytes,2,opt,name=chap_target_username,json=chapTargetUsername,proto3" json:"chap_target_username,omitempty"`
	// CHAP Intiator Secret
	//
	// x-displayName: "CHAP Intiator Secret"
	// CHAP initiator secret. Required if useCHAP=true
	ChapInitiatorSecret *schema.SecretType `protobuf:"bytes,3,opt,name=chap_initiator_secret,json=chapInitiatorSecret,proto3" json:"chap_initiator_secret,omitempty"`
	// CHAP Target Initiator Secret
	//
	// x-displayName: "CHAP Target Initiator Secret"
	// CHAP target initiator secret. Required if useCHAP=true
	ChapTargetInitiatorSecret *schema.SecretType `protobuf:"bytes,4,opt,name=chap_target_initiator_secret,json=chapTargetInitiatorSecret,proto3" json:"chap_target_initiator_secret,omitempty"`
}

func (m *DeviceNetappBackendOntapSanChapType) Reset()      { *m = DeviceNetappBackendOntapSanChapType{} }
func (*DeviceNetappBackendOntapSanChapType) ProtoMessage() {}
func (*DeviceNetappBackendOntapSanChapType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{17}
}
func (m *DeviceNetappBackendOntapSanChapType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceNetappBackendOntapSanChapType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeviceNetappBackendOntapSanChapType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceNetappBackendOntapSanChapType.Merge(m, src)
}
func (m *DeviceNetappBackendOntapSanChapType) XXX_Size() int {
	return m.Size()
}
func (m *DeviceNetappBackendOntapSanChapType) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceNetappBackendOntapSanChapType.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceNetappBackendOntapSanChapType proto.InternalMessageInfo

func (m *DeviceNetappBackendOntapSanChapType) GetChapUsername() string {
	if m != nil {
		return m.ChapUsername
	}
	return ""
}

func (m *DeviceNetappBackendOntapSanChapType) GetChapTargetUsername() string {
	if m != nil {
		return m.ChapTargetUsername
	}
	return ""
}

func (m *DeviceNetappBackendOntapSanChapType) GetChapInitiatorSecret() *schema.SecretType {
	if m != nil {
		return m.ChapInitiatorSecret
	}
	return nil
}

func (m *DeviceNetappBackendOntapSanChapType) GetChapTargetInitiatorSecret() *schema.SecretType {
	if m != nil {
		return m.ChapTargetInitiatorSecret
	}
	return nil
}

// Storage Backend NetApp ONTAP NAS
//
// x-displayName: "Storage Backend NetApp ONTAP NAS"
// Configuration of storage backend for NetApp ONTAP NAS
type StorageDeviceNetappBackendOntapNasType struct {
	// Storage Backend Driver
	//
	// x-displayName: "Storage Backend Driver"
	// x-required
	// x-example: "ontap-nas"
	// Configuration of Backend Name
	StorageDriverName string `protobuf:"bytes,1,opt,name=storage_driver_name,json=storageDriverName,proto3" json:"storage_driver_name,omitempty"`
	// Storage Backend Name
	//
	// x-displayName: "Storage Backend Name"
	// Configuration of Backend Name. Driver is name + "_" + dataLIF
	BackendName string `protobuf:"bytes,2,opt,name=backend_name,json=backendName,proto3" json:"backend_name,omitempty"`
	// Backend Management LIF
	//
	// x-displayName: "Backend Management LIF"
	// x-required
	// FQDN or IP address of a cluster or SVM management LIF
	//
	// Types that are valid to be assigned to ManagementLif:
	//	*StorageDeviceNetappBackendOntapNasType_ManagementLifIp
	//	*StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName
	ManagementLif isStorageDeviceNetappBackendOntapNasType_ManagementLif `protobuf_oneof:"management_lif"`
	// Backend Data LIF
	//
	// x-displayName: "Backend Data LIF"
	// x-example: "192.168.10.10"
	// FQDN or IP address of protocol LIF. Use square brackets for IPv6. Once set this cannot be updated. Derived by the SVM unless specified.
	//
	// Types that are valid to be assigned to DataLif:
	//	*StorageDeviceNetappBackendOntapNasType_DataLifIp
	//	*StorageDeviceNetappBackendOntapNasType_DataLifDnsName
	DataLif isStorageDeviceNetappBackendOntapNasType_DataLif `protobuf_oneof:"data_lif"`
	// Backend SVM
	//
	// x-displayName: "Backend SVM"
	// x-example: "trident_svm"
	// Storage virtual machine to use. Derived if an SVM managementLIF is specified
	Svm string `protobuf:"bytes,9,opt,name=svm,proto3" json:"svm,omitempty"`
	// Username
	//
	// x-displayName: "Username"
	// x-example: "cluster-admin"
	// x-required
	// Username to connect to the cluster/SVM
	Username string `protobuf:"bytes,10,opt,name=username,proto3" json:"username,omitempty"`
	// Password
	//
	// x-displayName: "Password"
	// Please Enter you password. Password to connect to the cluster/SVM
	Password *schema.SecretType `protobuf:"bytes,11,opt,name=password,proto3" json:"password,omitempty"`
	// Auto Export Policy
	//
	// x-displayName: "Auto Export Policy"
	// Enable automatic export policy creation and updating
	AutoExportPolicy bool `protobuf:"varint,12,opt,name=auto_export_policy,json=autoExportPolicy,proto3" json:"auto_export_policy,omitempty"`
	// Auto Export CIDRs
	//
	// x-displayName: "Auto Export CIDRs"
	// x-example: "0.0.0.0/0"
	// List of CIDRs to filter Kubernetes node IPs against when autoExportPolicy is enabled
	AutoExportCidrs *views.PrefixStringListType `protobuf:"bytes,13,opt,name=auto_export_cidrs,json=autoExportCidrs,proto3" json:"auto_export_cidrs,omitempty"`
	// Storage Prefix
	//
	// x-displayName: "Storage Prefix"
	// x-example: "trident"
	// Prefix used when provisioning new volumes in the SVM. Once set this cannot be updated
	StoragePrefix string `protobuf:"bytes,14,opt,name=storage_prefix,json=storagePrefix,proto3" json:"storage_prefix,omitempty"`
	// Limit Aggregate Usage
	//
	// x-displayName: "Limit Aggregate Usage"
	// x-example: "80%"
	// Fail provisioning if usage is above this percentage. Not enforced by default.
	LimitAggregateUsage string `protobuf:"bytes,15,opt,name=limit_aggregate_usage,json=limitAggregateUsage,proto3" json:"limit_aggregate_usage,omitempty"`
	// Limit Volume Size
	//
	// x-displayName: "Limit Volume Size"
	// x-example: "50Gi"
	// Fail provisioning if requested volume size is above this value. Not enforced by default.
	LimitVolumeSize string `protobuf:"bytes,16,opt,name=limit_volume_size,json=limitVolumeSize,proto3" json:"limit_volume_size,omitempty"`
	// NFS Mount Options
	//
	// x-displayName: "NFS Mount Options"
	// x-example: "nfsvers=4"
	// Comma-separated list of NFS mount options. Not enforced by default.
	NfsMountOptions string `protobuf:"bytes,17,opt,name=nfs_mount_options,json=nfsMountOptions,proto3" json:"nfs_mount_options,omitempty"`
	// Backend Volume Defaults
	//
	// x-displayName: "Backend Volume Defaults"
	// List of QoS volume defaults types
	VolumeDefaults *OntapVolumeDefaults `protobuf:"bytes,18,opt,name=volume_defaults,json=volumeDefaults,proto3" json:"volume_defaults,omitempty"`
	// Backend Labels
	//
	// x-displayName: "Backend Labels"
	// x-example: "{"store":"nas_store"}"
	// List of labels for Storage Device used in NetApp ONTAP. It is used for storage class selection.
	Labels map[string]string `protobuf:"bytes,19,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Backend Region
	//
	// x-displayName: "Backend Region"
	// x-example: "us_east_1b"
	// Virtual Pool Region
	Region string `protobuf:"bytes,20,opt,name=region,proto3" json:"region,omitempty"`
	// Virtual Storage Pools
	//
	// x-displayName: "Virtual Storage Pools"
	// List of Virtual Storage Pool definitions which are referred back by Storage Class label match selection.
	Storage []*OntapVirtualStoragePoolType `protobuf:"bytes,21,rep,name=storage,proto3" json:"storage,omitempty"`
	// Client Certificate
	//
	// x-displayName: "Client Certificate"
	// Please Enter Base64-encoded value of client certificate. Used for certificate-based auth.
	ClientCertificate string `protobuf:"bytes,22,opt,name=client_certificate,json=clientCertificate,proto3" json:"client_certificate,omitempty"`
	// Client Private Key
	//
	// x-displayName: "Client Private Key"
	// Please Enter value of client private key. Used for certificate-based auth.
	ClientPrivateKey *schema.SecretType `protobuf:"bytes,23,opt,name=client_private_key,json=clientPrivateKey,proto3" json:"client_private_key,omitempty"`
	// Trusted CA Certificate
	//
	// x-displayName: "Trusted CA Certificate"
	// Please Enter Base64-encoded value of trusted CA certificate. Optional. Used for certificate-based auth..
	TrustedCaCertificate string `protobuf:"bytes,24,opt,name=trusted_ca_certificate,json=trustedCaCertificate,proto3" json:"trusted_ca_certificate,omitempty"`
}

func (m *StorageDeviceNetappBackendOntapNasType) Reset() {
	*m = StorageDeviceNetappBackendOntapNasType{}
}
func (*StorageDeviceNetappBackendOntapNasType) ProtoMessage() {}
func (*StorageDeviceNetappBackendOntapNasType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{18}
}
func (m *StorageDeviceNetappBackendOntapNasType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageDeviceNetappBackendOntapNasType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StorageDeviceNetappBackendOntapNasType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageDeviceNetappBackendOntapNasType.Merge(m, src)
}
func (m *StorageDeviceNetappBackendOntapNasType) XXX_Size() int {
	return m.Size()
}
func (m *StorageDeviceNetappBackendOntapNasType) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageDeviceNetappBackendOntapNasType.DiscardUnknown(m)
}

var xxx_messageInfo_StorageDeviceNetappBackendOntapNasType proto.InternalMessageInfo

type isStorageDeviceNetappBackendOntapNasType_ManagementLif interface {
	isStorageDeviceNetappBackendOntapNasType_ManagementLif()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isStorageDeviceNetappBackendOntapNasType_DataLif interface {
	isStorageDeviceNetappBackendOntapNasType_DataLif()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type StorageDeviceNetappBackendOntapNasType_ManagementLifIp struct {
	ManagementLifIp string `protobuf:"bytes,4,opt,name=management_lif_ip,json=managementLifIp,proto3,oneof" json:"management_lif_ip,omitempty"`
}
type StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName struct {
	ManagementLifDnsName string `protobuf:"bytes,5,opt,name=management_lif_dns_name,json=managementLifDnsName,proto3,oneof" json:"management_lif_dns_name,omitempty"`
}
type StorageDeviceNetappBackendOntapNasType_DataLifIp struct {
	DataLifIp string `protobuf:"bytes,7,opt,name=data_lif_ip,json=dataLifIp,proto3,oneof" json:"data_lif_ip,omitempty"`
}
type StorageDeviceNetappBackendOntapNasType_DataLifDnsName struct {
	DataLifDnsName string `protobuf:"bytes,8,opt,name=data_lif_dns_name,json=dataLifDnsName,proto3,oneof" json:"data_lif_dns_name,omitempty"`
}

func (*StorageDeviceNetappBackendOntapNasType_ManagementLifIp) isStorageDeviceNetappBackendOntapNasType_ManagementLif() {
}
func (*StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName) isStorageDeviceNetappBackendOntapNasType_ManagementLif() {
}
func (*StorageDeviceNetappBackendOntapNasType_DataLifIp) isStorageDeviceNetappBackendOntapNasType_DataLif() {
}
func (*StorageDeviceNetappBackendOntapNasType_DataLifDnsName) isStorageDeviceNetappBackendOntapNasType_DataLif() {
}

func (m *StorageDeviceNetappBackendOntapNasType) GetManagementLif() isStorageDeviceNetappBackendOntapNasType_ManagementLif {
	if m != nil {
		return m.ManagementLif
	}
	return nil
}
func (m *StorageDeviceNetappBackendOntapNasType) GetDataLif() isStorageDeviceNetappBackendOntapNasType_DataLif {
	if m != nil {
		return m.DataLif
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapNasType) GetStorageDriverName() string {
	if m != nil {
		return m.StorageDriverName
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetBackendName() string {
	if m != nil {
		return m.BackendName
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetManagementLifIp() string {
	if x, ok := m.GetManagementLif().(*StorageDeviceNetappBackendOntapNasType_ManagementLifIp); ok {
		return x.ManagementLifIp
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetManagementLifDnsName() string {
	if x, ok := m.GetManagementLif().(*StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName); ok {
		return x.ManagementLifDnsName
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetDataLifIp() string {
	if x, ok := m.GetDataLif().(*StorageDeviceNetappBackendOntapNasType_DataLifIp); ok {
		return x.DataLifIp
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetDataLifDnsName() string {
	if x, ok := m.GetDataLif().(*StorageDeviceNetappBackendOntapNasType_DataLifDnsName); ok {
		return x.DataLifDnsName
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetSvm() string {
	if m != nil {
		return m.Svm
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetPassword() *schema.SecretType {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapNasType) GetAutoExportPolicy() bool {
	if m != nil {
		return m.AutoExportPolicy
	}
	return false
}

func (m *StorageDeviceNetappBackendOntapNasType) GetAutoExportCidrs() *views.PrefixStringListType {
	if m != nil {
		return m.AutoExportCidrs
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapNasType) GetStoragePrefix() string {
	if m != nil {
		return m.StoragePrefix
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetLimitAggregateUsage() string {
	if m != nil {
		return m.LimitAggregateUsage
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetLimitVolumeSize() string {
	if m != nil {
		return m.LimitVolumeSize
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetNfsMountOptions() string {
	if m != nil {
		return m.NfsMountOptions
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetVolumeDefaults() *OntapVolumeDefaults {
	if m != nil {
		return m.VolumeDefaults
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapNasType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapNasType) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetStorage() []*OntapVirtualStoragePoolType {
	if m != nil {
		return m.Storage
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapNasType) GetClientCertificate() string {
	if m != nil {
		return m.ClientCertificate
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetClientPrivateKey() *schema.SecretType {
	if m != nil {
		return m.ClientPrivateKey
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapNasType) GetTrustedCaCertificate() string {
	if m != nil {
		return m.TrustedCaCertificate
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StorageDeviceNetappBackendOntapNasType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StorageDeviceNetappBackendOntapNasType_ManagementLifIp)(nil),
		(*StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName)(nil),
		(*StorageDeviceNetappBackendOntapNasType_DataLifIp)(nil),
		(*StorageDeviceNetappBackendOntapNasType_DataLifDnsName)(nil),
	}
}

// Backend OnTap Volume Defaults
//
// x-displayName: "Backend OnTap Volume Defaults"
// It controls how each volume is provisioned by default using these options in a special section of the configuration.
type OntapVolumeDefaults struct {
	// Space Reservation Mode
	//
	// x-displayName: "Space Reservation Mode"
	// x-example: "thick"
	// Space reservation mode; none (thin) or volume (thick)
	SpaceReserve string `protobuf:"bytes,1,opt,name=space_reserve,json=spaceReserve,proto3" json:"space_reserve,omitempty"`
	// Snapshot Policy
	//
	// x-displayName: "Snapshot Policy"
	// x-example: "none"
	// Snapshot policy to use
	SnapshotPolicy string `protobuf:"bytes,2,opt,name=snapshot_policy,json=snapshotPolicy,proto3" json:"snapshot_policy,omitempty"`
	// Snapshot Rerserved
	//
	// x-displayName: "Snapshot Reserved"
	// x-example: "10"
	// Percentage of volume reserved for snapshots. "0" if snapshot policy is "none", else ""
	SnapshotReserve string `protobuf:"bytes,3,opt,name=snapshot_reserve,json=snapshotReserve,proto3" json:"snapshot_reserve,omitempty"`
	// Split on Clone
	//
	// x-displayName: "Split on Clone"
	// x-example: "false"
	// Split a clone from its parent upon creation.
	SplitOnClone bool `protobuf:"varint,4,opt,name=split_on_clone,json=splitOnClone,proto3" json:"split_on_clone,omitempty"`
	// Enable Encryption
	//
	// x-displayName: "Enable Encryption"
	// x-example: "false"
	// Enable NetApp volume encryption.
	Encryption bool `protobuf:"varint,5,opt,name=encryption,proto3" json:"encryption,omitempty"`
	// Unix Mode Permissions
	//
	// x-displayName: "Unix Mode Permissions"
	// x-example: "777"
	// Unix permission mode for new volumes. All allowed 777
	UnixPermissions int32 `protobuf:"varint,6,opt,name=unix_permissions,json=unixPermissions,proto3" json:"unix_permissions,omitempty"`
	// Access to Snapshot Directory
	//
	// x-displayName: "Access to Snapshot Directory"
	// Access to the .snapshot directory.
	SnapshotDir bool `protobuf:"varint,7,opt,name=snapshot_dir,json=snapshotDir,proto3" json:"snapshot_dir,omitempty"`
	// Export Policy
	//
	// x-displayName: "Export Policy"
	// x-example: "default"
	// Export policy to use.
	ExportPolicy string `protobuf:"bytes,8,opt,name=export_policy,json=exportPolicy,proto3" json:"export_policy,omitempty"`
	// Security Style
	//
	// x-displayName: "Security Style"
	// x-example: "unix"
	// Security style for new volumes.
	SecurityStyle string `protobuf:"bytes,9,opt,name=security_style,json=securityStyle,proto3" json:"security_style,omitempty"`
	// Tiering Policy
	//
	// x-displayName: "Tiering Policy"
	// x-example: "snapshot-only"
	// Tiering policy to use. "none" is default.
	TieringPolicy string `protobuf:"bytes,10,opt,name=tiering_policy,json=tieringPolicy,proto3" json:"tiering_policy,omitempty"`
	// QoS Policy
	//
	// x-displayName: "QoS Policy"
	// x-required
	// Choose one of QoS Policy or Adaptive QoS Policy per storage pool/backend.
	//
	// Types that are valid to be assigned to QosPolicyChoice:
	//	*OntapVolumeDefaults_NoQos
	//	*OntapVolumeDefaults_QosPolicy
	//	*OntapVolumeDefaults_AdaptiveQosPolicy
	QosPolicyChoice isOntapVolumeDefaults_QosPolicyChoice `protobuf_oneof:"qos_policy_choice"`
}

func (m *OntapVolumeDefaults) Reset()      { *m = OntapVolumeDefaults{} }
func (*OntapVolumeDefaults) ProtoMessage() {}
func (*OntapVolumeDefaults) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{19}
}
func (m *OntapVolumeDefaults) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OntapVolumeDefaults) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OntapVolumeDefaults) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OntapVolumeDefaults.Merge(m, src)
}
func (m *OntapVolumeDefaults) XXX_Size() int {
	return m.Size()
}
func (m *OntapVolumeDefaults) XXX_DiscardUnknown() {
	xxx_messageInfo_OntapVolumeDefaults.DiscardUnknown(m)
}

var xxx_messageInfo_OntapVolumeDefaults proto.InternalMessageInfo

type isOntapVolumeDefaults_QosPolicyChoice interface {
	isOntapVolumeDefaults_QosPolicyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type OntapVolumeDefaults_NoQos struct {
	NoQos *schema.Empty `protobuf:"bytes,12,opt,name=no_qos,json=noQos,proto3,oneof" json:"no_qos,omitempty"`
}
type OntapVolumeDefaults_QosPolicy struct {
	QosPolicy string `protobuf:"bytes,13,opt,name=qos_policy,json=qosPolicy,proto3,oneof" json:"qos_policy,omitempty"`
}
type OntapVolumeDefaults_AdaptiveQosPolicy struct {
	AdaptiveQosPolicy string `protobuf:"bytes,14,opt,name=adaptive_qos_policy,json=adaptiveQosPolicy,proto3,oneof" json:"adaptive_qos_policy,omitempty"`
}

func (*OntapVolumeDefaults_NoQos) isOntapVolumeDefaults_QosPolicyChoice()             {}
func (*OntapVolumeDefaults_QosPolicy) isOntapVolumeDefaults_QosPolicyChoice()         {}
func (*OntapVolumeDefaults_AdaptiveQosPolicy) isOntapVolumeDefaults_QosPolicyChoice() {}

func (m *OntapVolumeDefaults) GetQosPolicyChoice() isOntapVolumeDefaults_QosPolicyChoice {
	if m != nil {
		return m.QosPolicyChoice
	}
	return nil
}

func (m *OntapVolumeDefaults) GetSpaceReserve() string {
	if m != nil {
		return m.SpaceReserve
	}
	return ""
}

func (m *OntapVolumeDefaults) GetSnapshotPolicy() string {
	if m != nil {
		return m.SnapshotPolicy
	}
	return ""
}

func (m *OntapVolumeDefaults) GetSnapshotReserve() string {
	if m != nil {
		return m.SnapshotReserve
	}
	return ""
}

func (m *OntapVolumeDefaults) GetSplitOnClone() bool {
	if m != nil {
		return m.SplitOnClone
	}
	return false
}

func (m *OntapVolumeDefaults) GetEncryption() bool {
	if m != nil {
		return m.Encryption
	}
	return false
}

func (m *OntapVolumeDefaults) GetUnixPermissions() int32 {
	if m != nil {
		return m.UnixPermissions
	}
	return 0
}

func (m *OntapVolumeDefaults) GetSnapshotDir() bool {
	if m != nil {
		return m.SnapshotDir
	}
	return false
}

func (m *OntapVolumeDefaults) GetExportPolicy() string {
	if m != nil {
		return m.ExportPolicy
	}
	return ""
}

func (m *OntapVolumeDefaults) GetSecurityStyle() string {
	if m != nil {
		return m.SecurityStyle
	}
	return ""
}

func (m *OntapVolumeDefaults) GetTieringPolicy() string {
	if m != nil {
		return m.TieringPolicy
	}
	return ""
}

func (m *OntapVolumeDefaults) GetNoQos() *schema.Empty {
	if x, ok := m.GetQosPolicyChoice().(*OntapVolumeDefaults_NoQos); ok {
		return x.NoQos
	}
	return nil
}

func (m *OntapVolumeDefaults) GetQosPolicy() string {
	if x, ok := m.GetQosPolicyChoice().(*OntapVolumeDefaults_QosPolicy); ok {
		return x.QosPolicy
	}
	return ""
}

func (m *OntapVolumeDefaults) GetAdaptiveQosPolicy() string {
	if x, ok := m.GetQosPolicyChoice().(*OntapVolumeDefaults_AdaptiveQosPolicy); ok {
		return x.AdaptiveQosPolicy
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OntapVolumeDefaults) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OntapVolumeDefaults_NoQos)(nil),
		(*OntapVolumeDefaults_QosPolicy)(nil),
		(*OntapVolumeDefaults_AdaptiveQosPolicy)(nil),
	}
}

// Backend ONTAP Virtual Storage Pool
//
// x-displayName: "Backend ONTAP Virtual Storage Pool"
// ONTAP Virtual Storage Pool definition
type OntapVirtualStoragePoolType struct {
	// Storage Pool Labels
	//
	// x-displayName: "Storage Pool Labels"
	// x-example: "{"department":"finance", "creditpoints":"6000"}"
	// List of labels for Storage Device used in NetApp ONTAP. It is used for storage class label match selection.
	Labels map[string]string `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Pool Zone
	//
	// x-displayName: "Virtual Pool Zone"
	// x-example: "us_east_1b"
	// Virtual Storage Pool zone definition.
	Zone string `protobuf:"bytes,2,opt,name=zone,proto3" json:"zone,omitempty"`
	// Backend Volume Defaults
	//
	// x-displayName: "Backend Volume Defaults"
	// List of QoS volume default types
	VolumeDefaults *OntapVolumeDefaults `protobuf:"bytes,3,opt,name=volume_defaults,json=volumeDefaults,proto3" json:"volume_defaults,omitempty"`
}

func (m *OntapVirtualStoragePoolType) Reset()      { *m = OntapVirtualStoragePoolType{} }
func (*OntapVirtualStoragePoolType) ProtoMessage() {}
func (*OntapVirtualStoragePoolType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{20}
}
func (m *OntapVirtualStoragePoolType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OntapVirtualStoragePoolType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OntapVirtualStoragePoolType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OntapVirtualStoragePoolType.Merge(m, src)
}
func (m *OntapVirtualStoragePoolType) XXX_Size() int {
	return m.Size()
}
func (m *OntapVirtualStoragePoolType) XXX_DiscardUnknown() {
	xxx_messageInfo_OntapVirtualStoragePoolType.DiscardUnknown(m)
}

var xxx_messageInfo_OntapVirtualStoragePoolType proto.InternalMessageInfo

func (m *OntapVirtualStoragePoolType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *OntapVirtualStoragePoolType) GetZone() string {
	if m != nil {
		return m.Zone
	}
	return ""
}

func (m *OntapVirtualStoragePoolType) GetVolumeDefaults() *OntapVolumeDefaults {
	if m != nil {
		return m.VolumeDefaults
	}
	return nil
}

// Storage Device
//
// x-displayName: "Storage Device"
// Configuration of storage device
type FleetStorageDeviceType struct {
	// Storage Device
	//
	// x-displayName: "Storage Device"
	// x-required
	// x-example "DellEMC-isilon-F800-0"
	// Storage device and device unit
	StorageDevice string `protobuf:"bytes,1,opt,name=storage_device,json=storageDevice,proto3" json:"storage_device,omitempty"`
	// Select Storage Device Configuration
	//
	// x-displayName: "Select Storage Device to Configure"
	// x-required
	// Select type of storage device driver to configure
	//
	// Types that are valid to be assigned to DeviceChoice:
	//	*FleetStorageDeviceType_NetappTrident
	//	*FleetStorageDeviceType_PureServiceOrchestrator
	//	*FleetStorageDeviceType_OpenebsEnterprise
	//	*FleetStorageDeviceType_CustomStorage
	DeviceChoice isFleetStorageDeviceType_DeviceChoice `protobuf_oneof:"device_choice"`
	// Advanced Parameters
	//
	// x-displayName: "Advanced Parameters"
	// Map of parameter name and string value
	AdvancedAdvancedParameters map[string]string `protobuf:"bytes,5,rep,name=advanced_advanced_parameters,json=advancedAdvancedParameters,proto3" json:"advanced_advanced_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FleetStorageDeviceType) Reset()      { *m = FleetStorageDeviceType{} }
func (*FleetStorageDeviceType) ProtoMessage() {}
func (*FleetStorageDeviceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{21}
}
func (m *FleetStorageDeviceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FleetStorageDeviceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FleetStorageDeviceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FleetStorageDeviceType.Merge(m, src)
}
func (m *FleetStorageDeviceType) XXX_Size() int {
	return m.Size()
}
func (m *FleetStorageDeviceType) XXX_DiscardUnknown() {
	xxx_messageInfo_FleetStorageDeviceType.DiscardUnknown(m)
}

var xxx_messageInfo_FleetStorageDeviceType proto.InternalMessageInfo

type isFleetStorageDeviceType_DeviceChoice interface {
	isFleetStorageDeviceType_DeviceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type FleetStorageDeviceType_NetappTrident struct {
	NetappTrident *StorageDeviceNetappTridentType `protobuf:"bytes,6,opt,name=netapp_trident,json=netappTrident,proto3,oneof" json:"netapp_trident,omitempty"`
}
type FleetStorageDeviceType_PureServiceOrchestrator struct {
	PureServiceOrchestrator *StorageDevicePureStorageServiceOrchestratorType `protobuf:"bytes,7,opt,name=pure_service_orchestrator,json=pureServiceOrchestrator,proto3,oneof" json:"pure_service_orchestrator,omitempty"`
}
type FleetStorageDeviceType_OpenebsEnterprise struct {
	OpenebsEnterprise *StorageDeviceOpenebsEnterpriseType `protobuf:"bytes,8,opt,name=openebs_enterprise,json=openebsEnterprise,proto3,oneof" json:"openebs_enterprise,omitempty"`
}
type FleetStorageDeviceType_CustomStorage struct {
	CustomStorage *schema.Empty `protobuf:"bytes,9,opt,name=custom_storage,json=customStorage,proto3,oneof" json:"custom_storage,omitempty"`
}

func (*FleetStorageDeviceType_NetappTrident) isFleetStorageDeviceType_DeviceChoice()           {}
func (*FleetStorageDeviceType_PureServiceOrchestrator) isFleetStorageDeviceType_DeviceChoice() {}
func (*FleetStorageDeviceType_OpenebsEnterprise) isFleetStorageDeviceType_DeviceChoice()       {}
func (*FleetStorageDeviceType_CustomStorage) isFleetStorageDeviceType_DeviceChoice()           {}

func (m *FleetStorageDeviceType) GetDeviceChoice() isFleetStorageDeviceType_DeviceChoice {
	if m != nil {
		return m.DeviceChoice
	}
	return nil
}

func (m *FleetStorageDeviceType) GetStorageDevice() string {
	if m != nil {
		return m.StorageDevice
	}
	return ""
}

func (m *FleetStorageDeviceType) GetNetappTrident() *StorageDeviceNetappTridentType {
	if x, ok := m.GetDeviceChoice().(*FleetStorageDeviceType_NetappTrident); ok {
		return x.NetappTrident
	}
	return nil
}

func (m *FleetStorageDeviceType) GetPureServiceOrchestrator() *StorageDevicePureStorageServiceOrchestratorType {
	if x, ok := m.GetDeviceChoice().(*FleetStorageDeviceType_PureServiceOrchestrator); ok {
		return x.PureServiceOrchestrator
	}
	return nil
}

func (m *FleetStorageDeviceType) GetOpenebsEnterprise() *StorageDeviceOpenebsEnterpriseType {
	if x, ok := m.GetDeviceChoice().(*FleetStorageDeviceType_OpenebsEnterprise); ok {
		return x.OpenebsEnterprise
	}
	return nil
}

func (m *FleetStorageDeviceType) GetCustomStorage() *schema.Empty {
	if x, ok := m.GetDeviceChoice().(*FleetStorageDeviceType_CustomStorage); ok {
		return x.CustomStorage
	}
	return nil
}

func (m *FleetStorageDeviceType) GetAdvancedAdvancedParameters() map[string]string {
	if m != nil {
		return m.AdvancedAdvancedParameters
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FleetStorageDeviceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FleetStorageDeviceType_NetappTrident)(nil),
		(*FleetStorageDeviceType_PureServiceOrchestrator)(nil),
		(*FleetStorageDeviceType_OpenebsEnterprise)(nil),
		(*FleetStorageDeviceType_CustomStorage)(nil),
	}
}

// Custom Storage Device List
//
// x-displayName: "Custom Storage Device List"
// Add additional custom storage classes in kubernetes for this fleet
type FleetStorageDeviceListType struct {
	// List of Storage Devices
	//
	// x-displayName: "List of Storage Devices"
	// List of custom storage devices
	StorageDevices []*FleetStorageDeviceType `protobuf:"bytes,1,rep,name=storage_devices,json=storageDevices,proto3" json:"storage_devices,omitempty"`
}

func (m *FleetStorageDeviceListType) Reset()      { *m = FleetStorageDeviceListType{} }
func (*FleetStorageDeviceListType) ProtoMessage() {}
func (*FleetStorageDeviceListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{22}
}
func (m *FleetStorageDeviceListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FleetStorageDeviceListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FleetStorageDeviceListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FleetStorageDeviceListType.Merge(m, src)
}
func (m *FleetStorageDeviceListType) XXX_Size() int {
	return m.Size()
}
func (m *FleetStorageDeviceListType) XXX_DiscardUnknown() {
	xxx_messageInfo_FleetStorageDeviceListType.DiscardUnknown(m)
}

var xxx_messageInfo_FleetStorageDeviceListType proto.InternalMessageInfo

func (m *FleetStorageDeviceListType) GetStorageDevices() []*FleetStorageDeviceType {
	if m != nil {
		return m.StorageDevices
	}
	return nil
}

// Dell EMC isilon F800
//
// x-displayName: "Dell EMC isilon F800"
// Storage class configuration for Dell EMC isilon F800
type StorageClassDellIsilonF800Type struct {
	//  Select Az Service address
	//
	// x-displayName: "Select Az Service address"
	// x-required
	// Select how to reach Az Service.
	//
	// Types that are valid to be assigned to HttpsChoice:
	//	*StorageClassDellIsilonF800Type_AzServiceName
	//	*StorageClassDellIsilonF800Type_AzServiceIpAddress
	HttpsChoice isStorageClassDellIsilonF800Type_HttpsChoice `protobuf_oneof:"https_choice"`
	// iSCSI Access Zone
	//
	// x-displayName: "iSCSI Access Zone"
	// x-example: "System"
	// The name of the access zone, a volume can be created in
	IscsiAccessZone string `protobuf:"bytes,4,opt,name=iscsi_access_zone,json=iscsiAccessZone,proto3" json:"iscsi_access_zone,omitempty"`
	// Base Path
	//
	// x-displayName: "Base Path
	// x-example: "/ifs/data/csi"
	// Base path for the volume to be created, Ensure that this path exists on Isilon.
	BasePath string `protobuf:"bytes,5,opt,name=base_path,json=basePath,proto3" json:"base_path,omitempty"`
	// title
	//
	// x-displayName: "Enable Root Client"
	// Determines, when a node mounts the PVC, in NodeStageVolume, whether to add the K8s node to
	// the "Root clients" field (when true) or "Clients" field (when false) of the NFS export
	RootClientEnable bool `protobuf:"varint,6,opt,name=root_client_enable,json=rootClientEnable,proto3" json:"root_client_enable,omitempty"`
}

func (m *StorageClassDellIsilonF800Type) Reset()      { *m = StorageClassDellIsilonF800Type{} }
func (*StorageClassDellIsilonF800Type) ProtoMessage() {}
func (*StorageClassDellIsilonF800Type) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{23}
}
func (m *StorageClassDellIsilonF800Type) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageClassDellIsilonF800Type) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StorageClassDellIsilonF800Type) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageClassDellIsilonF800Type.Merge(m, src)
}
func (m *StorageClassDellIsilonF800Type) XXX_Size() int {
	return m.Size()
}
func (m *StorageClassDellIsilonF800Type) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageClassDellIsilonF800Type.DiscardUnknown(m)
}

var xxx_messageInfo_StorageClassDellIsilonF800Type proto.InternalMessageInfo

type isStorageClassDellIsilonF800Type_HttpsChoice interface {
	isStorageClassDellIsilonF800Type_HttpsChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type StorageClassDellIsilonF800Type_AzServiceName struct {
	AzServiceName string `protobuf:"bytes,2,opt,name=az_service_name,json=azServiceName,proto3,oneof" json:"az_service_name,omitempty"`
}
type StorageClassDellIsilonF800Type_AzServiceIpAddress struct {
	AzServiceIpAddress string `protobuf:"bytes,3,opt,name=az_service_ip_address,json=azServiceIpAddress,proto3,oneof" json:"az_service_ip_address,omitempty"`
}

func (*StorageClassDellIsilonF800Type_AzServiceName) isStorageClassDellIsilonF800Type_HttpsChoice() {}
func (*StorageClassDellIsilonF800Type_AzServiceIpAddress) isStorageClassDellIsilonF800Type_HttpsChoice() {
}

func (m *StorageClassDellIsilonF800Type) GetHttpsChoice() isStorageClassDellIsilonF800Type_HttpsChoice {
	if m != nil {
		return m.HttpsChoice
	}
	return nil
}

func (m *StorageClassDellIsilonF800Type) GetAzServiceName() string {
	if x, ok := m.GetHttpsChoice().(*StorageClassDellIsilonF800Type_AzServiceName); ok {
		return x.AzServiceName
	}
	return ""
}

func (m *StorageClassDellIsilonF800Type) GetAzServiceIpAddress() string {
	if x, ok := m.GetHttpsChoice().(*StorageClassDellIsilonF800Type_AzServiceIpAddress); ok {
		return x.AzServiceIpAddress
	}
	return ""
}

func (m *StorageClassDellIsilonF800Type) GetIscsiAccessZone() string {
	if m != nil {
		return m.IscsiAccessZone
	}
	return ""
}

func (m *StorageClassDellIsilonF800Type) GetBasePath() string {
	if m != nil {
		return m.BasePath
	}
	return ""
}

func (m *StorageClassDellIsilonF800Type) GetRootClientEnable() bool {
	if m != nil {
		return m.RootClientEnable
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StorageClassDellIsilonF800Type) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StorageClassDellIsilonF800Type_AzServiceName)(nil),
		(*StorageClassDellIsilonF800Type_AzServiceIpAddress)(nil),
	}
}

// HPE Nimbus Storage AF40
//
// x-displayName: "HPE Nimbus Storage AF40"
// Storage class Device configuration for HPE Nimbus Storage AF40
type StorageClassHPENimbusStorageAf40Type struct {
	// Performance Policy
	//
	// x-displayName: "Performance Policy"
	// x-example: "Other"
	// Performance Policy for this storage Class
	PerfPolicy string `protobuf:"bytes,1,opt,name=perf_policy,json=perfPolicy,proto3" json:"perf_policy,omitempty"`
	// IOP Limit
	//
	// x-displayName: "IOP Limit"
	// x-example: "76800"
	// I/O operations per second limit for this storage class
	LimitIops uint32 `protobuf:"varint,2,opt,name=limit_iops,json=limitIops,proto3" json:"limit_iops,omitempty"`
	// MBPS Limit
	//
	// x-displayName: "MBPS Limit"
	// x-example: "10000"
	// Mega Byte per second data thruput limit.
	LimitMbps uint32 `protobuf:"varint,3,opt,name=limit_mbps,json=limitMbps,proto3" json:"limit_mbps,omitempty"`
}

func (m *StorageClassHPENimbusStorageAf40Type) Reset()      { *m = StorageClassHPENimbusStorageAf40Type{} }
func (*StorageClassHPENimbusStorageAf40Type) ProtoMessage() {}
func (*StorageClassHPENimbusStorageAf40Type) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{24}
}
func (m *StorageClassHPENimbusStorageAf40Type) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageClassHPENimbusStorageAf40Type) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StorageClassHPENimbusStorageAf40Type) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageClassHPENimbusStorageAf40Type.Merge(m, src)
}
func (m *StorageClassHPENimbusStorageAf40Type) XXX_Size() int {
	return m.Size()
}
func (m *StorageClassHPENimbusStorageAf40Type) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageClassHPENimbusStorageAf40Type.DiscardUnknown(m)
}

var xxx_messageInfo_StorageClassHPENimbusStorageAf40Type proto.InternalMessageInfo

func (m *StorageClassHPENimbusStorageAf40Type) GetPerfPolicy() string {
	if m != nil {
		return m.PerfPolicy
	}
	return ""
}

func (m *StorageClassHPENimbusStorageAf40Type) GetLimitIops() uint32 {
	if m != nil {
		return m.LimitIops
	}
	return 0
}

func (m *StorageClassHPENimbusStorageAf40Type) GetLimitMbps() uint32 {
	if m != nil {
		return m.LimitMbps
	}
	return 0
}

// OpenEBS Enterprise
//
// x-displayName: "OpenEBS Enterprise"
// Storage class Device configuration for OpenEBS Enterprise
type StorageClassOpenebsEnterpriseType struct {
	// Protocol
	//
	// x-displayName: "Protocol"
	// x-example: "nvmf"
	// Defines type of transport protocol used to mount the PV to the worker node hosting the associated application pod (NVMe-oF)
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Replication
	//
	// x-displayName: "Replication"
	// x-example: "1"
	// Replication sets the replication factor of the PV, i.e. the number of data replicas to be maintained for it such as 1 or 3.
	Replication int32 `protobuf:"varint,2,opt,name=replication,proto3" json:"replication,omitempty"`
}

func (m *StorageClassOpenebsEnterpriseType) Reset()      { *m = StorageClassOpenebsEnterpriseType{} }
func (*StorageClassOpenebsEnterpriseType) ProtoMessage() {}
func (*StorageClassOpenebsEnterpriseType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{25}
}
func (m *StorageClassOpenebsEnterpriseType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageClassOpenebsEnterpriseType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StorageClassOpenebsEnterpriseType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageClassOpenebsEnterpriseType.Merge(m, src)
}
func (m *StorageClassOpenebsEnterpriseType) XXX_Size() int {
	return m.Size()
}
func (m *StorageClassOpenebsEnterpriseType) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageClassOpenebsEnterpriseType.DiscardUnknown(m)
}

var xxx_messageInfo_StorageClassOpenebsEnterpriseType proto.InternalMessageInfo

func (m *StorageClassOpenebsEnterpriseType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *StorageClassOpenebsEnterpriseType) GetReplication() int32 {
	if m != nil {
		return m.Replication
	}
	return 0
}

// NetApp Trident Storage
//
// x-displayName: "NetApp Trident Storage"
// Storage class Device configuration for NetApp Trident
type StorageClassNetappTridentType struct {
	// Selector
	//
	// x-displayName: "Selector"
	// x-example: "protection=silver; creditpoints=20000"
	// Using the Selector field, each StorageClass calls out which virtual pool(s) may be used to host a volume.
	// The volume will have the aspects defined in the chosen virtual pool.
	Selector map[string]string `protobuf:"bytes,1,rep,name=selector,proto3" json:"selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Storage Pools
	//
	// x-displayName: "Storage Pools"
	// x-example: "backend-name1:.*;backend-name2:storagePoolListName"
	// The storagePools parameter is used to further restrict the set of pools that match any specified attributes
	StoragePools string `protobuf:"bytes,2,opt,name=storage_pools,json=storagePools,proto3" json:"storage_pools,omitempty"`
}

func (m *StorageClassNetappTridentType) Reset()      { *m = StorageClassNetappTridentType{} }
func (*StorageClassNetappTridentType) ProtoMessage() {}
func (*StorageClassNetappTridentType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{26}
}
func (m *StorageClassNetappTridentType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageClassNetappTridentType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StorageClassNetappTridentType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageClassNetappTridentType.Merge(m, src)
}
func (m *StorageClassNetappTridentType) XXX_Size() int {
	return m.Size()
}
func (m *StorageClassNetappTridentType) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageClassNetappTridentType.DiscardUnknown(m)
}

var xxx_messageInfo_StorageClassNetappTridentType proto.InternalMessageInfo

func (m *StorageClassNetappTridentType) GetSelector() map[string]string {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *StorageClassNetappTridentType) GetStoragePools() string {
	if m != nil {
		return m.StoragePools
	}
	return ""
}

// Pure Storage Service Orchestrator
//
// x-displayName: "Pure Storage Service Orchestrator"
// Storage class Device configuration for Pure Service Orchestrator
type StorageClassPureServiceOrchestratorType struct {
	// Backend
	//
	// x-displayName: "Backend"
	// x-example: "block"
	// Defines type of Pure storage backend block or file.
	// The volume will have the aspects defined in the chosen virtual pool.
	Backend string `protobuf:"bytes,1,opt,name=backend,proto3" json:"backend,omitempty"`
	// IOPS Limit
	//
	// x-displayName: "IOPS Limit"
	// x-example: "3000"
	// Enable IOPS limitation. It must be between 100 and 100 million. If value is 0, IOPS limit is not defined.
	IopsLimit uint32 `protobuf:"varint,2,opt,name=iops_limit,json=iopsLimit,proto3" json:"iops_limit,omitempty"`
	// Bandwidth Limit
	//
	// x-displayName: "Bandwidth Limit"
	// x-example: "1G"
	// It must be between 1 MB/s and 512 GB/s. Enter the size as a number (bytes must be multiple of 512) or number with a single character unit symbol.
	// Valid unit symbols are K, M, G, representing KiB, MiB, and GiB.
	BandwidthLimit string `protobuf:"bytes,3,opt,name=bandwidth_limit,json=bandwidthLimit,proto3" json:"bandwidth_limit,omitempty"`
}

func (m *StorageClassPureServiceOrchestratorType) Reset() {
	*m = StorageClassPureServiceOrchestratorType{}
}
func (*StorageClassPureServiceOrchestratorType) ProtoMessage() {}
func (*StorageClassPureServiceOrchestratorType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{27}
}
func (m *StorageClassPureServiceOrchestratorType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageClassPureServiceOrchestratorType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StorageClassPureServiceOrchestratorType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageClassPureServiceOrchestratorType.Merge(m, src)
}
func (m *StorageClassPureServiceOrchestratorType) XXX_Size() int {
	return m.Size()
}
func (m *StorageClassPureServiceOrchestratorType) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageClassPureServiceOrchestratorType.DiscardUnknown(m)
}

var xxx_messageInfo_StorageClassPureServiceOrchestratorType proto.InternalMessageInfo

func (m *StorageClassPureServiceOrchestratorType) GetBackend() string {
	if m != nil {
		return m.Backend
	}
	return ""
}

func (m *StorageClassPureServiceOrchestratorType) GetIopsLimit() uint32 {
	if m != nil {
		return m.IopsLimit
	}
	return 0
}

func (m *StorageClassPureServiceOrchestratorType) GetBandwidthLimit() string {
	if m != nil {
		return m.BandwidthLimit
	}
	return ""
}

// Custom StorageClass
//
// x-displayName: "Custom StorageClass"
// Custom Storage Class allows to insert Kubernetes storageclass definition which will be applied into given site.
type StorageClassCustomType struct {
	// Storage Class YAML
	//
	// x-displayName: "Storage Class YAML"
	// K8s YAML for StorageClass
	Yaml string `protobuf:"bytes,1,opt,name=yaml,proto3" json:"yaml,omitempty"`
}

func (m *StorageClassCustomType) Reset()      { *m = StorageClassCustomType{} }
func (*StorageClassCustomType) ProtoMessage() {}
func (*StorageClassCustomType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{28}
}
func (m *StorageClassCustomType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageClassCustomType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StorageClassCustomType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageClassCustomType.Merge(m, src)
}
func (m *StorageClassCustomType) XXX_Size() int {
	return m.Size()
}
func (m *StorageClassCustomType) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageClassCustomType.DiscardUnknown(m)
}

var xxx_messageInfo_StorageClassCustomType proto.InternalMessageInfo

func (m *StorageClassCustomType) GetYaml() string {
	if m != nil {
		return m.Yaml
	}
	return ""
}

// Custom Storage Class
//
// x-displayName: "Custom Storage Class"
// Configuration of custom storage class
type FleetStorageClassType struct {
	// Storage Device
	//
	// x-displayName: "Storage Device"
	// x-example "DellEMC-isilon_F800-0"
	// x-required
	// Storage device that this class will use. The Device name defined at previous step.
	StorageDevice string `protobuf:"bytes,1,opt,name=storage_device,json=storageDevice,proto3" json:"storage_device,omitempty"`
	// Storage Class Description
	//
	// x-displayName: "Storage Class Description"
	// x-example "Volume from my fast storage"
	// Description for this storage class
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Default Storage Class
	//
	// x-displayName: "Default Storage Class"
	// Make this storage class default storage class for the K8s cluster
	DefaultStorageClass bool `protobuf:"varint,3,opt,name=default_storage_class,json=defaultStorageClass,proto3" json:"default_storage_class,omitempty"`
	// Select Storage Class Configuration
	//
	// x-displayName: "Select Storage Class Configuration"
	// x-required
	// Select storage Class configuration
	//
	// Types that are valid to be assigned to DeviceChoice:
	//	*FleetStorageClassType_NetappTrident
	//	*FleetStorageClassType_PureServiceOrchestrator
	//	*FleetStorageClassType_OpenebsEnterprise
	//	*FleetStorageClassType_CustomStorage
	DeviceChoice isFleetStorageClassType_DeviceChoice `protobuf_oneof:"device_choice"`
	// Reclaim Policy
	//
	// x-displayName: "Reclaim Policy"
	// x-example: "Delete"
	// Reclaim Policy
	ReclaimPolicy string `protobuf:"bytes,12,opt,name=reclaim_policy,json=reclaimPolicy,proto3" json:"reclaim_policy,omitempty"`
	// Allow Volume Expansion
	//
	// x-displayName: "Allow Volume Expansion"
	// Allow volume expansion.
	AllowVolumeExpansion bool `protobuf:"varint,13,opt,name=allow_volume_expansion,json=allowVolumeExpansion,proto3" json:"allow_volume_expansion,omitempty"`
	// Advanced Parameters
	//
	// x-displayName: "Advanced Parameters"
	// Map of parameter name and string value
	AdvancedStorageParameters map[string]string `protobuf:"bytes,7,rep,name=advanced_storage_parameters,json=advancedStorageParameters,proto3" json:"advanced_storage_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Storage Class Name
	//
	// x-displayName: "Storage Class Name"
	// x-example: "premium"
	// x-required
	// Name of the storage class as it will appear in K8s.
	StorageClassName string `protobuf:"bytes,8,opt,name=storage_class_name,json=storageClassName,proto3" json:"storage_class_name,omitempty"`
}

func (m *FleetStorageClassType) Reset()      { *m = FleetStorageClassType{} }
func (*FleetStorageClassType) ProtoMessage() {}
func (*FleetStorageClassType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{29}
}
func (m *FleetStorageClassType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FleetStorageClassType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FleetStorageClassType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FleetStorageClassType.Merge(m, src)
}
func (m *FleetStorageClassType) XXX_Size() int {
	return m.Size()
}
func (m *FleetStorageClassType) XXX_DiscardUnknown() {
	xxx_messageInfo_FleetStorageClassType.DiscardUnknown(m)
}

var xxx_messageInfo_FleetStorageClassType proto.InternalMessageInfo

type isFleetStorageClassType_DeviceChoice interface {
	isFleetStorageClassType_DeviceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type FleetStorageClassType_NetappTrident struct {
	NetappTrident *StorageClassNetappTridentType `protobuf:"bytes,9,opt,name=netapp_trident,json=netappTrident,proto3,oneof" json:"netapp_trident,omitempty"`
}
type FleetStorageClassType_PureServiceOrchestrator struct {
	PureServiceOrchestrator *StorageClassPureServiceOrchestratorType `protobuf:"bytes,10,opt,name=pure_service_orchestrator,json=pureServiceOrchestrator,proto3,oneof" json:"pure_service_orchestrator,omitempty"`
}
type FleetStorageClassType_OpenebsEnterprise struct {
	OpenebsEnterprise *StorageClassOpenebsEnterpriseType `protobuf:"bytes,11,opt,name=openebs_enterprise,json=openebsEnterprise,proto3,oneof" json:"openebs_enterprise,omitempty"`
}
type FleetStorageClassType_CustomStorage struct {
	CustomStorage *StorageClassCustomType `protobuf:"bytes,16,opt,name=custom_storage,json=customStorage,proto3,oneof" json:"custom_storage,omitempty"`
}

func (*FleetStorageClassType_NetappTrident) isFleetStorageClassType_DeviceChoice()           {}
func (*FleetStorageClassType_PureServiceOrchestrator) isFleetStorageClassType_DeviceChoice() {}
func (*FleetStorageClassType_OpenebsEnterprise) isFleetStorageClassType_DeviceChoice()       {}
func (*FleetStorageClassType_CustomStorage) isFleetStorageClassType_DeviceChoice()           {}

func (m *FleetStorageClassType) GetDeviceChoice() isFleetStorageClassType_DeviceChoice {
	if m != nil {
		return m.DeviceChoice
	}
	return nil
}

func (m *FleetStorageClassType) GetStorageDevice() string {
	if m != nil {
		return m.StorageDevice
	}
	return ""
}

func (m *FleetStorageClassType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *FleetStorageClassType) GetDefaultStorageClass() bool {
	if m != nil {
		return m.DefaultStorageClass
	}
	return false
}

func (m *FleetStorageClassType) GetNetappTrident() *StorageClassNetappTridentType {
	if x, ok := m.GetDeviceChoice().(*FleetStorageClassType_NetappTrident); ok {
		return x.NetappTrident
	}
	return nil
}

func (m *FleetStorageClassType) GetPureServiceOrchestrator() *StorageClassPureServiceOrchestratorType {
	if x, ok := m.GetDeviceChoice().(*FleetStorageClassType_PureServiceOrchestrator); ok {
		return x.PureServiceOrchestrator
	}
	return nil
}

func (m *FleetStorageClassType) GetOpenebsEnterprise() *StorageClassOpenebsEnterpriseType {
	if x, ok := m.GetDeviceChoice().(*FleetStorageClassType_OpenebsEnterprise); ok {
		return x.OpenebsEnterprise
	}
	return nil
}

func (m *FleetStorageClassType) GetCustomStorage() *StorageClassCustomType {
	if x, ok := m.GetDeviceChoice().(*FleetStorageClassType_CustomStorage); ok {
		return x.CustomStorage
	}
	return nil
}

func (m *FleetStorageClassType) GetReclaimPolicy() string {
	if m != nil {
		return m.ReclaimPolicy
	}
	return ""
}

func (m *FleetStorageClassType) GetAllowVolumeExpansion() bool {
	if m != nil {
		return m.AllowVolumeExpansion
	}
	return false
}

func (m *FleetStorageClassType) GetAdvancedStorageParameters() map[string]string {
	if m != nil {
		return m.AdvancedStorageParameters
	}
	return nil
}

func (m *FleetStorageClassType) GetStorageClassName() string {
	if m != nil {
		return m.StorageClassName
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FleetStorageClassType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FleetStorageClassType_NetappTrident)(nil),
		(*FleetStorageClassType_PureServiceOrchestrator)(nil),
		(*FleetStorageClassType_OpenebsEnterprise)(nil),
		(*FleetStorageClassType_CustomStorage)(nil),
	}
}

// Custom Storage Class List
//
// x-displayName: "Custom Storage Class List"
// Add additional custom storage classes in kubernetes for this fleet
type FleetStorageClassListType struct {
	// List of Storage Classes
	//
	// x-displayName: "List of Storage Classes"
	// List of custom storage classes
	StorageClasses []*FleetStorageClassType `protobuf:"bytes,1,rep,name=storage_classes,json=storageClasses,proto3" json:"storage_classes,omitempty"`
}

func (m *FleetStorageClassListType) Reset()      { *m = FleetStorageClassListType{} }
func (*FleetStorageClassListType) ProtoMessage() {}
func (*FleetStorageClassListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{30}
}
func (m *FleetStorageClassListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FleetStorageClassListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FleetStorageClassListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FleetStorageClassListType.Merge(m, src)
}
func (m *FleetStorageClassListType) XXX_Size() int {
	return m.Size()
}
func (m *FleetStorageClassListType) XXX_DiscardUnknown() {
	xxx_messageInfo_FleetStorageClassListType.DiscardUnknown(m)
}

var xxx_messageInfo_FleetStorageClassListType proto.InternalMessageInfo

func (m *FleetStorageClassListType) GetStorageClasses() []*FleetStorageClassType {
	if m != nil {
		return m.StorageClasses
	}
	return nil
}

// LACP parameters
//
// x-displayName: "LACP parameters
// LACP parameters for the bond device
type BondLacpType struct {
	// Interval
	//
	// x-displayName: "LACP Packet Interval"
	// x-example: "30"
	// Interval in seconds to transmit LACP packets
	Rate uint32 `protobuf:"varint,1,opt,name=rate,proto3" json:"rate,omitempty"`
}

func (m *BondLacpType) Reset()      { *m = BondLacpType{} }
func (*BondLacpType) ProtoMessage() {}
func (*BondLacpType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{31}
}
func (m *BondLacpType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BondLacpType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BondLacpType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BondLacpType.Merge(m, src)
}
func (m *BondLacpType) XXX_Size() int {
	return m.Size()
}
func (m *BondLacpType) XXX_DiscardUnknown() {
	xxx_messageInfo_BondLacpType.DiscardUnknown(m)
}

var xxx_messageInfo_BondLacpType proto.InternalMessageInfo

func (m *BondLacpType) GetRate() uint32 {
	if m != nil {
		return m.Rate
	}
	return 0
}

// Bond Device
//
// x-displayName: "Bond Device"
// Bond devices configuration for fleet
type FleetBondDeviceType struct {
	// Bond Device
	//
	// x-displayName: "Bond Device Name"
	// x-example: "bond0"
	// x-required
	// Bond device name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Member Ethernet Devices
	//
	// x-displayName: "Member Ethernet Devices"
	// x-required
	// Ethernet devices that will make up this bond
	Devices []string `protobuf:"bytes,2,rep,name=devices,proto3" json:"devices,omitempty"`
	// Select Bond Mode
	//
	// x-displayName: "Select Bond Mode"
	// x-required
	// Select how bonding will happen, Active/Backup or LACP
	//
	// Types that are valid to be assigned to LacpChoice:
	//	*FleetBondDeviceType_Lacp
	//	*FleetBondDeviceType_ActiveBackup
	LacpChoice isFleetBondDeviceType_LacpChoice `protobuf_oneof:"lacp_choice"`
	// Link Polling Interval
	//
	// x-displayName: "Link Polling Interval"
	// x-required
	// x-example: "1000"
	// Link polling interval in millisecond
	LinkPollingInterval uint32 `protobuf:"varint,6,opt,name=link_polling_interval,json=linkPollingInterval,proto3" json:"link_polling_interval,omitempty"`
	// Link Up Delay
	//
	// x-displayName: "Link Up Delay"
	// x-required
	// x-example: "200"
	// Milliseconds wait before link is declared up
	LinkUpDelay uint32 `protobuf:"varint,7,opt,name=link_up_delay,json=linkUpDelay,proto3" json:"link_up_delay,omitempty"`
}

func (m *FleetBondDeviceType) Reset()      { *m = FleetBondDeviceType{} }
func (*FleetBondDeviceType) ProtoMessage() {}
func (*FleetBondDeviceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{32}
}
func (m *FleetBondDeviceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FleetBondDeviceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FleetBondDeviceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FleetBondDeviceType.Merge(m, src)
}
func (m *FleetBondDeviceType) XXX_Size() int {
	return m.Size()
}
func (m *FleetBondDeviceType) XXX_DiscardUnknown() {
	xxx_messageInfo_FleetBondDeviceType.DiscardUnknown(m)
}

var xxx_messageInfo_FleetBondDeviceType proto.InternalMessageInfo

type isFleetBondDeviceType_LacpChoice interface {
	isFleetBondDeviceType_LacpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type FleetBondDeviceType_Lacp struct {
	Lacp *BondLacpType `protobuf:"bytes,4,opt,name=lacp,proto3,oneof" json:"lacp,omitempty"`
}
type FleetBondDeviceType_ActiveBackup struct {
	ActiveBackup *schema.Empty `protobuf:"bytes,5,opt,name=active_backup,json=activeBackup,proto3,oneof" json:"active_backup,omitempty"`
}

func (*FleetBondDeviceType_Lacp) isFleetBondDeviceType_LacpChoice()         {}
func (*FleetBondDeviceType_ActiveBackup) isFleetBondDeviceType_LacpChoice() {}

func (m *FleetBondDeviceType) GetLacpChoice() isFleetBondDeviceType_LacpChoice {
	if m != nil {
		return m.LacpChoice
	}
	return nil
}

func (m *FleetBondDeviceType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FleetBondDeviceType) GetDevices() []string {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *FleetBondDeviceType) GetLacp() *BondLacpType {
	if x, ok := m.GetLacpChoice().(*FleetBondDeviceType_Lacp); ok {
		return x.Lacp
	}
	return nil
}

func (m *FleetBondDeviceType) GetActiveBackup() *schema.Empty {
	if x, ok := m.GetLacpChoice().(*FleetBondDeviceType_ActiveBackup); ok {
		return x.ActiveBackup
	}
	return nil
}

func (m *FleetBondDeviceType) GetLinkPollingInterval() uint32 {
	if m != nil {
		return m.LinkPollingInterval
	}
	return 0
}

func (m *FleetBondDeviceType) GetLinkUpDelay() uint32 {
	if m != nil {
		return m.LinkUpDelay
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FleetBondDeviceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FleetBondDeviceType_Lacp)(nil),
		(*FleetBondDeviceType_ActiveBackup)(nil),
	}
}

// Bond Devices List
//
// x-displayName: "Bond Devices List"
// List of bond devices for this fleet
type FleetBondDevicesListType struct {
	// Bond Devices List
	//
	// x-displayName: "Bond Devices List"
	// x-required
	// List of bond devices for this fleet
	BondDevices []*FleetBondDeviceType `protobuf:"bytes,1,rep,name=bond_devices,json=bondDevices,proto3" json:"bond_devices,omitempty"`
}

func (m *FleetBondDevicesListType) Reset()      { *m = FleetBondDevicesListType{} }
func (*FleetBondDevicesListType) ProtoMessage() {}
func (*FleetBondDevicesListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{33}
}
func (m *FleetBondDevicesListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FleetBondDevicesListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FleetBondDevicesListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FleetBondDevicesListType.Merge(m, src)
}
func (m *FleetBondDevicesListType) XXX_Size() int {
	return m.Size()
}
func (m *FleetBondDevicesListType) XXX_DiscardUnknown() {
	xxx_messageInfo_FleetBondDevicesListType.DiscardUnknown(m)
}

var xxx_messageInfo_FleetBondDevicesListType proto.InternalMessageInfo

func (m *FleetBondDevicesListType) GetBondDevices() []*FleetBondDeviceType {
	if m != nil {
		return m.BondDevices
	}
	return nil
}

// Storage Static Routes List
//
// x-displayName: "Storage Static Routes List"
// List of storage static routes
type FleetStorageStaticRoutesListType struct {
	// List of Static Routes
	//
	// x-displayName: "List of Static Routes"
	// x-required
	// List of storage static routes
	StorageRoutes []*schema.StaticRouteType `protobuf:"bytes,1,rep,name=storage_routes,json=storageRoutes,proto3" json:"storage_routes,omitempty"`
}

func (m *FleetStorageStaticRoutesListType) Reset()      { *m = FleetStorageStaticRoutesListType{} }
func (*FleetStorageStaticRoutesListType) ProtoMessage() {}
func (*FleetStorageStaticRoutesListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{34}
}
func (m *FleetStorageStaticRoutesListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FleetStorageStaticRoutesListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FleetStorageStaticRoutesListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FleetStorageStaticRoutesListType.Merge(m, src)
}
func (m *FleetStorageStaticRoutesListType) XXX_Size() int {
	return m.Size()
}
func (m *FleetStorageStaticRoutesListType) XXX_DiscardUnknown() {
	xxx_messageInfo_FleetStorageStaticRoutesListType.DiscardUnknown(m)
}

var xxx_messageInfo_FleetStorageStaticRoutesListType proto.InternalMessageInfo

func (m *FleetStorageStaticRoutesListType) GetStorageRoutes() []*schema.StaticRouteType {
	if m != nil {
		return m.StorageRoutes
	}
	return nil
}

// vGPU Configuration
//
// x-displayName: "vGPU Configuration"
// Licensing configuration for NVIDIA vGPU
type VGPUConfiguration struct {
	// License Server Address
	//
	// x-displayName: "License Server Address"
	// x-example: "gridlicense1.example.com"
	// Set License Server Address
	ServerAddress string `protobuf:"bytes,2,opt,name=server_address,json=serverAddress,proto3" json:"server_address,omitempty"`
	// License Server Port Number
	//
	// x-displayName: "License Server Port Number"
	// Set License Server port number
	ServerPort uint32 `protobuf:"varint,3,opt,name=server_port,json=serverPort,proto3" json:"server_port,omitempty"`
	// Feature Type
	//
	// x-displayName: "Feature Type"
	// x-required
	// Set Feature to be enabled
	FeatureType VGPUFeatureType `protobuf:"varint,6,opt,name=feature_type,json=featureType,proto3,enum=ves.io.schema.fleet.VGPUFeatureType" json:"feature_type,omitempty"`
}

func (m *VGPUConfiguration) Reset()      { *m = VGPUConfiguration{} }
func (*VGPUConfiguration) ProtoMessage() {}
func (*VGPUConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{35}
}
func (m *VGPUConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VGPUConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VGPUConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VGPUConfiguration.Merge(m, src)
}
func (m *VGPUConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *VGPUConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_VGPUConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_VGPUConfiguration proto.InternalMessageInfo

func (m *VGPUConfiguration) GetServerAddress() string {
	if m != nil {
		return m.ServerAddress
	}
	return ""
}

func (m *VGPUConfiguration) GetServerPort() uint32 {
	if m != nil {
		return m.ServerPort
	}
	return 0
}

func (m *VGPUConfiguration) GetFeatureType() VGPUFeatureType {
	if m != nil {
		return m.FeatureType
	}
	return UNLICENSED
}

// VM Configuration
//
// x-displayName: "VM Configuration"
// VMs support configuration
type VMConfiguration struct {
}

func (m *VMConfiguration) Reset()      { *m = VMConfiguration{} }
func (*VMConfiguration) ProtoMessage() {}
func (*VMConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{36}
}
func (m *VMConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VMConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VMConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VMConfiguration.Merge(m, src)
}
func (m *VMConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *VMConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_VMConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_VMConfiguration proto.InternalMessageInfo

// BGP Configuration
//
// x-displayName: "BGP Configuration"
// BGP configuration parameters
type BGPConfiguration struct {
	// ASN
	//
	// x-displayName: "ASN"
	// x-example: 64512
	// x-required
	// Autonomous System Number
	Asn uint32 `protobuf:"varint,3,opt,name=asn,proto3" json:"asn,omitempty"`
	// BGP Peers
	//
	// x-displayName: "Peers"
	// BGP parameters for peer
	Peers []*bgp.Peer `protobuf:"bytes,2,rep,name=peers,proto3" json:"peers,omitempty"`
}

func (m *BGPConfiguration) Reset()      { *m = BGPConfiguration{} }
func (*BGPConfiguration) ProtoMessage() {}
func (*BGPConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{37}
}
func (m *BGPConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BGPConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPConfiguration.Merge(m, src)
}
func (m *BGPConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *BGPConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_BGPConfiguration proto.InternalMessageInfo

func (m *BGPConfiguration) GetAsn() uint32 {
	if m != nil {
		return m.Asn
	}
	return 0
}

func (m *BGPConfiguration) GetPeers() []*bgp.Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

// Local Control Plane
//
// x-displayName: "Local Control Plane"
// Enable local control plane for L3VPN, SRV6, EVPN etc
type LocalControlPlaneType struct {
	// Network Choice
	//
	// x-displayName: "Network for Control Plane"
	// x-required
	// Select local network for local control plane
	//
	// Types that are valid to be assigned to NetworkChoice:
	//	*LocalControlPlaneType_InsideVn
	//	*LocalControlPlaneType_OutsideVn
	NetworkChoice isLocalControlPlaneType_NetworkChoice `protobuf_oneof:"network_choice"`
	// BGP configuration
	//
	// x-displayName: "BGP Configuration"
	// BGP configuration for local control plane
	BgpConfig *BGPConfiguration `protobuf:"bytes,4,opt,name=bgp_config,json=bgpConfig,proto3" json:"bgp_config,omitempty"`
}

func (m *LocalControlPlaneType) Reset()      { *m = LocalControlPlaneType{} }
func (*LocalControlPlaneType) ProtoMessage() {}
func (*LocalControlPlaneType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{38}
}
func (m *LocalControlPlaneType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalControlPlaneType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocalControlPlaneType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalControlPlaneType.Merge(m, src)
}
func (m *LocalControlPlaneType) XXX_Size() int {
	return m.Size()
}
func (m *LocalControlPlaneType) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalControlPlaneType.DiscardUnknown(m)
}

var xxx_messageInfo_LocalControlPlaneType proto.InternalMessageInfo

type isLocalControlPlaneType_NetworkChoice interface {
	isLocalControlPlaneType_NetworkChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LocalControlPlaneType_InsideVn struct {
	InsideVn *schema.Empty `protobuf:"bytes,2,opt,name=inside_vn,json=insideVn,proto3,oneof" json:"inside_vn,omitempty"`
}
type LocalControlPlaneType_OutsideVn struct {
	OutsideVn *schema.Empty `protobuf:"bytes,3,opt,name=outside_vn,json=outsideVn,proto3,oneof" json:"outside_vn,omitempty"`
}

func (*LocalControlPlaneType_InsideVn) isLocalControlPlaneType_NetworkChoice()  {}
func (*LocalControlPlaneType_OutsideVn) isLocalControlPlaneType_NetworkChoice() {}

func (m *LocalControlPlaneType) GetNetworkChoice() isLocalControlPlaneType_NetworkChoice {
	if m != nil {
		return m.NetworkChoice
	}
	return nil
}

func (m *LocalControlPlaneType) GetInsideVn() *schema.Empty {
	if x, ok := m.GetNetworkChoice().(*LocalControlPlaneType_InsideVn); ok {
		return x.InsideVn
	}
	return nil
}

func (m *LocalControlPlaneType) GetOutsideVn() *schema.Empty {
	if x, ok := m.GetNetworkChoice().(*LocalControlPlaneType_OutsideVn); ok {
		return x.OutsideVn
	}
	return nil
}

func (m *LocalControlPlaneType) GetBgpConfig() *BGPConfiguration {
	if m != nil {
		return m.BgpConfig
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LocalControlPlaneType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LocalControlPlaneType_InsideVn)(nil),
		(*LocalControlPlaneType_OutsideVn)(nil),
	}
}

// Global Specifications
//
// x-displayName: "Global Specifications"
// Fleet specifications
type GlobalSpecType struct {
	// fleet_label
	//
	// x-displayName: "Fleet Label Value"
	// x-required
	// x-example: "sfo"
	// fleet_label value is used to create known_label "ves.io/fleet=<fleet_label>"
	// The known_label is created in the "shared" namespace for the tenant.
	//
	// A virtual_site object with name <fleet_label> is also created in "shared" namespace for tenant.
	// The virtual_site object will select all sites configured with the known_label above
	// fleet_label with "sfo" will create a known_label "ves.io/fleet=sfo" in tenant for the fleet
	FleetLabel string `protobuf:"bytes,1,opt,name=fleet_label,json=fleetLabel,proto3" json:"fleet_label,omitempty"`
	// Software Version
	//
	// x-displayName: "Software Version"
	// x-example: "value"
	// Volterra software version is human readable string matching released set of version components.
	// The given software version is applied to all sites that are member of the fleet.
	// Current software installed can be overridden via site config.
	VolterraSoftwareVersion string `protobuf:"bytes,2,opt,name=volterra_software_version,json=volterraSoftwareVersion,proto3" json:"volterra_software_version,omitempty"`
	// Devices
	//
	// x-displayName: "Devices"
	// Configuration for all devices in the fleet.
	// Examples of devices are - network interfaces, cameras, scanners etc.
	// Configuration a device is applied on VER node if the VER node is member of this fleet and
	// has an corresponding interface/device. The mapping from device configured in fleet with
	// interface/device in VER node depends on the type of device and is documented in
	// device instance specific sections
	Devices []*DeviceInstanceType `protobuf:"bytes,3,rep,name=devices,proto3" json:"devices,omitempty"`
	// Network Connectors
	//
	// x-displayName: "Network Connectors"
	// Network Connector defines connection between two virtual networks in a given site.
	// Fleet defines one or more such network connectors.
	// The network connectors configuration is applied on all sites that are member of the fleet.
	NetworkConnectors []*schema.ObjectRefType `protobuf:"bytes,4,rep,name=network_connectors,json=networkConnectors,proto3" json:"network_connectors,omitempty"`
	// Network Firewall
	//
	// x-displayName: "Network Firewall"
	// Network Firewall defines firewall to be applied for the virtual networks in the fleet.
	// The network firewall configuration is applied on all sites that are member of the fleet.
	//
	// Constraints
	// The Network Firewall is applied on Virtual Networks of type site local network and site local inside network
	NetworkFirewall []*schema.ObjectRefType `protobuf:"bytes,5,rep,name=network_firewall,json=networkFirewall,proto3" json:"network_firewall,omitempty"`
	// Operating System Version
	//
	// x-displayName: "Operating System Version"
	// x-example: "value"
	// Desired Operating System version that is applied to all sites that are member of the fleet.
	// Current Operating System version can be overridden via site config.
	OperatingSystemVersion string `protobuf:"bytes,6,opt,name=operating_system_version,json=operatingSystemVersion,proto3" json:"operating_system_version,omitempty"`
	// Outside Virtual Network
	//
	// x-displayName: "Outside (Site Local) Virtual Network"
	// Default outside (site local) virtual network for the fleet
	OutsideVirtualNetwork []*schema.ObjectRefType `protobuf:"bytes,7,rep,name=outside_virtual_network,json=outsideVirtualNetwork,proto3" json:"outside_virtual_network,omitempty"`
	// Inside Virtual Network
	//
	// x-displayName: "Site Local Inside Virtual Network"
	// Default inside (site local) virtual network for the fleet
	InsideVirtualNetwork []*schema.ObjectRefType `protobuf:"bytes,8,rep,name=inside_virtual_network,json=insideVirtualNetwork,proto3" json:"inside_virtual_network,omitempty"`
	// Select Interface Config
	//
	// x-displayName: "Select Interface Configuration"
	// x-required
	// Select how interfaces are configured for this fleet
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*GlobalSpecType_InterfaceList
	//	*GlobalSpecType_DefaultInterfaces
	//	*GlobalSpecType_LegacyDevices
	InterfaceChoice isGlobalSpecType_InterfaceChoice `protobuf_oneof:"interface_choice"`
	// Select Bond Configuration
	//
	// x-displayName: ""Select Bond Configuration"
	// x-required
	// Add bond interface devices to the fleet
	//
	// Types that are valid to be assigned to BondChoice:
	//	*GlobalSpecType_NoBondDevices
	//	*GlobalSpecType_BondDeviceList
	BondChoice isGlobalSpecType_BondChoice `protobuf_oneof:"bond_choice"`
	// Storage Interfaces
	//
	// x-displayName: "Select Storage Interface Configuration"
	// x-required
	// Select if storage interfaces are configured
	//
	// Types that are valid to be assigned to StorageInterfaceChoice:
	//	*GlobalSpecType_NoStorageInterfaces
	//	*GlobalSpecType_StorageInterfaceList
	StorageInterfaceChoice isGlobalSpecType_StorageInterfaceChoice `protobuf_oneof:"storage_interface_choice"`
	// Storage Device Configuration
	//
	// x-displayName: "Select Storage Device Configuration"
	// x-required
	// Configure external storage devices for this fleet
	//
	// Types that are valid to be assigned to StorageDeviceChoice:
	//	*GlobalSpecType_NoStorageDevice
	//	*GlobalSpecType_StorageDeviceList
	StorageDeviceChoice isGlobalSpecType_StorageDeviceChoice `protobuf_oneof:"storage_device_choice"`
	// Storage Class Configuration
	//
	// x-displayName: "Select Configuration for Storage Classes"
	// x-required
	// Configure custom storage classes in kubernetes for this fleet
	//
	// Types that are valid to be assigned to StorageClassChoice:
	//	*GlobalSpecType_DefaultStorageClass
	//	*GlobalSpecType_StorageClassList
	StorageClassChoice isGlobalSpecType_StorageClassChoice `protobuf_oneof:"storage_class_choice"`
	// Select DC Cluster Group
	//
	// x-displayName: "Select DC Cluster Group"
	// x-required
	// Configure DC cluster group for this fleet
	//
	// Types that are valid to be assigned to DcClusterGroupChoice:
	//	*GlobalSpecType_NoDcClusterGroup
	//	*GlobalSpecType_DcClusterGroup
	//	*GlobalSpecType_DcClusterGroupInside
	DcClusterGroupChoice isGlobalSpecType_DcClusterGroupChoice `protobuf_oneof:"dc_cluster_group_choice"`
	// Select GPU Enable/Disable
	//
	// x-displayName: "Enable/Disable GPU"
	// x-required
	// Enable or Disable GPU for this fleet
	//
	// Types that are valid to be assigned to GpuChoice:
	//	*GlobalSpecType_DisableGpu
	//	*GlobalSpecType_EnableGpu
	//	*GlobalSpecType_EnableVgpu
	GpuChoice isGlobalSpecType_GpuChoice `protobuf_oneof:"gpu_choice"`
	// Select VMs support Enable/Disable
	//
	// x-displayName: "Enable/Disable VMs support"
	// Enable or Disable VM support for this fleet
	//
	// Types that are valid to be assigned to VmChoice:
	//	*GlobalSpecType_DisableVm
	//	*GlobalSpecType_EnableVm
	VmChoice isGlobalSpecType_VmChoice `protobuf_oneof:"vm_choice"`
	// Etcd Clustering Network
	//
	// x-displayName: "Etcd Clustering Network"
	// Decided which network is used for etcd clustering
	EtcdClusterNetwork EtcdClusterNetworkType `protobuf:"varint,33,opt,name=etcd_cluster_network,json=etcdClusterNetwork,proto3,enum=ves.io.schema.fleet.EtcdClusterNetworkType" json:"etcd_cluster_network,omitempty"`
	// Storage Static Routes
	//
	// x-displayName: "Select Storage Storage Static Routes"
	// x-required
	// Select storage Storage Static Routes
	//
	// Types that are valid to be assigned to StorageStaticRoutesChoice:
	//	*GlobalSpecType_NoStorageStaticRoutes
	//	*GlobalSpecType_StorageStaticRoutes
	StorageStaticRoutesChoice isGlobalSpecType_StorageStaticRoutesChoice `protobuf_oneof:"storage_static_routes_choice"`
	// Enable default fleet config download
	//
	// x-displayName: "Enable Default Fleet Config Download"
	// Enable default fleet config, It must be set for storage config and gpu config
	EnableDefaultFleetConfigDownload bool `protobuf:"varint,37,opt,name=enable_default_fleet_config_download,json=enableDefaultFleetConfigDownload,proto3" json:"enable_default_fleet_config_download,omitempty"`
	// Fleet type
	//
	// x-displayName: "Fleet Type"
	// Fleet Type can be fleet of single site or multiple sites. Corresponding virtual site is not created
	// for single site fleet.
	FleetType FleetType `protobuf:"varint,41,opt,name=fleet_type,json=fleetType,proto3,enum=ves.io.schema.fleet.FleetType" json:"fleet_type,omitempty"`
	// Single Site Fleet Site
	//
	// x-displayName: "Single Site Fleet Site"
	// Vega should use this ref when when fleet type is single site fleet
	SingleSite []*schema.ObjectRefType `protobuf:"bytes,42,rep,name=single_site,json=singleSite,proto3" json:"single_site,omitempty"`
	// Logs Streaming
	//
	// x-displayName: "Logs Streaming"
	// x-required
	// Select Logs receiver for logs streaming
	//
	// Types that are valid to be assigned to LogsReceiverChoice:
	//	*GlobalSpecType_LogsStreamingDisabled
	//	*GlobalSpecType_LogReceiver
	LogsReceiverChoice isGlobalSpecType_LogsReceiverChoice `protobuf_oneof:"logs_receiver_choice"`
	// USB Device Policy
	//
	// x-displayName: "USB Device Policy"
	// x-required
	// Select USB device policy
	//
	// Types that are valid to be assigned to UsbPolicyChoice:
	//	*GlobalSpecType_DenyAllUsb
	//	*GlobalSpecType_AllowAllUsb
	//	*GlobalSpecType_UsbPolicy
	UsbPolicyChoice isGlobalSpecType_UsbPolicyChoice `protobuf_oneof:"usb_policy_choice"`
	// Enable Local K8s Cluster access
	//
	// x-displayName: "Enable Local K8s Cluster access"
	// Local K8s cluster access is enabled, using config k8s_cluster object
	K8SCluster *views.ObjectRefType `protobuf:"bytes,50,opt,name=k8s_cluster,json=k8sCluster,proto3" json:"k8s_cluster,omitempty"`
	// Local Control Plane
	//
	// x-displayName: "Local Control Plane"
	// Enable local control plane for L3VPN, SRV6, EVPN etc
	LocalControlPlane *LocalControlPlaneType `protobuf:"bytes,51,opt,name=local_control_plane,json=localControlPlane,proto3" json:"local_control_plane,omitempty"`
	// Flow Exporter Enable/Disable
	//
	// x-displayName: "Flow Exporter"
	// Configuration for exporting flows
	//
	// Types that are valid to be assigned to FlowExporterChoice:
	//	*GlobalSpecType_DisableFlowExport
	//	*GlobalSpecType_EnableFlowExport
	FlowExporterChoice isGlobalSpecType_FlowExporterChoice `protobuf_oneof:"flow_exporter_choice"`
	// view_internal
	//
	// x-displayName: "View Internal"
	// Reference to view internal object
	ViewInternal *views.ObjectRefType `protobuf:"bytes,1000,opt,name=view_internal,json=viewInternal,proto3" json:"view_internal,omitempty"`
	// K8s YAMLs
	//
	// x-displayName: "K8s YAMLs"
	// K8s YAML for CustomStorageClass
	GeneratedYamls []string `protobuf:"bytes,1001,rep,name=generated_yamls,json=generatedYamls,proto3" json:"generated_yamls,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{39}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_InterfaceChoice interface {
	isGlobalSpecType_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_BondChoice interface {
	isGlobalSpecType_BondChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_StorageInterfaceChoice interface {
	isGlobalSpecType_StorageInterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_StorageDeviceChoice interface {
	isGlobalSpecType_StorageDeviceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_StorageClassChoice interface {
	isGlobalSpecType_StorageClassChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_DcClusterGroupChoice interface {
	isGlobalSpecType_DcClusterGroupChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_GpuChoice interface {
	isGlobalSpecType_GpuChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_VmChoice interface {
	isGlobalSpecType_VmChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_StorageStaticRoutesChoice interface {
	isGlobalSpecType_StorageStaticRoutesChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_LogsReceiverChoice interface {
	isGlobalSpecType_LogsReceiverChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_UsbPolicyChoice interface {
	isGlobalSpecType_UsbPolicyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_FlowExporterChoice interface {
	isGlobalSpecType_FlowExporterChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_InterfaceList struct {
	InterfaceList *FleetInterfaceListType `protobuf:"bytes,10,opt,name=interface_list,json=interfaceList,proto3,oneof" json:"interface_list,omitempty"`
}
type GlobalSpecType_DefaultInterfaces struct {
	DefaultInterfaces *schema.Empty `protobuf:"bytes,39,opt,name=default_interfaces,json=defaultInterfaces,proto3,oneof" json:"default_interfaces,omitempty"`
}
type GlobalSpecType_LegacyDevices struct {
	LegacyDevices *schema.Empty `protobuf:"bytes,11,opt,name=legacy_devices,json=legacyDevices,proto3,oneof" json:"legacy_devices,omitempty"`
}
type GlobalSpecType_NoBondDevices struct {
	NoBondDevices *schema.Empty `protobuf:"bytes,16,opt,name=no_bond_devices,json=noBondDevices,proto3,oneof" json:"no_bond_devices,omitempty"`
}
type GlobalSpecType_BondDeviceList struct {
	BondDeviceList *FleetBondDevicesListType `protobuf:"bytes,17,opt,name=bond_device_list,json=bondDeviceList,proto3,oneof" json:"bond_device_list,omitempty"`
}
type GlobalSpecType_NoStorageInterfaces struct {
	NoStorageInterfaces *schema.Empty `protobuf:"bytes,19,opt,name=no_storage_interfaces,json=noStorageInterfaces,proto3,oneof" json:"no_storage_interfaces,omitempty"`
}
type GlobalSpecType_StorageInterfaceList struct {
	StorageInterfaceList *FleetInterfaceListType `protobuf:"bytes,20,opt,name=storage_interface_list,json=storageInterfaceList,proto3,oneof" json:"storage_interface_list,omitempty"`
}
type GlobalSpecType_NoStorageDevice struct {
	NoStorageDevice *schema.Empty `protobuf:"bytes,22,opt,name=no_storage_device,json=noStorageDevice,proto3,oneof" json:"no_storage_device,omitempty"`
}
type GlobalSpecType_StorageDeviceList struct {
	StorageDeviceList *FleetStorageDeviceListType `protobuf:"bytes,23,opt,name=storage_device_list,json=storageDeviceList,proto3,oneof" json:"storage_device_list,omitempty"`
}
type GlobalSpecType_DefaultStorageClass struct {
	DefaultStorageClass *schema.Empty `protobuf:"bytes,25,opt,name=default_storage_class,json=defaultStorageClass,proto3,oneof" json:"default_storage_class,omitempty"`
}
type GlobalSpecType_StorageClassList struct {
	StorageClassList *FleetStorageClassListType `protobuf:"bytes,26,opt,name=storage_class_list,json=storageClassList,proto3,oneof" json:"storage_class_list,omitempty"`
}
type GlobalSpecType_NoDcClusterGroup struct {
	NoDcClusterGroup *schema.Empty `protobuf:"bytes,28,opt,name=no_dc_cluster_group,json=noDcClusterGroup,proto3,oneof" json:"no_dc_cluster_group,omitempty"`
}
type GlobalSpecType_DcClusterGroup struct {
	DcClusterGroup *views.ObjectRefType `protobuf:"bytes,29,opt,name=dc_cluster_group,json=dcClusterGroup,proto3,oneof" json:"dc_cluster_group,omitempty"`
}
type GlobalSpecType_DcClusterGroupInside struct {
	DcClusterGroupInside *views.ObjectRefType `protobuf:"bytes,38,opt,name=dc_cluster_group_inside,json=dcClusterGroupInside,proto3,oneof" json:"dc_cluster_group_inside,omitempty"`
}
type GlobalSpecType_DisableGpu struct {
	DisableGpu *schema.Empty `protobuf:"bytes,31,opt,name=disable_gpu,json=disableGpu,proto3,oneof" json:"disable_gpu,omitempty"`
}
type GlobalSpecType_EnableGpu struct {
	EnableGpu *schema.Empty `protobuf:"bytes,32,opt,name=enable_gpu,json=enableGpu,proto3,oneof" json:"enable_gpu,omitempty"`
}
type GlobalSpecType_EnableVgpu struct {
	EnableVgpu *VGPUConfiguration `protobuf:"bytes,52,opt,name=enable_vgpu,json=enableVgpu,proto3,oneof" json:"enable_vgpu,omitempty"`
}
type GlobalSpecType_DisableVm struct {
	DisableVm *schema.Empty `protobuf:"bytes,56,opt,name=disable_vm,json=disableVm,proto3,oneof" json:"disable_vm,omitempty"`
}
type GlobalSpecType_EnableVm struct {
	EnableVm *VMConfiguration `protobuf:"bytes,57,opt,name=enable_vm,json=enableVm,proto3,oneof" json:"enable_vm,omitempty"`
}
type GlobalSpecType_NoStorageStaticRoutes struct {
	NoStorageStaticRoutes *schema.Empty `protobuf:"bytes,35,opt,name=no_storage_static_routes,json=noStorageStaticRoutes,proto3,oneof" json:"no_storage_static_routes,omitempty"`
}
type GlobalSpecType_StorageStaticRoutes struct {
	StorageStaticRoutes *FleetStorageStaticRoutesListType `protobuf:"bytes,36,opt,name=storage_static_routes,json=storageStaticRoutes,proto3,oneof" json:"storage_static_routes,omitempty"`
}
type GlobalSpecType_LogsStreamingDisabled struct {
	LogsStreamingDisabled *schema.Empty `protobuf:"bytes,44,opt,name=logs_streaming_disabled,json=logsStreamingDisabled,proto3,oneof" json:"logs_streaming_disabled,omitempty"`
}
type GlobalSpecType_LogReceiver struct {
	LogReceiver *views.ObjectRefType `protobuf:"bytes,45,opt,name=log_receiver,json=logReceiver,proto3,oneof" json:"log_receiver,omitempty"`
}
type GlobalSpecType_DenyAllUsb struct {
	DenyAllUsb *schema.Empty `protobuf:"bytes,47,opt,name=deny_all_usb,json=denyAllUsb,proto3,oneof" json:"deny_all_usb,omitempty"`
}
type GlobalSpecType_AllowAllUsb struct {
	AllowAllUsb *schema.Empty `protobuf:"bytes,48,opt,name=allow_all_usb,json=allowAllUsb,proto3,oneof" json:"allow_all_usb,omitempty"`
}
type GlobalSpecType_UsbPolicy struct {
	UsbPolicy *views.ObjectRefType `protobuf:"bytes,49,opt,name=usb_policy,json=usbPolicy,proto3,oneof" json:"usb_policy,omitempty"`
}
type GlobalSpecType_DisableFlowExport struct {
	DisableFlowExport *schema.Empty `protobuf:"bytes,54,opt,name=disable_flow_export,json=disableFlowExport,proto3,oneof" json:"disable_flow_export,omitempty"`
}
type GlobalSpecType_EnableFlowExport struct {
	EnableFlowExport *schema.Empty `protobuf:"bytes,55,opt,name=enable_flow_export,json=enableFlowExport,proto3,oneof" json:"enable_flow_export,omitempty"`
}

func (*GlobalSpecType_InterfaceList) isGlobalSpecType_InterfaceChoice()                   {}
func (*GlobalSpecType_DefaultInterfaces) isGlobalSpecType_InterfaceChoice()               {}
func (*GlobalSpecType_LegacyDevices) isGlobalSpecType_InterfaceChoice()                   {}
func (*GlobalSpecType_NoBondDevices) isGlobalSpecType_BondChoice()                        {}
func (*GlobalSpecType_BondDeviceList) isGlobalSpecType_BondChoice()                       {}
func (*GlobalSpecType_NoStorageInterfaces) isGlobalSpecType_StorageInterfaceChoice()      {}
func (*GlobalSpecType_StorageInterfaceList) isGlobalSpecType_StorageInterfaceChoice()     {}
func (*GlobalSpecType_NoStorageDevice) isGlobalSpecType_StorageDeviceChoice()             {}
func (*GlobalSpecType_StorageDeviceList) isGlobalSpecType_StorageDeviceChoice()           {}
func (*GlobalSpecType_DefaultStorageClass) isGlobalSpecType_StorageClassChoice()          {}
func (*GlobalSpecType_StorageClassList) isGlobalSpecType_StorageClassChoice()             {}
func (*GlobalSpecType_NoDcClusterGroup) isGlobalSpecType_DcClusterGroupChoice()           {}
func (*GlobalSpecType_DcClusterGroup) isGlobalSpecType_DcClusterGroupChoice()             {}
func (*GlobalSpecType_DcClusterGroupInside) isGlobalSpecType_DcClusterGroupChoice()       {}
func (*GlobalSpecType_DisableGpu) isGlobalSpecType_GpuChoice()                            {}
func (*GlobalSpecType_EnableGpu) isGlobalSpecType_GpuChoice()                             {}
func (*GlobalSpecType_EnableVgpu) isGlobalSpecType_GpuChoice()                            {}
func (*GlobalSpecType_DisableVm) isGlobalSpecType_VmChoice()                              {}
func (*GlobalSpecType_EnableVm) isGlobalSpecType_VmChoice()                               {}
func (*GlobalSpecType_NoStorageStaticRoutes) isGlobalSpecType_StorageStaticRoutesChoice() {}
func (*GlobalSpecType_StorageStaticRoutes) isGlobalSpecType_StorageStaticRoutesChoice()   {}
func (*GlobalSpecType_LogsStreamingDisabled) isGlobalSpecType_LogsReceiverChoice()        {}
func (*GlobalSpecType_LogReceiver) isGlobalSpecType_LogsReceiverChoice()                  {}
func (*GlobalSpecType_DenyAllUsb) isGlobalSpecType_UsbPolicyChoice()                      {}
func (*GlobalSpecType_AllowAllUsb) isGlobalSpecType_UsbPolicyChoice()                     {}
func (*GlobalSpecType_UsbPolicy) isGlobalSpecType_UsbPolicyChoice()                       {}
func (*GlobalSpecType_DisableFlowExport) isGlobalSpecType_FlowExporterChoice()            {}
func (*GlobalSpecType_EnableFlowExport) isGlobalSpecType_FlowExporterChoice()             {}

func (m *GlobalSpecType) GetInterfaceChoice() isGlobalSpecType_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}
func (m *GlobalSpecType) GetBondChoice() isGlobalSpecType_BondChoice {
	if m != nil {
		return m.BondChoice
	}
	return nil
}
func (m *GlobalSpecType) GetStorageInterfaceChoice() isGlobalSpecType_StorageInterfaceChoice {
	if m != nil {
		return m.StorageInterfaceChoice
	}
	return nil
}
func (m *GlobalSpecType) GetStorageDeviceChoice() isGlobalSpecType_StorageDeviceChoice {
	if m != nil {
		return m.StorageDeviceChoice
	}
	return nil
}
func (m *GlobalSpecType) GetStorageClassChoice() isGlobalSpecType_StorageClassChoice {
	if m != nil {
		return m.StorageClassChoice
	}
	return nil
}
func (m *GlobalSpecType) GetDcClusterGroupChoice() isGlobalSpecType_DcClusterGroupChoice {
	if m != nil {
		return m.DcClusterGroupChoice
	}
	return nil
}
func (m *GlobalSpecType) GetGpuChoice() isGlobalSpecType_GpuChoice {
	if m != nil {
		return m.GpuChoice
	}
	return nil
}
func (m *GlobalSpecType) GetVmChoice() isGlobalSpecType_VmChoice {
	if m != nil {
		return m.VmChoice
	}
	return nil
}
func (m *GlobalSpecType) GetStorageStaticRoutesChoice() isGlobalSpecType_StorageStaticRoutesChoice {
	if m != nil {
		return m.StorageStaticRoutesChoice
	}
	return nil
}
func (m *GlobalSpecType) GetLogsReceiverChoice() isGlobalSpecType_LogsReceiverChoice {
	if m != nil {
		return m.LogsReceiverChoice
	}
	return nil
}
func (m *GlobalSpecType) GetUsbPolicyChoice() isGlobalSpecType_UsbPolicyChoice {
	if m != nil {
		return m.UsbPolicyChoice
	}
	return nil
}
func (m *GlobalSpecType) GetFlowExporterChoice() isGlobalSpecType_FlowExporterChoice {
	if m != nil {
		return m.FlowExporterChoice
	}
	return nil
}

func (m *GlobalSpecType) GetFleetLabel() string {
	if m != nil {
		return m.FleetLabel
	}
	return ""
}

func (m *GlobalSpecType) GetVolterraSoftwareVersion() string {
	if m != nil {
		return m.VolterraSoftwareVersion
	}
	return ""
}

func (m *GlobalSpecType) GetDevices() []*DeviceInstanceType {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *GlobalSpecType) GetNetworkConnectors() []*schema.ObjectRefType {
	if m != nil {
		return m.NetworkConnectors
	}
	return nil
}

func (m *GlobalSpecType) GetNetworkFirewall() []*schema.ObjectRefType {
	if m != nil {
		return m.NetworkFirewall
	}
	return nil
}

func (m *GlobalSpecType) GetOperatingSystemVersion() string {
	if m != nil {
		return m.OperatingSystemVersion
	}
	return ""
}

func (m *GlobalSpecType) GetOutsideVirtualNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.OutsideVirtualNetwork
	}
	return nil
}

func (m *GlobalSpecType) GetInsideVirtualNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.InsideVirtualNetwork
	}
	return nil
}

func (m *GlobalSpecType) GetInterfaceList() *FleetInterfaceListType {
	if x, ok := m.GetInterfaceChoice().(*GlobalSpecType_InterfaceList); ok {
		return x.InterfaceList
	}
	return nil
}

func (m *GlobalSpecType) GetDefaultInterfaces() *schema.Empty {
	if x, ok := m.GetInterfaceChoice().(*GlobalSpecType_DefaultInterfaces); ok {
		return x.DefaultInterfaces
	}
	return nil
}

func (m *GlobalSpecType) GetLegacyDevices() *schema.Empty {
	if x, ok := m.GetInterfaceChoice().(*GlobalSpecType_LegacyDevices); ok {
		return x.LegacyDevices
	}
	return nil
}

func (m *GlobalSpecType) GetNoBondDevices() *schema.Empty {
	if x, ok := m.GetBondChoice().(*GlobalSpecType_NoBondDevices); ok {
		return x.NoBondDevices
	}
	return nil
}

func (m *GlobalSpecType) GetBondDeviceList() *FleetBondDevicesListType {
	if x, ok := m.GetBondChoice().(*GlobalSpecType_BondDeviceList); ok {
		return x.BondDeviceList
	}
	return nil
}

func (m *GlobalSpecType) GetNoStorageInterfaces() *schema.Empty {
	if x, ok := m.GetStorageInterfaceChoice().(*GlobalSpecType_NoStorageInterfaces); ok {
		return x.NoStorageInterfaces
	}
	return nil
}

func (m *GlobalSpecType) GetStorageInterfaceList() *FleetInterfaceListType {
	if x, ok := m.GetStorageInterfaceChoice().(*GlobalSpecType_StorageInterfaceList); ok {
		return x.StorageInterfaceList
	}
	return nil
}

func (m *GlobalSpecType) GetNoStorageDevice() *schema.Empty {
	if x, ok := m.GetStorageDeviceChoice().(*GlobalSpecType_NoStorageDevice); ok {
		return x.NoStorageDevice
	}
	return nil
}

func (m *GlobalSpecType) GetStorageDeviceList() *FleetStorageDeviceListType {
	if x, ok := m.GetStorageDeviceChoice().(*GlobalSpecType_StorageDeviceList); ok {
		return x.StorageDeviceList
	}
	return nil
}

func (m *GlobalSpecType) GetDefaultStorageClass() *schema.Empty {
	if x, ok := m.GetStorageClassChoice().(*GlobalSpecType_DefaultStorageClass); ok {
		return x.DefaultStorageClass
	}
	return nil
}

func (m *GlobalSpecType) GetStorageClassList() *FleetStorageClassListType {
	if x, ok := m.GetStorageClassChoice().(*GlobalSpecType_StorageClassList); ok {
		return x.StorageClassList
	}
	return nil
}

func (m *GlobalSpecType) GetNoDcClusterGroup() *schema.Empty {
	if x, ok := m.GetDcClusterGroupChoice().(*GlobalSpecType_NoDcClusterGroup); ok {
		return x.NoDcClusterGroup
	}
	return nil
}

func (m *GlobalSpecType) GetDcClusterGroup() *views.ObjectRefType {
	if x, ok := m.GetDcClusterGroupChoice().(*GlobalSpecType_DcClusterGroup); ok {
		return x.DcClusterGroup
	}
	return nil
}

func (m *GlobalSpecType) GetDcClusterGroupInside() *views.ObjectRefType {
	if x, ok := m.GetDcClusterGroupChoice().(*GlobalSpecType_DcClusterGroupInside); ok {
		return x.DcClusterGroupInside
	}
	return nil
}

func (m *GlobalSpecType) GetDisableGpu() *schema.Empty {
	if x, ok := m.GetGpuChoice().(*GlobalSpecType_DisableGpu); ok {
		return x.DisableGpu
	}
	return nil
}

func (m *GlobalSpecType) GetEnableGpu() *schema.Empty {
	if x, ok := m.GetGpuChoice().(*GlobalSpecType_EnableGpu); ok {
		return x.EnableGpu
	}
	return nil
}

func (m *GlobalSpecType) GetEnableVgpu() *VGPUConfiguration {
	if x, ok := m.GetGpuChoice().(*GlobalSpecType_EnableVgpu); ok {
		return x.EnableVgpu
	}
	return nil
}

func (m *GlobalSpecType) GetDisableVm() *schema.Empty {
	if x, ok := m.GetVmChoice().(*GlobalSpecType_DisableVm); ok {
		return x.DisableVm
	}
	return nil
}

func (m *GlobalSpecType) GetEnableVm() *VMConfiguration {
	if x, ok := m.GetVmChoice().(*GlobalSpecType_EnableVm); ok {
		return x.EnableVm
	}
	return nil
}

func (m *GlobalSpecType) GetEtcdClusterNetwork() EtcdClusterNetworkType {
	if m != nil {
		return m.EtcdClusterNetwork
	}
	return ETCD_CLUSTER_SITE_LOCAL_NETWORK
}

func (m *GlobalSpecType) GetNoStorageStaticRoutes() *schema.Empty {
	if x, ok := m.GetStorageStaticRoutesChoice().(*GlobalSpecType_NoStorageStaticRoutes); ok {
		return x.NoStorageStaticRoutes
	}
	return nil
}

func (m *GlobalSpecType) GetStorageStaticRoutes() *FleetStorageStaticRoutesListType {
	if x, ok := m.GetStorageStaticRoutesChoice().(*GlobalSpecType_StorageStaticRoutes); ok {
		return x.StorageStaticRoutes
	}
	return nil
}

func (m *GlobalSpecType) GetEnableDefaultFleetConfigDownload() bool {
	if m != nil {
		return m.EnableDefaultFleetConfigDownload
	}
	return false
}

func (m *GlobalSpecType) GetFleetType() FleetType {
	if m != nil {
		return m.FleetType
	}
	return MULTIPLE_SITE
}

func (m *GlobalSpecType) GetSingleSite() []*schema.ObjectRefType {
	if m != nil {
		return m.SingleSite
	}
	return nil
}

func (m *GlobalSpecType) GetLogsStreamingDisabled() *schema.Empty {
	if x, ok := m.GetLogsReceiverChoice().(*GlobalSpecType_LogsStreamingDisabled); ok {
		return x.LogsStreamingDisabled
	}
	return nil
}

func (m *GlobalSpecType) GetLogReceiver() *views.ObjectRefType {
	if x, ok := m.GetLogsReceiverChoice().(*GlobalSpecType_LogReceiver); ok {
		return x.LogReceiver
	}
	return nil
}

func (m *GlobalSpecType) GetDenyAllUsb() *schema.Empty {
	if x, ok := m.GetUsbPolicyChoice().(*GlobalSpecType_DenyAllUsb); ok {
		return x.DenyAllUsb
	}
	return nil
}

func (m *GlobalSpecType) GetAllowAllUsb() *schema.Empty {
	if x, ok := m.GetUsbPolicyChoice().(*GlobalSpecType_AllowAllUsb); ok {
		return x.AllowAllUsb
	}
	return nil
}

func (m *GlobalSpecType) GetUsbPolicy() *views.ObjectRefType {
	if x, ok := m.GetUsbPolicyChoice().(*GlobalSpecType_UsbPolicy); ok {
		return x.UsbPolicy
	}
	return nil
}

func (m *GlobalSpecType) GetK8SCluster() *views.ObjectRefType {
	if m != nil {
		return m.K8SCluster
	}
	return nil
}

func (m *GlobalSpecType) GetLocalControlPlane() *LocalControlPlaneType {
	if m != nil {
		return m.LocalControlPlane
	}
	return nil
}

func (m *GlobalSpecType) GetDisableFlowExport() *schema.Empty {
	if x, ok := m.GetFlowExporterChoice().(*GlobalSpecType_DisableFlowExport); ok {
		return x.DisableFlowExport
	}
	return nil
}

func (m *GlobalSpecType) GetEnableFlowExport() *schema.Empty {
	if x, ok := m.GetFlowExporterChoice().(*GlobalSpecType_EnableFlowExport); ok {
		return x.EnableFlowExport
	}
	return nil
}

func (m *GlobalSpecType) GetViewInternal() *views.ObjectRefType {
	if m != nil {
		return m.ViewInternal
	}
	return nil
}

func (m *GlobalSpecType) GetGeneratedYamls() []string {
	if m != nil {
		return m.GeneratedYamls
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_InterfaceList)(nil),
		(*GlobalSpecType_DefaultInterfaces)(nil),
		(*GlobalSpecType_LegacyDevices)(nil),
		(*GlobalSpecType_NoBondDevices)(nil),
		(*GlobalSpecType_BondDeviceList)(nil),
		(*GlobalSpecType_NoStorageInterfaces)(nil),
		(*GlobalSpecType_StorageInterfaceList)(nil),
		(*GlobalSpecType_NoStorageDevice)(nil),
		(*GlobalSpecType_StorageDeviceList)(nil),
		(*GlobalSpecType_DefaultStorageClass)(nil),
		(*GlobalSpecType_StorageClassList)(nil),
		(*GlobalSpecType_NoDcClusterGroup)(nil),
		(*GlobalSpecType_DcClusterGroup)(nil),
		(*GlobalSpecType_DcClusterGroupInside)(nil),
		(*GlobalSpecType_DisableGpu)(nil),
		(*GlobalSpecType_EnableGpu)(nil),
		(*GlobalSpecType_EnableVgpu)(nil),
		(*GlobalSpecType_DisableVm)(nil),
		(*GlobalSpecType_EnableVm)(nil),
		(*GlobalSpecType_NoStorageStaticRoutes)(nil),
		(*GlobalSpecType_StorageStaticRoutes)(nil),
		(*GlobalSpecType_LogsStreamingDisabled)(nil),
		(*GlobalSpecType_LogReceiver)(nil),
		(*GlobalSpecType_DenyAllUsb)(nil),
		(*GlobalSpecType_AllowAllUsb)(nil),
		(*GlobalSpecType_UsbPolicy)(nil),
		(*GlobalSpecType_DisableFlowExport)(nil),
		(*GlobalSpecType_EnableFlowExport)(nil),
	}
}

// Create Fleet
//
// x-displayName: "Create Fleet"
// Create fleet will create a fleet object in 'system' namespace of the user
type CreateSpecType struct {
	FleetLabel              string                  `protobuf:"bytes,1,opt,name=fleet_label,json=fleetLabel,proto3" json:"fleet_label,omitempty"`
	VolterraSoftwareVersion string                  `protobuf:"bytes,2,opt,name=volterra_software_version,json=volterraSoftwareVersion,proto3" json:"volterra_software_version,omitempty"`
	NetworkConnectors       []*schema.ObjectRefType `protobuf:"bytes,4,rep,name=network_connectors,json=networkConnectors,proto3" json:"network_connectors,omitempty"`
	NetworkFirewall         []*schema.ObjectRefType `protobuf:"bytes,5,rep,name=network_firewall,json=networkFirewall,proto3" json:"network_firewall,omitempty"`
	OperatingSystemVersion  string                  `protobuf:"bytes,6,opt,name=operating_system_version,json=operatingSystemVersion,proto3" json:"operating_system_version,omitempty"`
	OutsideVirtualNetwork   []*schema.ObjectRefType `protobuf:"bytes,7,rep,name=outside_virtual_network,json=outsideVirtualNetwork,proto3" json:"outside_virtual_network,omitempty"`
	InsideVirtualNetwork    []*schema.ObjectRefType `protobuf:"bytes,8,rep,name=inside_virtual_network,json=insideVirtualNetwork,proto3" json:"inside_virtual_network,omitempty"`
	// Select Interface Config
	//
	// x-displayName: "Select Interface Config"
	// x-required
	// Select how interfaces are configured for this fleet
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*CreateSpecType_InterfaceList
	//	*CreateSpecType_DefaultConfig
	//	*CreateSpecType_DeviceList
	InterfaceChoice isCreateSpecType_InterfaceChoice `protobuf_oneof:"interface_choice"`
	// Types that are valid to be assigned to BondChoice:
	//	*CreateSpecType_NoBondDevices
	//	*CreateSpecType_BondDeviceList
	BondChoice isCreateSpecType_BondChoice `protobuf_oneof:"bond_choice"`
	// Types that are valid to be assigned to StorageInterfaceChoice:
	//	*CreateSpecType_NoStorageInterfaces
	//	*CreateSpecType_StorageInterfaceList
	StorageInterfaceChoice isCreateSpecType_StorageInterfaceChoice `protobuf_oneof:"storage_interface_choice"`
	// Types that are valid to be assigned to StorageDeviceChoice:
	//	*CreateSpecType_NoStorageDevice
	//	*CreateSpecType_StorageDeviceList
	StorageDeviceChoice isCreateSpecType_StorageDeviceChoice `protobuf_oneof:"storage_device_choice"`
	// Types that are valid to be assigned to StorageClassChoice:
	//	*CreateSpecType_DefaultStorageClass
	//	*CreateSpecType_StorageClassList
	StorageClassChoice isCreateSpecType_StorageClassChoice `protobuf_oneof:"storage_class_choice"`
	// Types that are valid to be assigned to DcClusterGroupChoice:
	//	*CreateSpecType_NoDcClusterGroup
	//	*CreateSpecType_DcClusterGroup
	//	*CreateSpecType_DcClusterGroupInside
	DcClusterGroupChoice isCreateSpecType_DcClusterGroupChoice `protobuf_oneof:"dc_cluster_group_choice"`
	// Types that are valid to be assigned to GpuChoice:
	//	*CreateSpecType_DisableGpu
	//	*CreateSpecType_EnableGpu
	//	*CreateSpecType_EnableVgpu
	GpuChoice isCreateSpecType_GpuChoice `protobuf_oneof:"gpu_choice"`
	// Types that are valid to be assigned to StorageStaticRoutesChoice:
	//	*CreateSpecType_NoStorageStaticRoutes
	//	*CreateSpecType_StorageStaticRoutes
	StorageStaticRoutesChoice        isCreateSpecType_StorageStaticRoutesChoice `protobuf_oneof:"storage_static_routes_choice"`
	EnableDefaultFleetConfigDownload bool                                       `protobuf:"varint,37,opt,name=enable_default_fleet_config_download,json=enableDefaultFleetConfigDownload,proto3" json:"enable_default_fleet_config_download,omitempty"`
	// Types that are valid to be assigned to LogsReceiverChoice:
	//	*CreateSpecType_LogsStreamingDisabled
	//	*CreateSpecType_LogReceiver
	LogsReceiverChoice isCreateSpecType_LogsReceiverChoice `protobuf_oneof:"logs_receiver_choice"`
	// Types that are valid to be assigned to UsbPolicyChoice:
	//	*CreateSpecType_DenyAllUsb
	//	*CreateSpecType_AllowAllUsb
	//	*CreateSpecType_UsbPolicy
	UsbPolicyChoice isCreateSpecType_UsbPolicyChoice `protobuf_oneof:"usb_policy_choice"`
	// Types that are valid to be assigned to VmChoice:
	//	*CreateSpecType_DisableVm
	//	*CreateSpecType_EnableVm
	VmChoice isCreateSpecType_VmChoice `protobuf_oneof:"vm_choice"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{40}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_InterfaceChoice interface {
	isCreateSpecType_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_BondChoice interface {
	isCreateSpecType_BondChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_StorageInterfaceChoice interface {
	isCreateSpecType_StorageInterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_StorageDeviceChoice interface {
	isCreateSpecType_StorageDeviceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_StorageClassChoice interface {
	isCreateSpecType_StorageClassChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_DcClusterGroupChoice interface {
	isCreateSpecType_DcClusterGroupChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_GpuChoice interface {
	isCreateSpecType_GpuChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_StorageStaticRoutesChoice interface {
	isCreateSpecType_StorageStaticRoutesChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_LogsReceiverChoice interface {
	isCreateSpecType_LogsReceiverChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_UsbPolicyChoice interface {
	isCreateSpecType_UsbPolicyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_VmChoice interface {
	isCreateSpecType_VmChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_InterfaceList struct {
	InterfaceList *FleetInterfaceListType `protobuf:"bytes,13,opt,name=interface_list,json=interfaceList,proto3,oneof" json:"interface_list,omitempty"`
}
type CreateSpecType_DefaultConfig struct {
	DefaultConfig *schema.Empty `protobuf:"bytes,40,opt,name=default_config,json=defaultConfig,proto3,oneof" json:"default_config,omitempty"`
}
type CreateSpecType_DeviceList struct {
	DeviceList *FleetDeviceListType `protobuf:"bytes,14,opt,name=device_list,json=deviceList,proto3,oneof" json:"device_list,omitempty"`
}
type CreateSpecType_NoBondDevices struct {
	NoBondDevices *schema.Empty `protobuf:"bytes,16,opt,name=no_bond_devices,json=noBondDevices,proto3,oneof" json:"no_bond_devices,omitempty"`
}
type CreateSpecType_BondDeviceList struct {
	BondDeviceList *FleetBondDevicesListType `protobuf:"bytes,17,opt,name=bond_device_list,json=bondDeviceList,proto3,oneof" json:"bond_device_list,omitempty"`
}
type CreateSpecType_NoStorageInterfaces struct {
	NoStorageInterfaces *schema.Empty `protobuf:"bytes,19,opt,name=no_storage_interfaces,json=noStorageInterfaces,proto3,oneof" json:"no_storage_interfaces,omitempty"`
}
type CreateSpecType_StorageInterfaceList struct {
	StorageInterfaceList *FleetInterfaceListType `protobuf:"bytes,20,opt,name=storage_interface_list,json=storageInterfaceList,proto3,oneof" json:"storage_interface_list,omitempty"`
}
type CreateSpecType_NoStorageDevice struct {
	NoStorageDevice *schema.Empty `protobuf:"bytes,22,opt,name=no_storage_device,json=noStorageDevice,proto3,oneof" json:"no_storage_device,omitempty"`
}
type CreateSpecType_StorageDeviceList struct {
	StorageDeviceList *FleetStorageDeviceListType `protobuf:"bytes,23,opt,name=storage_device_list,json=storageDeviceList,proto3,oneof" json:"storage_device_list,omitempty"`
}
type CreateSpecType_DefaultStorageClass struct {
	DefaultStorageClass *schema.Empty `protobuf:"bytes,25,opt,name=default_storage_class,json=defaultStorageClass,proto3,oneof" json:"default_storage_class,omitempty"`
}
type CreateSpecType_StorageClassList struct {
	StorageClassList *FleetStorageClassListType `protobuf:"bytes,26,opt,name=storage_class_list,json=storageClassList,proto3,oneof" json:"storage_class_list,omitempty"`
}
type CreateSpecType_NoDcClusterGroup struct {
	NoDcClusterGroup *schema.Empty `protobuf:"bytes,28,opt,name=no_dc_cluster_group,json=noDcClusterGroup,proto3,oneof" json:"no_dc_cluster_group,omitempty"`
}
type CreateSpecType_DcClusterGroup struct {
	DcClusterGroup *views.ObjectRefType `protobuf:"bytes,29,opt,name=dc_cluster_group,json=dcClusterGroup,proto3,oneof" json:"dc_cluster_group,omitempty"`
}
type CreateSpecType_DcClusterGroupInside struct {
	DcClusterGroupInside *views.ObjectRefType `protobuf:"bytes,38,opt,name=dc_cluster_group_inside,json=dcClusterGroupInside,proto3,oneof" json:"dc_cluster_group_inside,omitempty"`
}
type CreateSpecType_DisableGpu struct {
	DisableGpu *schema.Empty `protobuf:"bytes,31,opt,name=disable_gpu,json=disableGpu,proto3,oneof" json:"disable_gpu,omitempty"`
}
type CreateSpecType_EnableGpu struct {
	EnableGpu *schema.Empty `protobuf:"bytes,32,opt,name=enable_gpu,json=enableGpu,proto3,oneof" json:"enable_gpu,omitempty"`
}
type CreateSpecType_EnableVgpu struct {
	EnableVgpu *VGPUConfiguration `protobuf:"bytes,52,opt,name=enable_vgpu,json=enableVgpu,proto3,oneof" json:"enable_vgpu,omitempty"`
}
type CreateSpecType_NoStorageStaticRoutes struct {
	NoStorageStaticRoutes *schema.Empty `protobuf:"bytes,35,opt,name=no_storage_static_routes,json=noStorageStaticRoutes,proto3,oneof" json:"no_storage_static_routes,omitempty"`
}
type CreateSpecType_StorageStaticRoutes struct {
	StorageStaticRoutes *FleetStorageStaticRoutesListType `protobuf:"bytes,36,opt,name=storage_static_routes,json=storageStaticRoutes,proto3,oneof" json:"storage_static_routes,omitempty"`
}
type CreateSpecType_LogsStreamingDisabled struct {
	LogsStreamingDisabled *schema.Empty `protobuf:"bytes,44,opt,name=logs_streaming_disabled,json=logsStreamingDisabled,proto3,oneof" json:"logs_streaming_disabled,omitempty"`
}
type CreateSpecType_LogReceiver struct {
	LogReceiver *views.ObjectRefType `protobuf:"bytes,45,opt,name=log_receiver,json=logReceiver,proto3,oneof" json:"log_receiver,omitempty"`
}
type CreateSpecType_DenyAllUsb struct {
	DenyAllUsb *schema.Empty `protobuf:"bytes,47,opt,name=deny_all_usb,json=denyAllUsb,proto3,oneof" json:"deny_all_usb,omitempty"`
}
type CreateSpecType_AllowAllUsb struct {
	AllowAllUsb *schema.Empty `protobuf:"bytes,48,opt,name=allow_all_usb,json=allowAllUsb,proto3,oneof" json:"allow_all_usb,omitempty"`
}
type CreateSpecType_UsbPolicy struct {
	UsbPolicy *views.ObjectRefType `protobuf:"bytes,49,opt,name=usb_policy,json=usbPolicy,proto3,oneof" json:"usb_policy,omitempty"`
}
type CreateSpecType_DisableVm struct {
	DisableVm *schema.Empty `protobuf:"bytes,56,opt,name=disable_vm,json=disableVm,proto3,oneof" json:"disable_vm,omitempty"`
}
type CreateSpecType_EnableVm struct {
	EnableVm *VMConfiguration `protobuf:"bytes,57,opt,name=enable_vm,json=enableVm,proto3,oneof" json:"enable_vm,omitempty"`
}

func (*CreateSpecType_InterfaceList) isCreateSpecType_InterfaceChoice()                   {}
func (*CreateSpecType_DefaultConfig) isCreateSpecType_InterfaceChoice()                   {}
func (*CreateSpecType_DeviceList) isCreateSpecType_InterfaceChoice()                      {}
func (*CreateSpecType_NoBondDevices) isCreateSpecType_BondChoice()                        {}
func (*CreateSpecType_BondDeviceList) isCreateSpecType_BondChoice()                       {}
func (*CreateSpecType_NoStorageInterfaces) isCreateSpecType_StorageInterfaceChoice()      {}
func (*CreateSpecType_StorageInterfaceList) isCreateSpecType_StorageInterfaceChoice()     {}
func (*CreateSpecType_NoStorageDevice) isCreateSpecType_StorageDeviceChoice()             {}
func (*CreateSpecType_StorageDeviceList) isCreateSpecType_StorageDeviceChoice()           {}
func (*CreateSpecType_DefaultStorageClass) isCreateSpecType_StorageClassChoice()          {}
func (*CreateSpecType_StorageClassList) isCreateSpecType_StorageClassChoice()             {}
func (*CreateSpecType_NoDcClusterGroup) isCreateSpecType_DcClusterGroupChoice()           {}
func (*CreateSpecType_DcClusterGroup) isCreateSpecType_DcClusterGroupChoice()             {}
func (*CreateSpecType_DcClusterGroupInside) isCreateSpecType_DcClusterGroupChoice()       {}
func (*CreateSpecType_DisableGpu) isCreateSpecType_GpuChoice()                            {}
func (*CreateSpecType_EnableGpu) isCreateSpecType_GpuChoice()                             {}
func (*CreateSpecType_EnableVgpu) isCreateSpecType_GpuChoice()                            {}
func (*CreateSpecType_NoStorageStaticRoutes) isCreateSpecType_StorageStaticRoutesChoice() {}
func (*CreateSpecType_StorageStaticRoutes) isCreateSpecType_StorageStaticRoutesChoice()   {}
func (*CreateSpecType_LogsStreamingDisabled) isCreateSpecType_LogsReceiverChoice()        {}
func (*CreateSpecType_LogReceiver) isCreateSpecType_LogsReceiverChoice()                  {}
func (*CreateSpecType_DenyAllUsb) isCreateSpecType_UsbPolicyChoice()                      {}
func (*CreateSpecType_AllowAllUsb) isCreateSpecType_UsbPolicyChoice()                     {}
func (*CreateSpecType_UsbPolicy) isCreateSpecType_UsbPolicyChoice()                       {}
func (*CreateSpecType_DisableVm) isCreateSpecType_VmChoice()                              {}
func (*CreateSpecType_EnableVm) isCreateSpecType_VmChoice()                               {}

func (m *CreateSpecType) GetInterfaceChoice() isCreateSpecType_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}
func (m *CreateSpecType) GetBondChoice() isCreateSpecType_BondChoice {
	if m != nil {
		return m.BondChoice
	}
	return nil
}
func (m *CreateSpecType) GetStorageInterfaceChoice() isCreateSpecType_StorageInterfaceChoice {
	if m != nil {
		return m.StorageInterfaceChoice
	}
	return nil
}
func (m *CreateSpecType) GetStorageDeviceChoice() isCreateSpecType_StorageDeviceChoice {
	if m != nil {
		return m.StorageDeviceChoice
	}
	return nil
}
func (m *CreateSpecType) GetStorageClassChoice() isCreateSpecType_StorageClassChoice {
	if m != nil {
		return m.StorageClassChoice
	}
	return nil
}
func (m *CreateSpecType) GetDcClusterGroupChoice() isCreateSpecType_DcClusterGroupChoice {
	if m != nil {
		return m.DcClusterGroupChoice
	}
	return nil
}
func (m *CreateSpecType) GetGpuChoice() isCreateSpecType_GpuChoice {
	if m != nil {
		return m.GpuChoice
	}
	return nil
}
func (m *CreateSpecType) GetStorageStaticRoutesChoice() isCreateSpecType_StorageStaticRoutesChoice {
	if m != nil {
		return m.StorageStaticRoutesChoice
	}
	return nil
}
func (m *CreateSpecType) GetLogsReceiverChoice() isCreateSpecType_LogsReceiverChoice {
	if m != nil {
		return m.LogsReceiverChoice
	}
	return nil
}
func (m *CreateSpecType) GetUsbPolicyChoice() isCreateSpecType_UsbPolicyChoice {
	if m != nil {
		return m.UsbPolicyChoice
	}
	return nil
}
func (m *CreateSpecType) GetVmChoice() isCreateSpecType_VmChoice {
	if m != nil {
		return m.VmChoice
	}
	return nil
}

func (m *CreateSpecType) GetFleetLabel() string {
	if m != nil {
		return m.FleetLabel
	}
	return ""
}

func (m *CreateSpecType) GetVolterraSoftwareVersion() string {
	if m != nil {
		return m.VolterraSoftwareVersion
	}
	return ""
}

func (m *CreateSpecType) GetNetworkConnectors() []*schema.ObjectRefType {
	if m != nil {
		return m.NetworkConnectors
	}
	return nil
}

func (m *CreateSpecType) GetNetworkFirewall() []*schema.ObjectRefType {
	if m != nil {
		return m.NetworkFirewall
	}
	return nil
}

func (m *CreateSpecType) GetOperatingSystemVersion() string {
	if m != nil {
		return m.OperatingSystemVersion
	}
	return ""
}

func (m *CreateSpecType) GetOutsideVirtualNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.OutsideVirtualNetwork
	}
	return nil
}

func (m *CreateSpecType) GetInsideVirtualNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.InsideVirtualNetwork
	}
	return nil
}

func (m *CreateSpecType) GetInterfaceList() *FleetInterfaceListType {
	if x, ok := m.GetInterfaceChoice().(*CreateSpecType_InterfaceList); ok {
		return x.InterfaceList
	}
	return nil
}

func (m *CreateSpecType) GetDefaultConfig() *schema.Empty {
	if x, ok := m.GetInterfaceChoice().(*CreateSpecType_DefaultConfig); ok {
		return x.DefaultConfig
	}
	return nil
}

func (m *CreateSpecType) GetDeviceList() *FleetDeviceListType {
	if x, ok := m.GetInterfaceChoice().(*CreateSpecType_DeviceList); ok {
		return x.DeviceList
	}
	return nil
}

func (m *CreateSpecType) GetNoBondDevices() *schema.Empty {
	if x, ok := m.GetBondChoice().(*CreateSpecType_NoBondDevices); ok {
		return x.NoBondDevices
	}
	return nil
}

func (m *CreateSpecType) GetBondDeviceList() *FleetBondDevicesListType {
	if x, ok := m.GetBondChoice().(*CreateSpecType_BondDeviceList); ok {
		return x.BondDeviceList
	}
	return nil
}

func (m *CreateSpecType) GetNoStorageInterfaces() *schema.Empty {
	if x, ok := m.GetStorageInterfaceChoice().(*CreateSpecType_NoStorageInterfaces); ok {
		return x.NoStorageInterfaces
	}
	return nil
}

func (m *CreateSpecType) GetStorageInterfaceList() *FleetInterfaceListType {
	if x, ok := m.GetStorageInterfaceChoice().(*CreateSpecType_StorageInterfaceList); ok {
		return x.StorageInterfaceList
	}
	return nil
}

func (m *CreateSpecType) GetNoStorageDevice() *schema.Empty {
	if x, ok := m.GetStorageDeviceChoice().(*CreateSpecType_NoStorageDevice); ok {
		return x.NoStorageDevice
	}
	return nil
}

func (m *CreateSpecType) GetStorageDeviceList() *FleetStorageDeviceListType {
	if x, ok := m.GetStorageDeviceChoice().(*CreateSpecType_StorageDeviceList); ok {
		return x.StorageDeviceList
	}
	return nil
}

func (m *CreateSpecType) GetDefaultStorageClass() *schema.Empty {
	if x, ok := m.GetStorageClassChoice().(*CreateSpecType_DefaultStorageClass); ok {
		return x.DefaultStorageClass
	}
	return nil
}

func (m *CreateSpecType) GetStorageClassList() *FleetStorageClassListType {
	if x, ok := m.GetStorageClassChoice().(*CreateSpecType_StorageClassList); ok {
		return x.StorageClassList
	}
	return nil
}

func (m *CreateSpecType) GetNoDcClusterGroup() *schema.Empty {
	if x, ok := m.GetDcClusterGroupChoice().(*CreateSpecType_NoDcClusterGroup); ok {
		return x.NoDcClusterGroup
	}
	return nil
}

func (m *CreateSpecType) GetDcClusterGroup() *views.ObjectRefType {
	if x, ok := m.GetDcClusterGroupChoice().(*CreateSpecType_DcClusterGroup); ok {
		return x.DcClusterGroup
	}
	return nil
}

func (m *CreateSpecType) GetDcClusterGroupInside() *views.ObjectRefType {
	if x, ok := m.GetDcClusterGroupChoice().(*CreateSpecType_DcClusterGroupInside); ok {
		return x.DcClusterGroupInside
	}
	return nil
}

func (m *CreateSpecType) GetDisableGpu() *schema.Empty {
	if x, ok := m.GetGpuChoice().(*CreateSpecType_DisableGpu); ok {
		return x.DisableGpu
	}
	return nil
}

func (m *CreateSpecType) GetEnableGpu() *schema.Empty {
	if x, ok := m.GetGpuChoice().(*CreateSpecType_EnableGpu); ok {
		return x.EnableGpu
	}
	return nil
}

func (m *CreateSpecType) GetEnableVgpu() *VGPUConfiguration {
	if x, ok := m.GetGpuChoice().(*CreateSpecType_EnableVgpu); ok {
		return x.EnableVgpu
	}
	return nil
}

func (m *CreateSpecType) GetNoStorageStaticRoutes() *schema.Empty {
	if x, ok := m.GetStorageStaticRoutesChoice().(*CreateSpecType_NoStorageStaticRoutes); ok {
		return x.NoStorageStaticRoutes
	}
	return nil
}

func (m *CreateSpecType) GetStorageStaticRoutes() *FleetStorageStaticRoutesListType {
	if x, ok := m.GetStorageStaticRoutesChoice().(*CreateSpecType_StorageStaticRoutes); ok {
		return x.StorageStaticRoutes
	}
	return nil
}

func (m *CreateSpecType) GetEnableDefaultFleetConfigDownload() bool {
	if m != nil {
		return m.EnableDefaultFleetConfigDownload
	}
	return false
}

func (m *CreateSpecType) GetLogsStreamingDisabled() *schema.Empty {
	if x, ok := m.GetLogsReceiverChoice().(*CreateSpecType_LogsStreamingDisabled); ok {
		return x.LogsStreamingDisabled
	}
	return nil
}

func (m *CreateSpecType) GetLogReceiver() *views.ObjectRefType {
	if x, ok := m.GetLogsReceiverChoice().(*CreateSpecType_LogReceiver); ok {
		return x.LogReceiver
	}
	return nil
}

func (m *CreateSpecType) GetDenyAllUsb() *schema.Empty {
	if x, ok := m.GetUsbPolicyChoice().(*CreateSpecType_DenyAllUsb); ok {
		return x.DenyAllUsb
	}
	return nil
}

func (m *CreateSpecType) GetAllowAllUsb() *schema.Empty {
	if x, ok := m.GetUsbPolicyChoice().(*CreateSpecType_AllowAllUsb); ok {
		return x.AllowAllUsb
	}
	return nil
}

func (m *CreateSpecType) GetUsbPolicy() *views.ObjectRefType {
	if x, ok := m.GetUsbPolicyChoice().(*CreateSpecType_UsbPolicy); ok {
		return x.UsbPolicy
	}
	return nil
}

func (m *CreateSpecType) GetDisableVm() *schema.Empty {
	if x, ok := m.GetVmChoice().(*CreateSpecType_DisableVm); ok {
		return x.DisableVm
	}
	return nil
}

func (m *CreateSpecType) GetEnableVm() *VMConfiguration {
	if x, ok := m.GetVmChoice().(*CreateSpecType_EnableVm); ok {
		return x.EnableVm
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_InterfaceList)(nil),
		(*CreateSpecType_DefaultConfig)(nil),
		(*CreateSpecType_DeviceList)(nil),
		(*CreateSpecType_NoBondDevices)(nil),
		(*CreateSpecType_BondDeviceList)(nil),
		(*CreateSpecType_NoStorageInterfaces)(nil),
		(*CreateSpecType_StorageInterfaceList)(nil),
		(*CreateSpecType_NoStorageDevice)(nil),
		(*CreateSpecType_StorageDeviceList)(nil),
		(*CreateSpecType_DefaultStorageClass)(nil),
		(*CreateSpecType_StorageClassList)(nil),
		(*CreateSpecType_NoDcClusterGroup)(nil),
		(*CreateSpecType_DcClusterGroup)(nil),
		(*CreateSpecType_DcClusterGroupInside)(nil),
		(*CreateSpecType_DisableGpu)(nil),
		(*CreateSpecType_EnableGpu)(nil),
		(*CreateSpecType_EnableVgpu)(nil),
		(*CreateSpecType_NoStorageStaticRoutes)(nil),
		(*CreateSpecType_StorageStaticRoutes)(nil),
		(*CreateSpecType_LogsStreamingDisabled)(nil),
		(*CreateSpecType_LogReceiver)(nil),
		(*CreateSpecType_DenyAllUsb)(nil),
		(*CreateSpecType_AllowAllUsb)(nil),
		(*CreateSpecType_UsbPolicy)(nil),
		(*CreateSpecType_DisableVm)(nil),
		(*CreateSpecType_EnableVm)(nil),
	}
}

// Replace fleet
//
// x-displayName: "Replace Fleet"
// Replace fleet will replace the contents of given fleet object
type ReplaceSpecType struct {
	VolterraSoftwareVersion string                  `protobuf:"bytes,2,opt,name=volterra_software_version,json=volterraSoftwareVersion,proto3" json:"volterra_software_version,omitempty"`
	NetworkConnectors       []*schema.ObjectRefType `protobuf:"bytes,4,rep,name=network_connectors,json=networkConnectors,proto3" json:"network_connectors,omitempty"`
	NetworkFirewall         []*schema.ObjectRefType `protobuf:"bytes,5,rep,name=network_firewall,json=networkFirewall,proto3" json:"network_firewall,omitempty"`
	OperatingSystemVersion  string                  `protobuf:"bytes,6,opt,name=operating_system_version,json=operatingSystemVersion,proto3" json:"operating_system_version,omitempty"`
	OutsideVirtualNetwork   []*schema.ObjectRefType `protobuf:"bytes,7,rep,name=outside_virtual_network,json=outsideVirtualNetwork,proto3" json:"outside_virtual_network,omitempty"`
	InsideVirtualNetwork    []*schema.ObjectRefType `protobuf:"bytes,8,rep,name=inside_virtual_network,json=insideVirtualNetwork,proto3" json:"inside_virtual_network,omitempty"`
	// Select Interface Config
	//
	// x-displayName: "Select Network Interface Config"
	// x-required
	// Select how network interfaces are configured for this fleet
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*ReplaceSpecType_InterfaceList
	//	*ReplaceSpecType_DefaultConfig
	//	*ReplaceSpecType_DeviceList
	InterfaceChoice isReplaceSpecType_InterfaceChoice `protobuf_oneof:"interface_choice"`
	// Types that are valid to be assigned to BondChoice:
	//	*ReplaceSpecType_NoBondDevices
	//	*ReplaceSpecType_BondDeviceList
	BondChoice isReplaceSpecType_BondChoice `protobuf_oneof:"bond_choice"`
	// Types that are valid to be assigned to StorageInterfaceChoice:
	//	*ReplaceSpecType_NoStorageInterfaces
	//	*ReplaceSpecType_StorageInterfaceList
	StorageInterfaceChoice isReplaceSpecType_StorageInterfaceChoice `protobuf_oneof:"storage_interface_choice"`
	// Types that are valid to be assigned to StorageDeviceChoice:
	//	*ReplaceSpecType_NoStorageDevice
	//	*ReplaceSpecType_StorageDeviceList
	StorageDeviceChoice isReplaceSpecType_StorageDeviceChoice `protobuf_oneof:"storage_device_choice"`
	// Types that are valid to be assigned to StorageClassChoice:
	//	*ReplaceSpecType_DefaultStorageClass
	//	*ReplaceSpecType_StorageClassList
	StorageClassChoice isReplaceSpecType_StorageClassChoice `protobuf_oneof:"storage_class_choice"`
	// Types that are valid to be assigned to DcClusterGroupChoice:
	//	*ReplaceSpecType_NoDcClusterGroup
	//	*ReplaceSpecType_DcClusterGroup
	//	*ReplaceSpecType_DcClusterGroupInside
	DcClusterGroupChoice isReplaceSpecType_DcClusterGroupChoice `protobuf_oneof:"dc_cluster_group_choice"`
	// Types that are valid to be assigned to GpuChoice:
	//	*ReplaceSpecType_DisableGpu
	//	*ReplaceSpecType_EnableGpu
	//	*ReplaceSpecType_EnableVgpu
	GpuChoice isReplaceSpecType_GpuChoice `protobuf_oneof:"gpu_choice"`
	// Types that are valid to be assigned to StorageStaticRoutesChoice:
	//	*ReplaceSpecType_NoStorageStaticRoutes
	//	*ReplaceSpecType_StorageStaticRoutes
	StorageStaticRoutesChoice        isReplaceSpecType_StorageStaticRoutesChoice `protobuf_oneof:"storage_static_routes_choice"`
	EnableDefaultFleetConfigDownload bool                                        `protobuf:"varint,37,opt,name=enable_default_fleet_config_download,json=enableDefaultFleetConfigDownload,proto3" json:"enable_default_fleet_config_download,omitempty"`
	// Types that are valid to be assigned to LogsReceiverChoice:
	//	*ReplaceSpecType_LogsStreamingDisabled
	//	*ReplaceSpecType_LogReceiver
	LogsReceiverChoice isReplaceSpecType_LogsReceiverChoice `protobuf_oneof:"logs_receiver_choice"`
	// Types that are valid to be assigned to UsbPolicyChoice:
	//	*ReplaceSpecType_DenyAllUsb
	//	*ReplaceSpecType_AllowAllUsb
	//	*ReplaceSpecType_UsbPolicy
	UsbPolicyChoice isReplaceSpecType_UsbPolicyChoice `protobuf_oneof:"usb_policy_choice"`
	// Types that are valid to be assigned to VmChoice:
	//	*ReplaceSpecType_DisableVm
	//	*ReplaceSpecType_EnableVm
	VmChoice isReplaceSpecType_VmChoice `protobuf_oneof:"vm_choice"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{41}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_InterfaceChoice interface {
	isReplaceSpecType_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_BondChoice interface {
	isReplaceSpecType_BondChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_StorageInterfaceChoice interface {
	isReplaceSpecType_StorageInterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_StorageDeviceChoice interface {
	isReplaceSpecType_StorageDeviceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_StorageClassChoice interface {
	isReplaceSpecType_StorageClassChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_DcClusterGroupChoice interface {
	isReplaceSpecType_DcClusterGroupChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_GpuChoice interface {
	isReplaceSpecType_GpuChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_StorageStaticRoutesChoice interface {
	isReplaceSpecType_StorageStaticRoutesChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_LogsReceiverChoice interface {
	isReplaceSpecType_LogsReceiverChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_UsbPolicyChoice interface {
	isReplaceSpecType_UsbPolicyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_VmChoice interface {
	isReplaceSpecType_VmChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_InterfaceList struct {
	InterfaceList *FleetInterfaceListType `protobuf:"bytes,13,opt,name=interface_list,json=interfaceList,proto3,oneof" json:"interface_list,omitempty"`
}
type ReplaceSpecType_DefaultConfig struct {
	DefaultConfig *schema.Empty `protobuf:"bytes,40,opt,name=default_config,json=defaultConfig,proto3,oneof" json:"default_config,omitempty"`
}
type ReplaceSpecType_DeviceList struct {
	DeviceList *FleetDeviceListType `protobuf:"bytes,14,opt,name=device_list,json=deviceList,proto3,oneof" json:"device_list,omitempty"`
}
type ReplaceSpecType_NoBondDevices struct {
	NoBondDevices *schema.Empty `protobuf:"bytes,16,opt,name=no_bond_devices,json=noBondDevices,proto3,oneof" json:"no_bond_devices,omitempty"`
}
type ReplaceSpecType_BondDeviceList struct {
	BondDeviceList *FleetBondDevicesListType `protobuf:"bytes,17,opt,name=bond_device_list,json=bondDeviceList,proto3,oneof" json:"bond_device_list,omitempty"`
}
type ReplaceSpecType_NoStorageInterfaces struct {
	NoStorageInterfaces *schema.Empty `protobuf:"bytes,19,opt,name=no_storage_interfaces,json=noStorageInterfaces,proto3,oneof" json:"no_storage_interfaces,omitempty"`
}
type ReplaceSpecType_StorageInterfaceList struct {
	StorageInterfaceList *FleetInterfaceListType `protobuf:"bytes,20,opt,name=storage_interface_list,json=storageInterfaceList,proto3,oneof" json:"storage_interface_list,omitempty"`
}
type ReplaceSpecType_NoStorageDevice struct {
	NoStorageDevice *schema.Empty `protobuf:"bytes,22,opt,name=no_storage_device,json=noStorageDevice,proto3,oneof" json:"no_storage_device,omitempty"`
}
type ReplaceSpecType_StorageDeviceList struct {
	StorageDeviceList *FleetStorageDeviceListType `protobuf:"bytes,23,opt,name=storage_device_list,json=storageDeviceList,proto3,oneof" json:"storage_device_list,omitempty"`
}
type ReplaceSpecType_DefaultStorageClass struct {
	DefaultStorageClass *schema.Empty `protobuf:"bytes,25,opt,name=default_storage_class,json=defaultStorageClass,proto3,oneof" json:"default_storage_class,omitempty"`
}
type ReplaceSpecType_StorageClassList struct {
	StorageClassList *FleetStorageClassListType `protobuf:"bytes,26,opt,name=storage_class_list,json=storageClassList,proto3,oneof" json:"storage_class_list,omitempty"`
}
type ReplaceSpecType_NoDcClusterGroup struct {
	NoDcClusterGroup *schema.Empty `protobuf:"bytes,28,opt,name=no_dc_cluster_group,json=noDcClusterGroup,proto3,oneof" json:"no_dc_cluster_group,omitempty"`
}
type ReplaceSpecType_DcClusterGroup struct {
	DcClusterGroup *views.ObjectRefType `protobuf:"bytes,29,opt,name=dc_cluster_group,json=dcClusterGroup,proto3,oneof" json:"dc_cluster_group,omitempty"`
}
type ReplaceSpecType_DcClusterGroupInside struct {
	DcClusterGroupInside *views.ObjectRefType `protobuf:"bytes,38,opt,name=dc_cluster_group_inside,json=dcClusterGroupInside,proto3,oneof" json:"dc_cluster_group_inside,omitempty"`
}
type ReplaceSpecType_DisableGpu struct {
	DisableGpu *schema.Empty `protobuf:"bytes,31,opt,name=disable_gpu,json=disableGpu,proto3,oneof" json:"disable_gpu,omitempty"`
}
type ReplaceSpecType_EnableGpu struct {
	EnableGpu *schema.Empty `protobuf:"bytes,32,opt,name=enable_gpu,json=enableGpu,proto3,oneof" json:"enable_gpu,omitempty"`
}
type ReplaceSpecType_EnableVgpu struct {
	EnableVgpu *VGPUConfiguration `protobuf:"bytes,52,opt,name=enable_vgpu,json=enableVgpu,proto3,oneof" json:"enable_vgpu,omitempty"`
}
type ReplaceSpecType_NoStorageStaticRoutes struct {
	NoStorageStaticRoutes *schema.Empty `protobuf:"bytes,35,opt,name=no_storage_static_routes,json=noStorageStaticRoutes,proto3,oneof" json:"no_storage_static_routes,omitempty"`
}
type ReplaceSpecType_StorageStaticRoutes struct {
	StorageStaticRoutes *FleetStorageStaticRoutesListType `protobuf:"bytes,36,opt,name=storage_static_routes,json=storageStaticRoutes,proto3,oneof" json:"storage_static_routes,omitempty"`
}
type ReplaceSpecType_LogsStreamingDisabled struct {
	LogsStreamingDisabled *schema.Empty `protobuf:"bytes,44,opt,name=logs_streaming_disabled,json=logsStreamingDisabled,proto3,oneof" json:"logs_streaming_disabled,omitempty"`
}
type ReplaceSpecType_LogReceiver struct {
	LogReceiver *views.ObjectRefType `protobuf:"bytes,45,opt,name=log_receiver,json=logReceiver,proto3,oneof" json:"log_receiver,omitempty"`
}
type ReplaceSpecType_DenyAllUsb struct {
	DenyAllUsb *schema.Empty `protobuf:"bytes,47,opt,name=deny_all_usb,json=denyAllUsb,proto3,oneof" json:"deny_all_usb,omitempty"`
}
type ReplaceSpecType_AllowAllUsb struct {
	AllowAllUsb *schema.Empty `protobuf:"bytes,48,opt,name=allow_all_usb,json=allowAllUsb,proto3,oneof" json:"allow_all_usb,omitempty"`
}
type ReplaceSpecType_UsbPolicy struct {
	UsbPolicy *views.ObjectRefType `protobuf:"bytes,49,opt,name=usb_policy,json=usbPolicy,proto3,oneof" json:"usb_policy,omitempty"`
}
type ReplaceSpecType_DisableVm struct {
	DisableVm *schema.Empty `protobuf:"bytes,56,opt,name=disable_vm,json=disableVm,proto3,oneof" json:"disable_vm,omitempty"`
}
type ReplaceSpecType_EnableVm struct {
	EnableVm *VMConfiguration `protobuf:"bytes,57,opt,name=enable_vm,json=enableVm,proto3,oneof" json:"enable_vm,omitempty"`
}

func (*ReplaceSpecType_InterfaceList) isReplaceSpecType_InterfaceChoice()                   {}
func (*ReplaceSpecType_DefaultConfig) isReplaceSpecType_InterfaceChoice()                   {}
func (*ReplaceSpecType_DeviceList) isReplaceSpecType_InterfaceChoice()                      {}
func (*ReplaceSpecType_NoBondDevices) isReplaceSpecType_BondChoice()                        {}
func (*ReplaceSpecType_BondDeviceList) isReplaceSpecType_BondChoice()                       {}
func (*ReplaceSpecType_NoStorageInterfaces) isReplaceSpecType_StorageInterfaceChoice()      {}
func (*ReplaceSpecType_StorageInterfaceList) isReplaceSpecType_StorageInterfaceChoice()     {}
func (*ReplaceSpecType_NoStorageDevice) isReplaceSpecType_StorageDeviceChoice()             {}
func (*ReplaceSpecType_StorageDeviceList) isReplaceSpecType_StorageDeviceChoice()           {}
func (*ReplaceSpecType_DefaultStorageClass) isReplaceSpecType_StorageClassChoice()          {}
func (*ReplaceSpecType_StorageClassList) isReplaceSpecType_StorageClassChoice()             {}
func (*ReplaceSpecType_NoDcClusterGroup) isReplaceSpecType_DcClusterGroupChoice()           {}
func (*ReplaceSpecType_DcClusterGroup) isReplaceSpecType_DcClusterGroupChoice()             {}
func (*ReplaceSpecType_DcClusterGroupInside) isReplaceSpecType_DcClusterGroupChoice()       {}
func (*ReplaceSpecType_DisableGpu) isReplaceSpecType_GpuChoice()                            {}
func (*ReplaceSpecType_EnableGpu) isReplaceSpecType_GpuChoice()                             {}
func (*ReplaceSpecType_EnableVgpu) isReplaceSpecType_GpuChoice()                            {}
func (*ReplaceSpecType_NoStorageStaticRoutes) isReplaceSpecType_StorageStaticRoutesChoice() {}
func (*ReplaceSpecType_StorageStaticRoutes) isReplaceSpecType_StorageStaticRoutesChoice()   {}
func (*ReplaceSpecType_LogsStreamingDisabled) isReplaceSpecType_LogsReceiverChoice()        {}
func (*ReplaceSpecType_LogReceiver) isReplaceSpecType_LogsReceiverChoice()                  {}
func (*ReplaceSpecType_DenyAllUsb) isReplaceSpecType_UsbPolicyChoice()                      {}
func (*ReplaceSpecType_AllowAllUsb) isReplaceSpecType_UsbPolicyChoice()                     {}
func (*ReplaceSpecType_UsbPolicy) isReplaceSpecType_UsbPolicyChoice()                       {}
func (*ReplaceSpecType_DisableVm) isReplaceSpecType_VmChoice()                              {}
func (*ReplaceSpecType_EnableVm) isReplaceSpecType_VmChoice()                               {}

func (m *ReplaceSpecType) GetInterfaceChoice() isReplaceSpecType_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetBondChoice() isReplaceSpecType_BondChoice {
	if m != nil {
		return m.BondChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetStorageInterfaceChoice() isReplaceSpecType_StorageInterfaceChoice {
	if m != nil {
		return m.StorageInterfaceChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetStorageDeviceChoice() isReplaceSpecType_StorageDeviceChoice {
	if m != nil {
		return m.StorageDeviceChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetStorageClassChoice() isReplaceSpecType_StorageClassChoice {
	if m != nil {
		return m.StorageClassChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetDcClusterGroupChoice() isReplaceSpecType_DcClusterGroupChoice {
	if m != nil {
		return m.DcClusterGroupChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetGpuChoice() isReplaceSpecType_GpuChoice {
	if m != nil {
		return m.GpuChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetStorageStaticRoutesChoice() isReplaceSpecType_StorageStaticRoutesChoice {
	if m != nil {
		return m.StorageStaticRoutesChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetLogsReceiverChoice() isReplaceSpecType_LogsReceiverChoice {
	if m != nil {
		return m.LogsReceiverChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetUsbPolicyChoice() isReplaceSpecType_UsbPolicyChoice {
	if m != nil {
		return m.UsbPolicyChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetVmChoice() isReplaceSpecType_VmChoice {
	if m != nil {
		return m.VmChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetVolterraSoftwareVersion() string {
	if m != nil {
		return m.VolterraSoftwareVersion
	}
	return ""
}

func (m *ReplaceSpecType) GetNetworkConnectors() []*schema.ObjectRefType {
	if m != nil {
		return m.NetworkConnectors
	}
	return nil
}

func (m *ReplaceSpecType) GetNetworkFirewall() []*schema.ObjectRefType {
	if m != nil {
		return m.NetworkFirewall
	}
	return nil
}

func (m *ReplaceSpecType) GetOperatingSystemVersion() string {
	if m != nil {
		return m.OperatingSystemVersion
	}
	return ""
}

func (m *ReplaceSpecType) GetOutsideVirtualNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.OutsideVirtualNetwork
	}
	return nil
}

func (m *ReplaceSpecType) GetInsideVirtualNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.InsideVirtualNetwork
	}
	return nil
}

func (m *ReplaceSpecType) GetInterfaceList() *FleetInterfaceListType {
	if x, ok := m.GetInterfaceChoice().(*ReplaceSpecType_InterfaceList); ok {
		return x.InterfaceList
	}
	return nil
}

func (m *ReplaceSpecType) GetDefaultConfig() *schema.Empty {
	if x, ok := m.GetInterfaceChoice().(*ReplaceSpecType_DefaultConfig); ok {
		return x.DefaultConfig
	}
	return nil
}

func (m *ReplaceSpecType) GetDeviceList() *FleetDeviceListType {
	if x, ok := m.GetInterfaceChoice().(*ReplaceSpecType_DeviceList); ok {
		return x.DeviceList
	}
	return nil
}

func (m *ReplaceSpecType) GetNoBondDevices() *schema.Empty {
	if x, ok := m.GetBondChoice().(*ReplaceSpecType_NoBondDevices); ok {
		return x.NoBondDevices
	}
	return nil
}

func (m *ReplaceSpecType) GetBondDeviceList() *FleetBondDevicesListType {
	if x, ok := m.GetBondChoice().(*ReplaceSpecType_BondDeviceList); ok {
		return x.BondDeviceList
	}
	return nil
}

func (m *ReplaceSpecType) GetNoStorageInterfaces() *schema.Empty {
	if x, ok := m.GetStorageInterfaceChoice().(*ReplaceSpecType_NoStorageInterfaces); ok {
		return x.NoStorageInterfaces
	}
	return nil
}

func (m *ReplaceSpecType) GetStorageInterfaceList() *FleetInterfaceListType {
	if x, ok := m.GetStorageInterfaceChoice().(*ReplaceSpecType_StorageInterfaceList); ok {
		return x.StorageInterfaceList
	}
	return nil
}

func (m *ReplaceSpecType) GetNoStorageDevice() *schema.Empty {
	if x, ok := m.GetStorageDeviceChoice().(*ReplaceSpecType_NoStorageDevice); ok {
		return x.NoStorageDevice
	}
	return nil
}

func (m *ReplaceSpecType) GetStorageDeviceList() *FleetStorageDeviceListType {
	if x, ok := m.GetStorageDeviceChoice().(*ReplaceSpecType_StorageDeviceList); ok {
		return x.StorageDeviceList
	}
	return nil
}

func (m *ReplaceSpecType) GetDefaultStorageClass() *schema.Empty {
	if x, ok := m.GetStorageClassChoice().(*ReplaceSpecType_DefaultStorageClass); ok {
		return x.DefaultStorageClass
	}
	return nil
}

func (m *ReplaceSpecType) GetStorageClassList() *FleetStorageClassListType {
	if x, ok := m.GetStorageClassChoice().(*ReplaceSpecType_StorageClassList); ok {
		return x.StorageClassList
	}
	return nil
}

func (m *ReplaceSpecType) GetNoDcClusterGroup() *schema.Empty {
	if x, ok := m.GetDcClusterGroupChoice().(*ReplaceSpecType_NoDcClusterGroup); ok {
		return x.NoDcClusterGroup
	}
	return nil
}

func (m *ReplaceSpecType) GetDcClusterGroup() *views.ObjectRefType {
	if x, ok := m.GetDcClusterGroupChoice().(*ReplaceSpecType_DcClusterGroup); ok {
		return x.DcClusterGroup
	}
	return nil
}

func (m *ReplaceSpecType) GetDcClusterGroupInside() *views.ObjectRefType {
	if x, ok := m.GetDcClusterGroupChoice().(*ReplaceSpecType_DcClusterGroupInside); ok {
		return x.DcClusterGroupInside
	}
	return nil
}

func (m *ReplaceSpecType) GetDisableGpu() *schema.Empty {
	if x, ok := m.GetGpuChoice().(*ReplaceSpecType_DisableGpu); ok {
		return x.DisableGpu
	}
	return nil
}

func (m *ReplaceSpecType) GetEnableGpu() *schema.Empty {
	if x, ok := m.GetGpuChoice().(*ReplaceSpecType_EnableGpu); ok {
		return x.EnableGpu
	}
	return nil
}

func (m *ReplaceSpecType) GetEnableVgpu() *VGPUConfiguration {
	if x, ok := m.GetGpuChoice().(*ReplaceSpecType_EnableVgpu); ok {
		return x.EnableVgpu
	}
	return nil
}

func (m *ReplaceSpecType) GetNoStorageStaticRoutes() *schema.Empty {
	if x, ok := m.GetStorageStaticRoutesChoice().(*ReplaceSpecType_NoStorageStaticRoutes); ok {
		return x.NoStorageStaticRoutes
	}
	return nil
}

func (m *ReplaceSpecType) GetStorageStaticRoutes() *FleetStorageStaticRoutesListType {
	if x, ok := m.GetStorageStaticRoutesChoice().(*ReplaceSpecType_StorageStaticRoutes); ok {
		return x.StorageStaticRoutes
	}
	return nil
}

func (m *ReplaceSpecType) GetEnableDefaultFleetConfigDownload() bool {
	if m != nil {
		return m.EnableDefaultFleetConfigDownload
	}
	return false
}

func (m *ReplaceSpecType) GetLogsStreamingDisabled() *schema.Empty {
	if x, ok := m.GetLogsReceiverChoice().(*ReplaceSpecType_LogsStreamingDisabled); ok {
		return x.LogsStreamingDisabled
	}
	return nil
}

func (m *ReplaceSpecType) GetLogReceiver() *views.ObjectRefType {
	if x, ok := m.GetLogsReceiverChoice().(*ReplaceSpecType_LogReceiver); ok {
		return x.LogReceiver
	}
	return nil
}

func (m *ReplaceSpecType) GetDenyAllUsb() *schema.Empty {
	if x, ok := m.GetUsbPolicyChoice().(*ReplaceSpecType_DenyAllUsb); ok {
		return x.DenyAllUsb
	}
	return nil
}

func (m *ReplaceSpecType) GetAllowAllUsb() *schema.Empty {
	if x, ok := m.GetUsbPolicyChoice().(*ReplaceSpecType_AllowAllUsb); ok {
		return x.AllowAllUsb
	}
	return nil
}

func (m *ReplaceSpecType) GetUsbPolicy() *views.ObjectRefType {
	if x, ok := m.GetUsbPolicyChoice().(*ReplaceSpecType_UsbPolicy); ok {
		return x.UsbPolicy
	}
	return nil
}

func (m *ReplaceSpecType) GetDisableVm() *schema.Empty {
	if x, ok := m.GetVmChoice().(*ReplaceSpecType_DisableVm); ok {
		return x.DisableVm
	}
	return nil
}

func (m *ReplaceSpecType) GetEnableVm() *VMConfiguration {
	if x, ok := m.GetVmChoice().(*ReplaceSpecType_EnableVm); ok {
		return x.EnableVm
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_InterfaceList)(nil),
		(*ReplaceSpecType_DefaultConfig)(nil),
		(*ReplaceSpecType_DeviceList)(nil),
		(*ReplaceSpecType_NoBondDevices)(nil),
		(*ReplaceSpecType_BondDeviceList)(nil),
		(*ReplaceSpecType_NoStorageInterfaces)(nil),
		(*ReplaceSpecType_StorageInterfaceList)(nil),
		(*ReplaceSpecType_NoStorageDevice)(nil),
		(*ReplaceSpecType_StorageDeviceList)(nil),
		(*ReplaceSpecType_DefaultStorageClass)(nil),
		(*ReplaceSpecType_StorageClassList)(nil),
		(*ReplaceSpecType_NoDcClusterGroup)(nil),
		(*ReplaceSpecType_DcClusterGroup)(nil),
		(*ReplaceSpecType_DcClusterGroupInside)(nil),
		(*ReplaceSpecType_DisableGpu)(nil),
		(*ReplaceSpecType_EnableGpu)(nil),
		(*ReplaceSpecType_EnableVgpu)(nil),
		(*ReplaceSpecType_NoStorageStaticRoutes)(nil),
		(*ReplaceSpecType_StorageStaticRoutes)(nil),
		(*ReplaceSpecType_LogsStreamingDisabled)(nil),
		(*ReplaceSpecType_LogReceiver)(nil),
		(*ReplaceSpecType_DenyAllUsb)(nil),
		(*ReplaceSpecType_AllowAllUsb)(nil),
		(*ReplaceSpecType_UsbPolicy)(nil),
		(*ReplaceSpecType_DisableVm)(nil),
		(*ReplaceSpecType_EnableVm)(nil),
	}
}

// Get fleet
//
// x-displayName: "Get Fleet"
// Get fleet will get fleet object from system namespace
type GetSpecType struct {
	FleetLabel              string                  `protobuf:"bytes,1,opt,name=fleet_label,json=fleetLabel,proto3" json:"fleet_label,omitempty"`
	VolterraSoftwareVersion string                  `protobuf:"bytes,2,opt,name=volterra_software_version,json=volterraSoftwareVersion,proto3" json:"volterra_software_version,omitempty"`
	NetworkConnectors       []*schema.ObjectRefType `protobuf:"bytes,4,rep,name=network_connectors,json=networkConnectors,proto3" json:"network_connectors,omitempty"`
	NetworkFirewall         []*schema.ObjectRefType `protobuf:"bytes,5,rep,name=network_firewall,json=networkFirewall,proto3" json:"network_firewall,omitempty"`
	OperatingSystemVersion  string                  `protobuf:"bytes,6,opt,name=operating_system_version,json=operatingSystemVersion,proto3" json:"operating_system_version,omitempty"`
	OutsideVirtualNetwork   []*schema.ObjectRefType `protobuf:"bytes,7,rep,name=outside_virtual_network,json=outsideVirtualNetwork,proto3" json:"outside_virtual_network,omitempty"`
	InsideVirtualNetwork    []*schema.ObjectRefType `protobuf:"bytes,8,rep,name=inside_virtual_network,json=insideVirtualNetwork,proto3" json:"inside_virtual_network,omitempty"`
	// Select Interface Config
	//
	// x-displayName: "Select Interface Config"
	// x-required
	// Select how interfaces are configured for this fleet
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*GetSpecType_InterfaceList
	//	*GetSpecType_DefaultConfig
	//	*GetSpecType_DeviceList
	InterfaceChoice isGetSpecType_InterfaceChoice `protobuf_oneof:"interface_choice"`
	// Types that are valid to be assigned to BondChoice:
	//	*GetSpecType_NoBondDevices
	//	*GetSpecType_BondDeviceList
	BondChoice isGetSpecType_BondChoice `protobuf_oneof:"bond_choice"`
	// Types that are valid to be assigned to StorageInterfaceChoice:
	//	*GetSpecType_NoStorageInterfaces
	//	*GetSpecType_StorageInterfaceList
	StorageInterfaceChoice isGetSpecType_StorageInterfaceChoice `protobuf_oneof:"storage_interface_choice"`
	// Types that are valid to be assigned to StorageDeviceChoice:
	//	*GetSpecType_NoStorageDevice
	//	*GetSpecType_StorageDeviceList
	StorageDeviceChoice isGetSpecType_StorageDeviceChoice `protobuf_oneof:"storage_device_choice"`
	// Types that are valid to be assigned to StorageClassChoice:
	//	*GetSpecType_DefaultStorageClass
	//	*GetSpecType_StorageClassList
	StorageClassChoice isGetSpecType_StorageClassChoice `protobuf_oneof:"storage_class_choice"`
	// Types that are valid to be assigned to DcClusterGroupChoice:
	//	*GetSpecType_NoDcClusterGroup
	//	*GetSpecType_DcClusterGroup
	//	*GetSpecType_DcClusterGroupInside
	DcClusterGroupChoice isGetSpecType_DcClusterGroupChoice `protobuf_oneof:"dc_cluster_group_choice"`
	// Types that are valid to be assigned to GpuChoice:
	//	*GetSpecType_DisableGpu
	//	*GetSpecType_EnableGpu
	//	*GetSpecType_EnableVgpu
	GpuChoice isGetSpecType_GpuChoice `protobuf_oneof:"gpu_choice"`
	// Types that are valid to be assigned to StorageStaticRoutesChoice:
	//	*GetSpecType_NoStorageStaticRoutes
	//	*GetSpecType_StorageStaticRoutes
	StorageStaticRoutesChoice        isGetSpecType_StorageStaticRoutesChoice `protobuf_oneof:"storage_static_routes_choice"`
	EnableDefaultFleetConfigDownload bool                                    `protobuf:"varint,37,opt,name=enable_default_fleet_config_download,json=enableDefaultFleetConfigDownload,proto3" json:"enable_default_fleet_config_download,omitempty"`
	// Types that are valid to be assigned to LogsReceiverChoice:
	//	*GetSpecType_LogsStreamingDisabled
	//	*GetSpecType_LogReceiver
	LogsReceiverChoice isGetSpecType_LogsReceiverChoice `protobuf_oneof:"logs_receiver_choice"`
	// Types that are valid to be assigned to UsbPolicyChoice:
	//	*GetSpecType_DenyAllUsb
	//	*GetSpecType_AllowAllUsb
	//	*GetSpecType_UsbPolicy
	UsbPolicyChoice isGetSpecType_UsbPolicyChoice `protobuf_oneof:"usb_policy_choice"`
	// Types that are valid to be assigned to VmChoice:
	//	*GetSpecType_DisableVm
	//	*GetSpecType_EnableVm
	VmChoice isGetSpecType_VmChoice `protobuf_oneof:"vm_choice"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{42}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_InterfaceChoice interface {
	isGetSpecType_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_BondChoice interface {
	isGetSpecType_BondChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_StorageInterfaceChoice interface {
	isGetSpecType_StorageInterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_StorageDeviceChoice interface {
	isGetSpecType_StorageDeviceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_StorageClassChoice interface {
	isGetSpecType_StorageClassChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_DcClusterGroupChoice interface {
	isGetSpecType_DcClusterGroupChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_GpuChoice interface {
	isGetSpecType_GpuChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_StorageStaticRoutesChoice interface {
	isGetSpecType_StorageStaticRoutesChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_LogsReceiverChoice interface {
	isGetSpecType_LogsReceiverChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_UsbPolicyChoice interface {
	isGetSpecType_UsbPolicyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_VmChoice interface {
	isGetSpecType_VmChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_InterfaceList struct {
	InterfaceList *FleetInterfaceListType `protobuf:"bytes,13,opt,name=interface_list,json=interfaceList,proto3,oneof" json:"interface_list,omitempty"`
}
type GetSpecType_DefaultConfig struct {
	DefaultConfig *schema.Empty `protobuf:"bytes,40,opt,name=default_config,json=defaultConfig,proto3,oneof" json:"default_config,omitempty"`
}
type GetSpecType_DeviceList struct {
	DeviceList *FleetDeviceListType `protobuf:"bytes,14,opt,name=device_list,json=deviceList,proto3,oneof" json:"device_list,omitempty"`
}
type GetSpecType_NoBondDevices struct {
	NoBondDevices *schema.Empty `protobuf:"bytes,16,opt,name=no_bond_devices,json=noBondDevices,proto3,oneof" json:"no_bond_devices,omitempty"`
}
type GetSpecType_BondDeviceList struct {
	BondDeviceList *FleetBondDevicesListType `protobuf:"bytes,17,opt,name=bond_device_list,json=bondDeviceList,proto3,oneof" json:"bond_device_list,omitempty"`
}
type GetSpecType_NoStorageInterfaces struct {
	NoStorageInterfaces *schema.Empty `protobuf:"bytes,19,opt,name=no_storage_interfaces,json=noStorageInterfaces,proto3,oneof" json:"no_storage_interfaces,omitempty"`
}
type GetSpecType_StorageInterfaceList struct {
	StorageInterfaceList *FleetInterfaceListType `protobuf:"bytes,20,opt,name=storage_interface_list,json=storageInterfaceList,proto3,oneof" json:"storage_interface_list,omitempty"`
}
type GetSpecType_NoStorageDevice struct {
	NoStorageDevice *schema.Empty `protobuf:"bytes,22,opt,name=no_storage_device,json=noStorageDevice,proto3,oneof" json:"no_storage_device,omitempty"`
}
type GetSpecType_StorageDeviceList struct {
	StorageDeviceList *FleetStorageDeviceListType `protobuf:"bytes,23,opt,name=storage_device_list,json=storageDeviceList,proto3,oneof" json:"storage_device_list,omitempty"`
}
type GetSpecType_DefaultStorageClass struct {
	DefaultStorageClass *schema.Empty `protobuf:"bytes,25,opt,name=default_storage_class,json=defaultStorageClass,proto3,oneof" json:"default_storage_class,omitempty"`
}
type GetSpecType_StorageClassList struct {
	StorageClassList *FleetStorageClassListType `protobuf:"bytes,26,opt,name=storage_class_list,json=storageClassList,proto3,oneof" json:"storage_class_list,omitempty"`
}
type GetSpecType_NoDcClusterGroup struct {
	NoDcClusterGroup *schema.Empty `protobuf:"bytes,28,opt,name=no_dc_cluster_group,json=noDcClusterGroup,proto3,oneof" json:"no_dc_cluster_group,omitempty"`
}
type GetSpecType_DcClusterGroup struct {
	DcClusterGroup *views.ObjectRefType `protobuf:"bytes,29,opt,name=dc_cluster_group,json=dcClusterGroup,proto3,oneof" json:"dc_cluster_group,omitempty"`
}
type GetSpecType_DcClusterGroupInside struct {
	DcClusterGroupInside *views.ObjectRefType `protobuf:"bytes,38,opt,name=dc_cluster_group_inside,json=dcClusterGroupInside,proto3,oneof" json:"dc_cluster_group_inside,omitempty"`
}
type GetSpecType_DisableGpu struct {
	DisableGpu *schema.Empty `protobuf:"bytes,31,opt,name=disable_gpu,json=disableGpu,proto3,oneof" json:"disable_gpu,omitempty"`
}
type GetSpecType_EnableGpu struct {
	EnableGpu *schema.Empty `protobuf:"bytes,32,opt,name=enable_gpu,json=enableGpu,proto3,oneof" json:"enable_gpu,omitempty"`
}
type GetSpecType_EnableVgpu struct {
	EnableVgpu *VGPUConfiguration `protobuf:"bytes,52,opt,name=enable_vgpu,json=enableVgpu,proto3,oneof" json:"enable_vgpu,omitempty"`
}
type GetSpecType_NoStorageStaticRoutes struct {
	NoStorageStaticRoutes *schema.Empty `protobuf:"bytes,35,opt,name=no_storage_static_routes,json=noStorageStaticRoutes,proto3,oneof" json:"no_storage_static_routes,omitempty"`
}
type GetSpecType_StorageStaticRoutes struct {
	StorageStaticRoutes *FleetStorageStaticRoutesListType `protobuf:"bytes,36,opt,name=storage_static_routes,json=storageStaticRoutes,proto3,oneof" json:"storage_static_routes,omitempty"`
}
type GetSpecType_LogsStreamingDisabled struct {
	LogsStreamingDisabled *schema.Empty `protobuf:"bytes,44,opt,name=logs_streaming_disabled,json=logsStreamingDisabled,proto3,oneof" json:"logs_streaming_disabled,omitempty"`
}
type GetSpecType_LogReceiver struct {
	LogReceiver *views.ObjectRefType `protobuf:"bytes,45,opt,name=log_receiver,json=logReceiver,proto3,oneof" json:"log_receiver,omitempty"`
}
type GetSpecType_DenyAllUsb struct {
	DenyAllUsb *schema.Empty `protobuf:"bytes,47,opt,name=deny_all_usb,json=denyAllUsb,proto3,oneof" json:"deny_all_usb,omitempty"`
}
type GetSpecType_AllowAllUsb struct {
	AllowAllUsb *schema.Empty `protobuf:"bytes,48,opt,name=allow_all_usb,json=allowAllUsb,proto3,oneof" json:"allow_all_usb,omitempty"`
}
type GetSpecType_UsbPolicy struct {
	UsbPolicy *views.ObjectRefType `protobuf:"bytes,49,opt,name=usb_policy,json=usbPolicy,proto3,oneof" json:"usb_policy,omitempty"`
}
type GetSpecType_DisableVm struct {
	DisableVm *schema.Empty `protobuf:"bytes,56,opt,name=disable_vm,json=disableVm,proto3,oneof" json:"disable_vm,omitempty"`
}
type GetSpecType_EnableVm struct {
	EnableVm *VMConfiguration `protobuf:"bytes,57,opt,name=enable_vm,json=enableVm,proto3,oneof" json:"enable_vm,omitempty"`
}

func (*GetSpecType_InterfaceList) isGetSpecType_InterfaceChoice()                   {}
func (*GetSpecType_DefaultConfig) isGetSpecType_InterfaceChoice()                   {}
func (*GetSpecType_DeviceList) isGetSpecType_InterfaceChoice()                      {}
func (*GetSpecType_NoBondDevices) isGetSpecType_BondChoice()                        {}
func (*GetSpecType_BondDeviceList) isGetSpecType_BondChoice()                       {}
func (*GetSpecType_NoStorageInterfaces) isGetSpecType_StorageInterfaceChoice()      {}
func (*GetSpecType_StorageInterfaceList) isGetSpecType_StorageInterfaceChoice()     {}
func (*GetSpecType_NoStorageDevice) isGetSpecType_StorageDeviceChoice()             {}
func (*GetSpecType_StorageDeviceList) isGetSpecType_StorageDeviceChoice()           {}
func (*GetSpecType_DefaultStorageClass) isGetSpecType_StorageClassChoice()          {}
func (*GetSpecType_StorageClassList) isGetSpecType_StorageClassChoice()             {}
func (*GetSpecType_NoDcClusterGroup) isGetSpecType_DcClusterGroupChoice()           {}
func (*GetSpecType_DcClusterGroup) isGetSpecType_DcClusterGroupChoice()             {}
func (*GetSpecType_DcClusterGroupInside) isGetSpecType_DcClusterGroupChoice()       {}
func (*GetSpecType_DisableGpu) isGetSpecType_GpuChoice()                            {}
func (*GetSpecType_EnableGpu) isGetSpecType_GpuChoice()                             {}
func (*GetSpecType_EnableVgpu) isGetSpecType_GpuChoice()                            {}
func (*GetSpecType_NoStorageStaticRoutes) isGetSpecType_StorageStaticRoutesChoice() {}
func (*GetSpecType_StorageStaticRoutes) isGetSpecType_StorageStaticRoutesChoice()   {}
func (*GetSpecType_LogsStreamingDisabled) isGetSpecType_LogsReceiverChoice()        {}
func (*GetSpecType_LogReceiver) isGetSpecType_LogsReceiverChoice()                  {}
func (*GetSpecType_DenyAllUsb) isGetSpecType_UsbPolicyChoice()                      {}
func (*GetSpecType_AllowAllUsb) isGetSpecType_UsbPolicyChoice()                     {}
func (*GetSpecType_UsbPolicy) isGetSpecType_UsbPolicyChoice()                       {}
func (*GetSpecType_DisableVm) isGetSpecType_VmChoice()                              {}
func (*GetSpecType_EnableVm) isGetSpecType_VmChoice()                               {}

func (m *GetSpecType) GetInterfaceChoice() isGetSpecType_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}
func (m *GetSpecType) GetBondChoice() isGetSpecType_BondChoice {
	if m != nil {
		return m.BondChoice
	}
	return nil
}
func (m *GetSpecType) GetStorageInterfaceChoice() isGetSpecType_StorageInterfaceChoice {
	if m != nil {
		return m.StorageInterfaceChoice
	}
	return nil
}
func (m *GetSpecType) GetStorageDeviceChoice() isGetSpecType_StorageDeviceChoice {
	if m != nil {
		return m.StorageDeviceChoice
	}
	return nil
}
func (m *GetSpecType) GetStorageClassChoice() isGetSpecType_StorageClassChoice {
	if m != nil {
		return m.StorageClassChoice
	}
	return nil
}
func (m *GetSpecType) GetDcClusterGroupChoice() isGetSpecType_DcClusterGroupChoice {
	if m != nil {
		return m.DcClusterGroupChoice
	}
	return nil
}
func (m *GetSpecType) GetGpuChoice() isGetSpecType_GpuChoice {
	if m != nil {
		return m.GpuChoice
	}
	return nil
}
func (m *GetSpecType) GetStorageStaticRoutesChoice() isGetSpecType_StorageStaticRoutesChoice {
	if m != nil {
		return m.StorageStaticRoutesChoice
	}
	return nil
}
func (m *GetSpecType) GetLogsReceiverChoice() isGetSpecType_LogsReceiverChoice {
	if m != nil {
		return m.LogsReceiverChoice
	}
	return nil
}
func (m *GetSpecType) GetUsbPolicyChoice() isGetSpecType_UsbPolicyChoice {
	if m != nil {
		return m.UsbPolicyChoice
	}
	return nil
}
func (m *GetSpecType) GetVmChoice() isGetSpecType_VmChoice {
	if m != nil {
		return m.VmChoice
	}
	return nil
}

func (m *GetSpecType) GetFleetLabel() string {
	if m != nil {
		return m.FleetLabel
	}
	return ""
}

func (m *GetSpecType) GetVolterraSoftwareVersion() string {
	if m != nil {
		return m.VolterraSoftwareVersion
	}
	return ""
}

func (m *GetSpecType) GetNetworkConnectors() []*schema.ObjectRefType {
	if m != nil {
		return m.NetworkConnectors
	}
	return nil
}

func (m *GetSpecType) GetNetworkFirewall() []*schema.ObjectRefType {
	if m != nil {
		return m.NetworkFirewall
	}
	return nil
}

func (m *GetSpecType) GetOperatingSystemVersion() string {
	if m != nil {
		return m.OperatingSystemVersion
	}
	return ""
}

func (m *GetSpecType) GetOutsideVirtualNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.OutsideVirtualNetwork
	}
	return nil
}

func (m *GetSpecType) GetInsideVirtualNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.InsideVirtualNetwork
	}
	return nil
}

func (m *GetSpecType) GetInterfaceList() *FleetInterfaceListType {
	if x, ok := m.GetInterfaceChoice().(*GetSpecType_InterfaceList); ok {
		return x.InterfaceList
	}
	return nil
}

func (m *GetSpecType) GetDefaultConfig() *schema.Empty {
	if x, ok := m.GetInterfaceChoice().(*GetSpecType_DefaultConfig); ok {
		return x.DefaultConfig
	}
	return nil
}

func (m *GetSpecType) GetDeviceList() *FleetDeviceListType {
	if x, ok := m.GetInterfaceChoice().(*GetSpecType_DeviceList); ok {
		return x.DeviceList
	}
	return nil
}

func (m *GetSpecType) GetNoBondDevices() *schema.Empty {
	if x, ok := m.GetBondChoice().(*GetSpecType_NoBondDevices); ok {
		return x.NoBondDevices
	}
	return nil
}

func (m *GetSpecType) GetBondDeviceList() *FleetBondDevicesListType {
	if x, ok := m.GetBondChoice().(*GetSpecType_BondDeviceList); ok {
		return x.BondDeviceList
	}
	return nil
}

func (m *GetSpecType) GetNoStorageInterfaces() *schema.Empty {
	if x, ok := m.GetStorageInterfaceChoice().(*GetSpecType_NoStorageInterfaces); ok {
		return x.NoStorageInterfaces
	}
	return nil
}

func (m *GetSpecType) GetStorageInterfaceList() *FleetInterfaceListType {
	if x, ok := m.GetStorageInterfaceChoice().(*GetSpecType_StorageInterfaceList); ok {
		return x.StorageInterfaceList
	}
	return nil
}

func (m *GetSpecType) GetNoStorageDevice() *schema.Empty {
	if x, ok := m.GetStorageDeviceChoice().(*GetSpecType_NoStorageDevice); ok {
		return x.NoStorageDevice
	}
	return nil
}

func (m *GetSpecType) GetStorageDeviceList() *FleetStorageDeviceListType {
	if x, ok := m.GetStorageDeviceChoice().(*GetSpecType_StorageDeviceList); ok {
		return x.StorageDeviceList
	}
	return nil
}

func (m *GetSpecType) GetDefaultStorageClass() *schema.Empty {
	if x, ok := m.GetStorageClassChoice().(*GetSpecType_DefaultStorageClass); ok {
		return x.DefaultStorageClass
	}
	return nil
}

func (m *GetSpecType) GetStorageClassList() *FleetStorageClassListType {
	if x, ok := m.GetStorageClassChoice().(*GetSpecType_StorageClassList); ok {
		return x.StorageClassList
	}
	return nil
}

func (m *GetSpecType) GetNoDcClusterGroup() *schema.Empty {
	if x, ok := m.GetDcClusterGroupChoice().(*GetSpecType_NoDcClusterGroup); ok {
		return x.NoDcClusterGroup
	}
	return nil
}

func (m *GetSpecType) GetDcClusterGroup() *views.ObjectRefType {
	if x, ok := m.GetDcClusterGroupChoice().(*GetSpecType_DcClusterGroup); ok {
		return x.DcClusterGroup
	}
	return nil
}

func (m *GetSpecType) GetDcClusterGroupInside() *views.ObjectRefType {
	if x, ok := m.GetDcClusterGroupChoice().(*GetSpecType_DcClusterGroupInside); ok {
		return x.DcClusterGroupInside
	}
	return nil
}

func (m *GetSpecType) GetDisableGpu() *schema.Empty {
	if x, ok := m.GetGpuChoice().(*GetSpecType_DisableGpu); ok {
		return x.DisableGpu
	}
	return nil
}

func (m *GetSpecType) GetEnableGpu() *schema.Empty {
	if x, ok := m.GetGpuChoice().(*GetSpecType_EnableGpu); ok {
		return x.EnableGpu
	}
	return nil
}

func (m *GetSpecType) GetEnableVgpu() *VGPUConfiguration {
	if x, ok := m.GetGpuChoice().(*GetSpecType_EnableVgpu); ok {
		return x.EnableVgpu
	}
	return nil
}

func (m *GetSpecType) GetNoStorageStaticRoutes() *schema.Empty {
	if x, ok := m.GetStorageStaticRoutesChoice().(*GetSpecType_NoStorageStaticRoutes); ok {
		return x.NoStorageStaticRoutes
	}
	return nil
}

func (m *GetSpecType) GetStorageStaticRoutes() *FleetStorageStaticRoutesListType {
	if x, ok := m.GetStorageStaticRoutesChoice().(*GetSpecType_StorageStaticRoutes); ok {
		return x.StorageStaticRoutes
	}
	return nil
}

func (m *GetSpecType) GetEnableDefaultFleetConfigDownload() bool {
	if m != nil {
		return m.EnableDefaultFleetConfigDownload
	}
	return false
}

func (m *GetSpecType) GetLogsStreamingDisabled() *schema.Empty {
	if x, ok := m.GetLogsReceiverChoice().(*GetSpecType_LogsStreamingDisabled); ok {
		return x.LogsStreamingDisabled
	}
	return nil
}

func (m *GetSpecType) GetLogReceiver() *views.ObjectRefType {
	if x, ok := m.GetLogsReceiverChoice().(*GetSpecType_LogReceiver); ok {
		return x.LogReceiver
	}
	return nil
}

func (m *GetSpecType) GetDenyAllUsb() *schema.Empty {
	if x, ok := m.GetUsbPolicyChoice().(*GetSpecType_DenyAllUsb); ok {
		return x.DenyAllUsb
	}
	return nil
}

func (m *GetSpecType) GetAllowAllUsb() *schema.Empty {
	if x, ok := m.GetUsbPolicyChoice().(*GetSpecType_AllowAllUsb); ok {
		return x.AllowAllUsb
	}
	return nil
}

func (m *GetSpecType) GetUsbPolicy() *views.ObjectRefType {
	if x, ok := m.GetUsbPolicyChoice().(*GetSpecType_UsbPolicy); ok {
		return x.UsbPolicy
	}
	return nil
}

func (m *GetSpecType) GetDisableVm() *schema.Empty {
	if x, ok := m.GetVmChoice().(*GetSpecType_DisableVm); ok {
		return x.DisableVm
	}
	return nil
}

func (m *GetSpecType) GetEnableVm() *VMConfiguration {
	if x, ok := m.GetVmChoice().(*GetSpecType_EnableVm); ok {
		return x.EnableVm
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_InterfaceList)(nil),
		(*GetSpecType_DefaultConfig)(nil),
		(*GetSpecType_DeviceList)(nil),
		(*GetSpecType_NoBondDevices)(nil),
		(*GetSpecType_BondDeviceList)(nil),
		(*GetSpecType_NoStorageInterfaces)(nil),
		(*GetSpecType_StorageInterfaceList)(nil),
		(*GetSpecType_NoStorageDevice)(nil),
		(*GetSpecType_StorageDeviceList)(nil),
		(*GetSpecType_DefaultStorageClass)(nil),
		(*GetSpecType_StorageClassList)(nil),
		(*GetSpecType_NoDcClusterGroup)(nil),
		(*GetSpecType_DcClusterGroup)(nil),
		(*GetSpecType_DcClusterGroupInside)(nil),
		(*GetSpecType_DisableGpu)(nil),
		(*GetSpecType_EnableGpu)(nil),
		(*GetSpecType_EnableVgpu)(nil),
		(*GetSpecType_NoStorageStaticRoutes)(nil),
		(*GetSpecType_StorageStaticRoutes)(nil),
		(*GetSpecType_LogsStreamingDisabled)(nil),
		(*GetSpecType_LogReceiver)(nil),
		(*GetSpecType_DenyAllUsb)(nil),
		(*GetSpecType_AllowAllUsb)(nil),
		(*GetSpecType_UsbPolicy)(nil),
		(*GetSpecType_DisableVm)(nil),
		(*GetSpecType_EnableVm)(nil),
	}
}

// Fleet Status
//
// x-displayName: "Fleet Status"
// Current status of fleet
type FleetStatus struct {
	// Software Version
	//
	// x-displayName: "Software Version"
	// Current software version used by the site
	AvailableSoftwareVersion string `protobuf:"bytes,1,opt,name=available_software_version,json=availableSoftwareVersion,proto3" json:"available_software_version,omitempty"`
}

func (m *FleetStatus) Reset()      { *m = FleetStatus{} }
func (*FleetStatus) ProtoMessage() {}
func (*FleetStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_82c3333ba2789298, []int{43}
}
func (m *FleetStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FleetStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FleetStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FleetStatus.Merge(m, src)
}
func (m *FleetStatus) XXX_Size() int {
	return m.Size()
}
func (m *FleetStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_FleetStatus.DiscardUnknown(m)
}

var xxx_messageInfo_FleetStatus proto.InternalMessageInfo

func (m *FleetStatus) GetAvailableSoftwareVersion() string {
	if m != nil {
		return m.AvailableSoftwareVersion
	}
	return ""
}

func init() {
	proto.RegisterEnum("ves.io.schema.fleet.EtcdClusterNetworkType", EtcdClusterNetworkType_name, EtcdClusterNetworkType_value)
	golang_proto.RegisterEnum("ves.io.schema.fleet.EtcdClusterNetworkType", EtcdClusterNetworkType_name, EtcdClusterNetworkType_value)
	proto.RegisterEnum("ves.io.schema.fleet.DeviceOwnerType", DeviceOwnerType_name, DeviceOwnerType_value)
	golang_proto.RegisterEnum("ves.io.schema.fleet.DeviceOwnerType", DeviceOwnerType_name, DeviceOwnerType_value)
	proto.RegisterEnum("ves.io.schema.fleet.FleetType", FleetType_name, FleetType_value)
	golang_proto.RegisterEnum("ves.io.schema.fleet.FleetType", FleetType_name, FleetType_value)
	proto.RegisterEnum("ves.io.schema.fleet.NetworkingDeviceInstanceUseType", NetworkingDeviceInstanceUseType_name, NetworkingDeviceInstanceUseType_value)
	golang_proto.RegisterEnum("ves.io.schema.fleet.NetworkingDeviceInstanceUseType", NetworkingDeviceInstanceUseType_name, NetworkingDeviceInstanceUseType_value)
	proto.RegisterEnum("ves.io.schema.fleet.VGPUFeatureType", VGPUFeatureType_name, VGPUFeatureType_value)
	golang_proto.RegisterEnum("ves.io.schema.fleet.VGPUFeatureType", VGPUFeatureType_name, VGPUFeatureType_value)
	proto.RegisterType((*NetworkingDeviceInstanceType)(nil), "ves.io.schema.fleet.NetworkingDeviceInstanceType")
	golang_proto.RegisterType((*NetworkingDeviceInstanceType)(nil), "ves.io.schema.fleet.NetworkingDeviceInstanceType")
	proto.RegisterType((*GenericDeviceInstanceType)(nil), "ves.io.schema.fleet.GenericDeviceInstanceType")
	golang_proto.RegisterType((*GenericDeviceInstanceType)(nil), "ves.io.schema.fleet.GenericDeviceInstanceType")
	proto.RegisterType((*DeviceInstanceType)(nil), "ves.io.schema.fleet.DeviceInstanceType")
	golang_proto.RegisterType((*DeviceInstanceType)(nil), "ves.io.schema.fleet.DeviceInstanceType")
	proto.RegisterType((*FleetInterfaceListType)(nil), "ves.io.schema.fleet.FleetInterfaceListType")
	golang_proto.RegisterType((*FleetInterfaceListType)(nil), "ves.io.schema.fleet.FleetInterfaceListType")
	proto.RegisterType((*FleetDeviceListType)(nil), "ves.io.schema.fleet.FleetDeviceListType")
	golang_proto.RegisterType((*FleetDeviceListType)(nil), "ves.io.schema.fleet.FleetDeviceListType")
	proto.RegisterType((*StorageDeviceOpenebsEnterpriseType)(nil), "ves.io.schema.fleet.StorageDeviceOpenebsEnterpriseType")
	golang_proto.RegisterType((*StorageDeviceOpenebsEnterpriseType)(nil), "ves.io.schema.fleet.StorageDeviceOpenebsEnterpriseType")
	proto.RegisterType((*OpenebsMayastorPoolType)(nil), "ves.io.schema.fleet.OpenebsMayastorPoolType")
	golang_proto.RegisterType((*OpenebsMayastorPoolType)(nil), "ves.io.schema.fleet.OpenebsMayastorPoolType")
	proto.RegisterType((*StorageDeviceDellIsilonF800Type)(nil), "ves.io.schema.fleet.StorageDeviceDellIsilonF800Type")
	golang_proto.RegisterType((*StorageDeviceDellIsilonF800Type)(nil), "ves.io.schema.fleet.StorageDeviceDellIsilonF800Type")
	proto.RegisterType((*StorageDeviceHPENimbusStorageAf40Type)(nil), "ves.io.schema.fleet.StorageDeviceHPENimbusStorageAf40Type")
	golang_proto.RegisterType((*StorageDeviceHPENimbusStorageAf40Type)(nil), "ves.io.schema.fleet.StorageDeviceHPENimbusStorageAf40Type")
	proto.RegisterType((*StorageDevicePureStorageServiceOrchestratorType)(nil), "ves.io.schema.fleet.StorageDevicePureStorageServiceOrchestratorType")
	golang_proto.RegisterType((*StorageDevicePureStorageServiceOrchestratorType)(nil), "ves.io.schema.fleet.StorageDevicePureStorageServiceOrchestratorType")
	proto.RegisterType((*PsoArrayConfiguration)(nil), "ves.io.schema.fleet.PsoArrayConfiguration")
	golang_proto.RegisterType((*PsoArrayConfiguration)(nil), "ves.io.schema.fleet.PsoArrayConfiguration")
	proto.RegisterType((*FlashBladeType)(nil), "ves.io.schema.fleet.FlashBladeType")
	golang_proto.RegisterType((*FlashBladeType)(nil), "ves.io.schema.fleet.FlashBladeType")
	proto.RegisterType((*FlashBladeEndpoint)(nil), "ves.io.schema.fleet.FlashBladeEndpoint")
	golang_proto.RegisterType((*FlashBladeEndpoint)(nil), "ves.io.schema.fleet.FlashBladeEndpoint")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.fleet.FlashBladeEndpoint.LablesEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.fleet.FlashBladeEndpoint.LablesEntry")
	proto.RegisterType((*FlashArrayType)(nil), "ves.io.schema.fleet.FlashArrayType")
	golang_proto.RegisterType((*FlashArrayType)(nil), "ves.io.schema.fleet.FlashArrayType")
	proto.RegisterType((*FlashArrayEndpoint)(nil), "ves.io.schema.fleet.FlashArrayEndpoint")
	golang_proto.RegisterType((*FlashArrayEndpoint)(nil), "ves.io.schema.fleet.FlashArrayEndpoint")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.fleet.FlashArrayEndpoint.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.fleet.FlashArrayEndpoint.LabelsEntry")
	proto.RegisterType((*StorageDeviceNetappTridentType)(nil), "ves.io.schema.fleet.StorageDeviceNetappTridentType")
	golang_proto.RegisterType((*StorageDeviceNetappTridentType)(nil), "ves.io.schema.fleet.StorageDeviceNetappTridentType")
	proto.RegisterType((*StorageDeviceNetappBackendOntapSanType)(nil), "ves.io.schema.fleet.StorageDeviceNetappBackendOntapSanType")
	golang_proto.RegisterType((*StorageDeviceNetappBackendOntapSanType)(nil), "ves.io.schema.fleet.StorageDeviceNetappBackendOntapSanType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.fleet.StorageDeviceNetappBackendOntapSanType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.fleet.StorageDeviceNetappBackendOntapSanType.LabelsEntry")
	proto.RegisterType((*DeviceNetappBackendOntapSanChapType)(nil), "ves.io.schema.fleet.DeviceNetappBackendOntapSanChapType")
	golang_proto.RegisterType((*DeviceNetappBackendOntapSanChapType)(nil), "ves.io.schema.fleet.DeviceNetappBackendOntapSanChapType")
	proto.RegisterType((*StorageDeviceNetappBackendOntapNasType)(nil), "ves.io.schema.fleet.StorageDeviceNetappBackendOntapNasType")
	golang_proto.RegisterType((*StorageDeviceNetappBackendOntapNasType)(nil), "ves.io.schema.fleet.StorageDeviceNetappBackendOntapNasType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.fleet.StorageDeviceNetappBackendOntapNasType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.fleet.StorageDeviceNetappBackendOntapNasType.LabelsEntry")
	proto.RegisterType((*OntapVolumeDefaults)(nil), "ves.io.schema.fleet.OntapVolumeDefaults")
	golang_proto.RegisterType((*OntapVolumeDefaults)(nil), "ves.io.schema.fleet.OntapVolumeDefaults")
	proto.RegisterType((*OntapVirtualStoragePoolType)(nil), "ves.io.schema.fleet.OntapVirtualStoragePoolType")
	golang_proto.RegisterType((*OntapVirtualStoragePoolType)(nil), "ves.io.schema.fleet.OntapVirtualStoragePoolType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.fleet.OntapVirtualStoragePoolType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.fleet.OntapVirtualStoragePoolType.LabelsEntry")
	proto.RegisterType((*FleetStorageDeviceType)(nil), "ves.io.schema.fleet.FleetStorageDeviceType")
	golang_proto.RegisterType((*FleetStorageDeviceType)(nil), "ves.io.schema.fleet.FleetStorageDeviceType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.fleet.FleetStorageDeviceType.AdvancedAdvancedParametersEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.fleet.FleetStorageDeviceType.AdvancedAdvancedParametersEntry")
	proto.RegisterType((*FleetStorageDeviceListType)(nil), "ves.io.schema.fleet.FleetStorageDeviceListType")
	golang_proto.RegisterType((*FleetStorageDeviceListType)(nil), "ves.io.schema.fleet.FleetStorageDeviceListType")
	proto.RegisterType((*StorageClassDellIsilonF800Type)(nil), "ves.io.schema.fleet.StorageClassDellIsilonF800Type")
	golang_proto.RegisterType((*StorageClassDellIsilonF800Type)(nil), "ves.io.schema.fleet.StorageClassDellIsilonF800Type")
	proto.RegisterType((*StorageClassHPENimbusStorageAf40Type)(nil), "ves.io.schema.fleet.StorageClassHPENimbusStorageAf40Type")
	golang_proto.RegisterType((*StorageClassHPENimbusStorageAf40Type)(nil), "ves.io.schema.fleet.StorageClassHPENimbusStorageAf40Type")
	proto.RegisterType((*StorageClassOpenebsEnterpriseType)(nil), "ves.io.schema.fleet.StorageClassOpenebsEnterpriseType")
	golang_proto.RegisterType((*StorageClassOpenebsEnterpriseType)(nil), "ves.io.schema.fleet.StorageClassOpenebsEnterpriseType")
	proto.RegisterType((*StorageClassNetappTridentType)(nil), "ves.io.schema.fleet.StorageClassNetappTridentType")
	golang_proto.RegisterType((*StorageClassNetappTridentType)(nil), "ves.io.schema.fleet.StorageClassNetappTridentType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.fleet.StorageClassNetappTridentType.SelectorEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.fleet.StorageClassNetappTridentType.SelectorEntry")
	proto.RegisterType((*StorageClassPureServiceOrchestratorType)(nil), "ves.io.schema.fleet.StorageClassPureServiceOrchestratorType")
	golang_proto.RegisterType((*StorageClassPureServiceOrchestratorType)(nil), "ves.io.schema.fleet.StorageClassPureServiceOrchestratorType")
	proto.RegisterType((*StorageClassCustomType)(nil), "ves.io.schema.fleet.StorageClassCustomType")
	golang_proto.RegisterType((*StorageClassCustomType)(nil), "ves.io.schema.fleet.StorageClassCustomType")
	proto.RegisterType((*FleetStorageClassType)(nil), "ves.io.schema.fleet.FleetStorageClassType")
	golang_proto.RegisterType((*FleetStorageClassType)(nil), "ves.io.schema.fleet.FleetStorageClassType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.fleet.FleetStorageClassType.AdvancedStorageParametersEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.fleet.FleetStorageClassType.AdvancedStorageParametersEntry")
	proto.RegisterType((*FleetStorageClassListType)(nil), "ves.io.schema.fleet.FleetStorageClassListType")
	golang_proto.RegisterType((*FleetStorageClassListType)(nil), "ves.io.schema.fleet.FleetStorageClassListType")
	proto.RegisterType((*BondLacpType)(nil), "ves.io.schema.fleet.BondLacpType")
	golang_proto.RegisterType((*BondLacpType)(nil), "ves.io.schema.fleet.BondLacpType")
	proto.RegisterType((*FleetBondDeviceType)(nil), "ves.io.schema.fleet.FleetBondDeviceType")
	golang_proto.RegisterType((*FleetBondDeviceType)(nil), "ves.io.schema.fleet.FleetBondDeviceType")
	proto.RegisterType((*FleetBondDevicesListType)(nil), "ves.io.schema.fleet.FleetBondDevicesListType")
	golang_proto.RegisterType((*FleetBondDevicesListType)(nil), "ves.io.schema.fleet.FleetBondDevicesListType")
	proto.RegisterType((*FleetStorageStaticRoutesListType)(nil), "ves.io.schema.fleet.FleetStorageStaticRoutesListType")
	golang_proto.RegisterType((*FleetStorageStaticRoutesListType)(nil), "ves.io.schema.fleet.FleetStorageStaticRoutesListType")
	proto.RegisterType((*VGPUConfiguration)(nil), "ves.io.schema.fleet.VGPUConfiguration")
	golang_proto.RegisterType((*VGPUConfiguration)(nil), "ves.io.schema.fleet.VGPUConfiguration")
	proto.RegisterType((*VMConfiguration)(nil), "ves.io.schema.fleet.VMConfiguration")
	golang_proto.RegisterType((*VMConfiguration)(nil), "ves.io.schema.fleet.VMConfiguration")
	proto.RegisterType((*BGPConfiguration)(nil), "ves.io.schema.fleet.BGPConfiguration")
	golang_proto.RegisterType((*BGPConfiguration)(nil), "ves.io.schema.fleet.BGPConfiguration")
	proto.RegisterType((*LocalControlPlaneType)(nil), "ves.io.schema.fleet.LocalControlPlaneType")
	golang_proto.RegisterType((*LocalControlPlaneType)(nil), "ves.io.schema.fleet.LocalControlPlaneType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.fleet.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.fleet.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.fleet.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.fleet.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.fleet.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.fleet.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.fleet.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.fleet.GetSpecType")
	proto.RegisterType((*FleetStatus)(nil), "ves.io.schema.fleet.FleetStatus")
	golang_proto.RegisterType((*FleetStatus)(nil), "ves.io.schema.fleet.FleetStatus")
}

func init() { proto.RegisterFile("ves.io/schema/fleet/types.proto", fileDescriptor_82c3333ba2789298) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/fleet/types.proto", fileDescriptor_82c3333ba2789298)
}

var fileDescriptor_82c3333ba2789298 = []byte{
	// 8169 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7d, 0x6d, 0x6c, 0x1b, 0x49,
	0x96, 0x98, 0x8a, 0xa4, 0x24, 0xf2, 0x51, 0x24, 0x5b, 0xa5, 0x0f, 0x53, 0xb2, 0x2d, 0xd3, 0x9c,
	0x2f, 0x8d, 0x86, 0xd6, 0x07, 0xf5, 0x69, 0xcf, 0x8c, 0x6f, 0x44, 0x49, 0xb6, 0xa5, 0x91, 0x65,
	0x6d, 0x4b, 0xf2, 0xe4, 0x66, 0x37, 0xdb, 0xd7, 0x22, 0x4b, 0x54, 0xaf, 0x9b, 0xdd, 0xbd, 0xdd,
	0x4d, 0x79, 0x34, 0x81, 0x81, 0x81, 0x7f, 0x64, 0x6f, 0xe7, 0x90, 0x64, 0x6f, 0xf7, 0x7e, 0xed,
	0x21, 0xc9, 0x25, 0x3f, 0x92, 0x60, 0x7e, 0xe4, 0x90, 0x3f, 0xc1, 0xdd, 0xd1, 0x08, 0x0c, 0x07,
	0x01, 0x16, 0x93, 0x20, 0x30, 0xf2, 0x27, 0x83, 0x41, 0x7e, 0xdc, 0x6a, 0xff, 0xec, 0xee, 0x9f,
	0x5b, 0x1c, 0x12, 0x60, 0x31, 0x08, 0x70, 0x41, 0x55, 0x57, 0x37, 0x9b, 0x54, 0x93, 0x92, 0xec,
	0xc9, 0x62, 0x6f, 0x21, 0xff, 0xa0, 0xc8, 0xae, 0xf7, 0x5e, 0xbd, 0x7a, 0xf5, 0xea, 0xd5, 0x7b,
	0xaf, 0x5e, 0xb5, 0xe1, 0xca, 0x01, 0xb1, 0xc6, 0x15, 0x7d, 0xc2, 0x2a, 0xee, 0x93, 0x8a, 0x3c,
	0xb1, 0xa7, 0x12, 0x62, 0x4f, 0xd8, 0x87, 0x06, 0xb1, 0xc6, 0x0d, 0x53, 0xb7, 0x75, 0xdc, 0xe7,
	0x00, 0x8c, 0x3b, 0x00, 0xe3, 0x0c, 0x60, 0xf8, 0x5a, 0x59, 0xb1, 0xf7, 0xab, 0xbb, 0xe3, 0x45,
	0xbd, 0x32, 0x51, 0xd6, 0xcb, 0xfa, 0x04, 0x83, 0xdd, 0xad, 0xee, 0xb1, 0x5f, 0xec, 0x07, 0xfb,
	0xe6, 0xd0, 0x18, 0xbe, 0x52, 0xd6, 0xf5, 0xb2, 0x4a, 0xea, 0x50, 0xb6, 0x52, 0x21, 0x96, 0x2d,
	0x57, 0x0c, 0x0e, 0x70, 0xb9, 0x91, 0x8b, 0xdd, 0xb2, 0xe1, 0xe7, 0x61, 0xf8, 0x42, 0x63, 0xb3,
	0x46, 0x6c, 0xde, 0x70, 0xb1, 0xb1, 0x41, 0x37, 0x6c, 0x45, 0xd7, 0xac, 0x60, 0xa2, 0xc6, 0x81,
	0x2d, 0xf9, 0x89, 0x0e, 0x35, 0x36, 0xfb, 0x9b, 0x2e, 0x35, 0x36, 0x1d, 0xc8, 0xaa, 0x52, 0x92,
	0x6d, 0xc2, 0x5b, 0x33, 0x4d, 0xad, 0x0a, 0x79, 0x28, 0x35, 0xf6, 0x7c, 0xe5, 0x38, 0x84, 0xe5,
	0xef, 0x20, 0xfb, 0x0c, 0xc1, 0xa5, 0x0d, 0x62, 0x3f, 0xd4, 0xcd, 0x07, 0x8a, 0x56, 0x5e, 0x26,
	0x07, 0x4a, 0x91, 0xac, 0x6a, 0x96, 0x2d, 0x6b, 0x45, 0xb2, 0x7d, 0x68, 0x10, 0xfc, 0x21, 0xc4,
	0x14, 0xcd, 0x26, 0xe6, 0x9e, 0x5c, 0x24, 0xe9, 0x50, 0x26, 0x3c, 0x1a, 0xcf, 0x5f, 0x1a, 0x6f,
	0x9c, 0x89, 0x7b, 0xbb, 0xdf, 0x21, 0x45, 0x5b, 0x24, 0x7b, 0x14, 0xa1, 0x30, 0xf2, 0xd9, 0xa3,
	0x5e, 0xcd, 0xa1, 0x28, 0x79, 0x98, 0x7f, 0xf5, 0x8b, 0xa7, 0xe1, 0xce, 0x1f, 0xa2, 0x90, 0x80,
	0xc4, 0x3a, 0x39, 0x7c, 0x0b, 0xc2, 0x55, 0x8b, 0xa4, 0xc3, 0x19, 0x34, 0x9a, 0xcc, 0xcf, 0x8c,
	0x07, 0xcc, 0xef, 0x78, 0x2b, 0xde, 0x76, 0x2c, 0xc6, 0x9e, 0x48, 0x09, 0x64, 0x2f, 0xc2, 0xd0,
	0x6d, 0xa2, 0x11, 0x53, 0x29, 0x1e, 0x1f, 0x40, 0xf6, 0x87, 0x61, 0xc0, 0x01, 0xe3, 0xc2, 0x10,
	0xd1, 0xe4, 0x0a, 0x49, 0xa3, 0x0c, 0x1a, 0x8d, 0x89, 0xec, 0x3b, 0xbe, 0x0d, 0x9d, 0xfa, 0x43,
	0x8d, 0x98, 0x9c, 0xa3, 0x57, 0x03, 0x39, 0x72, 0x68, 0xdd, 0xa3, 0x70, 0x6c, 0xbc, 0x71, 0x3a,
	0xb6, 0xae, 0xc7, 0x28, 0x3c, 0x8c, 0x90, 0xe8, 0xe0, 0xe3, 0x0f, 0x21, 0xe9, 0x8a, 0xa0, 0xc4,
	0xc0, 0xd3, 0x91, 0x0c, 0x1a, 0x8d, 0xe7, 0xa7, 0xce, 0x34, 0x46, 0x4a, 0xfe, 0x4e, 0x87, 0x98,
	0xe0, 0xa4, 0x9c, 0xc6, 0x1b, 0x7f, 0x82, 0x9e, 0xd5, 0xd0, 0x45, 0x18, 0x82, 0x7e, 0xe7, 0x41,
	0x66, 0x49, 0xd7, 0xf6, 0x94, 0x72, 0xd5, 0x94, 0xe9, 0xc4, 0x63, 0x34, 0xf5, 0x79, 0x0d, 0x7d,
	0x17, 0x92, 0x10, 0xd9, 0x90, 0x2b, 0x64, 0xb8, 0xcb, 0x19, 0x26, 0x60, 0xe8, 0x64, 0x2c, 0x0f,
	0xc7, 0xf8, 0x18, 0x33, 0x08, 0xde, 0x80, 0xd8, 0xaa, 0x3b, 0x17, 0xc3, 0xc3, 0x90, 0x6e, 0x64,
	0x79, 0xdc, 0x9b, 0x27, 0xc8, 0x42, 0x74, 0xc7, 0x22, 0x19, 0xca, 0xcf, 0xf0, 0x20, 0xe0, 0x26,
	0xb8, 0xaa, 0x45, 0x32, 0xa8, 0x90, 0x81, 0x94, 0xf3, 0x5b, 0x52, 0x38, 0xfb, 0x38, 0xf1, 0xb4,
	0x86, 0x22, 0xcf, 0x6b, 0xa8, 0xf3, 0xa8, 0x86, 0xd0, 0xcc, 0x5a, 0x24, 0x1a, 0x12, 0xc2, 0x6b,
	0x91, 0x68, 0xa7, 0xd0, 0x95, 0xfd, 0x01, 0x82, 0xc1, 0x5b, 0x74, 0xf0, 0x1e, 0x03, 0xeb, 0x8a,
	0x65, 0xb3, 0x89, 0x39, 0x00, 0xf0, 0x7a, 0xb6, 0xd2, 0x88, 0x69, 0x5c, 0xb6, 0x49, 0x6e, 0x4c,
	0x8f, 0x9b, 0xf4, 0x2e, 0xdf, 0x56, 0xef, 0x32, 0xee, 0xb7, 0x28, 0x72, 0xbf, 0xa5, 0x91, 0xe8,
	0xeb, 0x29, 0xab, 0x41, 0x1f, 0xe3, 0xc8, 0x91, 0xaa, 0xc7, 0xce, 0x07, 0xd0, 0xed, 0x8c, 0xcb,
	0x4a, 0x87, 0x19, 0x2f, 0x6f, 0xb4, 0xd1, 0x0a, 0xff, 0xcc, 0x15, 0xfa, 0xbd, 0xce, 0xa3, 0xbe,
	0x2e, 0x5d, 0x6a, 0xd9, 0x7f, 0x86, 0x20, 0xbb, 0x65, 0xeb, 0xa6, 0x5c, 0x26, 0x5c, 0xa5, 0x0c,
	0xa2, 0x91, 0x5d, 0x6b, 0x85, 0xb2, 0x64, 0x98, 0x8a, 0xa3, 0xe0, 0x58, 0x81, 0x64, 0x45, 0x3e,
	0x94, 0x2d, 0x5b, 0x37, 0x25, 0x43, 0xd7, 0x55, 0x57, 0x24, 0xb9, 0x40, 0x36, 0x38, 0x8d, 0xbb,
	0x1c, 0x63, 0x53, 0xd7, 0xd5, 0x26, 0x5e, 0xf2, 0x3e, 0x5e, 0x12, 0x15, 0x1f, 0x9c, 0x95, 0xfd,
	0x24, 0x04, 0x17, 0x5a, 0x10, 0xc0, 0xa3, 0x10, 0xa3, 0xbd, 0x4b, 0xf5, 0x35, 0xc3, 0x15, 0xdf,
	0xa4, 0x9a, 0xfd, 0x9e, 0x18, 0xa5, 0xad, 0x54, 0xe3, 0xf0, 0x65, 0x88, 0x68, 0x7a, 0x89, 0xda,
	0x0a, 0x0a, 0x14, 0xa3, 0x40, 0x11, 0x33, 0xb4, 0x8f, 0x44, 0xf6, 0x18, 0xaf, 0x41, 0x2f, 0x23,
	0x54, 0x52, 0x2c, 0x57, 0x83, 0x1c, 0xc9, 0xc6, 0x0a, 0x23, 0x1e, 0x93, 0x10, 0x38, 0x5b, 0x29,
	0x8a, 0xb8, 0xac, 0x58, 0x7c, 0x25, 0x58, 0x37, 0x36, 0x3f, 0xaf, 0xa1, 0x75, 0xe8, 0xe3, 0xaa,
	0x1e, 0xf7, 0xb1, 0xc8, 0xf4, 0x5f, 0x2f, 0x39, 0xfa, 0xaf, 0x97, 0x08, 0xbc, 0x06, 0x3d, 0x14,
	0x33, 0xc3, 0x51, 0x0b, 0x03, 0x01, 0x6c, 0x08, 0x9d, 0xd9, 0xff, 0xdc, 0x09, 0x57, 0x1a, 0x26,
	0x65, 0x99, 0xa8, 0xea, 0xaa, 0xa5, 0xa8, 0xba, 0x76, 0x6b, 0x61, 0x72, 0x92, 0x89, 0xe2, 0x26,
	0x44, 0xab, 0x16, 0x31, 0x7d, 0x92, 0xc8, 0xfe, 0xba, 0x86, 0x22, 0xff, 0xfa, 0x09, 0xea, 0xda,
	0x95, 0x2d, 0x32, 0x37, 0xc3, 0x58, 0x36, 0xc3, 0xa3, 0x9f, 0x20, 0xfe, 0xed, 0x07, 0x08, 0x89,
	0x1e, 0x0e, 0x7e, 0x1b, 0xa2, 0x86, 0x6c, 0x59, 0x0f, 0x75, 0xb3, 0xc4, 0x84, 0x14, 0xcf, 0x0f,
	0x35, 0xcd, 0xe5, 0x16, 0x29, 0x9a, 0x84, 0xa9, 0x5f, 0x81, 0xae, 0x1f, 0x24, 0x7a, 0x08, 0xf8,
	0x5d, 0x48, 0x5a, 0xa4, 0x58, 0x35, 0x89, 0xc4, 0x75, 0x9d, 0x5b, 0x96, 0xfe, 0x26, 0x12, 0x2b,
	0x15, 0xc3, 0x3e, 0xa4, 0xc6, 0xc3, 0x81, 0xe6, 0x26, 0x06, 0x6f, 0x43, 0xd2, 0x36, 0xab, 0x96,
	0x4d, 0x4a, 0x52, 0x51, 0x96, 0xaa, 0xa6, 0x9a, 0xee, 0x64, 0x23, 0xc8, 0x3d, 0xad, 0x21, 0xc4,
	0x47, 0x11, 0x37, 0x48, 0x25, 0x97, 0xa9, 0x0f, 0xa5, 0xcb, 0x8c, 0x8c, 0x7e, 0xf2, 0x49, 0xb4,
	0x3e, 0x96, 0x3b, 0x1d, 0x62, 0x0f, 0xa7, 0xb2, 0x24, 0xef, 0x98, 0x2a, 0x9e, 0x86, 0x94, 0x6c,
	0x28, 0x92, 0x45, 0xcc, 0x03, 0x62, 0x3a, 0x2a, 0xd2, 0xdd, 0x34, 0xfb, 0x77, 0x90, 0x98, 0x90,
	0x0d, 0x65, 0x8b, 0x81, 0x30, 0x3d, 0xb9, 0x09, 0x03, 0x3e, 0x24, 0xc5, 0x90, 0xe4, 0x52, 0xc9,
	0x24, 0x96, 0x95, 0x8e, 0x36, 0xa0, 0x7e, 0x44, 0x51, 0xb1, 0x87, 0xba, 0x6a, 0x2c, 0x3a, 0x60,
	0x78, 0xb6, 0xa1, 0x53, 0x43, 0x37, 0xed, 0x74, 0x2c, 0x83, 0x46, 0x13, 0x85, 0x04, 0xc5, 0x8c,
	0x8e, 0x75, 0xa5, 0xff, 0xee, 0xef, 0xc2, 0xa3, 0xfe, 0x6e, 0x37, 0x75, 0xd3, 0xc6, 0x73, 0xd0,
	0xab, 0x58, 0x45, 0x4b, 0x91, 0xe4, 0x62, 0x91, 0x58, 0x96, 0xf4, 0xb1, 0xae, 0x91, 0x34, 0xb0,
	0x2e, 0x81, 0x0f, 0x31, 0xfd, 0x09, 0x12, 0x53, 0x0c, 0x68, 0x91, 0xc1, 0x7c, 0xa8, 0x6b, 0x04,
	0x8f, 0x43, 0xe2, 0x40, 0x57, 0xab, 0x15, 0x22, 0x19, 0x26, 0xd9, 0x53, 0x3e, 0x4a, 0xc7, 0x1b,
	0xd8, 0x4c, 0xbf, 0x27, 0xf6, 0x38, 0xed, 0x9b, 0xac, 0x19, 0x8f, 0x41, 0x8c, 0x8a, 0x50, 0x32,
	0x64, 0x7b, 0x3f, 0xdd, 0xc3, 0x60, 0x1d, 0xc6, 0xcc, 0xae, 0xf4, 0x27, 0xa1, 0xbf, 0x08, 0x21,
	0x31, 0x4a, 0xdb, 0x37, 0x65, 0x7b, 0xbf, 0x70, 0x05, 0x7a, 0xf6, 0x6d, 0xdb, 0xb0, 0xa4, 0xe2,
	0xbe, 0xae, 0x14, 0x09, 0x4e, 0x71, 0xc3, 0x19, 0x3e, 0xaa, 0xa1, 0xf0, 0x4c, 0x6e, 0xb6, 0x70,
	0x15, 0x92, 0x5c, 0x3a, 0x7e, 0x90, 0xee, 0xe7, 0x35, 0xd4, 0x45, 0x41, 0xe6, 0x73, 0x0b, 0x6b,
	0x91, 0x68, 0x58, 0x88, 0xac, 0x45, 0xa2, 0x5d, 0x42, 0x77, 0xf6, 0x7f, 0x86, 0xe1, 0xb5, 0x06,
	0x2d, 0xbe, 0xb3, 0xb9, 0xb2, 0xa1, 0x54, 0x76, 0xab, 0x16, 0x7f, 0xba, 0xb8, 0x37, 0xe3, 0xe8,
	0xf2, 0x75, 0xe8, 0xb3, 0x9c, 0x47, 0x0d, 0xb3, 0x87, 0x9a, 0xd7, 0x6e, 0x2f, 0x87, 0xf2, 0xcd,
	0xdf, 0x32, 0x0c, 0x35, 0xa1, 0xfa, 0xe6, 0x30, 0xd4, 0x34, 0x87, 0xe2, 0x60, 0x03, 0x81, 0xb6,
	0xb3, 0x18, 0x3e, 0xc5, 0x2c, 0xfa, 0xd7, 0x60, 0xe4, 0x25, 0xd7, 0x60, 0xe7, 0x59, 0xd7, 0xe0,
	0x04, 0xc4, 0x0d, 0x62, 0xee, 0x49, 0x86, 0xae, 0x2a, 0xc5, 0xc3, 0x74, 0x17, 0xeb, 0x3f, 0xf9,
	0xeb, 0x1a, 0xea, 0xf0, 0x29, 0x10, 0x50, 0x90, 0x4d, 0x06, 0x81, 0x5f, 0x01, 0x50, 0x95, 0x8a,
	0x62, 0x4b, 0x8a, 0x6e, 0x58, 0x6c, 0x69, 0x24, 0x0a, 0x11, 0x0a, 0x2f, 0xc6, 0xd8, 0xf3, 0x55,
	0xdd, 0xb0, 0xea, 0x40, 0x95, 0x5d, 0xc3, 0x59, 0x04, 0x8d, 0x40, 0x77, 0x77, 0x0d, 0x2b, 0xfb,
	0x17, 0x21, 0x98, 0x68, 0x98, 0xd9, 0xcd, 0xaa, 0x49, 0xb6, 0xea, 0xa2, 0xa5, 0xdb, 0x88, 0x59,
	0xdc, 0x27, 0x96, 0x6d, 0xca, 0xb6, 0xce, 0x1c, 0x14, 0xfc, 0x7b, 0x00, 0x45, 0x95, 0xae, 0x56,
	0x53, 0x52, 0x4a, 0x7c, 0x6a, 0x33, 0x7c, 0x61, 0x0b, 0x28, 0x3d, 0x48, 0xbf, 0x0a, 0x66, 0x32,
	0xdf, 0xf3, 0xed, 0x6f, 0xca, 0xd7, 0x3e, 0x9e, 0xbc, 0x76, 0x5d, 0xfa, 0x87, 0x63, 0xaf, 0x8a,
	0x31, 0x8e, 0xb3, 0x5a, 0xc2, 0xef, 0xc1, 0x05, 0xa2, 0xc9, 0xbb, 0x2a, 0x91, 0xdc, 0x09, 0xb7,
	0x75, 0x43, 0x57, 0xf5, 0xf2, 0x21, 0x9b, 0xe7, 0x68, 0x21, 0xca, 0xad, 0x47, 0x87, 0x38, 0xe0,
	0x00, 0x72, 0x8e, 0xb6, 0x39, 0x18, 0xbe, 0x09, 0x83, 0x1e, 0x05, 0x53, 0x29, 0xda, 0x75, 0x02,
	0xe1, 0x26, 0x02, 0xfd, 0x2e, 0x01, 0x0a, 0xe6, 0xe1, 0x17, 0xa0, 0x4b, 0x36, 0x4d, 0xf9, 0xd0,
	0xe2, 0xd6, 0x6e, 0x2c, 0x70, 0xf3, 0xdb, 0xb4, 0xf4, 0x45, 0x0a, 0xd5, 0xe0, 0x10, 0x89, 0x1c,
	0x33, 0xfb, 0xe7, 0x08, 0x06, 0x02, 0x21, 0xf0, 0x1a, 0xc4, 0xf7, 0x54, 0xd9, 0xda, 0x97, 0x18,
	0x24, 0x93, 0x50, 0x3c, 0xff, 0x4a, 0x60, 0x17, 0xb7, 0x28, 0x1c, 0x23, 0xe1, 0xd3, 0x0c, 0xd8,
	0xf3, 0x9e, 0xd6, 0x69, 0xed, 0xaa, 0x32, 0xdf, 0x04, 0xdb, 0xd2, 0x2a, 0x50, 0xb0, 0x63, 0xb4,
	0xd8, 0xd3, 0xec, 0xdf, 0x22, 0x48, 0x36, 0x02, 0xe1, 0xf7, 0x60, 0xc8, 0x15, 0xa4, 0x26, 0x1b,
	0xd6, 0xbe, 0x6e, 0x4b, 0x25, 0xc5, 0x24, 0x45, 0x5b, 0x37, 0x1d, 0xc6, 0xa3, 0x5c, 0x67, 0xf8,
	0x8c, 0x6d, 0x71, 0xa8, 0x65, 0x17, 0x08, 0xe7, 0xa1, 0x87, 0x7c, 0x44, 0xd7, 0x99, 0x64, 0x56,
	0x55, 0xe2, 0xae, 0xd4, 0x94, 0xab, 0xbd, 0x8e, 0x4e, 0xe4, 0xc5, 0xb8, 0x03, 0x24, 0x52, 0x18,
	0xfc, 0x1d, 0xe8, 0xf1, 0x0d, 0xaa, 0xbd, 0x23, 0x54, 0x67, 0x78, 0x45, 0x2b, 0x19, 0xba, 0xa2,
	0xd9, 0xbe, 0x7d, 0x3d, 0x1a, 0xb8, 0xaf, 0xc7, 0xeb, 0x63, 0xb6, 0xb2, 0xbf, 0xee, 0x02, 0x7c,
	0x9c, 0x06, 0x1e, 0x85, 0xee, 0x4a, 0xb9, 0x62, 0x4b, 0x8a, 0xc1, 0x39, 0x4e, 0xb8, 0x1c, 0x47,
	0xcc, 0x90, 0x41, 0xb7, 0xa4, 0x2e, 0xda, 0xbe, 0x6a, 0xe0, 0x77, 0x21, 0xc1, 0x20, 0x4b, 0x9a,
	0xe5, 0x18, 0xb3, 0x30, 0x83, 0xbf, 0xd0, 0xb0, 0x3e, 0x43, 0xf5, 0x8d, 0xa9, 0x43, 0x8c, 0x53,
	0xf8, 0x65, 0xcd, 0x62, 0x66, 0xed, 0x1d, 0x88, 0x51, 0x83, 0x64, 0xeb, 0x0f, 0x88, 0xc6, 0xb5,
	0xed, 0x64, 0xd3, 0x20, 0x1b, 0xca, 0x36, 0x45, 0xc0, 0xf3, 0x90, 0xd2, 0xf6, 0x2c, 0x89, 0x70,
	0xb6, 0x29, 0xbb, 0x5d, 0x41, 0xec, 0x22, 0x31, 0xa1, 0xed, 0x59, 0xee, 0xe8, 0x56, 0x0d, 0xbc,
	0x0e, 0x03, 0x0d, 0x88, 0x1e, 0xf7, 0xdd, 0xed, 0xb9, 0x47, 0x22, 0xf6, 0x11, 0x72, 0x07, 0xf1,
	0xbd, 0x10, 0x74, 0xa9, 0x74, 0xfe, 0xa9, 0x21, 0xa1, 0x73, 0x35, 0x7d, 0xca, 0xb9, 0x1a, 0x5f,
	0x67, 0x58, 0x2b, 0x9a, 0x6d, 0x1e, 0x16, 0xfe, 0x92, 0x4d, 0x52, 0xcf, 0x8f, 0x51, 0x2c, 0xdb,
	0x6d, 0x76, 0x0a, 0x28, 0xcd, 0x8d, 0xe9, 0x8f, 0x51, 0x48, 0xe8, 0x77, 0x9b, 0xc6, 0xdc, 0xa6,
	0xa3, 0xbf, 0xfe, 0x2f, 0xe1, 0xbe, 0x4f, 0x9f, 0xa0, 0x14, 0x4e, 0xfc, 0xb2, 0x86, 0x62, 0xeb,
	0xf2, 0x2e, 0x51, 0x33, 0x0f, 0xc8, 0xa1, 0xef, 0xf9, 0x91, 0xf7, 0xfc, 0x7d, 0xe7, 0x39, 0x7c,
	0xfa, 0x04, 0x75, 0xe1, 0xc8, 0x4f, 0x6a, 0xa8, 0x83, 0xfe, 0xec, 0xfa, 0xf4, 0x09, 0x55, 0x0d,
	0xfa, 0x75, 0xe0, 0xd3, 0x27, 0xa8, 0x77, 0x38, 0xf5, 0xcb, 0x1a, 0x8a, 0x3b, 0x18, 0x07, 0xb2,
	0x5a, 0x25, 0xbe, 0x96, 0x23, 0xaf, 0xe5, 0xbe, 0xdb, 0xc2, 0xa8, 0x0d, 0x33, 0x6a, 0x22, 0x1f,
	0xfe, 0xf0, 0x75, 0x88, 0xfb, 0x86, 0x84, 0x05, 0x08, 0x3f, 0x20, 0x87, 0x3c, 0xe8, 0xa3, 0x5f,
	0x71, 0x3f, 0x74, 0x32, 0xd2, 0x8e, 0x5a, 0x89, 0xce, 0x8f, 0x1b, 0xa1, 0x05, 0x74, 0xe3, 0x5f,
	0xa2, 0xcf, 0x6b, 0xe8, 0xc7, 0x08, 0xc6, 0x01, 0xdf, 0x95, 0x35, 0xb9, 0x4c, 0x2a, 0x44, 0xb3,
	0x33, 0x54, 0xbe, 0x13, 0xab, 0x9b, 0xf9, 0xb4, 0xa7, 0x90, 0x4d, 0xfa, 0x06, 0x69, 0x88, 0x2d,
	0x6e, 0xae, 0x66, 0x98, 0x42, 0x50, 0xa7, 0xd4, 0x53, 0x27, 0x58, 0x80, 0x9e, 0x8d, 0x5b, 0x5b,
	0x19, 0x57, 0xd8, 0xf9, 0xd1, 0x63, 0xda, 0xd2, 0x42, 0x0b, 0xa0, 0x1f, 0xba, 0xd8, 0x60, 0xad,
	0x35, 0x70, 0x67, 0x56, 0x08, 0x17, 0x32, 0xbc, 0x6b, 0x17, 0x9e, 0x79, 0x05, 0x21, 0xaa, 0x92,
	0xd4, 0x2b, 0xc8, 0xe7, 0xa6, 0xa9, 0x67, 0xe1, 0x27, 0xc8, 0x00, 0xba, 0x78, 0x48, 0x16, 0x9e,
	0xcb, 0xcd, 0xaf, 0x45, 0xa2, 0x48, 0x08, 0xf1, 0xa0, 0xec, 0x4f, 0x22, 0xdc, 0xde, 0x78, 0x06,
	0x0e, 0xdf, 0x80, 0xa8, 0x25, 0x6b, 0x2c, 0x5b, 0xc1, 0x77, 0x8e, 0x2b, 0x5f, 0xd6, 0x50, 0xe7,
	0xea, 0xd6, 0xd2, 0xd6, 0xaa, 0xab, 0x92, 0x09, 0x33, 0x2e, 0x3a, 0x4f, 0xc4, 0xd0, 0xad, 0x25,
	0xb1, 0xdb, 0x92, 0x35, 0x86, 0xbb, 0x42, 0x23, 0xc2, 0x3d, 0xb9, 0xaa, 0xda, 0xd2, 0x9e, 0xe5,
	0x90, 0x70, 0x96, 0xee, 0xe5, 0x2f, 0x6b, 0x28, 0xfc, 0xd1, 0x9e, 0xe5, 0x27, 0x40, 0x7f, 0x8b,
	0x11, 0xf2, 0x91, 0x3d, 0x23, 0x26, 0x38, 0xd6, 0x2d, 0x8b, 0x91, 0x99, 0x83, 0xa4, 0x8f, 0x8c,
	0x6e, 0xd8, 0x7c, 0x41, 0x0b, 0x2e, 0xba, 0xab, 0x80, 0x62, 0x8f, 0x87, 0x78, 0xcf, 0xb0, 0xf1,
	0x2d, 0xc0, 0x2e, 0x5e, 0x45, 0xaf, 0x6a, 0x36, 0x45, 0xa5, 0xfb, 0x07, 0x8d, 0x34, 0xd2, 0xde,
	0x72, 0xa2, 0x56, 0x29, 0xe2, 0xb3, 0x45, 0x02, 0xc7, 0xb9, 0x4b, 0x51, 0xee, 0x19, 0xb6, 0x85,
	0x97, 0xe1, 0x62, 0x49, 0xb1, 0x98, 0xcd, 0x35, 0x4c, 0x42, 0x2a, 0x86, 0x2d, 0xc9, 0xb6, 0x2d,
	0x17, 0xf7, 0xa9, 0x3a, 0x58, 0xcc, 0x7b, 0x70, 0x8d, 0xee, 0x10, 0x07, 0xdc, 0x74, 0xe0, 0x16,
	0xeb, 0x60, 0xf8, 0x2e, 0xf4, 0x39, 0x6e, 0xa7, 0xaa, 0x97, 0x15, 0x4d, 0xb2, 0x95, 0x0a, 0xd1,
	0xab, 0x36, 0x33, 0x0e, 0x9d, 0x4c, 0x20, 0xa1, 0xfc, 0xe4, 0x51, 0x0d, 0x45, 0x20, 0x94, 0x9f,
	0xf4, 0x6c, 0xf1, 0x58, 0x24, 0x5d, 0x1a, 0x45, 0xa2, 0xe3, 0xb0, 0xae, 0x53, 0xc4, 0x6d, 0x07,
	0xaf, 0x6e, 0x91, 0xf9, 0xb6, 0xd8, 0x7d, 0x92, 0x45, 0x66, 0x53, 0x7a, 0x46, 0x8b, 0xbc, 0xe8,
	0x6c, 0x9c, 0xff, 0xb4, 0x93, 0x5b, 0xe4, 0x06, 0x1a, 0x7f, 0x5f, 0x2c, 0x32, 0x37, 0x85, 0x44,
	0xa5, 0x53, 0x75, 0x82, 0x29, 0x6c, 0x18, 0xe0, 0xb8, 0xb3, 0xe0, 0x7e, 0x37, 0x4c, 0x21, 0x51,
	0x5d, 0x53, 0xe8, 0x0e, 0xe9, 0x4c, 0xa6, 0xb0, 0xf4, 0x79, 0x0d, 0xfd, 0xc1, 0xd7, 0x68, 0x08,
	0x9b, 0xcd, 0x19, 0x51, 0x4f, 0x65, 0xce, 0x1c, 0x6b, 0x95, 0xfd, 0xcb, 0x10, 0x8c, 0x34, 0x38,
	0xc1, 0x1b, 0xc4, 0x96, 0x0d, 0x63, 0xdb, 0x54, 0x4a, 0x44, 0x73, 0x93, 0x48, 0x69, 0x8d, 0x3d,
	0x94, 0x76, 0xe5, 0xe2, 0x03, 0xa2, 0x95, 0x24, 0x5d, 0xb3, 0x65, 0x43, 0xd2, 0x64, 0x8b, 0xfb,
	0x64, 0x6f, 0x07, 0xaa, 0x41, 0x00, 0xd9, 0x82, 0x43, 0xe0, 0x1e, 0xc5, 0xdf, 0x90, 0x2d, 0x9e,
	0x94, 0x1b, 0xd0, 0x82, 0x1a, 0x5b, 0xf6, 0x6b, 0xc9, 0x1a, 0xd3, 0xfa, 0x17, 0xec, 0x77, 0xcb,
	0x31, 0xa9, 0xc1, 0xfd, 0x6e, 0xc9, 0x1a, 0x0d, 0x10, 0xdd, 0x0e, 0x7d, 0x01, 0x62, 0x80, 0xec,
	0xfe, 0x38, 0x05, 0xaf, 0x9f, 0xae, 0x33, 0xfc, 0x8f, 0xea, 0xb1, 0x61, 0xc9, 0x54, 0x9a, 0x62,
	0xc3, 0xf7, 0xbf, 0xac, 0xa1, 0x18, 0x1b, 0xdb, 0x35, 0x4b, 0xd6, 0xdc, 0x95, 0x3c, 0x6b, 0x4e,
	0x8b, 0xf5, 0xa7, 0x62, 0xaf, 0xf7, 0xf5, 0x1a, 0x29, 0xea, 0x9a, 0x5e, 0x39, 0x14, 0xfb, 0x9c,
	0x47, 0x9a, 0x6c, 0x5d, 0xdb, 0x53, 0xc9, 0x47, 0x65, 0x53, 0xaf, 0x1a, 0x5e, 0x74, 0xb9, 0xcc,
	0xba, 0xd9, 0x70, 0x02, 0xb4, 0xde, 0x8a, 0xa7, 0x6b, 0x92, 0xaa, 0xec, 0x51, 0x3b, 0x13, 0x09,
	0xb6, 0x33, 0xa9, 0x3a, 0xe4, 0xba, 0xb2, 0xb7, 0x6a, 0xe0, 0x4d, 0xb8, 0xd0, 0x84, 0xec, 0x99,
	0x9e, 0xce, 0x93, 0x4c, 0x4f, 0x7f, 0x03, 0x31, 0xd7, 0x06, 0x4d, 0x40, 0xbc, 0x24, 0xdb, 0xb2,
	0xcb, 0x48, 0x77, 0xb0, 0x4f, 0x17, 0xa3, 0x30, 0x0e, 0x0b, 0xcb, 0xd0, 0xeb, 0x21, 0x78, 0x9d,
	0x47, 0x4f, 0xf2, 0xe5, 0x92, 0x9c, 0x80, 0xdb, 0xed, 0x08, 0x84, 0xad, 0x83, 0x0a, 0xcb, 0x6b,
	0xc4, 0x0a, 0x3d, 0xbe, 0xcd, 0x2e, 0x24, 0xd2, 0x06, 0x3c, 0xea, 0x0b, 0x83, 0x21, 0x00, 0x28,
	0x38, 0xe0, 0x8d, 0x9f, 0x3d, 0xe0, 0xed, 0xd6, 0x74, 0xa9, 0xb8, 0x2f, 0x1b, 0xe9, 0x44, 0x9b,
	0x6c, 0x53, 0x48, 0xec, 0xd2, 0xf4, 0xa5, 0x7d, 0xd9, 0xc0, 0x3b, 0x8c, 0x2f, 0x07, 0x23, 0xc9,
	0x30, 0x16, 0xda, 0x64, 0x4d, 0x03, 0x55, 0x90, 0xd2, 0x61, 0x3a, 0x1f, 0x12, 0xbb, 0xab, 0x16,
	0x61, 0x64, 0xaf, 0x41, 0x5c, 0x61, 0x1a, 0xe3, 0x88, 0xb3, 0x37, 0x60, 0xc4, 0xe0, 0x00, 0x30,
	0xe9, 0xdd, 0x80, 0xa4, 0xab, 0xc0, 0x3c, 0x67, 0x83, 0x19, 0x46, 0x9f, 0x1b, 0x6d, 0xd6, 0x03,
	0x9e, 0x4d, 0x31, 0xc1, 0x41, 0x79, 0xfa, 0x66, 0x05, 0x06, 0x9c, 0x68, 0x5c, 0x2e, 0x97, 0x4d,
	0x52, 0x96, 0x6d, 0x22, 0x55, 0x2d, 0xb9, 0x4c, 0xd2, 0x7d, 0x2c, 0x30, 0xef, 0xf5, 0x93, 0x88,
	0x8c, 0x85, 0xd2, 0x25, 0xb1, 0x8f, 0xc1, 0x2f, 0xba, 0xe0, 0x3b, 0x14, 0x1a, 0xcf, 0x40, 0xaf,
	0x43, 0x86, 0xe7, 0x8e, 0x2c, 0xe5, 0x63, 0x92, 0xee, 0x67, 0x9b, 0x7e, 0x3d, 0xe6, 0x4d, 0x31,
	0x90, 0xfb, 0x0c, 0x62, 0x4b, 0xf9, 0x98, 0xe0, 0x6f, 0x42, 0x8a, 0xc3, 0x73, 0x6f, 0xc4, 0x4a,
	0x0f, 0x30, 0x29, 0x8e, 0x06, 0x27, 0x7d, 0xa9, 0xc8, 0x1c, 0xf4, 0x65, 0x0e, 0xef, 0xa3, 0x9e,
	0x3c, 0x68, 0x68, 0xc1, 0x7f, 0x5a, 0xdf, 0x10, 0x07, 0xd9, 0x86, 0x78, 0xfb, 0x25, 0x2c, 0xd2,
	0xef, 0xda, 0x26, 0x89, 0x2f, 0x41, 0x97, 0x49, 0xca, 0x8a, 0xae, 0xa5, 0x2f, 0x30, 0x5d, 0x71,
	0x1c, 0x3b, 0xfe, 0x0c, 0xff, 0x01, 0x74, 0x73, 0x35, 0x49, 0xa7, 0x99, 0xec, 0x26, 0xdb, 0x4c,
	0x88, 0x62, 0xda, 0x55, 0x59, 0xe5, 0x72, 0x0c, 0xc8, 0xc4, 0x37, 0x9c, 0x0a, 0x70, 0xb2, 0xf8,
	0x5d, 0xc0, 0x45, 0x55, 0xa1, 0x66, 0xab, 0x48, 0x4c, 0x5b, 0xd9, 0x53, 0x8a, 0xb2, 0x4d, 0xd2,
	0x43, 0x5e, 0x8a, 0x29, 0xec, 0x19, 0x8e, 0xf7, 0xc4, 0x5e, 0x07, 0x72, 0xa9, 0x0e, 0x88, 0xef,
	0x7a, 0xe8, 0x86, 0xa9, 0x1c, 0x50, 0xad, 0xa5, 0x7b, 0xfc, 0xf0, 0xe9, 0x16, 0xbc, 0xe0, 0xa0,
	0x6e, 0x3a, 0x98, 0xef, 0x93, 0x43, 0xbc, 0x0c, 0x83, 0xbe, 0x74, 0xb1, 0x9f, 0xa3, 0x8b, 0x81,
	0x1c, 0xf5, 0x7b, 0x69, 0x61, 0x1f, 0x53, 0x2f, 0xe3, 0x78, 0xe8, 0xcf, 0x6a, 0xe8, 0x01, 0xdc,
	0x82, 0x61, 0x2e, 0xc6, 0x0c, 0xd7, 0xc1, 0xcc, 0xa6, 0x6c, 0xca, 0x15, 0x62, 0x13, 0xd3, 0xc2,
	0xa3, 0x53, 0xb9, 0xe9, 0xdc, 0x5c, 0xee, 0x7a, 0x6e, 0x6a, 0x32, 0x37, 0x35, 0x95, 0x9b, 0xca,
	0xe7, 0xf2, 0xb3, 0xb9, 0xfc, 0x5c, 0x2e, 0x3f, 0x9f, 0x9b, 0x9a, 0xcf, 0x4d, 0x2d, 0xe4, 0xa6,
	0xae, 0xe7, 0xf2, 0x93, 0xb9, 0xfc, 0x14, 0x5c, 0x85, 0x01, 0x3e, 0x2b, 0x19, 0x97, 0x1e, 0x3b,
	0xf9, 0xc0, 0xd1, 0x7c, 0x3e, 0x97, 0x9f, 0xce, 0xe5, 0x67, 0xe8, 0x46, 0xda, 0xb8, 0x75, 0x1c,
	0x4f, 0xc6, 0x5e, 0x84, 0xa8, 0x6b, 0xda, 0x8f, 0xa5, 0x61, 0x0b, 0x19, 0x88, 0x53, 0xab, 0xe7,
	0xee, 0xc2, 0xd4, 0x4e, 0x24, 0x9e, 0xd7, 0x50, 0xcf, 0x51, 0x0d, 0x75, 0x4e, 0x4d, 0xe7, 0xa6,
	0x66, 0xfc, 0x89, 0xda, 0xb5, 0x48, 0xb4, 0x47, 0x48, 0x64, 0xff, 0x26, 0x04, 0xaf, 0x9c, 0xc2,
	0x12, 0xe2, 0xeb, 0x90, 0x60, 0xb4, 0x9b, 0x4e, 0x1f, 0xfa, 0xfd, 0xb6, 0xc8, 0x33, 0x84, 0x3d,
	0x14, 0x74, 0xc7, 0x35, 0xff, 0xb7, 0xa0, 0x9f, 0xa1, 0xda, 0xb2, 0x59, 0x26, 0x76, 0x9d, 0x42,
	0xa8, 0x0d, 0x05, 0x4c, 0x31, 0xb6, 0x19, 0x82, 0x47, 0xe7, 0x9b, 0x30, 0xc0, 0xe8, 0x28, 0x9a,
	0x62, 0x2b, 0xb2, 0xad, 0x9b, 0x92, 0xc5, 0xb4, 0x88, 0x3b, 0x37, 0x6d, 0x54, 0xac, 0x87, 0xf6,
	0xf1, 0xdc, 0x35, 0x4a, 0x7d, 0x94, 0xca, 0xaa, 0x4b, 0xc4, 0x01, 0xc3, 0xfb, 0x70, 0xc9, 0xcf,
	0xe4, 0xb1, 0x3e, 0x22, 0x67, 0xeb, 0x63, 0xa8, 0xce, 0x7f, 0x53, 0x4f, 0xd9, 0x7f, 0x71, 0xb2,
	0x17, 0xc4, 0x5d, 0xbd, 0x53, 0x7b, 0x41, 0x9a, 0x6c, 0x05, 0x78, 0x41, 0x9a, 0x6c, 0xb9, 0x5e,
	0x10, 0x75, 0x79, 0xce, 0xea, 0x05, 0xcd, 0x41, 0x8f, 0xeb, 0xd6, 0xf9, 0xa6, 0x2b, 0x60, 0xff,
	0xca, 0x8b, 0x71, 0x0e, 0x78, 0xee, 0x3d, 0xfd, 0xb6, 0x79, 0x4f, 0x73, 0x80, 0xe5, 0xaa, 0xad,
	0x4b, 0x3c, 0xed, 0xca, 0x4f, 0x0d, 0x7a, 0x9a, 0x12, 0xdf, 0x02, 0x85, 0x59, 0x61, 0x20, 0xfc,
	0xd4, 0x60, 0x07, 0x7a, 0xfd, 0x78, 0x45, 0xa5, 0x64, 0x5a, 0xdc, 0xff, 0x7a, 0x33, 0xf0, 0x3c,
	0xdc, 0x71, 0x5d, 0xb6, 0x6c, 0x53, 0xd1, 0xca, 0xee, 0xf9, 0xb5, 0x98, 0xaa, 0xd3, 0x5d, 0xa2,
	0x14, 0xf0, 0xc4, 0x31, 0xaf, 0x28, 0xc9, 0xc6, 0x5e, 0x67, 0xa5, 0xc9, 0x15, 0x7a, 0xa7, 0x95,
	0x2b, 0x94, 0x6a, 0xc2, 0x3b, 0xbd, 0x07, 0x24, 0x34, 0x61, 0x1e, 0xf3, 0x80, 0x66, 0xa0, 0x57,
	0xdb, 0xb3, 0xea, 0x89, 0x1b, 0x45, 0xd7, 0x2c, 0xee, 0xef, 0xf9, 0xb0, 0xb4, 0x3d, 0xcb, 0xcd,
	0xd3, 0x50, 0x80, 0x20, 0xbf, 0x09, 0xff, 0xff, 0xf0, 0x9b, 0xfa, 0x5e, 0xdc, 0x6f, 0xe2, 0x66,
	0xe5, 0x77, 0xd8, 0x6f, 0xea, 0x6f, 0xef, 0x37, 0x0d, 0xfc, 0x26, 0xfd, 0xa6, 0xc1, 0x97, 0xf3,
	0x9b, 0x2e, 0x7c, 0xfd, 0x7e, 0x53, 0xfa, 0x37, 0xe3, 0x37, 0x99, 0xcf, 0x6a, 0x48, 0x83, 0xd5,
	0xb6, 0x7e, 0xd3, 0x5b, 0xc7, 0xfd, 0x26, 0xee, 0x05, 0xe5, 0x98, 0xa7, 0x92, 0x9b, 0x9a, 0xcd,
	0x4d, 0xcd, 0x39, 0x3e, 0x54, 0x1b, 0xd7, 0xc9, 0xf5, 0xae, 0x5e, 0xd6, 0x75, 0x6a, 0x38, 0xc1,
	0xfe, 0x51, 0x17, 0xf4, 0x05, 0x2c, 0x4f, 0xbc, 0x02, 0x09, 0xcb, 0x90, 0x8b, 0x44, 0x32, 0x09,
	0x3b, 0x32, 0x76, 0x8f, 0x33, 0xbf, 0xac, 0xa1, 0x88, 0xa6, 0x6b, 0xc4, 0xdd, 0x1c, 0x52, 0x66,
	0x42, 0x64, 0x0f, 0xc4, 0x4e, 0x7b, 0x5f, 0x29, 0x3e, 0x10, 0x7b, 0x18, 0x9a, 0xe8, 0x60, 0xe1,
	0x6b, 0x90, 0xf2, 0xce, 0xcf, 0xb8, 0x3d, 0x0e, 0xf9, 0xd4, 0x36, 0xe9, 0x36, 0x72, 0x4b, 0x3c,
	0x01, 0x82, 0x07, 0xee, 0x76, 0x1c, 0xf6, 0xc1, 0x7b, 0xc4, 0x5c, 0xfa, 0x63, 0x90, 0xb4, 0x0c,
	0x55, 0xb1, 0x25, 0x5d, 0x93, 0x8a, 0xaa, 0xae, 0x39, 0x87, 0xd4, 0x6e, 0x9a, 0xb8, 0x87, 0xb5,
	0xdd, 0xd3, 0x96, 0x68, 0x0b, 0x7e, 0x15, 0x80, 0x68, 0x45, 0xf3, 0x90, 0xd9, 0xb0, 0x86, 0x74,
	0xb2, 0xef, 0x39, 0x5e, 0x00, 0xa1, 0xaa, 0x29, 0x1f, 0x49, 0x06, 0x31, 0x2b, 0x8a, 0x65, 0x31,
	0x7b, 0xe8, 0x24, 0x8f, 0xe9, 0x6a, 0xef, 0x84, 0xf0, 0xfc, 0xfc, 0xbc, 0xc3, 0x0b, 0x05, 0xdb,
	0xac, 0x43, 0xe1, 0x37, 0xa0, 0xc7, 0x7f, 0x56, 0xc8, 0x76, 0x5f, 0xb7, 0x87, 0xb8, 0x55, 0x3f,
	0x1f, 0xc4, 0x6f, 0x42, 0xa2, 0x71, 0x8b, 0x8a, 0xfa, 0x86, 0xc8, 0x0f, 0x0d, 0xb9, 0x40, 0x66,
	0x79, 0x15, 0x8a, 0x62, 0x1f, 0x4a, 0x96, 0x7d, 0xa8, 0x12, 0xbe, 0xc9, 0x26, 0x8f, 0x6a, 0xa8,
	0x0b, 0x22, 0x94, 0x05, 0xbe, 0x93, 0x70, 0xa8, 0x2d, 0x0a, 0x84, 0xdf, 0x82, 0xa4, 0xad, 0x10,
	0xba, 0x3d, 0xb9, 0x5d, 0x80, 0xaf, 0x8b, 0x04, 0x6f, 0xe3, 0x7d, 0x5c, 0x83, 0x2e, 0x4d, 0x97,
	0xbe, 0xab, 0x5b, 0x6c, 0xab, 0x6c, 0x5d, 0xe1, 0xd2, 0xa9, 0xe9, 0xdf, 0xd0, 0x2d, 0x7c, 0x0d,
	0xe0, 0xbb, 0xba, 0xe5, 0xd2, 0x4d, 0x1c, 0xdb, 0xce, 0xa9, 0x77, 0x12, 0xfb, 0xae, 0x6e, 0x71,
	0xea, 0x37, 0xa1, 0x4f, 0x2e, 0xc9, 0x86, 0xad, 0x1c, 0x10, 0xc9, 0x87, 0x97, 0x0c, 0xc4, 0xeb,
	0x75, 0x41, 0xbf, 0xe1, 0xe2, 0xdf, 0xb8, 0xf9, 0xac, 0x86, 0x6e, 0xc0, 0x02, 0x5c, 0x76, 0x17,
	0xd6, 0xbd, 0x8d, 0xed, 0xc5, 0xcd, 0x8c, 0xa3, 0xae, 0x19, 0x4f, 0x5f, 0x2f, 0x4c, 0xe5, 0xf2,
	0xb9, 0xe9, 0xdc, 0x4c, 0x6e, 0x36, 0x37, 0x97, 0x9b, 0xcf, 0x2d, 0xb8, 0xab, 0xad, 0x70, 0x0d,
	0x7a, 0xeb, 0xdd, 0xba, 0xd1, 0x42, 0xfa, 0x69, 0x0d, 0xf5, 0xfc, 0xc4, 0xf1, 0x61, 0xe3, 0x47,
	0x35, 0x14, 0x9d, 0xca, 0xe7, 0xdc, 0xa0, 0x21, 0x2e, 0xf4, 0x64, 0xff, 0xbc, 0x13, 0x2e, 0xb6,
	0xb1, 0x91, 0xf8, 0x07, 0xf5, 0x2d, 0xca, 0x29, 0x12, 0x7b, 0xe7, 0xac, 0x66, 0xf6, 0x77, 0x6e,
	0x5f, 0xc2, 0x10, 0x61, 0x15, 0x3e, 0x8e, 0x85, 0x64, 0xdf, 0x83, 0xdc, 0x84, 0xf0, 0xd7, 0xe5,
	0x26, 0xbc, 0x8c, 0xd1, 0x7e, 0x8e, 0x3e, 0xaf, 0xa1, 0xff, 0x8a, 0x20, 0x09, 0x91, 0x0f, 0x75,
	0x8d, 0xd5, 0xae, 0x51, 0x7e, 0x61, 0x1a, 0x04, 0xc7, 0xb0, 0xb0, 0x72, 0x85, 0xcc, 0x5d, 0xbd,
	0x44, 0x86, 0xaf, 0xc0, 0xe5, 0xa6, 0x31, 0x8c, 0x37, 0x18, 0x46, 0x98, 0x81, 0x94, 0x7b, 0xf8,
	0x9f, 0x71, 0x74, 0x76, 0xf8, 0x2a, 0x5c, 0x39, 0x86, 0xd3, 0x68, 0x05, 0x61, 0x01, 0xb0, 0x87,
	0x25, 0x12, 0x93, 0x91, 0x2a, 0x0d, 0x67, 0x21, 0xd3, 0x12, 0xd1, 0xed, 0x2f, 0x28, 0xa5, 0xdf,
	0x99, 0xfd, 0x4f, 0xc0, 0xeb, 0x3c, 0x1b, 0xdc, 0x22, 0xa6, 0xac, 0x93, 0x75, 0x3f, 0x94, 0xd7,
	0xc8, 0xa2, 0xe6, 0x8a, 0x2a, 0xd7, 0x11, 0x75, 0xb0, 0xf0, 0xb7, 0x58, 0x55, 0xad, 0x6c, 0x18,
	0x92, 0xed, 0xa4, 0xfa, 0x99, 0x05, 0x6c, 0x75, 0xa2, 0xd3, 0xfe, 0x84, 0x80, 0xd7, 0xd5, 0xd6,
	0x1f, 0xe2, 0xc7, 0x08, 0x86, 0x8c, 0xaa, 0xe9, 0x54, 0x33, 0x29, 0x45, 0x22, 0xe9, 0xbe, 0x42,
	0x1a, 0x66, 0x35, 0xe3, 0xf9, 0xe5, 0x93, 0x7b, 0x3a, 0xb9, 0x20, 0xe7, 0x4e, 0x87, 0x78, 0x81,
	0x76, 0x14, 0xd0, 0x8c, 0xf7, 0x01, 0xeb, 0x4e, 0x05, 0xa6, 0x44, 0xbc, 0x3a, 0x50, 0x66, 0x88,
	0xe3, 0xf9, 0xf9, 0x93, 0x3b, 0x0f, 0x2c, 0x21, 0xa5, 0x06, 0x4c, 0x6f, 0x6e, 0xc0, 0xef, 0x42,
	0xb2, 0x58, 0xb5, 0x6c, 0xbd, 0xe2, 0x16, 0xf5, 0x30, 0x13, 0xde, 0xa6, 0x90, 0xd0, 0x81, 0xe6,
	0xdd, 0xe1, 0x3f, 0x0d, 0xc3, 0x25, 0xb9, 0x74, 0x20, 0x6b, 0x45, 0x52, 0x92, 0xbc, 0x2f, 0x86,
	0xe7, 0x5d, 0xf0, 0xc3, 0xb6, 0xf7, 0x5b, 0x1c, 0xb6, 0x05, 0x69, 0xc4, 0xf8, 0x22, 0x27, 0xe3,
	0xfe, 0xad, 0xfb, 0x2a, 0x8e, 0x3d, 0xfa, 0xa3, 0x10, 0x5d, 0x75, 0xad, 0x6d, 0xd2, 0x7b, 0x81,
	0x36, 0x69, 0xe2, 0xd3, 0x27, 0xe8, 0x2d, 0xfc, 0xe6, 0x2f, 0x6b, 0xc8, 0xad, 0x89, 0xcb, 0x14,
	0x55, 0xd9, 0xb2, 0x32, 0x96, 0x41, 0x8a, 0xd4, 0xd5, 0xca, 0x78, 0x5c, 0x67, 0x68, 0xb0, 0x47,
	0x71, 0xd2, 0x9f, 0x3e, 0x41, 0xfd, 0x18, 0x1f, 0xd5, 0x50, 0xd2, 0x63, 0x82, 0x1d, 0x78, 0xb5,
	0x37, 0x5a, 0x37, 0x3f, 0x7d, 0x82, 0x6e, 0x0c, 0x2f, 0xfc, 0xb2, 0x86, 0x66, 0x4e, 0xec, 0x8a,
	0x2d, 0xfb, 0xcc, 0x9e, 0x6e, 0x66, 0xca, 0xca, 0x01, 0xd1, 0x5c, 0x4b, 0x39, 0xf4, 0xe9, 0x13,
	0x34, 0x30, 0xdc, 0x77, 0x54, 0x43, 0xa9, 0x7a, 0xcf, 0x81, 0x16, 0x6e, 0x58, 0x6e, 0x29, 0xae,
	0xe1, 0xbb, 0x70, 0xe5, 0x04, 0x61, 0x9e, 0xc9, 0x30, 0x3d, 0x0d, 0x3d, 0xab, 0xa1, 0xb7, 0x21,
	0x03, 0x43, 0xee, 0xb0, 0x78, 0xe9, 0xb9, 0xcf, 0x9b, 0x0c, 0x4f, 0xe5, 0xf2, 0x70, 0x01, 0x30,
	0x2f, 0xc4, 0xf7, 0x37, 0xa1, 0xd9, 0xcf, 0x6b, 0xe8, 0xff, 0x22, 0x48, 0xf3, 0x42, 0x5d, 0xa1,
	0x79, 0xe5, 0xc3, 0xbf, 0x41, 0x10, 0xa1, 0x2a, 0x30, 0xf6, 0xcf, 0x11, 0xfc, 0x31, 0x82, 0x4c,
	0xf3, 0x42, 0xcf, 0x27, 0x37, 0x88, 0xbd, 0x68, 0x18, 0x19, 0xbe, 0x58, 0xe1, 0xcd, 0x36, 0x6b,
	0x35, 0xdf, 0x43, 0xd7, 0xa0, 0xeb, 0xa6, 0xc2, 0x68, 0xd0, 0x92, 0xca, 0x63, 0xba, 0x54, 0x56,
	0x0a, 0x5b, 0x99, 0xfa, 0x92, 0x80, 0x74, 0xf3, 0x92, 0xc8, 0x77, 0x2d, 0xb1, 0xdf, 0xb8, 0x7b,
	0x47, 0x7b, 0xa0, 0xe9, 0x0f, 0x35, 0x98, 0x87, 0x3e, 0x57, 0xa0, 0xbe, 0x11, 0xae, 0x65, 0xda,
	0x2f, 0x06, 0x21, 0x52, 0x78, 0x15, 0x12, 0xbc, 0x3c, 0x9e, 0xef, 0xf5, 0x7d, 0x4f, 0x6b, 0x28,
	0xfa, 0xbc, 0x86, 0x42, 0x47, 0x35, 0xd4, 0xbd, 0xc0, 0xbc, 0x83, 0xeb, 0x5e, 0x89, 0xbc, 0xe3,
	0x08, 0x47, 0x84, 0xce, 0xec, 0x1f, 0x22, 0x18, 0x3e, 0xbe, 0x5c, 0xbc, 0xea, 0xf4, 0xef, 0x40,
	0xaa, 0x51, 0x94, 0xee, 0xce, 0xff, 0xd6, 0x19, 0x16, 0x9e, 0x2f, 0xb6, 0xf2, 0x97, 0x42, 0x24,
	0x1b, 0xac, 0xaf, 0x95, 0xfd, 0xef, 0xf5, 0x63, 0xd7, 0x25, 0xaa, 0xd5, 0x01, 0xa5, 0xd1, 0xd3,
	0x90, 0x92, 0x3f, 0xf6, 0x26, 0xc5, 0x97, 0xb2, 0x8a, 0xf9, 0x93, 0x44, 0x09, 0xf9, 0x63, 0x6e,
	0xfb, 0xbc, 0x42, 0xe0, 0x3a, 0x92, 0xaf, 0x88, 0x34, 0xdc, 0x5c, 0x08, 0xdc, 0x21, 0x62, 0x0f,
	0xb5, 0x5e, 0x42, 0x1a, 0x58, 0xd1, 0x1b, 0x39, 0xb9, 0xa2, 0xb7, 0xa1, 0x42, 0xb7, 0xb3, 0x6d,
	0x85, 0x2e, 0xce, 0x01, 0x36, 0x75, 0xdd, 0x96, 0x78, 0x90, 0xe8, 0x14, 0xd7, 0xb1, 0xed, 0x27,
	0x2a, 0x0a, 0xb4, 0x65, 0x89, 0x35, 0xac, 0xb0, 0xe7, 0x81, 0xf5, 0xbc, 0x01, 0x67, 0xb1, 0xff,
	0x0a, 0xc1, 0xab, 0x7e, 0x81, 0xb6, 0xac, 0xd2, 0x6d, 0x2a, 0x38, 0x45, 0x67, 0x2c, 0x38, 0x0d,
	0x9d, 0xa6, 0xe0, 0x34, 0x1c, 0x5c, 0x70, 0xfa, 0x18, 0xc1, 0x55, 0x3f, 0x8f, 0xc1, 0x97, 0x14,
	0x66, 0x21, 0xca, 0xae, 0x13, 0x15, 0x75, 0x95, 0x73, 0x37, 0xc4, 0x22, 0xb2, 0x83, 0xca, 0x9e,
	0xcb, 0x65, 0xd4, 0xec, 0x12, 0xd9, 0x03, 0xd1, 0x03, 0xc5, 0xaf, 0x43, 0xdc, 0x24, 0x86, 0x4a,
	0xa3, 0x5d, 0x1a, 0xfb, 0x84, 0x58, 0x3c, 0xc3, 0x23, 0x13, 0x5f, 0x43, 0xf6, 0x6f, 0x10, 0x5c,
	0xf6, 0x33, 0x71, 0xfc, 0xbc, 0xff, 0x5b, 0x10, 0xb5, 0x88, 0xca, 0x4a, 0x1c, 0xf9, 0x02, 0x78,
	0xaf, 0xdd, 0x6e, 0x19, 0x4c, 0x65, 0x7c, 0x8b, 0x93, 0x60, 0x16, 0x52, 0xf4, 0x28, 0xe2, 0x69,
	0x48, 0x78, 0x29, 0x33, 0x76, 0x05, 0x23, 0xe4, 0xcd, 0x00, 0xf2, 0x66, 0x20, 0x22, 0xf6, 0x58,
	0x75, 0x67, 0xda, 0x1a, 0x7e, 0x1b, 0x12, 0x0d, 0xf4, 0xce, 0x62, 0x71, 0xb3, 0xff, 0x0b, 0xc1,
	0x1b, 0x7e, 0x5e, 0x37, 0x83, 0xfd, 0x05, 0x36, 0xf6, 0xb7, 0xa1, 0x9b, 0xe7, 0x7e, 0xb9, 0xec,
	0xaf, 0x7e, 0x59, 0x43, 0x9d, 0xbb, 0xaa, 0x5e, 0x7c, 0xe0, 0x0f, 0x87, 0x9d, 0x27, 0x62, 0x64,
	0x4f, 0x51, 0x89, 0xe8, 0x62, 0xe0, 0x77, 0x00, 0xa8, 0x8e, 0x48, 0x6c, 0xc6, 0xb9, 0xa6, 0x5c,
	0xfe, 0xb2, 0x86, 0xd0, 0x24, 0xc5, 0xeb, 0x1b, 0xeb, 0x2d, 0xa4, 0x26, 0x73, 0x53, 0x93, 0x93,
	0xd7, 0xa6, 0x26, 0xf9, 0x3f, 0x31, 0x46, 0x11, 0xd6, 0x29, 0x3c, 0x9e, 0x83, 0xd4, 0xae, 0xac,
	0x95, 0x1e, 0x2a, 0x25, 0x7b, 0x9f, 0x93, 0x08, 0x1f, 0x4b, 0xee, 0xa6, 0x7b, 0xc4, 0xa4, 0x07,
	0xc5, 0xf0, 0xb2, 0x1b, 0x30, 0xe8, 0x1f, 0x9d, 0x63, 0x65, 0xd9, 0x60, 0x66, 0x20, 0x72, 0x28,
	0x57, 0x5c, 0x2d, 0xca, 0xf0, 0xa2, 0x6e, 0xf6, 0xcc, 0x93, 0x74, 0xc6, 0x57, 0xd2, 0xcd, 0x5a,
	0xb2, 0xff, 0x31, 0x09, 0x03, 0x7e, 0xdb, 0xc6, 0xa8, 0xba, 0xd5, 0x63, 0x81, 0x5e, 0xa6, 0xbf,
	0xe0, 0x95, 0x5d, 0x60, 0x69, 0xf2, 0x35, 0x27, 0x21, 0x5e, 0x22, 0x56, 0xd1, 0x54, 0x0c, 0x4f,
	0x35, 0x9b, 0x97, 0x5c, 0x48, 0xf4, 0x83, 0xe0, 0x3c, 0x0c, 0xb8, 0xf5, 0x66, 0x6e, 0x8f, 0x6c,
	0xf3, 0x77, 0x4a, 0x9c, 0xc5, 0x3e, 0xde, 0xe8, 0xe7, 0x10, 0x7f, 0xf3, 0x98, 0x47, 0xeb, 0x38,
	0x61, 0xf9, 0xb3, 0x2b, 0xef, 0x71, 0x87, 0xf6, 0xe3, 0x76, 0xfe, 0x2c, 0xb0, 0x7e, 0xde, 0x39,
	0xb1, 0x9f, 0x36, 0x8a, 0xd7, 0xce, 0x8f, 0x2d, 0x07, 0xfa, 0xb1, 0x4e, 0xea, 0x7c, 0xee, 0xc4,
	0x4e, 0xcf, 0xe0, 0xc6, 0x6e, 0x1f, 0x73, 0x63, 0x05, 0xd6, 0xc9, 0x5b, 0x27, 0x76, 0x52, 0x57,
	0xba, 0xe3, 0xde, 0xed, 0x32, 0x24, 0x4d, 0x52, 0x54, 0x65, 0xa5, 0xe2, 0x4f, 0xd7, 0xc7, 0x0a,
	0x97, 0x8f, 0x6a, 0x48, 0x80, 0xae, 0x65, 0xa2, 0x12, 0x9b, 0x40, 0x97, 0x48, 0x6c, 0x59, 0xd1,
	0x5c, 0x35, 0x17, 0xc4, 0x04, 0x47, 0xe2, 0x56, 0xf8, 0x06, 0x0c, 0xca, 0xaa, 0xaa, 0x3f, 0x74,
	0x53, 0xdf, 0xe4, 0x23, 0x43, 0xd6, 0x2c, 0xaa, 0x4e, 0x09, 0x5f, 0x0e, 0xa6, 0x9f, 0xc1, 0x38,
	0xf1, 0xe5, 0x8a, 0x0b, 0x81, 0x7f, 0x14, 0x86, 0x8b, 0x9e, 0x27, 0xe1, 0x19, 0x9f, 0xba, 0x7b,
	0xed, 0x14, 0xfc, 0xad, 0x9e, 0xb8, 0xcb, 0x7b, 0x2b, 0xc1, 0xf3, 0xae, 0xdd, 0x88, 0xbf, 0xc9,
	0xb9, 0xfe, 0x5e, 0xe8, 0xdc, 0xb1, 0x76, 0x1c, 0xeb, 0x21, 0xb9, 0x95, 0xa4, 0xf0, 0x02, 0xe0,
	0x86, 0xb5, 0xed, 0x3f, 0x98, 0x72, 0x7d, 0x8d, 0x3f, 0x0b, 0x21, 0x51, 0xb0, 0xfc, 0x4b, 0x95,
	0xfa, 0xbc, 0xeb, 0x30, 0xd2, 0x7e, 0x02, 0xce, 0xe4, 0x90, 0xff, 0x51, 0xe4, 0x59, 0x0d, 0xdd,
	0x82, 0xb7, 0x20, 0xed, 0x8a, 0x83, 0xf5, 0xe4, 0x77, 0xba, 0x53, 0x0b, 0x39, 0x37, 0xf7, 0xc4,
	0xb2, 0x48, 0xad, 0x7c, 0xf3, 0xf9, 0xcf, 0x6b, 0xe8, 0x49, 0x18, 0x2e, 0x71, 0xdf, 0xbc, 0x3f,
	0x68, 0x84, 0x30, 0x4c, 0x75, 0x9e, 0x2e, 0xf2, 0x00, 0xdf, 0xfd, 0x12, 0xc4, 0x97, 0xeb, 0x66,
	0x70, 0x38, 0xd1, 0x60, 0x38, 0x21, 0x0b, 0xdd, 0x3c, 0x35, 0x32, 0x7c, 0xa1, 0x85, 0x81, 0x84,
	0x7f, 0x8b, 0xa0, 0x93, 0xf1, 0xff, 0x5b, 0xef, 0xfe, 0xbf, 0x0a, 0x49, 0xd1, 0x59, 0xe2, 0x3c,
	0xa7, 0x22, 0x20, 0x2a, 0x91, 0x46, 0x5b, 0x01, 0x33, 0x30, 0xb8, 0x48, 0xd7, 0xb4, 0x9b, 0x0d,
	0xf4, 0x56, 0xb5, 0x80, 0x86, 0xd3, 0xad, 0x6c, 0x02, 0x2c, 0x04, 0x86, 0x16, 0x02, 0x5a, 0xbb,
	0xd2, 0xd6, 0x12, 0x08, 0x91, 0xc2, 0x1b, 0xcd, 0xb1, 0xc5, 0xe0, 0xd3, 0x1a, 0x8a, 0x3f, 0xaf,
	0xa1, 0xc8, 0x51, 0x0d, 0xc1, 0xd4, 0x14, 0x4f, 0x3a, 0xce, 0x39, 0x21, 0x85, 0x53, 0xec, 0xcd,
	0xf3, 0xec, 0xff, 0x18, 0xc1, 0xd0, 0x31, 0x73, 0xe1, 0x45, 0x17, 0x4a, 0x3d, 0xba, 0x60, 0x33,
	0xe5, 0x45, 0x17, 0x63, 0xa7, 0xb7, 0x3b, 0x27, 0x04, 0x17, 0x4b, 0x0e, 0xdd, 0xec, 0x2c, 0xf4,
	0x14, 0x74, 0xad, 0xb4, 0x2e, 0x17, 0x9d, 0x5a, 0x87, 0xd7, 0x20, 0x62, 0xca, 0xb6, 0xb3, 0x5b,
	0x27, 0x0a, 0xbd, 0x5f, 0xd6, 0x50, 0x68, 0x7a, 0xd2, 0x2d, 0x8a, 0x1e, 0x19, 0x45, 0x22, 0x6b,
	0xce, 0x3e, 0xee, 0xe2, 0xb7, 0x76, 0x29, 0xb2, 0x2f, 0xb9, 0xf4, 0xae, 0xff, 0x76, 0x77, 0xe1,
	0xcd, 0xa3, 0x1a, 0xba, 0x04, 0x9d, 0xbb, 0xba, 0x56, 0x9a, 0x74, 0xfe, 0x4c, 0x39, 0x7f, 0xf2,
	0xce, 0x9f, 0xe9, 0x7a, 0xca, 0xc9, 0xb9, 0x08, 0xfe, 0x4f, 0x50, 0xfd, 0xd6, 0x6f, 0x88, 0x55,
	0x8c, 0x5b, 0x47, 0x35, 0xb4, 0x04, 0x11, 0x62, 0xef, 0x4f, 0xb2, 0xcf, 0x29, 0xf6, 0x99, 0x67,
	0x9f, 0xd3, 0xec, 0x73, 0x86, 0x7d, 0xce, 0xb2, 0xcf, 0x39, 0xf6, 0x39, 0xcf, 0x3e, 0x17, 0xd8,
	0xe7, 0x75, 0xe8, 0xa4, 0x58, 0x6c, 0x08, 0xb1, 0x1f, 0xa2, 0xae, 0x2c, 0xeb, 0xee, 0x84, 0x32,
	0x6c, 0x97, 0x07, 0x3c, 0x0f, 0x11, 0x55, 0x2e, 0x1a, 0xbc, 0x02, 0xe2, 0x6a, 0xa0, 0xf4, 0xfd,
	0xe2, 0xbb, 0xd3, 0x21, 0x32, 0x04, 0xfc, 0x36, 0x24, 0xe4, 0x22, 0x4b, 0x72, 0x53, 0x87, 0xaf,
	0x6a, 0xf0, 0xcb, 0x6e, 0xad, 0x92, 0x3c, 0x3d, 0x0e, 0x70, 0x81, 0xc1, 0xe2, 0xbb, 0x30, 0xa0,
	0x2a, 0xda, 0x03, 0xaa, 0xd6, 0xaa, 0xa2, 0x95, 0x9d, 0x5b, 0xd5, 0x07, 0xb2, 0xca, 0xe2, 0x9e,
	0x44, 0x61, 0xe8, 0x69, 0x0d, 0x21, 0xea, 0xe6, 0x53, 0xd7, 0xd0, 0xbd, 0xad, 0xf7, 0x87, 0x6f,
	0x8c, 0xfe, 0xef, 0xb0, 0xd8, 0x47, 0xf1, 0x36, 0x1d, 0xb4, 0x55, 0x8e, 0x85, 0xaf, 0x43, 0x82,
	0x91, 0xab, 0x1a, 0x52, 0x89, 0xa8, 0xf2, 0x21, 0xbf, 0x08, 0x37, 0xc0, 0xc9, 0x84, 0xf3, 0x0e,
	0x95, 0xce, 0xb1, 0x70, 0xfa, 0xe7, 0xdd, 0x62, 0x9c, 0xc2, 0xee, 0x18, 0xcb, 0x14, 0xf2, 0xc6,
	0xff, 0x41, 0xcf, 0x6a, 0x28, 0x03, 0x23, 0x30, 0x44, 0x47, 0x99, 0x69, 0x7d, 0xf1, 0xfd, 0xbf,
	0xa1, 0x63, 0x37, 0xdf, 0x2f, 0x43, 0xf2, 0x2e, 0xa9, 0xec, 0x12, 0xd3, 0xbb, 0xfb, 0x1b, 0xf7,
	0x26, 0x57, 0x88, 0xc0, 0xbb, 0x10, 0x63, 0x34, 0xef, 0xea, 0x25, 0x32, 0x36, 0x09, 0xe3, 0xd0,
	0xe3, 0xc8, 0x3a, 0x1f, 0x59, 0x5f, 0x5c, 0xda, 0x84, 0x91, 0x26, 0x01, 0xe6, 0x13, 0x8b, 0xec,
	0xe7, 0x84, 0x23, 0x23, 0x98, 0x85, 0xe1, 0x75, 0x45, 0x7b, 0x90, 0xe1, 0x83, 0xcd, 0xb8, 0xa3,
	0xcd, 0x8c, 0x56, 0xac, 0x37, 0xa9, 0xc9, 0x0b, 0x94, 0x20, 0xbc, 0x06, 0x98, 0xa1, 0xed, 0x18,
	0x19, 0x36, 0x42, 0x07, 0x3c, 0xd5, 0x24, 0xa1, 0xc2, 0x08, 0xc4, 0x29, 0x2f, 0xad, 0xee, 0x85,
	0x3a, 0x99, 0x82, 0xec, 0x9f, 0x21, 0x48, 0x37, 0x2d, 0x82, 0xfa, 0x1a, 0x7e, 0x00, 0x3d, 0x54,
	0xc5, 0x9b, 0xd2, 0x03, 0xa3, 0xad, 0x17, 0x70, 0xe3, 0x4a, 0xf2, 0x5d, 0x15, 0x88, 0x04, 0x5f,
	0x15, 0xd8, 0xad, 0x77, 0x7a, 0xe3, 0xc2, 0xb3, 0x1a, 0xea, 0x83, 0x5e, 0x67, 0x2d, 0xbb, 0xf2,
	0xc6, 0x68, 0x2a, 0xfb, 0x7d, 0x04, 0x19, 0xbf, 0x79, 0xd8, 0xb2, 0x65, 0x5b, 0x29, 0x8a, 0x7a,
	0xd5, 0xf6, 0xb1, 0x4a, 0xea, 0x7b, 0x8b, 0xc9, 0x5a, 0x38, 0xb3, 0x23, 0xcd, 0x07, 0xb0, 0x75,
	0xe4, 0x26, 0x16, 0x83, 0x97, 0x91, 0xeb, 0xda, 0x3b, 0xdd, 0x65, 0x7f, 0x81, 0xa0, 0xf7, 0xfe,
	0xed, 0xcd, 0x9d, 0x46, 0xf5, 0x61, 0x47, 0x5a, 0xec, 0x12, 0x6a, 0xe3, 0x1d, 0xd6, 0xe4, 0xd3,
	0x7a, 0x90, 0xf7, 0x45, 0x88, 0x12, 0x63, 0x50, 0x6e, 0xf2, 0xe1, 0x26, 0xc4, 0x8f, 0xdf, 0x5d,
	0xbd, 0xec, 0xae, 0x8c, 0xf9, 0xc9, 0x79, 0xef, 0x36, 0x47, 0xfd, 0x2e, 0x2b, 0x58, 0xf5, 0x8b,
	0xac, 0x1f, 0x40, 0xcf, 0x1e, 0x91, 0x6d, 0xba, 0x99, 0xb1, 0x1b, 0x32, 0x5d, 0x6d, 0xde, 0x3c,
	0x41, 0x99, 0xbe, 0xe5, 0x00, 0xb3, 0x71, 0x27, 0xbf, 0xac, 0x21, 0xd8, 0xd9, 0x58, 0x5f, 0x5d,
	0x5a, 0xd9, 0xd8, 0x5a, 0x59, 0x16, 0xe3, 0x7b, 0xf5, 0x46, 0x9e, 0x62, 0xb8, 0x00, 0xa9, 0xfb,
	0x77, 0x1b, 0x06, 0xca, 0x1b, 0x3e, 0x06, 0xa1, 0x70, 0x7b, 0xb3, 0x51, 0x04, 0x17, 0x21, 0x2c,
	0x5b, 0x1a, 0x1f, 0x43, 0x8c, 0x57, 0xb6, 0x8e, 0x22, 0x91, 0x3e, 0xc5, 0x4b, 0xd0, 0x69, 0x10,
	0xea, 0x79, 0x3a, 0xef, 0x00, 0xb9, 0xd0, 0xc4, 0xe1, 0x6e, 0xd9, 0x18, 0xdf, 0x24, 0xc4, 0x0c,
	0x3a, 0xa7, 0x9f, 0x44, 0xa2, 0x83, 0xcb, 0xfb, 0xfe, 0x5b, 0x04, 0x03, 0xeb, 0x7a, 0x51, 0x56,
	0x97, 0x74, 0xcd, 0x36, 0x75, 0x75, 0x53, 0x95, 0x35, 0xc2, 0xf3, 0x47, 0x31, 0x45, 0xb3, 0x94,
	0x12, 0x91, 0x0e, 0x34, 0x5e, 0xa7, 0xdf, 0xca, 0x54, 0x45, 0x1d, 0xc0, 0xfb, 0x74, 0xe6, 0x40,
	0xaf, 0xda, 0x2e, 0x56, 0xb8, 0x2d, 0x56, 0x8c, 0x43, 0xde, 0xd7, 0xf0, 0x32, 0xc0, 0x6e, 0xd9,
	0x90, 0x8a, 0x4c, 0x04, 0xdc, 0xb2, 0xbe, 0x16, 0x6c, 0x59, 0x9b, 0x04, 0x25, 0xc6, 0x76, 0xcb,
	0x86, 0xf3, 0xa4, 0x70, 0xb5, 0xfe, 0xa6, 0x8f, 0xf6, 0xc9, 0x9e, 0xc7, 0x59, 0x48, 0xde, 0x56,
	0xf5, 0x5d, 0x59, 0xdd, 0x32, 0x48, 0x91, 0x8d, 0xf6, 0x2d, 0x88, 0xb3, 0x0e, 0x24, 0x76, 0x5c,
	0xc2, 0xf7, 0x2a, 0xd7, 0x8d, 0x7c, 0xee, 0x5c, 0x06, 0x25, 0xc4, 0x66, 0xc7, 0x2a, 0x78, 0x0d,
	0x86, 0x0e, 0x74, 0xd5, 0x26, 0xa6, 0x29, 0x4b, 0x96, 0xbe, 0x67, 0x3f, 0x94, 0x4d, 0x22, 0x1d,
	0x10, 0xd3, 0x6a, 0x1d, 0x9e, 0x5e, 0x70, 0x11, 0xb6, 0x38, 0xfc, 0x7d, 0x07, 0x1c, 0xdf, 0x7d,
	0xe1, 0x77, 0x5a, 0x40, 0x7d, 0x76, 0xeb, 0xbb, 0xd3, 0x83, 0xfa, 0x2b, 0x41, 0x8a, 0xba, 0xa6,
	0xb1, 0x94, 0x87, 0x73, 0xd3, 0xea, 0x2c, 0xef, 0x8a, 0xf1, 0x50, 0x7d, 0x5d, 0xb8, 0x8d, 0x4b,
	0x1e, 0x59, 0xbc, 0x07, 0x82, 0x8b, 0xb1, 0xa7, 0x98, 0xe4, 0xa1, 0xac, 0xaa, 0xfc, 0xac, 0xa1,
	0x7d, 0x57, 0x97, 0x3f, 0x7b, 0x74, 0x0c, 0xd1, 0xf7, 0x56, 0x9a, 0x14, 0x6f, 0xbb, 0xc5, 0x9b,
	0xf0, 0x1d, 0x48, 0xeb, 0x06, 0xa1, 0x13, 0xae, 0x95, 0x25, 0xeb, 0xd0, 0xb2, 0x49, 0xc5, 0x13,
	0x77, 0x57, 0xa0, 0xb8, 0x07, 0x3d, 0xf8, 0x2d, 0x06, 0xee, 0x4a, 0xdb, 0x84, 0x0b, 0x9e, 0x7e,
	0x3a, 0x87, 0xae, 0xde, 0xbb, 0x1b, 0xba, 0x4f, 0xc1, 0xf8, 0xa5, 0xcf, 0x1e, 0xa5, 0x9a, 0xf0,
	0x7c, 0x7c, 0x0f, 0xb8, 0x0a, 0xed, 0x40, 0xb8, 0xef, 0x79, 0x30, 0x60, 0xd0, 0x5d, 0x48, 0x4d,
	0x5d, 0x46, 0x5f, 0xba, 0xcb, 0x7e, 0xbe, 0xf2, 0x1a, 0x7b, 0xdc, 0x86, 0xa4, 0xf7, 0x32, 0x15,
	0x49, 0x55, 0x2c, 0x9b, 0xa7, 0x18, 0xda, 0x24, 0xa2, 0x8f, 0xbd, 0xfb, 0x85, 0x06, 0xe2, 0x8a,
	0xff, 0x21, 0x5e, 0xa9, 0x5f, 0xe2, 0xf3, 0xbd, 0x14, 0xe6, 0x8d, 0xb6, 0x6b, 0xbc, 0x97, 0x63,
	0x78, 0xe4, 0x2d, 0xbc, 0x04, 0x49, 0x95, 0x94, 0xe5, 0xe2, 0xa1, 0xb7, 0x0d, 0xc6, 0x5b, 0x93,
	0x28, 0x44, 0xa8, 0xf9, 0xa6, 0xbc, 0x38, 0x38, 0xee, 0x36, 0x76, 0x13, 0x52, 0x9a, 0x2e, 0x35,
	0x6c, 0xa6, 0x42, 0x1b, 0x46, 0x90, 0x98, 0xd0, 0x74, 0xdf, 0x8e, 0x8c, 0x7f, 0x1f, 0x04, 0x1f,
	0xb2, 0x23, 0xa3, 0x5e, 0x46, 0xe0, 0xda, 0x69, 0x76, 0x63, 0x6f, 0x9f, 0xbc, 0x83, 0xc4, 0x64,
	0x7d, 0xd3, 0x65, 0x62, 0x5a, 0x83, 0x01, 0x4d, 0xf7, 0x82, 0x03, 0x9f, 0xa4, 0xfa, 0xda, 0x5e,
	0xd7, 0xe8, 0xd3, 0x74, 0xbe, 0x1f, 0xfb, 0x64, 0x55, 0x84, 0xc1, 0x63, 0x84, 0x1c, 0x66, 0xfb,
	0xcf, 0x3e, 0xa1, 0x21, 0xb1, 0xdf, 0x6a, 0xea, 0x81, 0x31, 0x5c, 0x80, 0x5e, 0x1f, 0xc3, 0x3c,
	0x33, 0x37, 0xd8, 0x86, 0xd9, 0xb0, 0x98, 0xf2, 0x98, 0xe5, 0x29, 0x3a, 0xd9, 0x57, 0x99, 0xeb,
	0x13, 0xa9, 0x53, 0xb4, 0x35, 0x71, 0xca, 0xf3, 0x0f, 0x8f, 0xd3, 0x70, 0xbd, 0xfe, 0xb6, 0x41,
	0xae, 0xc1, 0x39, 0xbd, 0xa1, 0x36, 0xac, 0x46, 0x82, 0x73, 0x7d, 0xdf, 0x6e, 0x8e, 0xac, 0x19,
	0xb7, 0x4e, 0x69, 0xfe, 0xf8, 0xe9, 0xe2, 0x29, 0x8f, 0xd9, 0x48, 0x63, 0x86, 0x81, 0xf1, 0xfa,
	0x3e, 0xf4, 0x69, 0xba, 0x54, 0x2a, 0x4a, 0xee, 0xcb, 0x1e, 0x58, 0x55, 0x71, 0xfa, 0xd2, 0x89,
	0x8a, 0xde, 0x29, 0x0a, 0x9a, 0xbe, 0x5c, 0x5c, 0x72, 0xd0, 0x6e, 0x53, 0x2c, 0x5c, 0x06, 0xe1,
	0x18, 0xa5, 0xcb, 0x8c, 0xd2, 0x69, 0x5e, 0xc5, 0x74, 0xe1, 0xb3, 0x47, 0xc7, 0xd0, 0x79, 0x57,
	0xc9, 0x52, 0x63, 0x47, 0x36, 0x5c, 0x68, 0x86, 0x94, 0x1c, 0xfb, 0x92, 0x7e, 0xfd, 0xeb, 0xe8,
	0xaf, 0xbf, 0xb1, 0xbf, 0x55, 0x46, 0x1a, 0xbf, 0x0b, 0x71, 0xf7, 0x4e, 0x6f, 0xd9, 0xa8, 0xa6,
	0xaf, 0x9c, 0x28, 0xa3, 0x2e, 0x11, 0x38, 0xc2, 0x6d, 0xa3, 0x8a, 0xdf, 0x06, 0xe0, 0x6f, 0x61,
	0xa0, 0xd8, 0x99, 0x53, 0x60, 0xc7, 0x1c, 0x78, 0x8a, 0x7c, 0x0f, 0xe2, 0x1c, 0xf9, 0x80, 0x62,
	0xcf, 0x30, 0xec, 0xd7, 0x5b, 0x3a, 0x7c, 0x0d, 0x9e, 0x47, 0x9d, 0x1b, 0x87, 0xc4, 0xfd, 0xb2,
	0x51, 0xc5, 0xbf, 0x07, 0x2e, 0x6f, 0xd2, 0x41, 0x25, 0xbd, 0xd0, 0x86, 0x1b, 0x56, 0xb5, 0xf2,
	0x73, 0x4a, 0xa1, 0x5b, 0x8c, 0x71, 0x9c, 0xfb, 0x15, 0x7c, 0x17, 0x62, 0x2e, 0x47, 0x95, 0xf4,
	0x75, 0x86, 0xdf, 0xc2, 0x01, 0x6d, 0x74, 0x25, 0x1b, 0xe8, 0x45, 0x39, 0x47, 0x15, 0xbc, 0x07,
	0xfd, 0xc4, 0x2e, 0x96, 0xbc, 0xe9, 0x70, 0x77, 0x9e, 0xab, 0xcc, 0xb5, 0x0d, 0x36, 0x1f, 0x2b,
	0x76, 0xb1, 0xc4, 0xe7, 0x89, 0x6f, 0x28, 0x6c, 0x62, 0xbb, 0xbf, 0x78, 0xc4, 0xe8, 0x8b, 0x98,
	0x1c, 0x03, 0xc0, 0xf7, 0x20, 0xed, 0xb3, 0x21, 0x16, 0x0b, 0x0a, 0xdc, 0xc0, 0xe1, 0x95, 0x36,
	0xeb, 0x33, 0x2a, 0x0e, 0x78, 0xa6, 0xc4, 0x1f, 0x87, 0xe0, 0x07, 0x30, 0x10, 0x4c, 0xed, 0x55,
	0x46, 0x6d, 0xf6, 0xc4, 0x45, 0x1a, 0x14, 0xd5, 0xdc, 0x89, 0x8a, 0xae, 0x99, 0x6a, 0xe8, 0x6c,
	0x1b, 0x5e, 0xe5, 0x42, 0xf7, 0x6e, 0xb7, 0x33, 0x5f, 0xd0, 0xf1, 0x47, 0xa5, 0x92, 0xfe, 0x50,
	0x53, 0x75, 0xb9, 0x94, 0x7e, 0xcd, 0x49, 0x15, 0x53, 0x49, 0x8b, 0x19, 0x07, 0x83, 0x27, 0xd4,
	0x58, 0xcf, 0xce, 0x84, 0x2c, 0x73, 0x68, 0x7c, 0x0b, 0x1c, 0x9f, 0xd1, 0x09, 0x26, 0xde, 0x64,
	0x12, 0x1f, 0x69, 0xcd, 0x77, 0xa3, 0x90, 0x63, 0x7b, 0xee, 0x33, 0xfc, 0x01, 0xc4, 0x2d, 0x45,
	0x2b, 0xab, 0x44, 0xb2, 0x14, 0x9b, 0xa4, 0xc7, 0x4e, 0xe1, 0x34, 0xa4, 0x3f, 0x7b, 0x14, 0xa1,
	0xc0, 0x9c, 0x9a, 0xcf, 0x61, 0x00, 0x87, 0xd4, 0x96, 0x62, 0x13, 0xbc, 0x0d, 0x17, 0x54, 0xbd,
	0x6c, 0x49, 0x96, 0x6d, 0x12, 0xb9, 0x42, 0x7d, 0x2b, 0xae, 0x87, 0xa5, 0x74, 0xee, 0xc4, 0x75,
	0x14, 0x13, 0x07, 0x28, 0xf2, 0x96, 0x8b, 0xbb, 0xcc, 0x51, 0xf1, 0xb7, 0xa0, 0x47, 0xd5, 0xcb,
	0x92, 0x49, 0x8a, 0x44, 0x39, 0x20, 0x66, 0xfa, 0xda, 0xa9, 0x4d, 0x47, 0xdf, 0x67, 0x8f, 0x1a,
	0x50, 0x79, 0x3f, 0x71, 0x55, 0x2f, 0x8b, 0xfc, 0x11, 0xbe, 0x09, 0x3d, 0x25, 0xa2, 0x1d, 0x4a,
	0xb2, 0xaa, 0x4a, 0x55, 0x6b, 0x37, 0x3d, 0x71, 0x22, 0xa3, 0x20, 0x02, 0xc5, 0x58, 0x54, 0xd5,
	0x1d, 0x6b, 0x17, 0xbf, 0x07, 0x09, 0x27, 0xe7, 0xe7, 0x12, 0x98, 0x3c, 0x05, 0x81, 0x38, 0x43,
	0xe1, 0x14, 0xee, 0x03, 0x54, 0xad, 0x5d, 0xf7, 0x2c, 0x62, 0xea, 0xd4, 0xa3, 0xeb, 0xfd, 0xec,
	0x91, 0x0f, 0x91, 0x53, 0x8e, 0x55, 0xad, 0x5d, 0x7e, 0x42, 0xf1, 0x21, 0xc4, 0x1f, 0x2c, 0x58,
	0xee, 0x4a, 0x4d, 0xe7, 0x4f, 0x4d, 0x78, 0xe0, 0xb3, 0x47, 0x7e, 0x4c, 0x57, 0x83, 0xe0, 0xc1,
	0x82, 0xc5, 0x57, 0x29, 0x2e, 0x42, 0x9f, 0x4a, 0x83, 0x3c, 0xaa, 0xd1, 0x34, 0xca, 0x93, 0x0c,
	0x1a, 0xe6, 0xa5, 0xa7, 0xdb, 0xbc, 0xc0, 0x27, 0x30, 0x28, 0xac, 0xeb, 0x67, 0xaf, 0xda, 0xdc,
	0x8e, 0xd7, 0xa1, 0xcf, 0xb5, 0x7d, 0x7b, 0x54, 0xc2, 0x4e, 0x95, 0x6a, 0x7a, 0xee, 0x44, 0x01,
	0xc7, 0xc5, 0x5e, 0x8e, 0x78, 0x4b, 0xd5, 0x1f, 0x3a, 0xf7, 0x23, 0xf0, 0x37, 0x00, 0xf3, 0x35,
	0xe9, 0x27, 0x36, 0xdf, 0x86, 0x58, 0xfc, 0x8b, 0x47, 0xc8, 0x33, 0x82, 0x71, 0x51, 0x70, 0xd0,
	0x7d, 0x24, 0xbf, 0x0d, 0x09, 0xf6, 0x5a, 0x4e, 0xe6, 0x4a, 0x69, 0xb2, 0x9a, 0xfe, 0x79, 0xf7,
	0xa9, 0x85, 0xdc, 0xff, 0xd9, 0xa3, 0x46, 0x64, 0x26, 0x85, 0x1e, 0xfa, 0x68, 0x95, 0x3f, 0xc1,
	0xf7, 0x20, 0x55, 0x26, 0x1a, 0x8d, 0x3b, 0x48, 0x49, 0x3a, 0x94, 0x2b, 0xaa, 0x95, 0xfe, 0x45,
	0x37, 0xcb, 0x58, 0xbe, 0xe6, 0x5b, 0x88, 0xf0, 0x43, 0xd4, 0x9d, 0xad, 0x9f, 0x9d, 0xba, 0x3f,
	0x7f, 0x80, 0x90, 0x98, 0xf4, 0xd0, 0x7f, 0x9f, 0x62, 0x17, 0x46, 0x41, 0xa8, 0xbb, 0x7d, 0x3c,
	0xa4, 0xed, 0x7f, 0x5a, 0x43, 0x6f, 0x3c, 0xaf, 0xa1, 0xd8, 0x51, 0x0d, 0x45, 0xa7, 0xdd, 0x12,
	0xd6, 0x0c, 0xb0, 0xdc, 0x8f, 0xff, 0xaa, 0x9b, 0xf0, 0xbc, 0x86, 0x52, 0xec, 0xaa, 0xdb, 0x5c,
	0x6e, 0x6a, 0xbe, 0x70, 0x0d, 0xd2, 0xc7, 0x5d, 0x49, 0x1f, 0x78, 0xdf, 0xf3, 0x1a, 0xc2, 0x0c,
	0xfc, 0x7a, 0x2e, 0x3f, 0x59, 0x18, 0xab, 0xdb, 0xdf, 0xc6, 0x7c, 0x36, 0x85, 0x1d, 0x7c, 0x5e,
	0x43, 0x03, 0x14, 0x96, 0x15, 0xa9, 0x17, 0xde, 0x84, 0xfe, 0x46, 0x6f, 0xca, 0x07, 0x3a, 0xf4,
	0xbc, 0x86, 0xd2, 0x0c, 0x74, 0x36, 0x97, 0x9f, 0x2b, 0x4c, 0x06, 0xb8, 0x18, 0x1c, 0x7a, 0xe0,
	0x69, 0x0d, 0x5d, 0xe2, 0x05, 0xb7, 0x17, 0x19, 0xc6, 0x42, 0x2e, 0x7f, 0xbd, 0xf0, 0x3a, 0x40,
	0xd9, 0xa8, 0xfa, 0xab, 0x72, 0xaf, 0x70, 0xa0, 0x11, 0x26, 0x81, 0xa9, 0xdc, 0x74, 0x3e, 0x37,
	0x9b, 0x2f, 0xbc, 0x0e, 0xb1, 0x83, 0x8a, 0x0b, 0x36, 0xf4, 0xb4, 0x86, 0x16, 0x38, 0xd8, 0x0d,
	0x4a, 0x6b, 0x76, 0x2e, 0x37, 0x3b, 0xff, 0xab, 0x1a, 0x42, 0x85, 0x29, 0xb8, 0x14, 0xb8, 0xb1,
	0xf8, 0x99, 0x7e, 0xe5, 0x79, 0x0d, 0x65, 0x29, 0xda, 0xf4, 0x6c, 0x6e, 0x7a, 0xae, 0x70, 0x0d,
	0xfa, 0x99, 0x9d, 0x74, 0xed, 0x92, 0x9f, 0xe3, 0x1c, 0xef, 0xe5, 0x2d, 0x0a, 0x3e, 0x33, 0x93,
	0x9b, 0x99, 0x2d, 0x5c, 0x83, 0xde, 0xfa, 0x3a, 0xf7, 0x33, 0x3e, 0xc1, 0x61, 0xc7, 0x29, 0xe3,
	0x33, 0xf3, 0xb9, 0x99, 0x85, 0xdc, 0xcc, 0xf5, 0xc2, 0x28, 0xf4, 0xfb, 0x34, 0xbc, 0x4e, 0x5d,
	0x78, 0x5a, 0x43, 0x73, 0x1c, 0x63, 0x96, 0xb2, 0xbe, 0x16, 0x89, 0xc6, 0x04, 0x58, 0x8b, 0x44,
	0x53, 0x82, 0xb0, 0x16, 0x89, 0x62, 0xa1, 0x6f, 0x2d, 0x12, 0x1d, 0x10, 0x06, 0xd7, 0x22, 0xd1,
	0xb4, 0x30, 0xb4, 0x16, 0x89, 0x5e, 0x14, 0x2e, 0xad, 0x45, 0xa2, 0x23, 0xc2, 0x95, 0xb5, 0x48,
	0xf4, 0x86, 0xf0, 0xf6, 0x5a, 0x24, 0x9a, 0x15, 0x5e, 0x59, 0x8b, 0x44, 0x47, 0x85, 0x37, 0xd7,
	0x22, 0xd1, 0xb7, 0x84, 0xdc, 0x5a, 0x24, 0x3a, 0x2e, 0x4c, 0xac, 0x45, 0xa2, 0xb3, 0xc2, 0x5c,
	0xf6, 0x3f, 0x5c, 0x84, 0xe4, 0x92, 0x49, 0x64, 0x9b, 0xbc, 0x58, 0x12, 0xe4, 0xc6, 0x89, 0x49,
	0x90, 0xd6, 0x49, 0x0f, 0xf9, 0x85, 0xb3, 0x14, 0xfd, 0x41, 0x59, 0x8a, 0xa0, 0xdc, 0xc4, 0xb7,
	0x5e, 0x30, 0x37, 0xd1, 0x17, 0x90, 0x9b, 0x38, 0x9e, 0x91, 0x58, 0x38, 0x29, 0x23, 0xd1, 0x32,
	0x03, 0xb1, 0xff, 0x72, 0x19, 0x08, 0x7c, 0x3c, 0x1d, 0xd0, 0x2a, 0xef, 0xb0, 0xf7, 0x52, 0x79,
	0x87, 0xa0, 0x8e, 0x4e, 0x9b, 0x6d, 0x48, 0x7c, 0x0d, 0xd9, 0x86, 0x77, 0xeb, 0xaf, 0x1a, 0xe2,
	0x69, 0xc1, 0xd1, 0xf6, 0x35, 0xb1, 0x1c, 0xda, 0x71, 0xc2, 0xf0, 0xfb, 0x10, 0xf7, 0x07, 0xa2,
	0xc9, 0x36, 0x35, 0xe5, 0x01, 0x6f, 0x9a, 0xbd, 0xd3, 0x41, 0x9d, 0x06, 0x2f, 0xf4, 0x3c, 0xcf,
	0x36, 0x9c, 0x67, 0x1b, 0x7e, 0x8b, 0xb3, 0x0d, 0x2b, 0x67, 0xce, 0x36, 0x04, 0xe6, 0x19, 0x8a,
	0x2f, 0x95, 0x67, 0xe8, 0x0b, 0x88, 0xfb, 0x03, 0x72, 0x0c, 0xc6, 0xd7, 0x91, 0x63, 0x68, 0xd1,
	0x57, 0x70, 0x7e, 0x61, 0xfe, 0xd4, 0xf9, 0x85, 0xa6, 0xcc, 0xc2, 0xec, 0x69, 0x33, 0x0b, 0x8d,
	0x39, 0x85, 0xd5, 0x97, 0xc8, 0x29, 0x34, 0x65, 0x13, 0x5e, 0x34, 0xaa, 0xee, 0xfe, 0xcd, 0x46,
	0xd5, 0xdd, 0xc1, 0x51, 0xf5, 0xc6, 0x59, 0xa2, 0xea, 0x53, 0xc4, 0xd3, 0x1b, 0x2f, 0x14, 0xae,
	0xde, 0x89, 0xb6, 0x0a, 0x54, 0xff, 0xc1, 0x0b, 0x07, 0xaa, 0xa9, 0xa6, 0x40, 0xf5, 0x4e, 0xb4,
	0x31, 0x48, 0x5d, 0x38, 0x7d, 0x90, 0x7a, 0x27, 0xd6, 0x10, 0x9e, 0xde, 0x38, 0x43, 0x78, 0x4a,
	0x43, 0x63, 0x7f, 0x60, 0x2a, 0xbe, 0x60, 0x60, 0x9a, 0x68, 0x08, 0x4c, 0xef, 0xc4, 0xfc, 0x41,
	0xe9, 0xec, 0x69, 0xf3, 0x59, 0x34, 0x96, 0xad, 0x67, 0xb1, 0x96, 0x5e, 0x30, 0x8b, 0x75, 0x07,
	0xea, 0xb9, 0xab, 0x1b, 0xff, 0x03, 0x7d, 0x7e, 0xb3, 0xe9, 0x98, 0xee, 0x59, 0x0d, 0x3d, 0x41,
	0x90, 0xe1, 0x75, 0x26, 0x4d, 0x45, 0x07, 0xb1, 0x29, 0x76, 0xab, 0x2f, 0x9f, 0x9b, 0x83, 0x8b,
	0x80, 0xb9, 0x77, 0x92, 0xf1, 0xed, 0x6f, 0x9d, 0x53, 0xb3, 0xb9, 0x29, 0x76, 0x31, 0xc2, 0x6d,
	0xf4, 0xf9, 0x8b, 0x68, 0x06, 0x06, 0x40, 0x70, 0x1b, 0x3c, 0x47, 0x0f, 0xcd, 0xc2, 0x55, 0x18,
	0xf0, 0x2a, 0xbb, 0x1a, 0x3a, 0x8c, 0x4e, 0x2d, 0xe4, 0xf2, 0x53, 0xb9, 0xfc, 0x0c, 0x8c, 0xc2,
	0xa0, 0x57, 0x2f, 0xd4, 0x08, 0x93, 0xcc, 0xcf, 0xe7, 0xa6, 0x27, 0x73, 0xd3, 0x33, 0xb9, 0x99,
	0xe9, 0xdc, 0xcc, 0x5c, 0xcb, 0x90, 0x6e, 0x94, 0xbf, 0x98, 0x24, 0x3a, 0x33, 0xe9, 0x5c, 0x33,
	0x2c, 0x8c, 0x34, 0x86, 0x74, 0xa9, 0xc7, 0x5f, 0x21, 0xff, 0x83, 0xc2, 0x42, 0x9b, 0x80, 0xee,
	0xd2, 0xe3, 0xaf, 0x50, 0xcb, 0xd6, 0x42, 0xbe, 0x55, 0x6c, 0x37, 0xf4, 0xf8, 0x2b, 0x14, 0xdc,
	0x54, 0x98, 0x6c, 0x11, 0xe3, 0xa5, 0x1f, 0x7f, 0x85, 0x02, 0x5b, 0x0a, 0x73, 0xad, 0x43, 0xbd,
	0x8b, 0x8f, 0xbf, 0x42, 0xad, 0x1a, 0x0b, 0x97, 0x1a, 0x02, 0xbe, 0xe4, 0xe3, 0xaf, 0x90, 0xef,
	0x77, 0xe1, 0xbd, 0x13, 0xc2, 0xb7, 0xcc, 0xe3, 0xaf, 0x50, 0x5b, 0x08, 0x3a, 0x92, 0xc0, 0x68,
	0x8e, 0x8d, 0x24, 0xa8, 0xa5, 0x30, 0x16, 0x14, 0xd0, 0x0d, 0x3c, 0xfe, 0x0a, 0x1d, 0x7f, 0x5c,
	0x18, 0xf6, 0x87, 0xa1, 0x89, 0xc7, 0x5f, 0xa1, 0xfa, 0x4f, 0xe7, 0x0d, 0x33, 0xa7, 0x8c, 0xdf,
	0x9c, 0xc8, 0xcd, 0x1f, 0xb3, 0xdd, 0x10, 0xde, 0xce, 0x7e, 0xff, 0x22, 0xa4, 0x44, 0x62, 0xa8,
	0x72, 0xb1, 0x1e, 0xb4, 0x9d, 0xc7, 0x61, 0xe7, 0x71, 0xd8, 0x79, 0x1c, 0x76, 0x1e, 0x87, 0x9d,
	0xc7, 0x61, 0xe7, 0x71, 0xd8, 0x79, 0x1c, 0x76, 0x1e, 0x87, 0x9d, 0xc7, 0x61, 0xe7, 0x71, 0xd8,
	0xd7, 0x1a, 0x87, 0x3d, 0x0f, 0x8c, 0xc3, 0xfe, 0x0a, 0xc1, 0x48, 0x70, 0x1c, 0xd6, 0x7d, 0x1e,
	0x85, 0x9d, 0x47, 0x61, 0xbf, 0xcd, 0x51, 0x98, 0xf3, 0xbf, 0x2c, 0xbc, 0x6c, 0x2c, 0xf6, 0xef,
	0x2f, 0x42, 0xfc, 0x36, 0xb1, 0xcf, 0x0f, 0xcf, 0xce, 0x83, 0xb6, 0xf3, 0xa0, 0xed, 0x3c, 0x68,
	0x3b, 0x0f, 0xda, 0xce, 0x83, 0xb6, 0xf3, 0xa0, 0xed, 0x3c, 0x68, 0x3b, 0x0f, 0xda, 0xce, 0x83,
	0xb6, 0xf3, 0xc3, 0xb3, 0xf3, 0xb0, 0xed, 0x3c, 0x6c, 0xfb, 0x6d, 0x3b, 0x3c, 0x7b, 0x1f, 0xe2,
	0xdc, 0x1a, 0xcb, 0x76, 0xd5, 0xc2, 0xef, 0xc0, 0xb0, 0x7c, 0x20, 0x2b, 0xaa, 0xf3, 0x3f, 0x78,
	0x36, 0xc7, 0x60, 0xce, 0xab, 0x3f, 0xd2, 0x1e, 0x44, 0x53, 0x10, 0x36, 0xf6, 0x23, 0x04, 0x83,
	0xc1, 0x17, 0x25, 0xf0, 0x2b, 0x70, 0x65, 0x65, 0x7b, 0x69, 0x59, 0x5a, 0x5a, 0xdf, 0xd9, 0xda,
	0x5e, 0x11, 0xa5, 0xad, 0xd5, 0xed, 0x15, 0x69, 0xfd, 0xde, 0xd2, 0xe2, 0xba, 0xb4, 0xb1, 0xb2,
	0xfd, 0xc1, 0x3d, 0xf1, 0x7d, 0xa1, 0x03, 0x8f, 0xc1, 0xeb, 0xad, 0x80, 0x56, 0x37, 0xb6, 0x56,
	0x97, 0x57, 0x3c, 0x58, 0x84, 0x47, 0xe1, 0xd5, 0xe3, 0xb0, 0x77, 0x17, 0x37, 0x16, 0x6f, 0xaf,
	0xdc, 0x5d, 0xd9, 0xd8, 0xf6, 0x20, 0x43, 0x63, 0x87, 0x90, 0x6a, 0xfa, 0x2f, 0xf1, 0x71, 0x1a,
	0xfa, 0x97, 0x57, 0xee, 0xaf, 0x2e, 0xad, 0x48, 0xf7, 0x3e, 0xd8, 0x58, 0x11, 0xa5, 0xd5, 0x8d,
	0xfb, 0x8b, 0xeb, 0xab, 0xcb, 0x42, 0x07, 0xee, 0x07, 0xa1, 0xa1, 0xe5, 0xfe, 0x8a, 0x28, 0x20,
	0x7c, 0x05, 0x2e, 0x36, 0x3e, 0x7d, 0x7f, 0x61, 0x4b, 0xa2, 0xe4, 0xa5, 0xf5, 0x7b, 0x8b, 0xcb,
	0x42, 0x08, 0x0f, 0x40, 0x6f, 0x03, 0xc0, 0x9d, 0x7b, 0x5b, 0xdb, 0x42, 0x78, 0x6c, 0x02, 0x62,
	0xde, 0x35, 0x06, 0xdc, 0x0b, 0x89, 0xbb, 0x3b, 0xeb, 0xdb, 0xab, 0x9b, 0xeb, 0x2b, 0x8c, 0x5b,
	0xa1, 0x03, 0xa7, 0x20, 0xbe, 0xb5, 0xba, 0x71, 0xdb, 0x7d, 0x80, 0xc6, 0xbe, 0x8f, 0xe0, 0x4a,
	0xab, 0xff, 0x6d, 0x7f, 0x87, 0xbf, 0xcb, 0xec, 0x2a, 0x5c, 0xe6, 0x83, 0x93, 0x56, 0x37, 0xb6,
	0x57, 0xc4, 0x5b, 0x8b, 0x4b, 0x2b, 0xd2, 0xce, 0xd6, 0x8a, 0x24, 0xae, 0xdc, 0xde, 0x59, 0x5f,
	0x14, 0x85, 0x8e, 0xd6, 0x20, 0xf7, 0x76, 0xb6, 0xa9, 0x1c, 0x05, 0x84, 0x33, 0x70, 0x29, 0x18,
	0xc4, 0x91, 0xb4, 0x10, 0x1a, 0x7b, 0x17, 0x52, 0x4d, 0x17, 0xba, 0x71, 0x12, 0x7c, 0xd7, 0xb9,
	0x85, 0x0e, 0x1c, 0x85, 0x08, 0x05, 0x11, 0x10, 0xee, 0x86, 0xf0, 0xfd, 0x0f, 0xb6, 0x84, 0x10,
	0xfb, 0xb2, 0xb4, 0x25, 0x44, 0x0a, 0xdf, 0x43, 0xcf, 0x7f, 0x3a, 0xd2, 0xf1, 0xc5, 0x4f, 0x47,
	0x3a, 0x7e, 0xf5, 0xd3, 0x11, 0xf4, 0xc9, 0xd1, 0x08, 0xfa, 0x77, 0x47, 0x23, 0xe8, 0x27, 0x47,
	0x23, 0xe8, 0xf9, 0xd1, 0x08, 0xfa, 0xe2, 0x68, 0x04, 0xfd, 0xf5, 0xd1, 0x08, 0xfa, 0xf9, 0xd1,
	0x48, 0xc7, 0xaf, 0x8e, 0x46, 0xd0, 0x0f, 0x7e, 0x36, 0xd2, 0xf1, 0xf4, 0x67, 0x23, 0xe8, 0xf9,
	0xcf, 0x46, 0x3a, 0xbe, 0xf8, 0xd9, 0x48, 0xc7, 0x87, 0xab, 0x65, 0xdd, 0x78, 0x50, 0x1e, 0x77,
	0xe3, 0xfd, 0xf1, 0xaa, 0x35, 0xc1, 0xbe, 0xec, 0xe9, 0x66, 0xe5, 0x9a, 0x61, 0xea, 0x07, 0x4a,
	0x89, 0x98, 0xd7, 0xdc, 0xe6, 0x09, 0x63, 0xb7, 0xac, 0x4f, 0x90, 0x8f, 0x6c, 0x67, 0x2f, 0x98,
	0xe0, 0x7f, 0xd8, 0x96, 0xb0, 0xdb, 0xc5, 0xde, 0xe7, 0x36, 0xfd, 0xff, 0x02, 0x00, 0x00, 0xff,
	0xff, 0x54, 0x2d, 0xbf, 0x56, 0xc1, 0x83, 0x00, 0x00,
}

func (x EtcdClusterNetworkType) String() string {
	s, ok := EtcdClusterNetworkType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DeviceOwnerType) String() string {
	s, ok := DeviceOwnerType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x FleetType) String() string {
	s, ok := FleetType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NetworkingDeviceInstanceUseType) String() string {
	s, ok := NetworkingDeviceInstanceUseType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x VGPUFeatureType) String() string {
	s, ok := VGPUFeatureType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *NetworkingDeviceInstanceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkingDeviceInstanceType)
	if !ok {
		that2, ok := that.(NetworkingDeviceInstanceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Interface) != len(that1.Interface) {
		return false
	}
	for i := range this.Interface {
		if !this.Interface[i].Equal(that1.Interface[i]) {
			return false
		}
	}
	if this.Use != that1.Use {
		return false
	}
	return true
}
func (this *GenericDeviceInstanceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GenericDeviceInstanceType)
	if !ok {
		that2, ok := that.(GenericDeviceInstanceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *DeviceInstanceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeviceInstanceType)
	if !ok {
		that2, ok := that.(DeviceInstanceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Owner != that1.Owner {
		return false
	}
	if that1.DeviceInstance == nil {
		if this.DeviceInstance != nil {
			return false
		}
	} else if this.DeviceInstance == nil {
		return false
	} else if !this.DeviceInstance.Equal(that1.DeviceInstance) {
		return false
	}
	return true
}
func (this *DeviceInstanceType_NetworkDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeviceInstanceType_NetworkDevice)
	if !ok {
		that2, ok := that.(DeviceInstanceType_NetworkDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NetworkDevice.Equal(that1.NetworkDevice) {
		return false
	}
	return true
}
func (this *FleetInterfaceListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetInterfaceListType)
	if !ok {
		that2, ok := that.(FleetInterfaceListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Interfaces) != len(that1.Interfaces) {
		return false
	}
	for i := range this.Interfaces {
		if !this.Interfaces[i].Equal(that1.Interfaces[i]) {
			return false
		}
	}
	return true
}
func (this *FleetDeviceListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetDeviceListType)
	if !ok {
		that2, ok := that.(FleetDeviceListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Devices) != len(that1.Devices) {
		return false
	}
	for i := range this.Devices {
		if !this.Devices[i].Equal(that1.Devices[i]) {
			return false
		}
	}
	return true
}
func (this *StorageDeviceOpenebsEnterpriseType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceOpenebsEnterpriseType)
	if !ok {
		that2, ok := that.(StorageDeviceOpenebsEnterpriseType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.MayastorPools) != len(that1.MayastorPools) {
		return false
	}
	for i := range this.MayastorPools {
		if !this.MayastorPools[i].Equal(that1.MayastorPools[i]) {
			return false
		}
	}
	return true
}
func (this *OpenebsMayastorPoolType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OpenebsMayastorPoolType)
	if !ok {
		that2, ok := that.(OpenebsMayastorPoolType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PoolName != that1.PoolName {
		return false
	}
	if this.Node != that1.Node {
		return false
	}
	if len(this.PoolDiskDevices) != len(that1.PoolDiskDevices) {
		return false
	}
	for i := range this.PoolDiskDevices {
		if this.PoolDiskDevices[i] != that1.PoolDiskDevices[i] {
			return false
		}
	}
	return true
}
func (this *StorageDeviceDellIsilonF800Type) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceDellIsilonF800Type)
	if !ok {
		that2, ok := that.(StorageDeviceDellIsilonF800Type)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if !this.Password.Equal(that1.Password) {
		return false
	}
	if that1.HttpsChoice == nil {
		if this.HttpsChoice != nil {
			return false
		}
	} else if this.HttpsChoice == nil {
		return false
	} else if !this.HttpsChoice.Equal(that1.HttpsChoice) {
		return false
	}
	if that1.AddressChoice == nil {
		if this.AddressChoice != nil {
			return false
		}
	} else if this.AddressChoice == nil {
		return false
	} else if !this.AddressChoice.Equal(that1.AddressChoice) {
		return false
	}
	if this.ApiServerPort != that1.ApiServerPort {
		return false
	}
	if this.IscsiAccessZone != that1.IscsiAccessZone {
		return false
	}
	if this.VolumePrefix != that1.VolumePrefix {
		return false
	}
	if this.BasePath != that1.BasePath {
		return false
	}
	return true
}
func (this *StorageDeviceDellIsilonF800Type_SecureNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceDellIsilonF800Type_SecureNetwork)
	if !ok {
		that2, ok := that.(StorageDeviceDellIsilonF800Type_SecureNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SecureNetwork.Equal(that1.SecureNetwork) {
		return false
	}
	return true
}
func (this *StorageDeviceDellIsilonF800Type_TrustedCaUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceDellIsilonF800Type_TrustedCaUrl)
	if !ok {
		that2, ok := that.(StorageDeviceDellIsilonF800Type_TrustedCaUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TrustedCaUrl != that1.TrustedCaUrl {
		return false
	}
	return true
}
func (this *StorageDeviceDellIsilonF800Type_ApiServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceDellIsilonF800Type_ApiServerName)
	if !ok {
		that2, ok := that.(StorageDeviceDellIsilonF800Type_ApiServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ApiServerName != that1.ApiServerName {
		return false
	}
	return true
}
func (this *StorageDeviceDellIsilonF800Type_ApiServerIpAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceDellIsilonF800Type_ApiServerIpAddress)
	if !ok {
		that2, ok := that.(StorageDeviceDellIsilonF800Type_ApiServerIpAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ApiServerIpAddress != that1.ApiServerIpAddress {
		return false
	}
	return true
}
func (this *StorageDeviceHPENimbusStorageAf40Type) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceHPENimbusStorageAf40Type)
	if !ok {
		that2, ok := that.(StorageDeviceHPENimbusStorageAf40Type)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StorageServerName != that1.StorageServerName {
		return false
	}
	if this.StorageServerIpAddress != that1.StorageServerIpAddress {
		return false
	}
	if this.ApiServerPort != that1.ApiServerPort {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if !this.Password.Equal(that1.Password) {
		return false
	}
	if this.PerfPolicy != that1.PerfPolicy {
		return false
	}
	if this.LimitIops != that1.LimitIops {
		return false
	}
	if this.LimitMbps != that1.LimitMbps {
		return false
	}
	return true
}
func (this *StorageDevicePureStorageServiceOrchestratorType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDevicePureStorageServiceOrchestratorType)
	if !ok {
		that2, ok := that.(StorageDevicePureStorageServiceOrchestratorType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClusterId != that1.ClusterId {
		return false
	}
	if this.EnableStorageTopology != that1.EnableStorageTopology {
		return false
	}
	if this.EnableStrictTopology != that1.EnableStrictTopology {
		return false
	}
	if !this.Arrays.Equal(that1.Arrays) {
		return false
	}
	return true
}
func (this *PsoArrayConfiguration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PsoArrayConfiguration)
	if !ok {
		that2, ok := that.(PsoArrayConfiguration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FlashArray.Equal(that1.FlashArray) {
		return false
	}
	if !this.FlashBlade.Equal(that1.FlashBlade) {
		return false
	}
	return true
}
func (this *FlashBladeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashBladeType)
	if !ok {
		that2, ok := that.(FlashBladeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EnableSnapshotDirectory != that1.EnableSnapshotDirectory {
		return false
	}
	if this.ExportRules != that1.ExportRules {
		return false
	}
	if len(this.FlashBlades) != len(that1.FlashBlades) {
		return false
	}
	for i := range this.FlashBlades {
		if !this.FlashBlades[i].Equal(that1.FlashBlades[i]) {
			return false
		}
	}
	return true
}
func (this *FlashBladeEndpoint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashBladeEndpoint)
	if !ok {
		that2, ok := that.(FlashBladeEndpoint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.MgmtEndpoint == nil {
		if this.MgmtEndpoint != nil {
			return false
		}
	} else if this.MgmtEndpoint == nil {
		return false
	} else if !this.MgmtEndpoint.Equal(that1.MgmtEndpoint) {
		return false
	}
	if !this.ApiToken.Equal(that1.ApiToken) {
		return false
	}
	if that1.NfsEndpoint == nil {
		if this.NfsEndpoint != nil {
			return false
		}
	} else if this.NfsEndpoint == nil {
		return false
	} else if !this.NfsEndpoint.Equal(that1.NfsEndpoint) {
		return false
	}
	if len(this.Lables) != len(that1.Lables) {
		return false
	}
	for i := range this.Lables {
		if this.Lables[i] != that1.Lables[i] {
			return false
		}
	}
	return true
}
func (this *FlashBladeEndpoint_MgmtIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashBladeEndpoint_MgmtIp)
	if !ok {
		that2, ok := that.(FlashBladeEndpoint_MgmtIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MgmtIp != that1.MgmtIp {
		return false
	}
	return true
}
func (this *FlashBladeEndpoint_MgmtDnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashBladeEndpoint_MgmtDnsName)
	if !ok {
		that2, ok := that.(FlashBladeEndpoint_MgmtDnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MgmtDnsName != that1.MgmtDnsName {
		return false
	}
	return true
}
func (this *FlashBladeEndpoint_NfsEndpointIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashBladeEndpoint_NfsEndpointIp)
	if !ok {
		that2, ok := that.(FlashBladeEndpoint_NfsEndpointIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NfsEndpointIp != that1.NfsEndpointIp {
		return false
	}
	return true
}
func (this *FlashBladeEndpoint_NfsEndpointDnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashBladeEndpoint_NfsEndpointDnsName)
	if !ok {
		that2, ok := that.(FlashBladeEndpoint_NfsEndpointDnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NfsEndpointDnsName != that1.NfsEndpointDnsName {
		return false
	}
	return true
}
func (this *FlashArrayType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashArrayType)
	if !ok {
		that2, ok := that.(FlashArrayType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SanType != that1.SanType {
		return false
	}
	if this.DefaultFsType != that1.DefaultFsType {
		return false
	}
	if this.DefaultFsOpt != that1.DefaultFsOpt {
		return false
	}
	if len(this.DefaultMountOpts) != len(that1.DefaultMountOpts) {
		return false
	}
	for i := range this.DefaultMountOpts {
		if this.DefaultMountOpts[i] != that1.DefaultMountOpts[i] {
			return false
		}
	}
	if this.DisablePreemptAttachments != that1.DisablePreemptAttachments {
		return false
	}
	if this.IscsiLoginTimeout != that1.IscsiLoginTimeout {
		return false
	}
	if len(this.FlashArrays) != len(that1.FlashArrays) {
		return false
	}
	for i := range this.FlashArrays {
		if !this.FlashArrays[i].Equal(that1.FlashArrays[i]) {
			return false
		}
	}
	return true
}
func (this *FlashArrayEndpoint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashArrayEndpoint)
	if !ok {
		that2, ok := that.(FlashArrayEndpoint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.MgmtEndpoint == nil {
		if this.MgmtEndpoint != nil {
			return false
		}
	} else if this.MgmtEndpoint == nil {
		return false
	} else if !this.MgmtEndpoint.Equal(that1.MgmtEndpoint) {
		return false
	}
	if !this.ApiToken.Equal(that1.ApiToken) {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	return true
}
func (this *FlashArrayEndpoint_MgmtIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashArrayEndpoint_MgmtIp)
	if !ok {
		that2, ok := that.(FlashArrayEndpoint_MgmtIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MgmtIp != that1.MgmtIp {
		return false
	}
	return true
}
func (this *FlashArrayEndpoint_MgmtDnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashArrayEndpoint_MgmtDnsName)
	if !ok {
		that2, ok := that.(FlashArrayEndpoint_MgmtDnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MgmtDnsName != that1.MgmtDnsName {
		return false
	}
	return true
}
func (this *StorageDeviceNetappTridentType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappTridentType)
	if !ok {
		that2, ok := that.(StorageDeviceNetappTridentType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.BackendChoice == nil {
		if this.BackendChoice != nil {
			return false
		}
	} else if this.BackendChoice == nil {
		return false
	} else if !this.BackendChoice.Equal(that1.BackendChoice) {
		return false
	}
	return true
}
func (this *StorageDeviceNetappTridentType_NetappBackendOntapNas) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappTridentType_NetappBackendOntapNas)
	if !ok {
		that2, ok := that.(StorageDeviceNetappTridentType_NetappBackendOntapNas)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NetappBackendOntapNas.Equal(that1.NetappBackendOntapNas) {
		return false
	}
	return true
}
func (this *StorageDeviceNetappTridentType_NetappBackendOntapSan) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappTridentType_NetappBackendOntapSan)
	if !ok {
		that2, ok := that.(StorageDeviceNetappTridentType_NetappBackendOntapSan)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NetappBackendOntapSan.Equal(that1.NetappBackendOntapSan) {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapSanType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapSanType)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapSanType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StorageDriverName != that1.StorageDriverName {
		return false
	}
	if that1.ManagementLif == nil {
		if this.ManagementLif != nil {
			return false
		}
	} else if this.ManagementLif == nil {
		return false
	} else if !this.ManagementLif.Equal(that1.ManagementLif) {
		return false
	}
	if that1.DataLif == nil {
		if this.DataLif != nil {
			return false
		}
	} else if this.DataLif == nil {
		return false
	} else if !this.DataLif.Equal(that1.DataLif) {
		return false
	}
	if this.Svm != that1.Svm {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if !this.Password.Equal(that1.Password) {
		return false
	}
	if that1.ChapChoice == nil {
		if this.ChapChoice != nil {
			return false
		}
	} else if this.ChapChoice == nil {
		return false
	} else if !this.ChapChoice.Equal(that1.ChapChoice) {
		return false
	}
	if this.IgroupName != that1.IgroupName {
		return false
	}
	if this.StoragePrefix != that1.StoragePrefix {
		return false
	}
	if this.LimitAggregateUsage != that1.LimitAggregateUsage {
		return false
	}
	if this.LimitVolumeSize != that1.LimitVolumeSize {
		return false
	}
	if !this.VolumeDefaults.Equal(that1.VolumeDefaults) {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if this.Region != that1.Region {
		return false
	}
	if len(this.Storage) != len(that1.Storage) {
		return false
	}
	for i := range this.Storage {
		if !this.Storage[i].Equal(that1.Storage[i]) {
			return false
		}
	}
	if this.ClientCertificate != that1.ClientCertificate {
		return false
	}
	if !this.ClientPrivateKey.Equal(that1.ClientPrivateKey) {
		return false
	}
	if this.TrustedCaCertificate != that1.TrustedCaCertificate {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapSanType_ManagementLifIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapSanType_ManagementLifIp)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapSanType_ManagementLifIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ManagementLifIp != that1.ManagementLifIp {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ManagementLifDnsName != that1.ManagementLifDnsName {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapSanType_DataLifIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapSanType_DataLifIp)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapSanType_DataLifIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DataLifIp != that1.DataLifIp {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapSanType_DataLifDnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapSanType_DataLifDnsName)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapSanType_DataLifDnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DataLifDnsName != that1.DataLifDnsName {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapSanType_NoChap) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapSanType_NoChap)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapSanType_NoChap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoChap.Equal(that1.NoChap) {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapSanType_UseChap) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapSanType_UseChap)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapSanType_UseChap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseChap.Equal(that1.UseChap) {
		return false
	}
	return true
}
func (this *DeviceNetappBackendOntapSanChapType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeviceNetappBackendOntapSanChapType)
	if !ok {
		that2, ok := that.(DeviceNetappBackendOntapSanChapType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChapUsername != that1.ChapUsername {
		return false
	}
	if this.ChapTargetUsername != that1.ChapTargetUsername {
		return false
	}
	if !this.ChapInitiatorSecret.Equal(that1.ChapInitiatorSecret) {
		return false
	}
	if !this.ChapTargetInitiatorSecret.Equal(that1.ChapTargetInitiatorSecret) {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapNasType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapNasType)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapNasType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StorageDriverName != that1.StorageDriverName {
		return false
	}
	if this.BackendName != that1.BackendName {
		return false
	}
	if that1.ManagementLif == nil {
		if this.ManagementLif != nil {
			return false
		}
	} else if this.ManagementLif == nil {
		return false
	} else if !this.ManagementLif.Equal(that1.ManagementLif) {
		return false
	}
	if that1.DataLif == nil {
		if this.DataLif != nil {
			return false
		}
	} else if this.DataLif == nil {
		return false
	} else if !this.DataLif.Equal(that1.DataLif) {
		return false
	}
	if this.Svm != that1.Svm {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if !this.Password.Equal(that1.Password) {
		return false
	}
	if this.AutoExportPolicy != that1.AutoExportPolicy {
		return false
	}
	if !this.AutoExportCidrs.Equal(that1.AutoExportCidrs) {
		return false
	}
	if this.StoragePrefix != that1.StoragePrefix {
		return false
	}
	if this.LimitAggregateUsage != that1.LimitAggregateUsage {
		return false
	}
	if this.LimitVolumeSize != that1.LimitVolumeSize {
		return false
	}
	if this.NfsMountOptions != that1.NfsMountOptions {
		return false
	}
	if !this.VolumeDefaults.Equal(that1.VolumeDefaults) {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if this.Region != that1.Region {
		return false
	}
	if len(this.Storage) != len(that1.Storage) {
		return false
	}
	for i := range this.Storage {
		if !this.Storage[i].Equal(that1.Storage[i]) {
			return false
		}
	}
	if this.ClientCertificate != that1.ClientCertificate {
		return false
	}
	if !this.ClientPrivateKey.Equal(that1.ClientPrivateKey) {
		return false
	}
	if this.TrustedCaCertificate != that1.TrustedCaCertificate {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapNasType_ManagementLifIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapNasType_ManagementLifIp)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapNasType_ManagementLifIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ManagementLifIp != that1.ManagementLifIp {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ManagementLifDnsName != that1.ManagementLifDnsName {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapNasType_DataLifIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapNasType_DataLifIp)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapNasType_DataLifIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DataLifIp != that1.DataLifIp {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapNasType_DataLifDnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapNasType_DataLifDnsName)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapNasType_DataLifDnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DataLifDnsName != that1.DataLifDnsName {
		return false
	}
	return true
}
func (this *OntapVolumeDefaults) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OntapVolumeDefaults)
	if !ok {
		that2, ok := that.(OntapVolumeDefaults)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SpaceReserve != that1.SpaceReserve {
		return false
	}
	if this.SnapshotPolicy != that1.SnapshotPolicy {
		return false
	}
	if this.SnapshotReserve != that1.SnapshotReserve {
		return false
	}
	if this.SplitOnClone != that1.SplitOnClone {
		return false
	}
	if this.Encryption != that1.Encryption {
		return false
	}
	if this.UnixPermissions != that1.UnixPermissions {
		return false
	}
	if this.SnapshotDir != that1.SnapshotDir {
		return false
	}
	if this.ExportPolicy != that1.ExportPolicy {
		return false
	}
	if this.SecurityStyle != that1.SecurityStyle {
		return false
	}
	if this.TieringPolicy != that1.TieringPolicy {
		return false
	}
	if that1.QosPolicyChoice == nil {
		if this.QosPolicyChoice != nil {
			return false
		}
	} else if this.QosPolicyChoice == nil {
		return false
	} else if !this.QosPolicyChoice.Equal(that1.QosPolicyChoice) {
		return false
	}
	return true
}
func (this *OntapVolumeDefaults_NoQos) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OntapVolumeDefaults_NoQos)
	if !ok {
		that2, ok := that.(OntapVolumeDefaults_NoQos)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoQos.Equal(that1.NoQos) {
		return false
	}
	return true
}
func (this *OntapVolumeDefaults_QosPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OntapVolumeDefaults_QosPolicy)
	if !ok {
		that2, ok := that.(OntapVolumeDefaults_QosPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.QosPolicy != that1.QosPolicy {
		return false
	}
	return true
}
func (this *OntapVolumeDefaults_AdaptiveQosPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OntapVolumeDefaults_AdaptiveQosPolicy)
	if !ok {
		that2, ok := that.(OntapVolumeDefaults_AdaptiveQosPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AdaptiveQosPolicy != that1.AdaptiveQosPolicy {
		return false
	}
	return true
}
func (this *OntapVirtualStoragePoolType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OntapVirtualStoragePoolType)
	if !ok {
		that2, ok := that.(OntapVirtualStoragePoolType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if this.Zone != that1.Zone {
		return false
	}
	if !this.VolumeDefaults.Equal(that1.VolumeDefaults) {
		return false
	}
	return true
}
func (this *FleetStorageDeviceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageDeviceType)
	if !ok {
		that2, ok := that.(FleetStorageDeviceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StorageDevice != that1.StorageDevice {
		return false
	}
	if that1.DeviceChoice == nil {
		if this.DeviceChoice != nil {
			return false
		}
	} else if this.DeviceChoice == nil {
		return false
	} else if !this.DeviceChoice.Equal(that1.DeviceChoice) {
		return false
	}
	if len(this.AdvancedAdvancedParameters) != len(that1.AdvancedAdvancedParameters) {
		return false
	}
	for i := range this.AdvancedAdvancedParameters {
		if this.AdvancedAdvancedParameters[i] != that1.AdvancedAdvancedParameters[i] {
			return false
		}
	}
	return true
}
func (this *FleetStorageDeviceType_NetappTrident) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageDeviceType_NetappTrident)
	if !ok {
		that2, ok := that.(FleetStorageDeviceType_NetappTrident)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NetappTrident.Equal(that1.NetappTrident) {
		return false
	}
	return true
}
func (this *FleetStorageDeviceType_PureServiceOrchestrator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageDeviceType_PureServiceOrchestrator)
	if !ok {
		that2, ok := that.(FleetStorageDeviceType_PureServiceOrchestrator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PureServiceOrchestrator.Equal(that1.PureServiceOrchestrator) {
		return false
	}
	return true
}
func (this *FleetStorageDeviceType_OpenebsEnterprise) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageDeviceType_OpenebsEnterprise)
	if !ok {
		that2, ok := that.(FleetStorageDeviceType_OpenebsEnterprise)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OpenebsEnterprise.Equal(that1.OpenebsEnterprise) {
		return false
	}
	return true
}
func (this *FleetStorageDeviceType_CustomStorage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageDeviceType_CustomStorage)
	if !ok {
		that2, ok := that.(FleetStorageDeviceType_CustomStorage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomStorage.Equal(that1.CustomStorage) {
		return false
	}
	return true
}
func (this *FleetStorageDeviceListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageDeviceListType)
	if !ok {
		that2, ok := that.(FleetStorageDeviceListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.StorageDevices) != len(that1.StorageDevices) {
		return false
	}
	for i := range this.StorageDevices {
		if !this.StorageDevices[i].Equal(that1.StorageDevices[i]) {
			return false
		}
	}
	return true
}
func (this *StorageClassDellIsilonF800Type) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageClassDellIsilonF800Type)
	if !ok {
		that2, ok := that.(StorageClassDellIsilonF800Type)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.HttpsChoice == nil {
		if this.HttpsChoice != nil {
			return false
		}
	} else if this.HttpsChoice == nil {
		return false
	} else if !this.HttpsChoice.Equal(that1.HttpsChoice) {
		return false
	}
	if this.IscsiAccessZone != that1.IscsiAccessZone {
		return false
	}
	if this.BasePath != that1.BasePath {
		return false
	}
	if this.RootClientEnable != that1.RootClientEnable {
		return false
	}
	return true
}
func (this *StorageClassDellIsilonF800Type_AzServiceName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageClassDellIsilonF800Type_AzServiceName)
	if !ok {
		that2, ok := that.(StorageClassDellIsilonF800Type_AzServiceName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AzServiceName != that1.AzServiceName {
		return false
	}
	return true
}
func (this *StorageClassDellIsilonF800Type_AzServiceIpAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageClassDellIsilonF800Type_AzServiceIpAddress)
	if !ok {
		that2, ok := that.(StorageClassDellIsilonF800Type_AzServiceIpAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AzServiceIpAddress != that1.AzServiceIpAddress {
		return false
	}
	return true
}
func (this *StorageClassHPENimbusStorageAf40Type) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageClassHPENimbusStorageAf40Type)
	if !ok {
		that2, ok := that.(StorageClassHPENimbusStorageAf40Type)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PerfPolicy != that1.PerfPolicy {
		return false
	}
	if this.LimitIops != that1.LimitIops {
		return false
	}
	if this.LimitMbps != that1.LimitMbps {
		return false
	}
	return true
}
func (this *StorageClassOpenebsEnterpriseType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageClassOpenebsEnterpriseType)
	if !ok {
		that2, ok := that.(StorageClassOpenebsEnterpriseType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.Replication != that1.Replication {
		return false
	}
	return true
}
func (this *StorageClassNetappTridentType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageClassNetappTridentType)
	if !ok {
		that2, ok := that.(StorageClassNetappTridentType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Selector) != len(that1.Selector) {
		return false
	}
	for i := range this.Selector {
		if this.Selector[i] != that1.Selector[i] {
			return false
		}
	}
	if this.StoragePools != that1.StoragePools {
		return false
	}
	return true
}
func (this *StorageClassPureServiceOrchestratorType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageClassPureServiceOrchestratorType)
	if !ok {
		that2, ok := that.(StorageClassPureServiceOrchestratorType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Backend != that1.Backend {
		return false
	}
	if this.IopsLimit != that1.IopsLimit {
		return false
	}
	if this.BandwidthLimit != that1.BandwidthLimit {
		return false
	}
	return true
}
func (this *StorageClassCustomType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageClassCustomType)
	if !ok {
		that2, ok := that.(StorageClassCustomType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Yaml != that1.Yaml {
		return false
	}
	return true
}
func (this *FleetStorageClassType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageClassType)
	if !ok {
		that2, ok := that.(FleetStorageClassType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StorageDevice != that1.StorageDevice {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.DefaultStorageClass != that1.DefaultStorageClass {
		return false
	}
	if that1.DeviceChoice == nil {
		if this.DeviceChoice != nil {
			return false
		}
	} else if this.DeviceChoice == nil {
		return false
	} else if !this.DeviceChoice.Equal(that1.DeviceChoice) {
		return false
	}
	if this.ReclaimPolicy != that1.ReclaimPolicy {
		return false
	}
	if this.AllowVolumeExpansion != that1.AllowVolumeExpansion {
		return false
	}
	if len(this.AdvancedStorageParameters) != len(that1.AdvancedStorageParameters) {
		return false
	}
	for i := range this.AdvancedStorageParameters {
		if this.AdvancedStorageParameters[i] != that1.AdvancedStorageParameters[i] {
			return false
		}
	}
	if this.StorageClassName != that1.StorageClassName {
		return false
	}
	return true
}
func (this *FleetStorageClassType_NetappTrident) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageClassType_NetappTrident)
	if !ok {
		that2, ok := that.(FleetStorageClassType_NetappTrident)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NetappTrident.Equal(that1.NetappTrident) {
		return false
	}
	return true
}
func (this *FleetStorageClassType_PureServiceOrchestrator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageClassType_PureServiceOrchestrator)
	if !ok {
		that2, ok := that.(FleetStorageClassType_PureServiceOrchestrator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PureServiceOrchestrator.Equal(that1.PureServiceOrchestrator) {
		return false
	}
	return true
}
func (this *FleetStorageClassType_OpenebsEnterprise) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageClassType_OpenebsEnterprise)
	if !ok {
		that2, ok := that.(FleetStorageClassType_OpenebsEnterprise)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OpenebsEnterprise.Equal(that1.OpenebsEnterprise) {
		return false
	}
	return true
}
func (this *FleetStorageClassType_CustomStorage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageClassType_CustomStorage)
	if !ok {
		that2, ok := that.(FleetStorageClassType_CustomStorage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomStorage.Equal(that1.CustomStorage) {
		return false
	}
	return true
}
func (this *FleetStorageClassListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageClassListType)
	if !ok {
		that2, ok := that.(FleetStorageClassListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.StorageClasses) != len(that1.StorageClasses) {
		return false
	}
	for i := range this.StorageClasses {
		if !this.StorageClasses[i].Equal(that1.StorageClasses[i]) {
			return false
		}
	}
	return true
}
func (this *BondLacpType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BondLacpType)
	if !ok {
		that2, ok := that.(BondLacpType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Rate != that1.Rate {
		return false
	}
	return true
}
func (this *FleetBondDeviceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetBondDeviceType)
	if !ok {
		that2, ok := that.(FleetBondDeviceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Devices) != len(that1.Devices) {
		return false
	}
	for i := range this.Devices {
		if this.Devices[i] != that1.Devices[i] {
			return false
		}
	}
	if that1.LacpChoice == nil {
		if this.LacpChoice != nil {
			return false
		}
	} else if this.LacpChoice == nil {
		return false
	} else if !this.LacpChoice.Equal(that1.LacpChoice) {
		return false
	}
	if this.LinkPollingInterval != that1.LinkPollingInterval {
		return false
	}
	if this.LinkUpDelay != that1.LinkUpDelay {
		return false
	}
	return true
}
func (this *FleetBondDeviceType_Lacp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetBondDeviceType_Lacp)
	if !ok {
		that2, ok := that.(FleetBondDeviceType_Lacp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Lacp.Equal(that1.Lacp) {
		return false
	}
	return true
}
func (this *FleetBondDeviceType_ActiveBackup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetBondDeviceType_ActiveBackup)
	if !ok {
		that2, ok := that.(FleetBondDeviceType_ActiveBackup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ActiveBackup.Equal(that1.ActiveBackup) {
		return false
	}
	return true
}
func (this *FleetBondDevicesListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetBondDevicesListType)
	if !ok {
		that2, ok := that.(FleetBondDevicesListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.BondDevices) != len(that1.BondDevices) {
		return false
	}
	for i := range this.BondDevices {
		if !this.BondDevices[i].Equal(that1.BondDevices[i]) {
			return false
		}
	}
	return true
}
func (this *FleetStorageStaticRoutesListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageStaticRoutesListType)
	if !ok {
		that2, ok := that.(FleetStorageStaticRoutesListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.StorageRoutes) != len(that1.StorageRoutes) {
		return false
	}
	for i := range this.StorageRoutes {
		if !this.StorageRoutes[i].Equal(that1.StorageRoutes[i]) {
			return false
		}
	}
	return true
}
func (this *VGPUConfiguration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VGPUConfiguration)
	if !ok {
		that2, ok := that.(VGPUConfiguration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerAddress != that1.ServerAddress {
		return false
	}
	if this.ServerPort != that1.ServerPort {
		return false
	}
	if this.FeatureType != that1.FeatureType {
		return false
	}
	return true
}
func (this *VMConfiguration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VMConfiguration)
	if !ok {
		that2, ok := that.(VMConfiguration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *BGPConfiguration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BGPConfiguration)
	if !ok {
		that2, ok := that.(BGPConfiguration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Asn != that1.Asn {
		return false
	}
	if len(this.Peers) != len(that1.Peers) {
		return false
	}
	for i := range this.Peers {
		if !this.Peers[i].Equal(that1.Peers[i]) {
			return false
		}
	}
	return true
}
func (this *LocalControlPlaneType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalControlPlaneType)
	if !ok {
		that2, ok := that.(LocalControlPlaneType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.NetworkChoice == nil {
		if this.NetworkChoice != nil {
			return false
		}
	} else if this.NetworkChoice == nil {
		return false
	} else if !this.NetworkChoice.Equal(that1.NetworkChoice) {
		return false
	}
	if !this.BgpConfig.Equal(that1.BgpConfig) {
		return false
	}
	return true
}
func (this *LocalControlPlaneType_InsideVn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalControlPlaneType_InsideVn)
	if !ok {
		that2, ok := that.(LocalControlPlaneType_InsideVn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InsideVn.Equal(that1.InsideVn) {
		return false
	}
	return true
}
func (this *LocalControlPlaneType_OutsideVn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalControlPlaneType_OutsideVn)
	if !ok {
		that2, ok := that.(LocalControlPlaneType_OutsideVn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OutsideVn.Equal(that1.OutsideVn) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FleetLabel != that1.FleetLabel {
		return false
	}
	if this.VolterraSoftwareVersion != that1.VolterraSoftwareVersion {
		return false
	}
	if len(this.Devices) != len(that1.Devices) {
		return false
	}
	for i := range this.Devices {
		if !this.Devices[i].Equal(that1.Devices[i]) {
			return false
		}
	}
	if len(this.NetworkConnectors) != len(that1.NetworkConnectors) {
		return false
	}
	for i := range this.NetworkConnectors {
		if !this.NetworkConnectors[i].Equal(that1.NetworkConnectors[i]) {
			return false
		}
	}
	if len(this.NetworkFirewall) != len(that1.NetworkFirewall) {
		return false
	}
	for i := range this.NetworkFirewall {
		if !this.NetworkFirewall[i].Equal(that1.NetworkFirewall[i]) {
			return false
		}
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	if len(this.OutsideVirtualNetwork) != len(that1.OutsideVirtualNetwork) {
		return false
	}
	for i := range this.OutsideVirtualNetwork {
		if !this.OutsideVirtualNetwork[i].Equal(that1.OutsideVirtualNetwork[i]) {
			return false
		}
	}
	if len(this.InsideVirtualNetwork) != len(that1.InsideVirtualNetwork) {
		return false
	}
	for i := range this.InsideVirtualNetwork {
		if !this.InsideVirtualNetwork[i].Equal(that1.InsideVirtualNetwork[i]) {
			return false
		}
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	if that1.BondChoice == nil {
		if this.BondChoice != nil {
			return false
		}
	} else if this.BondChoice == nil {
		return false
	} else if !this.BondChoice.Equal(that1.BondChoice) {
		return false
	}
	if that1.StorageInterfaceChoice == nil {
		if this.StorageInterfaceChoice != nil {
			return false
		}
	} else if this.StorageInterfaceChoice == nil {
		return false
	} else if !this.StorageInterfaceChoice.Equal(that1.StorageInterfaceChoice) {
		return false
	}
	if that1.StorageDeviceChoice == nil {
		if this.StorageDeviceChoice != nil {
			return false
		}
	} else if this.StorageDeviceChoice == nil {
		return false
	} else if !this.StorageDeviceChoice.Equal(that1.StorageDeviceChoice) {
		return false
	}
	if that1.StorageClassChoice == nil {
		if this.StorageClassChoice != nil {
			return false
		}
	} else if this.StorageClassChoice == nil {
		return false
	} else if !this.StorageClassChoice.Equal(that1.StorageClassChoice) {
		return false
	}
	if that1.DcClusterGroupChoice == nil {
		if this.DcClusterGroupChoice != nil {
			return false
		}
	} else if this.DcClusterGroupChoice == nil {
		return false
	} else if !this.DcClusterGroupChoice.Equal(that1.DcClusterGroupChoice) {
		return false
	}
	if that1.GpuChoice == nil {
		if this.GpuChoice != nil {
			return false
		}
	} else if this.GpuChoice == nil {
		return false
	} else if !this.GpuChoice.Equal(that1.GpuChoice) {
		return false
	}
	if that1.VmChoice == nil {
		if this.VmChoice != nil {
			return false
		}
	} else if this.VmChoice == nil {
		return false
	} else if !this.VmChoice.Equal(that1.VmChoice) {
		return false
	}
	if this.EtcdClusterNetwork != that1.EtcdClusterNetwork {
		return false
	}
	if that1.StorageStaticRoutesChoice == nil {
		if this.StorageStaticRoutesChoice != nil {
			return false
		}
	} else if this.StorageStaticRoutesChoice == nil {
		return false
	} else if !this.StorageStaticRoutesChoice.Equal(that1.StorageStaticRoutesChoice) {
		return false
	}
	if this.EnableDefaultFleetConfigDownload != that1.EnableDefaultFleetConfigDownload {
		return false
	}
	if this.FleetType != that1.FleetType {
		return false
	}
	if len(this.SingleSite) != len(that1.SingleSite) {
		return false
	}
	for i := range this.SingleSite {
		if !this.SingleSite[i].Equal(that1.SingleSite[i]) {
			return false
		}
	}
	if that1.LogsReceiverChoice == nil {
		if this.LogsReceiverChoice != nil {
			return false
		}
	} else if this.LogsReceiverChoice == nil {
		return false
	} else if !this.LogsReceiverChoice.Equal(that1.LogsReceiverChoice) {
		return false
	}
	if that1.UsbPolicyChoice == nil {
		if this.UsbPolicyChoice != nil {
			return false
		}
	} else if this.UsbPolicyChoice == nil {
		return false
	} else if !this.UsbPolicyChoice.Equal(that1.UsbPolicyChoice) {
		return false
	}
	if !this.K8SCluster.Equal(that1.K8SCluster) {
		return false
	}
	if !this.LocalControlPlane.Equal(that1.LocalControlPlane) {
		return false
	}
	if that1.FlowExporterChoice == nil {
		if this.FlowExporterChoice != nil {
			return false
		}
	} else if this.FlowExporterChoice == nil {
		return false
	} else if !this.FlowExporterChoice.Equal(that1.FlowExporterChoice) {
		return false
	}
	if !this.ViewInternal.Equal(that1.ViewInternal) {
		return false
	}
	if len(this.GeneratedYamls) != len(that1.GeneratedYamls) {
		return false
	}
	for i := range this.GeneratedYamls {
		if this.GeneratedYamls[i] != that1.GeneratedYamls[i] {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType_InterfaceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_InterfaceList)
	if !ok {
		that2, ok := that.(GlobalSpecType_InterfaceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InterfaceList.Equal(that1.InterfaceList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DefaultInterfaces) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DefaultInterfaces)
	if !ok {
		that2, ok := that.(GlobalSpecType_DefaultInterfaces)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultInterfaces.Equal(that1.DefaultInterfaces) {
		return false
	}
	return true
}
func (this *GlobalSpecType_LegacyDevices) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_LegacyDevices)
	if !ok {
		that2, ok := that.(GlobalSpecType_LegacyDevices)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyDevices.Equal(that1.LegacyDevices) {
		return false
	}
	return true
}
func (this *GlobalSpecType_NoBondDevices) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_NoBondDevices)
	if !ok {
		that2, ok := that.(GlobalSpecType_NoBondDevices)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoBondDevices.Equal(that1.NoBondDevices) {
		return false
	}
	return true
}
func (this *GlobalSpecType_BondDeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_BondDeviceList)
	if !ok {
		that2, ok := that.(GlobalSpecType_BondDeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BondDeviceList.Equal(that1.BondDeviceList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_NoStorageInterfaces) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_NoStorageInterfaces)
	if !ok {
		that2, ok := that.(GlobalSpecType_NoStorageInterfaces)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageInterfaces.Equal(that1.NoStorageInterfaces) {
		return false
	}
	return true
}
func (this *GlobalSpecType_StorageInterfaceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_StorageInterfaceList)
	if !ok {
		that2, ok := that.(GlobalSpecType_StorageInterfaceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageInterfaceList.Equal(that1.StorageInterfaceList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_NoStorageDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_NoStorageDevice)
	if !ok {
		that2, ok := that.(GlobalSpecType_NoStorageDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageDevice.Equal(that1.NoStorageDevice) {
		return false
	}
	return true
}
func (this *GlobalSpecType_StorageDeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_StorageDeviceList)
	if !ok {
		that2, ok := that.(GlobalSpecType_StorageDeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageDeviceList.Equal(that1.StorageDeviceList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DefaultStorageClass) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DefaultStorageClass)
	if !ok {
		that2, ok := that.(GlobalSpecType_DefaultStorageClass)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultStorageClass.Equal(that1.DefaultStorageClass) {
		return false
	}
	return true
}
func (this *GlobalSpecType_StorageClassList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_StorageClassList)
	if !ok {
		that2, ok := that.(GlobalSpecType_StorageClassList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageClassList.Equal(that1.StorageClassList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_NoDcClusterGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_NoDcClusterGroup)
	if !ok {
		that2, ok := that.(GlobalSpecType_NoDcClusterGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoDcClusterGroup.Equal(that1.NoDcClusterGroup) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DcClusterGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DcClusterGroup)
	if !ok {
		that2, ok := that.(GlobalSpecType_DcClusterGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DcClusterGroup.Equal(that1.DcClusterGroup) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DcClusterGroupInside) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DcClusterGroupInside)
	if !ok {
		that2, ok := that.(GlobalSpecType_DcClusterGroupInside)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DcClusterGroupInside.Equal(that1.DcClusterGroupInside) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DisableGpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DisableGpu)
	if !ok {
		that2, ok := that.(GlobalSpecType_DisableGpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableGpu.Equal(that1.DisableGpu) {
		return false
	}
	return true
}
func (this *GlobalSpecType_EnableGpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_EnableGpu)
	if !ok {
		that2, ok := that.(GlobalSpecType_EnableGpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableGpu.Equal(that1.EnableGpu) {
		return false
	}
	return true
}
func (this *GlobalSpecType_EnableVgpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_EnableVgpu)
	if !ok {
		that2, ok := that.(GlobalSpecType_EnableVgpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableVgpu.Equal(that1.EnableVgpu) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DisableVm) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DisableVm)
	if !ok {
		that2, ok := that.(GlobalSpecType_DisableVm)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableVm.Equal(that1.DisableVm) {
		return false
	}
	return true
}
func (this *GlobalSpecType_EnableVm) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_EnableVm)
	if !ok {
		that2, ok := that.(GlobalSpecType_EnableVm)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableVm.Equal(that1.EnableVm) {
		return false
	}
	return true
}
func (this *GlobalSpecType_NoStorageStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_NoStorageStaticRoutes)
	if !ok {
		that2, ok := that.(GlobalSpecType_NoStorageStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageStaticRoutes.Equal(that1.NoStorageStaticRoutes) {
		return false
	}
	return true
}
func (this *GlobalSpecType_StorageStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_StorageStaticRoutes)
	if !ok {
		that2, ok := that.(GlobalSpecType_StorageStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageStaticRoutes.Equal(that1.StorageStaticRoutes) {
		return false
	}
	return true
}
func (this *GlobalSpecType_LogsStreamingDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_LogsStreamingDisabled)
	if !ok {
		that2, ok := that.(GlobalSpecType_LogsStreamingDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogsStreamingDisabled.Equal(that1.LogsStreamingDisabled) {
		return false
	}
	return true
}
func (this *GlobalSpecType_LogReceiver) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_LogReceiver)
	if !ok {
		that2, ok := that.(GlobalSpecType_LogReceiver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogReceiver.Equal(that1.LogReceiver) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DenyAllUsb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DenyAllUsb)
	if !ok {
		that2, ok := that.(GlobalSpecType_DenyAllUsb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyAllUsb.Equal(that1.DenyAllUsb) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AllowAllUsb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AllowAllUsb)
	if !ok {
		that2, ok := that.(GlobalSpecType_AllowAllUsb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowAllUsb.Equal(that1.AllowAllUsb) {
		return false
	}
	return true
}
func (this *GlobalSpecType_UsbPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_UsbPolicy)
	if !ok {
		that2, ok := that.(GlobalSpecType_UsbPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UsbPolicy.Equal(that1.UsbPolicy) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DisableFlowExport) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DisableFlowExport)
	if !ok {
		that2, ok := that.(GlobalSpecType_DisableFlowExport)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableFlowExport.Equal(that1.DisableFlowExport) {
		return false
	}
	return true
}
func (this *GlobalSpecType_EnableFlowExport) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_EnableFlowExport)
	if !ok {
		that2, ok := that.(GlobalSpecType_EnableFlowExport)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableFlowExport.Equal(that1.EnableFlowExport) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FleetLabel != that1.FleetLabel {
		return false
	}
	if this.VolterraSoftwareVersion != that1.VolterraSoftwareVersion {
		return false
	}
	if len(this.NetworkConnectors) != len(that1.NetworkConnectors) {
		return false
	}
	for i := range this.NetworkConnectors {
		if !this.NetworkConnectors[i].Equal(that1.NetworkConnectors[i]) {
			return false
		}
	}
	if len(this.NetworkFirewall) != len(that1.NetworkFirewall) {
		return false
	}
	for i := range this.NetworkFirewall {
		if !this.NetworkFirewall[i].Equal(that1.NetworkFirewall[i]) {
			return false
		}
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	if len(this.OutsideVirtualNetwork) != len(that1.OutsideVirtualNetwork) {
		return false
	}
	for i := range this.OutsideVirtualNetwork {
		if !this.OutsideVirtualNetwork[i].Equal(that1.OutsideVirtualNetwork[i]) {
			return false
		}
	}
	if len(this.InsideVirtualNetwork) != len(that1.InsideVirtualNetwork) {
		return false
	}
	for i := range this.InsideVirtualNetwork {
		if !this.InsideVirtualNetwork[i].Equal(that1.InsideVirtualNetwork[i]) {
			return false
		}
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	if that1.BondChoice == nil {
		if this.BondChoice != nil {
			return false
		}
	} else if this.BondChoice == nil {
		return false
	} else if !this.BondChoice.Equal(that1.BondChoice) {
		return false
	}
	if that1.StorageInterfaceChoice == nil {
		if this.StorageInterfaceChoice != nil {
			return false
		}
	} else if this.StorageInterfaceChoice == nil {
		return false
	} else if !this.StorageInterfaceChoice.Equal(that1.StorageInterfaceChoice) {
		return false
	}
	if that1.StorageDeviceChoice == nil {
		if this.StorageDeviceChoice != nil {
			return false
		}
	} else if this.StorageDeviceChoice == nil {
		return false
	} else if !this.StorageDeviceChoice.Equal(that1.StorageDeviceChoice) {
		return false
	}
	if that1.StorageClassChoice == nil {
		if this.StorageClassChoice != nil {
			return false
		}
	} else if this.StorageClassChoice == nil {
		return false
	} else if !this.StorageClassChoice.Equal(that1.StorageClassChoice) {
		return false
	}
	if that1.DcClusterGroupChoice == nil {
		if this.DcClusterGroupChoice != nil {
			return false
		}
	} else if this.DcClusterGroupChoice == nil {
		return false
	} else if !this.DcClusterGroupChoice.Equal(that1.DcClusterGroupChoice) {
		return false
	}
	if that1.GpuChoice == nil {
		if this.GpuChoice != nil {
			return false
		}
	} else if this.GpuChoice == nil {
		return false
	} else if !this.GpuChoice.Equal(that1.GpuChoice) {
		return false
	}
	if that1.StorageStaticRoutesChoice == nil {
		if this.StorageStaticRoutesChoice != nil {
			return false
		}
	} else if this.StorageStaticRoutesChoice == nil {
		return false
	} else if !this.StorageStaticRoutesChoice.Equal(that1.StorageStaticRoutesChoice) {
		return false
	}
	if this.EnableDefaultFleetConfigDownload != that1.EnableDefaultFleetConfigDownload {
		return false
	}
	if that1.LogsReceiverChoice == nil {
		if this.LogsReceiverChoice != nil {
			return false
		}
	} else if this.LogsReceiverChoice == nil {
		return false
	} else if !this.LogsReceiverChoice.Equal(that1.LogsReceiverChoice) {
		return false
	}
	if that1.UsbPolicyChoice == nil {
		if this.UsbPolicyChoice != nil {
			return false
		}
	} else if this.UsbPolicyChoice == nil {
		return false
	} else if !this.UsbPolicyChoice.Equal(that1.UsbPolicyChoice) {
		return false
	}
	if that1.VmChoice == nil {
		if this.VmChoice != nil {
			return false
		}
	} else if this.VmChoice == nil {
		return false
	} else if !this.VmChoice.Equal(that1.VmChoice) {
		return false
	}
	return true
}
func (this *CreateSpecType_InterfaceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_InterfaceList)
	if !ok {
		that2, ok := that.(CreateSpecType_InterfaceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InterfaceList.Equal(that1.InterfaceList) {
		return false
	}
	return true
}
func (this *CreateSpecType_DefaultConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DefaultConfig)
	if !ok {
		that2, ok := that.(CreateSpecType_DefaultConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultConfig.Equal(that1.DefaultConfig) {
		return false
	}
	return true
}
func (this *CreateSpecType_DeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DeviceList)
	if !ok {
		that2, ok := that.(CreateSpecType_DeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeviceList.Equal(that1.DeviceList) {
		return false
	}
	return true
}
func (this *CreateSpecType_NoBondDevices) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_NoBondDevices)
	if !ok {
		that2, ok := that.(CreateSpecType_NoBondDevices)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoBondDevices.Equal(that1.NoBondDevices) {
		return false
	}
	return true
}
func (this *CreateSpecType_BondDeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_BondDeviceList)
	if !ok {
		that2, ok := that.(CreateSpecType_BondDeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BondDeviceList.Equal(that1.BondDeviceList) {
		return false
	}
	return true
}
func (this *CreateSpecType_NoStorageInterfaces) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_NoStorageInterfaces)
	if !ok {
		that2, ok := that.(CreateSpecType_NoStorageInterfaces)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageInterfaces.Equal(that1.NoStorageInterfaces) {
		return false
	}
	return true
}
func (this *CreateSpecType_StorageInterfaceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_StorageInterfaceList)
	if !ok {
		that2, ok := that.(CreateSpecType_StorageInterfaceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageInterfaceList.Equal(that1.StorageInterfaceList) {
		return false
	}
	return true
}
func (this *CreateSpecType_NoStorageDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_NoStorageDevice)
	if !ok {
		that2, ok := that.(CreateSpecType_NoStorageDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageDevice.Equal(that1.NoStorageDevice) {
		return false
	}
	return true
}
func (this *CreateSpecType_StorageDeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_StorageDeviceList)
	if !ok {
		that2, ok := that.(CreateSpecType_StorageDeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageDeviceList.Equal(that1.StorageDeviceList) {
		return false
	}
	return true
}
func (this *CreateSpecType_DefaultStorageClass) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DefaultStorageClass)
	if !ok {
		that2, ok := that.(CreateSpecType_DefaultStorageClass)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultStorageClass.Equal(that1.DefaultStorageClass) {
		return false
	}
	return true
}
func (this *CreateSpecType_StorageClassList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_StorageClassList)
	if !ok {
		that2, ok := that.(CreateSpecType_StorageClassList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageClassList.Equal(that1.StorageClassList) {
		return false
	}
	return true
}
func (this *CreateSpecType_NoDcClusterGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_NoDcClusterGroup)
	if !ok {
		that2, ok := that.(CreateSpecType_NoDcClusterGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoDcClusterGroup.Equal(that1.NoDcClusterGroup) {
		return false
	}
	return true
}
func (this *CreateSpecType_DcClusterGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DcClusterGroup)
	if !ok {
		that2, ok := that.(CreateSpecType_DcClusterGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DcClusterGroup.Equal(that1.DcClusterGroup) {
		return false
	}
	return true
}
func (this *CreateSpecType_DcClusterGroupInside) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DcClusterGroupInside)
	if !ok {
		that2, ok := that.(CreateSpecType_DcClusterGroupInside)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DcClusterGroupInside.Equal(that1.DcClusterGroupInside) {
		return false
	}
	return true
}
func (this *CreateSpecType_DisableGpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DisableGpu)
	if !ok {
		that2, ok := that.(CreateSpecType_DisableGpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableGpu.Equal(that1.DisableGpu) {
		return false
	}
	return true
}
func (this *CreateSpecType_EnableGpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_EnableGpu)
	if !ok {
		that2, ok := that.(CreateSpecType_EnableGpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableGpu.Equal(that1.EnableGpu) {
		return false
	}
	return true
}
func (this *CreateSpecType_EnableVgpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_EnableVgpu)
	if !ok {
		that2, ok := that.(CreateSpecType_EnableVgpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableVgpu.Equal(that1.EnableVgpu) {
		return false
	}
	return true
}
func (this *CreateSpecType_NoStorageStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_NoStorageStaticRoutes)
	if !ok {
		that2, ok := that.(CreateSpecType_NoStorageStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageStaticRoutes.Equal(that1.NoStorageStaticRoutes) {
		return false
	}
	return true
}
func (this *CreateSpecType_StorageStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_StorageStaticRoutes)
	if !ok {
		that2, ok := that.(CreateSpecType_StorageStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageStaticRoutes.Equal(that1.StorageStaticRoutes) {
		return false
	}
	return true
}
func (this *CreateSpecType_LogsStreamingDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_LogsStreamingDisabled)
	if !ok {
		that2, ok := that.(CreateSpecType_LogsStreamingDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogsStreamingDisabled.Equal(that1.LogsStreamingDisabled) {
		return false
	}
	return true
}
func (this *CreateSpecType_LogReceiver) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_LogReceiver)
	if !ok {
		that2, ok := that.(CreateSpecType_LogReceiver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogReceiver.Equal(that1.LogReceiver) {
		return false
	}
	return true
}
func (this *CreateSpecType_DenyAllUsb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DenyAllUsb)
	if !ok {
		that2, ok := that.(CreateSpecType_DenyAllUsb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyAllUsb.Equal(that1.DenyAllUsb) {
		return false
	}
	return true
}
func (this *CreateSpecType_AllowAllUsb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AllowAllUsb)
	if !ok {
		that2, ok := that.(CreateSpecType_AllowAllUsb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowAllUsb.Equal(that1.AllowAllUsb) {
		return false
	}
	return true
}
func (this *CreateSpecType_UsbPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_UsbPolicy)
	if !ok {
		that2, ok := that.(CreateSpecType_UsbPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UsbPolicy.Equal(that1.UsbPolicy) {
		return false
	}
	return true
}
func (this *CreateSpecType_DisableVm) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DisableVm)
	if !ok {
		that2, ok := that.(CreateSpecType_DisableVm)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableVm.Equal(that1.DisableVm) {
		return false
	}
	return true
}
func (this *CreateSpecType_EnableVm) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_EnableVm)
	if !ok {
		that2, ok := that.(CreateSpecType_EnableVm)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableVm.Equal(that1.EnableVm) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VolterraSoftwareVersion != that1.VolterraSoftwareVersion {
		return false
	}
	if len(this.NetworkConnectors) != len(that1.NetworkConnectors) {
		return false
	}
	for i := range this.NetworkConnectors {
		if !this.NetworkConnectors[i].Equal(that1.NetworkConnectors[i]) {
			return false
		}
	}
	if len(this.NetworkFirewall) != len(that1.NetworkFirewall) {
		return false
	}
	for i := range this.NetworkFirewall {
		if !this.NetworkFirewall[i].Equal(that1.NetworkFirewall[i]) {
			return false
		}
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	if len(this.OutsideVirtualNetwork) != len(that1.OutsideVirtualNetwork) {
		return false
	}
	for i := range this.OutsideVirtualNetwork {
		if !this.OutsideVirtualNetwork[i].Equal(that1.OutsideVirtualNetwork[i]) {
			return false
		}
	}
	if len(this.InsideVirtualNetwork) != len(that1.InsideVirtualNetwork) {
		return false
	}
	for i := range this.InsideVirtualNetwork {
		if !this.InsideVirtualNetwork[i].Equal(that1.InsideVirtualNetwork[i]) {
			return false
		}
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	if that1.BondChoice == nil {
		if this.BondChoice != nil {
			return false
		}
	} else if this.BondChoice == nil {
		return false
	} else if !this.BondChoice.Equal(that1.BondChoice) {
		return false
	}
	if that1.StorageInterfaceChoice == nil {
		if this.StorageInterfaceChoice != nil {
			return false
		}
	} else if this.StorageInterfaceChoice == nil {
		return false
	} else if !this.StorageInterfaceChoice.Equal(that1.StorageInterfaceChoice) {
		return false
	}
	if that1.StorageDeviceChoice == nil {
		if this.StorageDeviceChoice != nil {
			return false
		}
	} else if this.StorageDeviceChoice == nil {
		return false
	} else if !this.StorageDeviceChoice.Equal(that1.StorageDeviceChoice) {
		return false
	}
	if that1.StorageClassChoice == nil {
		if this.StorageClassChoice != nil {
			return false
		}
	} else if this.StorageClassChoice == nil {
		return false
	} else if !this.StorageClassChoice.Equal(that1.StorageClassChoice) {
		return false
	}
	if that1.DcClusterGroupChoice == nil {
		if this.DcClusterGroupChoice != nil {
			return false
		}
	} else if this.DcClusterGroupChoice == nil {
		return false
	} else if !this.DcClusterGroupChoice.Equal(that1.DcClusterGroupChoice) {
		return false
	}
	if that1.GpuChoice == nil {
		if this.GpuChoice != nil {
			return false
		}
	} else if this.GpuChoice == nil {
		return false
	} else if !this.GpuChoice.Equal(that1.GpuChoice) {
		return false
	}
	if that1.StorageStaticRoutesChoice == nil {
		if this.StorageStaticRoutesChoice != nil {
			return false
		}
	} else if this.StorageStaticRoutesChoice == nil {
		return false
	} else if !this.StorageStaticRoutesChoice.Equal(that1.StorageStaticRoutesChoice) {
		return false
	}
	if this.EnableDefaultFleetConfigDownload != that1.EnableDefaultFleetConfigDownload {
		return false
	}
	if that1.LogsReceiverChoice == nil {
		if this.LogsReceiverChoice != nil {
			return false
		}
	} else if this.LogsReceiverChoice == nil {
		return false
	} else if !this.LogsReceiverChoice.Equal(that1.LogsReceiverChoice) {
		return false
	}
	if that1.UsbPolicyChoice == nil {
		if this.UsbPolicyChoice != nil {
			return false
		}
	} else if this.UsbPolicyChoice == nil {
		return false
	} else if !this.UsbPolicyChoice.Equal(that1.UsbPolicyChoice) {
		return false
	}
	if that1.VmChoice == nil {
		if this.VmChoice != nil {
			return false
		}
	} else if this.VmChoice == nil {
		return false
	} else if !this.VmChoice.Equal(that1.VmChoice) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_InterfaceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_InterfaceList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_InterfaceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InterfaceList.Equal(that1.InterfaceList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DefaultConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DefaultConfig)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DefaultConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultConfig.Equal(that1.DefaultConfig) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DeviceList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeviceList.Equal(that1.DeviceList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_NoBondDevices) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_NoBondDevices)
	if !ok {
		that2, ok := that.(ReplaceSpecType_NoBondDevices)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoBondDevices.Equal(that1.NoBondDevices) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_BondDeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_BondDeviceList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_BondDeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BondDeviceList.Equal(that1.BondDeviceList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_NoStorageInterfaces) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_NoStorageInterfaces)
	if !ok {
		that2, ok := that.(ReplaceSpecType_NoStorageInterfaces)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageInterfaces.Equal(that1.NoStorageInterfaces) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_StorageInterfaceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_StorageInterfaceList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_StorageInterfaceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageInterfaceList.Equal(that1.StorageInterfaceList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_NoStorageDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_NoStorageDevice)
	if !ok {
		that2, ok := that.(ReplaceSpecType_NoStorageDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageDevice.Equal(that1.NoStorageDevice) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_StorageDeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_StorageDeviceList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_StorageDeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageDeviceList.Equal(that1.StorageDeviceList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DefaultStorageClass) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DefaultStorageClass)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DefaultStorageClass)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultStorageClass.Equal(that1.DefaultStorageClass) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_StorageClassList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_StorageClassList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_StorageClassList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageClassList.Equal(that1.StorageClassList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_NoDcClusterGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_NoDcClusterGroup)
	if !ok {
		that2, ok := that.(ReplaceSpecType_NoDcClusterGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoDcClusterGroup.Equal(that1.NoDcClusterGroup) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DcClusterGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DcClusterGroup)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DcClusterGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DcClusterGroup.Equal(that1.DcClusterGroup) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DcClusterGroupInside) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DcClusterGroupInside)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DcClusterGroupInside)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DcClusterGroupInside.Equal(that1.DcClusterGroupInside) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DisableGpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DisableGpu)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DisableGpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableGpu.Equal(that1.DisableGpu) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_EnableGpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_EnableGpu)
	if !ok {
		that2, ok := that.(ReplaceSpecType_EnableGpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableGpu.Equal(that1.EnableGpu) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_EnableVgpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_EnableVgpu)
	if !ok {
		that2, ok := that.(ReplaceSpecType_EnableVgpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableVgpu.Equal(that1.EnableVgpu) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_NoStorageStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_NoStorageStaticRoutes)
	if !ok {
		that2, ok := that.(ReplaceSpecType_NoStorageStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageStaticRoutes.Equal(that1.NoStorageStaticRoutes) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_StorageStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_StorageStaticRoutes)
	if !ok {
		that2, ok := that.(ReplaceSpecType_StorageStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageStaticRoutes.Equal(that1.StorageStaticRoutes) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_LogsStreamingDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_LogsStreamingDisabled)
	if !ok {
		that2, ok := that.(ReplaceSpecType_LogsStreamingDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogsStreamingDisabled.Equal(that1.LogsStreamingDisabled) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_LogReceiver) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_LogReceiver)
	if !ok {
		that2, ok := that.(ReplaceSpecType_LogReceiver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogReceiver.Equal(that1.LogReceiver) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DenyAllUsb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DenyAllUsb)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DenyAllUsb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyAllUsb.Equal(that1.DenyAllUsb) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AllowAllUsb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AllowAllUsb)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AllowAllUsb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowAllUsb.Equal(that1.AllowAllUsb) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_UsbPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_UsbPolicy)
	if !ok {
		that2, ok := that.(ReplaceSpecType_UsbPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UsbPolicy.Equal(that1.UsbPolicy) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DisableVm) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DisableVm)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DisableVm)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableVm.Equal(that1.DisableVm) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_EnableVm) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_EnableVm)
	if !ok {
		that2, ok := that.(ReplaceSpecType_EnableVm)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableVm.Equal(that1.EnableVm) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FleetLabel != that1.FleetLabel {
		return false
	}
	if this.VolterraSoftwareVersion != that1.VolterraSoftwareVersion {
		return false
	}
	if len(this.NetworkConnectors) != len(that1.NetworkConnectors) {
		return false
	}
	for i := range this.NetworkConnectors {
		if !this.NetworkConnectors[i].Equal(that1.NetworkConnectors[i]) {
			return false
		}
	}
	if len(this.NetworkFirewall) != len(that1.NetworkFirewall) {
		return false
	}
	for i := range this.NetworkFirewall {
		if !this.NetworkFirewall[i].Equal(that1.NetworkFirewall[i]) {
			return false
		}
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	if len(this.OutsideVirtualNetwork) != len(that1.OutsideVirtualNetwork) {
		return false
	}
	for i := range this.OutsideVirtualNetwork {
		if !this.OutsideVirtualNetwork[i].Equal(that1.OutsideVirtualNetwork[i]) {
			return false
		}
	}
	if len(this.InsideVirtualNetwork) != len(that1.InsideVirtualNetwork) {
		return false
	}
	for i := range this.InsideVirtualNetwork {
		if !this.InsideVirtualNetwork[i].Equal(that1.InsideVirtualNetwork[i]) {
			return false
		}
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	if that1.BondChoice == nil {
		if this.BondChoice != nil {
			return false
		}
	} else if this.BondChoice == nil {
		return false
	} else if !this.BondChoice.Equal(that1.BondChoice) {
		return false
	}
	if that1.StorageInterfaceChoice == nil {
		if this.StorageInterfaceChoice != nil {
			return false
		}
	} else if this.StorageInterfaceChoice == nil {
		return false
	} else if !this.StorageInterfaceChoice.Equal(that1.StorageInterfaceChoice) {
		return false
	}
	if that1.StorageDeviceChoice == nil {
		if this.StorageDeviceChoice != nil {
			return false
		}
	} else if this.StorageDeviceChoice == nil {
		return false
	} else if !this.StorageDeviceChoice.Equal(that1.StorageDeviceChoice) {
		return false
	}
	if that1.StorageClassChoice == nil {
		if this.StorageClassChoice != nil {
			return false
		}
	} else if this.StorageClassChoice == nil {
		return false
	} else if !this.StorageClassChoice.Equal(that1.StorageClassChoice) {
		return false
	}
	if that1.DcClusterGroupChoice == nil {
		if this.DcClusterGroupChoice != nil {
			return false
		}
	} else if this.DcClusterGroupChoice == nil {
		return false
	} else if !this.DcClusterGroupChoice.Equal(that1.DcClusterGroupChoice) {
		return false
	}
	if that1.GpuChoice == nil {
		if this.GpuChoice != nil {
			return false
		}
	} else if this.GpuChoice == nil {
		return false
	} else if !this.GpuChoice.Equal(that1.GpuChoice) {
		return false
	}
	if that1.StorageStaticRoutesChoice == nil {
		if this.StorageStaticRoutesChoice != nil {
			return false
		}
	} else if this.StorageStaticRoutesChoice == nil {
		return false
	} else if !this.StorageStaticRoutesChoice.Equal(that1.StorageStaticRoutesChoice) {
		return false
	}
	if this.EnableDefaultFleetConfigDownload != that1.EnableDefaultFleetConfigDownload {
		return false
	}
	if that1.LogsReceiverChoice == nil {
		if this.LogsReceiverChoice != nil {
			return false
		}
	} else if this.LogsReceiverChoice == nil {
		return false
	} else if !this.LogsReceiverChoice.Equal(that1.LogsReceiverChoice) {
		return false
	}
	if that1.UsbPolicyChoice == nil {
		if this.UsbPolicyChoice != nil {
			return false
		}
	} else if this.UsbPolicyChoice == nil {
		return false
	} else if !this.UsbPolicyChoice.Equal(that1.UsbPolicyChoice) {
		return false
	}
	if that1.VmChoice == nil {
		if this.VmChoice != nil {
			return false
		}
	} else if this.VmChoice == nil {
		return false
	} else if !this.VmChoice.Equal(that1.VmChoice) {
		return false
	}
	return true
}
func (this *GetSpecType_InterfaceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_InterfaceList)
	if !ok {
		that2, ok := that.(GetSpecType_InterfaceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InterfaceList.Equal(that1.InterfaceList) {
		return false
	}
	return true
}
func (this *GetSpecType_DefaultConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DefaultConfig)
	if !ok {
		that2, ok := that.(GetSpecType_DefaultConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultConfig.Equal(that1.DefaultConfig) {
		return false
	}
	return true
}
func (this *GetSpecType_DeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DeviceList)
	if !ok {
		that2, ok := that.(GetSpecType_DeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeviceList.Equal(that1.DeviceList) {
		return false
	}
	return true
}
func (this *GetSpecType_NoBondDevices) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_NoBondDevices)
	if !ok {
		that2, ok := that.(GetSpecType_NoBondDevices)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoBondDevices.Equal(that1.NoBondDevices) {
		return false
	}
	return true
}
func (this *GetSpecType_BondDeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_BondDeviceList)
	if !ok {
		that2, ok := that.(GetSpecType_BondDeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BondDeviceList.Equal(that1.BondDeviceList) {
		return false
	}
	return true
}
func (this *GetSpecType_NoStorageInterfaces) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_NoStorageInterfaces)
	if !ok {
		that2, ok := that.(GetSpecType_NoStorageInterfaces)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageInterfaces.Equal(that1.NoStorageInterfaces) {
		return false
	}
	return true
}
func (this *GetSpecType_StorageInterfaceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_StorageInterfaceList)
	if !ok {
		that2, ok := that.(GetSpecType_StorageInterfaceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageInterfaceList.Equal(that1.StorageInterfaceList) {
		return false
	}
	return true
}
func (this *GetSpecType_NoStorageDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_NoStorageDevice)
	if !ok {
		that2, ok := that.(GetSpecType_NoStorageDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageDevice.Equal(that1.NoStorageDevice) {
		return false
	}
	return true
}
func (this *GetSpecType_StorageDeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_StorageDeviceList)
	if !ok {
		that2, ok := that.(GetSpecType_StorageDeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageDeviceList.Equal(that1.StorageDeviceList) {
		return false
	}
	return true
}
func (this *GetSpecType_DefaultStorageClass) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DefaultStorageClass)
	if !ok {
		that2, ok := that.(GetSpecType_DefaultStorageClass)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultStorageClass.Equal(that1.DefaultStorageClass) {
		return false
	}
	return true
}
func (this *GetSpecType_StorageClassList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_StorageClassList)
	if !ok {
		that2, ok := that.(GetSpecType_StorageClassList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageClassList.Equal(that1.StorageClassList) {
		return false
	}
	return true
}
func (this *GetSpecType_NoDcClusterGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_NoDcClusterGroup)
	if !ok {
		that2, ok := that.(GetSpecType_NoDcClusterGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoDcClusterGroup.Equal(that1.NoDcClusterGroup) {
		return false
	}
	return true
}
func (this *GetSpecType_DcClusterGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DcClusterGroup)
	if !ok {
		that2, ok := that.(GetSpecType_DcClusterGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DcClusterGroup.Equal(that1.DcClusterGroup) {
		return false
	}
	return true
}
func (this *GetSpecType_DcClusterGroupInside) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DcClusterGroupInside)
	if !ok {
		that2, ok := that.(GetSpecType_DcClusterGroupInside)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DcClusterGroupInside.Equal(that1.DcClusterGroupInside) {
		return false
	}
	return true
}
func (this *GetSpecType_DisableGpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DisableGpu)
	if !ok {
		that2, ok := that.(GetSpecType_DisableGpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableGpu.Equal(that1.DisableGpu) {
		return false
	}
	return true
}
func (this *GetSpecType_EnableGpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_EnableGpu)
	if !ok {
		that2, ok := that.(GetSpecType_EnableGpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableGpu.Equal(that1.EnableGpu) {
		return false
	}
	return true
}
func (this *GetSpecType_EnableVgpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_EnableVgpu)
	if !ok {
		that2, ok := that.(GetSpecType_EnableVgpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableVgpu.Equal(that1.EnableVgpu) {
		return false
	}
	return true
}
func (this *GetSpecType_NoStorageStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_NoStorageStaticRoutes)
	if !ok {
		that2, ok := that.(GetSpecType_NoStorageStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageStaticRoutes.Equal(that1.NoStorageStaticRoutes) {
		return false
	}
	return true
}
func (this *GetSpecType_StorageStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_StorageStaticRoutes)
	if !ok {
		that2, ok := that.(GetSpecType_StorageStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageStaticRoutes.Equal(that1.StorageStaticRoutes) {
		return false
	}
	return true
}
func (this *GetSpecType_LogsStreamingDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_LogsStreamingDisabled)
	if !ok {
		that2, ok := that.(GetSpecType_LogsStreamingDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogsStreamingDisabled.Equal(that1.LogsStreamingDisabled) {
		return false
	}
	return true
}
func (this *GetSpecType_LogReceiver) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_LogReceiver)
	if !ok {
		that2, ok := that.(GetSpecType_LogReceiver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogReceiver.Equal(that1.LogReceiver) {
		return false
	}
	return true
}
func (this *GetSpecType_DenyAllUsb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DenyAllUsb)
	if !ok {
		that2, ok := that.(GetSpecType_DenyAllUsb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyAllUsb.Equal(that1.DenyAllUsb) {
		return false
	}
	return true
}
func (this *GetSpecType_AllowAllUsb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AllowAllUsb)
	if !ok {
		that2, ok := that.(GetSpecType_AllowAllUsb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowAllUsb.Equal(that1.AllowAllUsb) {
		return false
	}
	return true
}
func (this *GetSpecType_UsbPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_UsbPolicy)
	if !ok {
		that2, ok := that.(GetSpecType_UsbPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UsbPolicy.Equal(that1.UsbPolicy) {
		return false
	}
	return true
}
func (this *GetSpecType_DisableVm) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DisableVm)
	if !ok {
		that2, ok := that.(GetSpecType_DisableVm)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableVm.Equal(that1.DisableVm) {
		return false
	}
	return true
}
func (this *GetSpecType_EnableVm) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_EnableVm)
	if !ok {
		that2, ok := that.(GetSpecType_EnableVm)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableVm.Equal(that1.EnableVm) {
		return false
	}
	return true
}
func (this *FleetStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStatus)
	if !ok {
		that2, ok := that.(FleetStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AvailableSoftwareVersion != that1.AvailableSoftwareVersion {
		return false
	}
	return true
}
func (this *NetworkingDeviceInstanceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&fleet.NetworkingDeviceInstanceType{")
	if this.Interface != nil {
		s = append(s, "Interface: "+fmt.Sprintf("%#v", this.Interface)+",\n")
	}
	s = append(s, "Use: "+fmt.Sprintf("%#v", this.Use)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GenericDeviceInstanceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&fleet.GenericDeviceInstanceType{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeviceInstanceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&fleet.DeviceInstanceType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Owner: "+fmt.Sprintf("%#v", this.Owner)+",\n")
	if this.DeviceInstance != nil {
		s = append(s, "DeviceInstance: "+fmt.Sprintf("%#v", this.DeviceInstance)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeviceInstanceType_NetworkDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.DeviceInstanceType_NetworkDevice{` +
		`NetworkDevice:` + fmt.Sprintf("%#v", this.NetworkDevice) + `}`}, ", ")
	return s
}
func (this *FleetInterfaceListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&fleet.FleetInterfaceListType{")
	if this.Interfaces != nil {
		s = append(s, "Interfaces: "+fmt.Sprintf("%#v", this.Interfaces)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FleetDeviceListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&fleet.FleetDeviceListType{")
	if this.Devices != nil {
		s = append(s, "Devices: "+fmt.Sprintf("%#v", this.Devices)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDeviceOpenebsEnterpriseType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&fleet.StorageDeviceOpenebsEnterpriseType{")
	if this.MayastorPools != nil {
		s = append(s, "MayastorPools: "+fmt.Sprintf("%#v", this.MayastorPools)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OpenebsMayastorPoolType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&fleet.OpenebsMayastorPoolType{")
	s = append(s, "PoolName: "+fmt.Sprintf("%#v", this.PoolName)+",\n")
	s = append(s, "Node: "+fmt.Sprintf("%#v", this.Node)+",\n")
	s = append(s, "PoolDiskDevices: "+fmt.Sprintf("%#v", this.PoolDiskDevices)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDeviceDellIsilonF800Type) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&fleet.StorageDeviceDellIsilonF800Type{")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	if this.Password != nil {
		s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	}
	if this.HttpsChoice != nil {
		s = append(s, "HttpsChoice: "+fmt.Sprintf("%#v", this.HttpsChoice)+",\n")
	}
	if this.AddressChoice != nil {
		s = append(s, "AddressChoice: "+fmt.Sprintf("%#v", this.AddressChoice)+",\n")
	}
	s = append(s, "ApiServerPort: "+fmt.Sprintf("%#v", this.ApiServerPort)+",\n")
	s = append(s, "IscsiAccessZone: "+fmt.Sprintf("%#v", this.IscsiAccessZone)+",\n")
	s = append(s, "VolumePrefix: "+fmt.Sprintf("%#v", this.VolumePrefix)+",\n")
	s = append(s, "BasePath: "+fmt.Sprintf("%#v", this.BasePath)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDeviceDellIsilonF800Type_SecureNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceDellIsilonF800Type_SecureNetwork{` +
		`SecureNetwork:` + fmt.Sprintf("%#v", this.SecureNetwork) + `}`}, ", ")
	return s
}
func (this *StorageDeviceDellIsilonF800Type_TrustedCaUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceDellIsilonF800Type_TrustedCaUrl{` +
		`TrustedCaUrl:` + fmt.Sprintf("%#v", this.TrustedCaUrl) + `}`}, ", ")
	return s
}
func (this *StorageDeviceDellIsilonF800Type_ApiServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceDellIsilonF800Type_ApiServerName{` +
		`ApiServerName:` + fmt.Sprintf("%#v", this.ApiServerName) + `}`}, ", ")
	return s
}
func (this *StorageDeviceDellIsilonF800Type_ApiServerIpAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceDellIsilonF800Type_ApiServerIpAddress{` +
		`ApiServerIpAddress:` + fmt.Sprintf("%#v", this.ApiServerIpAddress) + `}`}, ", ")
	return s
}
func (this *StorageDeviceHPENimbusStorageAf40Type) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&fleet.StorageDeviceHPENimbusStorageAf40Type{")
	s = append(s, "StorageServerName: "+fmt.Sprintf("%#v", this.StorageServerName)+",\n")
	s = append(s, "StorageServerIpAddress: "+fmt.Sprintf("%#v", this.StorageServerIpAddress)+",\n")
	s = append(s, "ApiServerPort: "+fmt.Sprintf("%#v", this.ApiServerPort)+",\n")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	if this.Password != nil {
		s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	}
	s = append(s, "PerfPolicy: "+fmt.Sprintf("%#v", this.PerfPolicy)+",\n")
	s = append(s, "LimitIops: "+fmt.Sprintf("%#v", this.LimitIops)+",\n")
	s = append(s, "LimitMbps: "+fmt.Sprintf("%#v", this.LimitMbps)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDevicePureStorageServiceOrchestratorType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&fleet.StorageDevicePureStorageServiceOrchestratorType{")
	s = append(s, "ClusterId: "+fmt.Sprintf("%#v", this.ClusterId)+",\n")
	s = append(s, "EnableStorageTopology: "+fmt.Sprintf("%#v", this.EnableStorageTopology)+",\n")
	s = append(s, "EnableStrictTopology: "+fmt.Sprintf("%#v", this.EnableStrictTopology)+",\n")
	if this.Arrays != nil {
		s = append(s, "Arrays: "+fmt.Sprintf("%#v", this.Arrays)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PsoArrayConfiguration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&fleet.PsoArrayConfiguration{")
	if this.FlashArray != nil {
		s = append(s, "FlashArray: "+fmt.Sprintf("%#v", this.FlashArray)+",\n")
	}
	if this.FlashBlade != nil {
		s = append(s, "FlashBlade: "+fmt.Sprintf("%#v", this.FlashBlade)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FlashBladeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&fleet.FlashBladeType{")
	s = append(s, "EnableSnapshotDirectory: "+fmt.Sprintf("%#v", this.EnableSnapshotDirectory)+",\n")
	s = append(s, "ExportRules: "+fmt.Sprintf("%#v", this.ExportRules)+",\n")
	if this.FlashBlades != nil {
		s = append(s, "FlashBlades: "+fmt.Sprintf("%#v", this.FlashBlades)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FlashBladeEndpoint) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&fleet.FlashBladeEndpoint{")
	if this.MgmtEndpoint != nil {
		s = append(s, "MgmtEndpoint: "+fmt.Sprintf("%#v", this.MgmtEndpoint)+",\n")
	}
	if this.ApiToken != nil {
		s = append(s, "ApiToken: "+fmt.Sprintf("%#v", this.ApiToken)+",\n")
	}
	if this.NfsEndpoint != nil {
		s = append(s, "NfsEndpoint: "+fmt.Sprintf("%#v", this.NfsEndpoint)+",\n")
	}
	keysForLables := make([]string, 0, len(this.Lables))
	for k, _ := range this.Lables {
		keysForLables = append(keysForLables, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLables)
	mapStringForLables := "map[string]string{"
	for _, k := range keysForLables {
		mapStringForLables += fmt.Sprintf("%#v: %#v,", k, this.Lables[k])
	}
	mapStringForLables += "}"
	if this.Lables != nil {
		s = append(s, "Lables: "+mapStringForLables+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FlashBladeEndpoint_MgmtIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FlashBladeEndpoint_MgmtIp{` +
		`MgmtIp:` + fmt.Sprintf("%#v", this.MgmtIp) + `}`}, ", ")
	return s
}
func (this *FlashBladeEndpoint_MgmtDnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FlashBladeEndpoint_MgmtDnsName{` +
		`MgmtDnsName:` + fmt.Sprintf("%#v", this.MgmtDnsName) + `}`}, ", ")
	return s
}
func (this *FlashBladeEndpoint_NfsEndpointIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FlashBladeEndpoint_NfsEndpointIp{` +
		`NfsEndpointIp:` + fmt.Sprintf("%#v", this.NfsEndpointIp) + `}`}, ", ")
	return s
}
func (this *FlashBladeEndpoint_NfsEndpointDnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FlashBladeEndpoint_NfsEndpointDnsName{` +
		`NfsEndpointDnsName:` + fmt.Sprintf("%#v", this.NfsEndpointDnsName) + `}`}, ", ")
	return s
}
func (this *FlashArrayType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&fleet.FlashArrayType{")
	s = append(s, "SanType: "+fmt.Sprintf("%#v", this.SanType)+",\n")
	s = append(s, "DefaultFsType: "+fmt.Sprintf("%#v", this.DefaultFsType)+",\n")
	s = append(s, "DefaultFsOpt: "+fmt.Sprintf("%#v", this.DefaultFsOpt)+",\n")
	s = append(s, "DefaultMountOpts: "+fmt.Sprintf("%#v", this.DefaultMountOpts)+",\n")
	s = append(s, "DisablePreemptAttachments: "+fmt.Sprintf("%#v", this.DisablePreemptAttachments)+",\n")
	s = append(s, "IscsiLoginTimeout: "+fmt.Sprintf("%#v", this.IscsiLoginTimeout)+",\n")
	if this.FlashArrays != nil {
		s = append(s, "FlashArrays: "+fmt.Sprintf("%#v", this.FlashArrays)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FlashArrayEndpoint) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&fleet.FlashArrayEndpoint{")
	if this.MgmtEndpoint != nil {
		s = append(s, "MgmtEndpoint: "+fmt.Sprintf("%#v", this.MgmtEndpoint)+",\n")
	}
	if this.ApiToken != nil {
		s = append(s, "ApiToken: "+fmt.Sprintf("%#v", this.ApiToken)+",\n")
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FlashArrayEndpoint_MgmtIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FlashArrayEndpoint_MgmtIp{` +
		`MgmtIp:` + fmt.Sprintf("%#v", this.MgmtIp) + `}`}, ", ")
	return s
}
func (this *FlashArrayEndpoint_MgmtDnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FlashArrayEndpoint_MgmtDnsName{` +
		`MgmtDnsName:` + fmt.Sprintf("%#v", this.MgmtDnsName) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappTridentType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&fleet.StorageDeviceNetappTridentType{")
	if this.BackendChoice != nil {
		s = append(s, "BackendChoice: "+fmt.Sprintf("%#v", this.BackendChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDeviceNetappTridentType_NetappBackendOntapNas) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappTridentType_NetappBackendOntapNas{` +
		`NetappBackendOntapNas:` + fmt.Sprintf("%#v", this.NetappBackendOntapNas) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappTridentType_NetappBackendOntapSan) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappTridentType_NetappBackendOntapSan{` +
		`NetappBackendOntapSan:` + fmt.Sprintf("%#v", this.NetappBackendOntapSan) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 25)
	s = append(s, "&fleet.StorageDeviceNetappBackendOntapSanType{")
	s = append(s, "StorageDriverName: "+fmt.Sprintf("%#v", this.StorageDriverName)+",\n")
	if this.ManagementLif != nil {
		s = append(s, "ManagementLif: "+fmt.Sprintf("%#v", this.ManagementLif)+",\n")
	}
	if this.DataLif != nil {
		s = append(s, "DataLif: "+fmt.Sprintf("%#v", this.DataLif)+",\n")
	}
	s = append(s, "Svm: "+fmt.Sprintf("%#v", this.Svm)+",\n")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	if this.Password != nil {
		s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	}
	if this.ChapChoice != nil {
		s = append(s, "ChapChoice: "+fmt.Sprintf("%#v", this.ChapChoice)+",\n")
	}
	s = append(s, "IgroupName: "+fmt.Sprintf("%#v", this.IgroupName)+",\n")
	s = append(s, "StoragePrefix: "+fmt.Sprintf("%#v", this.StoragePrefix)+",\n")
	s = append(s, "LimitAggregateUsage: "+fmt.Sprintf("%#v", this.LimitAggregateUsage)+",\n")
	s = append(s, "LimitVolumeSize: "+fmt.Sprintf("%#v", this.LimitVolumeSize)+",\n")
	if this.VolumeDefaults != nil {
		s = append(s, "VolumeDefaults: "+fmt.Sprintf("%#v", this.VolumeDefaults)+",\n")
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	if this.Storage != nil {
		s = append(s, "Storage: "+fmt.Sprintf("%#v", this.Storage)+",\n")
	}
	s = append(s, "ClientCertificate: "+fmt.Sprintf("%#v", this.ClientCertificate)+",\n")
	if this.ClientPrivateKey != nil {
		s = append(s, "ClientPrivateKey: "+fmt.Sprintf("%#v", this.ClientPrivateKey)+",\n")
	}
	s = append(s, "TrustedCaCertificate: "+fmt.Sprintf("%#v", this.TrustedCaCertificate)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDeviceNetappBackendOntapSanType_ManagementLifIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapSanType_ManagementLifIp{` +
		`ManagementLifIp:` + fmt.Sprintf("%#v", this.ManagementLifIp) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName{` +
		`ManagementLifDnsName:` + fmt.Sprintf("%#v", this.ManagementLifDnsName) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_DataLifIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapSanType_DataLifIp{` +
		`DataLifIp:` + fmt.Sprintf("%#v", this.DataLifIp) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_DataLifDnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapSanType_DataLifDnsName{` +
		`DataLifDnsName:` + fmt.Sprintf("%#v", this.DataLifDnsName) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_NoChap) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapSanType_NoChap{` +
		`NoChap:` + fmt.Sprintf("%#v", this.NoChap) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_UseChap) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapSanType_UseChap{` +
		`UseChap:` + fmt.Sprintf("%#v", this.UseChap) + `}`}, ", ")
	return s
}
func (this *DeviceNetappBackendOntapSanChapType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&fleet.DeviceNetappBackendOntapSanChapType{")
	s = append(s, "ChapUsername: "+fmt.Sprintf("%#v", this.ChapUsername)+",\n")
	s = append(s, "ChapTargetUsername: "+fmt.Sprintf("%#v", this.ChapTargetUsername)+",\n")
	if this.ChapInitiatorSecret != nil {
		s = append(s, "ChapInitiatorSecret: "+fmt.Sprintf("%#v", this.ChapInitiatorSecret)+",\n")
	}
	if this.ChapTargetInitiatorSecret != nil {
		s = append(s, "ChapTargetInitiatorSecret: "+fmt.Sprintf("%#v", this.ChapTargetInitiatorSecret)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDeviceNetappBackendOntapNasType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 26)
	s = append(s, "&fleet.StorageDeviceNetappBackendOntapNasType{")
	s = append(s, "StorageDriverName: "+fmt.Sprintf("%#v", this.StorageDriverName)+",\n")
	s = append(s, "BackendName: "+fmt.Sprintf("%#v", this.BackendName)+",\n")
	if this.ManagementLif != nil {
		s = append(s, "ManagementLif: "+fmt.Sprintf("%#v", this.ManagementLif)+",\n")
	}
	if this.DataLif != nil {
		s = append(s, "DataLif: "+fmt.Sprintf("%#v", this.DataLif)+",\n")
	}
	s = append(s, "Svm: "+fmt.Sprintf("%#v", this.Svm)+",\n")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	if this.Password != nil {
		s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	}
	s = append(s, "AutoExportPolicy: "+fmt.Sprintf("%#v", this.AutoExportPolicy)+",\n")
	if this.AutoExportCidrs != nil {
		s = append(s, "AutoExportCidrs: "+fmt.Sprintf("%#v", this.AutoExportCidrs)+",\n")
	}
	s = append(s, "StoragePrefix: "+fmt.Sprintf("%#v", this.StoragePrefix)+",\n")
	s = append(s, "LimitAggregateUsage: "+fmt.Sprintf("%#v", this.LimitAggregateUsage)+",\n")
	s = append(s, "LimitVolumeSize: "+fmt.Sprintf("%#v", this.LimitVolumeSize)+",\n")
	s = append(s, "NfsMountOptions: "+fmt.Sprintf("%#v", this.NfsMountOptions)+",\n")
	if this.VolumeDefaults != nil {
		s = append(s, "VolumeDefaults: "+fmt.Sprintf("%#v", this.VolumeDefaults)+",\n")
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	if this.Storage != nil {
		s = append(s, "Storage: "+fmt.Sprintf("%#v", this.Storage)+",\n")
	}
	s = append(s, "ClientCertificate: "+fmt.Sprintf("%#v", this.ClientCertificate)+",\n")
	if this.ClientPrivateKey != nil {
		s = append(s, "ClientPrivateKey: "+fmt.Sprintf("%#v", this.ClientPrivateKey)+",\n")
	}
	s = append(s, "TrustedCaCertificate: "+fmt.Sprintf("%#v", this.TrustedCaCertificate)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDeviceNetappBackendOntapNasType_ManagementLifIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapNasType_ManagementLifIp{` +
		`ManagementLifIp:` + fmt.Sprintf("%#v", this.ManagementLifIp) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName{` +
		`ManagementLifDnsName:` + fmt.Sprintf("%#v", this.ManagementLifDnsName) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappBackendOntapNasType_DataLifIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapNasType_DataLifIp{` +
		`DataLifIp:` + fmt.Sprintf("%#v", this.DataLifIp) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappBackendOntapNasType_DataLifDnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapNasType_DataLifDnsName{` +
		`DataLifDnsName:` + fmt.Sprintf("%#v", this.DataLifDnsName) + `}`}, ", ")
	return s
}
func (this *OntapVolumeDefaults) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&fleet.OntapVolumeDefaults{")
	s = append(s, "SpaceReserve: "+fmt.Sprintf("%#v", this.SpaceReserve)+",\n")
	s = append(s, "SnapshotPolicy: "+fmt.Sprintf("%#v", this.SnapshotPolicy)+",\n")
	s = append(s, "SnapshotReserve: "+fmt.Sprintf("%#v", this.SnapshotReserve)+",\n")
	s = append(s, "SplitOnClone: "+fmt.Sprintf("%#v", this.SplitOnClone)+",\n")
	s = append(s, "Encryption: "+fmt.Sprintf("%#v", this.Encryption)+",\n")
	s = append(s, "UnixPermissions: "+fmt.Sprintf("%#v", this.UnixPermissions)+",\n")
	s = append(s, "SnapshotDir: "+fmt.Sprintf("%#v", this.SnapshotDir)+",\n")
	s = append(s, "ExportPolicy: "+fmt.Sprintf("%#v", this.ExportPolicy)+",\n")
	s = append(s, "SecurityStyle: "+fmt.Sprintf("%#v", this.SecurityStyle)+",\n")
	s = append(s, "TieringPolicy: "+fmt.Sprintf("%#v", this.TieringPolicy)+",\n")
	if this.QosPolicyChoice != nil {
		s = append(s, "QosPolicyChoice: "+fmt.Sprintf("%#v", this.QosPolicyChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OntapVolumeDefaults_NoQos) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.OntapVolumeDefaults_NoQos{` +
		`NoQos:` + fmt.Sprintf("%#v", this.NoQos) + `}`}, ", ")
	return s
}
func (this *OntapVolumeDefaults_QosPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.OntapVolumeDefaults_QosPolicy{` +
		`QosPolicy:` + fmt.Sprintf("%#v", this.QosPolicy) + `}`}, ", ")
	return s
}
func (this *OntapVolumeDefaults_AdaptiveQosPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.OntapVolumeDefaults_AdaptiveQosPolicy{` +
		`AdaptiveQosPolicy:` + fmt.Sprintf("%#v", this.AdaptiveQosPolicy) + `}`}, ", ")
	return s
}
func (this *OntapVirtualStoragePoolType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&fleet.OntapVirtualStoragePoolType{")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "Zone: "+fmt.Sprintf("%#v", this.Zone)+",\n")
	if this.VolumeDefaults != nil {
		s = append(s, "VolumeDefaults: "+fmt.Sprintf("%#v", this.VolumeDefaults)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FleetStorageDeviceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&fleet.FleetStorageDeviceType{")
	s = append(s, "StorageDevice: "+fmt.Sprintf("%#v", this.StorageDevice)+",\n")
	if this.DeviceChoice != nil {
		s = append(s, "DeviceChoice: "+fmt.Sprintf("%#v", this.DeviceChoice)+",\n")
	}
	keysForAdvancedAdvancedParameters := make([]string, 0, len(this.AdvancedAdvancedParameters))
	for k, _ := range this.AdvancedAdvancedParameters {
		keysForAdvancedAdvancedParameters = append(keysForAdvancedAdvancedParameters, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAdvancedAdvancedParameters)
	mapStringForAdvancedAdvancedParameters := "map[string]string{"
	for _, k := range keysForAdvancedAdvancedParameters {
		mapStringForAdvancedAdvancedParameters += fmt.Sprintf("%#v: %#v,", k, this.AdvancedAdvancedParameters[k])
	}
	mapStringForAdvancedAdvancedParameters += "}"
	if this.AdvancedAdvancedParameters != nil {
		s = append(s, "AdvancedAdvancedParameters: "+mapStringForAdvancedAdvancedParameters+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FleetStorageDeviceType_NetappTrident) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FleetStorageDeviceType_NetappTrident{` +
		`NetappTrident:` + fmt.Sprintf("%#v", this.NetappTrident) + `}`}, ", ")
	return s
}
func (this *FleetStorageDeviceType_PureServiceOrchestrator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FleetStorageDeviceType_PureServiceOrchestrator{` +
		`PureServiceOrchestrator:` + fmt.Sprintf("%#v", this.PureServiceOrchestrator) + `}`}, ", ")
	return s
}
func (this *FleetStorageDeviceType_OpenebsEnterprise) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FleetStorageDeviceType_OpenebsEnterprise{` +
		`OpenebsEnterprise:` + fmt.Sprintf("%#v", this.OpenebsEnterprise) + `}`}, ", ")
	return s
}
func (this *FleetStorageDeviceType_CustomStorage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FleetStorageDeviceType_CustomStorage{` +
		`CustomStorage:` + fmt.Sprintf("%#v", this.CustomStorage) + `}`}, ", ")
	return s
}
func (this *FleetStorageDeviceListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&fleet.FleetStorageDeviceListType{")
	if this.StorageDevices != nil {
		s = append(s, "StorageDevices: "+fmt.Sprintf("%#v", this.StorageDevices)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageClassDellIsilonF800Type) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&fleet.StorageClassDellIsilonF800Type{")
	if this.HttpsChoice != nil {
		s = append(s, "HttpsChoice: "+fmt.Sprintf("%#v", this.HttpsChoice)+",\n")
	}
	s = append(s, "IscsiAccessZone: "+fmt.Sprintf("%#v", this.IscsiAccessZone)+",\n")
	s = append(s, "BasePath: "+fmt.Sprintf("%#v", this.BasePath)+",\n")
	s = append(s, "RootClientEnable: "+fmt.Sprintf("%#v", this.RootClientEnable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageClassDellIsilonF800Type_AzServiceName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageClassDellIsilonF800Type_AzServiceName{` +
		`AzServiceName:` + fmt.Sprintf("%#v", this.AzServiceName) + `}`}, ", ")
	return s
}
func (this *StorageClassDellIsilonF800Type_AzServiceIpAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageClassDellIsilonF800Type_AzServiceIpAddress{` +
		`AzServiceIpAddress:` + fmt.Sprintf("%#v", this.AzServiceIpAddress) + `}`}, ", ")
	return s
}
func (this *StorageClassHPENimbusStorageAf40Type) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&fleet.StorageClassHPENimbusStorageAf40Type{")
	s = append(s, "PerfPolicy: "+fmt.Sprintf("%#v", this.PerfPolicy)+",\n")
	s = append(s, "LimitIops: "+fmt.Sprintf("%#v", this.LimitIops)+",\n")
	s = append(s, "LimitMbps: "+fmt.Sprintf("%#v", this.LimitMbps)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageClassOpenebsEnterpriseType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&fleet.StorageClassOpenebsEnterpriseType{")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "Replication: "+fmt.Sprintf("%#v", this.Replication)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageClassNetappTridentType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&fleet.StorageClassNetappTridentType{")
	keysForSelector := make([]string, 0, len(this.Selector))
	for k, _ := range this.Selector {
		keysForSelector = append(keysForSelector, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSelector)
	mapStringForSelector := "map[string]string{"
	for _, k := range keysForSelector {
		mapStringForSelector += fmt.Sprintf("%#v: %#v,", k, this.Selector[k])
	}
	mapStringForSelector += "}"
	if this.Selector != nil {
		s = append(s, "Selector: "+mapStringForSelector+",\n")
	}
	s = append(s, "StoragePools: "+fmt.Sprintf("%#v", this.StoragePools)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageClassPureServiceOrchestratorType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&fleet.StorageClassPureServiceOrchestratorType{")
	s = append(s, "Backend: "+fmt.Sprintf("%#v", this.Backend)+",\n")
	s = append(s, "IopsLimit: "+fmt.Sprintf("%#v", this.IopsLimit)+",\n")
	s = append(s, "BandwidthLimit: "+fmt.Sprintf("%#v", this.BandwidthLimit)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageClassCustomType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&fleet.StorageClassCustomType{")
	s = append(s, "Yaml: "+fmt.Sprintf("%#v", this.Yaml)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FleetStorageClassType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&fleet.FleetStorageClassType{")
	s = append(s, "StorageDevice: "+fmt.Sprintf("%#v", this.StorageDevice)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "DefaultStorageClass: "+fmt.Sprintf("%#v", this.DefaultStorageClass)+",\n")
	if this.DeviceChoice != nil {
		s = append(s, "DeviceChoice: "+fmt.Sprintf("%#v", this.DeviceChoice)+",\n")
	}
	s = append(s, "ReclaimPolicy: "+fmt.Sprintf("%#v", this.ReclaimPolicy)+",\n")
	s = append(s, "AllowVolumeExpansion: "+fmt.Sprintf("%#v", this.AllowVolumeExpansion)+",\n")
	keysForAdvancedStorageParameters := make([]string, 0, len(this.AdvancedStorageParameters))
	for k, _ := range this.AdvancedStorageParameters {
		keysForAdvancedStorageParameters = append(keysForAdvancedStorageParameters, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAdvancedStorageParameters)
	mapStringForAdvancedStorageParameters := "map[string]string{"
	for _, k := range keysForAdvancedStorageParameters {
		mapStringForAdvancedStorageParameters += fmt.Sprintf("%#v: %#v,", k, this.AdvancedStorageParameters[k])
	}
	mapStringForAdvancedStorageParameters += "}"
	if this.AdvancedStorageParameters != nil {
		s = append(s, "AdvancedStorageParameters: "+mapStringForAdvancedStorageParameters+",\n")
	}
	s = append(s, "StorageClassName: "+fmt.Sprintf("%#v", this.StorageClassName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FleetStorageClassType_NetappTrident) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FleetStorageClassType_NetappTrident{` +
		`NetappTrident:` + fmt.Sprintf("%#v", this.NetappTrident) + `}`}, ", ")
	return s
}
func (this *FleetStorageClassType_PureServiceOrchestrator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FleetStorageClassType_PureServiceOrchestrator{` +
		`PureServiceOrchestrator:` + fmt.Sprintf("%#v", this.PureServiceOrchestrator) + `}`}, ", ")
	return s
}
func (this *FleetStorageClassType_OpenebsEnterprise) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FleetStorageClassType_OpenebsEnterprise{` +
		`OpenebsEnterprise:` + fmt.Sprintf("%#v", this.OpenebsEnterprise) + `}`}, ", ")
	return s
}
func (this *FleetStorageClassType_CustomStorage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FleetStorageClassType_CustomStorage{` +
		`CustomStorage:` + fmt.Sprintf("%#v", this.CustomStorage) + `}`}, ", ")
	return s
}
func (this *FleetStorageClassListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&fleet.FleetStorageClassListType{")
	if this.StorageClasses != nil {
		s = append(s, "StorageClasses: "+fmt.Sprintf("%#v", this.StorageClasses)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BondLacpType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&fleet.BondLacpType{")
	s = append(s, "Rate: "+fmt.Sprintf("%#v", this.Rate)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FleetBondDeviceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&fleet.FleetBondDeviceType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Devices: "+fmt.Sprintf("%#v", this.Devices)+",\n")
	if this.LacpChoice != nil {
		s = append(s, "LacpChoice: "+fmt.Sprintf("%#v", this.LacpChoice)+",\n")
	}
	s = append(s, "LinkPollingInterval: "+fmt.Sprintf("%#v", this.LinkPollingInterval)+",\n")
	s = append(s, "LinkUpDelay: "+fmt.Sprintf("%#v", this.LinkUpDelay)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FleetBondDeviceType_Lacp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FleetBondDeviceType_Lacp{` +
		`Lacp:` + fmt.Sprintf("%#v", this.Lacp) + `}`}, ", ")
	return s
}
func (this *FleetBondDeviceType_ActiveBackup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FleetBondDeviceType_ActiveBackup{` +
		`ActiveBackup:` + fmt.Sprintf("%#v", this.ActiveBackup) + `}`}, ", ")
	return s
}
func (this *FleetBondDevicesListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&fleet.FleetBondDevicesListType{")
	if this.BondDevices != nil {
		s = append(s, "BondDevices: "+fmt.Sprintf("%#v", this.BondDevices)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FleetStorageStaticRoutesListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&fleet.FleetStorageStaticRoutesListType{")
	if this.StorageRoutes != nil {
		s = append(s, "StorageRoutes: "+fmt.Sprintf("%#v", this.StorageRoutes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VGPUConfiguration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&fleet.VGPUConfiguration{")
	s = append(s, "ServerAddress: "+fmt.Sprintf("%#v", this.ServerAddress)+",\n")
	s = append(s, "ServerPort: "+fmt.Sprintf("%#v", this.ServerPort)+",\n")
	s = append(s, "FeatureType: "+fmt.Sprintf("%#v", this.FeatureType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VMConfiguration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&fleet.VMConfiguration{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BGPConfiguration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&fleet.BGPConfiguration{")
	s = append(s, "Asn: "+fmt.Sprintf("%#v", this.Asn)+",\n")
	if this.Peers != nil {
		s = append(s, "Peers: "+fmt.Sprintf("%#v", this.Peers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LocalControlPlaneType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&fleet.LocalControlPlaneType{")
	if this.NetworkChoice != nil {
		s = append(s, "NetworkChoice: "+fmt.Sprintf("%#v", this.NetworkChoice)+",\n")
	}
	if this.BgpConfig != nil {
		s = append(s, "BgpConfig: "+fmt.Sprintf("%#v", this.BgpConfig)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LocalControlPlaneType_InsideVn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.LocalControlPlaneType_InsideVn{` +
		`InsideVn:` + fmt.Sprintf("%#v", this.InsideVn) + `}`}, ", ")
	return s
}
func (this *LocalControlPlaneType_OutsideVn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.LocalControlPlaneType_OutsideVn{` +
		`OutsideVn:` + fmt.Sprintf("%#v", this.OutsideVn) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 48)
	s = append(s, "&fleet.GlobalSpecType{")
	s = append(s, "FleetLabel: "+fmt.Sprintf("%#v", this.FleetLabel)+",\n")
	s = append(s, "VolterraSoftwareVersion: "+fmt.Sprintf("%#v", this.VolterraSoftwareVersion)+",\n")
	if this.Devices != nil {
		s = append(s, "Devices: "+fmt.Sprintf("%#v", this.Devices)+",\n")
	}
	if this.NetworkConnectors != nil {
		s = append(s, "NetworkConnectors: "+fmt.Sprintf("%#v", this.NetworkConnectors)+",\n")
	}
	if this.NetworkFirewall != nil {
		s = append(s, "NetworkFirewall: "+fmt.Sprintf("%#v", this.NetworkFirewall)+",\n")
	}
	s = append(s, "OperatingSystemVersion: "+fmt.Sprintf("%#v", this.OperatingSystemVersion)+",\n")
	if this.OutsideVirtualNetwork != nil {
		s = append(s, "OutsideVirtualNetwork: "+fmt.Sprintf("%#v", this.OutsideVirtualNetwork)+",\n")
	}
	if this.InsideVirtualNetwork != nil {
		s = append(s, "InsideVirtualNetwork: "+fmt.Sprintf("%#v", this.InsideVirtualNetwork)+",\n")
	}
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	if this.BondChoice != nil {
		s = append(s, "BondChoice: "+fmt.Sprintf("%#v", this.BondChoice)+",\n")
	}
	if this.StorageInterfaceChoice != nil {
		s = append(s, "StorageInterfaceChoice: "+fmt.Sprintf("%#v", this.StorageInterfaceChoice)+",\n")
	}
	if this.StorageDeviceChoice != nil {
		s = append(s, "StorageDeviceChoice: "+fmt.Sprintf("%#v", this.StorageDeviceChoice)+",\n")
	}
	if this.StorageClassChoice != nil {
		s = append(s, "StorageClassChoice: "+fmt.Sprintf("%#v", this.StorageClassChoice)+",\n")
	}
	if this.DcClusterGroupChoice != nil {
		s = append(s, "DcClusterGroupChoice: "+fmt.Sprintf("%#v", this.DcClusterGroupChoice)+",\n")
	}
	if this.GpuChoice != nil {
		s = append(s, "GpuChoice: "+fmt.Sprintf("%#v", this.GpuChoice)+",\n")
	}
	if this.VmChoice != nil {
		s = append(s, "VmChoice: "+fmt.Sprintf("%#v", this.VmChoice)+",\n")
	}
	s = append(s, "EtcdClusterNetwork: "+fmt.Sprintf("%#v", this.EtcdClusterNetwork)+",\n")
	if this.StorageStaticRoutesChoice != nil {
		s = append(s, "StorageStaticRoutesChoice: "+fmt.Sprintf("%#v", this.StorageStaticRoutesChoice)+",\n")
	}
	s = append(s, "EnableDefaultFleetConfigDownload: "+fmt.Sprintf("%#v", this.EnableDefaultFleetConfigDownload)+",\n")
	s = append(s, "FleetType: "+fmt.Sprintf("%#v", this.FleetType)+",\n")
	if this.SingleSite != nil {
		s = append(s, "SingleSite: "+fmt.Sprintf("%#v", this.SingleSite)+",\n")
	}
	if this.LogsReceiverChoice != nil {
		s = append(s, "LogsReceiverChoice: "+fmt.Sprintf("%#v", this.LogsReceiverChoice)+",\n")
	}
	if this.UsbPolicyChoice != nil {
		s = append(s, "UsbPolicyChoice: "+fmt.Sprintf("%#v", this.UsbPolicyChoice)+",\n")
	}
	if this.K8SCluster != nil {
		s = append(s, "K8SCluster: "+fmt.Sprintf("%#v", this.K8SCluster)+",\n")
	}
	if this.LocalControlPlane != nil {
		s = append(s, "LocalControlPlane: "+fmt.Sprintf("%#v", this.LocalControlPlane)+",\n")
	}
	if this.FlowExporterChoice != nil {
		s = append(s, "FlowExporterChoice: "+fmt.Sprintf("%#v", this.FlowExporterChoice)+",\n")
	}
	if this.ViewInternal != nil {
		s = append(s, "ViewInternal: "+fmt.Sprintf("%#v", this.ViewInternal)+",\n")
	}
	s = append(s, "GeneratedYamls: "+fmt.Sprintf("%#v", this.GeneratedYamls)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_InterfaceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_InterfaceList{` +
		`InterfaceList:` + fmt.Sprintf("%#v", this.InterfaceList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DefaultInterfaces) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_DefaultInterfaces{` +
		`DefaultInterfaces:` + fmt.Sprintf("%#v", this.DefaultInterfaces) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_LegacyDevices) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_LegacyDevices{` +
		`LegacyDevices:` + fmt.Sprintf("%#v", this.LegacyDevices) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_NoBondDevices) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_NoBondDevices{` +
		`NoBondDevices:` + fmt.Sprintf("%#v", this.NoBondDevices) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_BondDeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_BondDeviceList{` +
		`BondDeviceList:` + fmt.Sprintf("%#v", this.BondDeviceList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_NoStorageInterfaces) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_NoStorageInterfaces{` +
		`NoStorageInterfaces:` + fmt.Sprintf("%#v", this.NoStorageInterfaces) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_StorageInterfaceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_StorageInterfaceList{` +
		`StorageInterfaceList:` + fmt.Sprintf("%#v", this.StorageInterfaceList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_NoStorageDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_NoStorageDevice{` +
		`NoStorageDevice:` + fmt.Sprintf("%#v", this.NoStorageDevice) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_StorageDeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_StorageDeviceList{` +
		`StorageDeviceList:` + fmt.Sprintf("%#v", this.StorageDeviceList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DefaultStorageClass) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_DefaultStorageClass{` +
		`DefaultStorageClass:` + fmt.Sprintf("%#v", this.DefaultStorageClass) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_StorageClassList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_StorageClassList{` +
		`StorageClassList:` + fmt.Sprintf("%#v", this.StorageClassList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_NoDcClusterGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_NoDcClusterGroup{` +
		`NoDcClusterGroup:` + fmt.Sprintf("%#v", this.NoDcClusterGroup) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DcClusterGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_DcClusterGroup{` +
		`DcClusterGroup:` + fmt.Sprintf("%#v", this.DcClusterGroup) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DcClusterGroupInside) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_DcClusterGroupInside{` +
		`DcClusterGroupInside:` + fmt.Sprintf("%#v", this.DcClusterGroupInside) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DisableGpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_DisableGpu{` +
		`DisableGpu:` + fmt.Sprintf("%#v", this.DisableGpu) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_EnableGpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_EnableGpu{` +
		`EnableGpu:` + fmt.Sprintf("%#v", this.EnableGpu) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_EnableVgpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_EnableVgpu{` +
		`EnableVgpu:` + fmt.Sprintf("%#v", this.EnableVgpu) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DisableVm) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_DisableVm{` +
		`DisableVm:` + fmt.Sprintf("%#v", this.DisableVm) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_EnableVm) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_EnableVm{` +
		`EnableVm:` + fmt.Sprintf("%#v", this.EnableVm) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_NoStorageStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_NoStorageStaticRoutes{` +
		`NoStorageStaticRoutes:` + fmt.Sprintf("%#v", this.NoStorageStaticRoutes) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_StorageStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_StorageStaticRoutes{` +
		`StorageStaticRoutes:` + fmt.Sprintf("%#v", this.StorageStaticRoutes) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_LogsStreamingDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_LogsStreamingDisabled{` +
		`LogsStreamingDisabled:` + fmt.Sprintf("%#v", this.LogsStreamingDisabled) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_LogReceiver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_LogReceiver{` +
		`LogReceiver:` + fmt.Sprintf("%#v", this.LogReceiver) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DenyAllUsb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_DenyAllUsb{` +
		`DenyAllUsb:` + fmt.Sprintf("%#v", this.DenyAllUsb) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AllowAllUsb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_AllowAllUsb{` +
		`AllowAllUsb:` + fmt.Sprintf("%#v", this.AllowAllUsb) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_UsbPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_UsbPolicy{` +
		`UsbPolicy:` + fmt.Sprintf("%#v", this.UsbPolicy) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DisableFlowExport) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_DisableFlowExport{` +
		`DisableFlowExport:` + fmt.Sprintf("%#v", this.DisableFlowExport) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_EnableFlowExport) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_EnableFlowExport{` +
		`EnableFlowExport:` + fmt.Sprintf("%#v", this.EnableFlowExport) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 38)
	s = append(s, "&fleet.CreateSpecType{")
	s = append(s, "FleetLabel: "+fmt.Sprintf("%#v", this.FleetLabel)+",\n")
	s = append(s, "VolterraSoftwareVersion: "+fmt.Sprintf("%#v", this.VolterraSoftwareVersion)+",\n")
	if this.NetworkConnectors != nil {
		s = append(s, "NetworkConnectors: "+fmt.Sprintf("%#v", this.NetworkConnectors)+",\n")
	}
	if this.NetworkFirewall != nil {
		s = append(s, "NetworkFirewall: "+fmt.Sprintf("%#v", this.NetworkFirewall)+",\n")
	}
	s = append(s, "OperatingSystemVersion: "+fmt.Sprintf("%#v", this.OperatingSystemVersion)+",\n")
	if this.OutsideVirtualNetwork != nil {
		s = append(s, "OutsideVirtualNetwork: "+fmt.Sprintf("%#v", this.OutsideVirtualNetwork)+",\n")
	}
	if this.InsideVirtualNetwork != nil {
		s = append(s, "InsideVirtualNetwork: "+fmt.Sprintf("%#v", this.InsideVirtualNetwork)+",\n")
	}
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	if this.BondChoice != nil {
		s = append(s, "BondChoice: "+fmt.Sprintf("%#v", this.BondChoice)+",\n")
	}
	if this.StorageInterfaceChoice != nil {
		s = append(s, "StorageInterfaceChoice: "+fmt.Sprintf("%#v", this.StorageInterfaceChoice)+",\n")
	}
	if this.StorageDeviceChoice != nil {
		s = append(s, "StorageDeviceChoice: "+fmt.Sprintf("%#v", this.StorageDeviceChoice)+",\n")
	}
	if this.StorageClassChoice != nil {
		s = append(s, "StorageClassChoice: "+fmt.Sprintf("%#v", this.StorageClassChoice)+",\n")
	}
	if this.DcClusterGroupChoice != nil {
		s = append(s, "DcClusterGroupChoice: "+fmt.Sprintf("%#v", this.DcClusterGroupChoice)+",\n")
	}
	if this.GpuChoice != nil {
		s = append(s, "GpuChoice: "+fmt.Sprintf("%#v", this.GpuChoice)+",\n")
	}
	if this.StorageStaticRoutesChoice != nil {
		s = append(s, "StorageStaticRoutesChoice: "+fmt.Sprintf("%#v", this.StorageStaticRoutesChoice)+",\n")
	}
	s = append(s, "EnableDefaultFleetConfigDownload: "+fmt.Sprintf("%#v", this.EnableDefaultFleetConfigDownload)+",\n")
	if this.LogsReceiverChoice != nil {
		s = append(s, "LogsReceiverChoice: "+fmt.Sprintf("%#v", this.LogsReceiverChoice)+",\n")
	}
	if this.UsbPolicyChoice != nil {
		s = append(s, "UsbPolicyChoice: "+fmt.Sprintf("%#v", this.UsbPolicyChoice)+",\n")
	}
	if this.VmChoice != nil {
		s = append(s, "VmChoice: "+fmt.Sprintf("%#v", this.VmChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_InterfaceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_InterfaceList{` +
		`InterfaceList:` + fmt.Sprintf("%#v", this.InterfaceList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DefaultConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_DefaultConfig{` +
		`DefaultConfig:` + fmt.Sprintf("%#v", this.DefaultConfig) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_DeviceList{` +
		`DeviceList:` + fmt.Sprintf("%#v", this.DeviceList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_NoBondDevices) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_NoBondDevices{` +
		`NoBondDevices:` + fmt.Sprintf("%#v", this.NoBondDevices) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_BondDeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_BondDeviceList{` +
		`BondDeviceList:` + fmt.Sprintf("%#v", this.BondDeviceList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_NoStorageInterfaces) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_NoStorageInterfaces{` +
		`NoStorageInterfaces:` + fmt.Sprintf("%#v", this.NoStorageInterfaces) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_StorageInterfaceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_StorageInterfaceList{` +
		`StorageInterfaceList:` + fmt.Sprintf("%#v", this.StorageInterfaceList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_NoStorageDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_NoStorageDevice{` +
		`NoStorageDevice:` + fmt.Sprintf("%#v", this.NoStorageDevice) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_StorageDeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_StorageDeviceList{` +
		`StorageDeviceList:` + fmt.Sprintf("%#v", this.StorageDeviceList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DefaultStorageClass) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_DefaultStorageClass{` +
		`DefaultStorageClass:` + fmt.Sprintf("%#v", this.DefaultStorageClass) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_StorageClassList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_StorageClassList{` +
		`StorageClassList:` + fmt.Sprintf("%#v", this.StorageClassList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_NoDcClusterGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_NoDcClusterGroup{` +
		`NoDcClusterGroup:` + fmt.Sprintf("%#v", this.NoDcClusterGroup) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DcClusterGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_DcClusterGroup{` +
		`DcClusterGroup:` + fmt.Sprintf("%#v", this.DcClusterGroup) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DcClusterGroupInside) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_DcClusterGroupInside{` +
		`DcClusterGroupInside:` + fmt.Sprintf("%#v", this.DcClusterGroupInside) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DisableGpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_DisableGpu{` +
		`DisableGpu:` + fmt.Sprintf("%#v", this.DisableGpu) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_EnableGpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_EnableGpu{` +
		`EnableGpu:` + fmt.Sprintf("%#v", this.EnableGpu) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_EnableVgpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_EnableVgpu{` +
		`EnableVgpu:` + fmt.Sprintf("%#v", this.EnableVgpu) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_NoStorageStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_NoStorageStaticRoutes{` +
		`NoStorageStaticRoutes:` + fmt.Sprintf("%#v", this.NoStorageStaticRoutes) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_StorageStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_StorageStaticRoutes{` +
		`StorageStaticRoutes:` + fmt.Sprintf("%#v", this.StorageStaticRoutes) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_LogsStreamingDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_LogsStreamingDisabled{` +
		`LogsStreamingDisabled:` + fmt.Sprintf("%#v", this.LogsStreamingDisabled) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_LogReceiver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_LogReceiver{` +
		`LogReceiver:` + fmt.Sprintf("%#v", this.LogReceiver) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DenyAllUsb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_DenyAllUsb{` +
		`DenyAllUsb:` + fmt.Sprintf("%#v", this.DenyAllUsb) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AllowAllUsb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_AllowAllUsb{` +
		`AllowAllUsb:` + fmt.Sprintf("%#v", this.AllowAllUsb) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_UsbPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_UsbPolicy{` +
		`UsbPolicy:` + fmt.Sprintf("%#v", this.UsbPolicy) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DisableVm) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_DisableVm{` +
		`DisableVm:` + fmt.Sprintf("%#v", this.DisableVm) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_EnableVm) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_EnableVm{` +
		`EnableVm:` + fmt.Sprintf("%#v", this.EnableVm) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 37)
	s = append(s, "&fleet.ReplaceSpecType{")
	s = append(s, "VolterraSoftwareVersion: "+fmt.Sprintf("%#v", this.VolterraSoftwareVersion)+",\n")
	if this.NetworkConnectors != nil {
		s = append(s, "NetworkConnectors: "+fmt.Sprintf("%#v", this.NetworkConnectors)+",\n")
	}
	if this.NetworkFirewall != nil {
		s = append(s, "NetworkFirewall: "+fmt.Sprintf("%#v", this.NetworkFirewall)+",\n")
	}
	s = append(s, "OperatingSystemVersion: "+fmt.Sprintf("%#v", this.OperatingSystemVersion)+",\n")
	if this.OutsideVirtualNetwork != nil {
		s = append(s, "OutsideVirtualNetwork: "+fmt.Sprintf("%#v", this.OutsideVirtualNetwork)+",\n")
	}
	if this.InsideVirtualNetwork != nil {
		s = append(s, "InsideVirtualNetwork: "+fmt.Sprintf("%#v", this.InsideVirtualNetwork)+",\n")
	}
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	if this.BondChoice != nil {
		s = append(s, "BondChoice: "+fmt.Sprintf("%#v", this.BondChoice)+",\n")
	}
	if this.StorageInterfaceChoice != nil {
		s = append(s, "StorageInterfaceChoice: "+fmt.Sprintf("%#v", this.StorageInterfaceChoice)+",\n")
	}
	if this.StorageDeviceChoice != nil {
		s = append(s, "StorageDeviceChoice: "+fmt.Sprintf("%#v", this.StorageDeviceChoice)+",\n")
	}
	if this.StorageClassChoice != nil {
		s = append(s, "StorageClassChoice: "+fmt.Sprintf("%#v", this.StorageClassChoice)+",\n")
	}
	if this.DcClusterGroupChoice != nil {
		s = append(s, "DcClusterGroupChoice: "+fmt.Sprintf("%#v", this.DcClusterGroupChoice)+",\n")
	}
	if this.GpuChoice != nil {
		s = append(s, "GpuChoice: "+fmt.Sprintf("%#v", this.GpuChoice)+",\n")
	}
	if this.StorageStaticRoutesChoice != nil {
		s = append(s, "StorageStaticRoutesChoice: "+fmt.Sprintf("%#v", this.StorageStaticRoutesChoice)+",\n")
	}
	s = append(s, "EnableDefaultFleetConfigDownload: "+fmt.Sprintf("%#v", this.EnableDefaultFleetConfigDownload)+",\n")
	if this.LogsReceiverChoice != nil {
		s = append(s, "LogsReceiverChoice: "+fmt.Sprintf("%#v", this.LogsReceiverChoice)+",\n")
	}
	if this.UsbPolicyChoice != nil {
		s = append(s, "UsbPolicyChoice: "+fmt.Sprintf("%#v", this.UsbPolicyChoice)+",\n")
	}
	if this.VmChoice != nil {
		s = append(s, "VmChoice: "+fmt.Sprintf("%#v", this.VmChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_InterfaceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_InterfaceList{` +
		`InterfaceList:` + fmt.Sprintf("%#v", this.InterfaceList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DefaultConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_DefaultConfig{` +
		`DefaultConfig:` + fmt.Sprintf("%#v", this.DefaultConfig) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_DeviceList{` +
		`DeviceList:` + fmt.Sprintf("%#v", this.DeviceList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_NoBondDevices) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_NoBondDevices{` +
		`NoBondDevices:` + fmt.Sprintf("%#v", this.NoBondDevices) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_BondDeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_BondDeviceList{` +
		`BondDeviceList:` + fmt.Sprintf("%#v", this.BondDeviceList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_NoStorageInterfaces) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_NoStorageInterfaces{` +
		`NoStorageInterfaces:` + fmt.Sprintf("%#v", this.NoStorageInterfaces) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_StorageInterfaceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_StorageInterfaceList{` +
		`StorageInterfaceList:` + fmt.Sprintf("%#v", this.StorageInterfaceList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_NoStorageDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_NoStorageDevice{` +
		`NoStorageDevice:` + fmt.Sprintf("%#v", this.NoStorageDevice) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_StorageDeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_StorageDeviceList{` +
		`StorageDeviceList:` + fmt.Sprintf("%#v", this.StorageDeviceList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DefaultStorageClass) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_DefaultStorageClass{` +
		`DefaultStorageClass:` + fmt.Sprintf("%#v", this.DefaultStorageClass) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_StorageClassList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_StorageClassList{` +
		`StorageClassList:` + fmt.Sprintf("%#v", this.StorageClassList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_NoDcClusterGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_NoDcClusterGroup{` +
		`NoDcClusterGroup:` + fmt.Sprintf("%#v", this.NoDcClusterGroup) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DcClusterGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_DcClusterGroup{` +
		`DcClusterGroup:` + fmt.Sprintf("%#v", this.DcClusterGroup) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DcClusterGroupInside) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_DcClusterGroupInside{` +
		`DcClusterGroupInside:` + fmt.Sprintf("%#v", this.DcClusterGroupInside) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DisableGpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_DisableGpu{` +
		`DisableGpu:` + fmt.Sprintf("%#v", this.DisableGpu) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_EnableGpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_EnableGpu{` +
		`EnableGpu:` + fmt.Sprintf("%#v", this.EnableGpu) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_EnableVgpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_EnableVgpu{` +
		`EnableVgpu:` + fmt.Sprintf("%#v", this.EnableVgpu) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_NoStorageStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_NoStorageStaticRoutes{` +
		`NoStorageStaticRoutes:` + fmt.Sprintf("%#v", this.NoStorageStaticRoutes) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_StorageStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_StorageStaticRoutes{` +
		`StorageStaticRoutes:` + fmt.Sprintf("%#v", this.StorageStaticRoutes) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_LogsStreamingDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_LogsStreamingDisabled{` +
		`LogsStreamingDisabled:` + fmt.Sprintf("%#v", this.LogsStreamingDisabled) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_LogReceiver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_LogReceiver{` +
		`LogReceiver:` + fmt.Sprintf("%#v", this.LogReceiver) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DenyAllUsb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_DenyAllUsb{` +
		`DenyAllUsb:` + fmt.Sprintf("%#v", this.DenyAllUsb) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AllowAllUsb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_AllowAllUsb{` +
		`AllowAllUsb:` + fmt.Sprintf("%#v", this.AllowAllUsb) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_UsbPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_UsbPolicy{` +
		`UsbPolicy:` + fmt.Sprintf("%#v", this.UsbPolicy) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DisableVm) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_DisableVm{` +
		`DisableVm:` + fmt.Sprintf("%#v", this.DisableVm) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_EnableVm) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_EnableVm{` +
		`EnableVm:` + fmt.Sprintf("%#v", this.EnableVm) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 38)
	s = append(s, "&fleet.GetSpecType{")
	s = append(s, "FleetLabel: "+fmt.Sprintf("%#v", this.FleetLabel)+",\n")
	s = append(s, "VolterraSoftwareVersion: "+fmt.Sprintf("%#v", this.VolterraSoftwareVersion)+",\n")
	if this.NetworkConnectors != nil {
		s = append(s, "NetworkConnectors: "+fmt.Sprintf("%#v", this.NetworkConnectors)+",\n")
	}
	if this.NetworkFirewall != nil {
		s = append(s, "NetworkFirewall: "+fmt.Sprintf("%#v", this.NetworkFirewall)+",\n")
	}
	s = append(s, "OperatingSystemVersion: "+fmt.Sprintf("%#v", this.OperatingSystemVersion)+",\n")
	if this.OutsideVirtualNetwork != nil {
		s = append(s, "OutsideVirtualNetwork: "+fmt.Sprintf("%#v", this.OutsideVirtualNetwork)+",\n")
	}
	if this.InsideVirtualNetwork != nil {
		s = append(s, "InsideVirtualNetwork: "+fmt.Sprintf("%#v", this.InsideVirtualNetwork)+",\n")
	}
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	if this.BondChoice != nil {
		s = append(s, "BondChoice: "+fmt.Sprintf("%#v", this.BondChoice)+",\n")
	}
	if this.StorageInterfaceChoice != nil {
		s = append(s, "StorageInterfaceChoice: "+fmt.Sprintf("%#v", this.StorageInterfaceChoice)+",\n")
	}
	if this.StorageDeviceChoice != nil {
		s = append(s, "StorageDeviceChoice: "+fmt.Sprintf("%#v", this.StorageDeviceChoice)+",\n")
	}
	if this.StorageClassChoice != nil {
		s = append(s, "StorageClassChoice: "+fmt.Sprintf("%#v", this.StorageClassChoice)+",\n")
	}
	if this.DcClusterGroupChoice != nil {
		s = append(s, "DcClusterGroupChoice: "+fmt.Sprintf("%#v", this.DcClusterGroupChoice)+",\n")
	}
	if this.GpuChoice != nil {
		s = append(s, "GpuChoice: "+fmt.Sprintf("%#v", this.GpuChoice)+",\n")
	}
	if this.StorageStaticRoutesChoice != nil {
		s = append(s, "StorageStaticRoutesChoice: "+fmt.Sprintf("%#v", this.StorageStaticRoutesChoice)+",\n")
	}
	s = append(s, "EnableDefaultFleetConfigDownload: "+fmt.Sprintf("%#v", this.EnableDefaultFleetConfigDownload)+",\n")
	if this.LogsReceiverChoice != nil {
		s = append(s, "LogsReceiverChoice: "+fmt.Sprintf("%#v", this.LogsReceiverChoice)+",\n")
	}
	if this.UsbPolicyChoice != nil {
		s = append(s, "UsbPolicyChoice: "+fmt.Sprintf("%#v", this.UsbPolicyChoice)+",\n")
	}
	if this.VmChoice != nil {
		s = append(s, "VmChoice: "+fmt.Sprintf("%#v", this.VmChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_InterfaceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_InterfaceList{` +
		`InterfaceList:` + fmt.Sprintf("%#v", this.InterfaceList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DefaultConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_DefaultConfig{` +
		`DefaultConfig:` + fmt.Sprintf("%#v", this.DefaultConfig) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_DeviceList{` +
		`DeviceList:` + fmt.Sprintf("%#v", this.DeviceList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_NoBondDevices) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_NoBondDevices{` +
		`NoBondDevices:` + fmt.Sprintf("%#v", this.NoBondDevices) + `}`}, ", ")
	return s
}
func (this *GetSpecType_BondDeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_BondDeviceList{` +
		`BondDeviceList:` + fmt.Sprintf("%#v", this.BondDeviceList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_NoStorageInterfaces) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_NoStorageInterfaces{` +
		`NoStorageInterfaces:` + fmt.Sprintf("%#v", this.NoStorageInterfaces) + `}`}, ", ")
	return s
}
func (this *GetSpecType_StorageInterfaceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_StorageInterfaceList{` +
		`StorageInterfaceList:` + fmt.Sprintf("%#v", this.StorageInterfaceList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_NoStorageDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_NoStorageDevice{` +
		`NoStorageDevice:` + fmt.Sprintf("%#v", this.NoStorageDevice) + `}`}, ", ")
	return s
}
func (this *GetSpecType_StorageDeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_StorageDeviceList{` +
		`StorageDeviceList:` + fmt.Sprintf("%#v", this.StorageDeviceList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DefaultStorageClass) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_DefaultStorageClass{` +
		`DefaultStorageClass:` + fmt.Sprintf("%#v", this.DefaultStorageClass) + `}`}, ", ")
	return s
}
func (this *GetSpecType_StorageClassList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_StorageClassList{` +
		`StorageClassList:` + fmt.Sprintf("%#v", this.StorageClassList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_NoDcClusterGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_NoDcClusterGroup{` +
		`NoDcClusterGroup:` + fmt.Sprintf("%#v", this.NoDcClusterGroup) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DcClusterGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_DcClusterGroup{` +
		`DcClusterGroup:` + fmt.Sprintf("%#v", this.DcClusterGroup) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DcClusterGroupInside) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_DcClusterGroupInside{` +
		`DcClusterGroupInside:` + fmt.Sprintf("%#v", this.DcClusterGroupInside) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DisableGpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_DisableGpu{` +
		`DisableGpu:` + fmt.Sprintf("%#v", this.DisableGpu) + `}`}, ", ")
	return s
}
func (this *GetSpecType_EnableGpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_EnableGpu{` +
		`EnableGpu:` + fmt.Sprintf("%#v", this.EnableGpu) + `}`}, ", ")
	return s
}
func (this *GetSpecType_EnableVgpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_EnableVgpu{` +
		`EnableVgpu:` + fmt.Sprintf("%#v", this.EnableVgpu) + `}`}, ", ")
	return s
}
func (this *GetSpecType_NoStorageStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_NoStorageStaticRoutes{` +
		`NoStorageStaticRoutes:` + fmt.Sprintf("%#v", this.NoStorageStaticRoutes) + `}`}, ", ")
	return s
}
func (this *GetSpecType_StorageStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_StorageStaticRoutes{` +
		`StorageStaticRoutes:` + fmt.Sprintf("%#v", this.StorageStaticRoutes) + `}`}, ", ")
	return s
}
func (this *GetSpecType_LogsStreamingDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_LogsStreamingDisabled{` +
		`LogsStreamingDisabled:` + fmt.Sprintf("%#v", this.LogsStreamingDisabled) + `}`}, ", ")
	return s
}
func (this *GetSpecType_LogReceiver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_LogReceiver{` +
		`LogReceiver:` + fmt.Sprintf("%#v", this.LogReceiver) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DenyAllUsb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_DenyAllUsb{` +
		`DenyAllUsb:` + fmt.Sprintf("%#v", this.DenyAllUsb) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AllowAllUsb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_AllowAllUsb{` +
		`AllowAllUsb:` + fmt.Sprintf("%#v", this.AllowAllUsb) + `}`}, ", ")
	return s
}
func (this *GetSpecType_UsbPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_UsbPolicy{` +
		`UsbPolicy:` + fmt.Sprintf("%#v", this.UsbPolicy) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DisableVm) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_DisableVm{` +
		`DisableVm:` + fmt.Sprintf("%#v", this.DisableVm) + `}`}, ", ")
	return s
}
func (this *GetSpecType_EnableVm) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_EnableVm{` +
		`EnableVm:` + fmt.Sprintf("%#v", this.EnableVm) + `}`}, ", ")
	return s
}
func (this *FleetStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&fleet.FleetStatus{")
	s = append(s, "AvailableSoftwareVersion: "+fmt.Sprintf("%#v", this.AvailableSoftwareVersion)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *NetworkingDeviceInstanceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkingDeviceInstanceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkingDeviceInstanceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Use != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Use))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Interface) > 0 {
		for iNdEx := len(m.Interface) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Interface[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *GenericDeviceInstanceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenericDeviceInstanceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenericDeviceInstanceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DeviceInstanceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceInstanceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceInstanceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeviceInstance != nil {
		{
			size := m.DeviceInstance.Size()
			i -= size
			if _, err := m.DeviceInstance.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Owner != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Owner))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeviceInstanceType_NetworkDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceInstanceType_NetworkDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NetworkDevice != nil {
		{
			size, err := m.NetworkDevice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *FleetInterfaceListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetInterfaceListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetInterfaceListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for iNdEx := len(m.Interfaces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Interfaces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FleetDeviceListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetDeviceListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetDeviceListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Devices) > 0 {
		for iNdEx := len(m.Devices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Devices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	return len(dAtA) - i, nil
}

func (m *StorageDeviceOpenebsEnterpriseType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDeviceOpenebsEnterpriseType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceOpenebsEnterpriseType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MayastorPools) > 0 {
		for iNdEx := len(m.MayastorPools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MayastorPools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OpenebsMayastorPoolType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenebsMayastorPoolType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenebsMayastorPoolType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PoolDiskDevices) > 0 {
		for iNdEx := len(m.PoolDiskDevices) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PoolDiskDevices[iNdEx])
			copy(dAtA[i:], m.PoolDiskDevices[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.PoolDiskDevices[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Node) > 0 {
		i -= len(m.Node)
		copy(dAtA[i:], m.Node)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Node)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PoolName) > 0 {
		i -= len(m.PoolName)
		copy(dAtA[i:], m.PoolName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PoolName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageDeviceDellIsilonF800Type) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDeviceDellIsilonF800Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceDellIsilonF800Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BasePath) > 0 {
		i -= len(m.BasePath)
		copy(dAtA[i:], m.BasePath)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BasePath)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.VolumePrefix) > 0 {
		i -= len(m.VolumePrefix)
		copy(dAtA[i:], m.VolumePrefix)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VolumePrefix)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.IscsiAccessZone) > 0 {
		i -= len(m.IscsiAccessZone)
		copy(dAtA[i:], m.IscsiAccessZone)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IscsiAccessZone)))
		i--
		dAtA[i] = 0x52
	}
	if m.ApiServerPort != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ApiServerPort))
		i--
		dAtA[i] = 0x48
	}
	if m.AddressChoice != nil {
		{
			size := m.AddressChoice.Size()
			i -= size
			if _, err := m.AddressChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.HttpsChoice != nil {
		{
			size := m.HttpsChoice.Size()
			i -= size
			if _, err := m.HttpsChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Password != nil {
		{
			size, err := m.Password.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageDeviceDellIsilonF800Type_SecureNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceDellIsilonF800Type_SecureNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SecureNetwork != nil {
		{
			size, err := m.SecureNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *StorageDeviceDellIsilonF800Type_TrustedCaUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceDellIsilonF800Type_TrustedCaUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.TrustedCaUrl)
	copy(dAtA[i:], m.TrustedCaUrl)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.TrustedCaUrl)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *StorageDeviceDellIsilonF800Type_ApiServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceDellIsilonF800Type_ApiServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ApiServerName)
	copy(dAtA[i:], m.ApiServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ApiServerName)))
	i--
	dAtA[i] = 0x3a
	return len(dAtA) - i, nil
}
func (m *StorageDeviceDellIsilonF800Type_ApiServerIpAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceDellIsilonF800Type_ApiServerIpAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ApiServerIpAddress)
	copy(dAtA[i:], m.ApiServerIpAddress)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ApiServerIpAddress)))
	i--
	dAtA[i] = 0x42
	return len(dAtA) - i, nil
}
func (m *StorageDeviceHPENimbusStorageAf40Type) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDeviceHPENimbusStorageAf40Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceHPENimbusStorageAf40Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LimitMbps != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LimitMbps))
		i--
		dAtA[i] = 0x40
	}
	if m.LimitIops != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LimitIops))
		i--
		dAtA[i] = 0x38
	}
	if len(m.PerfPolicy) > 0 {
		i -= len(m.PerfPolicy)
		copy(dAtA[i:], m.PerfPolicy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PerfPolicy)))
		i--
		dAtA[i] = 0x32
	}
	if m.Password != nil {
		{
			size, err := m.Password.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x22
	}
	if m.ApiServerPort != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ApiServerPort))
		i--
		dAtA[i] = 0x18
	}
	if len(m.StorageServerIpAddress) > 0 {
		i -= len(m.StorageServerIpAddress)
		copy(dAtA[i:], m.StorageServerIpAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StorageServerIpAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StorageServerName) > 0 {
		i -= len(m.StorageServerName)
		copy(dAtA[i:], m.StorageServerName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StorageServerName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageDevicePureStorageServiceOrchestratorType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDevicePureStorageServiceOrchestratorType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDevicePureStorageServiceOrchestratorType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Arrays != nil {
		{
			size, err := m.Arrays.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.EnableStrictTopology {
		i--
		if m.EnableStrictTopology {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.EnableStorageTopology {
		i--
		if m.EnableStorageTopology {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PsoArrayConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PsoArrayConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PsoArrayConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FlashBlade != nil {
		{
			size, err := m.FlashBlade.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.FlashArray != nil {
		{
			size, err := m.FlashArray.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FlashBladeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlashBladeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlashBladeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FlashBlades) > 0 {
		for iNdEx := len(m.FlashBlades) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FlashBlades[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ExportRules) > 0 {
		i -= len(m.ExportRules)
		copy(dAtA[i:], m.ExportRules)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExportRules)))
		i--
		dAtA[i] = 0x12
	}
	if m.EnableSnapshotDirectory {
		i--
		if m.EnableSnapshotDirectory {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FlashBladeEndpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlashBladeEndpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlashBladeEndpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Lables) > 0 {
		keysForLables := make([]string, 0, len(m.Lables))
		for k := range m.Lables {
			keysForLables = append(keysForLables, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLables)
		for iNdEx := len(keysForLables) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Lables[string(keysForLables[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLables[iNdEx])
			copy(dAtA[i:], keysForLables[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLables[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.NfsEndpoint != nil {
		{
			size := m.NfsEndpoint.Size()
			i -= size
			if _, err := m.NfsEndpoint.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ApiToken != nil {
		{
			size, err := m.ApiToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MgmtEndpoint != nil {
		{
			size := m.MgmtEndpoint.Size()
			i -= size
			if _, err := m.MgmtEndpoint.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *FlashBladeEndpoint_MgmtIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlashBladeEndpoint_MgmtIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.MgmtIp)
	copy(dAtA[i:], m.MgmtIp)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.MgmtIp)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *FlashBladeEndpoint_MgmtDnsName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlashBladeEndpoint_MgmtDnsName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.MgmtDnsName)
	copy(dAtA[i:], m.MgmtDnsName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.MgmtDnsName)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *FlashBladeEndpoint_NfsEndpointIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlashBladeEndpoint_NfsEndpointIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.NfsEndpointIp)
	copy(dAtA[i:], m.NfsEndpointIp)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.NfsEndpointIp)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *FlashBladeEndpoint_NfsEndpointDnsName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlashBladeEndpoint_NfsEndpointDnsName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.NfsEndpointDnsName)
	copy(dAtA[i:], m.NfsEndpointDnsName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.NfsEndpointDnsName)))
	i--
	dAtA[i] = 0x3a
	return len(dAtA) - i, nil
}
func (m *FlashArrayType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlashArrayType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlashArrayType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FlashArrays) > 0 {
		for iNdEx := len(m.FlashArrays) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FlashArrays[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.IscsiLoginTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IscsiLoginTimeout))
		i--
		dAtA[i] = 0x30
	}
	if m.DisablePreemptAttachments {
		i--
		if m.DisablePreemptAttachments {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.DefaultMountOpts) > 0 {
		for iNdEx := len(m.DefaultMountOpts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DefaultMountOpts[iNdEx])
			copy(dAtA[i:], m.DefaultMountOpts[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.DefaultMountOpts[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DefaultFsOpt) > 0 {
		i -= len(m.DefaultFsOpt)
		copy(dAtA[i:], m.DefaultFsOpt)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DefaultFsOpt)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DefaultFsType) > 0 {
		i -= len(m.DefaultFsType)
		copy(dAtA[i:], m.DefaultFsType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DefaultFsType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SanType) > 0 {
		i -= len(m.SanType)
		copy(dAtA[i:], m.SanType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SanType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FlashArrayEndpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlashArrayEndpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlashArrayEndpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ApiToken != nil {
		{
			size, err := m.ApiToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MgmtEndpoint != nil {
		{
			size := m.MgmtEndpoint.Size()
			i -= size
			if _, err := m.MgmtEndpoint.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *FlashArrayEndpoint_MgmtIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlashArrayEndpoint_MgmtIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.MgmtIp)
	copy(dAtA[i:], m.MgmtIp)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.MgmtIp)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *FlashArrayEndpoint_MgmtDnsName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlashArrayEndpoint_MgmtDnsName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.MgmtDnsName)
	copy(dAtA[i:], m.MgmtDnsName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.MgmtDnsName)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *StorageDeviceNetappTridentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDeviceNetappTridentType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceNetappTridentType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BackendChoice != nil {
		{
			size := m.BackendChoice.Size()
			i -= size
			if _, err := m.BackendChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StorageDeviceNetappTridentType_NetappBackendOntapNas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceNetappTridentType_NetappBackendOntapNas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NetappBackendOntapNas != nil {
		{
			size, err := m.NetappBackendOntapNas.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *StorageDeviceNetappTridentType_NetappBackendOntapSan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceNetappTridentType_NetappBackendOntapSan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NetappBackendOntapSan != nil {
		{
			size, err := m.NetappBackendOntapSan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *StorageDeviceNetappBackendOntapSanType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDeviceNetappBackendOntapSanType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceNetappBackendOntapSanType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TrustedCaCertificate) > 0 {
		i -= len(m.TrustedCaCertificate)
		copy(dAtA[i:], m.TrustedCaCertificate)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TrustedCaCertificate)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.ClientPrivateKey != nil {
		{
			size, err := m.ClientPrivateKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.ClientCertificate) > 0 {
		i -= len(m.ClientCertificate)
		copy(dAtA[i:], m.ClientCertificate)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientCertificate)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.Storage) > 0 {
		for iNdEx := len(m.Storage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Storage[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.VolumeDefaults != nil {
		{
			size, err := m.VolumeDefaults.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.LimitVolumeSize != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LimitVolumeSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.LimitAggregateUsage != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LimitAggregateUsage))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.StoragePrefix) > 0 {
		i -= len(m.StoragePrefix)
		copy(dAtA[i:], m.StoragePrefix)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StoragePrefix)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.IgroupName) > 0 {
		i -= len(m.IgroupName)
		copy(dAtA[i:], m.IgroupName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IgroupName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.ChapChoice != nil {
		{
			size := m.ChapChoice.Size()
			i -= size
			if _, err := m.ChapChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Password != nil {
		{
			size, err := m.Password.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Svm) > 0 {
		i -= len(m.Svm)
		copy(dAtA[i:], m.Svm)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Svm)))
		i--
		dAtA[i] = 0x4a
	}
	if m.DataLif != nil {
		{
			size := m.DataLif.Size()
			i -= size
			if _, err := m.DataLif.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ManagementLif != nil {
		{
			size := m.ManagementLif.Size()
			i -= size
			if _, err := m.ManagementLif.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.StorageDriverName) > 0 {
		i -= len(m.StorageDriverName)
		copy(dAtA[i:], m.StorageDriverName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StorageDriverName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageDeviceNetappBackendOntapSanType_ManagementLifIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceNetappBackendOntapSanType_ManagementLifIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ManagementLifIp)
	copy(dAtA[i:], m.ManagementLifIp)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ManagementLifIp)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ManagementLifDnsName)
	copy(dAtA[i:], m.ManagementLifDnsName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ManagementLifDnsName)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *StorageDeviceNetappBackendOntapSanType_DataLifIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceNetappBackendOntapSanType_DataLifIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DataLifIp)
	copy(dAtA[i:], m.DataLifIp)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DataLifIp)))
	i--
	dAtA[i] = 0x3a
	return len(dAtA) - i, nil
}
func (m *StorageDeviceNetappBackendOntapSanType_DataLifDnsName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceNetappBackendOntapSanType_DataLifDnsName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DataLifDnsName)
	copy(dAtA[i:], m.DataLifDnsName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DataLifDnsName)))
	i--
	dAtA[i] = 0x42
	return len(dAtA) - i, nil
}
func (m *StorageDeviceNetappBackendOntapSanType_NoChap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceNetappBackendOntapSanType_NoChap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoChap != nil {
		{
			size, err := m.NoChap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *StorageDeviceNetappBackendOntapSanType_UseChap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceNetappBackendOntapSanType_UseChap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseChap != nil {
		{
			size, err := m.UseChap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *DeviceNetappBackendOntapSanChapType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceNetappBackendOntapSanChapType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceNetappBackendOntapSanChapType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChapTargetInitiatorSecret != nil {
		{
			size, err := m.ChapTargetInitiatorSecret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ChapInitiatorSecret != nil {
		{
			size, err := m.ChapInitiatorSecret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChapTargetUsername) > 0 {
		i -= len(m.ChapTargetUsername)
		copy(dAtA[i:], m.ChapTargetUsername)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ChapTargetUsername)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChapUsername) > 0 {
		i -= len(m.ChapUsername)
		copy(dAtA[i:], m.ChapUsername)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ChapUsername)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageDeviceNetappBackendOntapNasType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDeviceNetappBackendOntapNasType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceNetappBackendOntapNasType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TrustedCaCertificate) > 0 {
		i -= len(m.TrustedCaCertificate)
		copy(dAtA[i:], m.TrustedCaCertificate)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TrustedCaCertificate)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.ClientPrivateKey != nil {
		{
			size, err := m.ClientPrivateKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.ClientCertificate) > 0 {
		i -= len(m.ClientCertificate)
		copy(dAtA[i:], m.ClientCertificate)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientCertificate)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.Storage) > 0 {
		for iNdEx := len(m.Storage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Storage[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.VolumeDefaults != nil {
		{
			size, err := m.VolumeDefaults.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.NfsMountOptions) > 0 {
		i -= len(m.NfsMountOptions)
		copy(dAtA[i:], m.NfsMountOptions)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NfsMountOptions)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.LimitVolumeSize) > 0 {
		i -= len(m.LimitVolumeSize)
		copy(dAtA[i:], m.LimitVolumeSize)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LimitVolumeSize)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.LimitAggregateUsage) > 0 {
		i -= len(m.LimitAggregateUsage)
		copy(dAtA[i:], m.LimitAggregateUsage)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LimitAggregateUsage)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.StoragePrefix) > 0 {
		i -= len(m.StoragePrefix)
		copy(dAtA[i:], m.StoragePrefix)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StoragePrefix)))
		i--
		dAtA[i] = 0x72
	}
	if m.AutoExportCidrs != nil {
		{
			size, err := m.AutoExportCidrs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.AutoExportPolicy {
		i--
		if m.AutoExportPolicy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Password != nil {
		{
			size, err := m.Password.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Svm) > 0 {
		i -= len(m.Svm)
		copy(dAtA[i:], m.Svm)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Svm)))
		i--
		dAtA[i] = 0x4a
	}
	if m.DataLif != nil {
		{
			size := m.DataLif.Size()
			i -= size
			if _, err := m.DataLif.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ManagementLif != nil {
		{
			size := m.ManagementLif.Size()
			i -= size
			if _, err := m.ManagementLif.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.BackendName) > 0 {
		i -= len(m.BackendName)
		copy(dAtA[i:], m.BackendName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BackendName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StorageDriverName) > 0 {
		i -= len(m.StorageDriverName)
		copy(dAtA[i:], m.StorageDriverName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StorageDriverName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageDeviceNetappBackendOntapNasType_ManagementLifIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceNetappBackendOntapNasType_ManagementLifIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ManagementLifIp)
	copy(dAtA[i:], m.ManagementLifIp)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ManagementLifIp)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ManagementLifDnsName)
	copy(dAtA[i:], m.ManagementLifDnsName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ManagementLifDnsName)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *StorageDeviceNetappBackendOntapNasType_DataLifIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceNetappBackendOntapNasType_DataLifIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DataLifIp)
	copy(dAtA[i:], m.DataLifIp)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DataLifIp)))
	i--
	dAtA[i] = 0x3a
	return len(dAtA) - i, nil
}
func (m *StorageDeviceNetappBackendOntapNasType_DataLifDnsName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeviceNetappBackendOntapNasType_DataLifDnsName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DataLifDnsName)
	copy(dAtA[i:], m.DataLifDnsName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DataLifDnsName)))
	i--
	dAtA[i] = 0x42
	return len(dAtA) - i, nil
}
func (m *OntapVolumeDefaults) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OntapVolumeDefaults) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OntapVolumeDefaults) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QosPolicyChoice != nil {
		{
			size := m.QosPolicyChoice.Size()
			i -= size
			if _, err := m.QosPolicyChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.TieringPolicy) > 0 {
		i -= len(m.TieringPolicy)
		copy(dAtA[i:], m.TieringPolicy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TieringPolicy)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.SecurityStyle) > 0 {
		i -= len(m.SecurityStyle)
		copy(dAtA[i:], m.SecurityStyle)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SecurityStyle)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ExportPolicy) > 0 {
		i -= len(m.ExportPolicy)
		copy(dAtA[i:], m.ExportPolicy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExportPolicy)))
		i--
		dAtA[i] = 0x42
	}
	if m.SnapshotDir {
		i--
		if m.SnapshotDir {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.UnixPermissions != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UnixPermissions))
		i--
		dAtA[i] = 0x30
	}
	if m.Encryption {
		i--
		if m.Encryption {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.SplitOnClone {
		i--
		if m.SplitOnClone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.SnapshotReserve) > 0 {
		i -= len(m.SnapshotReserve)
		copy(dAtA[i:], m.SnapshotReserve)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SnapshotReserve)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SnapshotPolicy) > 0 {
		i -= len(m.SnapshotPolicy)
		copy(dAtA[i:], m.SnapshotPolicy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SnapshotPolicy)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceReserve) > 0 {
		i -= len(m.SpaceReserve)
		copy(dAtA[i:], m.SpaceReserve)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SpaceReserve)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OntapVolumeDefaults_NoQos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OntapVolumeDefaults_NoQos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoQos != nil {
		{
			size, err := m.NoQos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *OntapVolumeDefaults_QosPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OntapVolumeDefaults_QosPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.QosPolicy)
	copy(dAtA[i:], m.QosPolicy)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.QosPolicy)))
	i--
	dAtA[i] = 0x6a
	return len(dAtA) - i, nil
}
func (m *OntapVolumeDefaults_AdaptiveQosPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OntapVolumeDefaults_AdaptiveQosPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.AdaptiveQosPolicy)
	copy(dAtA[i:], m.AdaptiveQosPolicy)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.AdaptiveQosPolicy)))
	i--
	dAtA[i] = 0x72
	return len(dAtA) - i, nil
}
func (m *OntapVirtualStoragePoolType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OntapVirtualStoragePoolType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OntapVirtualStoragePoolType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VolumeDefaults != nil {
		{
			size, err := m.VolumeDefaults.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Zone) > 0 {
		i -= len(m.Zone)
		copy(dAtA[i:], m.Zone)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Zone)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FleetStorageDeviceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetStorageDeviceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetStorageDeviceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeviceChoice != nil {
		{
			size := m.DeviceChoice.Size()
			i -= size
			if _, err := m.DeviceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.AdvancedAdvancedParameters) > 0 {
		keysForAdvancedAdvancedParameters := make([]string, 0, len(m.AdvancedAdvancedParameters))
		for k := range m.AdvancedAdvancedParameters {
			keysForAdvancedAdvancedParameters = append(keysForAdvancedAdvancedParameters, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForAdvancedAdvancedParameters)
		for iNdEx := len(keysForAdvancedAdvancedParameters) - 1; iNdEx >= 0; iNdEx-- {
			v := m.AdvancedAdvancedParameters[string(keysForAdvancedAdvancedParameters[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForAdvancedAdvancedParameters[iNdEx])
			copy(dAtA[i:], keysForAdvancedAdvancedParameters[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForAdvancedAdvancedParameters[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.StorageDevice) > 0 {
		i -= len(m.StorageDevice)
		copy(dAtA[i:], m.StorageDevice)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StorageDevice)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FleetStorageDeviceType_NetappTrident) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetStorageDeviceType_NetappTrident) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NetappTrident != nil {
		{
			size, err := m.NetappTrident.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *FleetStorageDeviceType_PureServiceOrchestrator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetStorageDeviceType_PureServiceOrchestrator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PureServiceOrchestrator != nil {
		{
			size, err := m.PureServiceOrchestrator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *FleetStorageDeviceType_OpenebsEnterprise) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetStorageDeviceType_OpenebsEnterprise) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OpenebsEnterprise != nil {
		{
			size, err := m.OpenebsEnterprise.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *FleetStorageDeviceType_CustomStorage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetStorageDeviceType_CustomStorage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CustomStorage != nil {
		{
			size, err := m.CustomStorage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *FleetStorageDeviceListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetStorageDeviceListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetStorageDeviceListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StorageDevices) > 0 {
		for iNdEx := len(m.StorageDevices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StorageDevices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StorageClassDellIsilonF800Type) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageClassDellIsilonF800Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageClassDellIsilonF800Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RootClientEnable {
		i--
		if m.RootClientEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.BasePath) > 0 {
		i -= len(m.BasePath)
		copy(dAtA[i:], m.BasePath)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BasePath)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.IscsiAccessZone) > 0 {
		i -= len(m.IscsiAccessZone)
		copy(dAtA[i:], m.IscsiAccessZone)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IscsiAccessZone)))
		i--
		dAtA[i] = 0x22
	}
	if m.HttpsChoice != nil {
		{
			size := m.HttpsChoice.Size()
			i -= size
			if _, err := m.HttpsChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StorageClassDellIsilonF800Type_AzServiceName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageClassDellIsilonF800Type_AzServiceName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.AzServiceName)
	copy(dAtA[i:], m.AzServiceName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.AzServiceName)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *StorageClassDellIsilonF800Type_AzServiceIpAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageClassDellIsilonF800Type_AzServiceIpAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.AzServiceIpAddress)
	copy(dAtA[i:], m.AzServiceIpAddress)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.AzServiceIpAddress)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *StorageClassHPENimbusStorageAf40Type) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageClassHPENimbusStorageAf40Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageClassHPENimbusStorageAf40Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LimitMbps != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LimitMbps))
		i--
		dAtA[i] = 0x18
	}
	if m.LimitIops != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LimitIops))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PerfPolicy) > 0 {
		i -= len(m.PerfPolicy)
		copy(dAtA[i:], m.PerfPolicy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PerfPolicy)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageClassOpenebsEnterpriseType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageClassOpenebsEnterpriseType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageClassOpenebsEnterpriseType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Replication != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Replication))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageClassNetappTridentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageClassNetappTridentType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageClassNetappTridentType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StoragePools) > 0 {
		i -= len(m.StoragePools)
		copy(dAtA[i:], m.StoragePools)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StoragePools)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Selector) > 0 {
		keysForSelector := make([]string, 0, len(m.Selector))
		for k := range m.Selector {
			keysForSelector = append(keysForSelector, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForSelector)
		for iNdEx := len(keysForSelector) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Selector[string(keysForSelector[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForSelector[iNdEx])
			copy(dAtA[i:], keysForSelector[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForSelector[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StorageClassPureServiceOrchestratorType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageClassPureServiceOrchestratorType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageClassPureServiceOrchestratorType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BandwidthLimit) > 0 {
		i -= len(m.BandwidthLimit)
		copy(dAtA[i:], m.BandwidthLimit)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BandwidthLimit)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IopsLimit != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IopsLimit))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Backend) > 0 {
		i -= len(m.Backend)
		copy(dAtA[i:], m.Backend)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Backend)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageClassCustomType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageClassCustomType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageClassCustomType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Yaml) > 0 {
		i -= len(m.Yaml)
		copy(dAtA[i:], m.Yaml)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Yaml)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FleetStorageClassType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetStorageClassType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetStorageClassType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeviceChoice != nil {
		{
			size := m.DeviceChoice.Size()
			i -= size
			if _, err := m.DeviceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AllowVolumeExpansion {
		i--
		if m.AllowVolumeExpansion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.ReclaimPolicy) > 0 {
		i -= len(m.ReclaimPolicy)
		copy(dAtA[i:], m.ReclaimPolicy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ReclaimPolicy)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.StorageClassName) > 0 {
		i -= len(m.StorageClassName)
		copy(dAtA[i:], m.StorageClassName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StorageClassName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AdvancedStorageParameters) > 0 {
		keysForAdvancedStorageParameters := make([]string, 0, len(m.AdvancedStorageParameters))
		for k := range m.AdvancedStorageParameters {
			keysForAdvancedStorageParameters = append(keysForAdvancedStorageParameters, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForAdvancedStorageParameters)
		for iNdEx := len(keysForAdvancedStorageParameters) - 1; iNdEx >= 0; iNdEx-- {
			v := m.AdvancedStorageParameters[string(keysForAdvancedStorageParameters[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForAdvancedStorageParameters[iNdEx])
			copy(dAtA[i:], keysForAdvancedStorageParameters[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForAdvancedStorageParameters[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.DefaultStorageClass {
		i--
		if m.DefaultStorageClass {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StorageDevice) > 0 {
		i -= len(m.StorageDevice)
		copy(dAtA[i:], m.StorageDevice)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StorageDevice)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FleetStorageClassType_NetappTrident) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetStorageClassType_NetappTrident) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NetappTrident != nil {
		{
			size, err := m.NetappTrident.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *FleetStorageClassType_PureServiceOrchestrator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetStorageClassType_PureServiceOrchestrator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PureServiceOrchestrator != nil {
		{
			size, err := m.PureServiceOrchestrator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *FleetStorageClassType_OpenebsEnterprise) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetStorageClassType_OpenebsEnterprise) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OpenebsEnterprise != nil {
		{
			size, err := m.OpenebsEnterprise.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *FleetStorageClassType_CustomStorage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetStorageClassType_CustomStorage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CustomStorage != nil {
		{
			size, err := m.CustomStorage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *FleetStorageClassListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetStorageClassListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetStorageClassListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StorageClasses) > 0 {
		for iNdEx := len(m.StorageClasses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StorageClasses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BondLacpType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BondLacpType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BondLacpType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rate != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Rate))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FleetBondDeviceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetBondDeviceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetBondDeviceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LinkUpDelay != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LinkUpDelay))
		i--
		dAtA[i] = 0x38
	}
	if m.LinkPollingInterval != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LinkPollingInterval))
		i--
		dAtA[i] = 0x30
	}
	if m.LacpChoice != nil {
		{
			size := m.LacpChoice.Size()
			i -= size
			if _, err := m.LacpChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Devices) > 0 {
		for iNdEx := len(m.Devices) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Devices[iNdEx])
			copy(dAtA[i:], m.Devices[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Devices[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FleetBondDeviceType_Lacp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetBondDeviceType_Lacp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Lacp != nil {
		{
			size, err := m.Lacp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *FleetBondDeviceType_ActiveBackup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetBondDeviceType_ActiveBackup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ActiveBackup != nil {
		{
			size, err := m.ActiveBackup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *FleetBondDevicesListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetBondDevicesListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetBondDevicesListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BondDevices) > 0 {
		for iNdEx := len(m.BondDevices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BondDevices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FleetStorageStaticRoutesListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetStorageStaticRoutesListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetStorageStaticRoutesListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StorageRoutes) > 0 {
		for iNdEx := len(m.StorageRoutes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StorageRoutes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VGPUConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VGPUConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VGPUConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FeatureType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.FeatureType))
		i--
		dAtA[i] = 0x30
	}
	if m.ServerPort != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ServerPort))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ServerAddress) > 0 {
		i -= len(m.ServerAddress)
		copy(dAtA[i:], m.ServerAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerAddress)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *VMConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VMConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VMConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *BGPConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Asn != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Asn))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Peers) > 0 {
		for iNdEx := len(m.Peers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Peers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *LocalControlPlaneType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalControlPlaneType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalControlPlaneType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BgpConfig != nil {
		{
			size, err := m.BgpConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.NetworkChoice != nil {
		{
			size := m.NetworkChoice.Size()
			i -= size
			if _, err := m.NetworkChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *LocalControlPlaneType_InsideVn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalControlPlaneType_InsideVn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InsideVn != nil {
		{
			size, err := m.InsideVn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *LocalControlPlaneType_OutsideVn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalControlPlaneType_OutsideVn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OutsideVn != nil {
		{
			size, err := m.OutsideVn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GeneratedYamls) > 0 {
		for iNdEx := len(m.GeneratedYamls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GeneratedYamls[iNdEx])
			copy(dAtA[i:], m.GeneratedYamls[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.GeneratedYamls[iNdEx])))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xca
		}
	}
	if m.ViewInternal != nil {
		{
			size, err := m.ViewInternal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc2
	}
	if m.VmChoice != nil {
		{
			size := m.VmChoice.Size()
			i -= size
			if _, err := m.VmChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.FlowExporterChoice != nil {
		{
			size := m.FlowExporterChoice.Size()
			i -= size
			if _, err := m.FlowExporterChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.GpuChoice != nil {
		{
			size := m.GpuChoice.Size()
			i -= size
			if _, err := m.GpuChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LocalControlPlane != nil {
		{
			size, err := m.LocalControlPlane.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	if m.K8SCluster != nil {
		{
			size, err := m.K8SCluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.UsbPolicyChoice != nil {
		{
			size := m.UsbPolicyChoice.Size()
			i -= size
			if _, err := m.UsbPolicyChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LogsReceiverChoice != nil {
		{
			size := m.LogsReceiverChoice.Size()
			i -= size
			if _, err := m.LogsReceiverChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.SingleSite) > 0 {
		for iNdEx := len(m.SingleSite) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SingleSite[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xd2
		}
	}
	if m.FleetType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.FleetType))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.InterfaceChoice != nil {
		{
			size := m.InterfaceChoice.Size()
			i -= size
			if _, err := m.InterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DcClusterGroupChoice != nil {
		{
			size := m.DcClusterGroupChoice.Size()
			i -= size
			if _, err := m.DcClusterGroupChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.EnableDefaultFleetConfigDownload {
		i--
		if m.EnableDefaultFleetConfigDownload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.StorageStaticRoutesChoice != nil {
		{
			size := m.StorageStaticRoutesChoice.Size()
			i -= size
			if _, err := m.StorageStaticRoutesChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.EtcdClusterNetwork != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EtcdClusterNetwork))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.StorageClassChoice != nil {
		{
			size := m.StorageClassChoice.Size()
			i -= size
			if _, err := m.StorageClassChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.StorageDeviceChoice != nil {
		{
			size := m.StorageDeviceChoice.Size()
			i -= size
			if _, err := m.StorageDeviceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.StorageInterfaceChoice != nil {
		{
			size := m.StorageInterfaceChoice.Size()
			i -= size
			if _, err := m.StorageInterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.BondChoice != nil {
		{
			size := m.BondChoice.Size()
			i -= size
			if _, err := m.BondChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.InsideVirtualNetwork) > 0 {
		for iNdEx := len(m.InsideVirtualNetwork) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InsideVirtualNetwork[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.OutsideVirtualNetwork) > 0 {
		for iNdEx := len(m.OutsideVirtualNetwork) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutsideVirtualNetwork[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.OperatingSystemVersion) > 0 {
		i -= len(m.OperatingSystemVersion)
		copy(dAtA[i:], m.OperatingSystemVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.NetworkFirewall) > 0 {
		for iNdEx := len(m.NetworkFirewall) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NetworkFirewall[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.NetworkConnectors) > 0 {
		for iNdEx := len(m.NetworkConnectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NetworkConnectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Devices) > 0 {
		for iNdEx := len(m.Devices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Devices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.VolterraSoftwareVersion) > 0 {
		i -= len(m.VolterraSoftwareVersion)
		copy(dAtA[i:], m.VolterraSoftwareVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VolterraSoftwareVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FleetLabel) > 0 {
		i -= len(m.FleetLabel)
		copy(dAtA[i:], m.FleetLabel)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FleetLabel)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_InterfaceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_InterfaceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InterfaceList != nil {
		{
			size, err := m.InterfaceList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_LegacyDevices) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_LegacyDevices) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LegacyDevices != nil {
		{
			size, err := m.LegacyDevices.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_NoBondDevices) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_NoBondDevices) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoBondDevices != nil {
		{
			size, err := m.NoBondDevices.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_BondDeviceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_BondDeviceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BondDeviceList != nil {
		{
			size, err := m.BondDeviceList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_NoStorageInterfaces) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_NoStorageInterfaces) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoStorageInterfaces != nil {
		{
			size, err := m.NoStorageInterfaces.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_StorageInterfaceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_StorageInterfaceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StorageInterfaceList != nil {
		{
			size, err := m.StorageInterfaceList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_NoStorageDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_NoStorageDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoStorageDevice != nil {
		{
			size, err := m.NoStorageDevice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_StorageDeviceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_StorageDeviceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StorageDeviceList != nil {
		{
			size, err := m.StorageDeviceList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DefaultStorageClass) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DefaultStorageClass) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultStorageClass != nil {
		{
			size, err := m.DefaultStorageClass.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_StorageClassList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_StorageClassList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StorageClassList != nil {
		{
			size, err := m.StorageClassList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_NoDcClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_NoDcClusterGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoDcClusterGroup != nil {
		{
			size, err := m.NoDcClusterGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DcClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DcClusterGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DcClusterGroup != nil {
		{
			size, err := m.DcClusterGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DisableGpu) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DisableGpu) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableGpu != nil {
		{
			size, err := m.DisableGpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_EnableGpu) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_EnableGpu) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableGpu != nil {
		{
			size, err := m.EnableGpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_NoStorageStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_NoStorageStaticRoutes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoStorageStaticRoutes != nil {
		{
			size, err := m.NoStorageStaticRoutes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_StorageStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_StorageStaticRoutes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StorageStaticRoutes != nil {
		{
			size, err := m.StorageStaticRoutes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DcClusterGroupInside) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DcClusterGroupInside) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DcClusterGroupInside != nil {
		{
			size, err := m.DcClusterGroupInside.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DefaultInterfaces) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DefaultInterfaces) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultInterfaces != nil {
		{
			size, err := m.DefaultInterfaces.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_LogsStreamingDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_LogsStreamingDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LogsStreamingDisabled != nil {
		{
			size, err := m.LogsStreamingDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_LogReceiver) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_LogReceiver) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LogReceiver != nil {
		{
			size, err := m.LogReceiver.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DenyAllUsb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DenyAllUsb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyAllUsb != nil {
		{
			size, err := m.DenyAllUsb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AllowAllUsb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AllowAllUsb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowAllUsb != nil {
		{
			size, err := m.AllowAllUsb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_UsbPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_UsbPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UsbPolicy != nil {
		{
			size, err := m.UsbPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_EnableVgpu) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_EnableVgpu) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableVgpu != nil {
		{
			size, err := m.EnableVgpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DisableFlowExport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DisableFlowExport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableFlowExport != nil {
		{
			size, err := m.DisableFlowExport.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_EnableFlowExport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_EnableFlowExport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableFlowExport != nil {
		{
			size, err := m.EnableFlowExport.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DisableVm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DisableVm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableVm != nil {
		{
			size, err := m.DisableVm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_EnableVm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_EnableVm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableVm != nil {
		{
			size, err := m.EnableVm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VmChoice != nil {
		{
			size := m.VmChoice.Size()
			i -= size
			if _, err := m.VmChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.GpuChoice != nil {
		{
			size := m.GpuChoice.Size()
			i -= size
			if _, err := m.GpuChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.UsbPolicyChoice != nil {
		{
			size := m.UsbPolicyChoice.Size()
			i -= size
			if _, err := m.UsbPolicyChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LogsReceiverChoice != nil {
		{
			size := m.LogsReceiverChoice.Size()
			i -= size
			if _, err := m.LogsReceiverChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.InterfaceChoice != nil {
		{
			size := m.InterfaceChoice.Size()
			i -= size
			if _, err := m.InterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DcClusterGroupChoice != nil {
		{
			size := m.DcClusterGroupChoice.Size()
			i -= size
			if _, err := m.DcClusterGroupChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.EnableDefaultFleetConfigDownload {
		i--
		if m.EnableDefaultFleetConfigDownload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.StorageStaticRoutesChoice != nil {
		{
			size := m.StorageStaticRoutesChoice.Size()
			i -= size
			if _, err := m.StorageStaticRoutesChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.StorageClassChoice != nil {
		{
			size := m.StorageClassChoice.Size()
			i -= size
			if _, err := m.StorageClassChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.StorageDeviceChoice != nil {
		{
			size := m.StorageDeviceChoice.Size()
			i -= size
			if _, err := m.StorageDeviceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.StorageInterfaceChoice != nil {
		{
			size := m.StorageInterfaceChoice.Size()
			i -= size
			if _, err := m.StorageInterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.BondChoice != nil {
		{
			size := m.BondChoice.Size()
			i -= size
			if _, err := m.BondChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.InsideVirtualNetwork) > 0 {
		for iNdEx := len(m.InsideVirtualNetwork) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InsideVirtualNetwork[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.OutsideVirtualNetwork) > 0 {
		for iNdEx := len(m.OutsideVirtualNetwork) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutsideVirtualNetwork[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.OperatingSystemVersion) > 0 {
		i -= len(m.OperatingSystemVersion)
		copy(dAtA[i:], m.OperatingSystemVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.NetworkFirewall) > 0 {
		for iNdEx := len(m.NetworkFirewall) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NetworkFirewall[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.NetworkConnectors) > 0 {
		for iNdEx := len(m.NetworkConnectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NetworkConnectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.VolterraSoftwareVersion) > 0 {
		i -= len(m.VolterraSoftwareVersion)
		copy(dAtA[i:], m.VolterraSoftwareVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VolterraSoftwareVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FleetLabel) > 0 {
		i -= len(m.FleetLabel)
		copy(dAtA[i:], m.FleetLabel)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FleetLabel)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_InterfaceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_InterfaceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InterfaceList != nil {
		{
			size, err := m.InterfaceList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DeviceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DeviceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeviceList != nil {
		{
			size, err := m.DeviceList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_NoBondDevices) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_NoBondDevices) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoBondDevices != nil {
		{
			size, err := m.NoBondDevices.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_BondDeviceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_BondDeviceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BondDeviceList != nil {
		{
			size, err := m.BondDeviceList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_NoStorageInterfaces) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_NoStorageInterfaces) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoStorageInterfaces != nil {
		{
			size, err := m.NoStorageInterfaces.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_StorageInterfaceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_StorageInterfaceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StorageInterfaceList != nil {
		{
			size, err := m.StorageInterfaceList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_NoStorageDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_NoStorageDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoStorageDevice != nil {
		{
			size, err := m.NoStorageDevice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_StorageDeviceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_StorageDeviceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StorageDeviceList != nil {
		{
			size, err := m.StorageDeviceList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DefaultStorageClass) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DefaultStorageClass) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultStorageClass != nil {
		{
			size, err := m.DefaultStorageClass.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_StorageClassList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_StorageClassList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StorageClassList != nil {
		{
			size, err := m.StorageClassList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_NoDcClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_NoDcClusterGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoDcClusterGroup != nil {
		{
			size, err := m.NoDcClusterGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DcClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DcClusterGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DcClusterGroup != nil {
		{
			size, err := m.DcClusterGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DisableGpu) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DisableGpu) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableGpu != nil {
		{
			size, err := m.DisableGpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_EnableGpu) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_EnableGpu) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableGpu != nil {
		{
			size, err := m.EnableGpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_NoStorageStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_NoStorageStaticRoutes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoStorageStaticRoutes != nil {
		{
			size, err := m.NoStorageStaticRoutes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_StorageStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_StorageStaticRoutes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StorageStaticRoutes != nil {
		{
			size, err := m.StorageStaticRoutes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DcClusterGroupInside) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DcClusterGroupInside) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DcClusterGroupInside != nil {
		{
			size, err := m.DcClusterGroupInside.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DefaultConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DefaultConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultConfig != nil {
		{
			size, err := m.DefaultConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_LogsStreamingDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_LogsStreamingDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LogsStreamingDisabled != nil {
		{
			size, err := m.LogsStreamingDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_LogReceiver) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_LogReceiver) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LogReceiver != nil {
		{
			size, err := m.LogReceiver.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DenyAllUsb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DenyAllUsb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyAllUsb != nil {
		{
			size, err := m.DenyAllUsb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_AllowAllUsb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AllowAllUsb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowAllUsb != nil {
		{
			size, err := m.AllowAllUsb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_UsbPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_UsbPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UsbPolicy != nil {
		{
			size, err := m.UsbPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_EnableVgpu) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_EnableVgpu) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableVgpu != nil {
		{
			size, err := m.EnableVgpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DisableVm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DisableVm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableVm != nil {
		{
			size, err := m.DisableVm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_EnableVm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_EnableVm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableVm != nil {
		{
			size, err := m.EnableVm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VmChoice != nil {
		{
			size := m.VmChoice.Size()
			i -= size
			if _, err := m.VmChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.GpuChoice != nil {
		{
			size := m.GpuChoice.Size()
			i -= size
			if _, err := m.GpuChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.UsbPolicyChoice != nil {
		{
			size := m.UsbPolicyChoice.Size()
			i -= size
			if _, err := m.UsbPolicyChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LogsReceiverChoice != nil {
		{
			size := m.LogsReceiverChoice.Size()
			i -= size
			if _, err := m.LogsReceiverChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.InterfaceChoice != nil {
		{
			size := m.InterfaceChoice.Size()
			i -= size
			if _, err := m.InterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DcClusterGroupChoice != nil {
		{
			size := m.DcClusterGroupChoice.Size()
			i -= size
			if _, err := m.DcClusterGroupChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.EnableDefaultFleetConfigDownload {
		i--
		if m.EnableDefaultFleetConfigDownload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.StorageStaticRoutesChoice != nil {
		{
			size := m.StorageStaticRoutesChoice.Size()
			i -= size
			if _, err := m.StorageStaticRoutesChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.StorageClassChoice != nil {
		{
			size := m.StorageClassChoice.Size()
			i -= size
			if _, err := m.StorageClassChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.StorageDeviceChoice != nil {
		{
			size := m.StorageDeviceChoice.Size()
			i -= size
			if _, err := m.StorageDeviceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.StorageInterfaceChoice != nil {
		{
			size := m.StorageInterfaceChoice.Size()
			i -= size
			if _, err := m.StorageInterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.BondChoice != nil {
		{
			size := m.BondChoice.Size()
			i -= size
			if _, err := m.BondChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.InsideVirtualNetwork) > 0 {
		for iNdEx := len(m.InsideVirtualNetwork) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InsideVirtualNetwork[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.OutsideVirtualNetwork) > 0 {
		for iNdEx := len(m.OutsideVirtualNetwork) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutsideVirtualNetwork[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.OperatingSystemVersion) > 0 {
		i -= len(m.OperatingSystemVersion)
		copy(dAtA[i:], m.OperatingSystemVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.NetworkFirewall) > 0 {
		for iNdEx := len(m.NetworkFirewall) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NetworkFirewall[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.NetworkConnectors) > 0 {
		for iNdEx := len(m.NetworkConnectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NetworkConnectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.VolterraSoftwareVersion) > 0 {
		i -= len(m.VolterraSoftwareVersion)
		copy(dAtA[i:], m.VolterraSoftwareVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VolterraSoftwareVersion)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_InterfaceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_InterfaceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InterfaceList != nil {
		{
			size, err := m.InterfaceList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DeviceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DeviceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeviceList != nil {
		{
			size, err := m.DeviceList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_NoBondDevices) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_NoBondDevices) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoBondDevices != nil {
		{
			size, err := m.NoBondDevices.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_BondDeviceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_BondDeviceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BondDeviceList != nil {
		{
			size, err := m.BondDeviceList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_NoStorageInterfaces) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_NoStorageInterfaces) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoStorageInterfaces != nil {
		{
			size, err := m.NoStorageInterfaces.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_StorageInterfaceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_StorageInterfaceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StorageInterfaceList != nil {
		{
			size, err := m.StorageInterfaceList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_NoStorageDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_NoStorageDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoStorageDevice != nil {
		{
			size, err := m.NoStorageDevice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_StorageDeviceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_StorageDeviceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StorageDeviceList != nil {
		{
			size, err := m.StorageDeviceList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DefaultStorageClass) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DefaultStorageClass) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultStorageClass != nil {
		{
			size, err := m.DefaultStorageClass.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_StorageClassList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_StorageClassList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StorageClassList != nil {
		{
			size, err := m.StorageClassList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_NoDcClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_NoDcClusterGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoDcClusterGroup != nil {
		{
			size, err := m.NoDcClusterGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DcClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DcClusterGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DcClusterGroup != nil {
		{
			size, err := m.DcClusterGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DisableGpu) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DisableGpu) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableGpu != nil {
		{
			size, err := m.DisableGpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_EnableGpu) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_EnableGpu) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableGpu != nil {
		{
			size, err := m.EnableGpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_NoStorageStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_NoStorageStaticRoutes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoStorageStaticRoutes != nil {
		{
			size, err := m.NoStorageStaticRoutes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_StorageStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_StorageStaticRoutes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StorageStaticRoutes != nil {
		{
			size, err := m.StorageStaticRoutes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DcClusterGroupInside) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DcClusterGroupInside) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DcClusterGroupInside != nil {
		{
			size, err := m.DcClusterGroupInside.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DefaultConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DefaultConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultConfig != nil {
		{
			size, err := m.DefaultConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_LogsStreamingDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_LogsStreamingDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LogsStreamingDisabled != nil {
		{
			size, err := m.LogsStreamingDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_LogReceiver) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_LogReceiver) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LogReceiver != nil {
		{
			size, err := m.LogReceiver.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DenyAllUsb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DenyAllUsb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyAllUsb != nil {
		{
			size, err := m.DenyAllUsb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_AllowAllUsb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AllowAllUsb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowAllUsb != nil {
		{
			size, err := m.AllowAllUsb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_UsbPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_UsbPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UsbPolicy != nil {
		{
			size, err := m.UsbPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_EnableVgpu) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_EnableVgpu) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableVgpu != nil {
		{
			size, err := m.EnableVgpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DisableVm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DisableVm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableVm != nil {
		{
			size, err := m.DisableVm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_EnableVm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_EnableVm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableVm != nil {
		{
			size, err := m.EnableVm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VmChoice != nil {
		{
			size := m.VmChoice.Size()
			i -= size
			if _, err := m.VmChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.GpuChoice != nil {
		{
			size := m.GpuChoice.Size()
			i -= size
			if _, err := m.GpuChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.UsbPolicyChoice != nil {
		{
			size := m.UsbPolicyChoice.Size()
			i -= size
			if _, err := m.UsbPolicyChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LogsReceiverChoice != nil {
		{
			size := m.LogsReceiverChoice.Size()
			i -= size
			if _, err := m.LogsReceiverChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.InterfaceChoice != nil {
		{
			size := m.InterfaceChoice.Size()
			i -= size
			if _, err := m.InterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DcClusterGroupChoice != nil {
		{
			size := m.DcClusterGroupChoice.Size()
			i -= size
			if _, err := m.DcClusterGroupChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.EnableDefaultFleetConfigDownload {
		i--
		if m.EnableDefaultFleetConfigDownload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.StorageStaticRoutesChoice != nil {
		{
			size := m.StorageStaticRoutesChoice.Size()
			i -= size
			if _, err := m.StorageStaticRoutesChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.StorageClassChoice != nil {
		{
			size := m.StorageClassChoice.Size()
			i -= size
			if _, err := m.StorageClassChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.StorageDeviceChoice != nil {
		{
			size := m.StorageDeviceChoice.Size()
			i -= size
			if _, err := m.StorageDeviceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.StorageInterfaceChoice != nil {
		{
			size := m.StorageInterfaceChoice.Size()
			i -= size
			if _, err := m.StorageInterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.BondChoice != nil {
		{
			size := m.BondChoice.Size()
			i -= size
			if _, err := m.BondChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.InsideVirtualNetwork) > 0 {
		for iNdEx := len(m.InsideVirtualNetwork) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InsideVirtualNetwork[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.OutsideVirtualNetwork) > 0 {
		for iNdEx := len(m.OutsideVirtualNetwork) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutsideVirtualNetwork[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.OperatingSystemVersion) > 0 {
		i -= len(m.OperatingSystemVersion)
		copy(dAtA[i:], m.OperatingSystemVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.NetworkFirewall) > 0 {
		for iNdEx := len(m.NetworkFirewall) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NetworkFirewall[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.NetworkConnectors) > 0 {
		for iNdEx := len(m.NetworkConnectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NetworkConnectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.VolterraSoftwareVersion) > 0 {
		i -= len(m.VolterraSoftwareVersion)
		copy(dAtA[i:], m.VolterraSoftwareVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VolterraSoftwareVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FleetLabel) > 0 {
		i -= len(m.FleetLabel)
		copy(dAtA[i:], m.FleetLabel)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FleetLabel)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_InterfaceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_InterfaceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InterfaceList != nil {
		{
			size, err := m.InterfaceList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DeviceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DeviceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeviceList != nil {
		{
			size, err := m.DeviceList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_NoBondDevices) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_NoBondDevices) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoBondDevices != nil {
		{
			size, err := m.NoBondDevices.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_BondDeviceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_BondDeviceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BondDeviceList != nil {
		{
			size, err := m.BondDeviceList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_NoStorageInterfaces) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_NoStorageInterfaces) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoStorageInterfaces != nil {
		{
			size, err := m.NoStorageInterfaces.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_StorageInterfaceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_StorageInterfaceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StorageInterfaceList != nil {
		{
			size, err := m.StorageInterfaceList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_NoStorageDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_NoStorageDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoStorageDevice != nil {
		{
			size, err := m.NoStorageDevice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_StorageDeviceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_StorageDeviceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StorageDeviceList != nil {
		{
			size, err := m.StorageDeviceList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DefaultStorageClass) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DefaultStorageClass) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultStorageClass != nil {
		{
			size, err := m.DefaultStorageClass.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_StorageClassList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_StorageClassList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StorageClassList != nil {
		{
			size, err := m.StorageClassList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_NoDcClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_NoDcClusterGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoDcClusterGroup != nil {
		{
			size, err := m.NoDcClusterGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DcClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DcClusterGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DcClusterGroup != nil {
		{
			size, err := m.DcClusterGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DisableGpu) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DisableGpu) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableGpu != nil {
		{
			size, err := m.DisableGpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_EnableGpu) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_EnableGpu) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableGpu != nil {
		{
			size, err := m.EnableGpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_NoStorageStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_NoStorageStaticRoutes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoStorageStaticRoutes != nil {
		{
			size, err := m.NoStorageStaticRoutes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_StorageStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_StorageStaticRoutes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StorageStaticRoutes != nil {
		{
			size, err := m.StorageStaticRoutes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DcClusterGroupInside) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DcClusterGroupInside) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DcClusterGroupInside != nil {
		{
			size, err := m.DcClusterGroupInside.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DefaultConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DefaultConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultConfig != nil {
		{
			size, err := m.DefaultConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_LogsStreamingDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_LogsStreamingDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LogsStreamingDisabled != nil {
		{
			size, err := m.LogsStreamingDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_LogReceiver) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_LogReceiver) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LogReceiver != nil {
		{
			size, err := m.LogReceiver.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DenyAllUsb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DenyAllUsb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyAllUsb != nil {
		{
			size, err := m.DenyAllUsb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_AllowAllUsb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AllowAllUsb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowAllUsb != nil {
		{
			size, err := m.AllowAllUsb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_UsbPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_UsbPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UsbPolicy != nil {
		{
			size, err := m.UsbPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_EnableVgpu) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_EnableVgpu) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableVgpu != nil {
		{
			size, err := m.EnableVgpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DisableVm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DisableVm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableVm != nil {
		{
			size, err := m.DisableVm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_EnableVm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_EnableVm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableVm != nil {
		{
			size, err := m.EnableVm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *FleetStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AvailableSoftwareVersion) > 0 {
		i -= len(m.AvailableSoftwareVersion)
		copy(dAtA[i:], m.AvailableSoftwareVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AvailableSoftwareVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NetworkingDeviceInstanceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Interface) > 0 {
		for _, e := range m.Interface {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Use != 0 {
		n += 1 + sovTypes(uint64(m.Use))
	}
	return n
}

func (m *GenericDeviceInstanceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DeviceInstanceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Owner != 0 {
		n += 1 + sovTypes(uint64(m.Owner))
	}
	if m.DeviceInstance != nil {
		n += m.DeviceInstance.Size()
	}
	return n
}

func (m *DeviceInstanceType_NetworkDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetworkDevice != nil {
		l = m.NetworkDevice.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetInterfaceListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for _, e := range m.Interfaces {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *FleetDeviceListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *StorageDeviceOpenebsEnterpriseType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MayastorPools) > 0 {
		for _, e := range m.MayastorPools {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *OpenebsMayastorPoolType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PoolName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.PoolDiskDevices) > 0 {
		for _, s := range m.PoolDiskDevices {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *StorageDeviceDellIsilonF800Type) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Password != nil {
		l = m.Password.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HttpsChoice != nil {
		n += m.HttpsChoice.Size()
	}
	if m.AddressChoice != nil {
		n += m.AddressChoice.Size()
	}
	if m.ApiServerPort != 0 {
		n += 1 + sovTypes(uint64(m.ApiServerPort))
	}
	l = len(m.IscsiAccessZone)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VolumePrefix)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BasePath)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StorageDeviceDellIsilonF800Type_SecureNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SecureNetwork != nil {
		l = m.SecureNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *StorageDeviceDellIsilonF800Type_TrustedCaUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TrustedCaUrl)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceDellIsilonF800Type_ApiServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApiServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceDellIsilonF800Type_ApiServerIpAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApiServerIpAddress)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceHPENimbusStorageAf40Type) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StorageServerName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.StorageServerIpAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ApiServerPort != 0 {
		n += 1 + sovTypes(uint64(m.ApiServerPort))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Password != nil {
		l = m.Password.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PerfPolicy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LimitIops != 0 {
		n += 1 + sovTypes(uint64(m.LimitIops))
	}
	if m.LimitMbps != 0 {
		n += 1 + sovTypes(uint64(m.LimitMbps))
	}
	return n
}

func (m *StorageDevicePureStorageServiceOrchestratorType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EnableStorageTopology {
		n += 2
	}
	if m.EnableStrictTopology {
		n += 2
	}
	if m.Arrays != nil {
		l = m.Arrays.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *PsoArrayConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlashArray != nil {
		l = m.FlashArray.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.FlashBlade != nil {
		l = m.FlashBlade.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *FlashBladeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableSnapshotDirectory {
		n += 2
	}
	l = len(m.ExportRules)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.FlashBlades) > 0 {
		for _, e := range m.FlashBlades {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *FlashBladeEndpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MgmtEndpoint != nil {
		n += m.MgmtEndpoint.Size()
	}
	if m.ApiToken != nil {
		l = m.ApiToken.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NfsEndpoint != nil {
		n += m.NfsEndpoint.Size()
	}
	if len(m.Lables) > 0 {
		for k, v := range m.Lables {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FlashBladeEndpoint_MgmtIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MgmtIp)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *FlashBladeEndpoint_MgmtDnsName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MgmtDnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *FlashBladeEndpoint_NfsEndpointIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NfsEndpointIp)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *FlashBladeEndpoint_NfsEndpointDnsName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NfsEndpointDnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *FlashArrayType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SanType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DefaultFsType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DefaultFsOpt)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.DefaultMountOpts) > 0 {
		for _, s := range m.DefaultMountOpts {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DisablePreemptAttachments {
		n += 2
	}
	if m.IscsiLoginTimeout != 0 {
		n += 1 + sovTypes(uint64(m.IscsiLoginTimeout))
	}
	if len(m.FlashArrays) > 0 {
		for _, e := range m.FlashArrays {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *FlashArrayEndpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MgmtEndpoint != nil {
		n += m.MgmtEndpoint.Size()
	}
	if m.ApiToken != nil {
		l = m.ApiToken.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FlashArrayEndpoint_MgmtIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MgmtIp)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *FlashArrayEndpoint_MgmtDnsName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MgmtDnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceNetappTridentType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BackendChoice != nil {
		n += m.BackendChoice.Size()
	}
	return n
}

func (m *StorageDeviceNetappTridentType_NetappBackendOntapNas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetappBackendOntapNas != nil {
		l = m.NetappBackendOntapNas.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *StorageDeviceNetappTridentType_NetappBackendOntapSan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetappBackendOntapSan != nil {
		l = m.NetappBackendOntapSan.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *StorageDeviceNetappBackendOntapSanType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StorageDriverName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ManagementLif != nil {
		n += m.ManagementLif.Size()
	}
	if m.DataLif != nil {
		n += m.DataLif.Size()
	}
	l = len(m.Svm)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Password != nil {
		l = m.Password.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ChapChoice != nil {
		n += m.ChapChoice.Size()
	}
	l = len(m.IgroupName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.StoragePrefix)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.LimitAggregateUsage != 0 {
		n += 2 + sovTypes(uint64(m.LimitAggregateUsage))
	}
	if m.LimitVolumeSize != 0 {
		n += 2 + sovTypes(uint64(m.LimitVolumeSize))
	}
	if m.VolumeDefaults != nil {
		l = m.VolumeDefaults.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Region)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.Storage) > 0 {
		for _, e := range m.Storage {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.ClientCertificate)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ClientPrivateKey != nil {
		l = m.ClientPrivateKey.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.TrustedCaCertificate)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StorageDeviceNetappBackendOntapSanType_ManagementLifIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ManagementLifIp)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ManagementLifDnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceNetappBackendOntapSanType_DataLifIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DataLifIp)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceNetappBackendOntapSanType_DataLifDnsName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DataLifDnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceNetappBackendOntapSanType_NoChap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoChap != nil {
		l = m.NoChap.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *StorageDeviceNetappBackendOntapSanType_UseChap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseChap != nil {
		l = m.UseChap.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DeviceNetappBackendOntapSanChapType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChapUsername)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ChapTargetUsername)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ChapInitiatorSecret != nil {
		l = m.ChapInitiatorSecret.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ChapTargetInitiatorSecret != nil {
		l = m.ChapTargetInitiatorSecret.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StorageDeviceNetappBackendOntapNasType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StorageDriverName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BackendName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ManagementLif != nil {
		n += m.ManagementLif.Size()
	}
	if m.DataLif != nil {
		n += m.DataLif.Size()
	}
	l = len(m.Svm)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Password != nil {
		l = m.Password.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AutoExportPolicy {
		n += 2
	}
	if m.AutoExportCidrs != nil {
		l = m.AutoExportCidrs.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.StoragePrefix)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.LimitAggregateUsage)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.LimitVolumeSize)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.NfsMountOptions)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VolumeDefaults != nil {
		l = m.VolumeDefaults.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Region)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.Storage) > 0 {
		for _, e := range m.Storage {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.ClientCertificate)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ClientPrivateKey != nil {
		l = m.ClientPrivateKey.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.TrustedCaCertificate)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StorageDeviceNetappBackendOntapNasType_ManagementLifIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ManagementLifIp)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ManagementLifDnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceNetappBackendOntapNasType_DataLifIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DataLifIp)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceNetappBackendOntapNasType_DataLifDnsName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DataLifDnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *OntapVolumeDefaults) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceReserve)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SnapshotPolicy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SnapshotReserve)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SplitOnClone {
		n += 2
	}
	if m.Encryption {
		n += 2
	}
	if m.UnixPermissions != 0 {
		n += 1 + sovTypes(uint64(m.UnixPermissions))
	}
	if m.SnapshotDir {
		n += 2
	}
	l = len(m.ExportPolicy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SecurityStyle)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TieringPolicy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.QosPolicyChoice != nil {
		n += m.QosPolicyChoice.Size()
	}
	return n
}

func (m *OntapVolumeDefaults_NoQos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoQos != nil {
		l = m.NoQos.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *OntapVolumeDefaults_QosPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.QosPolicy)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *OntapVolumeDefaults_AdaptiveQosPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AdaptiveQosPolicy)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *OntapVirtualStoragePoolType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VolumeDefaults != nil {
		l = m.VolumeDefaults.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *FleetStorageDeviceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StorageDevice)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AdvancedAdvancedParameters) > 0 {
		for k, v := range m.AdvancedAdvancedParameters {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.DeviceChoice != nil {
		n += m.DeviceChoice.Size()
	}
	return n
}

func (m *FleetStorageDeviceType_NetappTrident) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetappTrident != nil {
		l = m.NetappTrident.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetStorageDeviceType_PureServiceOrchestrator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PureServiceOrchestrator != nil {
		l = m.PureServiceOrchestrator.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetStorageDeviceType_OpenebsEnterprise) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpenebsEnterprise != nil {
		l = m.OpenebsEnterprise.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetStorageDeviceType_CustomStorage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CustomStorage != nil {
		l = m.CustomStorage.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetStorageDeviceListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StorageDevices) > 0 {
		for _, e := range m.StorageDevices {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *StorageClassDellIsilonF800Type) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpsChoice != nil {
		n += m.HttpsChoice.Size()
	}
	l = len(m.IscsiAccessZone)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BasePath)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RootClientEnable {
		n += 2
	}
	return n
}

func (m *StorageClassDellIsilonF800Type_AzServiceName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AzServiceName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageClassDellIsilonF800Type_AzServiceIpAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AzServiceIpAddress)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageClassHPENimbusStorageAf40Type) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PerfPolicy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LimitIops != 0 {
		n += 1 + sovTypes(uint64(m.LimitIops))
	}
	if m.LimitMbps != 0 {
		n += 1 + sovTypes(uint64(m.LimitMbps))
	}
	return n
}

func (m *StorageClassOpenebsEnterpriseType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Replication != 0 {
		n += 1 + sovTypes(uint64(m.Replication))
	}
	return n
}

func (m *StorageClassNetappTridentType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Selector) > 0 {
		for k, v := range m.Selector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.StoragePools)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StorageClassPureServiceOrchestratorType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Backend)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IopsLimit != 0 {
		n += 1 + sovTypes(uint64(m.IopsLimit))
	}
	l = len(m.BandwidthLimit)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StorageClassCustomType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *FleetStorageClassType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StorageDevice)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DefaultStorageClass {
		n += 2
	}
	if len(m.AdvancedStorageParameters) > 0 {
		for k, v := range m.AdvancedStorageParameters {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.StorageClassName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DeviceChoice != nil {
		n += m.DeviceChoice.Size()
	}
	l = len(m.ReclaimPolicy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AllowVolumeExpansion {
		n += 2
	}
	return n
}

func (m *FleetStorageClassType_NetappTrident) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetappTrident != nil {
		l = m.NetappTrident.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetStorageClassType_PureServiceOrchestrator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PureServiceOrchestrator != nil {
		l = m.PureServiceOrchestrator.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetStorageClassType_OpenebsEnterprise) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpenebsEnterprise != nil {
		l = m.OpenebsEnterprise.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetStorageClassType_CustomStorage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CustomStorage != nil {
		l = m.CustomStorage.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetStorageClassListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StorageClasses) > 0 {
		for _, e := range m.StorageClasses {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *BondLacpType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rate != 0 {
		n += 1 + sovTypes(uint64(m.Rate))
	}
	return n
}

func (m *FleetBondDeviceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Devices) > 0 {
		for _, s := range m.Devices {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.LacpChoice != nil {
		n += m.LacpChoice.Size()
	}
	if m.LinkPollingInterval != 0 {
		n += 1 + sovTypes(uint64(m.LinkPollingInterval))
	}
	if m.LinkUpDelay != 0 {
		n += 1 + sovTypes(uint64(m.LinkUpDelay))
	}
	return n
}

func (m *FleetBondDeviceType_Lacp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lacp != nil {
		l = m.Lacp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetBondDeviceType_ActiveBackup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActiveBackup != nil {
		l = m.ActiveBackup.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetBondDevicesListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BondDevices) > 0 {
		for _, e := range m.BondDevices {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *FleetStorageStaticRoutesListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StorageRoutes) > 0 {
		for _, e := range m.StorageRoutes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *VGPUConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ServerPort != 0 {
		n += 1 + sovTypes(uint64(m.ServerPort))
	}
	if m.FeatureType != 0 {
		n += 1 + sovTypes(uint64(m.FeatureType))
	}
	return n
}

func (m *VMConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BGPConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Asn != 0 {
		n += 1 + sovTypes(uint64(m.Asn))
	}
	return n
}

func (m *LocalControlPlaneType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetworkChoice != nil {
		n += m.NetworkChoice.Size()
	}
	if m.BgpConfig != nil {
		l = m.BgpConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *LocalControlPlaneType_InsideVn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InsideVn != nil {
		l = m.InsideVn.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LocalControlPlaneType_OutsideVn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OutsideVn != nil {
		l = m.OutsideVn.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FleetLabel)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VolterraSoftwareVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.NetworkConnectors) > 0 {
		for _, e := range m.NetworkConnectors {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.NetworkFirewall) > 0 {
		for _, e := range m.NetworkFirewall {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.OperatingSystemVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.OutsideVirtualNetwork) > 0 {
		for _, e := range m.OutsideVirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.InsideVirtualNetwork) > 0 {
		for _, e := range m.InsideVirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	if m.BondChoice != nil {
		n += m.BondChoice.Size()
	}
	if m.StorageInterfaceChoice != nil {
		n += m.StorageInterfaceChoice.Size()
	}
	if m.StorageDeviceChoice != nil {
		n += m.StorageDeviceChoice.Size()
	}
	if m.StorageClassChoice != nil {
		n += m.StorageClassChoice.Size()
	}
	if m.DcClusterGroupChoice != nil {
		n += m.DcClusterGroupChoice.Size()
	}
	if m.GpuChoice != nil {
		n += m.GpuChoice.Size()
	}
	if m.EtcdClusterNetwork != 0 {
		n += 2 + sovTypes(uint64(m.EtcdClusterNetwork))
	}
	if m.StorageStaticRoutesChoice != nil {
		n += m.StorageStaticRoutesChoice.Size()
	}
	if m.EnableDefaultFleetConfigDownload {
		n += 3
	}
	if m.FleetType != 0 {
		n += 2 + sovTypes(uint64(m.FleetType))
	}
	if len(m.SingleSite) > 0 {
		for _, e := range m.SingleSite {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.LogsReceiverChoice != nil {
		n += m.LogsReceiverChoice.Size()
	}
	if m.UsbPolicyChoice != nil {
		n += m.UsbPolicyChoice.Size()
	}
	if m.K8SCluster != nil {
		l = m.K8SCluster.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.LocalControlPlane != nil {
		l = m.LocalControlPlane.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.FlowExporterChoice != nil {
		n += m.FlowExporterChoice.Size()
	}
	if m.VmChoice != nil {
		n += m.VmChoice.Size()
	}
	if m.ViewInternal != nil {
		l = m.ViewInternal.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.GeneratedYamls) > 0 {
		for _, s := range m.GeneratedYamls {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType_InterfaceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InterfaceList != nil {
		l = m.InterfaceList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_LegacyDevices) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LegacyDevices != nil {
		l = m.LegacyDevices.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_NoBondDevices) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoBondDevices != nil {
		l = m.NoBondDevices.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_BondDeviceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BondDeviceList != nil {
		l = m.BondDeviceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_NoStorageInterfaces) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoStorageInterfaces != nil {
		l = m.NoStorageInterfaces.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_StorageInterfaceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageInterfaceList != nil {
		l = m.StorageInterfaceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_NoStorageDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoStorageDevice != nil {
		l = m.NoStorageDevice.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_StorageDeviceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageDeviceList != nil {
		l = m.StorageDeviceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DefaultStorageClass) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultStorageClass != nil {
		l = m.DefaultStorageClass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_StorageClassList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageClassList != nil {
		l = m.StorageClassList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_NoDcClusterGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoDcClusterGroup != nil {
		l = m.NoDcClusterGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DcClusterGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DcClusterGroup != nil {
		l = m.DcClusterGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DisableGpu) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableGpu != nil {
		l = m.DisableGpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_EnableGpu) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableGpu != nil {
		l = m.EnableGpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_NoStorageStaticRoutes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoStorageStaticRoutes != nil {
		l = m.NoStorageStaticRoutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_StorageStaticRoutes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageStaticRoutes != nil {
		l = m.StorageStaticRoutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DcClusterGroupInside) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DcClusterGroupInside != nil {
		l = m.DcClusterGroupInside.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DefaultInterfaces) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultInterfaces != nil {
		l = m.DefaultInterfaces.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_LogsStreamingDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogsStreamingDisabled != nil {
		l = m.LogsStreamingDisabled.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_LogReceiver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogReceiver != nil {
		l = m.LogReceiver.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DenyAllUsb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyAllUsb != nil {
		l = m.DenyAllUsb.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AllowAllUsb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowAllUsb != nil {
		l = m.AllowAllUsb.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_UsbPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UsbPolicy != nil {
		l = m.UsbPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_EnableVgpu) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableVgpu != nil {
		l = m.EnableVgpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DisableFlowExport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableFlowExport != nil {
		l = m.DisableFlowExport.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_EnableFlowExport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableFlowExport != nil {
		l = m.EnableFlowExport.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DisableVm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableVm != nil {
		l = m.DisableVm.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_EnableVm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableVm != nil {
		l = m.EnableVm.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FleetLabel)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VolterraSoftwareVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.NetworkConnectors) > 0 {
		for _, e := range m.NetworkConnectors {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.NetworkFirewall) > 0 {
		for _, e := range m.NetworkFirewall {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.OperatingSystemVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.OutsideVirtualNetwork) > 0 {
		for _, e := range m.OutsideVirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.InsideVirtualNetwork) > 0 {
		for _, e := range m.InsideVirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	if m.BondChoice != nil {
		n += m.BondChoice.Size()
	}
	if m.StorageInterfaceChoice != nil {
		n += m.StorageInterfaceChoice.Size()
	}
	if m.StorageDeviceChoice != nil {
		n += m.StorageDeviceChoice.Size()
	}
	if m.StorageClassChoice != nil {
		n += m.StorageClassChoice.Size()
	}
	if m.DcClusterGroupChoice != nil {
		n += m.DcClusterGroupChoice.Size()
	}
	if m.GpuChoice != nil {
		n += m.GpuChoice.Size()
	}
	if m.StorageStaticRoutesChoice != nil {
		n += m.StorageStaticRoutesChoice.Size()
	}
	if m.EnableDefaultFleetConfigDownload {
		n += 3
	}
	if m.LogsReceiverChoice != nil {
		n += m.LogsReceiverChoice.Size()
	}
	if m.UsbPolicyChoice != nil {
		n += m.UsbPolicyChoice.Size()
	}
	if m.VmChoice != nil {
		n += m.VmChoice.Size()
	}
	return n
}

func (m *CreateSpecType_InterfaceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InterfaceList != nil {
		l = m.InterfaceList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DeviceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeviceList != nil {
		l = m.DeviceList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_NoBondDevices) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoBondDevices != nil {
		l = m.NoBondDevices.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_BondDeviceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BondDeviceList != nil {
		l = m.BondDeviceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_NoStorageInterfaces) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoStorageInterfaces != nil {
		l = m.NoStorageInterfaces.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_StorageInterfaceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageInterfaceList != nil {
		l = m.StorageInterfaceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_NoStorageDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoStorageDevice != nil {
		l = m.NoStorageDevice.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_StorageDeviceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageDeviceList != nil {
		l = m.StorageDeviceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DefaultStorageClass) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultStorageClass != nil {
		l = m.DefaultStorageClass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_StorageClassList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageClassList != nil {
		l = m.StorageClassList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_NoDcClusterGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoDcClusterGroup != nil {
		l = m.NoDcClusterGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DcClusterGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DcClusterGroup != nil {
		l = m.DcClusterGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DisableGpu) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableGpu != nil {
		l = m.DisableGpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_EnableGpu) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableGpu != nil {
		l = m.EnableGpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_NoStorageStaticRoutes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoStorageStaticRoutes != nil {
		l = m.NoStorageStaticRoutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_StorageStaticRoutes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageStaticRoutes != nil {
		l = m.StorageStaticRoutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DcClusterGroupInside) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DcClusterGroupInside != nil {
		l = m.DcClusterGroupInside.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DefaultConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultConfig != nil {
		l = m.DefaultConfig.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_LogsStreamingDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogsStreamingDisabled != nil {
		l = m.LogsStreamingDisabled.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_LogReceiver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogReceiver != nil {
		l = m.LogReceiver.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DenyAllUsb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyAllUsb != nil {
		l = m.DenyAllUsb.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AllowAllUsb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowAllUsb != nil {
		l = m.AllowAllUsb.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_UsbPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UsbPolicy != nil {
		l = m.UsbPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_EnableVgpu) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableVgpu != nil {
		l = m.EnableVgpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DisableVm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableVm != nil {
		l = m.DisableVm.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_EnableVm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableVm != nil {
		l = m.EnableVm.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VolterraSoftwareVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.NetworkConnectors) > 0 {
		for _, e := range m.NetworkConnectors {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.NetworkFirewall) > 0 {
		for _, e := range m.NetworkFirewall {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.OperatingSystemVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.OutsideVirtualNetwork) > 0 {
		for _, e := range m.OutsideVirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.InsideVirtualNetwork) > 0 {
		for _, e := range m.InsideVirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	if m.BondChoice != nil {
		n += m.BondChoice.Size()
	}
	if m.StorageInterfaceChoice != nil {
		n += m.StorageInterfaceChoice.Size()
	}
	if m.StorageDeviceChoice != nil {
		n += m.StorageDeviceChoice.Size()
	}
	if m.StorageClassChoice != nil {
		n += m.StorageClassChoice.Size()
	}
	if m.DcClusterGroupChoice != nil {
		n += m.DcClusterGroupChoice.Size()
	}
	if m.GpuChoice != nil {
		n += m.GpuChoice.Size()
	}
	if m.StorageStaticRoutesChoice != nil {
		n += m.StorageStaticRoutesChoice.Size()
	}
	if m.EnableDefaultFleetConfigDownload {
		n += 3
	}
	if m.LogsReceiverChoice != nil {
		n += m.LogsReceiverChoice.Size()
	}
	if m.UsbPolicyChoice != nil {
		n += m.UsbPolicyChoice.Size()
	}
	if m.VmChoice != nil {
		n += m.VmChoice.Size()
	}
	return n
}

func (m *ReplaceSpecType_InterfaceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InterfaceList != nil {
		l = m.InterfaceList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DeviceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeviceList != nil {
		l = m.DeviceList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_NoBondDevices) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoBondDevices != nil {
		l = m.NoBondDevices.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_BondDeviceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BondDeviceList != nil {
		l = m.BondDeviceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_NoStorageInterfaces) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoStorageInterfaces != nil {
		l = m.NoStorageInterfaces.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_StorageInterfaceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageInterfaceList != nil {
		l = m.StorageInterfaceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_NoStorageDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoStorageDevice != nil {
		l = m.NoStorageDevice.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_StorageDeviceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageDeviceList != nil {
		l = m.StorageDeviceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DefaultStorageClass) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultStorageClass != nil {
		l = m.DefaultStorageClass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_StorageClassList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageClassList != nil {
		l = m.StorageClassList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_NoDcClusterGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoDcClusterGroup != nil {
		l = m.NoDcClusterGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DcClusterGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DcClusterGroup != nil {
		l = m.DcClusterGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DisableGpu) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableGpu != nil {
		l = m.DisableGpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_EnableGpu) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableGpu != nil {
		l = m.EnableGpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_NoStorageStaticRoutes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoStorageStaticRoutes != nil {
		l = m.NoStorageStaticRoutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_StorageStaticRoutes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageStaticRoutes != nil {
		l = m.StorageStaticRoutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DcClusterGroupInside) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DcClusterGroupInside != nil {
		l = m.DcClusterGroupInside.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DefaultConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultConfig != nil {
		l = m.DefaultConfig.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_LogsStreamingDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogsStreamingDisabled != nil {
		l = m.LogsStreamingDisabled.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_LogReceiver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogReceiver != nil {
		l = m.LogReceiver.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DenyAllUsb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyAllUsb != nil {
		l = m.DenyAllUsb.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AllowAllUsb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowAllUsb != nil {
		l = m.AllowAllUsb.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_UsbPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UsbPolicy != nil {
		l = m.UsbPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_EnableVgpu) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableVgpu != nil {
		l = m.EnableVgpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DisableVm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableVm != nil {
		l = m.DisableVm.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_EnableVm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableVm != nil {
		l = m.EnableVm.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FleetLabel)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VolterraSoftwareVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.NetworkConnectors) > 0 {
		for _, e := range m.NetworkConnectors {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.NetworkFirewall) > 0 {
		for _, e := range m.NetworkFirewall {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.OperatingSystemVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.OutsideVirtualNetwork) > 0 {
		for _, e := range m.OutsideVirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.InsideVirtualNetwork) > 0 {
		for _, e := range m.InsideVirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	if m.BondChoice != nil {
		n += m.BondChoice.Size()
	}
	if m.StorageInterfaceChoice != nil {
		n += m.StorageInterfaceChoice.Size()
	}
	if m.StorageDeviceChoice != nil {
		n += m.StorageDeviceChoice.Size()
	}
	if m.StorageClassChoice != nil {
		n += m.StorageClassChoice.Size()
	}
	if m.DcClusterGroupChoice != nil {
		n += m.DcClusterGroupChoice.Size()
	}
	if m.GpuChoice != nil {
		n += m.GpuChoice.Size()
	}
	if m.StorageStaticRoutesChoice != nil {
		n += m.StorageStaticRoutesChoice.Size()
	}
	if m.EnableDefaultFleetConfigDownload {
		n += 3
	}
	if m.LogsReceiverChoice != nil {
		n += m.LogsReceiverChoice.Size()
	}
	if m.UsbPolicyChoice != nil {
		n += m.UsbPolicyChoice.Size()
	}
	if m.VmChoice != nil {
		n += m.VmChoice.Size()
	}
	return n
}

func (m *GetSpecType_InterfaceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InterfaceList != nil {
		l = m.InterfaceList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DeviceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeviceList != nil {
		l = m.DeviceList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_NoBondDevices) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoBondDevices != nil {
		l = m.NoBondDevices.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_BondDeviceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BondDeviceList != nil {
		l = m.BondDeviceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_NoStorageInterfaces) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoStorageInterfaces != nil {
		l = m.NoStorageInterfaces.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_StorageInterfaceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageInterfaceList != nil {
		l = m.StorageInterfaceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_NoStorageDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoStorageDevice != nil {
		l = m.NoStorageDevice.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_StorageDeviceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageDeviceList != nil {
		l = m.StorageDeviceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DefaultStorageClass) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultStorageClass != nil {
		l = m.DefaultStorageClass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_StorageClassList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageClassList != nil {
		l = m.StorageClassList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_NoDcClusterGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoDcClusterGroup != nil {
		l = m.NoDcClusterGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DcClusterGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DcClusterGroup != nil {
		l = m.DcClusterGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DisableGpu) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableGpu != nil {
		l = m.DisableGpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_EnableGpu) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableGpu != nil {
		l = m.EnableGpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_NoStorageStaticRoutes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoStorageStaticRoutes != nil {
		l = m.NoStorageStaticRoutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_StorageStaticRoutes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageStaticRoutes != nil {
		l = m.StorageStaticRoutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DcClusterGroupInside) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DcClusterGroupInside != nil {
		l = m.DcClusterGroupInside.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DefaultConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultConfig != nil {
		l = m.DefaultConfig.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_LogsStreamingDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogsStreamingDisabled != nil {
		l = m.LogsStreamingDisabled.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_LogReceiver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogReceiver != nil {
		l = m.LogReceiver.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DenyAllUsb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyAllUsb != nil {
		l = m.DenyAllUsb.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AllowAllUsb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowAllUsb != nil {
		l = m.AllowAllUsb.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_UsbPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UsbPolicy != nil {
		l = m.UsbPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_EnableVgpu) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableVgpu != nil {
		l = m.EnableVgpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DisableVm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableVm != nil {
		l = m.DisableVm.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_EnableVm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableVm != nil {
		l = m.EnableVm.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AvailableSoftwareVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *NetworkingDeviceInstanceType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInterface := "[]*ObjectRefType{"
	for _, f := range this.Interface {
		repeatedStringForInterface += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForInterface += "}"
	s := strings.Join([]string{`&NetworkingDeviceInstanceType{`,
		`Interface:` + repeatedStringForInterface + `,`,
		`Use:` + fmt.Sprintf("%v", this.Use) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GenericDeviceInstanceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GenericDeviceInstanceType{`,
		`}`,
	}, "")
	return s
}
func (this *DeviceInstanceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeviceInstanceType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Owner:` + fmt.Sprintf("%v", this.Owner) + `,`,
		`DeviceInstance:` + fmt.Sprintf("%v", this.DeviceInstance) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeviceInstanceType_NetworkDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeviceInstanceType_NetworkDevice{`,
		`NetworkDevice:` + strings.Replace(fmt.Sprintf("%v", this.NetworkDevice), "NetworkingDeviceInstanceType", "NetworkingDeviceInstanceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetInterfaceListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInterfaces := "[]*ObjectRefType{"
	for _, f := range this.Interfaces {
		repeatedStringForInterfaces += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForInterfaces += "}"
	s := strings.Join([]string{`&FleetInterfaceListType{`,
		`Interfaces:` + repeatedStringForInterfaces + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetDeviceListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDevices := "[]*DeviceInstanceType{"
	for _, f := range this.Devices {
		repeatedStringForDevices += strings.Replace(f.String(), "DeviceInstanceType", "DeviceInstanceType", 1) + ","
	}
	repeatedStringForDevices += "}"
	s := strings.Join([]string{`&FleetDeviceListType{`,
		`Devices:` + repeatedStringForDevices + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceOpenebsEnterpriseType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMayastorPools := "[]*OpenebsMayastorPoolType{"
	for _, f := range this.MayastorPools {
		repeatedStringForMayastorPools += strings.Replace(f.String(), "OpenebsMayastorPoolType", "OpenebsMayastorPoolType", 1) + ","
	}
	repeatedStringForMayastorPools += "}"
	s := strings.Join([]string{`&StorageDeviceOpenebsEnterpriseType{`,
		`MayastorPools:` + repeatedStringForMayastorPools + `,`,
		`}`,
	}, "")
	return s
}
func (this *OpenebsMayastorPoolType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OpenebsMayastorPoolType{`,
		`PoolName:` + fmt.Sprintf("%v", this.PoolName) + `,`,
		`Node:` + fmt.Sprintf("%v", this.Node) + `,`,
		`PoolDiskDevices:` + fmt.Sprintf("%v", this.PoolDiskDevices) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceDellIsilonF800Type) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceDellIsilonF800Type{`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`Password:` + strings.Replace(fmt.Sprintf("%v", this.Password), "SecretType", "schema.SecretType", 1) + `,`,
		`HttpsChoice:` + fmt.Sprintf("%v", this.HttpsChoice) + `,`,
		`AddressChoice:` + fmt.Sprintf("%v", this.AddressChoice) + `,`,
		`ApiServerPort:` + fmt.Sprintf("%v", this.ApiServerPort) + `,`,
		`IscsiAccessZone:` + fmt.Sprintf("%v", this.IscsiAccessZone) + `,`,
		`VolumePrefix:` + fmt.Sprintf("%v", this.VolumePrefix) + `,`,
		`BasePath:` + fmt.Sprintf("%v", this.BasePath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceDellIsilonF800Type_SecureNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceDellIsilonF800Type_SecureNetwork{`,
		`SecureNetwork:` + strings.Replace(fmt.Sprintf("%v", this.SecureNetwork), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceDellIsilonF800Type_TrustedCaUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceDellIsilonF800Type_TrustedCaUrl{`,
		`TrustedCaUrl:` + fmt.Sprintf("%v", this.TrustedCaUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceDellIsilonF800Type_ApiServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceDellIsilonF800Type_ApiServerName{`,
		`ApiServerName:` + fmt.Sprintf("%v", this.ApiServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceDellIsilonF800Type_ApiServerIpAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceDellIsilonF800Type_ApiServerIpAddress{`,
		`ApiServerIpAddress:` + fmt.Sprintf("%v", this.ApiServerIpAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceHPENimbusStorageAf40Type) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceHPENimbusStorageAf40Type{`,
		`StorageServerName:` + fmt.Sprintf("%v", this.StorageServerName) + `,`,
		`StorageServerIpAddress:` + fmt.Sprintf("%v", this.StorageServerIpAddress) + `,`,
		`ApiServerPort:` + fmt.Sprintf("%v", this.ApiServerPort) + `,`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`Password:` + strings.Replace(fmt.Sprintf("%v", this.Password), "SecretType", "schema.SecretType", 1) + `,`,
		`PerfPolicy:` + fmt.Sprintf("%v", this.PerfPolicy) + `,`,
		`LimitIops:` + fmt.Sprintf("%v", this.LimitIops) + `,`,
		`LimitMbps:` + fmt.Sprintf("%v", this.LimitMbps) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDevicePureStorageServiceOrchestratorType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDevicePureStorageServiceOrchestratorType{`,
		`ClusterId:` + fmt.Sprintf("%v", this.ClusterId) + `,`,
		`EnableStorageTopology:` + fmt.Sprintf("%v", this.EnableStorageTopology) + `,`,
		`EnableStrictTopology:` + fmt.Sprintf("%v", this.EnableStrictTopology) + `,`,
		`Arrays:` + strings.Replace(this.Arrays.String(), "PsoArrayConfiguration", "PsoArrayConfiguration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PsoArrayConfiguration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PsoArrayConfiguration{`,
		`FlashArray:` + strings.Replace(this.FlashArray.String(), "FlashArrayType", "FlashArrayType", 1) + `,`,
		`FlashBlade:` + strings.Replace(this.FlashBlade.String(), "FlashBladeType", "FlashBladeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashBladeType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForFlashBlades := "[]*FlashBladeEndpoint{"
	for _, f := range this.FlashBlades {
		repeatedStringForFlashBlades += strings.Replace(f.String(), "FlashBladeEndpoint", "FlashBladeEndpoint", 1) + ","
	}
	repeatedStringForFlashBlades += "}"
	s := strings.Join([]string{`&FlashBladeType{`,
		`EnableSnapshotDirectory:` + fmt.Sprintf("%v", this.EnableSnapshotDirectory) + `,`,
		`ExportRules:` + fmt.Sprintf("%v", this.ExportRules) + `,`,
		`FlashBlades:` + repeatedStringForFlashBlades + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashBladeEndpoint) String() string {
	if this == nil {
		return "nil"
	}
	keysForLables := make([]string, 0, len(this.Lables))
	for k, _ := range this.Lables {
		keysForLables = append(keysForLables, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLables)
	mapStringForLables := "map[string]string{"
	for _, k := range keysForLables {
		mapStringForLables += fmt.Sprintf("%v: %v,", k, this.Lables[k])
	}
	mapStringForLables += "}"
	s := strings.Join([]string{`&FlashBladeEndpoint{`,
		`MgmtEndpoint:` + fmt.Sprintf("%v", this.MgmtEndpoint) + `,`,
		`ApiToken:` + strings.Replace(fmt.Sprintf("%v", this.ApiToken), "SecretType", "schema.SecretType", 1) + `,`,
		`NfsEndpoint:` + fmt.Sprintf("%v", this.NfsEndpoint) + `,`,
		`Lables:` + mapStringForLables + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashBladeEndpoint_MgmtIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FlashBladeEndpoint_MgmtIp{`,
		`MgmtIp:` + fmt.Sprintf("%v", this.MgmtIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashBladeEndpoint_MgmtDnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FlashBladeEndpoint_MgmtDnsName{`,
		`MgmtDnsName:` + fmt.Sprintf("%v", this.MgmtDnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashBladeEndpoint_NfsEndpointIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FlashBladeEndpoint_NfsEndpointIp{`,
		`NfsEndpointIp:` + fmt.Sprintf("%v", this.NfsEndpointIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashBladeEndpoint_NfsEndpointDnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FlashBladeEndpoint_NfsEndpointDnsName{`,
		`NfsEndpointDnsName:` + fmt.Sprintf("%v", this.NfsEndpointDnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashArrayType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForFlashArrays := "[]*FlashArrayEndpoint{"
	for _, f := range this.FlashArrays {
		repeatedStringForFlashArrays += strings.Replace(f.String(), "FlashArrayEndpoint", "FlashArrayEndpoint", 1) + ","
	}
	repeatedStringForFlashArrays += "}"
	s := strings.Join([]string{`&FlashArrayType{`,
		`SanType:` + fmt.Sprintf("%v", this.SanType) + `,`,
		`DefaultFsType:` + fmt.Sprintf("%v", this.DefaultFsType) + `,`,
		`DefaultFsOpt:` + fmt.Sprintf("%v", this.DefaultFsOpt) + `,`,
		`DefaultMountOpts:` + fmt.Sprintf("%v", this.DefaultMountOpts) + `,`,
		`DisablePreemptAttachments:` + fmt.Sprintf("%v", this.DisablePreemptAttachments) + `,`,
		`IscsiLoginTimeout:` + fmt.Sprintf("%v", this.IscsiLoginTimeout) + `,`,
		`FlashArrays:` + repeatedStringForFlashArrays + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashArrayEndpoint) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&FlashArrayEndpoint{`,
		`MgmtEndpoint:` + fmt.Sprintf("%v", this.MgmtEndpoint) + `,`,
		`ApiToken:` + strings.Replace(fmt.Sprintf("%v", this.ApiToken), "SecretType", "schema.SecretType", 1) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashArrayEndpoint_MgmtIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FlashArrayEndpoint_MgmtIp{`,
		`MgmtIp:` + fmt.Sprintf("%v", this.MgmtIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashArrayEndpoint_MgmtDnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FlashArrayEndpoint_MgmtDnsName{`,
		`MgmtDnsName:` + fmt.Sprintf("%v", this.MgmtDnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappTridentType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappTridentType{`,
		`BackendChoice:` + fmt.Sprintf("%v", this.BackendChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappTridentType_NetappBackendOntapNas) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappTridentType_NetappBackendOntapNas{`,
		`NetappBackendOntapNas:` + strings.Replace(fmt.Sprintf("%v", this.NetappBackendOntapNas), "StorageDeviceNetappBackendOntapNasType", "StorageDeviceNetappBackendOntapNasType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappTridentType_NetappBackendOntapSan) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappTridentType_NetappBackendOntapSan{`,
		`NetappBackendOntapSan:` + strings.Replace(fmt.Sprintf("%v", this.NetappBackendOntapSan), "StorageDeviceNetappBackendOntapSanType", "StorageDeviceNetappBackendOntapSanType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForStorage := "[]*OntapVirtualStoragePoolType{"
	for _, f := range this.Storage {
		repeatedStringForStorage += strings.Replace(f.String(), "OntapVirtualStoragePoolType", "OntapVirtualStoragePoolType", 1) + ","
	}
	repeatedStringForStorage += "}"
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapSanType{`,
		`StorageDriverName:` + fmt.Sprintf("%v", this.StorageDriverName) + `,`,
		`ManagementLif:` + fmt.Sprintf("%v", this.ManagementLif) + `,`,
		`DataLif:` + fmt.Sprintf("%v", this.DataLif) + `,`,
		`Svm:` + fmt.Sprintf("%v", this.Svm) + `,`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`Password:` + strings.Replace(fmt.Sprintf("%v", this.Password), "SecretType", "schema.SecretType", 1) + `,`,
		`ChapChoice:` + fmt.Sprintf("%v", this.ChapChoice) + `,`,
		`IgroupName:` + fmt.Sprintf("%v", this.IgroupName) + `,`,
		`StoragePrefix:` + fmt.Sprintf("%v", this.StoragePrefix) + `,`,
		`LimitAggregateUsage:` + fmt.Sprintf("%v", this.LimitAggregateUsage) + `,`,
		`LimitVolumeSize:` + fmt.Sprintf("%v", this.LimitVolumeSize) + `,`,
		`VolumeDefaults:` + strings.Replace(this.VolumeDefaults.String(), "OntapVolumeDefaults", "OntapVolumeDefaults", 1) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`Storage:` + repeatedStringForStorage + `,`,
		`ClientCertificate:` + fmt.Sprintf("%v", this.ClientCertificate) + `,`,
		`ClientPrivateKey:` + strings.Replace(fmt.Sprintf("%v", this.ClientPrivateKey), "SecretType", "schema.SecretType", 1) + `,`,
		`TrustedCaCertificate:` + fmt.Sprintf("%v", this.TrustedCaCertificate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_ManagementLifIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapSanType_ManagementLifIp{`,
		`ManagementLifIp:` + fmt.Sprintf("%v", this.ManagementLifIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName{`,
		`ManagementLifDnsName:` + fmt.Sprintf("%v", this.ManagementLifDnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_DataLifIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapSanType_DataLifIp{`,
		`DataLifIp:` + fmt.Sprintf("%v", this.DataLifIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_DataLifDnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapSanType_DataLifDnsName{`,
		`DataLifDnsName:` + fmt.Sprintf("%v", this.DataLifDnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_NoChap) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapSanType_NoChap{`,
		`NoChap:` + strings.Replace(fmt.Sprintf("%v", this.NoChap), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_UseChap) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapSanType_UseChap{`,
		`UseChap:` + strings.Replace(fmt.Sprintf("%v", this.UseChap), "DeviceNetappBackendOntapSanChapType", "DeviceNetappBackendOntapSanChapType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeviceNetappBackendOntapSanChapType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeviceNetappBackendOntapSanChapType{`,
		`ChapUsername:` + fmt.Sprintf("%v", this.ChapUsername) + `,`,
		`ChapTargetUsername:` + fmt.Sprintf("%v", this.ChapTargetUsername) + `,`,
		`ChapInitiatorSecret:` + strings.Replace(fmt.Sprintf("%v", this.ChapInitiatorSecret), "SecretType", "schema.SecretType", 1) + `,`,
		`ChapTargetInitiatorSecret:` + strings.Replace(fmt.Sprintf("%v", this.ChapTargetInitiatorSecret), "SecretType", "schema.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapNasType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForStorage := "[]*OntapVirtualStoragePoolType{"
	for _, f := range this.Storage {
		repeatedStringForStorage += strings.Replace(f.String(), "OntapVirtualStoragePoolType", "OntapVirtualStoragePoolType", 1) + ","
	}
	repeatedStringForStorage += "}"
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapNasType{`,
		`StorageDriverName:` + fmt.Sprintf("%v", this.StorageDriverName) + `,`,
		`BackendName:` + fmt.Sprintf("%v", this.BackendName) + `,`,
		`ManagementLif:` + fmt.Sprintf("%v", this.ManagementLif) + `,`,
		`DataLif:` + fmt.Sprintf("%v", this.DataLif) + `,`,
		`Svm:` + fmt.Sprintf("%v", this.Svm) + `,`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`Password:` + strings.Replace(fmt.Sprintf("%v", this.Password), "SecretType", "schema.SecretType", 1) + `,`,
		`AutoExportPolicy:` + fmt.Sprintf("%v", this.AutoExportPolicy) + `,`,
		`AutoExportCidrs:` + strings.Replace(fmt.Sprintf("%v", this.AutoExportCidrs), "PrefixStringListType", "views.PrefixStringListType", 1) + `,`,
		`StoragePrefix:` + fmt.Sprintf("%v", this.StoragePrefix) + `,`,
		`LimitAggregateUsage:` + fmt.Sprintf("%v", this.LimitAggregateUsage) + `,`,
		`LimitVolumeSize:` + fmt.Sprintf("%v", this.LimitVolumeSize) + `,`,
		`NfsMountOptions:` + fmt.Sprintf("%v", this.NfsMountOptions) + `,`,
		`VolumeDefaults:` + strings.Replace(this.VolumeDefaults.String(), "OntapVolumeDefaults", "OntapVolumeDefaults", 1) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`Storage:` + repeatedStringForStorage + `,`,
		`ClientCertificate:` + fmt.Sprintf("%v", this.ClientCertificate) + `,`,
		`ClientPrivateKey:` + strings.Replace(fmt.Sprintf("%v", this.ClientPrivateKey), "SecretType", "schema.SecretType", 1) + `,`,
		`TrustedCaCertificate:` + fmt.Sprintf("%v", this.TrustedCaCertificate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapNasType_ManagementLifIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapNasType_ManagementLifIp{`,
		`ManagementLifIp:` + fmt.Sprintf("%v", this.ManagementLifIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName{`,
		`ManagementLifDnsName:` + fmt.Sprintf("%v", this.ManagementLifDnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapNasType_DataLifIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapNasType_DataLifIp{`,
		`DataLifIp:` + fmt.Sprintf("%v", this.DataLifIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapNasType_DataLifDnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapNasType_DataLifDnsName{`,
		`DataLifDnsName:` + fmt.Sprintf("%v", this.DataLifDnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OntapVolumeDefaults) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OntapVolumeDefaults{`,
		`SpaceReserve:` + fmt.Sprintf("%v", this.SpaceReserve) + `,`,
		`SnapshotPolicy:` + fmt.Sprintf("%v", this.SnapshotPolicy) + `,`,
		`SnapshotReserve:` + fmt.Sprintf("%v", this.SnapshotReserve) + `,`,
		`SplitOnClone:` + fmt.Sprintf("%v", this.SplitOnClone) + `,`,
		`Encryption:` + fmt.Sprintf("%v", this.Encryption) + `,`,
		`UnixPermissions:` + fmt.Sprintf("%v", this.UnixPermissions) + `,`,
		`SnapshotDir:` + fmt.Sprintf("%v", this.SnapshotDir) + `,`,
		`ExportPolicy:` + fmt.Sprintf("%v", this.ExportPolicy) + `,`,
		`SecurityStyle:` + fmt.Sprintf("%v", this.SecurityStyle) + `,`,
		`TieringPolicy:` + fmt.Sprintf("%v", this.TieringPolicy) + `,`,
		`QosPolicyChoice:` + fmt.Sprintf("%v", this.QosPolicyChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OntapVolumeDefaults_NoQos) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OntapVolumeDefaults_NoQos{`,
		`NoQos:` + strings.Replace(fmt.Sprintf("%v", this.NoQos), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OntapVolumeDefaults_QosPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OntapVolumeDefaults_QosPolicy{`,
		`QosPolicy:` + fmt.Sprintf("%v", this.QosPolicy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OntapVolumeDefaults_AdaptiveQosPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OntapVolumeDefaults_AdaptiveQosPolicy{`,
		`AdaptiveQosPolicy:` + fmt.Sprintf("%v", this.AdaptiveQosPolicy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OntapVirtualStoragePoolType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&OntapVirtualStoragePoolType{`,
		`Labels:` + mapStringForLabels + `,`,
		`Zone:` + fmt.Sprintf("%v", this.Zone) + `,`,
		`VolumeDefaults:` + strings.Replace(this.VolumeDefaults.String(), "OntapVolumeDefaults", "OntapVolumeDefaults", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageDeviceType) String() string {
	if this == nil {
		return "nil"
	}
	keysForAdvancedAdvancedParameters := make([]string, 0, len(this.AdvancedAdvancedParameters))
	for k, _ := range this.AdvancedAdvancedParameters {
		keysForAdvancedAdvancedParameters = append(keysForAdvancedAdvancedParameters, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAdvancedAdvancedParameters)
	mapStringForAdvancedAdvancedParameters := "map[string]string{"
	for _, k := range keysForAdvancedAdvancedParameters {
		mapStringForAdvancedAdvancedParameters += fmt.Sprintf("%v: %v,", k, this.AdvancedAdvancedParameters[k])
	}
	mapStringForAdvancedAdvancedParameters += "}"
	s := strings.Join([]string{`&FleetStorageDeviceType{`,
		`StorageDevice:` + fmt.Sprintf("%v", this.StorageDevice) + `,`,
		`AdvancedAdvancedParameters:` + mapStringForAdvancedAdvancedParameters + `,`,
		`DeviceChoice:` + fmt.Sprintf("%v", this.DeviceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageDeviceType_NetappTrident) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStorageDeviceType_NetappTrident{`,
		`NetappTrident:` + strings.Replace(fmt.Sprintf("%v", this.NetappTrident), "StorageDeviceNetappTridentType", "StorageDeviceNetappTridentType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageDeviceType_PureServiceOrchestrator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStorageDeviceType_PureServiceOrchestrator{`,
		`PureServiceOrchestrator:` + strings.Replace(fmt.Sprintf("%v", this.PureServiceOrchestrator), "StorageDevicePureStorageServiceOrchestratorType", "StorageDevicePureStorageServiceOrchestratorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageDeviceType_OpenebsEnterprise) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStorageDeviceType_OpenebsEnterprise{`,
		`OpenebsEnterprise:` + strings.Replace(fmt.Sprintf("%v", this.OpenebsEnterprise), "StorageDeviceOpenebsEnterpriseType", "StorageDeviceOpenebsEnterpriseType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageDeviceType_CustomStorage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStorageDeviceType_CustomStorage{`,
		`CustomStorage:` + strings.Replace(fmt.Sprintf("%v", this.CustomStorage), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageDeviceListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForStorageDevices := "[]*FleetStorageDeviceType{"
	for _, f := range this.StorageDevices {
		repeatedStringForStorageDevices += strings.Replace(f.String(), "FleetStorageDeviceType", "FleetStorageDeviceType", 1) + ","
	}
	repeatedStringForStorageDevices += "}"
	s := strings.Join([]string{`&FleetStorageDeviceListType{`,
		`StorageDevices:` + repeatedStringForStorageDevices + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageClassDellIsilonF800Type) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageClassDellIsilonF800Type{`,
		`HttpsChoice:` + fmt.Sprintf("%v", this.HttpsChoice) + `,`,
		`IscsiAccessZone:` + fmt.Sprintf("%v", this.IscsiAccessZone) + `,`,
		`BasePath:` + fmt.Sprintf("%v", this.BasePath) + `,`,
		`RootClientEnable:` + fmt.Sprintf("%v", this.RootClientEnable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageClassDellIsilonF800Type_AzServiceName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageClassDellIsilonF800Type_AzServiceName{`,
		`AzServiceName:` + fmt.Sprintf("%v", this.AzServiceName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageClassDellIsilonF800Type_AzServiceIpAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageClassDellIsilonF800Type_AzServiceIpAddress{`,
		`AzServiceIpAddress:` + fmt.Sprintf("%v", this.AzServiceIpAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageClassHPENimbusStorageAf40Type) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageClassHPENimbusStorageAf40Type{`,
		`PerfPolicy:` + fmt.Sprintf("%v", this.PerfPolicy) + `,`,
		`LimitIops:` + fmt.Sprintf("%v", this.LimitIops) + `,`,
		`LimitMbps:` + fmt.Sprintf("%v", this.LimitMbps) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageClassOpenebsEnterpriseType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageClassOpenebsEnterpriseType{`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`Replication:` + fmt.Sprintf("%v", this.Replication) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageClassNetappTridentType) String() string {
	if this == nil {
		return "nil"
	}
	keysForSelector := make([]string, 0, len(this.Selector))
	for k, _ := range this.Selector {
		keysForSelector = append(keysForSelector, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSelector)
	mapStringForSelector := "map[string]string{"
	for _, k := range keysForSelector {
		mapStringForSelector += fmt.Sprintf("%v: %v,", k, this.Selector[k])
	}
	mapStringForSelector += "}"
	s := strings.Join([]string{`&StorageClassNetappTridentType{`,
		`Selector:` + mapStringForSelector + `,`,
		`StoragePools:` + fmt.Sprintf("%v", this.StoragePools) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageClassPureServiceOrchestratorType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageClassPureServiceOrchestratorType{`,
		`Backend:` + fmt.Sprintf("%v", this.Backend) + `,`,
		`IopsLimit:` + fmt.Sprintf("%v", this.IopsLimit) + `,`,
		`BandwidthLimit:` + fmt.Sprintf("%v", this.BandwidthLimit) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageClassCustomType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageClassCustomType{`,
		`Yaml:` + fmt.Sprintf("%v", this.Yaml) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageClassType) String() string {
	if this == nil {
		return "nil"
	}
	keysForAdvancedStorageParameters := make([]string, 0, len(this.AdvancedStorageParameters))
	for k, _ := range this.AdvancedStorageParameters {
		keysForAdvancedStorageParameters = append(keysForAdvancedStorageParameters, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAdvancedStorageParameters)
	mapStringForAdvancedStorageParameters := "map[string]string{"
	for _, k := range keysForAdvancedStorageParameters {
		mapStringForAdvancedStorageParameters += fmt.Sprintf("%v: %v,", k, this.AdvancedStorageParameters[k])
	}
	mapStringForAdvancedStorageParameters += "}"
	s := strings.Join([]string{`&FleetStorageClassType{`,
		`StorageDevice:` + fmt.Sprintf("%v", this.StorageDevice) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`DefaultStorageClass:` + fmt.Sprintf("%v", this.DefaultStorageClass) + `,`,
		`AdvancedStorageParameters:` + mapStringForAdvancedStorageParameters + `,`,
		`StorageClassName:` + fmt.Sprintf("%v", this.StorageClassName) + `,`,
		`DeviceChoice:` + fmt.Sprintf("%v", this.DeviceChoice) + `,`,
		`ReclaimPolicy:` + fmt.Sprintf("%v", this.ReclaimPolicy) + `,`,
		`AllowVolumeExpansion:` + fmt.Sprintf("%v", this.AllowVolumeExpansion) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageClassType_NetappTrident) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStorageClassType_NetappTrident{`,
		`NetappTrident:` + strings.Replace(fmt.Sprintf("%v", this.NetappTrident), "StorageClassNetappTridentType", "StorageClassNetappTridentType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageClassType_PureServiceOrchestrator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStorageClassType_PureServiceOrchestrator{`,
		`PureServiceOrchestrator:` + strings.Replace(fmt.Sprintf("%v", this.PureServiceOrchestrator), "StorageClassPureServiceOrchestratorType", "StorageClassPureServiceOrchestratorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageClassType_OpenebsEnterprise) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStorageClassType_OpenebsEnterprise{`,
		`OpenebsEnterprise:` + strings.Replace(fmt.Sprintf("%v", this.OpenebsEnterprise), "StorageClassOpenebsEnterpriseType", "StorageClassOpenebsEnterpriseType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageClassType_CustomStorage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStorageClassType_CustomStorage{`,
		`CustomStorage:` + strings.Replace(fmt.Sprintf("%v", this.CustomStorage), "StorageClassCustomType", "StorageClassCustomType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageClassListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForStorageClasses := "[]*FleetStorageClassType{"
	for _, f := range this.StorageClasses {
		repeatedStringForStorageClasses += strings.Replace(f.String(), "FleetStorageClassType", "FleetStorageClassType", 1) + ","
	}
	repeatedStringForStorageClasses += "}"
	s := strings.Join([]string{`&FleetStorageClassListType{`,
		`StorageClasses:` + repeatedStringForStorageClasses + `,`,
		`}`,
	}, "")
	return s
}
func (this *BondLacpType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BondLacpType{`,
		`Rate:` + fmt.Sprintf("%v", this.Rate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetBondDeviceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetBondDeviceType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Devices:` + fmt.Sprintf("%v", this.Devices) + `,`,
		`LacpChoice:` + fmt.Sprintf("%v", this.LacpChoice) + `,`,
		`LinkPollingInterval:` + fmt.Sprintf("%v", this.LinkPollingInterval) + `,`,
		`LinkUpDelay:` + fmt.Sprintf("%v", this.LinkUpDelay) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetBondDeviceType_Lacp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetBondDeviceType_Lacp{`,
		`Lacp:` + strings.Replace(fmt.Sprintf("%v", this.Lacp), "BondLacpType", "BondLacpType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetBondDeviceType_ActiveBackup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetBondDeviceType_ActiveBackup{`,
		`ActiveBackup:` + strings.Replace(fmt.Sprintf("%v", this.ActiveBackup), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetBondDevicesListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForBondDevices := "[]*FleetBondDeviceType{"
	for _, f := range this.BondDevices {
		repeatedStringForBondDevices += strings.Replace(f.String(), "FleetBondDeviceType", "FleetBondDeviceType", 1) + ","
	}
	repeatedStringForBondDevices += "}"
	s := strings.Join([]string{`&FleetBondDevicesListType{`,
		`BondDevices:` + repeatedStringForBondDevices + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageStaticRoutesListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForStorageRoutes := "[]*StaticRouteType{"
	for _, f := range this.StorageRoutes {
		repeatedStringForStorageRoutes += strings.Replace(fmt.Sprintf("%v", f), "StaticRouteType", "schema.StaticRouteType", 1) + ","
	}
	repeatedStringForStorageRoutes += "}"
	s := strings.Join([]string{`&FleetStorageStaticRoutesListType{`,
		`StorageRoutes:` + repeatedStringForStorageRoutes + `,`,
		`}`,
	}, "")
	return s
}
func (this *VGPUConfiguration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VGPUConfiguration{`,
		`ServerAddress:` + fmt.Sprintf("%v", this.ServerAddress) + `,`,
		`ServerPort:` + fmt.Sprintf("%v", this.ServerPort) + `,`,
		`FeatureType:` + fmt.Sprintf("%v", this.FeatureType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VMConfiguration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VMConfiguration{`,
		`}`,
	}, "")
	return s
}
func (this *BGPConfiguration) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPeers := "[]*Peer{"
	for _, f := range this.Peers {
		repeatedStringForPeers += strings.Replace(fmt.Sprintf("%v", f), "Peer", "bgp.Peer", 1) + ","
	}
	repeatedStringForPeers += "}"
	s := strings.Join([]string{`&BGPConfiguration{`,
		`Peers:` + repeatedStringForPeers + `,`,
		`Asn:` + fmt.Sprintf("%v", this.Asn) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalControlPlaneType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalControlPlaneType{`,
		`NetworkChoice:` + fmt.Sprintf("%v", this.NetworkChoice) + `,`,
		`BgpConfig:` + strings.Replace(this.BgpConfig.String(), "BGPConfiguration", "BGPConfiguration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalControlPlaneType_InsideVn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalControlPlaneType_InsideVn{`,
		`InsideVn:` + strings.Replace(fmt.Sprintf("%v", this.InsideVn), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalControlPlaneType_OutsideVn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalControlPlaneType_OutsideVn{`,
		`OutsideVn:` + strings.Replace(fmt.Sprintf("%v", this.OutsideVn), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDevices := "[]*DeviceInstanceType{"
	for _, f := range this.Devices {
		repeatedStringForDevices += strings.Replace(f.String(), "DeviceInstanceType", "DeviceInstanceType", 1) + ","
	}
	repeatedStringForDevices += "}"
	repeatedStringForNetworkConnectors := "[]*ObjectRefType{"
	for _, f := range this.NetworkConnectors {
		repeatedStringForNetworkConnectors += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForNetworkConnectors += "}"
	repeatedStringForNetworkFirewall := "[]*ObjectRefType{"
	for _, f := range this.NetworkFirewall {
		repeatedStringForNetworkFirewall += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForNetworkFirewall += "}"
	repeatedStringForOutsideVirtualNetwork := "[]*ObjectRefType{"
	for _, f := range this.OutsideVirtualNetwork {
		repeatedStringForOutsideVirtualNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForOutsideVirtualNetwork += "}"
	repeatedStringForInsideVirtualNetwork := "[]*ObjectRefType{"
	for _, f := range this.InsideVirtualNetwork {
		repeatedStringForInsideVirtualNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForInsideVirtualNetwork += "}"
	repeatedStringForSingleSite := "[]*ObjectRefType{"
	for _, f := range this.SingleSite {
		repeatedStringForSingleSite += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSingleSite += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`FleetLabel:` + fmt.Sprintf("%v", this.FleetLabel) + `,`,
		`VolterraSoftwareVersion:` + fmt.Sprintf("%v", this.VolterraSoftwareVersion) + `,`,
		`Devices:` + repeatedStringForDevices + `,`,
		`NetworkConnectors:` + repeatedStringForNetworkConnectors + `,`,
		`NetworkFirewall:` + repeatedStringForNetworkFirewall + `,`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`OutsideVirtualNetwork:` + repeatedStringForOutsideVirtualNetwork + `,`,
		`InsideVirtualNetwork:` + repeatedStringForInsideVirtualNetwork + `,`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`BondChoice:` + fmt.Sprintf("%v", this.BondChoice) + `,`,
		`StorageInterfaceChoice:` + fmt.Sprintf("%v", this.StorageInterfaceChoice) + `,`,
		`StorageDeviceChoice:` + fmt.Sprintf("%v", this.StorageDeviceChoice) + `,`,
		`StorageClassChoice:` + fmt.Sprintf("%v", this.StorageClassChoice) + `,`,
		`DcClusterGroupChoice:` + fmt.Sprintf("%v", this.DcClusterGroupChoice) + `,`,
		`GpuChoice:` + fmt.Sprintf("%v", this.GpuChoice) + `,`,
		`EtcdClusterNetwork:` + fmt.Sprintf("%v", this.EtcdClusterNetwork) + `,`,
		`StorageStaticRoutesChoice:` + fmt.Sprintf("%v", this.StorageStaticRoutesChoice) + `,`,
		`EnableDefaultFleetConfigDownload:` + fmt.Sprintf("%v", this.EnableDefaultFleetConfigDownload) + `,`,
		`FleetType:` + fmt.Sprintf("%v", this.FleetType) + `,`,
		`SingleSite:` + repeatedStringForSingleSite + `,`,
		`LogsReceiverChoice:` + fmt.Sprintf("%v", this.LogsReceiverChoice) + `,`,
		`UsbPolicyChoice:` + fmt.Sprintf("%v", this.UsbPolicyChoice) + `,`,
		`K8SCluster:` + strings.Replace(fmt.Sprintf("%v", this.K8SCluster), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`LocalControlPlane:` + strings.Replace(this.LocalControlPlane.String(), "LocalControlPlaneType", "LocalControlPlaneType", 1) + `,`,
		`FlowExporterChoice:` + fmt.Sprintf("%v", this.FlowExporterChoice) + `,`,
		`VmChoice:` + fmt.Sprintf("%v", this.VmChoice) + `,`,
		`ViewInternal:` + strings.Replace(fmt.Sprintf("%v", this.ViewInternal), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`GeneratedYamls:` + fmt.Sprintf("%v", this.GeneratedYamls) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_InterfaceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_InterfaceList{`,
		`InterfaceList:` + strings.Replace(fmt.Sprintf("%v", this.InterfaceList), "FleetInterfaceListType", "FleetInterfaceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_LegacyDevices) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_LegacyDevices{`,
		`LegacyDevices:` + strings.Replace(fmt.Sprintf("%v", this.LegacyDevices), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_NoBondDevices) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_NoBondDevices{`,
		`NoBondDevices:` + strings.Replace(fmt.Sprintf("%v", this.NoBondDevices), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_BondDeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_BondDeviceList{`,
		`BondDeviceList:` + strings.Replace(fmt.Sprintf("%v", this.BondDeviceList), "FleetBondDevicesListType", "FleetBondDevicesListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_NoStorageInterfaces) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_NoStorageInterfaces{`,
		`NoStorageInterfaces:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageInterfaces), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_StorageInterfaceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_StorageInterfaceList{`,
		`StorageInterfaceList:` + strings.Replace(fmt.Sprintf("%v", this.StorageInterfaceList), "FleetInterfaceListType", "FleetInterfaceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_NoStorageDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_NoStorageDevice{`,
		`NoStorageDevice:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageDevice), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_StorageDeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_StorageDeviceList{`,
		`StorageDeviceList:` + strings.Replace(fmt.Sprintf("%v", this.StorageDeviceList), "FleetStorageDeviceListType", "FleetStorageDeviceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DefaultStorageClass) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DefaultStorageClass{`,
		`DefaultStorageClass:` + strings.Replace(fmt.Sprintf("%v", this.DefaultStorageClass), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_StorageClassList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_StorageClassList{`,
		`StorageClassList:` + strings.Replace(fmt.Sprintf("%v", this.StorageClassList), "FleetStorageClassListType", "FleetStorageClassListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_NoDcClusterGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_NoDcClusterGroup{`,
		`NoDcClusterGroup:` + strings.Replace(fmt.Sprintf("%v", this.NoDcClusterGroup), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DcClusterGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DcClusterGroup{`,
		`DcClusterGroup:` + strings.Replace(fmt.Sprintf("%v", this.DcClusterGroup), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DisableGpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DisableGpu{`,
		`DisableGpu:` + strings.Replace(fmt.Sprintf("%v", this.DisableGpu), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_EnableGpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_EnableGpu{`,
		`EnableGpu:` + strings.Replace(fmt.Sprintf("%v", this.EnableGpu), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_NoStorageStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_NoStorageStaticRoutes{`,
		`NoStorageStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageStaticRoutes), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_StorageStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_StorageStaticRoutes{`,
		`StorageStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.StorageStaticRoutes), "FleetStorageStaticRoutesListType", "FleetStorageStaticRoutesListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DcClusterGroupInside) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DcClusterGroupInside{`,
		`DcClusterGroupInside:` + strings.Replace(fmt.Sprintf("%v", this.DcClusterGroupInside), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DefaultInterfaces) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DefaultInterfaces{`,
		`DefaultInterfaces:` + strings.Replace(fmt.Sprintf("%v", this.DefaultInterfaces), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_LogsStreamingDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_LogsStreamingDisabled{`,
		`LogsStreamingDisabled:` + strings.Replace(fmt.Sprintf("%v", this.LogsStreamingDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_LogReceiver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_LogReceiver{`,
		`LogReceiver:` + strings.Replace(fmt.Sprintf("%v", this.LogReceiver), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DenyAllUsb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DenyAllUsb{`,
		`DenyAllUsb:` + strings.Replace(fmt.Sprintf("%v", this.DenyAllUsb), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AllowAllUsb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AllowAllUsb{`,
		`AllowAllUsb:` + strings.Replace(fmt.Sprintf("%v", this.AllowAllUsb), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_UsbPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_UsbPolicy{`,
		`UsbPolicy:` + strings.Replace(fmt.Sprintf("%v", this.UsbPolicy), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_EnableVgpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_EnableVgpu{`,
		`EnableVgpu:` + strings.Replace(fmt.Sprintf("%v", this.EnableVgpu), "VGPUConfiguration", "VGPUConfiguration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DisableFlowExport) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DisableFlowExport{`,
		`DisableFlowExport:` + strings.Replace(fmt.Sprintf("%v", this.DisableFlowExport), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_EnableFlowExport) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_EnableFlowExport{`,
		`EnableFlowExport:` + strings.Replace(fmt.Sprintf("%v", this.EnableFlowExport), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DisableVm) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DisableVm{`,
		`DisableVm:` + strings.Replace(fmt.Sprintf("%v", this.DisableVm), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_EnableVm) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_EnableVm{`,
		`EnableVm:` + strings.Replace(fmt.Sprintf("%v", this.EnableVm), "VMConfiguration", "VMConfiguration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNetworkConnectors := "[]*ObjectRefType{"
	for _, f := range this.NetworkConnectors {
		repeatedStringForNetworkConnectors += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForNetworkConnectors += "}"
	repeatedStringForNetworkFirewall := "[]*ObjectRefType{"
	for _, f := range this.NetworkFirewall {
		repeatedStringForNetworkFirewall += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForNetworkFirewall += "}"
	repeatedStringForOutsideVirtualNetwork := "[]*ObjectRefType{"
	for _, f := range this.OutsideVirtualNetwork {
		repeatedStringForOutsideVirtualNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForOutsideVirtualNetwork += "}"
	repeatedStringForInsideVirtualNetwork := "[]*ObjectRefType{"
	for _, f := range this.InsideVirtualNetwork {
		repeatedStringForInsideVirtualNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForInsideVirtualNetwork += "}"
	s := strings.Join([]string{`&CreateSpecType{`,
		`FleetLabel:` + fmt.Sprintf("%v", this.FleetLabel) + `,`,
		`VolterraSoftwareVersion:` + fmt.Sprintf("%v", this.VolterraSoftwareVersion) + `,`,
		`NetworkConnectors:` + repeatedStringForNetworkConnectors + `,`,
		`NetworkFirewall:` + repeatedStringForNetworkFirewall + `,`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`OutsideVirtualNetwork:` + repeatedStringForOutsideVirtualNetwork + `,`,
		`InsideVirtualNetwork:` + repeatedStringForInsideVirtualNetwork + `,`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`BondChoice:` + fmt.Sprintf("%v", this.BondChoice) + `,`,
		`StorageInterfaceChoice:` + fmt.Sprintf("%v", this.StorageInterfaceChoice) + `,`,
		`StorageDeviceChoice:` + fmt.Sprintf("%v", this.StorageDeviceChoice) + `,`,
		`StorageClassChoice:` + fmt.Sprintf("%v", this.StorageClassChoice) + `,`,
		`DcClusterGroupChoice:` + fmt.Sprintf("%v", this.DcClusterGroupChoice) + `,`,
		`GpuChoice:` + fmt.Sprintf("%v", this.GpuChoice) + `,`,
		`StorageStaticRoutesChoice:` + fmt.Sprintf("%v", this.StorageStaticRoutesChoice) + `,`,
		`EnableDefaultFleetConfigDownload:` + fmt.Sprintf("%v", this.EnableDefaultFleetConfigDownload) + `,`,
		`LogsReceiverChoice:` + fmt.Sprintf("%v", this.LogsReceiverChoice) + `,`,
		`UsbPolicyChoice:` + fmt.Sprintf("%v", this.UsbPolicyChoice) + `,`,
		`VmChoice:` + fmt.Sprintf("%v", this.VmChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_InterfaceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_InterfaceList{`,
		`InterfaceList:` + strings.Replace(fmt.Sprintf("%v", this.InterfaceList), "FleetInterfaceListType", "FleetInterfaceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DeviceList{`,
		`DeviceList:` + strings.Replace(fmt.Sprintf("%v", this.DeviceList), "FleetDeviceListType", "FleetDeviceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_NoBondDevices) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_NoBondDevices{`,
		`NoBondDevices:` + strings.Replace(fmt.Sprintf("%v", this.NoBondDevices), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_BondDeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_BondDeviceList{`,
		`BondDeviceList:` + strings.Replace(fmt.Sprintf("%v", this.BondDeviceList), "FleetBondDevicesListType", "FleetBondDevicesListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_NoStorageInterfaces) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_NoStorageInterfaces{`,
		`NoStorageInterfaces:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageInterfaces), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_StorageInterfaceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_StorageInterfaceList{`,
		`StorageInterfaceList:` + strings.Replace(fmt.Sprintf("%v", this.StorageInterfaceList), "FleetInterfaceListType", "FleetInterfaceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_NoStorageDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_NoStorageDevice{`,
		`NoStorageDevice:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageDevice), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_StorageDeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_StorageDeviceList{`,
		`StorageDeviceList:` + strings.Replace(fmt.Sprintf("%v", this.StorageDeviceList), "FleetStorageDeviceListType", "FleetStorageDeviceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DefaultStorageClass) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DefaultStorageClass{`,
		`DefaultStorageClass:` + strings.Replace(fmt.Sprintf("%v", this.DefaultStorageClass), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_StorageClassList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_StorageClassList{`,
		`StorageClassList:` + strings.Replace(fmt.Sprintf("%v", this.StorageClassList), "FleetStorageClassListType", "FleetStorageClassListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_NoDcClusterGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_NoDcClusterGroup{`,
		`NoDcClusterGroup:` + strings.Replace(fmt.Sprintf("%v", this.NoDcClusterGroup), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DcClusterGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DcClusterGroup{`,
		`DcClusterGroup:` + strings.Replace(fmt.Sprintf("%v", this.DcClusterGroup), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DisableGpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DisableGpu{`,
		`DisableGpu:` + strings.Replace(fmt.Sprintf("%v", this.DisableGpu), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_EnableGpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_EnableGpu{`,
		`EnableGpu:` + strings.Replace(fmt.Sprintf("%v", this.EnableGpu), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_NoStorageStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_NoStorageStaticRoutes{`,
		`NoStorageStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageStaticRoutes), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_StorageStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_StorageStaticRoutes{`,
		`StorageStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.StorageStaticRoutes), "FleetStorageStaticRoutesListType", "FleetStorageStaticRoutesListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DcClusterGroupInside) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DcClusterGroupInside{`,
		`DcClusterGroupInside:` + strings.Replace(fmt.Sprintf("%v", this.DcClusterGroupInside), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DefaultConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DefaultConfig{`,
		`DefaultConfig:` + strings.Replace(fmt.Sprintf("%v", this.DefaultConfig), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_LogsStreamingDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_LogsStreamingDisabled{`,
		`LogsStreamingDisabled:` + strings.Replace(fmt.Sprintf("%v", this.LogsStreamingDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_LogReceiver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_LogReceiver{`,
		`LogReceiver:` + strings.Replace(fmt.Sprintf("%v", this.LogReceiver), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DenyAllUsb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DenyAllUsb{`,
		`DenyAllUsb:` + strings.Replace(fmt.Sprintf("%v", this.DenyAllUsb), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AllowAllUsb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AllowAllUsb{`,
		`AllowAllUsb:` + strings.Replace(fmt.Sprintf("%v", this.AllowAllUsb), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_UsbPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_UsbPolicy{`,
		`UsbPolicy:` + strings.Replace(fmt.Sprintf("%v", this.UsbPolicy), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_EnableVgpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_EnableVgpu{`,
		`EnableVgpu:` + strings.Replace(fmt.Sprintf("%v", this.EnableVgpu), "VGPUConfiguration", "VGPUConfiguration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DisableVm) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DisableVm{`,
		`DisableVm:` + strings.Replace(fmt.Sprintf("%v", this.DisableVm), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_EnableVm) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_EnableVm{`,
		`EnableVm:` + strings.Replace(fmt.Sprintf("%v", this.EnableVm), "VMConfiguration", "VMConfiguration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNetworkConnectors := "[]*ObjectRefType{"
	for _, f := range this.NetworkConnectors {
		repeatedStringForNetworkConnectors += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForNetworkConnectors += "}"
	repeatedStringForNetworkFirewall := "[]*ObjectRefType{"
	for _, f := range this.NetworkFirewall {
		repeatedStringForNetworkFirewall += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForNetworkFirewall += "}"
	repeatedStringForOutsideVirtualNetwork := "[]*ObjectRefType{"
	for _, f := range this.OutsideVirtualNetwork {
		repeatedStringForOutsideVirtualNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForOutsideVirtualNetwork += "}"
	repeatedStringForInsideVirtualNetwork := "[]*ObjectRefType{"
	for _, f := range this.InsideVirtualNetwork {
		repeatedStringForInsideVirtualNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForInsideVirtualNetwork += "}"
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`VolterraSoftwareVersion:` + fmt.Sprintf("%v", this.VolterraSoftwareVersion) + `,`,
		`NetworkConnectors:` + repeatedStringForNetworkConnectors + `,`,
		`NetworkFirewall:` + repeatedStringForNetworkFirewall + `,`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`OutsideVirtualNetwork:` + repeatedStringForOutsideVirtualNetwork + `,`,
		`InsideVirtualNetwork:` + repeatedStringForInsideVirtualNetwork + `,`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`BondChoice:` + fmt.Sprintf("%v", this.BondChoice) + `,`,
		`StorageInterfaceChoice:` + fmt.Sprintf("%v", this.StorageInterfaceChoice) + `,`,
		`StorageDeviceChoice:` + fmt.Sprintf("%v", this.StorageDeviceChoice) + `,`,
		`StorageClassChoice:` + fmt.Sprintf("%v", this.StorageClassChoice) + `,`,
		`DcClusterGroupChoice:` + fmt.Sprintf("%v", this.DcClusterGroupChoice) + `,`,
		`GpuChoice:` + fmt.Sprintf("%v", this.GpuChoice) + `,`,
		`StorageStaticRoutesChoice:` + fmt.Sprintf("%v", this.StorageStaticRoutesChoice) + `,`,
		`EnableDefaultFleetConfigDownload:` + fmt.Sprintf("%v", this.EnableDefaultFleetConfigDownload) + `,`,
		`LogsReceiverChoice:` + fmt.Sprintf("%v", this.LogsReceiverChoice) + `,`,
		`UsbPolicyChoice:` + fmt.Sprintf("%v", this.UsbPolicyChoice) + `,`,
		`VmChoice:` + fmt.Sprintf("%v", this.VmChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_InterfaceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_InterfaceList{`,
		`InterfaceList:` + strings.Replace(fmt.Sprintf("%v", this.InterfaceList), "FleetInterfaceListType", "FleetInterfaceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DeviceList{`,
		`DeviceList:` + strings.Replace(fmt.Sprintf("%v", this.DeviceList), "FleetDeviceListType", "FleetDeviceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_NoBondDevices) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_NoBondDevices{`,
		`NoBondDevices:` + strings.Replace(fmt.Sprintf("%v", this.NoBondDevices), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_BondDeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_BondDeviceList{`,
		`BondDeviceList:` + strings.Replace(fmt.Sprintf("%v", this.BondDeviceList), "FleetBondDevicesListType", "FleetBondDevicesListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_NoStorageInterfaces) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_NoStorageInterfaces{`,
		`NoStorageInterfaces:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageInterfaces), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_StorageInterfaceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_StorageInterfaceList{`,
		`StorageInterfaceList:` + strings.Replace(fmt.Sprintf("%v", this.StorageInterfaceList), "FleetInterfaceListType", "FleetInterfaceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_NoStorageDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_NoStorageDevice{`,
		`NoStorageDevice:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageDevice), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_StorageDeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_StorageDeviceList{`,
		`StorageDeviceList:` + strings.Replace(fmt.Sprintf("%v", this.StorageDeviceList), "FleetStorageDeviceListType", "FleetStorageDeviceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DefaultStorageClass) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DefaultStorageClass{`,
		`DefaultStorageClass:` + strings.Replace(fmt.Sprintf("%v", this.DefaultStorageClass), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_StorageClassList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_StorageClassList{`,
		`StorageClassList:` + strings.Replace(fmt.Sprintf("%v", this.StorageClassList), "FleetStorageClassListType", "FleetStorageClassListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_NoDcClusterGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_NoDcClusterGroup{`,
		`NoDcClusterGroup:` + strings.Replace(fmt.Sprintf("%v", this.NoDcClusterGroup), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DcClusterGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DcClusterGroup{`,
		`DcClusterGroup:` + strings.Replace(fmt.Sprintf("%v", this.DcClusterGroup), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DisableGpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DisableGpu{`,
		`DisableGpu:` + strings.Replace(fmt.Sprintf("%v", this.DisableGpu), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_EnableGpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_EnableGpu{`,
		`EnableGpu:` + strings.Replace(fmt.Sprintf("%v", this.EnableGpu), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_NoStorageStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_NoStorageStaticRoutes{`,
		`NoStorageStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageStaticRoutes), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_StorageStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_StorageStaticRoutes{`,
		`StorageStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.StorageStaticRoutes), "FleetStorageStaticRoutesListType", "FleetStorageStaticRoutesListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DcClusterGroupInside) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DcClusterGroupInside{`,
		`DcClusterGroupInside:` + strings.Replace(fmt.Sprintf("%v", this.DcClusterGroupInside), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DefaultConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DefaultConfig{`,
		`DefaultConfig:` + strings.Replace(fmt.Sprintf("%v", this.DefaultConfig), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_LogsStreamingDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_LogsStreamingDisabled{`,
		`LogsStreamingDisabled:` + strings.Replace(fmt.Sprintf("%v", this.LogsStreamingDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_LogReceiver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_LogReceiver{`,
		`LogReceiver:` + strings.Replace(fmt.Sprintf("%v", this.LogReceiver), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DenyAllUsb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DenyAllUsb{`,
		`DenyAllUsb:` + strings.Replace(fmt.Sprintf("%v", this.DenyAllUsb), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AllowAllUsb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AllowAllUsb{`,
		`AllowAllUsb:` + strings.Replace(fmt.Sprintf("%v", this.AllowAllUsb), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_UsbPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_UsbPolicy{`,
		`UsbPolicy:` + strings.Replace(fmt.Sprintf("%v", this.UsbPolicy), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_EnableVgpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_EnableVgpu{`,
		`EnableVgpu:` + strings.Replace(fmt.Sprintf("%v", this.EnableVgpu), "VGPUConfiguration", "VGPUConfiguration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DisableVm) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DisableVm{`,
		`DisableVm:` + strings.Replace(fmt.Sprintf("%v", this.DisableVm), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_EnableVm) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_EnableVm{`,
		`EnableVm:` + strings.Replace(fmt.Sprintf("%v", this.EnableVm), "VMConfiguration", "VMConfiguration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNetworkConnectors := "[]*ObjectRefType{"
	for _, f := range this.NetworkConnectors {
		repeatedStringForNetworkConnectors += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForNetworkConnectors += "}"
	repeatedStringForNetworkFirewall := "[]*ObjectRefType{"
	for _, f := range this.NetworkFirewall {
		repeatedStringForNetworkFirewall += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForNetworkFirewall += "}"
	repeatedStringForOutsideVirtualNetwork := "[]*ObjectRefType{"
	for _, f := range this.OutsideVirtualNetwork {
		repeatedStringForOutsideVirtualNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForOutsideVirtualNetwork += "}"
	repeatedStringForInsideVirtualNetwork := "[]*ObjectRefType{"
	for _, f := range this.InsideVirtualNetwork {
		repeatedStringForInsideVirtualNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForInsideVirtualNetwork += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`FleetLabel:` + fmt.Sprintf("%v", this.FleetLabel) + `,`,
		`VolterraSoftwareVersion:` + fmt.Sprintf("%v", this.VolterraSoftwareVersion) + `,`,
		`NetworkConnectors:` + repeatedStringForNetworkConnectors + `,`,
		`NetworkFirewall:` + repeatedStringForNetworkFirewall + `,`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`OutsideVirtualNetwork:` + repeatedStringForOutsideVirtualNetwork + `,`,
		`InsideVirtualNetwork:` + repeatedStringForInsideVirtualNetwork + `,`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`BondChoice:` + fmt.Sprintf("%v", this.BondChoice) + `,`,
		`StorageInterfaceChoice:` + fmt.Sprintf("%v", this.StorageInterfaceChoice) + `,`,
		`StorageDeviceChoice:` + fmt.Sprintf("%v", this.StorageDeviceChoice) + `,`,
		`StorageClassChoice:` + fmt.Sprintf("%v", this.StorageClassChoice) + `,`,
		`DcClusterGroupChoice:` + fmt.Sprintf("%v", this.DcClusterGroupChoice) + `,`,
		`GpuChoice:` + fmt.Sprintf("%v", this.GpuChoice) + `,`,
		`StorageStaticRoutesChoice:` + fmt.Sprintf("%v", this.StorageStaticRoutesChoice) + `,`,
		`EnableDefaultFleetConfigDownload:` + fmt.Sprintf("%v", this.EnableDefaultFleetConfigDownload) + `,`,
		`LogsReceiverChoice:` + fmt.Sprintf("%v", this.LogsReceiverChoice) + `,`,
		`UsbPolicyChoice:` + fmt.Sprintf("%v", this.UsbPolicyChoice) + `,`,
		`VmChoice:` + fmt.Sprintf("%v", this.VmChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_InterfaceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_InterfaceList{`,
		`InterfaceList:` + strings.Replace(fmt.Sprintf("%v", this.InterfaceList), "FleetInterfaceListType", "FleetInterfaceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DeviceList{`,
		`DeviceList:` + strings.Replace(fmt.Sprintf("%v", this.DeviceList), "FleetDeviceListType", "FleetDeviceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_NoBondDevices) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_NoBondDevices{`,
		`NoBondDevices:` + strings.Replace(fmt.Sprintf("%v", this.NoBondDevices), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_BondDeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_BondDeviceList{`,
		`BondDeviceList:` + strings.Replace(fmt.Sprintf("%v", this.BondDeviceList), "FleetBondDevicesListType", "FleetBondDevicesListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_NoStorageInterfaces) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_NoStorageInterfaces{`,
		`NoStorageInterfaces:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageInterfaces), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_StorageInterfaceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_StorageInterfaceList{`,
		`StorageInterfaceList:` + strings.Replace(fmt.Sprintf("%v", this.StorageInterfaceList), "FleetInterfaceListType", "FleetInterfaceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_NoStorageDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_NoStorageDevice{`,
		`NoStorageDevice:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageDevice), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_StorageDeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_StorageDeviceList{`,
		`StorageDeviceList:` + strings.Replace(fmt.Sprintf("%v", this.StorageDeviceList), "FleetStorageDeviceListType", "FleetStorageDeviceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DefaultStorageClass) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DefaultStorageClass{`,
		`DefaultStorageClass:` + strings.Replace(fmt.Sprintf("%v", this.DefaultStorageClass), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_StorageClassList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_StorageClassList{`,
		`StorageClassList:` + strings.Replace(fmt.Sprintf("%v", this.StorageClassList), "FleetStorageClassListType", "FleetStorageClassListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_NoDcClusterGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_NoDcClusterGroup{`,
		`NoDcClusterGroup:` + strings.Replace(fmt.Sprintf("%v", this.NoDcClusterGroup), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DcClusterGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DcClusterGroup{`,
		`DcClusterGroup:` + strings.Replace(fmt.Sprintf("%v", this.DcClusterGroup), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DisableGpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DisableGpu{`,
		`DisableGpu:` + strings.Replace(fmt.Sprintf("%v", this.DisableGpu), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_EnableGpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_EnableGpu{`,
		`EnableGpu:` + strings.Replace(fmt.Sprintf("%v", this.EnableGpu), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_NoStorageStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_NoStorageStaticRoutes{`,
		`NoStorageStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageStaticRoutes), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_StorageStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_StorageStaticRoutes{`,
		`StorageStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.StorageStaticRoutes), "FleetStorageStaticRoutesListType", "FleetStorageStaticRoutesListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DcClusterGroupInside) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DcClusterGroupInside{`,
		`DcClusterGroupInside:` + strings.Replace(fmt.Sprintf("%v", this.DcClusterGroupInside), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DefaultConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DefaultConfig{`,
		`DefaultConfig:` + strings.Replace(fmt.Sprintf("%v", this.DefaultConfig), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_LogsStreamingDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_LogsStreamingDisabled{`,
		`LogsStreamingDisabled:` + strings.Replace(fmt.Sprintf("%v", this.LogsStreamingDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_LogReceiver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_LogReceiver{`,
		`LogReceiver:` + strings.Replace(fmt.Sprintf("%v", this.LogReceiver), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DenyAllUsb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DenyAllUsb{`,
		`DenyAllUsb:` + strings.Replace(fmt.Sprintf("%v", this.DenyAllUsb), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AllowAllUsb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AllowAllUsb{`,
		`AllowAllUsb:` + strings.Replace(fmt.Sprintf("%v", this.AllowAllUsb), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_UsbPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_UsbPolicy{`,
		`UsbPolicy:` + strings.Replace(fmt.Sprintf("%v", this.UsbPolicy), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_EnableVgpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_EnableVgpu{`,
		`EnableVgpu:` + strings.Replace(fmt.Sprintf("%v", this.EnableVgpu), "VGPUConfiguration", "VGPUConfiguration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DisableVm) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DisableVm{`,
		`DisableVm:` + strings.Replace(fmt.Sprintf("%v", this.DisableVm), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_EnableVm) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_EnableVm{`,
		`EnableVm:` + strings.Replace(fmt.Sprintf("%v", this.EnableVm), "VMConfiguration", "VMConfiguration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStatus{`,
		`AvailableSoftwareVersion:` + fmt.Sprintf("%v", this.AvailableSoftwareVersion) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *NetworkingDeviceInstanceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkingDeviceInstanceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkingDeviceInstanceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interface = append(m.Interface, &schema.ObjectRefType{})
			if err := m.Interface[len(m.Interface)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Use", wireType)
			}
			m.Use = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Use |= NetworkingDeviceInstanceUseType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenericDeviceInstanceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenericDeviceInstanceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenericDeviceInstanceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceInstanceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceInstanceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceInstanceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			m.Owner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Owner |= DeviceOwnerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NetworkingDeviceInstanceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeviceInstance = &DeviceInstanceType_NetworkDevice{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetInterfaceListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetInterfaceListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetInterfaceListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interfaces = append(m.Interfaces, &views.ObjectRefType{})
			if err := m.Interfaces[len(m.Interfaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetDeviceListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetDeviceListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetDeviceListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &DeviceInstanceType{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDeviceOpenebsEnterpriseType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDeviceOpenebsEnterpriseType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDeviceOpenebsEnterpriseType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MayastorPools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MayastorPools = append(m.MayastorPools, &OpenebsMayastorPoolType{})
			if err := m.MayastorPools[len(m.MayastorPools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenebsMayastorPoolType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenebsMayastorPoolType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenebsMayastorPoolType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolDiskDevices", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolDiskDevices = append(m.PoolDiskDevices, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDeviceDellIsilonF800Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDeviceDellIsilonF800Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDeviceDellIsilonF800Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Password == nil {
				m.Password = &schema.SecretType{}
			}
			if err := m.Password.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecureNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HttpsChoice = &StorageDeviceDellIsilonF800Type_SecureNetwork{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpsChoice = &StorageDeviceDellIsilonF800Type_TrustedCaUrl{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressChoice = &StorageDeviceDellIsilonF800Type_ApiServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiServerIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressChoice = &StorageDeviceDellIsilonF800Type_ApiServerIpAddress{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiServerPort", wireType)
			}
			m.ApiServerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiServerPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IscsiAccessZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IscsiAccessZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDeviceHPENimbusStorageAf40Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDeviceHPENimbusStorageAf40Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDeviceHPENimbusStorageAf40Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageServerIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageServerIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiServerPort", wireType)
			}
			m.ApiServerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiServerPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Password == nil {
				m.Password = &schema.SecretType{}
			}
			if err := m.Password.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerfPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PerfPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitIops", wireType)
			}
			m.LimitIops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitIops |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitMbps", wireType)
			}
			m.LimitMbps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitMbps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDevicePureStorageServiceOrchestratorType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDevicePureStorageServiceOrchestratorType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDevicePureStorageServiceOrchestratorType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableStorageTopology", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableStorageTopology = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableStrictTopology", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableStrictTopology = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arrays", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arrays == nil {
				m.Arrays = &PsoArrayConfiguration{}
			}
			if err := m.Arrays.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PsoArrayConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PsoArrayConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PsoArrayConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlashArray", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlashArray == nil {
				m.FlashArray = &FlashArrayType{}
			}
			if err := m.FlashArray.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlashBlade", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlashBlade == nil {
				m.FlashBlade = &FlashBladeType{}
			}
			if err := m.FlashBlade.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlashBladeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlashBladeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlashBladeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSnapshotDirectory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableSnapshotDirectory = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportRules", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExportRules = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlashBlades", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlashBlades = append(m.FlashBlades, &FlashBladeEndpoint{})
			if err := m.FlashBlades[len(m.FlashBlades)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlashBladeEndpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlashBladeEndpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlashBladeEndpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MgmtEndpoint = &FlashBladeEndpoint_MgmtIp{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtDnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MgmtEndpoint = &FlashBladeEndpoint_MgmtDnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiToken == nil {
				m.ApiToken = &schema.SecretType{}
			}
			if err := m.ApiToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NfsEndpointIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NfsEndpoint = &FlashBladeEndpoint_NfsEndpointIp{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NfsEndpointDnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NfsEndpoint = &FlashBladeEndpoint_NfsEndpointDnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lables == nil {
				m.Lables = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Lables[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlashArrayType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlashArrayType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlashArrayType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SanType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SanType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFsType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultFsType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFsOpt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultFsOpt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultMountOpts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultMountOpts = append(m.DefaultMountOpts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisablePreemptAttachments", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisablePreemptAttachments = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IscsiLoginTimeout", wireType)
			}
			m.IscsiLoginTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IscsiLoginTimeout |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlashArrays", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlashArrays = append(m.FlashArrays, &FlashArrayEndpoint{})
			if err := m.FlashArrays[len(m.FlashArrays)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlashArrayEndpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlashArrayEndpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlashArrayEndpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MgmtEndpoint = &FlashArrayEndpoint_MgmtIp{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtDnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MgmtEndpoint = &FlashArrayEndpoint_MgmtDnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiToken == nil {
				m.ApiToken = &schema.SecretType{}
			}
			if err := m.ApiToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDeviceNetappTridentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDeviceNetappTridentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDeviceNetappTridentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetappBackendOntapNas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageDeviceNetappBackendOntapNasType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BackendChoice = &StorageDeviceNetappTridentType_NetappBackendOntapNas{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetappBackendOntapSan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageDeviceNetappBackendOntapSanType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BackendChoice = &StorageDeviceNetappTridentType_NetappBackendOntapSan{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDeviceNetappBackendOntapSanType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDeviceNetappBackendOntapSanType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDeviceNetappBackendOntapSanType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDriverName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageDriverName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementLifIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagementLif = &StorageDeviceNetappBackendOntapSanType_ManagementLifIp{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementLifDnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagementLif = &StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLifIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataLif = &StorageDeviceNetappBackendOntapSanType_DataLifIp{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLifDnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataLif = &StorageDeviceNetappBackendOntapSanType_DataLifDnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Svm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Password == nil {
				m.Password = &schema.SecretType{}
			}
			if err := m.Password.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoChap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChapChoice = &StorageDeviceNetappBackendOntapSanType_NoChap{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseChap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeviceNetappBackendOntapSanChapType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChapChoice = &StorageDeviceNetappBackendOntapSanType_UseChap{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IgroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoragePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoragePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitAggregateUsage", wireType)
			}
			m.LimitAggregateUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitAggregateUsage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitVolumeSize", wireType)
			}
			m.LimitVolumeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitVolumeSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeDefaults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeDefaults == nil {
				m.VolumeDefaults = &OntapVolumeDefaults{}
			}
			if err := m.VolumeDefaults.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storage = append(m.Storage, &OntapVirtualStoragePoolType{})
			if err := m.Storage[len(m.Storage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCertificate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientCertificate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientPrivateKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientPrivateKey == nil {
				m.ClientPrivateKey = &schema.SecretType{}
			}
			if err := m.ClientPrivateKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaCertificate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaCertificate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceNetappBackendOntapSanChapType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceNetappBackendOntapSanChapType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceNetappBackendOntapSanChapType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChapUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapTargetUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChapTargetUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapInitiatorSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChapInitiatorSecret == nil {
				m.ChapInitiatorSecret = &schema.SecretType{}
			}
			if err := m.ChapInitiatorSecret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapTargetInitiatorSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChapTargetInitiatorSecret == nil {
				m.ChapTargetInitiatorSecret = &schema.SecretType{}
			}
			if err := m.ChapTargetInitiatorSecret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDeviceNetappBackendOntapNasType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDeviceNetappBackendOntapNasType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDeviceNetappBackendOntapNasType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDriverName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageDriverName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackendName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackendName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementLifIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagementLif = &StorageDeviceNetappBackendOntapNasType_ManagementLifIp{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementLifDnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagementLif = &StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLifIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataLif = &StorageDeviceNetappBackendOntapNasType_DataLifIp{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLifDnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataLif = &StorageDeviceNetappBackendOntapNasType_DataLifDnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Svm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Password == nil {
				m.Password = &schema.SecretType{}
			}
			if err := m.Password.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoExportPolicy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoExportPolicy = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoExportCidrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoExportCidrs == nil {
				m.AutoExportCidrs = &views.PrefixStringListType{}
			}
			if err := m.AutoExportCidrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoragePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoragePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitAggregateUsage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LimitAggregateUsage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitVolumeSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LimitVolumeSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NfsMountOptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NfsMountOptions = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeDefaults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeDefaults == nil {
				m.VolumeDefaults = &OntapVolumeDefaults{}
			}
			if err := m.VolumeDefaults.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storage = append(m.Storage, &OntapVirtualStoragePoolType{})
			if err := m.Storage[len(m.Storage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCertificate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientCertificate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientPrivateKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientPrivateKey == nil {
				m.ClientPrivateKey = &schema.SecretType{}
			}
			if err := m.ClientPrivateKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaCertificate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaCertificate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OntapVolumeDefaults) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OntapVolumeDefaults: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OntapVolumeDefaults: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceReserve", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceReserve = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotReserve", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotReserve = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitOnClone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SplitOnClone = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Encryption = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnixPermissions", wireType)
			}
			m.UnixPermissions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnixPermissions |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotDir", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SnapshotDir = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExportPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityStyle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityStyle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TieringPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TieringPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoQos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QosPolicyChoice = &OntapVolumeDefaults_NoQos{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QosPolicyChoice = &OntapVolumeDefaults_QosPolicy{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptiveQosPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QosPolicyChoice = &OntapVolumeDefaults_AdaptiveQosPolicy{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OntapVirtualStoragePoolType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OntapVirtualStoragePoolType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OntapVirtualStoragePoolType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeDefaults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeDefaults == nil {
				m.VolumeDefaults = &OntapVolumeDefaults{}
			}
			if err := m.VolumeDefaults.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetStorageDeviceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetStorageDeviceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetStorageDeviceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDevice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageDevice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvancedAdvancedParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdvancedAdvancedParameters == nil {
				m.AdvancedAdvancedParameters = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AdvancedAdvancedParameters[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetappTrident", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageDeviceNetappTridentType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeviceChoice = &FleetStorageDeviceType_NetappTrident{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PureServiceOrchestrator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageDevicePureStorageServiceOrchestratorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeviceChoice = &FleetStorageDeviceType_PureServiceOrchestrator{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenebsEnterprise", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageDeviceOpenebsEnterpriseType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeviceChoice = &FleetStorageDeviceType_OpenebsEnterprise{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomStorage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeviceChoice = &FleetStorageDeviceType_CustomStorage{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetStorageDeviceListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetStorageDeviceListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetStorageDeviceListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageDevices = append(m.StorageDevices, &FleetStorageDeviceType{})
			if err := m.StorageDevices[len(m.StorageDevices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageClassDellIsilonF800Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageClassDellIsilonF800Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageClassDellIsilonF800Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpsChoice = &StorageClassDellIsilonF800Type_AzServiceName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzServiceIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpsChoice = &StorageClassDellIsilonF800Type_AzServiceIpAddress{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IscsiAccessZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IscsiAccessZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootClientEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RootClientEnable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageClassHPENimbusStorageAf40Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageClassHPENimbusStorageAf40Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageClassHPENimbusStorageAf40Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerfPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PerfPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitIops", wireType)
			}
			m.LimitIops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitIops |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitMbps", wireType)
			}
			m.LimitMbps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitMbps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageClassOpenebsEnterpriseType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageClassOpenebsEnterpriseType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageClassOpenebsEnterpriseType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replication", wireType)
			}
			m.Replication = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Replication |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageClassNetappTridentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageClassNetappTridentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageClassNetappTridentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selector == nil {
				m.Selector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Selector[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoragePools", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoragePools = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageClassPureServiceOrchestratorType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageClassPureServiceOrchestratorType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageClassPureServiceOrchestratorType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backend", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Backend = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IopsLimit", wireType)
			}
			m.IopsLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IopsLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BandwidthLimit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BandwidthLimit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageClassCustomType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageClassCustomType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageClassCustomType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetStorageClassType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetStorageClassType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetStorageClassType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDevice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageDevice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultStorageClass", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultStorageClass = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvancedStorageParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdvancedStorageParameters == nil {
				m.AdvancedStorageParameters = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AdvancedStorageParameters[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetappTrident", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageClassNetappTridentType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeviceChoice = &FleetStorageClassType_NetappTrident{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PureServiceOrchestrator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageClassPureServiceOrchestratorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeviceChoice = &FleetStorageClassType_PureServiceOrchestrator{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenebsEnterprise", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageClassOpenebsEnterpriseType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeviceChoice = &FleetStorageClassType_OpenebsEnterprise{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReclaimPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReclaimPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowVolumeExpansion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowVolumeExpansion = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomStorage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageClassCustomType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeviceChoice = &FleetStorageClassType_CustomStorage{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetStorageClassListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetStorageClassListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetStorageClassListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClasses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageClasses = append(m.StorageClasses, &FleetStorageClassType{})
			if err := m.StorageClasses[len(m.StorageClasses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BondLacpType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BondLacpType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BondLacpType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetBondDeviceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetBondDeviceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetBondDeviceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lacp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BondLacpType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LacpChoice = &FleetBondDeviceType_Lacp{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveBackup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LacpChoice = &FleetBondDeviceType_ActiveBackup{v}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkPollingInterval", wireType)
			}
			m.LinkPollingInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkPollingInterval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkUpDelay", wireType)
			}
			m.LinkUpDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkUpDelay |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetBondDevicesListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetBondDevicesListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetBondDevicesListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondDevices = append(m.BondDevices, &FleetBondDeviceType{})
			if err := m.BondDevices[len(m.BondDevices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetStorageStaticRoutesListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetStorageStaticRoutesListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetStorageStaticRoutesListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageRoutes = append(m.StorageRoutes, &schema.StaticRouteType{})
			if err := m.StorageRoutes[len(m.StorageRoutes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VGPUConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VGPUConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VGPUConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerPort", wireType)
			}
			m.ServerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureType", wireType)
			}
			m.FeatureType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeatureType |= VGPUFeatureType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &bgp.Peer{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asn", wireType)
			}
			m.Asn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Asn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalControlPlaneType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalControlPlaneType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalControlPlaneType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &LocalControlPlaneType_InsideVn{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &LocalControlPlaneType_OutsideVn{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BgpConfig == nil {
				m.BgpConfig = &BGPConfiguration{}
			}
			if err := m.BgpConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FleetLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FleetLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolterraSoftwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &DeviceInstanceType{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkConnectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkConnectors = append(m.NetworkConnectors, &schema.ObjectRefType{})
			if err := m.NetworkConnectors[len(m.NetworkConnectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkFirewall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkFirewall = append(m.NetworkFirewall, &schema.ObjectRefType{})
			if err := m.NetworkFirewall[len(m.NetworkFirewall)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVirtualNetwork = append(m.OutsideVirtualNetwork, &schema.ObjectRefType{})
			if err := m.OutsideVirtualNetwork[len(m.OutsideVirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVirtualNetwork = append(m.InsideVirtualNetwork, &schema.ObjectRefType{})
			if err := m.InsideVirtualNetwork[len(m.InsideVirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetInterfaceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GlobalSpecType_InterfaceList{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GlobalSpecType_LegacyDevices{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoBondDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BondChoice = &GlobalSpecType_NoBondDevices{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetBondDevicesListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BondChoice = &GlobalSpecType_BondDeviceList{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageInterfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageInterfaceChoice = &GlobalSpecType_NoStorageInterfaces{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageInterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetInterfaceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageInterfaceChoice = &GlobalSpecType_StorageInterfaceList{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageDeviceChoice = &GlobalSpecType_NoStorageDevice{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageDeviceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageDeviceChoice = &GlobalSpecType_StorageDeviceList{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultStorageClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageClassChoice = &GlobalSpecType_DefaultStorageClass{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClassList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageClassListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageClassChoice = &GlobalSpecType_StorageClassList{v}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoDcClusterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &GlobalSpecType_NoDcClusterGroup{v}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &GlobalSpecType_DcClusterGroup{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableGpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &GlobalSpecType_DisableGpu{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableGpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &GlobalSpecType_EnableGpu{v}
			iNdEx = postIndex
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EtcdClusterNetwork", wireType)
			}
			m.EtcdClusterNetwork = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EtcdClusterNetwork |= EtcdClusterNetworkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageStaticRoutesChoice = &GlobalSpecType_NoStorageStaticRoutes{v}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageStaticRoutesListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageStaticRoutesChoice = &GlobalSpecType_StorageStaticRoutes{v}
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableDefaultFleetConfigDownload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableDefaultFleetConfigDownload = bool(v != 0)
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroupInside", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &GlobalSpecType_DcClusterGroupInside{v}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultInterfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GlobalSpecType_DefaultInterfaces{v}
			iNdEx = postIndex
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FleetType", wireType)
			}
			m.FleetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FleetType |= FleetType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SingleSite = append(m.SingleSite, &schema.ObjectRefType{})
			if err := m.SingleSite[len(m.SingleSite)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsStreamingDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &GlobalSpecType_LogsStreamingDisabled{v}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogReceiver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &GlobalSpecType_LogReceiver{v}
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyAllUsb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &GlobalSpecType_DenyAllUsb{v}
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAllUsb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &GlobalSpecType_AllowAllUsb{v}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsbPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &GlobalSpecType_UsbPolicy{v}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K8SCluster == nil {
				m.K8SCluster = &views.ObjectRefType{}
			}
			if err := m.K8SCluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalControlPlane", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalControlPlane == nil {
				m.LocalControlPlane = &LocalControlPlaneType{}
			}
			if err := m.LocalControlPlane.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableVgpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VGPUConfiguration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &GlobalSpecType_EnableVgpu{v}
			iNdEx = postIndex
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableFlowExport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FlowExporterChoice = &GlobalSpecType_DisableFlowExport{v}
			iNdEx = postIndex
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableFlowExport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FlowExporterChoice = &GlobalSpecType_EnableFlowExport{v}
			iNdEx = postIndex
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableVm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VmChoice = &GlobalSpecType_DisableVm{v}
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableVm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VMConfiguration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VmChoice = &GlobalSpecType_EnableVm{v}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewInternal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ViewInternal == nil {
				m.ViewInternal = &views.ObjectRefType{}
			}
			if err := m.ViewInternal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedYamls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeneratedYamls = append(m.GeneratedYamls, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FleetLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FleetLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolterraSoftwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkConnectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkConnectors = append(m.NetworkConnectors, &schema.ObjectRefType{})
			if err := m.NetworkConnectors[len(m.NetworkConnectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkFirewall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkFirewall = append(m.NetworkFirewall, &schema.ObjectRefType{})
			if err := m.NetworkFirewall[len(m.NetworkFirewall)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVirtualNetwork = append(m.OutsideVirtualNetwork, &schema.ObjectRefType{})
			if err := m.OutsideVirtualNetwork[len(m.OutsideVirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVirtualNetwork = append(m.InsideVirtualNetwork, &schema.ObjectRefType{})
			if err := m.InsideVirtualNetwork[len(m.InsideVirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetInterfaceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &CreateSpecType_InterfaceList{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetDeviceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &CreateSpecType_DeviceList{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoBondDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BondChoice = &CreateSpecType_NoBondDevices{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetBondDevicesListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BondChoice = &CreateSpecType_BondDeviceList{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageInterfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageInterfaceChoice = &CreateSpecType_NoStorageInterfaces{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageInterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetInterfaceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageInterfaceChoice = &CreateSpecType_StorageInterfaceList{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageDeviceChoice = &CreateSpecType_NoStorageDevice{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageDeviceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageDeviceChoice = &CreateSpecType_StorageDeviceList{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultStorageClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageClassChoice = &CreateSpecType_DefaultStorageClass{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClassList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageClassListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageClassChoice = &CreateSpecType_StorageClassList{v}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoDcClusterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &CreateSpecType_NoDcClusterGroup{v}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &CreateSpecType_DcClusterGroup{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableGpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &CreateSpecType_DisableGpu{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableGpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &CreateSpecType_EnableGpu{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageStaticRoutesChoice = &CreateSpecType_NoStorageStaticRoutes{v}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageStaticRoutesListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageStaticRoutesChoice = &CreateSpecType_StorageStaticRoutes{v}
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableDefaultFleetConfigDownload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableDefaultFleetConfigDownload = bool(v != 0)
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroupInside", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &CreateSpecType_DcClusterGroupInside{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &CreateSpecType_DefaultConfig{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsStreamingDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &CreateSpecType_LogsStreamingDisabled{v}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogReceiver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &CreateSpecType_LogReceiver{v}
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyAllUsb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &CreateSpecType_DenyAllUsb{v}
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAllUsb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &CreateSpecType_AllowAllUsb{v}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsbPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &CreateSpecType_UsbPolicy{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableVgpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VGPUConfiguration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &CreateSpecType_EnableVgpu{v}
			iNdEx = postIndex
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableVm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VmChoice = &CreateSpecType_DisableVm{v}
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableVm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VMConfiguration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VmChoice = &CreateSpecType_EnableVm{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolterraSoftwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkConnectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkConnectors = append(m.NetworkConnectors, &schema.ObjectRefType{})
			if err := m.NetworkConnectors[len(m.NetworkConnectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkFirewall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkFirewall = append(m.NetworkFirewall, &schema.ObjectRefType{})
			if err := m.NetworkFirewall[len(m.NetworkFirewall)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVirtualNetwork = append(m.OutsideVirtualNetwork, &schema.ObjectRefType{})
			if err := m.OutsideVirtualNetwork[len(m.OutsideVirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVirtualNetwork = append(m.InsideVirtualNetwork, &schema.ObjectRefType{})
			if err := m.InsideVirtualNetwork[len(m.InsideVirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetInterfaceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &ReplaceSpecType_InterfaceList{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetDeviceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &ReplaceSpecType_DeviceList{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoBondDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BondChoice = &ReplaceSpecType_NoBondDevices{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetBondDevicesListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BondChoice = &ReplaceSpecType_BondDeviceList{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageInterfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageInterfaceChoice = &ReplaceSpecType_NoStorageInterfaces{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageInterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetInterfaceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageInterfaceChoice = &ReplaceSpecType_StorageInterfaceList{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageDeviceChoice = &ReplaceSpecType_NoStorageDevice{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageDeviceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageDeviceChoice = &ReplaceSpecType_StorageDeviceList{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultStorageClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageClassChoice = &ReplaceSpecType_DefaultStorageClass{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClassList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageClassListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageClassChoice = &ReplaceSpecType_StorageClassList{v}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoDcClusterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &ReplaceSpecType_NoDcClusterGroup{v}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &ReplaceSpecType_DcClusterGroup{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableGpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &ReplaceSpecType_DisableGpu{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableGpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &ReplaceSpecType_EnableGpu{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageStaticRoutesChoice = &ReplaceSpecType_NoStorageStaticRoutes{v}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageStaticRoutesListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageStaticRoutesChoice = &ReplaceSpecType_StorageStaticRoutes{v}
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableDefaultFleetConfigDownload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableDefaultFleetConfigDownload = bool(v != 0)
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroupInside", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &ReplaceSpecType_DcClusterGroupInside{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &ReplaceSpecType_DefaultConfig{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsStreamingDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &ReplaceSpecType_LogsStreamingDisabled{v}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogReceiver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &ReplaceSpecType_LogReceiver{v}
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyAllUsb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &ReplaceSpecType_DenyAllUsb{v}
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAllUsb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &ReplaceSpecType_AllowAllUsb{v}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsbPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &ReplaceSpecType_UsbPolicy{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableVgpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VGPUConfiguration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &ReplaceSpecType_EnableVgpu{v}
			iNdEx = postIndex
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableVm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VmChoice = &ReplaceSpecType_DisableVm{v}
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableVm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VMConfiguration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VmChoice = &ReplaceSpecType_EnableVm{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FleetLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FleetLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolterraSoftwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkConnectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkConnectors = append(m.NetworkConnectors, &schema.ObjectRefType{})
			if err := m.NetworkConnectors[len(m.NetworkConnectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkFirewall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkFirewall = append(m.NetworkFirewall, &schema.ObjectRefType{})
			if err := m.NetworkFirewall[len(m.NetworkFirewall)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVirtualNetwork = append(m.OutsideVirtualNetwork, &schema.ObjectRefType{})
			if err := m.OutsideVirtualNetwork[len(m.OutsideVirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVirtualNetwork = append(m.InsideVirtualNetwork, &schema.ObjectRefType{})
			if err := m.InsideVirtualNetwork[len(m.InsideVirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetInterfaceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GetSpecType_InterfaceList{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetDeviceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GetSpecType_DeviceList{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoBondDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BondChoice = &GetSpecType_NoBondDevices{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetBondDevicesListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BondChoice = &GetSpecType_BondDeviceList{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageInterfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageInterfaceChoice = &GetSpecType_NoStorageInterfaces{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageInterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetInterfaceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageInterfaceChoice = &GetSpecType_StorageInterfaceList{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageDeviceChoice = &GetSpecType_NoStorageDevice{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageDeviceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageDeviceChoice = &GetSpecType_StorageDeviceList{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultStorageClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageClassChoice = &GetSpecType_DefaultStorageClass{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClassList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageClassListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageClassChoice = &GetSpecType_StorageClassList{v}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoDcClusterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &GetSpecType_NoDcClusterGroup{v}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &GetSpecType_DcClusterGroup{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableGpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &GetSpecType_DisableGpu{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableGpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &GetSpecType_EnableGpu{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageStaticRoutesChoice = &GetSpecType_NoStorageStaticRoutes{v}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageStaticRoutesListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageStaticRoutesChoice = &GetSpecType_StorageStaticRoutes{v}
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableDefaultFleetConfigDownload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableDefaultFleetConfigDownload = bool(v != 0)
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroupInside", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &GetSpecType_DcClusterGroupInside{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GetSpecType_DefaultConfig{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsStreamingDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &GetSpecType_LogsStreamingDisabled{v}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogReceiver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &GetSpecType_LogReceiver{v}
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyAllUsb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &GetSpecType_DenyAllUsb{v}
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAllUsb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &GetSpecType_AllowAllUsb{v}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsbPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &GetSpecType_UsbPolicy{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableVgpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VGPUConfiguration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &GetSpecType_EnableVgpu{v}
			iNdEx = postIndex
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableVm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VmChoice = &GetSpecType_DisableVm{v}
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableVm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VMConfiguration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VmChoice = &GetSpecType_EnableVm{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailableSoftwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
