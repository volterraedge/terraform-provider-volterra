// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/fleet/types.proto

package fleet

import proto "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/gogo/protobuf/types"
import ves_io_schema_bgp "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/bgp"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import ves_io_schema4 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import _ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
import ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"

import strconv "strconv"

import strings "strings"
import reflect "reflect"
import sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Etcd Clustering Network
//
// x-displayName: "Etcd Clustering Network"
// Decided which network is used for etcd clustering
type EtcdClusterNetworkType int32

const (
	// x-displayName: "Site Local (Outside) Network"
	// Etcd clustering happens over Site local network
	ETCD_CLUSTER_SITE_LOCAL_NETWORK EtcdClusterNetworkType = 0
	// x-displayName: "Site Local Inside Network"
	// Etcd clustering happens over Site local inside network
	ETCD_CLUSTER_SITE_LOCAL_INSIDE_NETWORK EtcdClusterNetworkType = 1
	// x-displayName: "Site Management Network"
	// Etcd clustering happens over Site management network, requires redundant dedicated management interfaces
	ETCD_CLUSTER_SITE_MANAGEMENT_NETWORK EtcdClusterNetworkType = 2
)

var EtcdClusterNetworkType_name = map[int32]string{
	0: "ETCD_CLUSTER_SITE_LOCAL_NETWORK",
	1: "ETCD_CLUSTER_SITE_LOCAL_INSIDE_NETWORK",
	2: "ETCD_CLUSTER_SITE_MANAGEMENT_NETWORK",
}
var EtcdClusterNetworkType_value = map[string]int32{
	"ETCD_CLUSTER_SITE_LOCAL_NETWORK":        0,
	"ETCD_CLUSTER_SITE_LOCAL_INSIDE_NETWORK": 1,
	"ETCD_CLUSTER_SITE_MANAGEMENT_NETWORK":   2,
}

func (EtcdClusterNetworkType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

// Device Owner Type
//
// x-displayName: "Device Owner Type"
// Defines ownership for a device.
type DeviceOwnerType int32

const (
	// x-displayName: "Owner Invalid"
	// Device owner is invalid
	DEVICE_OWNER_INVALID DeviceOwnerType = 0
	// x-displayName: "Owner VER"
	// Device is owned by VER pod. usually it will be network interface device or accelerator like crypto engine.
	DEVICE_OWNER_VER DeviceOwnerType = 1
	// x-displayName: "Owner vK8s Workload"
	// Device is available to be owned by vK8s workload on the site, like camera GPU etc.
	DEVICE_OWNER_VK8S_WORK_LOAD DeviceOwnerType = 2
	// x-displayName: "Owner Host"
	// Device is not available to be owned by vK8s or VER. Can be exposed via some other service. Like TPM.
	DEVICE_OWNER_HOST DeviceOwnerType = 3
)

var DeviceOwnerType_name = map[int32]string{
	0: "DEVICE_OWNER_INVALID",
	1: "DEVICE_OWNER_VER",
	2: "DEVICE_OWNER_VK8S_WORK_LOAD",
	3: "DEVICE_OWNER_HOST",
}
var DeviceOwnerType_value = map[string]int32{
	"DEVICE_OWNER_INVALID":        0,
	"DEVICE_OWNER_VER":            1,
	"DEVICE_OWNER_VK8S_WORK_LOAD": 2,
	"DEVICE_OWNER_HOST":           3,
}

func (DeviceOwnerType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

// Fleet Type
//
// x-displayName: "Fleet Type"
// Defines fleet type. We have different constraints per each type.
type FleetType int32

const (
	// x-displayName: "Multiple Site Fleet"
	// Default fleet type.
	MULTIPLE_SITE FleetType = 0
	// x-displayName: "Single Site Fleet"
	// Internally created site by single fleet such as AWS/Azure/GCP etc.
	SINGLE_SITE FleetType = 1
)

var FleetType_name = map[int32]string{
	0: "MULTIPLE_SITE",
	1: "SINGLE_SITE",
}
var FleetType_value = map[string]int32{
	"MULTIPLE_SITE": 0,
	"SINGLE_SITE":   1,
}

func (FleetType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

// Network Device Use
//
// x-displayName: "Network Device Use"
// Defines how the device is used
type NetworkingDeviceInstanceUseType int32

const (
	// x-displayName: "Regular Interface"
	// If networking device is owned by VER, it is available for users to configure as required
	NETWORK_INTERFACE_USE_REGULAR NetworkingDeviceInstanceUseType = 0
	// x-displayName: "Outside Interface"
	// If networking device is owned by VER, it is included in bootstrap config and member of outside network.
	NETWORK_INTERFACE_USE_OUTSIDE NetworkingDeviceInstanceUseType = 1
	// x-displayName: "Inside Interface"
	// If networking device is owned by VER, it is included in bootstrap config and member of inside network.
	NETWORK_INTERFACE_USE_INSIDE NetworkingDeviceInstanceUseType = 2
)

var NetworkingDeviceInstanceUseType_name = map[int32]string{
	0: "NETWORK_INTERFACE_USE_REGULAR",
	1: "NETWORK_INTERFACE_USE_OUTSIDE",
	2: "NETWORK_INTERFACE_USE_INSIDE",
}
var NetworkingDeviceInstanceUseType_value = map[string]int32{
	"NETWORK_INTERFACE_USE_REGULAR": 0,
	"NETWORK_INTERFACE_USE_OUTSIDE": 1,
	"NETWORK_INTERFACE_USE_INSIDE":  2,
}

func (NetworkingDeviceInstanceUseType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{3}
}

// Network Device Type
//
// x-displayName: "Network Device Type"
// Represents physical network interface.
// The 'interface' reference points to a Network Interface object. Attributes such as Labels, MTU from
// Network Interface must be applied to the device.
//
// Device mapping to nodes
//
// A fleet can have many devices and nodes in VER customer edge site can have many interfaces.
// An interface in node inherits configuration from a device by matching,
//   - device_name in Network Interface for the device
//   - device name for physical-interface in the node
type NetworkingDeviceInstanceType struct {
	// Network Interface
	//
	// x-displayName: "Network Interface"
	// x-required
	// Network Interface attributes for the device.
	// User network interface configuration for this network device.
	// Attributes like labels, MTU from the 'interface' are applied to corresponding interface in VER node
	// If network interface refers to a virtual-network, the virtual-netowrk type must be consistent with use attribute given below
	// If use is NETWORK_INTERFACE_USE_REGULAR, the virtual-network must be of type VIRTUAL_NETWORK_SITE_LOCAL or VIRTUAL_NETWORK_SITE_LOCAL_INSIDE
	// if use is NETWORK_INTERFACE_USE_OUTSIDE, the virtual-network must of type VIRTUAL_NETWORK_SITE_LOCAL
	// if use is NETWORK_INTERFACE_USE_INSIDE, the virtual-network must of type VIRTUAL_NETWORK_SITE_LOCAL_INSIDE
	Interface []*ves_io_schema4.ObjectRefType `protobuf:"bytes,2,rep,name=interface" json:"interface,omitempty"`
	// Use
	//
	// x-displayName: "Use"
	// x-required
	// Defines how the device is used.
	// 'use' specifies how the device is used in node
	// Specifies if the network interface is connected to inside network or outside network.
	Use NetworkingDeviceInstanceUseType `protobuf:"varint,3,opt,name=use,proto3,enum=ves.io.schema.fleet.NetworkingDeviceInstanceUseType" json:"use,omitempty"`
}

func (m *NetworkingDeviceInstanceType) Reset()      { *m = NetworkingDeviceInstanceType{} }
func (*NetworkingDeviceInstanceType) ProtoMessage() {}
func (*NetworkingDeviceInstanceType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{0}
}

func (m *NetworkingDeviceInstanceType) GetInterface() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.Interface
	}
	return nil
}

func (m *NetworkingDeviceInstanceType) GetUse() NetworkingDeviceInstanceUseType {
	if m != nil {
		return m.Use
	}
	return NETWORK_INTERFACE_USE_REGULAR
}

// Generic Device
//
// x-displayName: "Generic Device"
// Represent a generic device
// This is not yet supported
type GenericDeviceInstanceType struct {
}

func (m *GenericDeviceInstanceType) Reset()                    { *m = GenericDeviceInstanceType{} }
func (*GenericDeviceInstanceType) ProtoMessage()               {}
func (*GenericDeviceInstanceType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

// Device Instance
//
// x-displayName: "Device Instance"
// Device Instance describes a single device in fleet
// A device can be of type network interface, camera, scanner etc. A device instance is created for each instance of device.
// If there are 2 network interfaces(eth0, eth1...), then 2 DeviceInstanceType are created one for eth0 and another for eth1
type DeviceInstanceType struct {
	// Name
	//
	// x-displayName: "Device Name"
	// Name of the device including the unit number (e.g. eth0 or disk1). The name must match name of device in host-os of node
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Owner
	//
	// x-displayName: "Device Owner"
	// x-required
	// Defines ownership of the device. A device can be owned by,
	//   * VER : Devices like ethernet are owned by VER
	//   * VK8S Workload : The devices is available for VK8S workload use.
	//                     This option is not yet supported
	//   * HOST : Device is owned by host-os. The devices can be exposed via some other services like TPM.
	//            This option is not yet supported
	Owner DeviceOwnerType `protobuf:"varint,3,opt,name=owner,proto3,enum=ves.io.schema.fleet.DeviceOwnerType" json:"owner,omitempty"`
	// Device Instance
	//
	// x-displayName: "Device Instance"
	// x-required
	// Device Instance specifies the type of interface and its characteristics
	//
	// Types that are valid to be assigned to DeviceInstance:
	//	*DeviceInstanceType_NetworkDevice
	DeviceInstance isDeviceInstanceType_DeviceInstance `protobuf_oneof:"device_instance"`
}

func (m *DeviceInstanceType) Reset()                    { *m = DeviceInstanceType{} }
func (*DeviceInstanceType) ProtoMessage()               {}
func (*DeviceInstanceType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

type isDeviceInstanceType_DeviceInstance interface {
	isDeviceInstanceType_DeviceInstance()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DeviceInstanceType_NetworkDevice struct {
	NetworkDevice *NetworkingDeviceInstanceType `protobuf:"bytes,4,opt,name=network_device,json=networkDevice,oneof"`
}

func (*DeviceInstanceType_NetworkDevice) isDeviceInstanceType_DeviceInstance() {}

func (m *DeviceInstanceType) GetDeviceInstance() isDeviceInstanceType_DeviceInstance {
	if m != nil {
		return m.DeviceInstance
	}
	return nil
}

func (m *DeviceInstanceType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeviceInstanceType) GetOwner() DeviceOwnerType {
	if m != nil {
		return m.Owner
	}
	return DEVICE_OWNER_INVALID
}

func (m *DeviceInstanceType) GetNetworkDevice() *NetworkingDeviceInstanceType {
	if x, ok := m.GetDeviceInstance().(*DeviceInstanceType_NetworkDevice); ok {
		return x.NetworkDevice
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DeviceInstanceType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DeviceInstanceType_OneofMarshaler, _DeviceInstanceType_OneofUnmarshaler, _DeviceInstanceType_OneofSizer, []interface{}{
		(*DeviceInstanceType_NetworkDevice)(nil),
	}
}

func _DeviceInstanceType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DeviceInstanceType)
	// device_instance
	switch x := m.DeviceInstance.(type) {
	case *DeviceInstanceType_NetworkDevice:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NetworkDevice); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DeviceInstanceType.DeviceInstance has unexpected type %T", x)
	}
	return nil
}

func _DeviceInstanceType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DeviceInstanceType)
	switch tag {
	case 4: // device_instance.network_device
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NetworkingDeviceInstanceType)
		err := b.DecodeMessage(msg)
		m.DeviceInstance = &DeviceInstanceType_NetworkDevice{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DeviceInstanceType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DeviceInstanceType)
	// device_instance
	switch x := m.DeviceInstance.(type) {
	case *DeviceInstanceType_NetworkDevice:
		s := proto.Size(x.NetworkDevice)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// List of Interfaces
//
// x-displayName: "List of Interfaces"
// Add all interfaces belonging to this fleet
type FleetInterfaceListType struct {
	// List of Interfaces
	//
	// x-displayName: "List of Interfaces"
	// x-required
	// Add all interfaces belonging to this fleet
	Interfaces []*ves_io_schema_views.ObjectRefType `protobuf:"bytes,1,rep,name=interfaces" json:"interfaces,omitempty"`
}

func (m *FleetInterfaceListType) Reset()                    { *m = FleetInterfaceListType{} }
func (*FleetInterfaceListType) ProtoMessage()               {}
func (*FleetInterfaceListType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *FleetInterfaceListType) GetInterfaces() []*ves_io_schema_views.ObjectRefType {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

// List of Devices
//
// x-displayName: "List of Devices"
// Add device for all interfaces belonging to this fleet
type FleetDeviceListType struct {
	// Add device for all interfaces belonging to this fleet
	//
	// x-displayName: "Devices"
	// Configuration for all devices in the fleet.
	// Examples of devices are - network interfaces, cameras, scanners etc.
	// Configuration a device is applied on VER node if the VER node is member of this fleet and
	// has an corresponding interface/device. The mapping from device configured in fleet with
	// interface/device in VER node depends on the type of device and is documented in
	// device instance specific sections
	Devices []*DeviceInstanceType `protobuf:"bytes,3,rep,name=devices" json:"devices,omitempty"`
}

func (m *FleetDeviceListType) Reset()                    { *m = FleetDeviceListType{} }
func (*FleetDeviceListType) ProtoMessage()               {}
func (*FleetDeviceListType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

func (m *FleetDeviceListType) GetDevices() []*DeviceInstanceType {
	if m != nil {
		return m.Devices
	}
	return nil
}

// OpenEBS Enterprise
//
// x-displayName: "OpenEBS Enterprise"
// Device configuration for OpenEBS Enterprise
type StorageDeviceOpenebsEnterpriseType struct {
	// List of  Mayastor Pools
	//
	// x-displayName: "List of  Mayastor Pools"
	// List of  Mayastor Pools. When a Mayastor Node (MSN) allocates storage capacity for a Persistent Volume (PV) it does so from a construct named a Mayastor Pool (MSP).
	// Each MSN may have zero, one, or more such pools associated with it.  The ownership of a pool by a MSN is exclusive.
	// In the current version of Mayastor, a pool may have only a single block device member, which constitutes the entire data persistence layer for that pool.
	// Each MSP include a unique name for the pool, the host name of the MSN on which it is hosted and a reference to a disk device which is accessible from that node (for inclusion within the pool).
	// The pool definition allows the reference to its member disk to adhere to one of a number of possible schemes, each associated with a specific access
	// mechanism/transport/device type and differentiated by corresponding performance and/or attachment locality.
	MayastorPools []*OpenebsMayastorPoolType `protobuf:"bytes,1,rep,name=mayastor_pools,json=mayastorPools" json:"mayastor_pools,omitempty"`
}

func (m *StorageDeviceOpenebsEnterpriseType) Reset()      { *m = StorageDeviceOpenebsEnterpriseType{} }
func (*StorageDeviceOpenebsEnterpriseType) ProtoMessage() {}
func (*StorageDeviceOpenebsEnterpriseType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{5}
}

func (m *StorageDeviceOpenebsEnterpriseType) GetMayastorPools() []*OpenebsMayastorPoolType {
	if m != nil {
		return m.MayastorPools
	}
	return nil
}

// OpenEBS Mayastor Pool
//
// x-displayName: "OpenEBS Mayastor Pool"
// Configuration for OpenEBS Mayastor Pool. When a Mayastor Node (MSN) allocates storage capacity for a Persistent Volume (PV) it does so from a construct named a Mayastor Pool (MSP).
// Each MSN may have zero, one, or more such pools associated with it.  The ownership of a pool by a MSN is exclusive.
// In the current version of Mayastor, a pool may have only a single block device member, which constitutes the entire data persistence layer for that pool.
// Each MSP include a unique name for the pool, the host name of the MSN on which it is hosted and a reference to a disk device which is accessible from that node (for inclusion within the pool).
// The pool definition allows the reference to its member disk to adhere to one of a number of possible schemes, each associated with a specific access
// mechanism/transport/device type and differentiated by corresponding performance and/or attachment locality.
type OpenebsMayastorPoolType struct {
	// Mayastor Pool Name
	//
	// x-displayName: "Mayastor Pool Name"
	// x-example: "maya-pool-01"
	// x-required
	// Enter Mayastor Pool Name
	PoolName string `protobuf:"bytes,1,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty"`
	// Node Name
	//
	// x-displayName: "Node Name"
	// x-required
	// x-example: "master-0"
	// Enter k8s node name of Mayastor Node (MSN) where this pool is or going to be located.
	Node string `protobuf:"bytes,2,opt,name=node,proto3" json:"node,omitempty"`
	// List of Disk Devices
	//
	// x-displayName: "List of  Disk Devices"
	// x-required
	// x-example: "/dev/sdb"
	// List of Disk Devices on Mayastore Node (MSN). Once Mayastor has created a pool it is assumed that it henceforth has exclusive use of the associated
	// disk device; it should not be partitioned, formatted, or shared with another application or process.  Any existing data on the device will be destroyed.
	// It supports various types such as "/dev/sdb", "nvme://nqn.2014-08.com.vendor:nvme:nvm-subsystem-sn-d78432" or "iscsi://iqn.2000-08.com.datacore.com:cloudvm41-2".
	PoolDiskDevices []string `protobuf:"bytes,3,rep,name=pool_disk_devices,json=poolDiskDevices" json:"pool_disk_devices,omitempty"`
}

func (m *OpenebsMayastorPoolType) Reset()                    { *m = OpenebsMayastorPoolType{} }
func (*OpenebsMayastorPoolType) ProtoMessage()               {}
func (*OpenebsMayastorPoolType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

func (m *OpenebsMayastorPoolType) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

func (m *OpenebsMayastorPoolType) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

func (m *OpenebsMayastorPoolType) GetPoolDiskDevices() []string {
	if m != nil {
		return m.PoolDiskDevices
	}
	return nil
}

// Dell EMC isilon F800
//
// x-displayName: "Dell EMC isilon F800"
// Device configuration for Dell EMC isilon F800
type StorageDeviceDellIsilonF800Type struct {
	// Username
	//
	// x-displayName: "Username"
	// x-example: "string:///YWRtaW4="
	// x-required
	// Base64 encoded username
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	// Password
	//
	// x-displayName: "Password"
	// Please Enter you password.
	Password *ves_io_schema4.SecretType `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
	//  Select Network Security Mode
	//
	// x-displayName: "Select Network Security mode"
	// x-required
	// Select if network is secure or insecure, if insecure use https
	//
	// Types that are valid to be assigned to HttpsChoice:
	//	*StorageDeviceDellIsilonF800Type_SecureNetwork
	//	*StorageDeviceDellIsilonF800Type_TrustedCaUrl
	HttpsChoice isStorageDeviceDellIsilonF800Type_HttpsChoice `protobuf_oneof:"https_choice"`
	//  Select Storage server address
	//
	// x-displayName: "Select Storage server address"
	// x-required
	// Select how to reach API server.
	//
	// Types that are valid to be assigned to AddressChoice:
	//	*StorageDeviceDellIsilonF800Type_ApiServerName
	//	*StorageDeviceDellIsilonF800Type_ApiServerIpAddress
	AddressChoice isStorageDeviceDellIsilonF800Type_AddressChoice `protobuf_oneof:"address_choice"`
	// Storage server Port
	//
	// x-displayName: "Storage server Port"
	// x-example: "8080"
	// Enter Storage Server Port
	ApiServerPort uint32 `protobuf:"varint,9,opt,name=api_server_port,json=apiServerPort,proto3" json:"api_server_port,omitempty"`
	// iSCSI Access Zone
	//
	// x-displayName: "iSCSI Access Zone"
	// x-example: "System"
	// The name of the access zone, a volume can be created in
	IscsiAccessZone string `protobuf:"bytes,10,opt,name=iscsi_access_zone,json=iscsiAccessZone,proto3" json:"iscsi_access_zone,omitempty"`
	// Volume Prefix
	//
	// x-displayName: "Volume Prefix"
	// x-example: "k8s"
	// Volume prefix is a string prepended to each volume created by the CSI driver
	VolumePrefix string `protobuf:"bytes,11,opt,name=volume_prefix,json=volumePrefix,proto3" json:"volume_prefix,omitempty"`
	// Base Path
	//
	// x-displayName: "Base Path
	// x-example: "/ifs/data/csi"
	// The default base path for the volumes to be created, this will be used if a storage class does not have the IsiPath parameter specified Ensure that this path exists on Isilon.
	BasePath string `protobuf:"bytes,12,opt,name=base_path,json=basePath,proto3" json:"base_path,omitempty"`
}

func (m *StorageDeviceDellIsilonF800Type) Reset()      { *m = StorageDeviceDellIsilonF800Type{} }
func (*StorageDeviceDellIsilonF800Type) ProtoMessage() {}
func (*StorageDeviceDellIsilonF800Type) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{7}
}

type isStorageDeviceDellIsilonF800Type_HttpsChoice interface {
	isStorageDeviceDellIsilonF800Type_HttpsChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isStorageDeviceDellIsilonF800Type_AddressChoice interface {
	isStorageDeviceDellIsilonF800Type_AddressChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type StorageDeviceDellIsilonF800Type_SecureNetwork struct {
	SecureNetwork *ves_io_schema4.Empty `protobuf:"bytes,4,opt,name=secure_network,json=secureNetwork,oneof"`
}
type StorageDeviceDellIsilonF800Type_TrustedCaUrl struct {
	TrustedCaUrl string `protobuf:"bytes,5,opt,name=trusted_ca_url,json=trustedCaUrl,proto3,oneof"`
}
type StorageDeviceDellIsilonF800Type_ApiServerName struct {
	ApiServerName string `protobuf:"bytes,7,opt,name=api_server_name,json=apiServerName,proto3,oneof"`
}
type StorageDeviceDellIsilonF800Type_ApiServerIpAddress struct {
	ApiServerIpAddress string `protobuf:"bytes,8,opt,name=api_server_ip_address,json=apiServerIpAddress,proto3,oneof"`
}

func (*StorageDeviceDellIsilonF800Type_SecureNetwork) isStorageDeviceDellIsilonF800Type_HttpsChoice() {
}
func (*StorageDeviceDellIsilonF800Type_TrustedCaUrl) isStorageDeviceDellIsilonF800Type_HttpsChoice() {
}
func (*StorageDeviceDellIsilonF800Type_ApiServerName) isStorageDeviceDellIsilonF800Type_AddressChoice() {
}
func (*StorageDeviceDellIsilonF800Type_ApiServerIpAddress) isStorageDeviceDellIsilonF800Type_AddressChoice() {
}

func (m *StorageDeviceDellIsilonF800Type) GetHttpsChoice() isStorageDeviceDellIsilonF800Type_HttpsChoice {
	if m != nil {
		return m.HttpsChoice
	}
	return nil
}
func (m *StorageDeviceDellIsilonF800Type) GetAddressChoice() isStorageDeviceDellIsilonF800Type_AddressChoice {
	if m != nil {
		return m.AddressChoice
	}
	return nil
}

func (m *StorageDeviceDellIsilonF800Type) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *StorageDeviceDellIsilonF800Type) GetPassword() *ves_io_schema4.SecretType {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *StorageDeviceDellIsilonF800Type) GetSecureNetwork() *ves_io_schema4.Empty {
	if x, ok := m.GetHttpsChoice().(*StorageDeviceDellIsilonF800Type_SecureNetwork); ok {
		return x.SecureNetwork
	}
	return nil
}

func (m *StorageDeviceDellIsilonF800Type) GetTrustedCaUrl() string {
	if x, ok := m.GetHttpsChoice().(*StorageDeviceDellIsilonF800Type_TrustedCaUrl); ok {
		return x.TrustedCaUrl
	}
	return ""
}

func (m *StorageDeviceDellIsilonF800Type) GetApiServerName() string {
	if x, ok := m.GetAddressChoice().(*StorageDeviceDellIsilonF800Type_ApiServerName); ok {
		return x.ApiServerName
	}
	return ""
}

func (m *StorageDeviceDellIsilonF800Type) GetApiServerIpAddress() string {
	if x, ok := m.GetAddressChoice().(*StorageDeviceDellIsilonF800Type_ApiServerIpAddress); ok {
		return x.ApiServerIpAddress
	}
	return ""
}

func (m *StorageDeviceDellIsilonF800Type) GetApiServerPort() uint32 {
	if m != nil {
		return m.ApiServerPort
	}
	return 0
}

func (m *StorageDeviceDellIsilonF800Type) GetIscsiAccessZone() string {
	if m != nil {
		return m.IscsiAccessZone
	}
	return ""
}

func (m *StorageDeviceDellIsilonF800Type) GetVolumePrefix() string {
	if m != nil {
		return m.VolumePrefix
	}
	return ""
}

func (m *StorageDeviceDellIsilonF800Type) GetBasePath() string {
	if m != nil {
		return m.BasePath
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StorageDeviceDellIsilonF800Type) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StorageDeviceDellIsilonF800Type_OneofMarshaler, _StorageDeviceDellIsilonF800Type_OneofUnmarshaler, _StorageDeviceDellIsilonF800Type_OneofSizer, []interface{}{
		(*StorageDeviceDellIsilonF800Type_SecureNetwork)(nil),
		(*StorageDeviceDellIsilonF800Type_TrustedCaUrl)(nil),
		(*StorageDeviceDellIsilonF800Type_ApiServerName)(nil),
		(*StorageDeviceDellIsilonF800Type_ApiServerIpAddress)(nil),
	}
}

func _StorageDeviceDellIsilonF800Type_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StorageDeviceDellIsilonF800Type)
	// https_choice
	switch x := m.HttpsChoice.(type) {
	case *StorageDeviceDellIsilonF800Type_SecureNetwork:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SecureNetwork); err != nil {
			return err
		}
	case *StorageDeviceDellIsilonF800Type_TrustedCaUrl:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.TrustedCaUrl)
	case nil:
	default:
		return fmt.Errorf("StorageDeviceDellIsilonF800Type.HttpsChoice has unexpected type %T", x)
	}
	// address_choice
	switch x := m.AddressChoice.(type) {
	case *StorageDeviceDellIsilonF800Type_ApiServerName:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ApiServerName)
	case *StorageDeviceDellIsilonF800Type_ApiServerIpAddress:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ApiServerIpAddress)
	case nil:
	default:
		return fmt.Errorf("StorageDeviceDellIsilonF800Type.AddressChoice has unexpected type %T", x)
	}
	return nil
}

func _StorageDeviceDellIsilonF800Type_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StorageDeviceDellIsilonF800Type)
	switch tag {
	case 4: // https_choice.secure_network
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.HttpsChoice = &StorageDeviceDellIsilonF800Type_SecureNetwork{msg}
		return true, err
	case 5: // https_choice.trusted_ca_url
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.HttpsChoice = &StorageDeviceDellIsilonF800Type_TrustedCaUrl{x}
		return true, err
	case 7: // address_choice.api_server_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.AddressChoice = &StorageDeviceDellIsilonF800Type_ApiServerName{x}
		return true, err
	case 8: // address_choice.api_server_ip_address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.AddressChoice = &StorageDeviceDellIsilonF800Type_ApiServerIpAddress{x}
		return true, err
	default:
		return false, nil
	}
}

func _StorageDeviceDellIsilonF800Type_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StorageDeviceDellIsilonF800Type)
	// https_choice
	switch x := m.HttpsChoice.(type) {
	case *StorageDeviceDellIsilonF800Type_SecureNetwork:
		s := proto.Size(x.SecureNetwork)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StorageDeviceDellIsilonF800Type_TrustedCaUrl:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.TrustedCaUrl)))
		n += len(x.TrustedCaUrl)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// address_choice
	switch x := m.AddressChoice.(type) {
	case *StorageDeviceDellIsilonF800Type_ApiServerName:
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ApiServerName)))
		n += len(x.ApiServerName)
	case *StorageDeviceDellIsilonF800Type_ApiServerIpAddress:
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ApiServerIpAddress)))
		n += len(x.ApiServerIpAddress)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// HPE Nimbus Storage AF40
//
// x-displayName: "HPE Nimbus Storage AF40"
// Device configuration for HPE Nimbus Storage AF40
type StorageDeviceHPENimbusStorageAf40Type struct {
	// Storage Server Name
	//
	// x-displayName: "Storage Server Name"
	// Enter storage server Name
	StorageServerName string `protobuf:"bytes,1,opt,name=storage_server_name,json=storageServerName,proto3" json:"storage_server_name,omitempty"`
	// Storage Server IP address
	//
	// x-displayName: "Storage Server IP address"
	// Enter storage server IP address
	StorageServerIpAddress string `protobuf:"bytes,2,opt,name=storage_server_ip_address,json=storageServerIpAddress,proto3" json:"storage_server_ip_address,omitempty"`
	// Storage server Port
	//
	// x-displayName: "Storage server Port"
	// x-example: "8080"
	// Enter Storage Server Port
	ApiServerPort uint32 `protobuf:"varint,3,opt,name=api_server_port,json=apiServerPort,proto3" json:"api_server_port,omitempty"`
	// Username
	//
	// x-displayName: "Username"
	// x-example: "string:///YWRtaW4="
	// x-required
	// Base64 encoded username
	Username string `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
	// Password
	//
	// x-displayName: "Password"
	// Please Enter you password.
	Password *ves_io_schema4.SecretType `protobuf:"bytes,5,opt,name=password" json:"password,omitempty"`
	// Performance Policy
	//
	// x-displayName: "Performance Policy"
	// x-example: "Other"
	// Performance Policy for this storage Class
	PerfPolicy string `protobuf:"bytes,6,opt,name=perf_policy,json=perfPolicy,proto3" json:"perf_policy,omitempty"`
	// IOP Limit
	//
	// x-displayName: "IOP Limit"
	// x-example: "76800"
	// I/O operations per second limit for this storage class
	LimitIops uint32 `protobuf:"varint,7,opt,name=limit_iops,json=limitIops,proto3" json:"limit_iops,omitempty"`
	// MBPS Limit
	//
	// x-displayName: "MBPS Limit"
	// x-example: "10000"
	// Mega Byte per second data thruput limit.
	LimitMbps uint32 `protobuf:"varint,8,opt,name=limit_mbps,json=limitMbps,proto3" json:"limit_mbps,omitempty"`
}

func (m *StorageDeviceHPENimbusStorageAf40Type) Reset()      { *m = StorageDeviceHPENimbusStorageAf40Type{} }
func (*StorageDeviceHPENimbusStorageAf40Type) ProtoMessage() {}
func (*StorageDeviceHPENimbusStorageAf40Type) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{8}
}

func (m *StorageDeviceHPENimbusStorageAf40Type) GetStorageServerName() string {
	if m != nil {
		return m.StorageServerName
	}
	return ""
}

func (m *StorageDeviceHPENimbusStorageAf40Type) GetStorageServerIpAddress() string {
	if m != nil {
		return m.StorageServerIpAddress
	}
	return ""
}

func (m *StorageDeviceHPENimbusStorageAf40Type) GetApiServerPort() uint32 {
	if m != nil {
		return m.ApiServerPort
	}
	return 0
}

func (m *StorageDeviceHPENimbusStorageAf40Type) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *StorageDeviceHPENimbusStorageAf40Type) GetPassword() *ves_io_schema4.SecretType {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *StorageDeviceHPENimbusStorageAf40Type) GetPerfPolicy() string {
	if m != nil {
		return m.PerfPolicy
	}
	return ""
}

func (m *StorageDeviceHPENimbusStorageAf40Type) GetLimitIops() uint32 {
	if m != nil {
		return m.LimitIops
	}
	return 0
}

func (m *StorageDeviceHPENimbusStorageAf40Type) GetLimitMbps() uint32 {
	if m != nil {
		return m.LimitMbps
	}
	return 0
}

// Pure Storage Service Orchestrator
//
// x-displayName: "Pure Storage Service Orchestrator"
// Device configuration for Pure Storage Service Orchestrator
type StorageDevicePureStorageServiceOrchestratorType struct {
	// Cluster ID
	//
	// x-displayName: "Cluster ID"
	// x-required
	// x-example: "cluster1"
	// clusterID is added as a prefix for all volumes created by this PSO installation.
	// clusterID is also used to identify the volumes used by the datastore, pso-db.
	// clusterID MUST BE UNIQUE for multiple K8s clusters running on top of the same storage arrays.
	// characters allowed: alphanumeric and underscores
	ClusterId string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// Enable Storage Topology
	//
	// x-displayName: "Enable Storage Topology"
	// This option is to enable/disable the csi topology feature for pso-csi
	EnableStorageTopology bool `protobuf:"varint,2,opt,name=enable_storage_topology,json=enableStorageTopology,proto3" json:"enable_storage_topology,omitempty"`
	// Enable Strict Topology
	//
	// x-displayName: "Enable Strict Topology"
	// This option is to enable/disable the strict csi topology feature for pso-csi
	EnableStrictTopology bool `protobuf:"varint,3,opt,name=enable_strict_topology,json=enableStrictTopology,proto3" json:"enable_strict_topology,omitempty"`
	// Arrays Configuration
	//
	// x-displayName: "Arrays Configuration"
	// x-required
	// This section configure PSO storage arrays
	Arrays *PsoArrayConfiguration `protobuf:"bytes,4,opt,name=arrays" json:"arrays,omitempty"`
}

func (m *StorageDevicePureStorageServiceOrchestratorType) Reset() {
	*m = StorageDevicePureStorageServiceOrchestratorType{}
}
func (*StorageDevicePureStorageServiceOrchestratorType) ProtoMessage() {}
func (*StorageDevicePureStorageServiceOrchestratorType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{9}
}

func (m *StorageDevicePureStorageServiceOrchestratorType) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *StorageDevicePureStorageServiceOrchestratorType) GetEnableStorageTopology() bool {
	if m != nil {
		return m.EnableStorageTopology
	}
	return false
}

func (m *StorageDevicePureStorageServiceOrchestratorType) GetEnableStrictTopology() bool {
	if m != nil {
		return m.EnableStrictTopology
	}
	return false
}

func (m *StorageDevicePureStorageServiceOrchestratorType) GetArrays() *PsoArrayConfiguration {
	if m != nil {
		return m.Arrays
	}
	return nil
}

// Arrays Configuration
//
// x-displayName: "Arrays Configuration"
// Device configuration for PSO Arrays
type PsoArrayConfiguration struct {
	// Flash Arrays
	//
	// x-displayName: "Flash Arrays"
	// Specify what storage flash arrays should be managed the plugin
	// For FlashArrays you must set the "mgmt_endpoint" and "api_token"
	FlashArray *FlashArrayType `protobuf:"bytes,1,opt,name=flash_array,json=flashArray" json:"flash_array,omitempty"`
	// Flash Blade
	//
	// x-displayName: "Flash Blade"
	// Specify what storage flash blades should be managed the plugin
	FlashBlade *FlashBladeType `protobuf:"bytes,2,opt,name=flash_blade,json=flashBlade" json:"flash_blade,omitempty"`
}

func (m *PsoArrayConfiguration) Reset()                    { *m = PsoArrayConfiguration{} }
func (*PsoArrayConfiguration) ProtoMessage()               {}
func (*PsoArrayConfiguration) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

func (m *PsoArrayConfiguration) GetFlashArray() *FlashArrayType {
	if m != nil {
		return m.FlashArray
	}
	return nil
}

func (m *PsoArrayConfiguration) GetFlashBlade() *FlashBladeType {
	if m != nil {
		return m.FlashBlade
	}
	return nil
}

// Flash Blades
//
// x-displayName: "Flash Blades"
// Specify what storage flash blades should be managed the plugin
type FlashBladeType struct {
	// Enable Snapshot Directory
	//
	// x-displayName: "Enable Snapshot Directory"
	// Enable/Disable FlashBlade snapshots
	EnableSnapshotDirectory bool `protobuf:"varint,1,opt,name=enable_snapshot_directory,json=enableSnapshotDirectory,proto3" json:"enable_snapshot_directory,omitempty"`
	// NFS Export Rules
	//
	// x-displayName: "NFS Export Rules"
	// x-example: "*(rw,no_root_squash)"
	// NFS Export rules
	ExportRules string `protobuf:"bytes,2,opt,name=export_rules,json=exportRules,proto3" json:"export_rules,omitempty"`
	// Flash Blades
	//
	// x-displayName: "Flash Blades"
	// x-required
	// For FlashBlades you must set the "mgmt_endpoint", "api_token" and nfs_endpoint
	FlashBlades []*FlashBladeEndpoint `protobuf:"bytes,3,rep,name=flash_blades,json=flashBlades" json:"flash_blades,omitempty"`
}

func (m *FlashBladeType) Reset()                    { *m = FlashBladeType{} }
func (*FlashBladeType) ProtoMessage()               {}
func (*FlashBladeType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

func (m *FlashBladeType) GetEnableSnapshotDirectory() bool {
	if m != nil {
		return m.EnableSnapshotDirectory
	}
	return false
}

func (m *FlashBladeType) GetExportRules() string {
	if m != nil {
		return m.ExportRules
	}
	return ""
}

func (m *FlashBladeType) GetFlashBlades() []*FlashBladeEndpoint {
	if m != nil {
		return m.FlashBlades
	}
	return nil
}

// Flash Blade Endpoint
//
// x-displayName: "Flash Blade Endpoint"
// For FlashBlades you must set the "mgmt_endpoint", "api_token" and nfs_endpoint
type FlashBladeEndpoint struct {
	// Management Endpoint
	//
	// x-displayName: "Management Endpoint"
	// x-required
	// FQDN or IP address of PSO Management endpoint
	//
	// Types that are valid to be assigned to MgmtEndpoint:
	//	*FlashBladeEndpoint_MgmtIp
	//	*FlashBladeEndpoint_MgmtDnsName
	MgmtEndpoint isFlashBladeEndpoint_MgmtEndpoint `protobuf_oneof:"mgmt_endpoint"`
	// API Token
	//
	// x-displayName: "API Token"
	// Please Enter API TOken. Token to connect to management interface
	ApiToken *ves_io_schema4.SecretType `protobuf:"bytes,4,opt,name=api_token,json=apiToken" json:"api_token,omitempty"`
	// NFS Endpoint
	//
	// x-displayName: "NFS Endpoint"
	// x-required
	// x-example: "192.168.10.10"
	// FQDN or IP address of PSO NFS endpoint
	//
	// Types that are valid to be assigned to NfsEndpoint:
	//	*FlashBladeEndpoint_NfsEndpointIp
	//	*FlashBladeEndpoint_NfsEndpointDnsName
	NfsEndpoint isFlashBladeEndpoint_NfsEndpoint `protobuf_oneof:"nfs_endpoint"`
	// Labels
	//
	// x-displayName: "Labels"
	// x-example: "{"rack": "22"}"
	// The labels are optional, and can be any key-value pair for use with the PSO "fleet" provisioner.
	Lables map[string]string `protobuf:"bytes,8,rep,name=lables" json:"lables,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FlashBladeEndpoint) Reset()                    { *m = FlashBladeEndpoint{} }
func (*FlashBladeEndpoint) ProtoMessage()               {}
func (*FlashBladeEndpoint) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{12} }

type isFlashBladeEndpoint_MgmtEndpoint interface {
	isFlashBladeEndpoint_MgmtEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isFlashBladeEndpoint_NfsEndpoint interface {
	isFlashBladeEndpoint_NfsEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type FlashBladeEndpoint_MgmtIp struct {
	MgmtIp string `protobuf:"bytes,2,opt,name=mgmt_ip,json=mgmtIp,proto3,oneof"`
}
type FlashBladeEndpoint_MgmtDnsName struct {
	MgmtDnsName string `protobuf:"bytes,3,opt,name=mgmt_dns_name,json=mgmtDnsName,proto3,oneof"`
}
type FlashBladeEndpoint_NfsEndpointIp struct {
	NfsEndpointIp string `protobuf:"bytes,6,opt,name=nfs_endpoint_ip,json=nfsEndpointIp,proto3,oneof"`
}
type FlashBladeEndpoint_NfsEndpointDnsName struct {
	NfsEndpointDnsName string `protobuf:"bytes,7,opt,name=nfs_endpoint_dns_name,json=nfsEndpointDnsName,proto3,oneof"`
}

func (*FlashBladeEndpoint_MgmtIp) isFlashBladeEndpoint_MgmtEndpoint()            {}
func (*FlashBladeEndpoint_MgmtDnsName) isFlashBladeEndpoint_MgmtEndpoint()       {}
func (*FlashBladeEndpoint_NfsEndpointIp) isFlashBladeEndpoint_NfsEndpoint()      {}
func (*FlashBladeEndpoint_NfsEndpointDnsName) isFlashBladeEndpoint_NfsEndpoint() {}

func (m *FlashBladeEndpoint) GetMgmtEndpoint() isFlashBladeEndpoint_MgmtEndpoint {
	if m != nil {
		return m.MgmtEndpoint
	}
	return nil
}
func (m *FlashBladeEndpoint) GetNfsEndpoint() isFlashBladeEndpoint_NfsEndpoint {
	if m != nil {
		return m.NfsEndpoint
	}
	return nil
}

func (m *FlashBladeEndpoint) GetMgmtIp() string {
	if x, ok := m.GetMgmtEndpoint().(*FlashBladeEndpoint_MgmtIp); ok {
		return x.MgmtIp
	}
	return ""
}

func (m *FlashBladeEndpoint) GetMgmtDnsName() string {
	if x, ok := m.GetMgmtEndpoint().(*FlashBladeEndpoint_MgmtDnsName); ok {
		return x.MgmtDnsName
	}
	return ""
}

func (m *FlashBladeEndpoint) GetApiToken() *ves_io_schema4.SecretType {
	if m != nil {
		return m.ApiToken
	}
	return nil
}

func (m *FlashBladeEndpoint) GetNfsEndpointIp() string {
	if x, ok := m.GetNfsEndpoint().(*FlashBladeEndpoint_NfsEndpointIp); ok {
		return x.NfsEndpointIp
	}
	return ""
}

func (m *FlashBladeEndpoint) GetNfsEndpointDnsName() string {
	if x, ok := m.GetNfsEndpoint().(*FlashBladeEndpoint_NfsEndpointDnsName); ok {
		return x.NfsEndpointDnsName
	}
	return ""
}

func (m *FlashBladeEndpoint) GetLables() map[string]string {
	if m != nil {
		return m.Lables
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FlashBladeEndpoint) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FlashBladeEndpoint_OneofMarshaler, _FlashBladeEndpoint_OneofUnmarshaler, _FlashBladeEndpoint_OneofSizer, []interface{}{
		(*FlashBladeEndpoint_MgmtIp)(nil),
		(*FlashBladeEndpoint_MgmtDnsName)(nil),
		(*FlashBladeEndpoint_NfsEndpointIp)(nil),
		(*FlashBladeEndpoint_NfsEndpointDnsName)(nil),
	}
}

func _FlashBladeEndpoint_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FlashBladeEndpoint)
	// mgmt_endpoint
	switch x := m.MgmtEndpoint.(type) {
	case *FlashBladeEndpoint_MgmtIp:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.MgmtIp)
	case *FlashBladeEndpoint_MgmtDnsName:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.MgmtDnsName)
	case nil:
	default:
		return fmt.Errorf("FlashBladeEndpoint.MgmtEndpoint has unexpected type %T", x)
	}
	// nfs_endpoint
	switch x := m.NfsEndpoint.(type) {
	case *FlashBladeEndpoint_NfsEndpointIp:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.NfsEndpointIp)
	case *FlashBladeEndpoint_NfsEndpointDnsName:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.NfsEndpointDnsName)
	case nil:
	default:
		return fmt.Errorf("FlashBladeEndpoint.NfsEndpoint has unexpected type %T", x)
	}
	return nil
}

func _FlashBladeEndpoint_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FlashBladeEndpoint)
	switch tag {
	case 2: // mgmt_endpoint.mgmt_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MgmtEndpoint = &FlashBladeEndpoint_MgmtIp{x}
		return true, err
	case 3: // mgmt_endpoint.mgmt_dns_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MgmtEndpoint = &FlashBladeEndpoint_MgmtDnsName{x}
		return true, err
	case 6: // nfs_endpoint.nfs_endpoint_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.NfsEndpoint = &FlashBladeEndpoint_NfsEndpointIp{x}
		return true, err
	case 7: // nfs_endpoint.nfs_endpoint_dns_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.NfsEndpoint = &FlashBladeEndpoint_NfsEndpointDnsName{x}
		return true, err
	default:
		return false, nil
	}
}

func _FlashBladeEndpoint_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FlashBladeEndpoint)
	// mgmt_endpoint
	switch x := m.MgmtEndpoint.(type) {
	case *FlashBladeEndpoint_MgmtIp:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.MgmtIp)))
		n += len(x.MgmtIp)
	case *FlashBladeEndpoint_MgmtDnsName:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.MgmtDnsName)))
		n += len(x.MgmtDnsName)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// nfs_endpoint
	switch x := m.NfsEndpoint.(type) {
	case *FlashBladeEndpoint_NfsEndpointIp:
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.NfsEndpointIp)))
		n += len(x.NfsEndpointIp)
	case *FlashBladeEndpoint_NfsEndpointDnsName:
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.NfsEndpointDnsName)))
		n += len(x.NfsEndpointDnsName)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Flash Arrays
//
// x-displayName: "Flash Arrays"
// Specify what storage flash arrays should be managed the plugin
type FlashArrayType struct {
	// SAN Type
	//
	// x-displayName: "SAN Type"
	// x-required
	// x-example: "ISCSI"
	// Block volume access protocol, either ISCSI or FC
	SanType string `protobuf:"bytes,1,opt,name=san_type,json=sanType,proto3" json:"san_type,omitempty"`
	// Default Filesystem Type
	//
	// x-displayName: "Default Filesystem Type"
	// x-required
	// x-example: "xfs"
	// Block volume default filesystem type. Not recommended to change!
	DefaultFsType string `protobuf:"bytes,2,opt,name=default_fs_type,json=defaultFsType,proto3" json:"default_fs_type,omitempty"`
	// Default Filesystem Options
	//
	// x-displayName: "Default Filesystem Options"
	// x-example: "-q"
	// Block volume default mkfs options. Not recommended to change!
	DefaultFsOpt string `protobuf:"bytes,3,opt,name=default_fs_opt,json=defaultFsOpt,proto3" json:"default_fs_opt,omitempty"`
	// Default Mount Options
	//
	// x-displayName: "Default Mount Options"
	// x-example: "[- discart]"
	// Block volume default filesystem mount options. Not recommended to change!
	DefaultMountOpts []string `protobuf:"bytes,4,rep,name=default_mount_opts,json=defaultMountOpts" json:"default_mount_opts,omitempty"`
	// Disable Preempt Attachments
	//
	// x-displayName: "Disable Preempt Attachments"
	// Enable/Disable attachment preemption!
	DisablePreemptAttachments bool `protobuf:"varint,5,opt,name=disable_preempt_attachments,json=disablePreemptAttachments,proto3" json:"disable_preempt_attachments,omitempty"`
	// iSCSI Login Timeout
	//
	// x-displayName: "iSCSI Login Timeout"
	// x-required
	// x-exmple: "20"
	// iSCSI login timeout in seconds. Not recommended to change!
	IscsiLoginTimeout int32 `protobuf:"varint,6,opt,name=iscsi_login_timeout,json=iscsiLoginTimeout,proto3" json:"iscsi_login_timeout,omitempty"`
	// Flash Arrays
	//
	// x-displayName: "Flash Arrays"
	// x-required
	// For FlashArrays you must set the "mgmt_endpoint" and "api_token"
	FlashArrays []*FlashArrayEndpoint `protobuf:"bytes,7,rep,name=flash_arrays,json=flashArrays" json:"flash_arrays,omitempty"`
}

func (m *FlashArrayType) Reset()                    { *m = FlashArrayType{} }
func (*FlashArrayType) ProtoMessage()               {}
func (*FlashArrayType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13} }

func (m *FlashArrayType) GetSanType() string {
	if m != nil {
		return m.SanType
	}
	return ""
}

func (m *FlashArrayType) GetDefaultFsType() string {
	if m != nil {
		return m.DefaultFsType
	}
	return ""
}

func (m *FlashArrayType) GetDefaultFsOpt() string {
	if m != nil {
		return m.DefaultFsOpt
	}
	return ""
}

func (m *FlashArrayType) GetDefaultMountOpts() []string {
	if m != nil {
		return m.DefaultMountOpts
	}
	return nil
}

func (m *FlashArrayType) GetDisablePreemptAttachments() bool {
	if m != nil {
		return m.DisablePreemptAttachments
	}
	return false
}

func (m *FlashArrayType) GetIscsiLoginTimeout() int32 {
	if m != nil {
		return m.IscsiLoginTimeout
	}
	return 0
}

func (m *FlashArrayType) GetFlashArrays() []*FlashArrayEndpoint {
	if m != nil {
		return m.FlashArrays
	}
	return nil
}

// Flash Array Endpoint
//
// x-displayName: "Flash Array Endpoint"
// For FlashArrays you must set the "mgmt_endpoint" and "api_token"
type FlashArrayEndpoint struct {
	// Management Endpoint
	//
	// x-displayName: "Management Endpoint"
	// x-required
	// FQDN or IP address of PSO Management endpoint
	//
	// Types that are valid to be assigned to MgmtEndpoint:
	//	*FlashArrayEndpoint_MgmtIp
	//	*FlashArrayEndpoint_MgmtDnsName
	MgmtEndpoint isFlashArrayEndpoint_MgmtEndpoint `protobuf_oneof:"mgmt_endpoint"`
	// API Token
	//
	// x-displayName: "API Token"
	// Please Enter API TOken. Token to connect to management interface
	ApiToken *ves_io_schema4.SecretType `protobuf:"bytes,4,opt,name=api_token,json=apiToken" json:"api_token,omitempty"`
	// Labels
	//
	// x-displayName: "Labels"
	// x-example: "{"rack": "22"}"
	// The labels are optional, and can be any key-value pair for use with the PSO "fleet" provisioner.
	Labels map[string]string `protobuf:"bytes,5,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FlashArrayEndpoint) Reset()                    { *m = FlashArrayEndpoint{} }
func (*FlashArrayEndpoint) ProtoMessage()               {}
func (*FlashArrayEndpoint) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14} }

type isFlashArrayEndpoint_MgmtEndpoint interface {
	isFlashArrayEndpoint_MgmtEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type FlashArrayEndpoint_MgmtIp struct {
	MgmtIp string `protobuf:"bytes,2,opt,name=mgmt_ip,json=mgmtIp,proto3,oneof"`
}
type FlashArrayEndpoint_MgmtDnsName struct {
	MgmtDnsName string `protobuf:"bytes,3,opt,name=mgmt_dns_name,json=mgmtDnsName,proto3,oneof"`
}

func (*FlashArrayEndpoint_MgmtIp) isFlashArrayEndpoint_MgmtEndpoint()      {}
func (*FlashArrayEndpoint_MgmtDnsName) isFlashArrayEndpoint_MgmtEndpoint() {}

func (m *FlashArrayEndpoint) GetMgmtEndpoint() isFlashArrayEndpoint_MgmtEndpoint {
	if m != nil {
		return m.MgmtEndpoint
	}
	return nil
}

func (m *FlashArrayEndpoint) GetMgmtIp() string {
	if x, ok := m.GetMgmtEndpoint().(*FlashArrayEndpoint_MgmtIp); ok {
		return x.MgmtIp
	}
	return ""
}

func (m *FlashArrayEndpoint) GetMgmtDnsName() string {
	if x, ok := m.GetMgmtEndpoint().(*FlashArrayEndpoint_MgmtDnsName); ok {
		return x.MgmtDnsName
	}
	return ""
}

func (m *FlashArrayEndpoint) GetApiToken() *ves_io_schema4.SecretType {
	if m != nil {
		return m.ApiToken
	}
	return nil
}

func (m *FlashArrayEndpoint) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FlashArrayEndpoint) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FlashArrayEndpoint_OneofMarshaler, _FlashArrayEndpoint_OneofUnmarshaler, _FlashArrayEndpoint_OneofSizer, []interface{}{
		(*FlashArrayEndpoint_MgmtIp)(nil),
		(*FlashArrayEndpoint_MgmtDnsName)(nil),
	}
}

func _FlashArrayEndpoint_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FlashArrayEndpoint)
	// mgmt_endpoint
	switch x := m.MgmtEndpoint.(type) {
	case *FlashArrayEndpoint_MgmtIp:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.MgmtIp)
	case *FlashArrayEndpoint_MgmtDnsName:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.MgmtDnsName)
	case nil:
	default:
		return fmt.Errorf("FlashArrayEndpoint.MgmtEndpoint has unexpected type %T", x)
	}
	return nil
}

func _FlashArrayEndpoint_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FlashArrayEndpoint)
	switch tag {
	case 2: // mgmt_endpoint.mgmt_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MgmtEndpoint = &FlashArrayEndpoint_MgmtIp{x}
		return true, err
	case 3: // mgmt_endpoint.mgmt_dns_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MgmtEndpoint = &FlashArrayEndpoint_MgmtDnsName{x}
		return true, err
	default:
		return false, nil
	}
}

func _FlashArrayEndpoint_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FlashArrayEndpoint)
	// mgmt_endpoint
	switch x := m.MgmtEndpoint.(type) {
	case *FlashArrayEndpoint_MgmtIp:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.MgmtIp)))
		n += len(x.MgmtIp)
	case *FlashArrayEndpoint_MgmtDnsName:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.MgmtDnsName)))
		n += len(x.MgmtDnsName)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// NetApp Trident
//
// x-displayName: "NetApp Trident"
// Device configuration for NetApp Trident Storage
type StorageDeviceNetappTridentType struct {
	// Select NetApp Trident Backend
	//
	// x-displayName: "Select NetApp Trident Backend"
	// x-required
	// Select type of backend to configure
	//
	// Types that are valid to be assigned to BackendChoice:
	//	*StorageDeviceNetappTridentType_NetappBackendOntapNas
	//	*StorageDeviceNetappTridentType_NetappBackendOntapSan
	BackendChoice isStorageDeviceNetappTridentType_BackendChoice `protobuf_oneof:"backend_choice"`
}

func (m *StorageDeviceNetappTridentType) Reset()      { *m = StorageDeviceNetappTridentType{} }
func (*StorageDeviceNetappTridentType) ProtoMessage() {}
func (*StorageDeviceNetappTridentType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{15}
}

type isStorageDeviceNetappTridentType_BackendChoice interface {
	isStorageDeviceNetappTridentType_BackendChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type StorageDeviceNetappTridentType_NetappBackendOntapNas struct {
	NetappBackendOntapNas *StorageDeviceNetappBackendOntapNasType `protobuf:"bytes,2,opt,name=netapp_backend_ontap_nas,json=netappBackendOntapNas,oneof"`
}
type StorageDeviceNetappTridentType_NetappBackendOntapSan struct {
	NetappBackendOntapSan *StorageDeviceNetappBackendOntapSanType `protobuf:"bytes,3,opt,name=netapp_backend_ontap_san,json=netappBackendOntapSan,oneof"`
}

func (*StorageDeviceNetappTridentType_NetappBackendOntapNas) isStorageDeviceNetappTridentType_BackendChoice() {
}
func (*StorageDeviceNetappTridentType_NetappBackendOntapSan) isStorageDeviceNetappTridentType_BackendChoice() {
}

func (m *StorageDeviceNetappTridentType) GetBackendChoice() isStorageDeviceNetappTridentType_BackendChoice {
	if m != nil {
		return m.BackendChoice
	}
	return nil
}

func (m *StorageDeviceNetappTridentType) GetNetappBackendOntapNas() *StorageDeviceNetappBackendOntapNasType {
	if x, ok := m.GetBackendChoice().(*StorageDeviceNetappTridentType_NetappBackendOntapNas); ok {
		return x.NetappBackendOntapNas
	}
	return nil
}

func (m *StorageDeviceNetappTridentType) GetNetappBackendOntapSan() *StorageDeviceNetappBackendOntapSanType {
	if x, ok := m.GetBackendChoice().(*StorageDeviceNetappTridentType_NetappBackendOntapSan); ok {
		return x.NetappBackendOntapSan
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StorageDeviceNetappTridentType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StorageDeviceNetappTridentType_OneofMarshaler, _StorageDeviceNetappTridentType_OneofUnmarshaler, _StorageDeviceNetappTridentType_OneofSizer, []interface{}{
		(*StorageDeviceNetappTridentType_NetappBackendOntapNas)(nil),
		(*StorageDeviceNetappTridentType_NetappBackendOntapSan)(nil),
	}
}

func _StorageDeviceNetappTridentType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StorageDeviceNetappTridentType)
	// backend_choice
	switch x := m.BackendChoice.(type) {
	case *StorageDeviceNetappTridentType_NetappBackendOntapNas:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NetappBackendOntapNas); err != nil {
			return err
		}
	case *StorageDeviceNetappTridentType_NetappBackendOntapSan:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NetappBackendOntapSan); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("StorageDeviceNetappTridentType.BackendChoice has unexpected type %T", x)
	}
	return nil
}

func _StorageDeviceNetappTridentType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StorageDeviceNetappTridentType)
	switch tag {
	case 2: // backend_choice.netapp_backend_ontap_nas
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StorageDeviceNetappBackendOntapNasType)
		err := b.DecodeMessage(msg)
		m.BackendChoice = &StorageDeviceNetappTridentType_NetappBackendOntapNas{msg}
		return true, err
	case 3: // backend_choice.netapp_backend_ontap_san
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StorageDeviceNetappBackendOntapSanType)
		err := b.DecodeMessage(msg)
		m.BackendChoice = &StorageDeviceNetappTridentType_NetappBackendOntapSan{msg}
		return true, err
	default:
		return false, nil
	}
}

func _StorageDeviceNetappTridentType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StorageDeviceNetappTridentType)
	// backend_choice
	switch x := m.BackendChoice.(type) {
	case *StorageDeviceNetappTridentType_NetappBackendOntapNas:
		s := proto.Size(x.NetappBackendOntapNas)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StorageDeviceNetappTridentType_NetappBackendOntapSan:
		s := proto.Size(x.NetappBackendOntapSan)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Storage Backend NetApp ONTAP SAN
//
// x-displayName: "Storage Backend NetApp ONTAP SAN"
// Configuration of storage backend for NetApp ONTAP SAN
type StorageDeviceNetappBackendOntapSanType struct {
	// Storage Backend Driver
	//
	// x-displayName: "Storage Backend Driver"
	// x-required
	// x-example: "ontap-nas"
	// Configuration of Backend Name
	StorageDriverName string `protobuf:"bytes,1,opt,name=storage_driver_name,json=storageDriverName,proto3" json:"storage_driver_name,omitempty"`
	// Backend Management LIF
	//
	// x-displayName: "Backend Management LIF"
	// x-required
	// FQDN or IP address of a cluster or SVM management LIF
	//
	// Types that are valid to be assigned to ManagementLif:
	//	*StorageDeviceNetappBackendOntapSanType_ManagementLifIp
	//	*StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName
	ManagementLif isStorageDeviceNetappBackendOntapSanType_ManagementLif `protobuf_oneof:"management_lif"`
	// Backend Data LIF
	//
	// x-displayName: "Backend Data LIF"
	// x-example: "192.168.10.10"
	// FQDN or IP address of protocol LIF. Use square brackets for IPv6. Once set this cannot be updated. Derived by the SVM unless specified.
	//
	// Types that are valid to be assigned to DataLif:
	//	*StorageDeviceNetappBackendOntapSanType_DataLifIp
	//	*StorageDeviceNetappBackendOntapSanType_DataLifDnsName
	DataLif isStorageDeviceNetappBackendOntapSanType_DataLif `protobuf_oneof:"data_lif"`
	// Backend SVM
	//
	// x-displayName: "Backend SVM"
	// x-example: "trident_svm"
	// Storage virtual machine to use. Derived if an SVM managementLIF is specified
	Svm string `protobuf:"bytes,9,opt,name=svm,proto3" json:"svm,omitempty"`
	// Username
	//
	// x-displayName: "Username"
	// x-example: "cluster-admin"
	// x-required
	// Username to connect to the cluster/SVM
	Username string `protobuf:"bytes,10,opt,name=username,proto3" json:"username,omitempty"`
	// Password
	//
	// x-displayName: "Password"
	// Please Enter you password. Password to connect to the cluster/SVM
	Password *ves_io_schema4.SecretType `protobuf:"bytes,11,opt,name=password" json:"password,omitempty"`
	// Use CHAP
	//
	// x-displayName: "Use CHAP"
	// Use CHAP to authenticate iSCSI for ONTAP SAN drivers.
	//
	// Types that are valid to be assigned to ChapChoice:
	//	*StorageDeviceNetappBackendOntapSanType_NoChap
	//	*StorageDeviceNetappBackendOntapSanType_UseChap
	ChapChoice isStorageDeviceNetappBackendOntapSanType_ChapChoice `protobuf_oneof:"chap_choice"`
	// iGroup Name
	//
	// x-displayName: "iGroup Name"
	// Name of the igroup for SAN volumes to use
	IgroupName string `protobuf:"bytes,17,opt,name=igroup_name,json=igroupName,proto3" json:"igroup_name,omitempty"`
	// Storage Prefix
	//
	// x-displayName: "Storage Prefix"
	// x-example: "trident"
	// Prefix used when provisioning new volumes in the SVM. Once set this cannot be updated
	StoragePrefix string `protobuf:"bytes,18,opt,name=storage_prefix,json=storagePrefix,proto3" json:"storage_prefix,omitempty"`
	// Limit Aggregate Usage
	//
	// x-displayName: "Limit Aggregate Usage"
	// x-example: "80"
	// Fail provisioning if usage is above this percentage. Not enforced by default.
	LimitAggregateUsage uint32 `protobuf:"varint,19,opt,name=limit_aggregate_usage,json=limitAggregateUsage,proto3" json:"limit_aggregate_usage,omitempty"`
	// Limit Volume Size
	//
	// x-displayName: "Limit Volume Size"
	// x-example: "50"
	// Fail provisioning if requested volume size in GBi is above this value. Not enforced by default.
	LimitVolumeSize int32 `protobuf:"varint,20,opt,name=limit_volume_size,json=limitVolumeSize,proto3" json:"limit_volume_size,omitempty"`
	// Backend Volume Defaults
	//
	// x-displayName: "Backend Volume Defaults"
	// List of QoS volume defaults types
	VolumeDefaults *OntapVolumeDefaults `protobuf:"bytes,21,opt,name=volume_defaults,json=volumeDefaults" json:"volume_defaults,omitempty"`
	// Backend Labels
	//
	// x-displayName: "Backend Labels"
	// x-example: "{"store":"nas_store"}"
	// List of labels for Storage Device used in NetApp ONTAP. It is used for storage class selection.
	Labels map[string]string `protobuf:"bytes,22,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Backend Region
	//
	// x-displayName: "Backend Region"
	// x-example: "us_east_1b"
	// Virtual Pool Region
	Region string `protobuf:"bytes,23,opt,name=region,proto3" json:"region,omitempty"`
	// Virtual Storage Pools
	//
	// x-displayName: "Virtual Storage Pools"
	// List of Virtual Storage Pool definitions which are referred back by Storage Class label match selection.
	Storage []*OntapVirtualStoragePoolType `protobuf:"bytes,24,rep,name=storage" json:"storage,omitempty"`
	// Client Certificate
	//
	// x-displayName: "Client Certificate"
	// Please Enter Base64-encoded value of client certificate. Used for certificate-based auth.
	ClientCertificate string `protobuf:"bytes,25,opt,name=client_certificate,json=clientCertificate,proto3" json:"client_certificate,omitempty"`
	// Client Private Key
	//
	// x-displayName: "Client Private Key"
	// Please Enter value of client private key. Used for certificate-based auth.
	ClientPrivateKey *ves_io_schema4.SecretType `protobuf:"bytes,26,opt,name=client_private_key,json=clientPrivateKey" json:"client_private_key,omitempty"`
	// Trusted CA Certificate
	//
	// x-displayName: "Trusted CA Certificate"
	// Please Enter Base64-encoded value of trusted CA certificate. Optional. Used for certificate-based auth..
	TrustedCaCertificate string `protobuf:"bytes,27,opt,name=trusted_ca_certificate,json=trustedCaCertificate,proto3" json:"trusted_ca_certificate,omitempty"`
}

func (m *StorageDeviceNetappBackendOntapSanType) Reset() {
	*m = StorageDeviceNetappBackendOntapSanType{}
}
func (*StorageDeviceNetappBackendOntapSanType) ProtoMessage() {}
func (*StorageDeviceNetappBackendOntapSanType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{16}
}

type isStorageDeviceNetappBackendOntapSanType_ManagementLif interface {
	isStorageDeviceNetappBackendOntapSanType_ManagementLif()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isStorageDeviceNetappBackendOntapSanType_DataLif interface {
	isStorageDeviceNetappBackendOntapSanType_DataLif()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isStorageDeviceNetappBackendOntapSanType_ChapChoice interface {
	isStorageDeviceNetappBackendOntapSanType_ChapChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type StorageDeviceNetappBackendOntapSanType_ManagementLifIp struct {
	ManagementLifIp string `protobuf:"bytes,4,opt,name=management_lif_ip,json=managementLifIp,proto3,oneof"`
}
type StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName struct {
	ManagementLifDnsName string `protobuf:"bytes,5,opt,name=management_lif_dns_name,json=managementLifDnsName,proto3,oneof"`
}
type StorageDeviceNetappBackendOntapSanType_DataLifIp struct {
	DataLifIp string `protobuf:"bytes,7,opt,name=data_lif_ip,json=dataLifIp,proto3,oneof"`
}
type StorageDeviceNetappBackendOntapSanType_DataLifDnsName struct {
	DataLifDnsName string `protobuf:"bytes,8,opt,name=data_lif_dns_name,json=dataLifDnsName,proto3,oneof"`
}
type StorageDeviceNetappBackendOntapSanType_NoChap struct {
	NoChap *ves_io_schema4.Empty `protobuf:"bytes,13,opt,name=no_chap,json=noChap,oneof"`
}
type StorageDeviceNetappBackendOntapSanType_UseChap struct {
	UseChap *DeviceNetappBackendOntapSanChapType `protobuf:"bytes,14,opt,name=use_chap,json=useChap,oneof"`
}

func (*StorageDeviceNetappBackendOntapSanType_ManagementLifIp) isStorageDeviceNetappBackendOntapSanType_ManagementLif() {
}
func (*StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName) isStorageDeviceNetappBackendOntapSanType_ManagementLif() {
}
func (*StorageDeviceNetappBackendOntapSanType_DataLifIp) isStorageDeviceNetappBackendOntapSanType_DataLif() {
}
func (*StorageDeviceNetappBackendOntapSanType_DataLifDnsName) isStorageDeviceNetappBackendOntapSanType_DataLif() {
}
func (*StorageDeviceNetappBackendOntapSanType_NoChap) isStorageDeviceNetappBackendOntapSanType_ChapChoice() {
}
func (*StorageDeviceNetappBackendOntapSanType_UseChap) isStorageDeviceNetappBackendOntapSanType_ChapChoice() {
}

func (m *StorageDeviceNetappBackendOntapSanType) GetManagementLif() isStorageDeviceNetappBackendOntapSanType_ManagementLif {
	if m != nil {
		return m.ManagementLif
	}
	return nil
}
func (m *StorageDeviceNetappBackendOntapSanType) GetDataLif() isStorageDeviceNetappBackendOntapSanType_DataLif {
	if m != nil {
		return m.DataLif
	}
	return nil
}
func (m *StorageDeviceNetappBackendOntapSanType) GetChapChoice() isStorageDeviceNetappBackendOntapSanType_ChapChoice {
	if m != nil {
		return m.ChapChoice
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapSanType) GetStorageDriverName() string {
	if m != nil {
		return m.StorageDriverName
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetManagementLifIp() string {
	if x, ok := m.GetManagementLif().(*StorageDeviceNetappBackendOntapSanType_ManagementLifIp); ok {
		return x.ManagementLifIp
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetManagementLifDnsName() string {
	if x, ok := m.GetManagementLif().(*StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName); ok {
		return x.ManagementLifDnsName
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetDataLifIp() string {
	if x, ok := m.GetDataLif().(*StorageDeviceNetappBackendOntapSanType_DataLifIp); ok {
		return x.DataLifIp
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetDataLifDnsName() string {
	if x, ok := m.GetDataLif().(*StorageDeviceNetappBackendOntapSanType_DataLifDnsName); ok {
		return x.DataLifDnsName
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetSvm() string {
	if m != nil {
		return m.Svm
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetPassword() *ves_io_schema4.SecretType {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapSanType) GetNoChap() *ves_io_schema4.Empty {
	if x, ok := m.GetChapChoice().(*StorageDeviceNetappBackendOntapSanType_NoChap); ok {
		return x.NoChap
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapSanType) GetUseChap() *DeviceNetappBackendOntapSanChapType {
	if x, ok := m.GetChapChoice().(*StorageDeviceNetappBackendOntapSanType_UseChap); ok {
		return x.UseChap
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapSanType) GetIgroupName() string {
	if m != nil {
		return m.IgroupName
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetStoragePrefix() string {
	if m != nil {
		return m.StoragePrefix
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetLimitAggregateUsage() uint32 {
	if m != nil {
		return m.LimitAggregateUsage
	}
	return 0
}

func (m *StorageDeviceNetappBackendOntapSanType) GetLimitVolumeSize() int32 {
	if m != nil {
		return m.LimitVolumeSize
	}
	return 0
}

func (m *StorageDeviceNetappBackendOntapSanType) GetVolumeDefaults() *OntapVolumeDefaults {
	if m != nil {
		return m.VolumeDefaults
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapSanType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapSanType) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetStorage() []*OntapVirtualStoragePoolType {
	if m != nil {
		return m.Storage
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapSanType) GetClientCertificate() string {
	if m != nil {
		return m.ClientCertificate
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapSanType) GetClientPrivateKey() *ves_io_schema4.SecretType {
	if m != nil {
		return m.ClientPrivateKey
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapSanType) GetTrustedCaCertificate() string {
	if m != nil {
		return m.TrustedCaCertificate
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StorageDeviceNetappBackendOntapSanType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StorageDeviceNetappBackendOntapSanType_OneofMarshaler, _StorageDeviceNetappBackendOntapSanType_OneofUnmarshaler, _StorageDeviceNetappBackendOntapSanType_OneofSizer, []interface{}{
		(*StorageDeviceNetappBackendOntapSanType_ManagementLifIp)(nil),
		(*StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName)(nil),
		(*StorageDeviceNetappBackendOntapSanType_DataLifIp)(nil),
		(*StorageDeviceNetappBackendOntapSanType_DataLifDnsName)(nil),
		(*StorageDeviceNetappBackendOntapSanType_NoChap)(nil),
		(*StorageDeviceNetappBackendOntapSanType_UseChap)(nil),
	}
}

func _StorageDeviceNetappBackendOntapSanType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StorageDeviceNetappBackendOntapSanType)
	// management_lif
	switch x := m.ManagementLif.(type) {
	case *StorageDeviceNetappBackendOntapSanType_ManagementLifIp:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ManagementLifIp)
	case *StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ManagementLifDnsName)
	case nil:
	default:
		return fmt.Errorf("StorageDeviceNetappBackendOntapSanType.ManagementLif has unexpected type %T", x)
	}
	// data_lif
	switch x := m.DataLif.(type) {
	case *StorageDeviceNetappBackendOntapSanType_DataLifIp:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.DataLifIp)
	case *StorageDeviceNetappBackendOntapSanType_DataLifDnsName:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.DataLifDnsName)
	case nil:
	default:
		return fmt.Errorf("StorageDeviceNetappBackendOntapSanType.DataLif has unexpected type %T", x)
	}
	// chap_choice
	switch x := m.ChapChoice.(type) {
	case *StorageDeviceNetappBackendOntapSanType_NoChap:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoChap); err != nil {
			return err
		}
	case *StorageDeviceNetappBackendOntapSanType_UseChap:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UseChap); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("StorageDeviceNetappBackendOntapSanType.ChapChoice has unexpected type %T", x)
	}
	return nil
}

func _StorageDeviceNetappBackendOntapSanType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StorageDeviceNetappBackendOntapSanType)
	switch tag {
	case 4: // management_lif.management_lif_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ManagementLif = &StorageDeviceNetappBackendOntapSanType_ManagementLifIp{x}
		return true, err
	case 5: // management_lif.management_lif_dns_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ManagementLif = &StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName{x}
		return true, err
	case 7: // data_lif.data_lif_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.DataLif = &StorageDeviceNetappBackendOntapSanType_DataLifIp{x}
		return true, err
	case 8: // data_lif.data_lif_dns_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.DataLif = &StorageDeviceNetappBackendOntapSanType_DataLifDnsName{x}
		return true, err
	case 13: // chap_choice.no_chap
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.ChapChoice = &StorageDeviceNetappBackendOntapSanType_NoChap{msg}
		return true, err
	case 14: // chap_choice.use_chap
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DeviceNetappBackendOntapSanChapType)
		err := b.DecodeMessage(msg)
		m.ChapChoice = &StorageDeviceNetappBackendOntapSanType_UseChap{msg}
		return true, err
	default:
		return false, nil
	}
}

func _StorageDeviceNetappBackendOntapSanType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StorageDeviceNetappBackendOntapSanType)
	// management_lif
	switch x := m.ManagementLif.(type) {
	case *StorageDeviceNetappBackendOntapSanType_ManagementLifIp:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ManagementLifIp)))
		n += len(x.ManagementLifIp)
	case *StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ManagementLifDnsName)))
		n += len(x.ManagementLifDnsName)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// data_lif
	switch x := m.DataLif.(type) {
	case *StorageDeviceNetappBackendOntapSanType_DataLifIp:
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.DataLifIp)))
		n += len(x.DataLifIp)
	case *StorageDeviceNetappBackendOntapSanType_DataLifDnsName:
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.DataLifDnsName)))
		n += len(x.DataLifDnsName)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// chap_choice
	switch x := m.ChapChoice.(type) {
	case *StorageDeviceNetappBackendOntapSanType_NoChap:
		s := proto.Size(x.NoChap)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StorageDeviceNetappBackendOntapSanType_UseChap:
		s := proto.Size(x.UseChap)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Device NetApp Backend ONTAP SAN CHAP configuration
//
// x-displayName: "Device NetApp Backend ONTAP SAN CHAP Configuration"
// Device NetApp Backend ONTAP SAN CHAP configuration options for enabled CHAP
type DeviceNetappBackendOntapSanChapType struct {
	// CHAP Username
	//
	// x-displayName: "CHAP Username"
	// Inbound username. Required if useCHAP=true
	ChapUsername string `protobuf:"bytes,1,opt,name=chap_username,json=chapUsername,proto3" json:"chap_username,omitempty"`
	// CHAP Target Username
	//
	// x-displayName: "CHAP Target Username"
	// Target username. Required if useCHAP=true
	ChapTargetUsername string `protobuf:"bytes,2,opt,name=chap_target_username,json=chapTargetUsername,proto3" json:"chap_target_username,omitempty"`
	// CHAP Intiator Secret
	//
	// x-displayName: "CHAP Intiator Secret"
	// CHAP initiator secret. Required if useCHAP=true
	ChapInitiatorSecret *ves_io_schema4.SecretType `protobuf:"bytes,3,opt,name=chap_initiator_secret,json=chapInitiatorSecret" json:"chap_initiator_secret,omitempty"`
	// CHAP Target Initiator Secret
	//
	// x-displayName: "CHAP Target Initiator Secret"
	// CHAP target initiator secret. Required if useCHAP=true
	ChapTargetInitiatorSecret *ves_io_schema4.SecretType `protobuf:"bytes,4,opt,name=chap_target_initiator_secret,json=chapTargetInitiatorSecret" json:"chap_target_initiator_secret,omitempty"`
}

func (m *DeviceNetappBackendOntapSanChapType) Reset()      { *m = DeviceNetappBackendOntapSanChapType{} }
func (*DeviceNetappBackendOntapSanChapType) ProtoMessage() {}
func (*DeviceNetappBackendOntapSanChapType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{17}
}

func (m *DeviceNetappBackendOntapSanChapType) GetChapUsername() string {
	if m != nil {
		return m.ChapUsername
	}
	return ""
}

func (m *DeviceNetappBackendOntapSanChapType) GetChapTargetUsername() string {
	if m != nil {
		return m.ChapTargetUsername
	}
	return ""
}

func (m *DeviceNetappBackendOntapSanChapType) GetChapInitiatorSecret() *ves_io_schema4.SecretType {
	if m != nil {
		return m.ChapInitiatorSecret
	}
	return nil
}

func (m *DeviceNetappBackendOntapSanChapType) GetChapTargetInitiatorSecret() *ves_io_schema4.SecretType {
	if m != nil {
		return m.ChapTargetInitiatorSecret
	}
	return nil
}

// Storage Backend NetApp ONTAP NAS
//
// x-displayName: "Storage Backend NetApp ONTAP NAS"
// Configuration of storage backend for NetApp ONTAP NAS
type StorageDeviceNetappBackendOntapNasType struct {
	// Storage Backend Driver
	//
	// x-displayName: "Storage Backend Driver"
	// x-required
	// x-example: "ontap-nas"
	// Configuration of Backend Name
	StorageDriverName string `protobuf:"bytes,1,opt,name=storage_driver_name,json=storageDriverName,proto3" json:"storage_driver_name,omitempty"`
	// Storage Backend Name
	//
	// x-displayName: "Storage Backend Name"
	// Configuration of Backend Name. Driver is name + "_" + dataLIF
	BackendName string `protobuf:"bytes,2,opt,name=backend_name,json=backendName,proto3" json:"backend_name,omitempty"`
	// Backend Management LIF
	//
	// x-displayName: "Backend Management LIF"
	// x-required
	// FQDN or IP address of a cluster or SVM management LIF
	//
	// Types that are valid to be assigned to ManagementLif:
	//	*StorageDeviceNetappBackendOntapNasType_ManagementLifIp
	//	*StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName
	ManagementLif isStorageDeviceNetappBackendOntapNasType_ManagementLif `protobuf_oneof:"management_lif"`
	// Backend Data LIF
	//
	// x-displayName: "Backend Data LIF"
	// x-example: "192.168.10.10"
	// FQDN or IP address of protocol LIF. Use square brackets for IPv6. Once set this cannot be updated. Derived by the SVM unless specified.
	//
	// Types that are valid to be assigned to DataLif:
	//	*StorageDeviceNetappBackendOntapNasType_DataLifIp
	//	*StorageDeviceNetappBackendOntapNasType_DataLifDnsName
	DataLif isStorageDeviceNetappBackendOntapNasType_DataLif `protobuf_oneof:"data_lif"`
	// Backend SVM
	//
	// x-displayName: "Backend SVM"
	// x-example: "trident_svm"
	// Storage virtual machine to use. Derived if an SVM managementLIF is specified
	Svm string `protobuf:"bytes,9,opt,name=svm,proto3" json:"svm,omitempty"`
	// Username
	//
	// x-displayName: "Username"
	// x-example: "cluster-admin"
	// x-required
	// Username to connect to the cluster/SVM
	Username string `protobuf:"bytes,10,opt,name=username,proto3" json:"username,omitempty"`
	// Password
	//
	// x-displayName: "Password"
	// Please Enter you password. Password to connect to the cluster/SVM
	Password *ves_io_schema4.SecretType `protobuf:"bytes,11,opt,name=password" json:"password,omitempty"`
	// Auto Export Policy
	//
	// x-displayName: "Auto Export Policy"
	// Enable automatic export policy creation and updating
	AutoExportPolicy bool `protobuf:"varint,12,opt,name=auto_export_policy,json=autoExportPolicy,proto3" json:"auto_export_policy,omitempty"`
	// Auto Export CIDRs
	//
	// x-displayName: "Auto Export CIDRs"
	// x-example: "0.0.0.0/0"
	// List of CIDRs to filter Kubernetes node IPs against when autoExportPolicy is enabled
	AutoExportCidrs *ves_io_schema_views.PrefixStringListType `protobuf:"bytes,13,opt,name=auto_export_cidrs,json=autoExportCidrs" json:"auto_export_cidrs,omitempty"`
	// Storage Prefix
	//
	// x-displayName: "Storage Prefix"
	// x-example: "trident"
	// Prefix used when provisioning new volumes in the SVM. Once set this cannot be updated
	StoragePrefix string `protobuf:"bytes,14,opt,name=storage_prefix,json=storagePrefix,proto3" json:"storage_prefix,omitempty"`
	// Limit Aggregate Usage
	//
	// x-displayName: "Limit Aggregate Usage"
	// x-example: "80%"
	// Fail provisioning if usage is above this percentage. Not enforced by default.
	LimitAggregateUsage string `protobuf:"bytes,15,opt,name=limit_aggregate_usage,json=limitAggregateUsage,proto3" json:"limit_aggregate_usage,omitempty"`
	// Limit Volume Size
	//
	// x-displayName: "Limit Volume Size"
	// x-example: "50Gi"
	// Fail provisioning if requested volume size is above this value. Not enforced by default.
	LimitVolumeSize string `protobuf:"bytes,16,opt,name=limit_volume_size,json=limitVolumeSize,proto3" json:"limit_volume_size,omitempty"`
	// NFS Mount Options
	//
	// x-displayName: "NFS Mount Options"
	// x-example: "nfsvers=4"
	// Comma-separated list of NFS mount options. Not enforced by default.
	NfsMountOptions string `protobuf:"bytes,17,opt,name=nfs_mount_options,json=nfsMountOptions,proto3" json:"nfs_mount_options,omitempty"`
	// Backend Volume Defaults
	//
	// x-displayName: "Backend Volume Defaults"
	// List of QoS volume defaults types
	VolumeDefaults *OntapVolumeDefaults `protobuf:"bytes,18,opt,name=volume_defaults,json=volumeDefaults" json:"volume_defaults,omitempty"`
	// Backend Labels
	//
	// x-displayName: "Backend Labels"
	// x-example: "{"store":"nas_store"}"
	// List of labels for Storage Device used in NetApp ONTAP. It is used for storage class selection.
	Labels map[string]string `protobuf:"bytes,19,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Backend Region
	//
	// x-displayName: "Backend Region"
	// x-example: "us_east_1b"
	// Virtual Pool Region
	Region string `protobuf:"bytes,20,opt,name=region,proto3" json:"region,omitempty"`
	// Virtual Storage Pools
	//
	// x-displayName: "Virtual Storage Pools"
	// List of Virtual Storage Pool definitions which are referred back by Storage Class label match selection.
	Storage []*OntapVirtualStoragePoolType `protobuf:"bytes,21,rep,name=storage" json:"storage,omitempty"`
	// Client Certificate
	//
	// x-displayName: "Client Certificate"
	// Please Enter Base64-encoded value of client certificate. Used for certificate-based auth.
	ClientCertificate string `protobuf:"bytes,22,opt,name=client_certificate,json=clientCertificate,proto3" json:"client_certificate,omitempty"`
	// Client Private Key
	//
	// x-displayName: "Client Private Key"
	// Please Enter value of client private key. Used for certificate-based auth.
	ClientPrivateKey *ves_io_schema4.SecretType `protobuf:"bytes,23,opt,name=client_private_key,json=clientPrivateKey" json:"client_private_key,omitempty"`
	// Trusted CA Certificate
	//
	// x-displayName: "Trusted CA Certificate"
	// Please Enter Base64-encoded value of trusted CA certificate. Optional. Used for certificate-based auth..
	TrustedCaCertificate string `protobuf:"bytes,24,opt,name=trusted_ca_certificate,json=trustedCaCertificate,proto3" json:"trusted_ca_certificate,omitempty"`
}

func (m *StorageDeviceNetappBackendOntapNasType) Reset() {
	*m = StorageDeviceNetappBackendOntapNasType{}
}
func (*StorageDeviceNetappBackendOntapNasType) ProtoMessage() {}
func (*StorageDeviceNetappBackendOntapNasType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{18}
}

type isStorageDeviceNetappBackendOntapNasType_ManagementLif interface {
	isStorageDeviceNetappBackendOntapNasType_ManagementLif()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isStorageDeviceNetappBackendOntapNasType_DataLif interface {
	isStorageDeviceNetappBackendOntapNasType_DataLif()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type StorageDeviceNetappBackendOntapNasType_ManagementLifIp struct {
	ManagementLifIp string `protobuf:"bytes,4,opt,name=management_lif_ip,json=managementLifIp,proto3,oneof"`
}
type StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName struct {
	ManagementLifDnsName string `protobuf:"bytes,5,opt,name=management_lif_dns_name,json=managementLifDnsName,proto3,oneof"`
}
type StorageDeviceNetappBackendOntapNasType_DataLifIp struct {
	DataLifIp string `protobuf:"bytes,7,opt,name=data_lif_ip,json=dataLifIp,proto3,oneof"`
}
type StorageDeviceNetappBackendOntapNasType_DataLifDnsName struct {
	DataLifDnsName string `protobuf:"bytes,8,opt,name=data_lif_dns_name,json=dataLifDnsName,proto3,oneof"`
}

func (*StorageDeviceNetappBackendOntapNasType_ManagementLifIp) isStorageDeviceNetappBackendOntapNasType_ManagementLif() {
}
func (*StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName) isStorageDeviceNetappBackendOntapNasType_ManagementLif() {
}
func (*StorageDeviceNetappBackendOntapNasType_DataLifIp) isStorageDeviceNetappBackendOntapNasType_DataLif() {
}
func (*StorageDeviceNetappBackendOntapNasType_DataLifDnsName) isStorageDeviceNetappBackendOntapNasType_DataLif() {
}

func (m *StorageDeviceNetappBackendOntapNasType) GetManagementLif() isStorageDeviceNetappBackendOntapNasType_ManagementLif {
	if m != nil {
		return m.ManagementLif
	}
	return nil
}
func (m *StorageDeviceNetappBackendOntapNasType) GetDataLif() isStorageDeviceNetappBackendOntapNasType_DataLif {
	if m != nil {
		return m.DataLif
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapNasType) GetStorageDriverName() string {
	if m != nil {
		return m.StorageDriverName
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetBackendName() string {
	if m != nil {
		return m.BackendName
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetManagementLifIp() string {
	if x, ok := m.GetManagementLif().(*StorageDeviceNetappBackendOntapNasType_ManagementLifIp); ok {
		return x.ManagementLifIp
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetManagementLifDnsName() string {
	if x, ok := m.GetManagementLif().(*StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName); ok {
		return x.ManagementLifDnsName
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetDataLifIp() string {
	if x, ok := m.GetDataLif().(*StorageDeviceNetappBackendOntapNasType_DataLifIp); ok {
		return x.DataLifIp
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetDataLifDnsName() string {
	if x, ok := m.GetDataLif().(*StorageDeviceNetappBackendOntapNasType_DataLifDnsName); ok {
		return x.DataLifDnsName
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetSvm() string {
	if m != nil {
		return m.Svm
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetPassword() *ves_io_schema4.SecretType {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapNasType) GetAutoExportPolicy() bool {
	if m != nil {
		return m.AutoExportPolicy
	}
	return false
}

func (m *StorageDeviceNetappBackendOntapNasType) GetAutoExportCidrs() *ves_io_schema_views.PrefixStringListType {
	if m != nil {
		return m.AutoExportCidrs
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapNasType) GetStoragePrefix() string {
	if m != nil {
		return m.StoragePrefix
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetLimitAggregateUsage() string {
	if m != nil {
		return m.LimitAggregateUsage
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetLimitVolumeSize() string {
	if m != nil {
		return m.LimitVolumeSize
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetNfsMountOptions() string {
	if m != nil {
		return m.NfsMountOptions
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetVolumeDefaults() *OntapVolumeDefaults {
	if m != nil {
		return m.VolumeDefaults
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapNasType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapNasType) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetStorage() []*OntapVirtualStoragePoolType {
	if m != nil {
		return m.Storage
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapNasType) GetClientCertificate() string {
	if m != nil {
		return m.ClientCertificate
	}
	return ""
}

func (m *StorageDeviceNetappBackendOntapNasType) GetClientPrivateKey() *ves_io_schema4.SecretType {
	if m != nil {
		return m.ClientPrivateKey
	}
	return nil
}

func (m *StorageDeviceNetappBackendOntapNasType) GetTrustedCaCertificate() string {
	if m != nil {
		return m.TrustedCaCertificate
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StorageDeviceNetappBackendOntapNasType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StorageDeviceNetappBackendOntapNasType_OneofMarshaler, _StorageDeviceNetappBackendOntapNasType_OneofUnmarshaler, _StorageDeviceNetappBackendOntapNasType_OneofSizer, []interface{}{
		(*StorageDeviceNetappBackendOntapNasType_ManagementLifIp)(nil),
		(*StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName)(nil),
		(*StorageDeviceNetappBackendOntapNasType_DataLifIp)(nil),
		(*StorageDeviceNetappBackendOntapNasType_DataLifDnsName)(nil),
	}
}

func _StorageDeviceNetappBackendOntapNasType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StorageDeviceNetappBackendOntapNasType)
	// management_lif
	switch x := m.ManagementLif.(type) {
	case *StorageDeviceNetappBackendOntapNasType_ManagementLifIp:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ManagementLifIp)
	case *StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ManagementLifDnsName)
	case nil:
	default:
		return fmt.Errorf("StorageDeviceNetappBackendOntapNasType.ManagementLif has unexpected type %T", x)
	}
	// data_lif
	switch x := m.DataLif.(type) {
	case *StorageDeviceNetappBackendOntapNasType_DataLifIp:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.DataLifIp)
	case *StorageDeviceNetappBackendOntapNasType_DataLifDnsName:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.DataLifDnsName)
	case nil:
	default:
		return fmt.Errorf("StorageDeviceNetappBackendOntapNasType.DataLif has unexpected type %T", x)
	}
	return nil
}

func _StorageDeviceNetappBackendOntapNasType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StorageDeviceNetappBackendOntapNasType)
	switch tag {
	case 4: // management_lif.management_lif_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ManagementLif = &StorageDeviceNetappBackendOntapNasType_ManagementLifIp{x}
		return true, err
	case 5: // management_lif.management_lif_dns_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ManagementLif = &StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName{x}
		return true, err
	case 7: // data_lif.data_lif_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.DataLif = &StorageDeviceNetappBackendOntapNasType_DataLifIp{x}
		return true, err
	case 8: // data_lif.data_lif_dns_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.DataLif = &StorageDeviceNetappBackendOntapNasType_DataLifDnsName{x}
		return true, err
	default:
		return false, nil
	}
}

func _StorageDeviceNetappBackendOntapNasType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StorageDeviceNetappBackendOntapNasType)
	// management_lif
	switch x := m.ManagementLif.(type) {
	case *StorageDeviceNetappBackendOntapNasType_ManagementLifIp:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ManagementLifIp)))
		n += len(x.ManagementLifIp)
	case *StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ManagementLifDnsName)))
		n += len(x.ManagementLifDnsName)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// data_lif
	switch x := m.DataLif.(type) {
	case *StorageDeviceNetappBackendOntapNasType_DataLifIp:
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.DataLifIp)))
		n += len(x.DataLifIp)
	case *StorageDeviceNetappBackendOntapNasType_DataLifDnsName:
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.DataLifDnsName)))
		n += len(x.DataLifDnsName)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Backend OnTap Volume Defaults
//
// x-displayName: "Backend OnTap Volume Defaults"
// It controls how each volume is provisioned by default using these options in a special section of the configuration.
type OntapVolumeDefaults struct {
	// Space Reservation Mode
	//
	// x-displayName: "Space Reservation Mode"
	// x-example: "thick"
	// Space reservation mode; none (thin) or volume (thick)
	SpaceReserve string `protobuf:"bytes,1,opt,name=space_reserve,json=spaceReserve,proto3" json:"space_reserve,omitempty"`
	// Snapshot Policy
	//
	// x-displayName: "Snapshot Policy"
	// x-example: "none"
	// Snapshot policy to use
	SnapshotPolicy string `protobuf:"bytes,2,opt,name=snapshot_policy,json=snapshotPolicy,proto3" json:"snapshot_policy,omitempty"`
	// Snapshot Rerserved
	//
	// x-displayName: "Snapshot Reserved"
	// x-example: "10"
	// Percentage of volume reserved for snapshots. "0" if snapshot policy is "none", else ""
	SnapshotReserve string `protobuf:"bytes,3,opt,name=snapshot_reserve,json=snapshotReserve,proto3" json:"snapshot_reserve,omitempty"`
	// Split on Clone
	//
	// x-displayName: "Split on Clone"
	// x-example: "false"
	// Split a clone from its parent upon creation.
	SplitOnClone bool `protobuf:"varint,4,opt,name=split_on_clone,json=splitOnClone,proto3" json:"split_on_clone,omitempty"`
	// Enable Encryption
	//
	// x-displayName: "Enable Encryption"
	// x-example: "false"
	// Enable NetApp volume encryption.
	Encryption bool `protobuf:"varint,5,opt,name=encryption,proto3" json:"encryption,omitempty"`
	// Unix Mode Permissions
	//
	// x-displayName: "Unix Mode Permissions"
	// x-example: "777"
	// Unix permission mode for new volumes. All allowed 777
	UnixPermissions int32 `protobuf:"varint,6,opt,name=unix_permissions,json=unixPermissions,proto3" json:"unix_permissions,omitempty"`
	// Access to Snapshot Directory
	//
	// x-displayName: "Access to Snapshot Directory"
	// Access to the .snapshot directory.
	SnapshotDir bool `protobuf:"varint,7,opt,name=snapshot_dir,json=snapshotDir,proto3" json:"snapshot_dir,omitempty"`
	// Export Policy
	//
	// x-displayName: "Export Policy"
	// x-example: "default"
	// Export policy to use.
	ExportPolicy string `protobuf:"bytes,8,opt,name=export_policy,json=exportPolicy,proto3" json:"export_policy,omitempty"`
	// Security Style
	//
	// x-displayName: "Security Style"
	// x-example: "unix"
	// Security style for new volumes.
	SecurityStyle string `protobuf:"bytes,9,opt,name=security_style,json=securityStyle,proto3" json:"security_style,omitempty"`
	// Tiering Policy
	//
	// x-displayName: "Tiering Policy"
	// x-example: "snapshot-only"
	// Tiering policy to use. "none" is default.
	TieringPolicy string `protobuf:"bytes,10,opt,name=tiering_policy,json=tieringPolicy,proto3" json:"tiering_policy,omitempty"`
	// QoS Policy
	//
	// x-displayName: "QoS Policy"
	// x-required
	// Choose one of QoS Policy or Adaptive QoS Policy per storage pool/backend.
	//
	// Types that are valid to be assigned to QosPolicyChoice:
	//	*OntapVolumeDefaults_NoQos
	//	*OntapVolumeDefaults_QosPolicy
	//	*OntapVolumeDefaults_AdaptiveQosPolicy
	QosPolicyChoice isOntapVolumeDefaults_QosPolicyChoice `protobuf_oneof:"qos_policy_choice"`
}

func (m *OntapVolumeDefaults) Reset()                    { *m = OntapVolumeDefaults{} }
func (*OntapVolumeDefaults) ProtoMessage()               {}
func (*OntapVolumeDefaults) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{19} }

type isOntapVolumeDefaults_QosPolicyChoice interface {
	isOntapVolumeDefaults_QosPolicyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type OntapVolumeDefaults_NoQos struct {
	NoQos *ves_io_schema4.Empty `protobuf:"bytes,12,opt,name=no_qos,json=noQos,oneof"`
}
type OntapVolumeDefaults_QosPolicy struct {
	QosPolicy string `protobuf:"bytes,13,opt,name=qos_policy,json=qosPolicy,proto3,oneof"`
}
type OntapVolumeDefaults_AdaptiveQosPolicy struct {
	AdaptiveQosPolicy string `protobuf:"bytes,14,opt,name=adaptive_qos_policy,json=adaptiveQosPolicy,proto3,oneof"`
}

func (*OntapVolumeDefaults_NoQos) isOntapVolumeDefaults_QosPolicyChoice()             {}
func (*OntapVolumeDefaults_QosPolicy) isOntapVolumeDefaults_QosPolicyChoice()         {}
func (*OntapVolumeDefaults_AdaptiveQosPolicy) isOntapVolumeDefaults_QosPolicyChoice() {}

func (m *OntapVolumeDefaults) GetQosPolicyChoice() isOntapVolumeDefaults_QosPolicyChoice {
	if m != nil {
		return m.QosPolicyChoice
	}
	return nil
}

func (m *OntapVolumeDefaults) GetSpaceReserve() string {
	if m != nil {
		return m.SpaceReserve
	}
	return ""
}

func (m *OntapVolumeDefaults) GetSnapshotPolicy() string {
	if m != nil {
		return m.SnapshotPolicy
	}
	return ""
}

func (m *OntapVolumeDefaults) GetSnapshotReserve() string {
	if m != nil {
		return m.SnapshotReserve
	}
	return ""
}

func (m *OntapVolumeDefaults) GetSplitOnClone() bool {
	if m != nil {
		return m.SplitOnClone
	}
	return false
}

func (m *OntapVolumeDefaults) GetEncryption() bool {
	if m != nil {
		return m.Encryption
	}
	return false
}

func (m *OntapVolumeDefaults) GetUnixPermissions() int32 {
	if m != nil {
		return m.UnixPermissions
	}
	return 0
}

func (m *OntapVolumeDefaults) GetSnapshotDir() bool {
	if m != nil {
		return m.SnapshotDir
	}
	return false
}

func (m *OntapVolumeDefaults) GetExportPolicy() string {
	if m != nil {
		return m.ExportPolicy
	}
	return ""
}

func (m *OntapVolumeDefaults) GetSecurityStyle() string {
	if m != nil {
		return m.SecurityStyle
	}
	return ""
}

func (m *OntapVolumeDefaults) GetTieringPolicy() string {
	if m != nil {
		return m.TieringPolicy
	}
	return ""
}

func (m *OntapVolumeDefaults) GetNoQos() *ves_io_schema4.Empty {
	if x, ok := m.GetQosPolicyChoice().(*OntapVolumeDefaults_NoQos); ok {
		return x.NoQos
	}
	return nil
}

func (m *OntapVolumeDefaults) GetQosPolicy() string {
	if x, ok := m.GetQosPolicyChoice().(*OntapVolumeDefaults_QosPolicy); ok {
		return x.QosPolicy
	}
	return ""
}

func (m *OntapVolumeDefaults) GetAdaptiveQosPolicy() string {
	if x, ok := m.GetQosPolicyChoice().(*OntapVolumeDefaults_AdaptiveQosPolicy); ok {
		return x.AdaptiveQosPolicy
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*OntapVolumeDefaults) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _OntapVolumeDefaults_OneofMarshaler, _OntapVolumeDefaults_OneofUnmarshaler, _OntapVolumeDefaults_OneofSizer, []interface{}{
		(*OntapVolumeDefaults_NoQos)(nil),
		(*OntapVolumeDefaults_QosPolicy)(nil),
		(*OntapVolumeDefaults_AdaptiveQosPolicy)(nil),
	}
}

func _OntapVolumeDefaults_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*OntapVolumeDefaults)
	// qos_policy_choice
	switch x := m.QosPolicyChoice.(type) {
	case *OntapVolumeDefaults_NoQos:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoQos); err != nil {
			return err
		}
	case *OntapVolumeDefaults_QosPolicy:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.QosPolicy)
	case *OntapVolumeDefaults_AdaptiveQosPolicy:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.AdaptiveQosPolicy)
	case nil:
	default:
		return fmt.Errorf("OntapVolumeDefaults.QosPolicyChoice has unexpected type %T", x)
	}
	return nil
}

func _OntapVolumeDefaults_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*OntapVolumeDefaults)
	switch tag {
	case 12: // qos_policy_choice.no_qos
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.QosPolicyChoice = &OntapVolumeDefaults_NoQos{msg}
		return true, err
	case 13: // qos_policy_choice.qos_policy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.QosPolicyChoice = &OntapVolumeDefaults_QosPolicy{x}
		return true, err
	case 14: // qos_policy_choice.adaptive_qos_policy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.QosPolicyChoice = &OntapVolumeDefaults_AdaptiveQosPolicy{x}
		return true, err
	default:
		return false, nil
	}
}

func _OntapVolumeDefaults_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*OntapVolumeDefaults)
	// qos_policy_choice
	switch x := m.QosPolicyChoice.(type) {
	case *OntapVolumeDefaults_NoQos:
		s := proto.Size(x.NoQos)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *OntapVolumeDefaults_QosPolicy:
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.QosPolicy)))
		n += len(x.QosPolicy)
	case *OntapVolumeDefaults_AdaptiveQosPolicy:
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.AdaptiveQosPolicy)))
		n += len(x.AdaptiveQosPolicy)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Backend ONTAP Virtual Storage Pool
//
// x-displayName: "Backend ONTAP Virtual Storage Pool"
// ONTAP Virtual Storage Pool definition
type OntapVirtualStoragePoolType struct {
	// Storage Pool Labels
	//
	// x-displayName: "Storage Pool Labels"
	// x-example: "{"department":"finance", "creditpoints":"6000"}"
	// List of labels for Storage Device used in NetApp ONTAP. It is used for storage class label match selection.
	Labels map[string]string `protobuf:"bytes,1,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Pool Zone
	//
	// x-displayName: "Virtual Pool Zone"
	// x-example: "us_east_1b"
	// Virtual Storage Pool zone definition.
	Zone string `protobuf:"bytes,2,opt,name=zone,proto3" json:"zone,omitempty"`
	// Backend Volume Defaults
	//
	// x-displayName: "Backend Volume Defaults"
	// List of QoS volume default types
	VolumeDefaults *OntapVolumeDefaults `protobuf:"bytes,3,opt,name=volume_defaults,json=volumeDefaults" json:"volume_defaults,omitempty"`
}

func (m *OntapVirtualStoragePoolType) Reset()      { *m = OntapVirtualStoragePoolType{} }
func (*OntapVirtualStoragePoolType) ProtoMessage() {}
func (*OntapVirtualStoragePoolType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{20}
}

func (m *OntapVirtualStoragePoolType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *OntapVirtualStoragePoolType) GetZone() string {
	if m != nil {
		return m.Zone
	}
	return ""
}

func (m *OntapVirtualStoragePoolType) GetVolumeDefaults() *OntapVolumeDefaults {
	if m != nil {
		return m.VolumeDefaults
	}
	return nil
}

// Storage Device
//
// x-displayName: "Storage Device"
// Configuration of storage device
type FleetStorageDeviceType struct {
	// Storage Device
	//
	// x-displayName: "Storage Device"
	// x-required
	// x-example "DellEMC-isilon-F800-0"
	// Storage device and device unit
	StorageDevice string `protobuf:"bytes,1,opt,name=storage_device,json=storageDevice,proto3" json:"storage_device,omitempty"`
	// Select Storage Device Configuration
	//
	// x-displayName: "Select Storage Device to Configure"
	// x-required
	// Select type of storage device driver to configure
	//
	// Types that are valid to be assigned to DeviceChoice:
	//	*FleetStorageDeviceType_NetappTrident
	//	*FleetStorageDeviceType_PureServiceOrchestrator
	//	*FleetStorageDeviceType_OpenebsEnterprise
	DeviceChoice isFleetStorageDeviceType_DeviceChoice `protobuf_oneof:"device_choice"`
	// Advanced Parameters
	//
	// x-displayName: "Advanced Parameters"
	// Map of parameter name and string value
	AdvancedAdvancedParameters map[string]string `protobuf:"bytes,5,rep,name=advanced_advanced_parameters,json=advancedAdvancedParameters" json:"advanced_advanced_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FleetStorageDeviceType) Reset()                    { *m = FleetStorageDeviceType{} }
func (*FleetStorageDeviceType) ProtoMessage()               {}
func (*FleetStorageDeviceType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{21} }

type isFleetStorageDeviceType_DeviceChoice interface {
	isFleetStorageDeviceType_DeviceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type FleetStorageDeviceType_NetappTrident struct {
	NetappTrident *StorageDeviceNetappTridentType `protobuf:"bytes,6,opt,name=netapp_trident,json=netappTrident,oneof"`
}
type FleetStorageDeviceType_PureServiceOrchestrator struct {
	PureServiceOrchestrator *StorageDevicePureStorageServiceOrchestratorType `protobuf:"bytes,7,opt,name=pure_service_orchestrator,json=pureServiceOrchestrator,oneof"`
}
type FleetStorageDeviceType_OpenebsEnterprise struct {
	OpenebsEnterprise *StorageDeviceOpenebsEnterpriseType `protobuf:"bytes,8,opt,name=openebs_enterprise,json=openebsEnterprise,oneof"`
}

func (*FleetStorageDeviceType_NetappTrident) isFleetStorageDeviceType_DeviceChoice()           {}
func (*FleetStorageDeviceType_PureServiceOrchestrator) isFleetStorageDeviceType_DeviceChoice() {}
func (*FleetStorageDeviceType_OpenebsEnterprise) isFleetStorageDeviceType_DeviceChoice()       {}

func (m *FleetStorageDeviceType) GetDeviceChoice() isFleetStorageDeviceType_DeviceChoice {
	if m != nil {
		return m.DeviceChoice
	}
	return nil
}

func (m *FleetStorageDeviceType) GetStorageDevice() string {
	if m != nil {
		return m.StorageDevice
	}
	return ""
}

func (m *FleetStorageDeviceType) GetNetappTrident() *StorageDeviceNetappTridentType {
	if x, ok := m.GetDeviceChoice().(*FleetStorageDeviceType_NetappTrident); ok {
		return x.NetappTrident
	}
	return nil
}

func (m *FleetStorageDeviceType) GetPureServiceOrchestrator() *StorageDevicePureStorageServiceOrchestratorType {
	if x, ok := m.GetDeviceChoice().(*FleetStorageDeviceType_PureServiceOrchestrator); ok {
		return x.PureServiceOrchestrator
	}
	return nil
}

func (m *FleetStorageDeviceType) GetOpenebsEnterprise() *StorageDeviceOpenebsEnterpriseType {
	if x, ok := m.GetDeviceChoice().(*FleetStorageDeviceType_OpenebsEnterprise); ok {
		return x.OpenebsEnterprise
	}
	return nil
}

func (m *FleetStorageDeviceType) GetAdvancedAdvancedParameters() map[string]string {
	if m != nil {
		return m.AdvancedAdvancedParameters
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FleetStorageDeviceType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FleetStorageDeviceType_OneofMarshaler, _FleetStorageDeviceType_OneofUnmarshaler, _FleetStorageDeviceType_OneofSizer, []interface{}{
		(*FleetStorageDeviceType_NetappTrident)(nil),
		(*FleetStorageDeviceType_PureServiceOrchestrator)(nil),
		(*FleetStorageDeviceType_OpenebsEnterprise)(nil),
	}
}

func _FleetStorageDeviceType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FleetStorageDeviceType)
	// device_choice
	switch x := m.DeviceChoice.(type) {
	case *FleetStorageDeviceType_NetappTrident:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NetappTrident); err != nil {
			return err
		}
	case *FleetStorageDeviceType_PureServiceOrchestrator:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PureServiceOrchestrator); err != nil {
			return err
		}
	case *FleetStorageDeviceType_OpenebsEnterprise:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OpenebsEnterprise); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FleetStorageDeviceType.DeviceChoice has unexpected type %T", x)
	}
	return nil
}

func _FleetStorageDeviceType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FleetStorageDeviceType)
	switch tag {
	case 6: // device_choice.netapp_trident
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StorageDeviceNetappTridentType)
		err := b.DecodeMessage(msg)
		m.DeviceChoice = &FleetStorageDeviceType_NetappTrident{msg}
		return true, err
	case 7: // device_choice.pure_service_orchestrator
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StorageDevicePureStorageServiceOrchestratorType)
		err := b.DecodeMessage(msg)
		m.DeviceChoice = &FleetStorageDeviceType_PureServiceOrchestrator{msg}
		return true, err
	case 8: // device_choice.openebs_enterprise
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StorageDeviceOpenebsEnterpriseType)
		err := b.DecodeMessage(msg)
		m.DeviceChoice = &FleetStorageDeviceType_OpenebsEnterprise{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FleetStorageDeviceType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FleetStorageDeviceType)
	// device_choice
	switch x := m.DeviceChoice.(type) {
	case *FleetStorageDeviceType_NetappTrident:
		s := proto.Size(x.NetappTrident)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FleetStorageDeviceType_PureServiceOrchestrator:
		s := proto.Size(x.PureServiceOrchestrator)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FleetStorageDeviceType_OpenebsEnterprise:
		s := proto.Size(x.OpenebsEnterprise)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Custom Storage Device List
//
// x-displayName: "Custom Storage Device List"
// Add additional custom storage classes in kubernetes for this fleet
type FleetStorageDeviceListType struct {
	// List of Storage Devices
	//
	// x-displayName: "List of Storage Devices"
	// List of custom storage devices
	StorageDevices []*FleetStorageDeviceType `protobuf:"bytes,1,rep,name=storage_devices,json=storageDevices" json:"storage_devices,omitempty"`
}

func (m *FleetStorageDeviceListType) Reset()      { *m = FleetStorageDeviceListType{} }
func (*FleetStorageDeviceListType) ProtoMessage() {}
func (*FleetStorageDeviceListType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{22}
}

func (m *FleetStorageDeviceListType) GetStorageDevices() []*FleetStorageDeviceType {
	if m != nil {
		return m.StorageDevices
	}
	return nil
}

// Dell EMC isilon F800
//
// x-displayName: "Dell EMC isilon F800"
// Storage class configuration for Dell EMC isilon F800
type StorageClassDellIsilonF800Type struct {
	//  Select Az Service address
	//
	// x-displayName: "Select Az Service address"
	// x-required
	// Select how to reach Az Service.
	//
	// Types that are valid to be assigned to HttpsChoice:
	//	*StorageClassDellIsilonF800Type_AzServiceName
	//	*StorageClassDellIsilonF800Type_AzServiceIpAddress
	HttpsChoice isStorageClassDellIsilonF800Type_HttpsChoice `protobuf_oneof:"https_choice"`
	// iSCSI Access Zone
	//
	// x-displayName: "iSCSI Access Zone"
	// x-example: "System"
	// The name of the access zone, a volume can be created in
	IscsiAccessZone string `protobuf:"bytes,4,opt,name=iscsi_access_zone,json=iscsiAccessZone,proto3" json:"iscsi_access_zone,omitempty"`
	// Base Path
	//
	// x-displayName: "Base Path
	// x-example: "/ifs/data/csi"
	// Base path for the volume to be created, Ensure that this path exists on Isilon.
	BasePath string `protobuf:"bytes,5,opt,name=base_path,json=basePath,proto3" json:"base_path,omitempty"`
	// title
	//
	// x-displayName: "Enable Root Client"
	// Determines, when a node mounts the PVC, in NodeStageVolume, whether to add the K8s node to
	// the "Root clients" field (when true) or "Clients" field (when false) of the NFS export
	RootClientEnable bool `protobuf:"varint,6,opt,name=root_client_enable,json=rootClientEnable,proto3" json:"root_client_enable,omitempty"`
}

func (m *StorageClassDellIsilonF800Type) Reset()      { *m = StorageClassDellIsilonF800Type{} }
func (*StorageClassDellIsilonF800Type) ProtoMessage() {}
func (*StorageClassDellIsilonF800Type) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{23}
}

type isStorageClassDellIsilonF800Type_HttpsChoice interface {
	isStorageClassDellIsilonF800Type_HttpsChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type StorageClassDellIsilonF800Type_AzServiceName struct {
	AzServiceName string `protobuf:"bytes,2,opt,name=az_service_name,json=azServiceName,proto3,oneof"`
}
type StorageClassDellIsilonF800Type_AzServiceIpAddress struct {
	AzServiceIpAddress string `protobuf:"bytes,3,opt,name=az_service_ip_address,json=azServiceIpAddress,proto3,oneof"`
}

func (*StorageClassDellIsilonF800Type_AzServiceName) isStorageClassDellIsilonF800Type_HttpsChoice() {}
func (*StorageClassDellIsilonF800Type_AzServiceIpAddress) isStorageClassDellIsilonF800Type_HttpsChoice() {
}

func (m *StorageClassDellIsilonF800Type) GetHttpsChoice() isStorageClassDellIsilonF800Type_HttpsChoice {
	if m != nil {
		return m.HttpsChoice
	}
	return nil
}

func (m *StorageClassDellIsilonF800Type) GetAzServiceName() string {
	if x, ok := m.GetHttpsChoice().(*StorageClassDellIsilonF800Type_AzServiceName); ok {
		return x.AzServiceName
	}
	return ""
}

func (m *StorageClassDellIsilonF800Type) GetAzServiceIpAddress() string {
	if x, ok := m.GetHttpsChoice().(*StorageClassDellIsilonF800Type_AzServiceIpAddress); ok {
		return x.AzServiceIpAddress
	}
	return ""
}

func (m *StorageClassDellIsilonF800Type) GetIscsiAccessZone() string {
	if m != nil {
		return m.IscsiAccessZone
	}
	return ""
}

func (m *StorageClassDellIsilonF800Type) GetBasePath() string {
	if m != nil {
		return m.BasePath
	}
	return ""
}

func (m *StorageClassDellIsilonF800Type) GetRootClientEnable() bool {
	if m != nil {
		return m.RootClientEnable
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StorageClassDellIsilonF800Type) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StorageClassDellIsilonF800Type_OneofMarshaler, _StorageClassDellIsilonF800Type_OneofUnmarshaler, _StorageClassDellIsilonF800Type_OneofSizer, []interface{}{
		(*StorageClassDellIsilonF800Type_AzServiceName)(nil),
		(*StorageClassDellIsilonF800Type_AzServiceIpAddress)(nil),
	}
}

func _StorageClassDellIsilonF800Type_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StorageClassDellIsilonF800Type)
	// https_choice
	switch x := m.HttpsChoice.(type) {
	case *StorageClassDellIsilonF800Type_AzServiceName:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.AzServiceName)
	case *StorageClassDellIsilonF800Type_AzServiceIpAddress:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.AzServiceIpAddress)
	case nil:
	default:
		return fmt.Errorf("StorageClassDellIsilonF800Type.HttpsChoice has unexpected type %T", x)
	}
	return nil
}

func _StorageClassDellIsilonF800Type_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StorageClassDellIsilonF800Type)
	switch tag {
	case 2: // https_choice.az_service_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.HttpsChoice = &StorageClassDellIsilonF800Type_AzServiceName{x}
		return true, err
	case 3: // https_choice.az_service_ip_address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.HttpsChoice = &StorageClassDellIsilonF800Type_AzServiceIpAddress{x}
		return true, err
	default:
		return false, nil
	}
}

func _StorageClassDellIsilonF800Type_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StorageClassDellIsilonF800Type)
	// https_choice
	switch x := m.HttpsChoice.(type) {
	case *StorageClassDellIsilonF800Type_AzServiceName:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.AzServiceName)))
		n += len(x.AzServiceName)
	case *StorageClassDellIsilonF800Type_AzServiceIpAddress:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.AzServiceIpAddress)))
		n += len(x.AzServiceIpAddress)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// HPE Nimbus Storage AF40
//
// x-displayName: "HPE Nimbus Storage AF40"
// Storage class Device configuration for HPE Nimbus Storage AF40
type StorageClassHPENimbusStorageAf40Type struct {
	// Performance Policy
	//
	// x-displayName: "Performance Policy"
	// x-example: "Other"
	// Performance Policy for this storage Class
	PerfPolicy string `protobuf:"bytes,1,opt,name=perf_policy,json=perfPolicy,proto3" json:"perf_policy,omitempty"`
	// IOP Limit
	//
	// x-displayName: "IOP Limit"
	// x-example: "76800"
	// I/O operations per second limit for this storage class
	LimitIops uint32 `protobuf:"varint,2,opt,name=limit_iops,json=limitIops,proto3" json:"limit_iops,omitempty"`
	// MBPS Limit
	//
	// x-displayName: "MBPS Limit"
	// x-example: "10000"
	// Mega Byte per second data thruput limit.
	LimitMbps uint32 `protobuf:"varint,3,opt,name=limit_mbps,json=limitMbps,proto3" json:"limit_mbps,omitempty"`
}

func (m *StorageClassHPENimbusStorageAf40Type) Reset()      { *m = StorageClassHPENimbusStorageAf40Type{} }
func (*StorageClassHPENimbusStorageAf40Type) ProtoMessage() {}
func (*StorageClassHPENimbusStorageAf40Type) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{24}
}

func (m *StorageClassHPENimbusStorageAf40Type) GetPerfPolicy() string {
	if m != nil {
		return m.PerfPolicy
	}
	return ""
}

func (m *StorageClassHPENimbusStorageAf40Type) GetLimitIops() uint32 {
	if m != nil {
		return m.LimitIops
	}
	return 0
}

func (m *StorageClassHPENimbusStorageAf40Type) GetLimitMbps() uint32 {
	if m != nil {
		return m.LimitMbps
	}
	return 0
}

// OpenEBS Enterprise
//
// x-displayName: "OpenEBS Enterprise"
// Storage class Device configuration for OpenEBS Enterprise
type StorageClassOpenebsEnterpriseType struct {
	// Protocol
	//
	// x-displayName: "Protocol"
	// x-example: "nvmf"
	// Defines type of transport protocol used to mount the PV to the worker node hosting the associated application pod (NVMe-oF)
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Replication
	//
	// x-displayName: "Replication"
	// x-example: "1"
	// Replication sets the replication factor of the PV, i.e. the number of data replicas to be maintained for it such as 1 or 3.
	Replication int32 `protobuf:"varint,2,opt,name=replication,proto3" json:"replication,omitempty"`
}

func (m *StorageClassOpenebsEnterpriseType) Reset()      { *m = StorageClassOpenebsEnterpriseType{} }
func (*StorageClassOpenebsEnterpriseType) ProtoMessage() {}
func (*StorageClassOpenebsEnterpriseType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{25}
}

func (m *StorageClassOpenebsEnterpriseType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *StorageClassOpenebsEnterpriseType) GetReplication() int32 {
	if m != nil {
		return m.Replication
	}
	return 0
}

// NetApp Trident Storage
//
// x-displayName: "NetApp Trident Storage"
// Storage class Device configuration for NetApp Trident
type StorageClassNetappTridentType struct {
	// Selector
	//
	// x-displayName: "Selector"
	// x-example: "protection=silver; creditpoints=20000"
	// Using the Selector field, each StorageClass calls out which virtual pool(s) may be used to host a volume.
	// The volume will have the aspects defined in the chosen virtual pool.
	Selector map[string]string `protobuf:"bytes,1,rep,name=selector" json:"selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Storage Pools
	//
	// x-displayName: "Storage Pools"
	// x-example: "backend-name1:.*;backend-name2:storagePoolListName"
	// The storagePools parameter is used to further restrict the set of pools that match any specified attributes
	StoragePools string `protobuf:"bytes,2,opt,name=storage_pools,json=storagePools,proto3" json:"storage_pools,omitempty"`
}

func (m *StorageClassNetappTridentType) Reset()      { *m = StorageClassNetappTridentType{} }
func (*StorageClassNetappTridentType) ProtoMessage() {}
func (*StorageClassNetappTridentType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{26}
}

func (m *StorageClassNetappTridentType) GetSelector() map[string]string {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *StorageClassNetappTridentType) GetStoragePools() string {
	if m != nil {
		return m.StoragePools
	}
	return ""
}

// Pure Storage Service Orchestrator
//
// x-displayName: "Pure Storage Service Orchestrator"
// Storage class Device configuration for Pure Service Orchestrator
type StorageClassPureServiceOrchestratorType struct {
	// Backend
	//
	// x-displayName: "Backend"
	// x-example: "block"
	// Defines type of Pure storage backend block or file.
	// The volume will have the aspects defined in the chosen virtual pool.
	Backend string `protobuf:"bytes,1,opt,name=backend,proto3" json:"backend,omitempty"`
	// IOPS Limit
	//
	// x-displayName: "IOPS Limit"
	// x-example: "3000"
	// Enable IOPS limitation. It must be between 100 and 100 million. If value is 0, IOPS limit is not defined.
	IopsLimit uint32 `protobuf:"varint,2,opt,name=iops_limit,json=iopsLimit,proto3" json:"iops_limit,omitempty"`
	// Bandwidth Limit
	//
	// x-displayName: "Bandwidth Limit"
	// x-example: "1G"
	// It must be between 1 MB/s and 512 GB/s. Enter the size as a number (bytes must be multiple of 512) or number with a single character unit symbol.
	// Valid unit symbols are K, M, G, representing KiB, MiB, and GiB.
	BandwidthLimit string `protobuf:"bytes,3,opt,name=bandwidth_limit,json=bandwidthLimit,proto3" json:"bandwidth_limit,omitempty"`
}

func (m *StorageClassPureServiceOrchestratorType) Reset() {
	*m = StorageClassPureServiceOrchestratorType{}
}
func (*StorageClassPureServiceOrchestratorType) ProtoMessage() {}
func (*StorageClassPureServiceOrchestratorType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{27}
}

func (m *StorageClassPureServiceOrchestratorType) GetBackend() string {
	if m != nil {
		return m.Backend
	}
	return ""
}

func (m *StorageClassPureServiceOrchestratorType) GetIopsLimit() uint32 {
	if m != nil {
		return m.IopsLimit
	}
	return 0
}

func (m *StorageClassPureServiceOrchestratorType) GetBandwidthLimit() string {
	if m != nil {
		return m.BandwidthLimit
	}
	return ""
}

// Custom Storage Class
//
// x-displayName: "Custom Storage Class"
// Configuration of custom storage class
type FleetStorageClassType struct {
	// Storage Device
	//
	// x-displayName: "Storage Device"
	// x-example "DellEMC-isilon_F800-0"
	// x-required
	// Storage device that this class will use. The Device name defined at previous step.
	StorageDevice string `protobuf:"bytes,1,opt,name=storage_device,json=storageDevice,proto3" json:"storage_device,omitempty"`
	// Storage Class Description
	//
	// x-displayName: "Storage Class Description"
	// x-example "Volume from my fast storage"
	// Description for this storage class
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Default Storage Class
	//
	// x-displayName: "Default Storage Class"
	// Make this storage class default storage class for the K8s cluster
	DefaultStorageClass bool `protobuf:"varint,3,opt,name=default_storage_class,json=defaultStorageClass,proto3" json:"default_storage_class,omitempty"`
	// Select Storage Class Configuration
	//
	// x-displayName: "Select Storage Class Configuration"
	// x-required
	// Select storage Class configuration
	//
	// Types that are valid to be assigned to DeviceChoice:
	//	*FleetStorageClassType_NetappTrident
	//	*FleetStorageClassType_PureServiceOrchestrator
	//	*FleetStorageClassType_OpenebsEnterprise
	DeviceChoice isFleetStorageClassType_DeviceChoice `protobuf_oneof:"device_choice"`
	// Reclaim Policy
	//
	// x-displayName: "Reclaim Policy"
	// x-example: "Delete"
	// Reclaim Policy
	ReclaimPolicy string `protobuf:"bytes,12,opt,name=reclaim_policy,json=reclaimPolicy,proto3" json:"reclaim_policy,omitempty"`
	// Allow Volume Expansion
	//
	// x-displayName: "Allow Volume Expansion"
	// Allow volume expansion.
	AllowVolumeExpansion bool `protobuf:"varint,13,opt,name=allow_volume_expansion,json=allowVolumeExpansion,proto3" json:"allow_volume_expansion,omitempty"`
	// Advanced Parameters
	//
	// x-displayName: "Advanced Parameters"
	// Map of parameter name and string value
	AdvancedStorageParameters map[string]string `protobuf:"bytes,7,rep,name=advanced_storage_parameters,json=advancedStorageParameters" json:"advanced_storage_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Storage Class Name
	//
	// x-displayName: "Storage Class Name"
	// x-example: "premium"
	// x-required
	// Name of the storage class as it will appear in K8s.
	StorageClassName string `protobuf:"bytes,8,opt,name=storage_class_name,json=storageClassName,proto3" json:"storage_class_name,omitempty"`
}

func (m *FleetStorageClassType) Reset()                    { *m = FleetStorageClassType{} }
func (*FleetStorageClassType) ProtoMessage()               {}
func (*FleetStorageClassType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{28} }

type isFleetStorageClassType_DeviceChoice interface {
	isFleetStorageClassType_DeviceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type FleetStorageClassType_NetappTrident struct {
	NetappTrident *StorageClassNetappTridentType `protobuf:"bytes,9,opt,name=netapp_trident,json=netappTrident,oneof"`
}
type FleetStorageClassType_PureServiceOrchestrator struct {
	PureServiceOrchestrator *StorageClassPureServiceOrchestratorType `protobuf:"bytes,10,opt,name=pure_service_orchestrator,json=pureServiceOrchestrator,oneof"`
}
type FleetStorageClassType_OpenebsEnterprise struct {
	OpenebsEnterprise *StorageClassOpenebsEnterpriseType `protobuf:"bytes,11,opt,name=openebs_enterprise,json=openebsEnterprise,oneof"`
}

func (*FleetStorageClassType_NetappTrident) isFleetStorageClassType_DeviceChoice()           {}
func (*FleetStorageClassType_PureServiceOrchestrator) isFleetStorageClassType_DeviceChoice() {}
func (*FleetStorageClassType_OpenebsEnterprise) isFleetStorageClassType_DeviceChoice()       {}

func (m *FleetStorageClassType) GetDeviceChoice() isFleetStorageClassType_DeviceChoice {
	if m != nil {
		return m.DeviceChoice
	}
	return nil
}

func (m *FleetStorageClassType) GetStorageDevice() string {
	if m != nil {
		return m.StorageDevice
	}
	return ""
}

func (m *FleetStorageClassType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *FleetStorageClassType) GetDefaultStorageClass() bool {
	if m != nil {
		return m.DefaultStorageClass
	}
	return false
}

func (m *FleetStorageClassType) GetNetappTrident() *StorageClassNetappTridentType {
	if x, ok := m.GetDeviceChoice().(*FleetStorageClassType_NetappTrident); ok {
		return x.NetappTrident
	}
	return nil
}

func (m *FleetStorageClassType) GetPureServiceOrchestrator() *StorageClassPureServiceOrchestratorType {
	if x, ok := m.GetDeviceChoice().(*FleetStorageClassType_PureServiceOrchestrator); ok {
		return x.PureServiceOrchestrator
	}
	return nil
}

func (m *FleetStorageClassType) GetOpenebsEnterprise() *StorageClassOpenebsEnterpriseType {
	if x, ok := m.GetDeviceChoice().(*FleetStorageClassType_OpenebsEnterprise); ok {
		return x.OpenebsEnterprise
	}
	return nil
}

func (m *FleetStorageClassType) GetReclaimPolicy() string {
	if m != nil {
		return m.ReclaimPolicy
	}
	return ""
}

func (m *FleetStorageClassType) GetAllowVolumeExpansion() bool {
	if m != nil {
		return m.AllowVolumeExpansion
	}
	return false
}

func (m *FleetStorageClassType) GetAdvancedStorageParameters() map[string]string {
	if m != nil {
		return m.AdvancedStorageParameters
	}
	return nil
}

func (m *FleetStorageClassType) GetStorageClassName() string {
	if m != nil {
		return m.StorageClassName
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FleetStorageClassType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FleetStorageClassType_OneofMarshaler, _FleetStorageClassType_OneofUnmarshaler, _FleetStorageClassType_OneofSizer, []interface{}{
		(*FleetStorageClassType_NetappTrident)(nil),
		(*FleetStorageClassType_PureServiceOrchestrator)(nil),
		(*FleetStorageClassType_OpenebsEnterprise)(nil),
	}
}

func _FleetStorageClassType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FleetStorageClassType)
	// device_choice
	switch x := m.DeviceChoice.(type) {
	case *FleetStorageClassType_NetappTrident:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NetappTrident); err != nil {
			return err
		}
	case *FleetStorageClassType_PureServiceOrchestrator:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PureServiceOrchestrator); err != nil {
			return err
		}
	case *FleetStorageClassType_OpenebsEnterprise:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OpenebsEnterprise); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FleetStorageClassType.DeviceChoice has unexpected type %T", x)
	}
	return nil
}

func _FleetStorageClassType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FleetStorageClassType)
	switch tag {
	case 9: // device_choice.netapp_trident
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StorageClassNetappTridentType)
		err := b.DecodeMessage(msg)
		m.DeviceChoice = &FleetStorageClassType_NetappTrident{msg}
		return true, err
	case 10: // device_choice.pure_service_orchestrator
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StorageClassPureServiceOrchestratorType)
		err := b.DecodeMessage(msg)
		m.DeviceChoice = &FleetStorageClassType_PureServiceOrchestrator{msg}
		return true, err
	case 11: // device_choice.openebs_enterprise
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StorageClassOpenebsEnterpriseType)
		err := b.DecodeMessage(msg)
		m.DeviceChoice = &FleetStorageClassType_OpenebsEnterprise{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FleetStorageClassType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FleetStorageClassType)
	// device_choice
	switch x := m.DeviceChoice.(type) {
	case *FleetStorageClassType_NetappTrident:
		s := proto.Size(x.NetappTrident)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FleetStorageClassType_PureServiceOrchestrator:
		s := proto.Size(x.PureServiceOrchestrator)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FleetStorageClassType_OpenebsEnterprise:
		s := proto.Size(x.OpenebsEnterprise)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Custom Storage Class List
//
// x-displayName: "Custom Storage Class List"
// Add additional custom storage classes in kubernetes for this fleet
type FleetStorageClassListType struct {
	// List of Storage Classes
	//
	// x-displayName: "List of Storage Classes"
	// List of custom storage classes
	StorageClasses []*FleetStorageClassType `protobuf:"bytes,1,rep,name=storage_classes,json=storageClasses" json:"storage_classes,omitempty"`
}

func (m *FleetStorageClassListType) Reset()                    { *m = FleetStorageClassListType{} }
func (*FleetStorageClassListType) ProtoMessage()               {}
func (*FleetStorageClassListType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{29} }

func (m *FleetStorageClassListType) GetStorageClasses() []*FleetStorageClassType {
	if m != nil {
		return m.StorageClasses
	}
	return nil
}

// LACP parameters
//
// x-displayName: "LACP parameters
// LACP parameters for the bond device
type BondLacpType struct {
	// Interval
	//
	// x-displayName: "LACP Packet Interval"
	// x-example: "30"
	// Interval in seconds to transmit LACP packets
	Rate uint32 `protobuf:"varint,1,opt,name=rate,proto3" json:"rate,omitempty"`
}

func (m *BondLacpType) Reset()                    { *m = BondLacpType{} }
func (*BondLacpType) ProtoMessage()               {}
func (*BondLacpType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{30} }

func (m *BondLacpType) GetRate() uint32 {
	if m != nil {
		return m.Rate
	}
	return 0
}

// Bond Device
//
// x-displayName: "Bond Device"
// Bond devices configuration for fleet
type FleetBondDeviceType struct {
	// Bond Device
	//
	// x-displayName: "Bond Device Name"
	// x-example: "bond0"
	// x-required
	// Bond device name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Member Ethernet Devices
	//
	// x-displayName: "Member Ethernet Devices"
	// x-required
	// Ethernet devices that will make up this bond
	Devices []string `protobuf:"bytes,2,rep,name=devices" json:"devices,omitempty"`
	// Select Bond Mode
	//
	// x-displayName: "Select Bond Mode"
	// x-required
	// Select how bonding will happen, Active/Backup or LACP
	//
	// Types that are valid to be assigned to LacpChoice:
	//	*FleetBondDeviceType_Lacp
	//	*FleetBondDeviceType_ActiveBackup
	LacpChoice isFleetBondDeviceType_LacpChoice `protobuf_oneof:"lacp_choice"`
	// Link Polling Interval
	//
	// x-displayName: "Link Polling Interval"
	// x-required
	// x-example: "1000"
	// Link polling interval in millisecond
	LinkPollingInterval uint32 `protobuf:"varint,6,opt,name=link_polling_interval,json=linkPollingInterval,proto3" json:"link_polling_interval,omitempty"`
	// Link Up Delay
	//
	// x-displayName: "Link Up Delay"
	// x-required
	// x-example: "200"
	// Milliseconds wait before link is declared up
	LinkUpDelay uint32 `protobuf:"varint,7,opt,name=link_up_delay,json=linkUpDelay,proto3" json:"link_up_delay,omitempty"`
}

func (m *FleetBondDeviceType) Reset()                    { *m = FleetBondDeviceType{} }
func (*FleetBondDeviceType) ProtoMessage()               {}
func (*FleetBondDeviceType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{31} }

type isFleetBondDeviceType_LacpChoice interface {
	isFleetBondDeviceType_LacpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type FleetBondDeviceType_Lacp struct {
	Lacp *BondLacpType `protobuf:"bytes,4,opt,name=lacp,oneof"`
}
type FleetBondDeviceType_ActiveBackup struct {
	ActiveBackup *ves_io_schema4.Empty `protobuf:"bytes,5,opt,name=active_backup,json=activeBackup,oneof"`
}

func (*FleetBondDeviceType_Lacp) isFleetBondDeviceType_LacpChoice()         {}
func (*FleetBondDeviceType_ActiveBackup) isFleetBondDeviceType_LacpChoice() {}

func (m *FleetBondDeviceType) GetLacpChoice() isFleetBondDeviceType_LacpChoice {
	if m != nil {
		return m.LacpChoice
	}
	return nil
}

func (m *FleetBondDeviceType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FleetBondDeviceType) GetDevices() []string {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *FleetBondDeviceType) GetLacp() *BondLacpType {
	if x, ok := m.GetLacpChoice().(*FleetBondDeviceType_Lacp); ok {
		return x.Lacp
	}
	return nil
}

func (m *FleetBondDeviceType) GetActiveBackup() *ves_io_schema4.Empty {
	if x, ok := m.GetLacpChoice().(*FleetBondDeviceType_ActiveBackup); ok {
		return x.ActiveBackup
	}
	return nil
}

func (m *FleetBondDeviceType) GetLinkPollingInterval() uint32 {
	if m != nil {
		return m.LinkPollingInterval
	}
	return 0
}

func (m *FleetBondDeviceType) GetLinkUpDelay() uint32 {
	if m != nil {
		return m.LinkUpDelay
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FleetBondDeviceType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FleetBondDeviceType_OneofMarshaler, _FleetBondDeviceType_OneofUnmarshaler, _FleetBondDeviceType_OneofSizer, []interface{}{
		(*FleetBondDeviceType_Lacp)(nil),
		(*FleetBondDeviceType_ActiveBackup)(nil),
	}
}

func _FleetBondDeviceType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FleetBondDeviceType)
	// lacp_choice
	switch x := m.LacpChoice.(type) {
	case *FleetBondDeviceType_Lacp:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Lacp); err != nil {
			return err
		}
	case *FleetBondDeviceType_ActiveBackup:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ActiveBackup); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FleetBondDeviceType.LacpChoice has unexpected type %T", x)
	}
	return nil
}

func _FleetBondDeviceType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FleetBondDeviceType)
	switch tag {
	case 4: // lacp_choice.lacp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BondLacpType)
		err := b.DecodeMessage(msg)
		m.LacpChoice = &FleetBondDeviceType_Lacp{msg}
		return true, err
	case 5: // lacp_choice.active_backup
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.LacpChoice = &FleetBondDeviceType_ActiveBackup{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FleetBondDeviceType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FleetBondDeviceType)
	// lacp_choice
	switch x := m.LacpChoice.(type) {
	case *FleetBondDeviceType_Lacp:
		s := proto.Size(x.Lacp)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FleetBondDeviceType_ActiveBackup:
		s := proto.Size(x.ActiveBackup)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Bond Devices List
//
// x-displayName: "Bond Devices List"
// List of bond devices for this fleet
type FleetBondDevicesListType struct {
	// Bond Devices List
	//
	// x-displayName: "Bond Devices List"
	// x-required
	// List of bond devices for this fleet
	BondDevices []*FleetBondDeviceType `protobuf:"bytes,1,rep,name=bond_devices,json=bondDevices" json:"bond_devices,omitempty"`
}

func (m *FleetBondDevicesListType) Reset()                    { *m = FleetBondDevicesListType{} }
func (*FleetBondDevicesListType) ProtoMessage()               {}
func (*FleetBondDevicesListType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{32} }

func (m *FleetBondDevicesListType) GetBondDevices() []*FleetBondDeviceType {
	if m != nil {
		return m.BondDevices
	}
	return nil
}

// Storage Static Routes List
//
// x-displayName: "Storage Static Routes List"
// List of storage static routes
type FleetStorageStaticRoutesListType struct {
	// List of Static Routes
	//
	// x-displayName: "List of Static Routes"
	// x-required
	// List of storage static routes
	StorageRoutes []*ves_io_schema4.StaticRouteType `protobuf:"bytes,1,rep,name=storage_routes,json=storageRoutes" json:"storage_routes,omitempty"`
}

func (m *FleetStorageStaticRoutesListType) Reset()      { *m = FleetStorageStaticRoutesListType{} }
func (*FleetStorageStaticRoutesListType) ProtoMessage() {}
func (*FleetStorageStaticRoutesListType) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{33}
}

func (m *FleetStorageStaticRoutesListType) GetStorageRoutes() []*ves_io_schema4.StaticRouteType {
	if m != nil {
		return m.StorageRoutes
	}
	return nil
}

// BGP Configuration
//
// x-displayName: "BGP Configuration"
// BGP configuration parameters
type BGPConfiguration struct {
	// BGP Parameters
	//
	// x-displayName: "Common Parameters"
	// x-required
	// BGP parameters for local site
	BgpParameters *ves_io_schema_bgp.BgpParameters `protobuf:"bytes,1,opt,name=bgp_parameters,json=bgpParameters" json:"bgp_parameters,omitempty"`
	// BGP Peers
	//
	// x-displayName: "Peers"
	// BGP parameters for peer
	Peers []*ves_io_schema_bgp.Peer `protobuf:"bytes,2,rep,name=peers" json:"peers,omitempty"`
}

func (m *BGPConfiguration) Reset()                    { *m = BGPConfiguration{} }
func (*BGPConfiguration) ProtoMessage()               {}
func (*BGPConfiguration) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{34} }

func (m *BGPConfiguration) GetBgpParameters() *ves_io_schema_bgp.BgpParameters {
	if m != nil {
		return m.BgpParameters
	}
	return nil
}

func (m *BGPConfiguration) GetPeers() []*ves_io_schema_bgp.Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

// Local Control Plane
//
// x-displayName: "Local Control Plane"
// Enable local control plane for L3VPN, SRV6, EVPN etc
type LocalControlPlaneType struct {
	// Network Choice
	//
	// x-displayName: "Network for Control Plane"
	// x-required
	// Select local network for local control plane
	//
	// Types that are valid to be assigned to NetworkChoice:
	//	*LocalControlPlaneType_InsideVn
	//	*LocalControlPlaneType_OutsideVn
	NetworkChoice isLocalControlPlaneType_NetworkChoice `protobuf_oneof:"network_choice"`
	// BGP configuration
	//
	// x-displayName: "BGP Configuration"
	// BGP configuration for local control plane
	BgpConfig *BGPConfiguration `protobuf:"bytes,4,opt,name=bgp_config,json=bgpConfig" json:"bgp_config,omitempty"`
}

func (m *LocalControlPlaneType) Reset()                    { *m = LocalControlPlaneType{} }
func (*LocalControlPlaneType) ProtoMessage()               {}
func (*LocalControlPlaneType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{35} }

type isLocalControlPlaneType_NetworkChoice interface {
	isLocalControlPlaneType_NetworkChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LocalControlPlaneType_InsideVn struct {
	InsideVn *ves_io_schema4.Empty `protobuf:"bytes,2,opt,name=inside_vn,json=insideVn,oneof"`
}
type LocalControlPlaneType_OutsideVn struct {
	OutsideVn *ves_io_schema4.Empty `protobuf:"bytes,3,opt,name=outside_vn,json=outsideVn,oneof"`
}

func (*LocalControlPlaneType_InsideVn) isLocalControlPlaneType_NetworkChoice()  {}
func (*LocalControlPlaneType_OutsideVn) isLocalControlPlaneType_NetworkChoice() {}

func (m *LocalControlPlaneType) GetNetworkChoice() isLocalControlPlaneType_NetworkChoice {
	if m != nil {
		return m.NetworkChoice
	}
	return nil
}

func (m *LocalControlPlaneType) GetInsideVn() *ves_io_schema4.Empty {
	if x, ok := m.GetNetworkChoice().(*LocalControlPlaneType_InsideVn); ok {
		return x.InsideVn
	}
	return nil
}

func (m *LocalControlPlaneType) GetOutsideVn() *ves_io_schema4.Empty {
	if x, ok := m.GetNetworkChoice().(*LocalControlPlaneType_OutsideVn); ok {
		return x.OutsideVn
	}
	return nil
}

func (m *LocalControlPlaneType) GetBgpConfig() *BGPConfiguration {
	if m != nil {
		return m.BgpConfig
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LocalControlPlaneType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LocalControlPlaneType_OneofMarshaler, _LocalControlPlaneType_OneofUnmarshaler, _LocalControlPlaneType_OneofSizer, []interface{}{
		(*LocalControlPlaneType_InsideVn)(nil),
		(*LocalControlPlaneType_OutsideVn)(nil),
	}
}

func _LocalControlPlaneType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LocalControlPlaneType)
	// network_choice
	switch x := m.NetworkChoice.(type) {
	case *LocalControlPlaneType_InsideVn:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InsideVn); err != nil {
			return err
		}
	case *LocalControlPlaneType_OutsideVn:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OutsideVn); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LocalControlPlaneType.NetworkChoice has unexpected type %T", x)
	}
	return nil
}

func _LocalControlPlaneType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LocalControlPlaneType)
	switch tag {
	case 2: // network_choice.inside_vn
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.NetworkChoice = &LocalControlPlaneType_InsideVn{msg}
		return true, err
	case 3: // network_choice.outside_vn
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.NetworkChoice = &LocalControlPlaneType_OutsideVn{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LocalControlPlaneType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LocalControlPlaneType)
	// network_choice
	switch x := m.NetworkChoice.(type) {
	case *LocalControlPlaneType_InsideVn:
		s := proto.Size(x.InsideVn)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LocalControlPlaneType_OutsideVn:
		s := proto.Size(x.OutsideVn)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Global Specifications
//
// x-displayName: "Global Specifications"
// Fleet specifications
type GlobalSpecType struct {
	// fleet_label
	//
	// x-displayName: "Fleet Label Value"
	// x-required
	// x-example: "sfo"
	// fleet_label value is used to create known_label "ves.io/fleet=<fleet_label>"
	// The known_label is created in the "shared" namespace for the tenant.
	//
	// A virtual_site object with name <fleet_label> is also created in "shared" namespace for tenant.
	// The virtual_site object will select all sites configured with the known_label above
	// fleet_label with "sfo" will create a known_label "ves.io/fleet=sfo" in tenant for the fleet
	FleetLabel string `protobuf:"bytes,1,opt,name=fleet_label,json=fleetLabel,proto3" json:"fleet_label,omitempty"`
	// Software Version
	//
	// x-displayName: "Software Version"
	// x-example: "value"
	// Volterra software version is human readable string matching released set of version components.
	// The given software version is applied to all sites that are member of the fleet.
	// Current software installed can be overridden via site config.
	VolterraSoftwareVersion string `protobuf:"bytes,2,opt,name=volterra_software_version,json=volterraSoftwareVersion,proto3" json:"volterra_software_version,omitempty"`
	// Devices
	//
	// x-displayName: "Devices"
	// Configuration for all devices in the fleet.
	// Examples of devices are - network interfaces, cameras, scanners etc.
	// Configuration a device is applied on VER node if the VER node is member of this fleet and
	// has an corresponding interface/device. The mapping from device configured in fleet with
	// interface/device in VER node depends on the type of device and is documented in
	// device instance specific sections
	Devices []*DeviceInstanceType `protobuf:"bytes,3,rep,name=devices" json:"devices,omitempty"`
	// Network Connectors
	//
	// x-displayName: "Network Connectors"
	// Network Connector defines connection between two virtual networks in a given site.
	// Fleet defines one or more such network connectors.
	// The network connectors configuration is applied on all sites that are member of the fleet.
	NetworkConnectors []*ves_io_schema4.ObjectRefType `protobuf:"bytes,4,rep,name=network_connectors,json=networkConnectors" json:"network_connectors,omitempty"`
	// Network Firewall
	//
	// x-displayName: "Network Firewall"
	// Network Firewall defines firewall to be applied for the virtual networks in the fleet.
	// The network firewall configuration is applied on all sites that are member of the fleet.
	//
	// Constraints
	// The Network Firewall is applied on Virtual Networks of type site local network and site local inside network
	NetworkFirewall []*ves_io_schema4.ObjectRefType `protobuf:"bytes,5,rep,name=network_firewall,json=networkFirewall" json:"network_firewall,omitempty"`
	// Operating System Version
	//
	// x-displayName: "Operating System Version"
	// x-example: "value"
	// Desired Operating System version that is applied to all sites that are member of the fleet.
	// Current Operating System version can be overridden via site config.
	OperatingSystemVersion string `protobuf:"bytes,6,opt,name=operating_system_version,json=operatingSystemVersion,proto3" json:"operating_system_version,omitempty"`
	// Outside Virtual Network
	//
	// x-displayName: "Outside (Site Local) Virtual Network"
	// Default outside (site local) virtual network for the fleet
	OutsideVirtualNetwork []*ves_io_schema4.ObjectRefType `protobuf:"bytes,7,rep,name=outside_virtual_network,json=outsideVirtualNetwork" json:"outside_virtual_network,omitempty"`
	// Inside Virtual Network
	//
	// x-displayName: "Site Local Inside Virtual Network"
	// Default inside (site local) virtual network for the fleet
	InsideVirtualNetwork []*ves_io_schema4.ObjectRefType `protobuf:"bytes,8,rep,name=inside_virtual_network,json=insideVirtualNetwork" json:"inside_virtual_network,omitempty"`
	// Select Interface Config
	//
	// x-displayName: "Select Interface Configuration"
	// x-required
	// Select how interfaces are configured for this fleet
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*GlobalSpecType_InterfaceList
	//	*GlobalSpecType_DefaultInterfaces
	//	*GlobalSpecType_LegacyDevices
	InterfaceChoice isGlobalSpecType_InterfaceChoice `protobuf_oneof:"interface_choice"`
	// Select Bond Configuration
	//
	// x-displayName: ""Select Bond Configuration"
	// x-required
	// Add bond interface devices to the fleet
	//
	// Types that are valid to be assigned to BondChoice:
	//	*GlobalSpecType_NoBondDevices
	//	*GlobalSpecType_BondDeviceList
	BondChoice isGlobalSpecType_BondChoice `protobuf_oneof:"bond_choice"`
	// Storage Interfaces
	//
	// x-displayName: "Select Storage Interface Configuration"
	// x-required
	// Select if storage interfaces are configured
	//
	// Types that are valid to be assigned to StorageInterfaceChoice:
	//	*GlobalSpecType_NoStorageInterfaces
	//	*GlobalSpecType_StorageInterfaceList
	StorageInterfaceChoice isGlobalSpecType_StorageInterfaceChoice `protobuf_oneof:"storage_interface_choice"`
	// Storage Device Configuration
	//
	// x-displayName: "Select Storage Device Configuration"
	// x-required
	// Configure external storage devices for this fleet
	//
	// Types that are valid to be assigned to StorageDeviceChoice:
	//	*GlobalSpecType_NoStorageDevice
	//	*GlobalSpecType_StorageDeviceList
	StorageDeviceChoice isGlobalSpecType_StorageDeviceChoice `protobuf_oneof:"storage_device_choice"`
	// Storage Class Configuration
	//
	// x-displayName: "Select Configuration for Storage Classes"
	// x-required
	// Configure custom storage classes in kubernetes for this fleet
	//
	// Types that are valid to be assigned to StorageClassChoice:
	//	*GlobalSpecType_DefaultStorageClass
	//	*GlobalSpecType_StorageClassList
	StorageClassChoice isGlobalSpecType_StorageClassChoice `protobuf_oneof:"storage_class_choice"`
	// Select DC Cluster Group
	//
	// x-displayName: "Select DC Cluster Group"
	// x-required
	// Configure DC cluster group for this fleet
	//
	// Types that are valid to be assigned to DcClusterGroupChoice:
	//	*GlobalSpecType_NoDcClusterGroup
	//	*GlobalSpecType_DcClusterGroup
	//	*GlobalSpecType_DcClusterGroupInside
	DcClusterGroupChoice isGlobalSpecType_DcClusterGroupChoice `protobuf_oneof:"dc_cluster_group_choice"`
	// Select GPU Enable/Disable
	//
	// x-displayName: "Enable/Disable GPU"
	// x-required
	// Enable or Disable GPU for this fleet
	//
	// Types that are valid to be assigned to GpuChoice:
	//	*GlobalSpecType_DisableGpu
	//	*GlobalSpecType_EnableGpu
	GpuChoice isGlobalSpecType_GpuChoice `protobuf_oneof:"gpu_choice"`
	// Etcd Clustering Network
	//
	// x-displayName: "Etcd Clustering Network"
	// Decided which network is used for etcd clustering
	EtcdClusterNetwork EtcdClusterNetworkType `protobuf:"varint,33,opt,name=etcd_cluster_network,json=etcdClusterNetwork,proto3,enum=ves.io.schema.fleet.EtcdClusterNetworkType" json:"etcd_cluster_network,omitempty"`
	// Storage Static Routes
	//
	// x-displayName: "Select Storage Storage Static Routes"
	// x-required
	// Select storage Storage Static Routes
	//
	// Types that are valid to be assigned to StorageStaticRoutesChoice:
	//	*GlobalSpecType_NoStorageStaticRoutes
	//	*GlobalSpecType_StorageStaticRoutes
	StorageStaticRoutesChoice isGlobalSpecType_StorageStaticRoutesChoice `protobuf_oneof:"storage_static_routes_choice"`
	// Enable default fleet config download
	//
	// x-displayName: "Enable Default Fleet Config Download"
	// Enable default fleet config, It must be set for storage config and gpu config
	EnableDefaultFleetConfigDownload bool `protobuf:"varint,37,opt,name=enable_default_fleet_config_download,json=enableDefaultFleetConfigDownload,proto3" json:"enable_default_fleet_config_download,omitempty"`
	// Fleet type
	//
	// x-displayName: "Fleet Type"
	// Fleet Type can be fleet of single site or multiple sites. Corresponding virtual site is not created
	// for single site fleet.
	FleetType FleetType `protobuf:"varint,41,opt,name=fleet_type,json=fleetType,proto3,enum=ves.io.schema.fleet.FleetType" json:"fleet_type,omitempty"`
	// Single Site Fleet Site
	//
	// x-displayName: "Single Site Fleet Site"
	// Vega should use this ref when when fleet type is single site fleet
	SingleSite []*ves_io_schema4.ObjectRefType `protobuf:"bytes,42,rep,name=single_site,json=singleSite" json:"single_site,omitempty"`
	// Logs Streaming
	//
	// x-displayName: "Logs Streaming"
	// x-required
	// Select Logs receiver for logs streaming
	//
	// Types that are valid to be assigned to LogsReceiverChoice:
	//	*GlobalSpecType_LogsStreamingDisabled
	//	*GlobalSpecType_LogReceiver
	LogsReceiverChoice isGlobalSpecType_LogsReceiverChoice `protobuf_oneof:"logs_receiver_choice"`
	// USB Device Policy
	//
	// x-displayName: "USB Device Policy"
	// x-required
	// Select USB device policy
	//
	// Types that are valid to be assigned to UsbPolicyChoice:
	//	*GlobalSpecType_DenyAllUsb
	//	*GlobalSpecType_AllowAllUsb
	//	*GlobalSpecType_UsbPolicy
	UsbPolicyChoice isGlobalSpecType_UsbPolicyChoice `protobuf_oneof:"usb_policy_choice"`
	// Enable Local K8s Cluster access
	//
	// x-displayName: "Enable Local K8s Cluster access"
	// Local K8s cluster access is enabled, using config k8s_cluster object
	K8SCluster *ves_io_schema_views.ObjectRefType `protobuf:"bytes,50,opt,name=k8s_cluster,json=k8sCluster" json:"k8s_cluster,omitempty"`
	// Local Control Plane
	//
	// x-displayName: "Local Control Plane"
	// Enable local control plane for L3VPN, SRV6, EVPN etc
	LocalControlPlane *LocalControlPlaneType `protobuf:"bytes,51,opt,name=local_control_plane,json=localControlPlane" json:"local_control_plane,omitempty"`
	// view_internal
	//
	// x-displayName: "View Internal"
	// Reference to view internal object
	ViewInternal *ves_io_schema_views.ObjectRefType `protobuf:"bytes,1000,opt,name=view_internal,json=viewInternal" json:"view_internal,omitempty"`
}

func (m *GlobalSpecType) Reset()                    { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage()               {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{36} }

type isGlobalSpecType_InterfaceChoice interface {
	isGlobalSpecType_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_BondChoice interface {
	isGlobalSpecType_BondChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_StorageInterfaceChoice interface {
	isGlobalSpecType_StorageInterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_StorageDeviceChoice interface {
	isGlobalSpecType_StorageDeviceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_StorageClassChoice interface {
	isGlobalSpecType_StorageClassChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_DcClusterGroupChoice interface {
	isGlobalSpecType_DcClusterGroupChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_GpuChoice interface {
	isGlobalSpecType_GpuChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_StorageStaticRoutesChoice interface {
	isGlobalSpecType_StorageStaticRoutesChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_LogsReceiverChoice interface {
	isGlobalSpecType_LogsReceiverChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_UsbPolicyChoice interface {
	isGlobalSpecType_UsbPolicyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_InterfaceList struct {
	InterfaceList *FleetInterfaceListType `protobuf:"bytes,10,opt,name=interface_list,json=interfaceList,oneof"`
}
type GlobalSpecType_DefaultInterfaces struct {
	DefaultInterfaces *ves_io_schema4.Empty `protobuf:"bytes,39,opt,name=default_interfaces,json=defaultInterfaces,oneof"`
}
type GlobalSpecType_LegacyDevices struct {
	LegacyDevices *ves_io_schema4.Empty `protobuf:"bytes,11,opt,name=legacy_devices,json=legacyDevices,oneof"`
}
type GlobalSpecType_NoBondDevices struct {
	NoBondDevices *ves_io_schema4.Empty `protobuf:"bytes,16,opt,name=no_bond_devices,json=noBondDevices,oneof"`
}
type GlobalSpecType_BondDeviceList struct {
	BondDeviceList *FleetBondDevicesListType `protobuf:"bytes,17,opt,name=bond_device_list,json=bondDeviceList,oneof"`
}
type GlobalSpecType_NoStorageInterfaces struct {
	NoStorageInterfaces *ves_io_schema4.Empty `protobuf:"bytes,19,opt,name=no_storage_interfaces,json=noStorageInterfaces,oneof"`
}
type GlobalSpecType_StorageInterfaceList struct {
	StorageInterfaceList *FleetInterfaceListType `protobuf:"bytes,20,opt,name=storage_interface_list,json=storageInterfaceList,oneof"`
}
type GlobalSpecType_NoStorageDevice struct {
	NoStorageDevice *ves_io_schema4.Empty `protobuf:"bytes,22,opt,name=no_storage_device,json=noStorageDevice,oneof"`
}
type GlobalSpecType_StorageDeviceList struct {
	StorageDeviceList *FleetStorageDeviceListType `protobuf:"bytes,23,opt,name=storage_device_list,json=storageDeviceList,oneof"`
}
type GlobalSpecType_DefaultStorageClass struct {
	DefaultStorageClass *ves_io_schema4.Empty `protobuf:"bytes,25,opt,name=default_storage_class,json=defaultStorageClass,oneof"`
}
type GlobalSpecType_StorageClassList struct {
	StorageClassList *FleetStorageClassListType `protobuf:"bytes,26,opt,name=storage_class_list,json=storageClassList,oneof"`
}
type GlobalSpecType_NoDcClusterGroup struct {
	NoDcClusterGroup *ves_io_schema4.Empty `protobuf:"bytes,28,opt,name=no_dc_cluster_group,json=noDcClusterGroup,oneof"`
}
type GlobalSpecType_DcClusterGroup struct {
	DcClusterGroup *ves_io_schema_views.ObjectRefType `protobuf:"bytes,29,opt,name=dc_cluster_group,json=dcClusterGroup,oneof"`
}
type GlobalSpecType_DcClusterGroupInside struct {
	DcClusterGroupInside *ves_io_schema_views.ObjectRefType `protobuf:"bytes,38,opt,name=dc_cluster_group_inside,json=dcClusterGroupInside,oneof"`
}
type GlobalSpecType_DisableGpu struct {
	DisableGpu *ves_io_schema4.Empty `protobuf:"bytes,31,opt,name=disable_gpu,json=disableGpu,oneof"`
}
type GlobalSpecType_EnableGpu struct {
	EnableGpu *ves_io_schema4.Empty `protobuf:"bytes,32,opt,name=enable_gpu,json=enableGpu,oneof"`
}
type GlobalSpecType_NoStorageStaticRoutes struct {
	NoStorageStaticRoutes *ves_io_schema4.Empty `protobuf:"bytes,35,opt,name=no_storage_static_routes,json=noStorageStaticRoutes,oneof"`
}
type GlobalSpecType_StorageStaticRoutes struct {
	StorageStaticRoutes *FleetStorageStaticRoutesListType `protobuf:"bytes,36,opt,name=storage_static_routes,json=storageStaticRoutes,oneof"`
}
type GlobalSpecType_LogsStreamingDisabled struct {
	LogsStreamingDisabled *ves_io_schema4.Empty `protobuf:"bytes,44,opt,name=logs_streaming_disabled,json=logsStreamingDisabled,oneof"`
}
type GlobalSpecType_LogReceiver struct {
	LogReceiver *ves_io_schema_views.ObjectRefType `protobuf:"bytes,45,opt,name=log_receiver,json=logReceiver,oneof"`
}
type GlobalSpecType_DenyAllUsb struct {
	DenyAllUsb *ves_io_schema4.Empty `protobuf:"bytes,47,opt,name=deny_all_usb,json=denyAllUsb,oneof"`
}
type GlobalSpecType_AllowAllUsb struct {
	AllowAllUsb *ves_io_schema4.Empty `protobuf:"bytes,48,opt,name=allow_all_usb,json=allowAllUsb,oneof"`
}
type GlobalSpecType_UsbPolicy struct {
	UsbPolicy *ves_io_schema_views.ObjectRefType `protobuf:"bytes,49,opt,name=usb_policy,json=usbPolicy,oneof"`
}

func (*GlobalSpecType_InterfaceList) isGlobalSpecType_InterfaceChoice()                   {}
func (*GlobalSpecType_DefaultInterfaces) isGlobalSpecType_InterfaceChoice()               {}
func (*GlobalSpecType_LegacyDevices) isGlobalSpecType_InterfaceChoice()                   {}
func (*GlobalSpecType_NoBondDevices) isGlobalSpecType_BondChoice()                        {}
func (*GlobalSpecType_BondDeviceList) isGlobalSpecType_BondChoice()                       {}
func (*GlobalSpecType_NoStorageInterfaces) isGlobalSpecType_StorageInterfaceChoice()      {}
func (*GlobalSpecType_StorageInterfaceList) isGlobalSpecType_StorageInterfaceChoice()     {}
func (*GlobalSpecType_NoStorageDevice) isGlobalSpecType_StorageDeviceChoice()             {}
func (*GlobalSpecType_StorageDeviceList) isGlobalSpecType_StorageDeviceChoice()           {}
func (*GlobalSpecType_DefaultStorageClass) isGlobalSpecType_StorageClassChoice()          {}
func (*GlobalSpecType_StorageClassList) isGlobalSpecType_StorageClassChoice()             {}
func (*GlobalSpecType_NoDcClusterGroup) isGlobalSpecType_DcClusterGroupChoice()           {}
func (*GlobalSpecType_DcClusterGroup) isGlobalSpecType_DcClusterGroupChoice()             {}
func (*GlobalSpecType_DcClusterGroupInside) isGlobalSpecType_DcClusterGroupChoice()       {}
func (*GlobalSpecType_DisableGpu) isGlobalSpecType_GpuChoice()                            {}
func (*GlobalSpecType_EnableGpu) isGlobalSpecType_GpuChoice()                             {}
func (*GlobalSpecType_NoStorageStaticRoutes) isGlobalSpecType_StorageStaticRoutesChoice() {}
func (*GlobalSpecType_StorageStaticRoutes) isGlobalSpecType_StorageStaticRoutesChoice()   {}
func (*GlobalSpecType_LogsStreamingDisabled) isGlobalSpecType_LogsReceiverChoice()        {}
func (*GlobalSpecType_LogReceiver) isGlobalSpecType_LogsReceiverChoice()                  {}
func (*GlobalSpecType_DenyAllUsb) isGlobalSpecType_UsbPolicyChoice()                      {}
func (*GlobalSpecType_AllowAllUsb) isGlobalSpecType_UsbPolicyChoice()                     {}
func (*GlobalSpecType_UsbPolicy) isGlobalSpecType_UsbPolicyChoice()                       {}

func (m *GlobalSpecType) GetInterfaceChoice() isGlobalSpecType_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}
func (m *GlobalSpecType) GetBondChoice() isGlobalSpecType_BondChoice {
	if m != nil {
		return m.BondChoice
	}
	return nil
}
func (m *GlobalSpecType) GetStorageInterfaceChoice() isGlobalSpecType_StorageInterfaceChoice {
	if m != nil {
		return m.StorageInterfaceChoice
	}
	return nil
}
func (m *GlobalSpecType) GetStorageDeviceChoice() isGlobalSpecType_StorageDeviceChoice {
	if m != nil {
		return m.StorageDeviceChoice
	}
	return nil
}
func (m *GlobalSpecType) GetStorageClassChoice() isGlobalSpecType_StorageClassChoice {
	if m != nil {
		return m.StorageClassChoice
	}
	return nil
}
func (m *GlobalSpecType) GetDcClusterGroupChoice() isGlobalSpecType_DcClusterGroupChoice {
	if m != nil {
		return m.DcClusterGroupChoice
	}
	return nil
}
func (m *GlobalSpecType) GetGpuChoice() isGlobalSpecType_GpuChoice {
	if m != nil {
		return m.GpuChoice
	}
	return nil
}
func (m *GlobalSpecType) GetStorageStaticRoutesChoice() isGlobalSpecType_StorageStaticRoutesChoice {
	if m != nil {
		return m.StorageStaticRoutesChoice
	}
	return nil
}
func (m *GlobalSpecType) GetLogsReceiverChoice() isGlobalSpecType_LogsReceiverChoice {
	if m != nil {
		return m.LogsReceiverChoice
	}
	return nil
}
func (m *GlobalSpecType) GetUsbPolicyChoice() isGlobalSpecType_UsbPolicyChoice {
	if m != nil {
		return m.UsbPolicyChoice
	}
	return nil
}

func (m *GlobalSpecType) GetFleetLabel() string {
	if m != nil {
		return m.FleetLabel
	}
	return ""
}

func (m *GlobalSpecType) GetVolterraSoftwareVersion() string {
	if m != nil {
		return m.VolterraSoftwareVersion
	}
	return ""
}

func (m *GlobalSpecType) GetDevices() []*DeviceInstanceType {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *GlobalSpecType) GetNetworkConnectors() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.NetworkConnectors
	}
	return nil
}

func (m *GlobalSpecType) GetNetworkFirewall() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.NetworkFirewall
	}
	return nil
}

func (m *GlobalSpecType) GetOperatingSystemVersion() string {
	if m != nil {
		return m.OperatingSystemVersion
	}
	return ""
}

func (m *GlobalSpecType) GetOutsideVirtualNetwork() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.OutsideVirtualNetwork
	}
	return nil
}

func (m *GlobalSpecType) GetInsideVirtualNetwork() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.InsideVirtualNetwork
	}
	return nil
}

func (m *GlobalSpecType) GetInterfaceList() *FleetInterfaceListType {
	if x, ok := m.GetInterfaceChoice().(*GlobalSpecType_InterfaceList); ok {
		return x.InterfaceList
	}
	return nil
}

func (m *GlobalSpecType) GetDefaultInterfaces() *ves_io_schema4.Empty {
	if x, ok := m.GetInterfaceChoice().(*GlobalSpecType_DefaultInterfaces); ok {
		return x.DefaultInterfaces
	}
	return nil
}

func (m *GlobalSpecType) GetLegacyDevices() *ves_io_schema4.Empty {
	if x, ok := m.GetInterfaceChoice().(*GlobalSpecType_LegacyDevices); ok {
		return x.LegacyDevices
	}
	return nil
}

func (m *GlobalSpecType) GetNoBondDevices() *ves_io_schema4.Empty {
	if x, ok := m.GetBondChoice().(*GlobalSpecType_NoBondDevices); ok {
		return x.NoBondDevices
	}
	return nil
}

func (m *GlobalSpecType) GetBondDeviceList() *FleetBondDevicesListType {
	if x, ok := m.GetBondChoice().(*GlobalSpecType_BondDeviceList); ok {
		return x.BondDeviceList
	}
	return nil
}

func (m *GlobalSpecType) GetNoStorageInterfaces() *ves_io_schema4.Empty {
	if x, ok := m.GetStorageInterfaceChoice().(*GlobalSpecType_NoStorageInterfaces); ok {
		return x.NoStorageInterfaces
	}
	return nil
}

func (m *GlobalSpecType) GetStorageInterfaceList() *FleetInterfaceListType {
	if x, ok := m.GetStorageInterfaceChoice().(*GlobalSpecType_StorageInterfaceList); ok {
		return x.StorageInterfaceList
	}
	return nil
}

func (m *GlobalSpecType) GetNoStorageDevice() *ves_io_schema4.Empty {
	if x, ok := m.GetStorageDeviceChoice().(*GlobalSpecType_NoStorageDevice); ok {
		return x.NoStorageDevice
	}
	return nil
}

func (m *GlobalSpecType) GetStorageDeviceList() *FleetStorageDeviceListType {
	if x, ok := m.GetStorageDeviceChoice().(*GlobalSpecType_StorageDeviceList); ok {
		return x.StorageDeviceList
	}
	return nil
}

func (m *GlobalSpecType) GetDefaultStorageClass() *ves_io_schema4.Empty {
	if x, ok := m.GetStorageClassChoice().(*GlobalSpecType_DefaultStorageClass); ok {
		return x.DefaultStorageClass
	}
	return nil
}

func (m *GlobalSpecType) GetStorageClassList() *FleetStorageClassListType {
	if x, ok := m.GetStorageClassChoice().(*GlobalSpecType_StorageClassList); ok {
		return x.StorageClassList
	}
	return nil
}

func (m *GlobalSpecType) GetNoDcClusterGroup() *ves_io_schema4.Empty {
	if x, ok := m.GetDcClusterGroupChoice().(*GlobalSpecType_NoDcClusterGroup); ok {
		return x.NoDcClusterGroup
	}
	return nil
}

func (m *GlobalSpecType) GetDcClusterGroup() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetDcClusterGroupChoice().(*GlobalSpecType_DcClusterGroup); ok {
		return x.DcClusterGroup
	}
	return nil
}

func (m *GlobalSpecType) GetDcClusterGroupInside() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetDcClusterGroupChoice().(*GlobalSpecType_DcClusterGroupInside); ok {
		return x.DcClusterGroupInside
	}
	return nil
}

func (m *GlobalSpecType) GetDisableGpu() *ves_io_schema4.Empty {
	if x, ok := m.GetGpuChoice().(*GlobalSpecType_DisableGpu); ok {
		return x.DisableGpu
	}
	return nil
}

func (m *GlobalSpecType) GetEnableGpu() *ves_io_schema4.Empty {
	if x, ok := m.GetGpuChoice().(*GlobalSpecType_EnableGpu); ok {
		return x.EnableGpu
	}
	return nil
}

func (m *GlobalSpecType) GetEtcdClusterNetwork() EtcdClusterNetworkType {
	if m != nil {
		return m.EtcdClusterNetwork
	}
	return ETCD_CLUSTER_SITE_LOCAL_NETWORK
}

func (m *GlobalSpecType) GetNoStorageStaticRoutes() *ves_io_schema4.Empty {
	if x, ok := m.GetStorageStaticRoutesChoice().(*GlobalSpecType_NoStorageStaticRoutes); ok {
		return x.NoStorageStaticRoutes
	}
	return nil
}

func (m *GlobalSpecType) GetStorageStaticRoutes() *FleetStorageStaticRoutesListType {
	if x, ok := m.GetStorageStaticRoutesChoice().(*GlobalSpecType_StorageStaticRoutes); ok {
		return x.StorageStaticRoutes
	}
	return nil
}

func (m *GlobalSpecType) GetEnableDefaultFleetConfigDownload() bool {
	if m != nil {
		return m.EnableDefaultFleetConfigDownload
	}
	return false
}

func (m *GlobalSpecType) GetFleetType() FleetType {
	if m != nil {
		return m.FleetType
	}
	return MULTIPLE_SITE
}

func (m *GlobalSpecType) GetSingleSite() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.SingleSite
	}
	return nil
}

func (m *GlobalSpecType) GetLogsStreamingDisabled() *ves_io_schema4.Empty {
	if x, ok := m.GetLogsReceiverChoice().(*GlobalSpecType_LogsStreamingDisabled); ok {
		return x.LogsStreamingDisabled
	}
	return nil
}

func (m *GlobalSpecType) GetLogReceiver() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetLogsReceiverChoice().(*GlobalSpecType_LogReceiver); ok {
		return x.LogReceiver
	}
	return nil
}

func (m *GlobalSpecType) GetDenyAllUsb() *ves_io_schema4.Empty {
	if x, ok := m.GetUsbPolicyChoice().(*GlobalSpecType_DenyAllUsb); ok {
		return x.DenyAllUsb
	}
	return nil
}

func (m *GlobalSpecType) GetAllowAllUsb() *ves_io_schema4.Empty {
	if x, ok := m.GetUsbPolicyChoice().(*GlobalSpecType_AllowAllUsb); ok {
		return x.AllowAllUsb
	}
	return nil
}

func (m *GlobalSpecType) GetUsbPolicy() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetUsbPolicyChoice().(*GlobalSpecType_UsbPolicy); ok {
		return x.UsbPolicy
	}
	return nil
}

func (m *GlobalSpecType) GetK8SCluster() *ves_io_schema_views.ObjectRefType {
	if m != nil {
		return m.K8SCluster
	}
	return nil
}

func (m *GlobalSpecType) GetLocalControlPlane() *LocalControlPlaneType {
	if m != nil {
		return m.LocalControlPlane
	}
	return nil
}

func (m *GlobalSpecType) GetViewInternal() *ves_io_schema_views.ObjectRefType {
	if m != nil {
		return m.ViewInternal
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GlobalSpecType_OneofMarshaler, _GlobalSpecType_OneofUnmarshaler, _GlobalSpecType_OneofSizer, []interface{}{
		(*GlobalSpecType_InterfaceList)(nil),
		(*GlobalSpecType_DefaultInterfaces)(nil),
		(*GlobalSpecType_LegacyDevices)(nil),
		(*GlobalSpecType_NoBondDevices)(nil),
		(*GlobalSpecType_BondDeviceList)(nil),
		(*GlobalSpecType_NoStorageInterfaces)(nil),
		(*GlobalSpecType_StorageInterfaceList)(nil),
		(*GlobalSpecType_NoStorageDevice)(nil),
		(*GlobalSpecType_StorageDeviceList)(nil),
		(*GlobalSpecType_DefaultStorageClass)(nil),
		(*GlobalSpecType_StorageClassList)(nil),
		(*GlobalSpecType_NoDcClusterGroup)(nil),
		(*GlobalSpecType_DcClusterGroup)(nil),
		(*GlobalSpecType_DcClusterGroupInside)(nil),
		(*GlobalSpecType_DisableGpu)(nil),
		(*GlobalSpecType_EnableGpu)(nil),
		(*GlobalSpecType_NoStorageStaticRoutes)(nil),
		(*GlobalSpecType_StorageStaticRoutes)(nil),
		(*GlobalSpecType_LogsStreamingDisabled)(nil),
		(*GlobalSpecType_LogReceiver)(nil),
		(*GlobalSpecType_DenyAllUsb)(nil),
		(*GlobalSpecType_AllowAllUsb)(nil),
		(*GlobalSpecType_UsbPolicy)(nil),
	}
}

func _GlobalSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GlobalSpecType)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *GlobalSpecType_InterfaceList:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InterfaceList); err != nil {
			return err
		}
	case *GlobalSpecType_DefaultInterfaces:
		_ = b.EncodeVarint(39<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DefaultInterfaces); err != nil {
			return err
		}
	case *GlobalSpecType_LegacyDevices:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LegacyDevices); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.InterfaceChoice has unexpected type %T", x)
	}
	// bond_choice
	switch x := m.BondChoice.(type) {
	case *GlobalSpecType_NoBondDevices:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoBondDevices); err != nil {
			return err
		}
	case *GlobalSpecType_BondDeviceList:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BondDeviceList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.BondChoice has unexpected type %T", x)
	}
	// storage_interface_choice
	switch x := m.StorageInterfaceChoice.(type) {
	case *GlobalSpecType_NoStorageInterfaces:
		_ = b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoStorageInterfaces); err != nil {
			return err
		}
	case *GlobalSpecType_StorageInterfaceList:
		_ = b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageInterfaceList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.StorageInterfaceChoice has unexpected type %T", x)
	}
	// storage_device_choice
	switch x := m.StorageDeviceChoice.(type) {
	case *GlobalSpecType_NoStorageDevice:
		_ = b.EncodeVarint(22<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoStorageDevice); err != nil {
			return err
		}
	case *GlobalSpecType_StorageDeviceList:
		_ = b.EncodeVarint(23<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageDeviceList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.StorageDeviceChoice has unexpected type %T", x)
	}
	// storage_class_choice
	switch x := m.StorageClassChoice.(type) {
	case *GlobalSpecType_DefaultStorageClass:
		_ = b.EncodeVarint(25<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DefaultStorageClass); err != nil {
			return err
		}
	case *GlobalSpecType_StorageClassList:
		_ = b.EncodeVarint(26<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageClassList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.StorageClassChoice has unexpected type %T", x)
	}
	// dc_cluster_group_choice
	switch x := m.DcClusterGroupChoice.(type) {
	case *GlobalSpecType_NoDcClusterGroup:
		_ = b.EncodeVarint(28<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoDcClusterGroup); err != nil {
			return err
		}
	case *GlobalSpecType_DcClusterGroup:
		_ = b.EncodeVarint(29<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DcClusterGroup); err != nil {
			return err
		}
	case *GlobalSpecType_DcClusterGroupInside:
		_ = b.EncodeVarint(38<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DcClusterGroupInside); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.DcClusterGroupChoice has unexpected type %T", x)
	}
	// gpu_choice
	switch x := m.GpuChoice.(type) {
	case *GlobalSpecType_DisableGpu:
		_ = b.EncodeVarint(31<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DisableGpu); err != nil {
			return err
		}
	case *GlobalSpecType_EnableGpu:
		_ = b.EncodeVarint(32<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EnableGpu); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.GpuChoice has unexpected type %T", x)
	}
	// storage_static_routes_choice
	switch x := m.StorageStaticRoutesChoice.(type) {
	case *GlobalSpecType_NoStorageStaticRoutes:
		_ = b.EncodeVarint(35<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoStorageStaticRoutes); err != nil {
			return err
		}
	case *GlobalSpecType_StorageStaticRoutes:
		_ = b.EncodeVarint(36<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageStaticRoutes); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.StorageStaticRoutesChoice has unexpected type %T", x)
	}
	// logs_receiver_choice
	switch x := m.LogsReceiverChoice.(type) {
	case *GlobalSpecType_LogsStreamingDisabled:
		_ = b.EncodeVarint(44<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogsStreamingDisabled); err != nil {
			return err
		}
	case *GlobalSpecType_LogReceiver:
		_ = b.EncodeVarint(45<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogReceiver); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.LogsReceiverChoice has unexpected type %T", x)
	}
	// usb_policy_choice
	switch x := m.UsbPolicyChoice.(type) {
	case *GlobalSpecType_DenyAllUsb:
		_ = b.EncodeVarint(47<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DenyAllUsb); err != nil {
			return err
		}
	case *GlobalSpecType_AllowAllUsb:
		_ = b.EncodeVarint(48<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AllowAllUsb); err != nil {
			return err
		}
	case *GlobalSpecType_UsbPolicy:
		_ = b.EncodeVarint(49<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UsbPolicy); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GlobalSpecType.UsbPolicyChoice has unexpected type %T", x)
	}
	return nil
}

func _GlobalSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GlobalSpecType)
	switch tag {
	case 10: // interface_choice.interface_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetInterfaceListType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &GlobalSpecType_InterfaceList{msg}
		return true, err
	case 39: // interface_choice.default_interfaces
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &GlobalSpecType_DefaultInterfaces{msg}
		return true, err
	case 11: // interface_choice.legacy_devices
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &GlobalSpecType_LegacyDevices{msg}
		return true, err
	case 16: // bond_choice.no_bond_devices
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.BondChoice = &GlobalSpecType_NoBondDevices{msg}
		return true, err
	case 17: // bond_choice.bond_device_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetBondDevicesListType)
		err := b.DecodeMessage(msg)
		m.BondChoice = &GlobalSpecType_BondDeviceList{msg}
		return true, err
	case 19: // storage_interface_choice.no_storage_interfaces
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.StorageInterfaceChoice = &GlobalSpecType_NoStorageInterfaces{msg}
		return true, err
	case 20: // storage_interface_choice.storage_interface_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetInterfaceListType)
		err := b.DecodeMessage(msg)
		m.StorageInterfaceChoice = &GlobalSpecType_StorageInterfaceList{msg}
		return true, err
	case 22: // storage_device_choice.no_storage_device
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.StorageDeviceChoice = &GlobalSpecType_NoStorageDevice{msg}
		return true, err
	case 23: // storage_device_choice.storage_device_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetStorageDeviceListType)
		err := b.DecodeMessage(msg)
		m.StorageDeviceChoice = &GlobalSpecType_StorageDeviceList{msg}
		return true, err
	case 25: // storage_class_choice.default_storage_class
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.StorageClassChoice = &GlobalSpecType_DefaultStorageClass{msg}
		return true, err
	case 26: // storage_class_choice.storage_class_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetStorageClassListType)
		err := b.DecodeMessage(msg)
		m.StorageClassChoice = &GlobalSpecType_StorageClassList{msg}
		return true, err
	case 28: // dc_cluster_group_choice.no_dc_cluster_group
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.DcClusterGroupChoice = &GlobalSpecType_NoDcClusterGroup{msg}
		return true, err
	case 29: // dc_cluster_group_choice.dc_cluster_group
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.DcClusterGroupChoice = &GlobalSpecType_DcClusterGroup{msg}
		return true, err
	case 38: // dc_cluster_group_choice.dc_cluster_group_inside
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.DcClusterGroupChoice = &GlobalSpecType_DcClusterGroupInside{msg}
		return true, err
	case 31: // gpu_choice.disable_gpu
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.GpuChoice = &GlobalSpecType_DisableGpu{msg}
		return true, err
	case 32: // gpu_choice.enable_gpu
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.GpuChoice = &GlobalSpecType_EnableGpu{msg}
		return true, err
	case 35: // storage_static_routes_choice.no_storage_static_routes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.StorageStaticRoutesChoice = &GlobalSpecType_NoStorageStaticRoutes{msg}
		return true, err
	case 36: // storage_static_routes_choice.storage_static_routes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetStorageStaticRoutesListType)
		err := b.DecodeMessage(msg)
		m.StorageStaticRoutesChoice = &GlobalSpecType_StorageStaticRoutes{msg}
		return true, err
	case 44: // logs_receiver_choice.logs_streaming_disabled
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.LogsReceiverChoice = &GlobalSpecType_LogsStreamingDisabled{msg}
		return true, err
	case 45: // logs_receiver_choice.log_receiver
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.LogsReceiverChoice = &GlobalSpecType_LogReceiver{msg}
		return true, err
	case 47: // usb_policy_choice.deny_all_usb
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.UsbPolicyChoice = &GlobalSpecType_DenyAllUsb{msg}
		return true, err
	case 48: // usb_policy_choice.allow_all_usb
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.UsbPolicyChoice = &GlobalSpecType_AllowAllUsb{msg}
		return true, err
	case 49: // usb_policy_choice.usb_policy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.UsbPolicyChoice = &GlobalSpecType_UsbPolicy{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GlobalSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GlobalSpecType)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *GlobalSpecType_InterfaceList:
		s := proto.Size(x.InterfaceList)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_DefaultInterfaces:
		s := proto.Size(x.DefaultInterfaces)
		n += proto.SizeVarint(39<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_LegacyDevices:
		s := proto.Size(x.LegacyDevices)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// bond_choice
	switch x := m.BondChoice.(type) {
	case *GlobalSpecType_NoBondDevices:
		s := proto.Size(x.NoBondDevices)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_BondDeviceList:
		s := proto.Size(x.BondDeviceList)
		n += proto.SizeVarint(17<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// storage_interface_choice
	switch x := m.StorageInterfaceChoice.(type) {
	case *GlobalSpecType_NoStorageInterfaces:
		s := proto.Size(x.NoStorageInterfaces)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_StorageInterfaceList:
		s := proto.Size(x.StorageInterfaceList)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// storage_device_choice
	switch x := m.StorageDeviceChoice.(type) {
	case *GlobalSpecType_NoStorageDevice:
		s := proto.Size(x.NoStorageDevice)
		n += proto.SizeVarint(22<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_StorageDeviceList:
		s := proto.Size(x.StorageDeviceList)
		n += proto.SizeVarint(23<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// storage_class_choice
	switch x := m.StorageClassChoice.(type) {
	case *GlobalSpecType_DefaultStorageClass:
		s := proto.Size(x.DefaultStorageClass)
		n += proto.SizeVarint(25<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_StorageClassList:
		s := proto.Size(x.StorageClassList)
		n += proto.SizeVarint(26<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// dc_cluster_group_choice
	switch x := m.DcClusterGroupChoice.(type) {
	case *GlobalSpecType_NoDcClusterGroup:
		s := proto.Size(x.NoDcClusterGroup)
		n += proto.SizeVarint(28<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_DcClusterGroup:
		s := proto.Size(x.DcClusterGroup)
		n += proto.SizeVarint(29<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_DcClusterGroupInside:
		s := proto.Size(x.DcClusterGroupInside)
		n += proto.SizeVarint(38<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// gpu_choice
	switch x := m.GpuChoice.(type) {
	case *GlobalSpecType_DisableGpu:
		s := proto.Size(x.DisableGpu)
		n += proto.SizeVarint(31<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_EnableGpu:
		s := proto.Size(x.EnableGpu)
		n += proto.SizeVarint(32<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// storage_static_routes_choice
	switch x := m.StorageStaticRoutesChoice.(type) {
	case *GlobalSpecType_NoStorageStaticRoutes:
		s := proto.Size(x.NoStorageStaticRoutes)
		n += proto.SizeVarint(35<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_StorageStaticRoutes:
		s := proto.Size(x.StorageStaticRoutes)
		n += proto.SizeVarint(36<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// logs_receiver_choice
	switch x := m.LogsReceiverChoice.(type) {
	case *GlobalSpecType_LogsStreamingDisabled:
		s := proto.Size(x.LogsStreamingDisabled)
		n += proto.SizeVarint(44<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_LogReceiver:
		s := proto.Size(x.LogReceiver)
		n += proto.SizeVarint(45<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// usb_policy_choice
	switch x := m.UsbPolicyChoice.(type) {
	case *GlobalSpecType_DenyAllUsb:
		s := proto.Size(x.DenyAllUsb)
		n += proto.SizeVarint(47<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_AllowAllUsb:
		s := proto.Size(x.AllowAllUsb)
		n += proto.SizeVarint(48<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GlobalSpecType_UsbPolicy:
		s := proto.Size(x.UsbPolicy)
		n += proto.SizeVarint(49<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Create Fleet
//
// x-displayName: "Create Fleet"
// Create fleet will create a fleet object in 'system' namespace of the user
type CreateSpecType struct {
	FleetLabel              string                          `protobuf:"bytes,1,opt,name=fleet_label,json=fleetLabel,proto3" json:"fleet_label,omitempty"`
	VolterraSoftwareVersion string                          `protobuf:"bytes,2,opt,name=volterra_software_version,json=volterraSoftwareVersion,proto3" json:"volterra_software_version,omitempty"`
	NetworkConnectors       []*ves_io_schema4.ObjectRefType `protobuf:"bytes,4,rep,name=network_connectors,json=networkConnectors" json:"network_connectors,omitempty"`
	NetworkFirewall         []*ves_io_schema4.ObjectRefType `protobuf:"bytes,5,rep,name=network_firewall,json=networkFirewall" json:"network_firewall,omitempty"`
	OperatingSystemVersion  string                          `protobuf:"bytes,6,opt,name=operating_system_version,json=operatingSystemVersion,proto3" json:"operating_system_version,omitempty"`
	OutsideVirtualNetwork   []*ves_io_schema4.ObjectRefType `protobuf:"bytes,7,rep,name=outside_virtual_network,json=outsideVirtualNetwork" json:"outside_virtual_network,omitempty"`
	InsideVirtualNetwork    []*ves_io_schema4.ObjectRefType `protobuf:"bytes,8,rep,name=inside_virtual_network,json=insideVirtualNetwork" json:"inside_virtual_network,omitempty"`
	// Select Interface Config
	//
	// x-displayName: "Select Interface Config"
	// x-required
	// Select how interfaces are configured for this fleet
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*CreateSpecType_InterfaceList
	//	*CreateSpecType_DefaultConfig
	//	*CreateSpecType_DeviceList
	InterfaceChoice isCreateSpecType_InterfaceChoice `protobuf_oneof:"interface_choice"`
	// Types that are valid to be assigned to BondChoice:
	//	*CreateSpecType_NoBondDevices
	//	*CreateSpecType_BondDeviceList
	BondChoice isCreateSpecType_BondChoice `protobuf_oneof:"bond_choice"`
	// Types that are valid to be assigned to StorageInterfaceChoice:
	//	*CreateSpecType_NoStorageInterfaces
	//	*CreateSpecType_StorageInterfaceList
	StorageInterfaceChoice isCreateSpecType_StorageInterfaceChoice `protobuf_oneof:"storage_interface_choice"`
	// Types that are valid to be assigned to StorageDeviceChoice:
	//	*CreateSpecType_NoStorageDevice
	//	*CreateSpecType_StorageDeviceList
	StorageDeviceChoice isCreateSpecType_StorageDeviceChoice `protobuf_oneof:"storage_device_choice"`
	// Types that are valid to be assigned to StorageClassChoice:
	//	*CreateSpecType_DefaultStorageClass
	//	*CreateSpecType_StorageClassList
	StorageClassChoice isCreateSpecType_StorageClassChoice `protobuf_oneof:"storage_class_choice"`
	// Types that are valid to be assigned to DcClusterGroupChoice:
	//	*CreateSpecType_NoDcClusterGroup
	//	*CreateSpecType_DcClusterGroup
	//	*CreateSpecType_DcClusterGroupInside
	DcClusterGroupChoice isCreateSpecType_DcClusterGroupChoice `protobuf_oneof:"dc_cluster_group_choice"`
	// Types that are valid to be assigned to GpuChoice:
	//	*CreateSpecType_DisableGpu
	//	*CreateSpecType_EnableGpu
	GpuChoice isCreateSpecType_GpuChoice `protobuf_oneof:"gpu_choice"`
	// Types that are valid to be assigned to StorageStaticRoutesChoice:
	//	*CreateSpecType_NoStorageStaticRoutes
	//	*CreateSpecType_StorageStaticRoutes
	StorageStaticRoutesChoice        isCreateSpecType_StorageStaticRoutesChoice `protobuf_oneof:"storage_static_routes_choice"`
	EnableDefaultFleetConfigDownload bool                                       `protobuf:"varint,37,opt,name=enable_default_fleet_config_download,json=enableDefaultFleetConfigDownload,proto3" json:"enable_default_fleet_config_download,omitempty"`
	// Types that are valid to be assigned to LogsReceiverChoice:
	//	*CreateSpecType_LogsStreamingDisabled
	//	*CreateSpecType_LogReceiver
	LogsReceiverChoice isCreateSpecType_LogsReceiverChoice `protobuf_oneof:"logs_receiver_choice"`
	// Types that are valid to be assigned to UsbPolicyChoice:
	//	*CreateSpecType_DenyAllUsb
	//	*CreateSpecType_AllowAllUsb
	//	*CreateSpecType_UsbPolicy
	UsbPolicyChoice isCreateSpecType_UsbPolicyChoice `protobuf_oneof:"usb_policy_choice"`
}

func (m *CreateSpecType) Reset()                    { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage()               {}
func (*CreateSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{37} }

type isCreateSpecType_InterfaceChoice interface {
	isCreateSpecType_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_BondChoice interface {
	isCreateSpecType_BondChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_StorageInterfaceChoice interface {
	isCreateSpecType_StorageInterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_StorageDeviceChoice interface {
	isCreateSpecType_StorageDeviceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_StorageClassChoice interface {
	isCreateSpecType_StorageClassChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_DcClusterGroupChoice interface {
	isCreateSpecType_DcClusterGroupChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_GpuChoice interface {
	isCreateSpecType_GpuChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_StorageStaticRoutesChoice interface {
	isCreateSpecType_StorageStaticRoutesChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_LogsReceiverChoice interface {
	isCreateSpecType_LogsReceiverChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_UsbPolicyChoice interface {
	isCreateSpecType_UsbPolicyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_InterfaceList struct {
	InterfaceList *FleetInterfaceListType `protobuf:"bytes,13,opt,name=interface_list,json=interfaceList,oneof"`
}
type CreateSpecType_DefaultConfig struct {
	DefaultConfig *ves_io_schema4.Empty `protobuf:"bytes,40,opt,name=default_config,json=defaultConfig,oneof"`
}
type CreateSpecType_DeviceList struct {
	DeviceList *FleetDeviceListType `protobuf:"bytes,14,opt,name=device_list,json=deviceList,oneof"`
}
type CreateSpecType_NoBondDevices struct {
	NoBondDevices *ves_io_schema4.Empty `protobuf:"bytes,16,opt,name=no_bond_devices,json=noBondDevices,oneof"`
}
type CreateSpecType_BondDeviceList struct {
	BondDeviceList *FleetBondDevicesListType `protobuf:"bytes,17,opt,name=bond_device_list,json=bondDeviceList,oneof"`
}
type CreateSpecType_NoStorageInterfaces struct {
	NoStorageInterfaces *ves_io_schema4.Empty `protobuf:"bytes,19,opt,name=no_storage_interfaces,json=noStorageInterfaces,oneof"`
}
type CreateSpecType_StorageInterfaceList struct {
	StorageInterfaceList *FleetInterfaceListType `protobuf:"bytes,20,opt,name=storage_interface_list,json=storageInterfaceList,oneof"`
}
type CreateSpecType_NoStorageDevice struct {
	NoStorageDevice *ves_io_schema4.Empty `protobuf:"bytes,22,opt,name=no_storage_device,json=noStorageDevice,oneof"`
}
type CreateSpecType_StorageDeviceList struct {
	StorageDeviceList *FleetStorageDeviceListType `protobuf:"bytes,23,opt,name=storage_device_list,json=storageDeviceList,oneof"`
}
type CreateSpecType_DefaultStorageClass struct {
	DefaultStorageClass *ves_io_schema4.Empty `protobuf:"bytes,25,opt,name=default_storage_class,json=defaultStorageClass,oneof"`
}
type CreateSpecType_StorageClassList struct {
	StorageClassList *FleetStorageClassListType `protobuf:"bytes,26,opt,name=storage_class_list,json=storageClassList,oneof"`
}
type CreateSpecType_NoDcClusterGroup struct {
	NoDcClusterGroup *ves_io_schema4.Empty `protobuf:"bytes,28,opt,name=no_dc_cluster_group,json=noDcClusterGroup,oneof"`
}
type CreateSpecType_DcClusterGroup struct {
	DcClusterGroup *ves_io_schema_views.ObjectRefType `protobuf:"bytes,29,opt,name=dc_cluster_group,json=dcClusterGroup,oneof"`
}
type CreateSpecType_DcClusterGroupInside struct {
	DcClusterGroupInside *ves_io_schema_views.ObjectRefType `protobuf:"bytes,38,opt,name=dc_cluster_group_inside,json=dcClusterGroupInside,oneof"`
}
type CreateSpecType_DisableGpu struct {
	DisableGpu *ves_io_schema4.Empty `protobuf:"bytes,31,opt,name=disable_gpu,json=disableGpu,oneof"`
}
type CreateSpecType_EnableGpu struct {
	EnableGpu *ves_io_schema4.Empty `protobuf:"bytes,32,opt,name=enable_gpu,json=enableGpu,oneof"`
}
type CreateSpecType_NoStorageStaticRoutes struct {
	NoStorageStaticRoutes *ves_io_schema4.Empty `protobuf:"bytes,35,opt,name=no_storage_static_routes,json=noStorageStaticRoutes,oneof"`
}
type CreateSpecType_StorageStaticRoutes struct {
	StorageStaticRoutes *FleetStorageStaticRoutesListType `protobuf:"bytes,36,opt,name=storage_static_routes,json=storageStaticRoutes,oneof"`
}
type CreateSpecType_LogsStreamingDisabled struct {
	LogsStreamingDisabled *ves_io_schema4.Empty `protobuf:"bytes,44,opt,name=logs_streaming_disabled,json=logsStreamingDisabled,oneof"`
}
type CreateSpecType_LogReceiver struct {
	LogReceiver *ves_io_schema_views.ObjectRefType `protobuf:"bytes,45,opt,name=log_receiver,json=logReceiver,oneof"`
}
type CreateSpecType_DenyAllUsb struct {
	DenyAllUsb *ves_io_schema4.Empty `protobuf:"bytes,47,opt,name=deny_all_usb,json=denyAllUsb,oneof"`
}
type CreateSpecType_AllowAllUsb struct {
	AllowAllUsb *ves_io_schema4.Empty `protobuf:"bytes,48,opt,name=allow_all_usb,json=allowAllUsb,oneof"`
}
type CreateSpecType_UsbPolicy struct {
	UsbPolicy *ves_io_schema_views.ObjectRefType `protobuf:"bytes,49,opt,name=usb_policy,json=usbPolicy,oneof"`
}

func (*CreateSpecType_InterfaceList) isCreateSpecType_InterfaceChoice()                   {}
func (*CreateSpecType_DefaultConfig) isCreateSpecType_InterfaceChoice()                   {}
func (*CreateSpecType_DeviceList) isCreateSpecType_InterfaceChoice()                      {}
func (*CreateSpecType_NoBondDevices) isCreateSpecType_BondChoice()                        {}
func (*CreateSpecType_BondDeviceList) isCreateSpecType_BondChoice()                       {}
func (*CreateSpecType_NoStorageInterfaces) isCreateSpecType_StorageInterfaceChoice()      {}
func (*CreateSpecType_StorageInterfaceList) isCreateSpecType_StorageInterfaceChoice()     {}
func (*CreateSpecType_NoStorageDevice) isCreateSpecType_StorageDeviceChoice()             {}
func (*CreateSpecType_StorageDeviceList) isCreateSpecType_StorageDeviceChoice()           {}
func (*CreateSpecType_DefaultStorageClass) isCreateSpecType_StorageClassChoice()          {}
func (*CreateSpecType_StorageClassList) isCreateSpecType_StorageClassChoice()             {}
func (*CreateSpecType_NoDcClusterGroup) isCreateSpecType_DcClusterGroupChoice()           {}
func (*CreateSpecType_DcClusterGroup) isCreateSpecType_DcClusterGroupChoice()             {}
func (*CreateSpecType_DcClusterGroupInside) isCreateSpecType_DcClusterGroupChoice()       {}
func (*CreateSpecType_DisableGpu) isCreateSpecType_GpuChoice()                            {}
func (*CreateSpecType_EnableGpu) isCreateSpecType_GpuChoice()                             {}
func (*CreateSpecType_NoStorageStaticRoutes) isCreateSpecType_StorageStaticRoutesChoice() {}
func (*CreateSpecType_StorageStaticRoutes) isCreateSpecType_StorageStaticRoutesChoice()   {}
func (*CreateSpecType_LogsStreamingDisabled) isCreateSpecType_LogsReceiverChoice()        {}
func (*CreateSpecType_LogReceiver) isCreateSpecType_LogsReceiverChoice()                  {}
func (*CreateSpecType_DenyAllUsb) isCreateSpecType_UsbPolicyChoice()                      {}
func (*CreateSpecType_AllowAllUsb) isCreateSpecType_UsbPolicyChoice()                     {}
func (*CreateSpecType_UsbPolicy) isCreateSpecType_UsbPolicyChoice()                       {}

func (m *CreateSpecType) GetInterfaceChoice() isCreateSpecType_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}
func (m *CreateSpecType) GetBondChoice() isCreateSpecType_BondChoice {
	if m != nil {
		return m.BondChoice
	}
	return nil
}
func (m *CreateSpecType) GetStorageInterfaceChoice() isCreateSpecType_StorageInterfaceChoice {
	if m != nil {
		return m.StorageInterfaceChoice
	}
	return nil
}
func (m *CreateSpecType) GetStorageDeviceChoice() isCreateSpecType_StorageDeviceChoice {
	if m != nil {
		return m.StorageDeviceChoice
	}
	return nil
}
func (m *CreateSpecType) GetStorageClassChoice() isCreateSpecType_StorageClassChoice {
	if m != nil {
		return m.StorageClassChoice
	}
	return nil
}
func (m *CreateSpecType) GetDcClusterGroupChoice() isCreateSpecType_DcClusterGroupChoice {
	if m != nil {
		return m.DcClusterGroupChoice
	}
	return nil
}
func (m *CreateSpecType) GetGpuChoice() isCreateSpecType_GpuChoice {
	if m != nil {
		return m.GpuChoice
	}
	return nil
}
func (m *CreateSpecType) GetStorageStaticRoutesChoice() isCreateSpecType_StorageStaticRoutesChoice {
	if m != nil {
		return m.StorageStaticRoutesChoice
	}
	return nil
}
func (m *CreateSpecType) GetLogsReceiverChoice() isCreateSpecType_LogsReceiverChoice {
	if m != nil {
		return m.LogsReceiverChoice
	}
	return nil
}
func (m *CreateSpecType) GetUsbPolicyChoice() isCreateSpecType_UsbPolicyChoice {
	if m != nil {
		return m.UsbPolicyChoice
	}
	return nil
}

func (m *CreateSpecType) GetFleetLabel() string {
	if m != nil {
		return m.FleetLabel
	}
	return ""
}

func (m *CreateSpecType) GetVolterraSoftwareVersion() string {
	if m != nil {
		return m.VolterraSoftwareVersion
	}
	return ""
}

func (m *CreateSpecType) GetNetworkConnectors() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.NetworkConnectors
	}
	return nil
}

func (m *CreateSpecType) GetNetworkFirewall() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.NetworkFirewall
	}
	return nil
}

func (m *CreateSpecType) GetOperatingSystemVersion() string {
	if m != nil {
		return m.OperatingSystemVersion
	}
	return ""
}

func (m *CreateSpecType) GetOutsideVirtualNetwork() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.OutsideVirtualNetwork
	}
	return nil
}

func (m *CreateSpecType) GetInsideVirtualNetwork() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.InsideVirtualNetwork
	}
	return nil
}

func (m *CreateSpecType) GetInterfaceList() *FleetInterfaceListType {
	if x, ok := m.GetInterfaceChoice().(*CreateSpecType_InterfaceList); ok {
		return x.InterfaceList
	}
	return nil
}

func (m *CreateSpecType) GetDefaultConfig() *ves_io_schema4.Empty {
	if x, ok := m.GetInterfaceChoice().(*CreateSpecType_DefaultConfig); ok {
		return x.DefaultConfig
	}
	return nil
}

func (m *CreateSpecType) GetDeviceList() *FleetDeviceListType {
	if x, ok := m.GetInterfaceChoice().(*CreateSpecType_DeviceList); ok {
		return x.DeviceList
	}
	return nil
}

func (m *CreateSpecType) GetNoBondDevices() *ves_io_schema4.Empty {
	if x, ok := m.GetBondChoice().(*CreateSpecType_NoBondDevices); ok {
		return x.NoBondDevices
	}
	return nil
}

func (m *CreateSpecType) GetBondDeviceList() *FleetBondDevicesListType {
	if x, ok := m.GetBondChoice().(*CreateSpecType_BondDeviceList); ok {
		return x.BondDeviceList
	}
	return nil
}

func (m *CreateSpecType) GetNoStorageInterfaces() *ves_io_schema4.Empty {
	if x, ok := m.GetStorageInterfaceChoice().(*CreateSpecType_NoStorageInterfaces); ok {
		return x.NoStorageInterfaces
	}
	return nil
}

func (m *CreateSpecType) GetStorageInterfaceList() *FleetInterfaceListType {
	if x, ok := m.GetStorageInterfaceChoice().(*CreateSpecType_StorageInterfaceList); ok {
		return x.StorageInterfaceList
	}
	return nil
}

func (m *CreateSpecType) GetNoStorageDevice() *ves_io_schema4.Empty {
	if x, ok := m.GetStorageDeviceChoice().(*CreateSpecType_NoStorageDevice); ok {
		return x.NoStorageDevice
	}
	return nil
}

func (m *CreateSpecType) GetStorageDeviceList() *FleetStorageDeviceListType {
	if x, ok := m.GetStorageDeviceChoice().(*CreateSpecType_StorageDeviceList); ok {
		return x.StorageDeviceList
	}
	return nil
}

func (m *CreateSpecType) GetDefaultStorageClass() *ves_io_schema4.Empty {
	if x, ok := m.GetStorageClassChoice().(*CreateSpecType_DefaultStorageClass); ok {
		return x.DefaultStorageClass
	}
	return nil
}

func (m *CreateSpecType) GetStorageClassList() *FleetStorageClassListType {
	if x, ok := m.GetStorageClassChoice().(*CreateSpecType_StorageClassList); ok {
		return x.StorageClassList
	}
	return nil
}

func (m *CreateSpecType) GetNoDcClusterGroup() *ves_io_schema4.Empty {
	if x, ok := m.GetDcClusterGroupChoice().(*CreateSpecType_NoDcClusterGroup); ok {
		return x.NoDcClusterGroup
	}
	return nil
}

func (m *CreateSpecType) GetDcClusterGroup() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetDcClusterGroupChoice().(*CreateSpecType_DcClusterGroup); ok {
		return x.DcClusterGroup
	}
	return nil
}

func (m *CreateSpecType) GetDcClusterGroupInside() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetDcClusterGroupChoice().(*CreateSpecType_DcClusterGroupInside); ok {
		return x.DcClusterGroupInside
	}
	return nil
}

func (m *CreateSpecType) GetDisableGpu() *ves_io_schema4.Empty {
	if x, ok := m.GetGpuChoice().(*CreateSpecType_DisableGpu); ok {
		return x.DisableGpu
	}
	return nil
}

func (m *CreateSpecType) GetEnableGpu() *ves_io_schema4.Empty {
	if x, ok := m.GetGpuChoice().(*CreateSpecType_EnableGpu); ok {
		return x.EnableGpu
	}
	return nil
}

func (m *CreateSpecType) GetNoStorageStaticRoutes() *ves_io_schema4.Empty {
	if x, ok := m.GetStorageStaticRoutesChoice().(*CreateSpecType_NoStorageStaticRoutes); ok {
		return x.NoStorageStaticRoutes
	}
	return nil
}

func (m *CreateSpecType) GetStorageStaticRoutes() *FleetStorageStaticRoutesListType {
	if x, ok := m.GetStorageStaticRoutesChoice().(*CreateSpecType_StorageStaticRoutes); ok {
		return x.StorageStaticRoutes
	}
	return nil
}

func (m *CreateSpecType) GetEnableDefaultFleetConfigDownload() bool {
	if m != nil {
		return m.EnableDefaultFleetConfigDownload
	}
	return false
}

func (m *CreateSpecType) GetLogsStreamingDisabled() *ves_io_schema4.Empty {
	if x, ok := m.GetLogsReceiverChoice().(*CreateSpecType_LogsStreamingDisabled); ok {
		return x.LogsStreamingDisabled
	}
	return nil
}

func (m *CreateSpecType) GetLogReceiver() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetLogsReceiverChoice().(*CreateSpecType_LogReceiver); ok {
		return x.LogReceiver
	}
	return nil
}

func (m *CreateSpecType) GetDenyAllUsb() *ves_io_schema4.Empty {
	if x, ok := m.GetUsbPolicyChoice().(*CreateSpecType_DenyAllUsb); ok {
		return x.DenyAllUsb
	}
	return nil
}

func (m *CreateSpecType) GetAllowAllUsb() *ves_io_schema4.Empty {
	if x, ok := m.GetUsbPolicyChoice().(*CreateSpecType_AllowAllUsb); ok {
		return x.AllowAllUsb
	}
	return nil
}

func (m *CreateSpecType) GetUsbPolicy() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetUsbPolicyChoice().(*CreateSpecType_UsbPolicy); ok {
		return x.UsbPolicy
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CreateSpecType_OneofMarshaler, _CreateSpecType_OneofUnmarshaler, _CreateSpecType_OneofSizer, []interface{}{
		(*CreateSpecType_InterfaceList)(nil),
		(*CreateSpecType_DefaultConfig)(nil),
		(*CreateSpecType_DeviceList)(nil),
		(*CreateSpecType_NoBondDevices)(nil),
		(*CreateSpecType_BondDeviceList)(nil),
		(*CreateSpecType_NoStorageInterfaces)(nil),
		(*CreateSpecType_StorageInterfaceList)(nil),
		(*CreateSpecType_NoStorageDevice)(nil),
		(*CreateSpecType_StorageDeviceList)(nil),
		(*CreateSpecType_DefaultStorageClass)(nil),
		(*CreateSpecType_StorageClassList)(nil),
		(*CreateSpecType_NoDcClusterGroup)(nil),
		(*CreateSpecType_DcClusterGroup)(nil),
		(*CreateSpecType_DcClusterGroupInside)(nil),
		(*CreateSpecType_DisableGpu)(nil),
		(*CreateSpecType_EnableGpu)(nil),
		(*CreateSpecType_NoStorageStaticRoutes)(nil),
		(*CreateSpecType_StorageStaticRoutes)(nil),
		(*CreateSpecType_LogsStreamingDisabled)(nil),
		(*CreateSpecType_LogReceiver)(nil),
		(*CreateSpecType_DenyAllUsb)(nil),
		(*CreateSpecType_AllowAllUsb)(nil),
		(*CreateSpecType_UsbPolicy)(nil),
	}
}

func _CreateSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CreateSpecType)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *CreateSpecType_InterfaceList:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InterfaceList); err != nil {
			return err
		}
	case *CreateSpecType_DefaultConfig:
		_ = b.EncodeVarint(40<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DefaultConfig); err != nil {
			return err
		}
	case *CreateSpecType_DeviceList:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DeviceList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.InterfaceChoice has unexpected type %T", x)
	}
	// bond_choice
	switch x := m.BondChoice.(type) {
	case *CreateSpecType_NoBondDevices:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoBondDevices); err != nil {
			return err
		}
	case *CreateSpecType_BondDeviceList:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BondDeviceList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.BondChoice has unexpected type %T", x)
	}
	// storage_interface_choice
	switch x := m.StorageInterfaceChoice.(type) {
	case *CreateSpecType_NoStorageInterfaces:
		_ = b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoStorageInterfaces); err != nil {
			return err
		}
	case *CreateSpecType_StorageInterfaceList:
		_ = b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageInterfaceList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.StorageInterfaceChoice has unexpected type %T", x)
	}
	// storage_device_choice
	switch x := m.StorageDeviceChoice.(type) {
	case *CreateSpecType_NoStorageDevice:
		_ = b.EncodeVarint(22<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoStorageDevice); err != nil {
			return err
		}
	case *CreateSpecType_StorageDeviceList:
		_ = b.EncodeVarint(23<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageDeviceList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.StorageDeviceChoice has unexpected type %T", x)
	}
	// storage_class_choice
	switch x := m.StorageClassChoice.(type) {
	case *CreateSpecType_DefaultStorageClass:
		_ = b.EncodeVarint(25<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DefaultStorageClass); err != nil {
			return err
		}
	case *CreateSpecType_StorageClassList:
		_ = b.EncodeVarint(26<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageClassList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.StorageClassChoice has unexpected type %T", x)
	}
	// dc_cluster_group_choice
	switch x := m.DcClusterGroupChoice.(type) {
	case *CreateSpecType_NoDcClusterGroup:
		_ = b.EncodeVarint(28<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoDcClusterGroup); err != nil {
			return err
		}
	case *CreateSpecType_DcClusterGroup:
		_ = b.EncodeVarint(29<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DcClusterGroup); err != nil {
			return err
		}
	case *CreateSpecType_DcClusterGroupInside:
		_ = b.EncodeVarint(38<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DcClusterGroupInside); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.DcClusterGroupChoice has unexpected type %T", x)
	}
	// gpu_choice
	switch x := m.GpuChoice.(type) {
	case *CreateSpecType_DisableGpu:
		_ = b.EncodeVarint(31<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DisableGpu); err != nil {
			return err
		}
	case *CreateSpecType_EnableGpu:
		_ = b.EncodeVarint(32<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EnableGpu); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.GpuChoice has unexpected type %T", x)
	}
	// storage_static_routes_choice
	switch x := m.StorageStaticRoutesChoice.(type) {
	case *CreateSpecType_NoStorageStaticRoutes:
		_ = b.EncodeVarint(35<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoStorageStaticRoutes); err != nil {
			return err
		}
	case *CreateSpecType_StorageStaticRoutes:
		_ = b.EncodeVarint(36<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageStaticRoutes); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.StorageStaticRoutesChoice has unexpected type %T", x)
	}
	// logs_receiver_choice
	switch x := m.LogsReceiverChoice.(type) {
	case *CreateSpecType_LogsStreamingDisabled:
		_ = b.EncodeVarint(44<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogsStreamingDisabled); err != nil {
			return err
		}
	case *CreateSpecType_LogReceiver:
		_ = b.EncodeVarint(45<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogReceiver); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.LogsReceiverChoice has unexpected type %T", x)
	}
	// usb_policy_choice
	switch x := m.UsbPolicyChoice.(type) {
	case *CreateSpecType_DenyAllUsb:
		_ = b.EncodeVarint(47<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DenyAllUsb); err != nil {
			return err
		}
	case *CreateSpecType_AllowAllUsb:
		_ = b.EncodeVarint(48<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AllowAllUsb); err != nil {
			return err
		}
	case *CreateSpecType_UsbPolicy:
		_ = b.EncodeVarint(49<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UsbPolicy); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateSpecType.UsbPolicyChoice has unexpected type %T", x)
	}
	return nil
}

func _CreateSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CreateSpecType)
	switch tag {
	case 13: // interface_choice.interface_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetInterfaceListType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &CreateSpecType_InterfaceList{msg}
		return true, err
	case 40: // interface_choice.default_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &CreateSpecType_DefaultConfig{msg}
		return true, err
	case 14: // interface_choice.device_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetDeviceListType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &CreateSpecType_DeviceList{msg}
		return true, err
	case 16: // bond_choice.no_bond_devices
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.BondChoice = &CreateSpecType_NoBondDevices{msg}
		return true, err
	case 17: // bond_choice.bond_device_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetBondDevicesListType)
		err := b.DecodeMessage(msg)
		m.BondChoice = &CreateSpecType_BondDeviceList{msg}
		return true, err
	case 19: // storage_interface_choice.no_storage_interfaces
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.StorageInterfaceChoice = &CreateSpecType_NoStorageInterfaces{msg}
		return true, err
	case 20: // storage_interface_choice.storage_interface_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetInterfaceListType)
		err := b.DecodeMessage(msg)
		m.StorageInterfaceChoice = &CreateSpecType_StorageInterfaceList{msg}
		return true, err
	case 22: // storage_device_choice.no_storage_device
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.StorageDeviceChoice = &CreateSpecType_NoStorageDevice{msg}
		return true, err
	case 23: // storage_device_choice.storage_device_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetStorageDeviceListType)
		err := b.DecodeMessage(msg)
		m.StorageDeviceChoice = &CreateSpecType_StorageDeviceList{msg}
		return true, err
	case 25: // storage_class_choice.default_storage_class
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.StorageClassChoice = &CreateSpecType_DefaultStorageClass{msg}
		return true, err
	case 26: // storage_class_choice.storage_class_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetStorageClassListType)
		err := b.DecodeMessage(msg)
		m.StorageClassChoice = &CreateSpecType_StorageClassList{msg}
		return true, err
	case 28: // dc_cluster_group_choice.no_dc_cluster_group
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.DcClusterGroupChoice = &CreateSpecType_NoDcClusterGroup{msg}
		return true, err
	case 29: // dc_cluster_group_choice.dc_cluster_group
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.DcClusterGroupChoice = &CreateSpecType_DcClusterGroup{msg}
		return true, err
	case 38: // dc_cluster_group_choice.dc_cluster_group_inside
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.DcClusterGroupChoice = &CreateSpecType_DcClusterGroupInside{msg}
		return true, err
	case 31: // gpu_choice.disable_gpu
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.GpuChoice = &CreateSpecType_DisableGpu{msg}
		return true, err
	case 32: // gpu_choice.enable_gpu
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.GpuChoice = &CreateSpecType_EnableGpu{msg}
		return true, err
	case 35: // storage_static_routes_choice.no_storage_static_routes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.StorageStaticRoutesChoice = &CreateSpecType_NoStorageStaticRoutes{msg}
		return true, err
	case 36: // storage_static_routes_choice.storage_static_routes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetStorageStaticRoutesListType)
		err := b.DecodeMessage(msg)
		m.StorageStaticRoutesChoice = &CreateSpecType_StorageStaticRoutes{msg}
		return true, err
	case 44: // logs_receiver_choice.logs_streaming_disabled
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.LogsReceiverChoice = &CreateSpecType_LogsStreamingDisabled{msg}
		return true, err
	case 45: // logs_receiver_choice.log_receiver
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.LogsReceiverChoice = &CreateSpecType_LogReceiver{msg}
		return true, err
	case 47: // usb_policy_choice.deny_all_usb
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.UsbPolicyChoice = &CreateSpecType_DenyAllUsb{msg}
		return true, err
	case 48: // usb_policy_choice.allow_all_usb
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.UsbPolicyChoice = &CreateSpecType_AllowAllUsb{msg}
		return true, err
	case 49: // usb_policy_choice.usb_policy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.UsbPolicyChoice = &CreateSpecType_UsbPolicy{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CreateSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CreateSpecType)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *CreateSpecType_InterfaceList:
		s := proto.Size(x.InterfaceList)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_DefaultConfig:
		s := proto.Size(x.DefaultConfig)
		n += proto.SizeVarint(40<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_DeviceList:
		s := proto.Size(x.DeviceList)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// bond_choice
	switch x := m.BondChoice.(type) {
	case *CreateSpecType_NoBondDevices:
		s := proto.Size(x.NoBondDevices)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_BondDeviceList:
		s := proto.Size(x.BondDeviceList)
		n += proto.SizeVarint(17<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// storage_interface_choice
	switch x := m.StorageInterfaceChoice.(type) {
	case *CreateSpecType_NoStorageInterfaces:
		s := proto.Size(x.NoStorageInterfaces)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_StorageInterfaceList:
		s := proto.Size(x.StorageInterfaceList)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// storage_device_choice
	switch x := m.StorageDeviceChoice.(type) {
	case *CreateSpecType_NoStorageDevice:
		s := proto.Size(x.NoStorageDevice)
		n += proto.SizeVarint(22<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_StorageDeviceList:
		s := proto.Size(x.StorageDeviceList)
		n += proto.SizeVarint(23<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// storage_class_choice
	switch x := m.StorageClassChoice.(type) {
	case *CreateSpecType_DefaultStorageClass:
		s := proto.Size(x.DefaultStorageClass)
		n += proto.SizeVarint(25<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_StorageClassList:
		s := proto.Size(x.StorageClassList)
		n += proto.SizeVarint(26<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// dc_cluster_group_choice
	switch x := m.DcClusterGroupChoice.(type) {
	case *CreateSpecType_NoDcClusterGroup:
		s := proto.Size(x.NoDcClusterGroup)
		n += proto.SizeVarint(28<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_DcClusterGroup:
		s := proto.Size(x.DcClusterGroup)
		n += proto.SizeVarint(29<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_DcClusterGroupInside:
		s := proto.Size(x.DcClusterGroupInside)
		n += proto.SizeVarint(38<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// gpu_choice
	switch x := m.GpuChoice.(type) {
	case *CreateSpecType_DisableGpu:
		s := proto.Size(x.DisableGpu)
		n += proto.SizeVarint(31<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_EnableGpu:
		s := proto.Size(x.EnableGpu)
		n += proto.SizeVarint(32<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// storage_static_routes_choice
	switch x := m.StorageStaticRoutesChoice.(type) {
	case *CreateSpecType_NoStorageStaticRoutes:
		s := proto.Size(x.NoStorageStaticRoutes)
		n += proto.SizeVarint(35<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_StorageStaticRoutes:
		s := proto.Size(x.StorageStaticRoutes)
		n += proto.SizeVarint(36<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// logs_receiver_choice
	switch x := m.LogsReceiverChoice.(type) {
	case *CreateSpecType_LogsStreamingDisabled:
		s := proto.Size(x.LogsStreamingDisabled)
		n += proto.SizeVarint(44<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_LogReceiver:
		s := proto.Size(x.LogReceiver)
		n += proto.SizeVarint(45<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// usb_policy_choice
	switch x := m.UsbPolicyChoice.(type) {
	case *CreateSpecType_DenyAllUsb:
		s := proto.Size(x.DenyAllUsb)
		n += proto.SizeVarint(47<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_AllowAllUsb:
		s := proto.Size(x.AllowAllUsb)
		n += proto.SizeVarint(48<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateSpecType_UsbPolicy:
		s := proto.Size(x.UsbPolicy)
		n += proto.SizeVarint(49<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Replace fleet
//
// x-displayName: "Replace Fleet"
// Replace fleet will replace the contents of given fleet object
type ReplaceSpecType struct {
	VolterraSoftwareVersion string                          `protobuf:"bytes,2,opt,name=volterra_software_version,json=volterraSoftwareVersion,proto3" json:"volterra_software_version,omitempty"`
	NetworkConnectors       []*ves_io_schema4.ObjectRefType `protobuf:"bytes,4,rep,name=network_connectors,json=networkConnectors" json:"network_connectors,omitempty"`
	NetworkFirewall         []*ves_io_schema4.ObjectRefType `protobuf:"bytes,5,rep,name=network_firewall,json=networkFirewall" json:"network_firewall,omitempty"`
	OperatingSystemVersion  string                          `protobuf:"bytes,6,opt,name=operating_system_version,json=operatingSystemVersion,proto3" json:"operating_system_version,omitempty"`
	OutsideVirtualNetwork   []*ves_io_schema4.ObjectRefType `protobuf:"bytes,7,rep,name=outside_virtual_network,json=outsideVirtualNetwork" json:"outside_virtual_network,omitempty"`
	InsideVirtualNetwork    []*ves_io_schema4.ObjectRefType `protobuf:"bytes,8,rep,name=inside_virtual_network,json=insideVirtualNetwork" json:"inside_virtual_network,omitempty"`
	// Select Interface Config
	//
	// x-displayName: "Select Network Interface Config"
	// x-required
	// Select how network interfaces are configured for this fleet
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*ReplaceSpecType_InterfaceList
	//	*ReplaceSpecType_DefaultConfig
	//	*ReplaceSpecType_DeviceList
	InterfaceChoice isReplaceSpecType_InterfaceChoice `protobuf_oneof:"interface_choice"`
	// Types that are valid to be assigned to BondChoice:
	//	*ReplaceSpecType_NoBondDevices
	//	*ReplaceSpecType_BondDeviceList
	BondChoice isReplaceSpecType_BondChoice `protobuf_oneof:"bond_choice"`
	// Types that are valid to be assigned to StorageInterfaceChoice:
	//	*ReplaceSpecType_NoStorageInterfaces
	//	*ReplaceSpecType_StorageInterfaceList
	StorageInterfaceChoice isReplaceSpecType_StorageInterfaceChoice `protobuf_oneof:"storage_interface_choice"`
	// Types that are valid to be assigned to StorageDeviceChoice:
	//	*ReplaceSpecType_NoStorageDevice
	//	*ReplaceSpecType_StorageDeviceList
	StorageDeviceChoice isReplaceSpecType_StorageDeviceChoice `protobuf_oneof:"storage_device_choice"`
	// Types that are valid to be assigned to StorageClassChoice:
	//	*ReplaceSpecType_DefaultStorageClass
	//	*ReplaceSpecType_StorageClassList
	StorageClassChoice isReplaceSpecType_StorageClassChoice `protobuf_oneof:"storage_class_choice"`
	// Types that are valid to be assigned to DcClusterGroupChoice:
	//	*ReplaceSpecType_NoDcClusterGroup
	//	*ReplaceSpecType_DcClusterGroup
	//	*ReplaceSpecType_DcClusterGroupInside
	DcClusterGroupChoice isReplaceSpecType_DcClusterGroupChoice `protobuf_oneof:"dc_cluster_group_choice"`
	// Types that are valid to be assigned to GpuChoice:
	//	*ReplaceSpecType_DisableGpu
	//	*ReplaceSpecType_EnableGpu
	GpuChoice isReplaceSpecType_GpuChoice `protobuf_oneof:"gpu_choice"`
	// Types that are valid to be assigned to StorageStaticRoutesChoice:
	//	*ReplaceSpecType_NoStorageStaticRoutes
	//	*ReplaceSpecType_StorageStaticRoutes
	StorageStaticRoutesChoice        isReplaceSpecType_StorageStaticRoutesChoice `protobuf_oneof:"storage_static_routes_choice"`
	EnableDefaultFleetConfigDownload bool                                        `protobuf:"varint,37,opt,name=enable_default_fleet_config_download,json=enableDefaultFleetConfigDownload,proto3" json:"enable_default_fleet_config_download,omitempty"`
	// Types that are valid to be assigned to LogsReceiverChoice:
	//	*ReplaceSpecType_LogsStreamingDisabled
	//	*ReplaceSpecType_LogReceiver
	LogsReceiverChoice isReplaceSpecType_LogsReceiverChoice `protobuf_oneof:"logs_receiver_choice"`
	// Types that are valid to be assigned to UsbPolicyChoice:
	//	*ReplaceSpecType_DenyAllUsb
	//	*ReplaceSpecType_AllowAllUsb
	//	*ReplaceSpecType_UsbPolicy
	UsbPolicyChoice isReplaceSpecType_UsbPolicyChoice `protobuf_oneof:"usb_policy_choice"`
}

func (m *ReplaceSpecType) Reset()                    { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage()               {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{38} }

type isReplaceSpecType_InterfaceChoice interface {
	isReplaceSpecType_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_BondChoice interface {
	isReplaceSpecType_BondChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_StorageInterfaceChoice interface {
	isReplaceSpecType_StorageInterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_StorageDeviceChoice interface {
	isReplaceSpecType_StorageDeviceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_StorageClassChoice interface {
	isReplaceSpecType_StorageClassChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_DcClusterGroupChoice interface {
	isReplaceSpecType_DcClusterGroupChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_GpuChoice interface {
	isReplaceSpecType_GpuChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_StorageStaticRoutesChoice interface {
	isReplaceSpecType_StorageStaticRoutesChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_LogsReceiverChoice interface {
	isReplaceSpecType_LogsReceiverChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_UsbPolicyChoice interface {
	isReplaceSpecType_UsbPolicyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_InterfaceList struct {
	InterfaceList *FleetInterfaceListType `protobuf:"bytes,13,opt,name=interface_list,json=interfaceList,oneof"`
}
type ReplaceSpecType_DefaultConfig struct {
	DefaultConfig *ves_io_schema4.Empty `protobuf:"bytes,40,opt,name=default_config,json=defaultConfig,oneof"`
}
type ReplaceSpecType_DeviceList struct {
	DeviceList *FleetDeviceListType `protobuf:"bytes,14,opt,name=device_list,json=deviceList,oneof"`
}
type ReplaceSpecType_NoBondDevices struct {
	NoBondDevices *ves_io_schema4.Empty `protobuf:"bytes,16,opt,name=no_bond_devices,json=noBondDevices,oneof"`
}
type ReplaceSpecType_BondDeviceList struct {
	BondDeviceList *FleetBondDevicesListType `protobuf:"bytes,17,opt,name=bond_device_list,json=bondDeviceList,oneof"`
}
type ReplaceSpecType_NoStorageInterfaces struct {
	NoStorageInterfaces *ves_io_schema4.Empty `protobuf:"bytes,19,opt,name=no_storage_interfaces,json=noStorageInterfaces,oneof"`
}
type ReplaceSpecType_StorageInterfaceList struct {
	StorageInterfaceList *FleetInterfaceListType `protobuf:"bytes,20,opt,name=storage_interface_list,json=storageInterfaceList,oneof"`
}
type ReplaceSpecType_NoStorageDevice struct {
	NoStorageDevice *ves_io_schema4.Empty `protobuf:"bytes,22,opt,name=no_storage_device,json=noStorageDevice,oneof"`
}
type ReplaceSpecType_StorageDeviceList struct {
	StorageDeviceList *FleetStorageDeviceListType `protobuf:"bytes,23,opt,name=storage_device_list,json=storageDeviceList,oneof"`
}
type ReplaceSpecType_DefaultStorageClass struct {
	DefaultStorageClass *ves_io_schema4.Empty `protobuf:"bytes,25,opt,name=default_storage_class,json=defaultStorageClass,oneof"`
}
type ReplaceSpecType_StorageClassList struct {
	StorageClassList *FleetStorageClassListType `protobuf:"bytes,26,opt,name=storage_class_list,json=storageClassList,oneof"`
}
type ReplaceSpecType_NoDcClusterGroup struct {
	NoDcClusterGroup *ves_io_schema4.Empty `protobuf:"bytes,28,opt,name=no_dc_cluster_group,json=noDcClusterGroup,oneof"`
}
type ReplaceSpecType_DcClusterGroup struct {
	DcClusterGroup *ves_io_schema_views.ObjectRefType `protobuf:"bytes,29,opt,name=dc_cluster_group,json=dcClusterGroup,oneof"`
}
type ReplaceSpecType_DcClusterGroupInside struct {
	DcClusterGroupInside *ves_io_schema_views.ObjectRefType `protobuf:"bytes,38,opt,name=dc_cluster_group_inside,json=dcClusterGroupInside,oneof"`
}
type ReplaceSpecType_DisableGpu struct {
	DisableGpu *ves_io_schema4.Empty `protobuf:"bytes,31,opt,name=disable_gpu,json=disableGpu,oneof"`
}
type ReplaceSpecType_EnableGpu struct {
	EnableGpu *ves_io_schema4.Empty `protobuf:"bytes,32,opt,name=enable_gpu,json=enableGpu,oneof"`
}
type ReplaceSpecType_NoStorageStaticRoutes struct {
	NoStorageStaticRoutes *ves_io_schema4.Empty `protobuf:"bytes,35,opt,name=no_storage_static_routes,json=noStorageStaticRoutes,oneof"`
}
type ReplaceSpecType_StorageStaticRoutes struct {
	StorageStaticRoutes *FleetStorageStaticRoutesListType `protobuf:"bytes,36,opt,name=storage_static_routes,json=storageStaticRoutes,oneof"`
}
type ReplaceSpecType_LogsStreamingDisabled struct {
	LogsStreamingDisabled *ves_io_schema4.Empty `protobuf:"bytes,44,opt,name=logs_streaming_disabled,json=logsStreamingDisabled,oneof"`
}
type ReplaceSpecType_LogReceiver struct {
	LogReceiver *ves_io_schema_views.ObjectRefType `protobuf:"bytes,45,opt,name=log_receiver,json=logReceiver,oneof"`
}
type ReplaceSpecType_DenyAllUsb struct {
	DenyAllUsb *ves_io_schema4.Empty `protobuf:"bytes,47,opt,name=deny_all_usb,json=denyAllUsb,oneof"`
}
type ReplaceSpecType_AllowAllUsb struct {
	AllowAllUsb *ves_io_schema4.Empty `protobuf:"bytes,48,opt,name=allow_all_usb,json=allowAllUsb,oneof"`
}
type ReplaceSpecType_UsbPolicy struct {
	UsbPolicy *ves_io_schema_views.ObjectRefType `protobuf:"bytes,49,opt,name=usb_policy,json=usbPolicy,oneof"`
}

func (*ReplaceSpecType_InterfaceList) isReplaceSpecType_InterfaceChoice()                   {}
func (*ReplaceSpecType_DefaultConfig) isReplaceSpecType_InterfaceChoice()                   {}
func (*ReplaceSpecType_DeviceList) isReplaceSpecType_InterfaceChoice()                      {}
func (*ReplaceSpecType_NoBondDevices) isReplaceSpecType_BondChoice()                        {}
func (*ReplaceSpecType_BondDeviceList) isReplaceSpecType_BondChoice()                       {}
func (*ReplaceSpecType_NoStorageInterfaces) isReplaceSpecType_StorageInterfaceChoice()      {}
func (*ReplaceSpecType_StorageInterfaceList) isReplaceSpecType_StorageInterfaceChoice()     {}
func (*ReplaceSpecType_NoStorageDevice) isReplaceSpecType_StorageDeviceChoice()             {}
func (*ReplaceSpecType_StorageDeviceList) isReplaceSpecType_StorageDeviceChoice()           {}
func (*ReplaceSpecType_DefaultStorageClass) isReplaceSpecType_StorageClassChoice()          {}
func (*ReplaceSpecType_StorageClassList) isReplaceSpecType_StorageClassChoice()             {}
func (*ReplaceSpecType_NoDcClusterGroup) isReplaceSpecType_DcClusterGroupChoice()           {}
func (*ReplaceSpecType_DcClusterGroup) isReplaceSpecType_DcClusterGroupChoice()             {}
func (*ReplaceSpecType_DcClusterGroupInside) isReplaceSpecType_DcClusterGroupChoice()       {}
func (*ReplaceSpecType_DisableGpu) isReplaceSpecType_GpuChoice()                            {}
func (*ReplaceSpecType_EnableGpu) isReplaceSpecType_GpuChoice()                             {}
func (*ReplaceSpecType_NoStorageStaticRoutes) isReplaceSpecType_StorageStaticRoutesChoice() {}
func (*ReplaceSpecType_StorageStaticRoutes) isReplaceSpecType_StorageStaticRoutesChoice()   {}
func (*ReplaceSpecType_LogsStreamingDisabled) isReplaceSpecType_LogsReceiverChoice()        {}
func (*ReplaceSpecType_LogReceiver) isReplaceSpecType_LogsReceiverChoice()                  {}
func (*ReplaceSpecType_DenyAllUsb) isReplaceSpecType_UsbPolicyChoice()                      {}
func (*ReplaceSpecType_AllowAllUsb) isReplaceSpecType_UsbPolicyChoice()                     {}
func (*ReplaceSpecType_UsbPolicy) isReplaceSpecType_UsbPolicyChoice()                       {}

func (m *ReplaceSpecType) GetInterfaceChoice() isReplaceSpecType_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetBondChoice() isReplaceSpecType_BondChoice {
	if m != nil {
		return m.BondChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetStorageInterfaceChoice() isReplaceSpecType_StorageInterfaceChoice {
	if m != nil {
		return m.StorageInterfaceChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetStorageDeviceChoice() isReplaceSpecType_StorageDeviceChoice {
	if m != nil {
		return m.StorageDeviceChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetStorageClassChoice() isReplaceSpecType_StorageClassChoice {
	if m != nil {
		return m.StorageClassChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetDcClusterGroupChoice() isReplaceSpecType_DcClusterGroupChoice {
	if m != nil {
		return m.DcClusterGroupChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetGpuChoice() isReplaceSpecType_GpuChoice {
	if m != nil {
		return m.GpuChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetStorageStaticRoutesChoice() isReplaceSpecType_StorageStaticRoutesChoice {
	if m != nil {
		return m.StorageStaticRoutesChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetLogsReceiverChoice() isReplaceSpecType_LogsReceiverChoice {
	if m != nil {
		return m.LogsReceiverChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetUsbPolicyChoice() isReplaceSpecType_UsbPolicyChoice {
	if m != nil {
		return m.UsbPolicyChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetVolterraSoftwareVersion() string {
	if m != nil {
		return m.VolterraSoftwareVersion
	}
	return ""
}

func (m *ReplaceSpecType) GetNetworkConnectors() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.NetworkConnectors
	}
	return nil
}

func (m *ReplaceSpecType) GetNetworkFirewall() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.NetworkFirewall
	}
	return nil
}

func (m *ReplaceSpecType) GetOperatingSystemVersion() string {
	if m != nil {
		return m.OperatingSystemVersion
	}
	return ""
}

func (m *ReplaceSpecType) GetOutsideVirtualNetwork() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.OutsideVirtualNetwork
	}
	return nil
}

func (m *ReplaceSpecType) GetInsideVirtualNetwork() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.InsideVirtualNetwork
	}
	return nil
}

func (m *ReplaceSpecType) GetInterfaceList() *FleetInterfaceListType {
	if x, ok := m.GetInterfaceChoice().(*ReplaceSpecType_InterfaceList); ok {
		return x.InterfaceList
	}
	return nil
}

func (m *ReplaceSpecType) GetDefaultConfig() *ves_io_schema4.Empty {
	if x, ok := m.GetInterfaceChoice().(*ReplaceSpecType_DefaultConfig); ok {
		return x.DefaultConfig
	}
	return nil
}

func (m *ReplaceSpecType) GetDeviceList() *FleetDeviceListType {
	if x, ok := m.GetInterfaceChoice().(*ReplaceSpecType_DeviceList); ok {
		return x.DeviceList
	}
	return nil
}

func (m *ReplaceSpecType) GetNoBondDevices() *ves_io_schema4.Empty {
	if x, ok := m.GetBondChoice().(*ReplaceSpecType_NoBondDevices); ok {
		return x.NoBondDevices
	}
	return nil
}

func (m *ReplaceSpecType) GetBondDeviceList() *FleetBondDevicesListType {
	if x, ok := m.GetBondChoice().(*ReplaceSpecType_BondDeviceList); ok {
		return x.BondDeviceList
	}
	return nil
}

func (m *ReplaceSpecType) GetNoStorageInterfaces() *ves_io_schema4.Empty {
	if x, ok := m.GetStorageInterfaceChoice().(*ReplaceSpecType_NoStorageInterfaces); ok {
		return x.NoStorageInterfaces
	}
	return nil
}

func (m *ReplaceSpecType) GetStorageInterfaceList() *FleetInterfaceListType {
	if x, ok := m.GetStorageInterfaceChoice().(*ReplaceSpecType_StorageInterfaceList); ok {
		return x.StorageInterfaceList
	}
	return nil
}

func (m *ReplaceSpecType) GetNoStorageDevice() *ves_io_schema4.Empty {
	if x, ok := m.GetStorageDeviceChoice().(*ReplaceSpecType_NoStorageDevice); ok {
		return x.NoStorageDevice
	}
	return nil
}

func (m *ReplaceSpecType) GetStorageDeviceList() *FleetStorageDeviceListType {
	if x, ok := m.GetStorageDeviceChoice().(*ReplaceSpecType_StorageDeviceList); ok {
		return x.StorageDeviceList
	}
	return nil
}

func (m *ReplaceSpecType) GetDefaultStorageClass() *ves_io_schema4.Empty {
	if x, ok := m.GetStorageClassChoice().(*ReplaceSpecType_DefaultStorageClass); ok {
		return x.DefaultStorageClass
	}
	return nil
}

func (m *ReplaceSpecType) GetStorageClassList() *FleetStorageClassListType {
	if x, ok := m.GetStorageClassChoice().(*ReplaceSpecType_StorageClassList); ok {
		return x.StorageClassList
	}
	return nil
}

func (m *ReplaceSpecType) GetNoDcClusterGroup() *ves_io_schema4.Empty {
	if x, ok := m.GetDcClusterGroupChoice().(*ReplaceSpecType_NoDcClusterGroup); ok {
		return x.NoDcClusterGroup
	}
	return nil
}

func (m *ReplaceSpecType) GetDcClusterGroup() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetDcClusterGroupChoice().(*ReplaceSpecType_DcClusterGroup); ok {
		return x.DcClusterGroup
	}
	return nil
}

func (m *ReplaceSpecType) GetDcClusterGroupInside() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetDcClusterGroupChoice().(*ReplaceSpecType_DcClusterGroupInside); ok {
		return x.DcClusterGroupInside
	}
	return nil
}

func (m *ReplaceSpecType) GetDisableGpu() *ves_io_schema4.Empty {
	if x, ok := m.GetGpuChoice().(*ReplaceSpecType_DisableGpu); ok {
		return x.DisableGpu
	}
	return nil
}

func (m *ReplaceSpecType) GetEnableGpu() *ves_io_schema4.Empty {
	if x, ok := m.GetGpuChoice().(*ReplaceSpecType_EnableGpu); ok {
		return x.EnableGpu
	}
	return nil
}

func (m *ReplaceSpecType) GetNoStorageStaticRoutes() *ves_io_schema4.Empty {
	if x, ok := m.GetStorageStaticRoutesChoice().(*ReplaceSpecType_NoStorageStaticRoutes); ok {
		return x.NoStorageStaticRoutes
	}
	return nil
}

func (m *ReplaceSpecType) GetStorageStaticRoutes() *FleetStorageStaticRoutesListType {
	if x, ok := m.GetStorageStaticRoutesChoice().(*ReplaceSpecType_StorageStaticRoutes); ok {
		return x.StorageStaticRoutes
	}
	return nil
}

func (m *ReplaceSpecType) GetEnableDefaultFleetConfigDownload() bool {
	if m != nil {
		return m.EnableDefaultFleetConfigDownload
	}
	return false
}

func (m *ReplaceSpecType) GetLogsStreamingDisabled() *ves_io_schema4.Empty {
	if x, ok := m.GetLogsReceiverChoice().(*ReplaceSpecType_LogsStreamingDisabled); ok {
		return x.LogsStreamingDisabled
	}
	return nil
}

func (m *ReplaceSpecType) GetLogReceiver() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetLogsReceiverChoice().(*ReplaceSpecType_LogReceiver); ok {
		return x.LogReceiver
	}
	return nil
}

func (m *ReplaceSpecType) GetDenyAllUsb() *ves_io_schema4.Empty {
	if x, ok := m.GetUsbPolicyChoice().(*ReplaceSpecType_DenyAllUsb); ok {
		return x.DenyAllUsb
	}
	return nil
}

func (m *ReplaceSpecType) GetAllowAllUsb() *ves_io_schema4.Empty {
	if x, ok := m.GetUsbPolicyChoice().(*ReplaceSpecType_AllowAllUsb); ok {
		return x.AllowAllUsb
	}
	return nil
}

func (m *ReplaceSpecType) GetUsbPolicy() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetUsbPolicyChoice().(*ReplaceSpecType_UsbPolicy); ok {
		return x.UsbPolicy
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReplaceSpecType_OneofMarshaler, _ReplaceSpecType_OneofUnmarshaler, _ReplaceSpecType_OneofSizer, []interface{}{
		(*ReplaceSpecType_InterfaceList)(nil),
		(*ReplaceSpecType_DefaultConfig)(nil),
		(*ReplaceSpecType_DeviceList)(nil),
		(*ReplaceSpecType_NoBondDevices)(nil),
		(*ReplaceSpecType_BondDeviceList)(nil),
		(*ReplaceSpecType_NoStorageInterfaces)(nil),
		(*ReplaceSpecType_StorageInterfaceList)(nil),
		(*ReplaceSpecType_NoStorageDevice)(nil),
		(*ReplaceSpecType_StorageDeviceList)(nil),
		(*ReplaceSpecType_DefaultStorageClass)(nil),
		(*ReplaceSpecType_StorageClassList)(nil),
		(*ReplaceSpecType_NoDcClusterGroup)(nil),
		(*ReplaceSpecType_DcClusterGroup)(nil),
		(*ReplaceSpecType_DcClusterGroupInside)(nil),
		(*ReplaceSpecType_DisableGpu)(nil),
		(*ReplaceSpecType_EnableGpu)(nil),
		(*ReplaceSpecType_NoStorageStaticRoutes)(nil),
		(*ReplaceSpecType_StorageStaticRoutes)(nil),
		(*ReplaceSpecType_LogsStreamingDisabled)(nil),
		(*ReplaceSpecType_LogReceiver)(nil),
		(*ReplaceSpecType_DenyAllUsb)(nil),
		(*ReplaceSpecType_AllowAllUsb)(nil),
		(*ReplaceSpecType_UsbPolicy)(nil),
	}
}

func _ReplaceSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReplaceSpecType)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *ReplaceSpecType_InterfaceList:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InterfaceList); err != nil {
			return err
		}
	case *ReplaceSpecType_DefaultConfig:
		_ = b.EncodeVarint(40<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DefaultConfig); err != nil {
			return err
		}
	case *ReplaceSpecType_DeviceList:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DeviceList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.InterfaceChoice has unexpected type %T", x)
	}
	// bond_choice
	switch x := m.BondChoice.(type) {
	case *ReplaceSpecType_NoBondDevices:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoBondDevices); err != nil {
			return err
		}
	case *ReplaceSpecType_BondDeviceList:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BondDeviceList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.BondChoice has unexpected type %T", x)
	}
	// storage_interface_choice
	switch x := m.StorageInterfaceChoice.(type) {
	case *ReplaceSpecType_NoStorageInterfaces:
		_ = b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoStorageInterfaces); err != nil {
			return err
		}
	case *ReplaceSpecType_StorageInterfaceList:
		_ = b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageInterfaceList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.StorageInterfaceChoice has unexpected type %T", x)
	}
	// storage_device_choice
	switch x := m.StorageDeviceChoice.(type) {
	case *ReplaceSpecType_NoStorageDevice:
		_ = b.EncodeVarint(22<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoStorageDevice); err != nil {
			return err
		}
	case *ReplaceSpecType_StorageDeviceList:
		_ = b.EncodeVarint(23<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageDeviceList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.StorageDeviceChoice has unexpected type %T", x)
	}
	// storage_class_choice
	switch x := m.StorageClassChoice.(type) {
	case *ReplaceSpecType_DefaultStorageClass:
		_ = b.EncodeVarint(25<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DefaultStorageClass); err != nil {
			return err
		}
	case *ReplaceSpecType_StorageClassList:
		_ = b.EncodeVarint(26<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageClassList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.StorageClassChoice has unexpected type %T", x)
	}
	// dc_cluster_group_choice
	switch x := m.DcClusterGroupChoice.(type) {
	case *ReplaceSpecType_NoDcClusterGroup:
		_ = b.EncodeVarint(28<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoDcClusterGroup); err != nil {
			return err
		}
	case *ReplaceSpecType_DcClusterGroup:
		_ = b.EncodeVarint(29<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DcClusterGroup); err != nil {
			return err
		}
	case *ReplaceSpecType_DcClusterGroupInside:
		_ = b.EncodeVarint(38<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DcClusterGroupInside); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.DcClusterGroupChoice has unexpected type %T", x)
	}
	// gpu_choice
	switch x := m.GpuChoice.(type) {
	case *ReplaceSpecType_DisableGpu:
		_ = b.EncodeVarint(31<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DisableGpu); err != nil {
			return err
		}
	case *ReplaceSpecType_EnableGpu:
		_ = b.EncodeVarint(32<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EnableGpu); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.GpuChoice has unexpected type %T", x)
	}
	// storage_static_routes_choice
	switch x := m.StorageStaticRoutesChoice.(type) {
	case *ReplaceSpecType_NoStorageStaticRoutes:
		_ = b.EncodeVarint(35<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoStorageStaticRoutes); err != nil {
			return err
		}
	case *ReplaceSpecType_StorageStaticRoutes:
		_ = b.EncodeVarint(36<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageStaticRoutes); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.StorageStaticRoutesChoice has unexpected type %T", x)
	}
	// logs_receiver_choice
	switch x := m.LogsReceiverChoice.(type) {
	case *ReplaceSpecType_LogsStreamingDisabled:
		_ = b.EncodeVarint(44<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogsStreamingDisabled); err != nil {
			return err
		}
	case *ReplaceSpecType_LogReceiver:
		_ = b.EncodeVarint(45<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogReceiver); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.LogsReceiverChoice has unexpected type %T", x)
	}
	// usb_policy_choice
	switch x := m.UsbPolicyChoice.(type) {
	case *ReplaceSpecType_DenyAllUsb:
		_ = b.EncodeVarint(47<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DenyAllUsb); err != nil {
			return err
		}
	case *ReplaceSpecType_AllowAllUsb:
		_ = b.EncodeVarint(48<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AllowAllUsb); err != nil {
			return err
		}
	case *ReplaceSpecType_UsbPolicy:
		_ = b.EncodeVarint(49<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UsbPolicy); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplaceSpecType.UsbPolicyChoice has unexpected type %T", x)
	}
	return nil
}

func _ReplaceSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReplaceSpecType)
	switch tag {
	case 13: // interface_choice.interface_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetInterfaceListType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &ReplaceSpecType_InterfaceList{msg}
		return true, err
	case 40: // interface_choice.default_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &ReplaceSpecType_DefaultConfig{msg}
		return true, err
	case 14: // interface_choice.device_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetDeviceListType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &ReplaceSpecType_DeviceList{msg}
		return true, err
	case 16: // bond_choice.no_bond_devices
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.BondChoice = &ReplaceSpecType_NoBondDevices{msg}
		return true, err
	case 17: // bond_choice.bond_device_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetBondDevicesListType)
		err := b.DecodeMessage(msg)
		m.BondChoice = &ReplaceSpecType_BondDeviceList{msg}
		return true, err
	case 19: // storage_interface_choice.no_storage_interfaces
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.StorageInterfaceChoice = &ReplaceSpecType_NoStorageInterfaces{msg}
		return true, err
	case 20: // storage_interface_choice.storage_interface_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetInterfaceListType)
		err := b.DecodeMessage(msg)
		m.StorageInterfaceChoice = &ReplaceSpecType_StorageInterfaceList{msg}
		return true, err
	case 22: // storage_device_choice.no_storage_device
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.StorageDeviceChoice = &ReplaceSpecType_NoStorageDevice{msg}
		return true, err
	case 23: // storage_device_choice.storage_device_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetStorageDeviceListType)
		err := b.DecodeMessage(msg)
		m.StorageDeviceChoice = &ReplaceSpecType_StorageDeviceList{msg}
		return true, err
	case 25: // storage_class_choice.default_storage_class
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.StorageClassChoice = &ReplaceSpecType_DefaultStorageClass{msg}
		return true, err
	case 26: // storage_class_choice.storage_class_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetStorageClassListType)
		err := b.DecodeMessage(msg)
		m.StorageClassChoice = &ReplaceSpecType_StorageClassList{msg}
		return true, err
	case 28: // dc_cluster_group_choice.no_dc_cluster_group
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.DcClusterGroupChoice = &ReplaceSpecType_NoDcClusterGroup{msg}
		return true, err
	case 29: // dc_cluster_group_choice.dc_cluster_group
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.DcClusterGroupChoice = &ReplaceSpecType_DcClusterGroup{msg}
		return true, err
	case 38: // dc_cluster_group_choice.dc_cluster_group_inside
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.DcClusterGroupChoice = &ReplaceSpecType_DcClusterGroupInside{msg}
		return true, err
	case 31: // gpu_choice.disable_gpu
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.GpuChoice = &ReplaceSpecType_DisableGpu{msg}
		return true, err
	case 32: // gpu_choice.enable_gpu
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.GpuChoice = &ReplaceSpecType_EnableGpu{msg}
		return true, err
	case 35: // storage_static_routes_choice.no_storage_static_routes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.StorageStaticRoutesChoice = &ReplaceSpecType_NoStorageStaticRoutes{msg}
		return true, err
	case 36: // storage_static_routes_choice.storage_static_routes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetStorageStaticRoutesListType)
		err := b.DecodeMessage(msg)
		m.StorageStaticRoutesChoice = &ReplaceSpecType_StorageStaticRoutes{msg}
		return true, err
	case 44: // logs_receiver_choice.logs_streaming_disabled
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.LogsReceiverChoice = &ReplaceSpecType_LogsStreamingDisabled{msg}
		return true, err
	case 45: // logs_receiver_choice.log_receiver
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.LogsReceiverChoice = &ReplaceSpecType_LogReceiver{msg}
		return true, err
	case 47: // usb_policy_choice.deny_all_usb
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.UsbPolicyChoice = &ReplaceSpecType_DenyAllUsb{msg}
		return true, err
	case 48: // usb_policy_choice.allow_all_usb
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.UsbPolicyChoice = &ReplaceSpecType_AllowAllUsb{msg}
		return true, err
	case 49: // usb_policy_choice.usb_policy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.UsbPolicyChoice = &ReplaceSpecType_UsbPolicy{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ReplaceSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReplaceSpecType)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *ReplaceSpecType_InterfaceList:
		s := proto.Size(x.InterfaceList)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_DefaultConfig:
		s := proto.Size(x.DefaultConfig)
		n += proto.SizeVarint(40<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_DeviceList:
		s := proto.Size(x.DeviceList)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// bond_choice
	switch x := m.BondChoice.(type) {
	case *ReplaceSpecType_NoBondDevices:
		s := proto.Size(x.NoBondDevices)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_BondDeviceList:
		s := proto.Size(x.BondDeviceList)
		n += proto.SizeVarint(17<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// storage_interface_choice
	switch x := m.StorageInterfaceChoice.(type) {
	case *ReplaceSpecType_NoStorageInterfaces:
		s := proto.Size(x.NoStorageInterfaces)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_StorageInterfaceList:
		s := proto.Size(x.StorageInterfaceList)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// storage_device_choice
	switch x := m.StorageDeviceChoice.(type) {
	case *ReplaceSpecType_NoStorageDevice:
		s := proto.Size(x.NoStorageDevice)
		n += proto.SizeVarint(22<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_StorageDeviceList:
		s := proto.Size(x.StorageDeviceList)
		n += proto.SizeVarint(23<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// storage_class_choice
	switch x := m.StorageClassChoice.(type) {
	case *ReplaceSpecType_DefaultStorageClass:
		s := proto.Size(x.DefaultStorageClass)
		n += proto.SizeVarint(25<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_StorageClassList:
		s := proto.Size(x.StorageClassList)
		n += proto.SizeVarint(26<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// dc_cluster_group_choice
	switch x := m.DcClusterGroupChoice.(type) {
	case *ReplaceSpecType_NoDcClusterGroup:
		s := proto.Size(x.NoDcClusterGroup)
		n += proto.SizeVarint(28<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_DcClusterGroup:
		s := proto.Size(x.DcClusterGroup)
		n += proto.SizeVarint(29<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_DcClusterGroupInside:
		s := proto.Size(x.DcClusterGroupInside)
		n += proto.SizeVarint(38<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// gpu_choice
	switch x := m.GpuChoice.(type) {
	case *ReplaceSpecType_DisableGpu:
		s := proto.Size(x.DisableGpu)
		n += proto.SizeVarint(31<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_EnableGpu:
		s := proto.Size(x.EnableGpu)
		n += proto.SizeVarint(32<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// storage_static_routes_choice
	switch x := m.StorageStaticRoutesChoice.(type) {
	case *ReplaceSpecType_NoStorageStaticRoutes:
		s := proto.Size(x.NoStorageStaticRoutes)
		n += proto.SizeVarint(35<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_StorageStaticRoutes:
		s := proto.Size(x.StorageStaticRoutes)
		n += proto.SizeVarint(36<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// logs_receiver_choice
	switch x := m.LogsReceiverChoice.(type) {
	case *ReplaceSpecType_LogsStreamingDisabled:
		s := proto.Size(x.LogsStreamingDisabled)
		n += proto.SizeVarint(44<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_LogReceiver:
		s := proto.Size(x.LogReceiver)
		n += proto.SizeVarint(45<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// usb_policy_choice
	switch x := m.UsbPolicyChoice.(type) {
	case *ReplaceSpecType_DenyAllUsb:
		s := proto.Size(x.DenyAllUsb)
		n += proto.SizeVarint(47<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_AllowAllUsb:
		s := proto.Size(x.AllowAllUsb)
		n += proto.SizeVarint(48<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplaceSpecType_UsbPolicy:
		s := proto.Size(x.UsbPolicy)
		n += proto.SizeVarint(49<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Get fleet
//
// x-displayName: "Get Fleet"
// Get fleet will get fleet object from system namespace
type GetSpecType struct {
	FleetLabel              string                          `protobuf:"bytes,1,opt,name=fleet_label,json=fleetLabel,proto3" json:"fleet_label,omitempty"`
	VolterraSoftwareVersion string                          `protobuf:"bytes,2,opt,name=volterra_software_version,json=volterraSoftwareVersion,proto3" json:"volterra_software_version,omitempty"`
	NetworkConnectors       []*ves_io_schema4.ObjectRefType `protobuf:"bytes,4,rep,name=network_connectors,json=networkConnectors" json:"network_connectors,omitempty"`
	NetworkFirewall         []*ves_io_schema4.ObjectRefType `protobuf:"bytes,5,rep,name=network_firewall,json=networkFirewall" json:"network_firewall,omitempty"`
	OperatingSystemVersion  string                          `protobuf:"bytes,6,opt,name=operating_system_version,json=operatingSystemVersion,proto3" json:"operating_system_version,omitempty"`
	OutsideVirtualNetwork   []*ves_io_schema4.ObjectRefType `protobuf:"bytes,7,rep,name=outside_virtual_network,json=outsideVirtualNetwork" json:"outside_virtual_network,omitempty"`
	InsideVirtualNetwork    []*ves_io_schema4.ObjectRefType `protobuf:"bytes,8,rep,name=inside_virtual_network,json=insideVirtualNetwork" json:"inside_virtual_network,omitempty"`
	// Select Interface Config
	//
	// x-displayName: "Select Interface Config"
	// x-required
	// Select how interfaces are configured for this fleet
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*GetSpecType_InterfaceList
	//	*GetSpecType_DefaultConfig
	//	*GetSpecType_DeviceList
	InterfaceChoice isGetSpecType_InterfaceChoice `protobuf_oneof:"interface_choice"`
	// Types that are valid to be assigned to BondChoice:
	//	*GetSpecType_NoBondDevices
	//	*GetSpecType_BondDeviceList
	BondChoice isGetSpecType_BondChoice `protobuf_oneof:"bond_choice"`
	// Types that are valid to be assigned to StorageInterfaceChoice:
	//	*GetSpecType_NoStorageInterfaces
	//	*GetSpecType_StorageInterfaceList
	StorageInterfaceChoice isGetSpecType_StorageInterfaceChoice `protobuf_oneof:"storage_interface_choice"`
	// Types that are valid to be assigned to StorageDeviceChoice:
	//	*GetSpecType_NoStorageDevice
	//	*GetSpecType_StorageDeviceList
	StorageDeviceChoice isGetSpecType_StorageDeviceChoice `protobuf_oneof:"storage_device_choice"`
	// Types that are valid to be assigned to StorageClassChoice:
	//	*GetSpecType_DefaultStorageClass
	//	*GetSpecType_StorageClassList
	StorageClassChoice isGetSpecType_StorageClassChoice `protobuf_oneof:"storage_class_choice"`
	// Types that are valid to be assigned to DcClusterGroupChoice:
	//	*GetSpecType_NoDcClusterGroup
	//	*GetSpecType_DcClusterGroup
	//	*GetSpecType_DcClusterGroupInside
	DcClusterGroupChoice isGetSpecType_DcClusterGroupChoice `protobuf_oneof:"dc_cluster_group_choice"`
	// Types that are valid to be assigned to GpuChoice:
	//	*GetSpecType_DisableGpu
	//	*GetSpecType_EnableGpu
	GpuChoice isGetSpecType_GpuChoice `protobuf_oneof:"gpu_choice"`
	// Types that are valid to be assigned to StorageStaticRoutesChoice:
	//	*GetSpecType_NoStorageStaticRoutes
	//	*GetSpecType_StorageStaticRoutes
	StorageStaticRoutesChoice        isGetSpecType_StorageStaticRoutesChoice `protobuf_oneof:"storage_static_routes_choice"`
	EnableDefaultFleetConfigDownload bool                                    `protobuf:"varint,37,opt,name=enable_default_fleet_config_download,json=enableDefaultFleetConfigDownload,proto3" json:"enable_default_fleet_config_download,omitempty"`
	// Types that are valid to be assigned to LogsReceiverChoice:
	//	*GetSpecType_LogsStreamingDisabled
	//	*GetSpecType_LogReceiver
	LogsReceiverChoice isGetSpecType_LogsReceiverChoice `protobuf_oneof:"logs_receiver_choice"`
	// Types that are valid to be assigned to UsbPolicyChoice:
	//	*GetSpecType_DenyAllUsb
	//	*GetSpecType_AllowAllUsb
	//	*GetSpecType_UsbPolicy
	UsbPolicyChoice isGetSpecType_UsbPolicyChoice `protobuf_oneof:"usb_policy_choice"`
}

func (m *GetSpecType) Reset()                    { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage()               {}
func (*GetSpecType) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{39} }

type isGetSpecType_InterfaceChoice interface {
	isGetSpecType_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_BondChoice interface {
	isGetSpecType_BondChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_StorageInterfaceChoice interface {
	isGetSpecType_StorageInterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_StorageDeviceChoice interface {
	isGetSpecType_StorageDeviceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_StorageClassChoice interface {
	isGetSpecType_StorageClassChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_DcClusterGroupChoice interface {
	isGetSpecType_DcClusterGroupChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_GpuChoice interface {
	isGetSpecType_GpuChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_StorageStaticRoutesChoice interface {
	isGetSpecType_StorageStaticRoutesChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_LogsReceiverChoice interface {
	isGetSpecType_LogsReceiverChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_UsbPolicyChoice interface {
	isGetSpecType_UsbPolicyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_InterfaceList struct {
	InterfaceList *FleetInterfaceListType `protobuf:"bytes,13,opt,name=interface_list,json=interfaceList,oneof"`
}
type GetSpecType_DefaultConfig struct {
	DefaultConfig *ves_io_schema4.Empty `protobuf:"bytes,40,opt,name=default_config,json=defaultConfig,oneof"`
}
type GetSpecType_DeviceList struct {
	DeviceList *FleetDeviceListType `protobuf:"bytes,14,opt,name=device_list,json=deviceList,oneof"`
}
type GetSpecType_NoBondDevices struct {
	NoBondDevices *ves_io_schema4.Empty `protobuf:"bytes,16,opt,name=no_bond_devices,json=noBondDevices,oneof"`
}
type GetSpecType_BondDeviceList struct {
	BondDeviceList *FleetBondDevicesListType `protobuf:"bytes,17,opt,name=bond_device_list,json=bondDeviceList,oneof"`
}
type GetSpecType_NoStorageInterfaces struct {
	NoStorageInterfaces *ves_io_schema4.Empty `protobuf:"bytes,19,opt,name=no_storage_interfaces,json=noStorageInterfaces,oneof"`
}
type GetSpecType_StorageInterfaceList struct {
	StorageInterfaceList *FleetInterfaceListType `protobuf:"bytes,20,opt,name=storage_interface_list,json=storageInterfaceList,oneof"`
}
type GetSpecType_NoStorageDevice struct {
	NoStorageDevice *ves_io_schema4.Empty `protobuf:"bytes,22,opt,name=no_storage_device,json=noStorageDevice,oneof"`
}
type GetSpecType_StorageDeviceList struct {
	StorageDeviceList *FleetStorageDeviceListType `protobuf:"bytes,23,opt,name=storage_device_list,json=storageDeviceList,oneof"`
}
type GetSpecType_DefaultStorageClass struct {
	DefaultStorageClass *ves_io_schema4.Empty `protobuf:"bytes,25,opt,name=default_storage_class,json=defaultStorageClass,oneof"`
}
type GetSpecType_StorageClassList struct {
	StorageClassList *FleetStorageClassListType `protobuf:"bytes,26,opt,name=storage_class_list,json=storageClassList,oneof"`
}
type GetSpecType_NoDcClusterGroup struct {
	NoDcClusterGroup *ves_io_schema4.Empty `protobuf:"bytes,28,opt,name=no_dc_cluster_group,json=noDcClusterGroup,oneof"`
}
type GetSpecType_DcClusterGroup struct {
	DcClusterGroup *ves_io_schema_views.ObjectRefType `protobuf:"bytes,29,opt,name=dc_cluster_group,json=dcClusterGroup,oneof"`
}
type GetSpecType_DcClusterGroupInside struct {
	DcClusterGroupInside *ves_io_schema_views.ObjectRefType `protobuf:"bytes,38,opt,name=dc_cluster_group_inside,json=dcClusterGroupInside,oneof"`
}
type GetSpecType_DisableGpu struct {
	DisableGpu *ves_io_schema4.Empty `protobuf:"bytes,31,opt,name=disable_gpu,json=disableGpu,oneof"`
}
type GetSpecType_EnableGpu struct {
	EnableGpu *ves_io_schema4.Empty `protobuf:"bytes,32,opt,name=enable_gpu,json=enableGpu,oneof"`
}
type GetSpecType_NoStorageStaticRoutes struct {
	NoStorageStaticRoutes *ves_io_schema4.Empty `protobuf:"bytes,35,opt,name=no_storage_static_routes,json=noStorageStaticRoutes,oneof"`
}
type GetSpecType_StorageStaticRoutes struct {
	StorageStaticRoutes *FleetStorageStaticRoutesListType `protobuf:"bytes,36,opt,name=storage_static_routes,json=storageStaticRoutes,oneof"`
}
type GetSpecType_LogsStreamingDisabled struct {
	LogsStreamingDisabled *ves_io_schema4.Empty `protobuf:"bytes,44,opt,name=logs_streaming_disabled,json=logsStreamingDisabled,oneof"`
}
type GetSpecType_LogReceiver struct {
	LogReceiver *ves_io_schema_views.ObjectRefType `protobuf:"bytes,45,opt,name=log_receiver,json=logReceiver,oneof"`
}
type GetSpecType_DenyAllUsb struct {
	DenyAllUsb *ves_io_schema4.Empty `protobuf:"bytes,47,opt,name=deny_all_usb,json=denyAllUsb,oneof"`
}
type GetSpecType_AllowAllUsb struct {
	AllowAllUsb *ves_io_schema4.Empty `protobuf:"bytes,48,opt,name=allow_all_usb,json=allowAllUsb,oneof"`
}
type GetSpecType_UsbPolicy struct {
	UsbPolicy *ves_io_schema_views.ObjectRefType `protobuf:"bytes,49,opt,name=usb_policy,json=usbPolicy,oneof"`
}

func (*GetSpecType_InterfaceList) isGetSpecType_InterfaceChoice()                   {}
func (*GetSpecType_DefaultConfig) isGetSpecType_InterfaceChoice()                   {}
func (*GetSpecType_DeviceList) isGetSpecType_InterfaceChoice()                      {}
func (*GetSpecType_NoBondDevices) isGetSpecType_BondChoice()                        {}
func (*GetSpecType_BondDeviceList) isGetSpecType_BondChoice()                       {}
func (*GetSpecType_NoStorageInterfaces) isGetSpecType_StorageInterfaceChoice()      {}
func (*GetSpecType_StorageInterfaceList) isGetSpecType_StorageInterfaceChoice()     {}
func (*GetSpecType_NoStorageDevice) isGetSpecType_StorageDeviceChoice()             {}
func (*GetSpecType_StorageDeviceList) isGetSpecType_StorageDeviceChoice()           {}
func (*GetSpecType_DefaultStorageClass) isGetSpecType_StorageClassChoice()          {}
func (*GetSpecType_StorageClassList) isGetSpecType_StorageClassChoice()             {}
func (*GetSpecType_NoDcClusterGroup) isGetSpecType_DcClusterGroupChoice()           {}
func (*GetSpecType_DcClusterGroup) isGetSpecType_DcClusterGroupChoice()             {}
func (*GetSpecType_DcClusterGroupInside) isGetSpecType_DcClusterGroupChoice()       {}
func (*GetSpecType_DisableGpu) isGetSpecType_GpuChoice()                            {}
func (*GetSpecType_EnableGpu) isGetSpecType_GpuChoice()                             {}
func (*GetSpecType_NoStorageStaticRoutes) isGetSpecType_StorageStaticRoutesChoice() {}
func (*GetSpecType_StorageStaticRoutes) isGetSpecType_StorageStaticRoutesChoice()   {}
func (*GetSpecType_LogsStreamingDisabled) isGetSpecType_LogsReceiverChoice()        {}
func (*GetSpecType_LogReceiver) isGetSpecType_LogsReceiverChoice()                  {}
func (*GetSpecType_DenyAllUsb) isGetSpecType_UsbPolicyChoice()                      {}
func (*GetSpecType_AllowAllUsb) isGetSpecType_UsbPolicyChoice()                     {}
func (*GetSpecType_UsbPolicy) isGetSpecType_UsbPolicyChoice()                       {}

func (m *GetSpecType) GetInterfaceChoice() isGetSpecType_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}
func (m *GetSpecType) GetBondChoice() isGetSpecType_BondChoice {
	if m != nil {
		return m.BondChoice
	}
	return nil
}
func (m *GetSpecType) GetStorageInterfaceChoice() isGetSpecType_StorageInterfaceChoice {
	if m != nil {
		return m.StorageInterfaceChoice
	}
	return nil
}
func (m *GetSpecType) GetStorageDeviceChoice() isGetSpecType_StorageDeviceChoice {
	if m != nil {
		return m.StorageDeviceChoice
	}
	return nil
}
func (m *GetSpecType) GetStorageClassChoice() isGetSpecType_StorageClassChoice {
	if m != nil {
		return m.StorageClassChoice
	}
	return nil
}
func (m *GetSpecType) GetDcClusterGroupChoice() isGetSpecType_DcClusterGroupChoice {
	if m != nil {
		return m.DcClusterGroupChoice
	}
	return nil
}
func (m *GetSpecType) GetGpuChoice() isGetSpecType_GpuChoice {
	if m != nil {
		return m.GpuChoice
	}
	return nil
}
func (m *GetSpecType) GetStorageStaticRoutesChoice() isGetSpecType_StorageStaticRoutesChoice {
	if m != nil {
		return m.StorageStaticRoutesChoice
	}
	return nil
}
func (m *GetSpecType) GetLogsReceiverChoice() isGetSpecType_LogsReceiverChoice {
	if m != nil {
		return m.LogsReceiverChoice
	}
	return nil
}
func (m *GetSpecType) GetUsbPolicyChoice() isGetSpecType_UsbPolicyChoice {
	if m != nil {
		return m.UsbPolicyChoice
	}
	return nil
}

func (m *GetSpecType) GetFleetLabel() string {
	if m != nil {
		return m.FleetLabel
	}
	return ""
}

func (m *GetSpecType) GetVolterraSoftwareVersion() string {
	if m != nil {
		return m.VolterraSoftwareVersion
	}
	return ""
}

func (m *GetSpecType) GetNetworkConnectors() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.NetworkConnectors
	}
	return nil
}

func (m *GetSpecType) GetNetworkFirewall() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.NetworkFirewall
	}
	return nil
}

func (m *GetSpecType) GetOperatingSystemVersion() string {
	if m != nil {
		return m.OperatingSystemVersion
	}
	return ""
}

func (m *GetSpecType) GetOutsideVirtualNetwork() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.OutsideVirtualNetwork
	}
	return nil
}

func (m *GetSpecType) GetInsideVirtualNetwork() []*ves_io_schema4.ObjectRefType {
	if m != nil {
		return m.InsideVirtualNetwork
	}
	return nil
}

func (m *GetSpecType) GetInterfaceList() *FleetInterfaceListType {
	if x, ok := m.GetInterfaceChoice().(*GetSpecType_InterfaceList); ok {
		return x.InterfaceList
	}
	return nil
}

func (m *GetSpecType) GetDefaultConfig() *ves_io_schema4.Empty {
	if x, ok := m.GetInterfaceChoice().(*GetSpecType_DefaultConfig); ok {
		return x.DefaultConfig
	}
	return nil
}

func (m *GetSpecType) GetDeviceList() *FleetDeviceListType {
	if x, ok := m.GetInterfaceChoice().(*GetSpecType_DeviceList); ok {
		return x.DeviceList
	}
	return nil
}

func (m *GetSpecType) GetNoBondDevices() *ves_io_schema4.Empty {
	if x, ok := m.GetBondChoice().(*GetSpecType_NoBondDevices); ok {
		return x.NoBondDevices
	}
	return nil
}

func (m *GetSpecType) GetBondDeviceList() *FleetBondDevicesListType {
	if x, ok := m.GetBondChoice().(*GetSpecType_BondDeviceList); ok {
		return x.BondDeviceList
	}
	return nil
}

func (m *GetSpecType) GetNoStorageInterfaces() *ves_io_schema4.Empty {
	if x, ok := m.GetStorageInterfaceChoice().(*GetSpecType_NoStorageInterfaces); ok {
		return x.NoStorageInterfaces
	}
	return nil
}

func (m *GetSpecType) GetStorageInterfaceList() *FleetInterfaceListType {
	if x, ok := m.GetStorageInterfaceChoice().(*GetSpecType_StorageInterfaceList); ok {
		return x.StorageInterfaceList
	}
	return nil
}

func (m *GetSpecType) GetNoStorageDevice() *ves_io_schema4.Empty {
	if x, ok := m.GetStorageDeviceChoice().(*GetSpecType_NoStorageDevice); ok {
		return x.NoStorageDevice
	}
	return nil
}

func (m *GetSpecType) GetStorageDeviceList() *FleetStorageDeviceListType {
	if x, ok := m.GetStorageDeviceChoice().(*GetSpecType_StorageDeviceList); ok {
		return x.StorageDeviceList
	}
	return nil
}

func (m *GetSpecType) GetDefaultStorageClass() *ves_io_schema4.Empty {
	if x, ok := m.GetStorageClassChoice().(*GetSpecType_DefaultStorageClass); ok {
		return x.DefaultStorageClass
	}
	return nil
}

func (m *GetSpecType) GetStorageClassList() *FleetStorageClassListType {
	if x, ok := m.GetStorageClassChoice().(*GetSpecType_StorageClassList); ok {
		return x.StorageClassList
	}
	return nil
}

func (m *GetSpecType) GetNoDcClusterGroup() *ves_io_schema4.Empty {
	if x, ok := m.GetDcClusterGroupChoice().(*GetSpecType_NoDcClusterGroup); ok {
		return x.NoDcClusterGroup
	}
	return nil
}

func (m *GetSpecType) GetDcClusterGroup() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetDcClusterGroupChoice().(*GetSpecType_DcClusterGroup); ok {
		return x.DcClusterGroup
	}
	return nil
}

func (m *GetSpecType) GetDcClusterGroupInside() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetDcClusterGroupChoice().(*GetSpecType_DcClusterGroupInside); ok {
		return x.DcClusterGroupInside
	}
	return nil
}

func (m *GetSpecType) GetDisableGpu() *ves_io_schema4.Empty {
	if x, ok := m.GetGpuChoice().(*GetSpecType_DisableGpu); ok {
		return x.DisableGpu
	}
	return nil
}

func (m *GetSpecType) GetEnableGpu() *ves_io_schema4.Empty {
	if x, ok := m.GetGpuChoice().(*GetSpecType_EnableGpu); ok {
		return x.EnableGpu
	}
	return nil
}

func (m *GetSpecType) GetNoStorageStaticRoutes() *ves_io_schema4.Empty {
	if x, ok := m.GetStorageStaticRoutesChoice().(*GetSpecType_NoStorageStaticRoutes); ok {
		return x.NoStorageStaticRoutes
	}
	return nil
}

func (m *GetSpecType) GetStorageStaticRoutes() *FleetStorageStaticRoutesListType {
	if x, ok := m.GetStorageStaticRoutesChoice().(*GetSpecType_StorageStaticRoutes); ok {
		return x.StorageStaticRoutes
	}
	return nil
}

func (m *GetSpecType) GetEnableDefaultFleetConfigDownload() bool {
	if m != nil {
		return m.EnableDefaultFleetConfigDownload
	}
	return false
}

func (m *GetSpecType) GetLogsStreamingDisabled() *ves_io_schema4.Empty {
	if x, ok := m.GetLogsReceiverChoice().(*GetSpecType_LogsStreamingDisabled); ok {
		return x.LogsStreamingDisabled
	}
	return nil
}

func (m *GetSpecType) GetLogReceiver() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetLogsReceiverChoice().(*GetSpecType_LogReceiver); ok {
		return x.LogReceiver
	}
	return nil
}

func (m *GetSpecType) GetDenyAllUsb() *ves_io_schema4.Empty {
	if x, ok := m.GetUsbPolicyChoice().(*GetSpecType_DenyAllUsb); ok {
		return x.DenyAllUsb
	}
	return nil
}

func (m *GetSpecType) GetAllowAllUsb() *ves_io_schema4.Empty {
	if x, ok := m.GetUsbPolicyChoice().(*GetSpecType_AllowAllUsb); ok {
		return x.AllowAllUsb
	}
	return nil
}

func (m *GetSpecType) GetUsbPolicy() *ves_io_schema_views.ObjectRefType {
	if x, ok := m.GetUsbPolicyChoice().(*GetSpecType_UsbPolicy); ok {
		return x.UsbPolicy
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetSpecType_OneofMarshaler, _GetSpecType_OneofUnmarshaler, _GetSpecType_OneofSizer, []interface{}{
		(*GetSpecType_InterfaceList)(nil),
		(*GetSpecType_DefaultConfig)(nil),
		(*GetSpecType_DeviceList)(nil),
		(*GetSpecType_NoBondDevices)(nil),
		(*GetSpecType_BondDeviceList)(nil),
		(*GetSpecType_NoStorageInterfaces)(nil),
		(*GetSpecType_StorageInterfaceList)(nil),
		(*GetSpecType_NoStorageDevice)(nil),
		(*GetSpecType_StorageDeviceList)(nil),
		(*GetSpecType_DefaultStorageClass)(nil),
		(*GetSpecType_StorageClassList)(nil),
		(*GetSpecType_NoDcClusterGroup)(nil),
		(*GetSpecType_DcClusterGroup)(nil),
		(*GetSpecType_DcClusterGroupInside)(nil),
		(*GetSpecType_DisableGpu)(nil),
		(*GetSpecType_EnableGpu)(nil),
		(*GetSpecType_NoStorageStaticRoutes)(nil),
		(*GetSpecType_StorageStaticRoutes)(nil),
		(*GetSpecType_LogsStreamingDisabled)(nil),
		(*GetSpecType_LogReceiver)(nil),
		(*GetSpecType_DenyAllUsb)(nil),
		(*GetSpecType_AllowAllUsb)(nil),
		(*GetSpecType_UsbPolicy)(nil),
	}
}

func _GetSpecType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetSpecType)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *GetSpecType_InterfaceList:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InterfaceList); err != nil {
			return err
		}
	case *GetSpecType_DefaultConfig:
		_ = b.EncodeVarint(40<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DefaultConfig); err != nil {
			return err
		}
	case *GetSpecType_DeviceList:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DeviceList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.InterfaceChoice has unexpected type %T", x)
	}
	// bond_choice
	switch x := m.BondChoice.(type) {
	case *GetSpecType_NoBondDevices:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoBondDevices); err != nil {
			return err
		}
	case *GetSpecType_BondDeviceList:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BondDeviceList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.BondChoice has unexpected type %T", x)
	}
	// storage_interface_choice
	switch x := m.StorageInterfaceChoice.(type) {
	case *GetSpecType_NoStorageInterfaces:
		_ = b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoStorageInterfaces); err != nil {
			return err
		}
	case *GetSpecType_StorageInterfaceList:
		_ = b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageInterfaceList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.StorageInterfaceChoice has unexpected type %T", x)
	}
	// storage_device_choice
	switch x := m.StorageDeviceChoice.(type) {
	case *GetSpecType_NoStorageDevice:
		_ = b.EncodeVarint(22<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoStorageDevice); err != nil {
			return err
		}
	case *GetSpecType_StorageDeviceList:
		_ = b.EncodeVarint(23<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageDeviceList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.StorageDeviceChoice has unexpected type %T", x)
	}
	// storage_class_choice
	switch x := m.StorageClassChoice.(type) {
	case *GetSpecType_DefaultStorageClass:
		_ = b.EncodeVarint(25<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DefaultStorageClass); err != nil {
			return err
		}
	case *GetSpecType_StorageClassList:
		_ = b.EncodeVarint(26<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageClassList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.StorageClassChoice has unexpected type %T", x)
	}
	// dc_cluster_group_choice
	switch x := m.DcClusterGroupChoice.(type) {
	case *GetSpecType_NoDcClusterGroup:
		_ = b.EncodeVarint(28<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoDcClusterGroup); err != nil {
			return err
		}
	case *GetSpecType_DcClusterGroup:
		_ = b.EncodeVarint(29<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DcClusterGroup); err != nil {
			return err
		}
	case *GetSpecType_DcClusterGroupInside:
		_ = b.EncodeVarint(38<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DcClusterGroupInside); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.DcClusterGroupChoice has unexpected type %T", x)
	}
	// gpu_choice
	switch x := m.GpuChoice.(type) {
	case *GetSpecType_DisableGpu:
		_ = b.EncodeVarint(31<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DisableGpu); err != nil {
			return err
		}
	case *GetSpecType_EnableGpu:
		_ = b.EncodeVarint(32<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EnableGpu); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.GpuChoice has unexpected type %T", x)
	}
	// storage_static_routes_choice
	switch x := m.StorageStaticRoutesChoice.(type) {
	case *GetSpecType_NoStorageStaticRoutes:
		_ = b.EncodeVarint(35<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NoStorageStaticRoutes); err != nil {
			return err
		}
	case *GetSpecType_StorageStaticRoutes:
		_ = b.EncodeVarint(36<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageStaticRoutes); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.StorageStaticRoutesChoice has unexpected type %T", x)
	}
	// logs_receiver_choice
	switch x := m.LogsReceiverChoice.(type) {
	case *GetSpecType_LogsStreamingDisabled:
		_ = b.EncodeVarint(44<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogsStreamingDisabled); err != nil {
			return err
		}
	case *GetSpecType_LogReceiver:
		_ = b.EncodeVarint(45<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogReceiver); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.LogsReceiverChoice has unexpected type %T", x)
	}
	// usb_policy_choice
	switch x := m.UsbPolicyChoice.(type) {
	case *GetSpecType_DenyAllUsb:
		_ = b.EncodeVarint(47<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DenyAllUsb); err != nil {
			return err
		}
	case *GetSpecType_AllowAllUsb:
		_ = b.EncodeVarint(48<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AllowAllUsb); err != nil {
			return err
		}
	case *GetSpecType_UsbPolicy:
		_ = b.EncodeVarint(49<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UsbPolicy); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSpecType.UsbPolicyChoice has unexpected type %T", x)
	}
	return nil
}

func _GetSpecType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetSpecType)
	switch tag {
	case 13: // interface_choice.interface_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetInterfaceListType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &GetSpecType_InterfaceList{msg}
		return true, err
	case 40: // interface_choice.default_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &GetSpecType_DefaultConfig{msg}
		return true, err
	case 14: // interface_choice.device_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetDeviceListType)
		err := b.DecodeMessage(msg)
		m.InterfaceChoice = &GetSpecType_DeviceList{msg}
		return true, err
	case 16: // bond_choice.no_bond_devices
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.BondChoice = &GetSpecType_NoBondDevices{msg}
		return true, err
	case 17: // bond_choice.bond_device_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetBondDevicesListType)
		err := b.DecodeMessage(msg)
		m.BondChoice = &GetSpecType_BondDeviceList{msg}
		return true, err
	case 19: // storage_interface_choice.no_storage_interfaces
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.StorageInterfaceChoice = &GetSpecType_NoStorageInterfaces{msg}
		return true, err
	case 20: // storage_interface_choice.storage_interface_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetInterfaceListType)
		err := b.DecodeMessage(msg)
		m.StorageInterfaceChoice = &GetSpecType_StorageInterfaceList{msg}
		return true, err
	case 22: // storage_device_choice.no_storage_device
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.StorageDeviceChoice = &GetSpecType_NoStorageDevice{msg}
		return true, err
	case 23: // storage_device_choice.storage_device_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetStorageDeviceListType)
		err := b.DecodeMessage(msg)
		m.StorageDeviceChoice = &GetSpecType_StorageDeviceList{msg}
		return true, err
	case 25: // storage_class_choice.default_storage_class
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.StorageClassChoice = &GetSpecType_DefaultStorageClass{msg}
		return true, err
	case 26: // storage_class_choice.storage_class_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetStorageClassListType)
		err := b.DecodeMessage(msg)
		m.StorageClassChoice = &GetSpecType_StorageClassList{msg}
		return true, err
	case 28: // dc_cluster_group_choice.no_dc_cluster_group
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.DcClusterGroupChoice = &GetSpecType_NoDcClusterGroup{msg}
		return true, err
	case 29: // dc_cluster_group_choice.dc_cluster_group
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.DcClusterGroupChoice = &GetSpecType_DcClusterGroup{msg}
		return true, err
	case 38: // dc_cluster_group_choice.dc_cluster_group_inside
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.DcClusterGroupChoice = &GetSpecType_DcClusterGroupInside{msg}
		return true, err
	case 31: // gpu_choice.disable_gpu
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.GpuChoice = &GetSpecType_DisableGpu{msg}
		return true, err
	case 32: // gpu_choice.enable_gpu
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.GpuChoice = &GetSpecType_EnableGpu{msg}
		return true, err
	case 35: // storage_static_routes_choice.no_storage_static_routes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.StorageStaticRoutesChoice = &GetSpecType_NoStorageStaticRoutes{msg}
		return true, err
	case 36: // storage_static_routes_choice.storage_static_routes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FleetStorageStaticRoutesListType)
		err := b.DecodeMessage(msg)
		m.StorageStaticRoutesChoice = &GetSpecType_StorageStaticRoutes{msg}
		return true, err
	case 44: // logs_receiver_choice.logs_streaming_disabled
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.LogsReceiverChoice = &GetSpecType_LogsStreamingDisabled{msg}
		return true, err
	case 45: // logs_receiver_choice.log_receiver
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.LogsReceiverChoice = &GetSpecType_LogReceiver{msg}
		return true, err
	case 47: // usb_policy_choice.deny_all_usb
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.UsbPolicyChoice = &GetSpecType_DenyAllUsb{msg}
		return true, err
	case 48: // usb_policy_choice.allow_all_usb
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema4.Empty)
		err := b.DecodeMessage(msg)
		m.UsbPolicyChoice = &GetSpecType_AllowAllUsb{msg}
		return true, err
	case 49: // usb_policy_choice.usb_policy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ves_io_schema_views.ObjectRefType)
		err := b.DecodeMessage(msg)
		m.UsbPolicyChoice = &GetSpecType_UsbPolicy{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GetSpecType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetSpecType)
	// interface_choice
	switch x := m.InterfaceChoice.(type) {
	case *GetSpecType_InterfaceList:
		s := proto.Size(x.InterfaceList)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_DefaultConfig:
		s := proto.Size(x.DefaultConfig)
		n += proto.SizeVarint(40<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_DeviceList:
		s := proto.Size(x.DeviceList)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// bond_choice
	switch x := m.BondChoice.(type) {
	case *GetSpecType_NoBondDevices:
		s := proto.Size(x.NoBondDevices)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_BondDeviceList:
		s := proto.Size(x.BondDeviceList)
		n += proto.SizeVarint(17<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// storage_interface_choice
	switch x := m.StorageInterfaceChoice.(type) {
	case *GetSpecType_NoStorageInterfaces:
		s := proto.Size(x.NoStorageInterfaces)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_StorageInterfaceList:
		s := proto.Size(x.StorageInterfaceList)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// storage_device_choice
	switch x := m.StorageDeviceChoice.(type) {
	case *GetSpecType_NoStorageDevice:
		s := proto.Size(x.NoStorageDevice)
		n += proto.SizeVarint(22<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_StorageDeviceList:
		s := proto.Size(x.StorageDeviceList)
		n += proto.SizeVarint(23<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// storage_class_choice
	switch x := m.StorageClassChoice.(type) {
	case *GetSpecType_DefaultStorageClass:
		s := proto.Size(x.DefaultStorageClass)
		n += proto.SizeVarint(25<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_StorageClassList:
		s := proto.Size(x.StorageClassList)
		n += proto.SizeVarint(26<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// dc_cluster_group_choice
	switch x := m.DcClusterGroupChoice.(type) {
	case *GetSpecType_NoDcClusterGroup:
		s := proto.Size(x.NoDcClusterGroup)
		n += proto.SizeVarint(28<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_DcClusterGroup:
		s := proto.Size(x.DcClusterGroup)
		n += proto.SizeVarint(29<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_DcClusterGroupInside:
		s := proto.Size(x.DcClusterGroupInside)
		n += proto.SizeVarint(38<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// gpu_choice
	switch x := m.GpuChoice.(type) {
	case *GetSpecType_DisableGpu:
		s := proto.Size(x.DisableGpu)
		n += proto.SizeVarint(31<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_EnableGpu:
		s := proto.Size(x.EnableGpu)
		n += proto.SizeVarint(32<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// storage_static_routes_choice
	switch x := m.StorageStaticRoutesChoice.(type) {
	case *GetSpecType_NoStorageStaticRoutes:
		s := proto.Size(x.NoStorageStaticRoutes)
		n += proto.SizeVarint(35<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_StorageStaticRoutes:
		s := proto.Size(x.StorageStaticRoutes)
		n += proto.SizeVarint(36<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// logs_receiver_choice
	switch x := m.LogsReceiverChoice.(type) {
	case *GetSpecType_LogsStreamingDisabled:
		s := proto.Size(x.LogsStreamingDisabled)
		n += proto.SizeVarint(44<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_LogReceiver:
		s := proto.Size(x.LogReceiver)
		n += proto.SizeVarint(45<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// usb_policy_choice
	switch x := m.UsbPolicyChoice.(type) {
	case *GetSpecType_DenyAllUsb:
		s := proto.Size(x.DenyAllUsb)
		n += proto.SizeVarint(47<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_AllowAllUsb:
		s := proto.Size(x.AllowAllUsb)
		n += proto.SizeVarint(48<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSpecType_UsbPolicy:
		s := proto.Size(x.UsbPolicy)
		n += proto.SizeVarint(49<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Fleet Status
//
// x-displayName: "Fleet Status"
// Current status of fleet
type FleetStatus struct {
	// Software Version
	//
	// x-displayName: "Software Version"
	// Current software version used by the site
	AvailableSoftwareVersion string `protobuf:"bytes,1,opt,name=available_software_version,json=availableSoftwareVersion,proto3" json:"available_software_version,omitempty"`
}

func (m *FleetStatus) Reset()                    { *m = FleetStatus{} }
func (*FleetStatus) ProtoMessage()               {}
func (*FleetStatus) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{40} }

func (m *FleetStatus) GetAvailableSoftwareVersion() string {
	if m != nil {
		return m.AvailableSoftwareVersion
	}
	return ""
}

func init() {
	proto.RegisterType((*NetworkingDeviceInstanceType)(nil), "ves.io.schema.fleet.NetworkingDeviceInstanceType")
	golang_proto.RegisterType((*NetworkingDeviceInstanceType)(nil), "ves.io.schema.fleet.NetworkingDeviceInstanceType")
	proto.RegisterType((*GenericDeviceInstanceType)(nil), "ves.io.schema.fleet.GenericDeviceInstanceType")
	golang_proto.RegisterType((*GenericDeviceInstanceType)(nil), "ves.io.schema.fleet.GenericDeviceInstanceType")
	proto.RegisterType((*DeviceInstanceType)(nil), "ves.io.schema.fleet.DeviceInstanceType")
	golang_proto.RegisterType((*DeviceInstanceType)(nil), "ves.io.schema.fleet.DeviceInstanceType")
	proto.RegisterType((*FleetInterfaceListType)(nil), "ves.io.schema.fleet.FleetInterfaceListType")
	golang_proto.RegisterType((*FleetInterfaceListType)(nil), "ves.io.schema.fleet.FleetInterfaceListType")
	proto.RegisterType((*FleetDeviceListType)(nil), "ves.io.schema.fleet.FleetDeviceListType")
	golang_proto.RegisterType((*FleetDeviceListType)(nil), "ves.io.schema.fleet.FleetDeviceListType")
	proto.RegisterType((*StorageDeviceOpenebsEnterpriseType)(nil), "ves.io.schema.fleet.StorageDeviceOpenebsEnterpriseType")
	golang_proto.RegisterType((*StorageDeviceOpenebsEnterpriseType)(nil), "ves.io.schema.fleet.StorageDeviceOpenebsEnterpriseType")
	proto.RegisterType((*OpenebsMayastorPoolType)(nil), "ves.io.schema.fleet.OpenebsMayastorPoolType")
	golang_proto.RegisterType((*OpenebsMayastorPoolType)(nil), "ves.io.schema.fleet.OpenebsMayastorPoolType")
	proto.RegisterType((*StorageDeviceDellIsilonF800Type)(nil), "ves.io.schema.fleet.StorageDeviceDellIsilonF800Type")
	golang_proto.RegisterType((*StorageDeviceDellIsilonF800Type)(nil), "ves.io.schema.fleet.StorageDeviceDellIsilonF800Type")
	proto.RegisterType((*StorageDeviceHPENimbusStorageAf40Type)(nil), "ves.io.schema.fleet.StorageDeviceHPENimbusStorageAf40Type")
	golang_proto.RegisterType((*StorageDeviceHPENimbusStorageAf40Type)(nil), "ves.io.schema.fleet.StorageDeviceHPENimbusStorageAf40Type")
	proto.RegisterType((*StorageDevicePureStorageServiceOrchestratorType)(nil), "ves.io.schema.fleet.StorageDevicePureStorageServiceOrchestratorType")
	golang_proto.RegisterType((*StorageDevicePureStorageServiceOrchestratorType)(nil), "ves.io.schema.fleet.StorageDevicePureStorageServiceOrchestratorType")
	proto.RegisterType((*PsoArrayConfiguration)(nil), "ves.io.schema.fleet.PsoArrayConfiguration")
	golang_proto.RegisterType((*PsoArrayConfiguration)(nil), "ves.io.schema.fleet.PsoArrayConfiguration")
	proto.RegisterType((*FlashBladeType)(nil), "ves.io.schema.fleet.FlashBladeType")
	golang_proto.RegisterType((*FlashBladeType)(nil), "ves.io.schema.fleet.FlashBladeType")
	proto.RegisterType((*FlashBladeEndpoint)(nil), "ves.io.schema.fleet.FlashBladeEndpoint")
	golang_proto.RegisterType((*FlashBladeEndpoint)(nil), "ves.io.schema.fleet.FlashBladeEndpoint")
	proto.RegisterType((*FlashArrayType)(nil), "ves.io.schema.fleet.FlashArrayType")
	golang_proto.RegisterType((*FlashArrayType)(nil), "ves.io.schema.fleet.FlashArrayType")
	proto.RegisterType((*FlashArrayEndpoint)(nil), "ves.io.schema.fleet.FlashArrayEndpoint")
	golang_proto.RegisterType((*FlashArrayEndpoint)(nil), "ves.io.schema.fleet.FlashArrayEndpoint")
	proto.RegisterType((*StorageDeviceNetappTridentType)(nil), "ves.io.schema.fleet.StorageDeviceNetappTridentType")
	golang_proto.RegisterType((*StorageDeviceNetappTridentType)(nil), "ves.io.schema.fleet.StorageDeviceNetappTridentType")
	proto.RegisterType((*StorageDeviceNetappBackendOntapSanType)(nil), "ves.io.schema.fleet.StorageDeviceNetappBackendOntapSanType")
	golang_proto.RegisterType((*StorageDeviceNetappBackendOntapSanType)(nil), "ves.io.schema.fleet.StorageDeviceNetappBackendOntapSanType")
	proto.RegisterType((*DeviceNetappBackendOntapSanChapType)(nil), "ves.io.schema.fleet.DeviceNetappBackendOntapSanChapType")
	golang_proto.RegisterType((*DeviceNetappBackendOntapSanChapType)(nil), "ves.io.schema.fleet.DeviceNetappBackendOntapSanChapType")
	proto.RegisterType((*StorageDeviceNetappBackendOntapNasType)(nil), "ves.io.schema.fleet.StorageDeviceNetappBackendOntapNasType")
	golang_proto.RegisterType((*StorageDeviceNetappBackendOntapNasType)(nil), "ves.io.schema.fleet.StorageDeviceNetappBackendOntapNasType")
	proto.RegisterType((*OntapVolumeDefaults)(nil), "ves.io.schema.fleet.OntapVolumeDefaults")
	golang_proto.RegisterType((*OntapVolumeDefaults)(nil), "ves.io.schema.fleet.OntapVolumeDefaults")
	proto.RegisterType((*OntapVirtualStoragePoolType)(nil), "ves.io.schema.fleet.OntapVirtualStoragePoolType")
	golang_proto.RegisterType((*OntapVirtualStoragePoolType)(nil), "ves.io.schema.fleet.OntapVirtualStoragePoolType")
	proto.RegisterType((*FleetStorageDeviceType)(nil), "ves.io.schema.fleet.FleetStorageDeviceType")
	golang_proto.RegisterType((*FleetStorageDeviceType)(nil), "ves.io.schema.fleet.FleetStorageDeviceType")
	proto.RegisterType((*FleetStorageDeviceListType)(nil), "ves.io.schema.fleet.FleetStorageDeviceListType")
	golang_proto.RegisterType((*FleetStorageDeviceListType)(nil), "ves.io.schema.fleet.FleetStorageDeviceListType")
	proto.RegisterType((*StorageClassDellIsilonF800Type)(nil), "ves.io.schema.fleet.StorageClassDellIsilonF800Type")
	golang_proto.RegisterType((*StorageClassDellIsilonF800Type)(nil), "ves.io.schema.fleet.StorageClassDellIsilonF800Type")
	proto.RegisterType((*StorageClassHPENimbusStorageAf40Type)(nil), "ves.io.schema.fleet.StorageClassHPENimbusStorageAf40Type")
	golang_proto.RegisterType((*StorageClassHPENimbusStorageAf40Type)(nil), "ves.io.schema.fleet.StorageClassHPENimbusStorageAf40Type")
	proto.RegisterType((*StorageClassOpenebsEnterpriseType)(nil), "ves.io.schema.fleet.StorageClassOpenebsEnterpriseType")
	golang_proto.RegisterType((*StorageClassOpenebsEnterpriseType)(nil), "ves.io.schema.fleet.StorageClassOpenebsEnterpriseType")
	proto.RegisterType((*StorageClassNetappTridentType)(nil), "ves.io.schema.fleet.StorageClassNetappTridentType")
	golang_proto.RegisterType((*StorageClassNetappTridentType)(nil), "ves.io.schema.fleet.StorageClassNetappTridentType")
	proto.RegisterType((*StorageClassPureServiceOrchestratorType)(nil), "ves.io.schema.fleet.StorageClassPureServiceOrchestratorType")
	golang_proto.RegisterType((*StorageClassPureServiceOrchestratorType)(nil), "ves.io.schema.fleet.StorageClassPureServiceOrchestratorType")
	proto.RegisterType((*FleetStorageClassType)(nil), "ves.io.schema.fleet.FleetStorageClassType")
	golang_proto.RegisterType((*FleetStorageClassType)(nil), "ves.io.schema.fleet.FleetStorageClassType")
	proto.RegisterType((*FleetStorageClassListType)(nil), "ves.io.schema.fleet.FleetStorageClassListType")
	golang_proto.RegisterType((*FleetStorageClassListType)(nil), "ves.io.schema.fleet.FleetStorageClassListType")
	proto.RegisterType((*BondLacpType)(nil), "ves.io.schema.fleet.BondLacpType")
	golang_proto.RegisterType((*BondLacpType)(nil), "ves.io.schema.fleet.BondLacpType")
	proto.RegisterType((*FleetBondDeviceType)(nil), "ves.io.schema.fleet.FleetBondDeviceType")
	golang_proto.RegisterType((*FleetBondDeviceType)(nil), "ves.io.schema.fleet.FleetBondDeviceType")
	proto.RegisterType((*FleetBondDevicesListType)(nil), "ves.io.schema.fleet.FleetBondDevicesListType")
	golang_proto.RegisterType((*FleetBondDevicesListType)(nil), "ves.io.schema.fleet.FleetBondDevicesListType")
	proto.RegisterType((*FleetStorageStaticRoutesListType)(nil), "ves.io.schema.fleet.FleetStorageStaticRoutesListType")
	golang_proto.RegisterType((*FleetStorageStaticRoutesListType)(nil), "ves.io.schema.fleet.FleetStorageStaticRoutesListType")
	proto.RegisterType((*BGPConfiguration)(nil), "ves.io.schema.fleet.BGPConfiguration")
	golang_proto.RegisterType((*BGPConfiguration)(nil), "ves.io.schema.fleet.BGPConfiguration")
	proto.RegisterType((*LocalControlPlaneType)(nil), "ves.io.schema.fleet.LocalControlPlaneType")
	golang_proto.RegisterType((*LocalControlPlaneType)(nil), "ves.io.schema.fleet.LocalControlPlaneType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.fleet.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.fleet.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.fleet.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.fleet.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.fleet.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.fleet.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.fleet.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.fleet.GetSpecType")
	proto.RegisterType((*FleetStatus)(nil), "ves.io.schema.fleet.FleetStatus")
	golang_proto.RegisterType((*FleetStatus)(nil), "ves.io.schema.fleet.FleetStatus")
	proto.RegisterEnum("ves.io.schema.fleet.EtcdClusterNetworkType", EtcdClusterNetworkType_name, EtcdClusterNetworkType_value)
	golang_proto.RegisterEnum("ves.io.schema.fleet.EtcdClusterNetworkType", EtcdClusterNetworkType_name, EtcdClusterNetworkType_value)
	proto.RegisterEnum("ves.io.schema.fleet.DeviceOwnerType", DeviceOwnerType_name, DeviceOwnerType_value)
	golang_proto.RegisterEnum("ves.io.schema.fleet.DeviceOwnerType", DeviceOwnerType_name, DeviceOwnerType_value)
	proto.RegisterEnum("ves.io.schema.fleet.FleetType", FleetType_name, FleetType_value)
	golang_proto.RegisterEnum("ves.io.schema.fleet.FleetType", FleetType_name, FleetType_value)
	proto.RegisterEnum("ves.io.schema.fleet.NetworkingDeviceInstanceUseType", NetworkingDeviceInstanceUseType_name, NetworkingDeviceInstanceUseType_value)
	golang_proto.RegisterEnum("ves.io.schema.fleet.NetworkingDeviceInstanceUseType", NetworkingDeviceInstanceUseType_name, NetworkingDeviceInstanceUseType_value)
}
func (x EtcdClusterNetworkType) String() string {
	s, ok := EtcdClusterNetworkType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DeviceOwnerType) String() string {
	s, ok := DeviceOwnerType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x FleetType) String() string {
	s, ok := FleetType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NetworkingDeviceInstanceUseType) String() string {
	s, ok := NetworkingDeviceInstanceUseType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *NetworkingDeviceInstanceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkingDeviceInstanceType)
	if !ok {
		that2, ok := that.(NetworkingDeviceInstanceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Interface) != len(that1.Interface) {
		return false
	}
	for i := range this.Interface {
		if !this.Interface[i].Equal(that1.Interface[i]) {
			return false
		}
	}
	if this.Use != that1.Use {
		return false
	}
	return true
}
func (this *GenericDeviceInstanceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GenericDeviceInstanceType)
	if !ok {
		that2, ok := that.(GenericDeviceInstanceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *DeviceInstanceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeviceInstanceType)
	if !ok {
		that2, ok := that.(DeviceInstanceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Owner != that1.Owner {
		return false
	}
	if that1.DeviceInstance == nil {
		if this.DeviceInstance != nil {
			return false
		}
	} else if this.DeviceInstance == nil {
		return false
	} else if !this.DeviceInstance.Equal(that1.DeviceInstance) {
		return false
	}
	return true
}
func (this *DeviceInstanceType_NetworkDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeviceInstanceType_NetworkDevice)
	if !ok {
		that2, ok := that.(DeviceInstanceType_NetworkDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NetworkDevice.Equal(that1.NetworkDevice) {
		return false
	}
	return true
}
func (this *FleetInterfaceListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetInterfaceListType)
	if !ok {
		that2, ok := that.(FleetInterfaceListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Interfaces) != len(that1.Interfaces) {
		return false
	}
	for i := range this.Interfaces {
		if !this.Interfaces[i].Equal(that1.Interfaces[i]) {
			return false
		}
	}
	return true
}
func (this *FleetDeviceListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetDeviceListType)
	if !ok {
		that2, ok := that.(FleetDeviceListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Devices) != len(that1.Devices) {
		return false
	}
	for i := range this.Devices {
		if !this.Devices[i].Equal(that1.Devices[i]) {
			return false
		}
	}
	return true
}
func (this *StorageDeviceOpenebsEnterpriseType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceOpenebsEnterpriseType)
	if !ok {
		that2, ok := that.(StorageDeviceOpenebsEnterpriseType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.MayastorPools) != len(that1.MayastorPools) {
		return false
	}
	for i := range this.MayastorPools {
		if !this.MayastorPools[i].Equal(that1.MayastorPools[i]) {
			return false
		}
	}
	return true
}
func (this *OpenebsMayastorPoolType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OpenebsMayastorPoolType)
	if !ok {
		that2, ok := that.(OpenebsMayastorPoolType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PoolName != that1.PoolName {
		return false
	}
	if this.Node != that1.Node {
		return false
	}
	if len(this.PoolDiskDevices) != len(that1.PoolDiskDevices) {
		return false
	}
	for i := range this.PoolDiskDevices {
		if this.PoolDiskDevices[i] != that1.PoolDiskDevices[i] {
			return false
		}
	}
	return true
}
func (this *StorageDeviceDellIsilonF800Type) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceDellIsilonF800Type)
	if !ok {
		that2, ok := that.(StorageDeviceDellIsilonF800Type)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if !this.Password.Equal(that1.Password) {
		return false
	}
	if that1.HttpsChoice == nil {
		if this.HttpsChoice != nil {
			return false
		}
	} else if this.HttpsChoice == nil {
		return false
	} else if !this.HttpsChoice.Equal(that1.HttpsChoice) {
		return false
	}
	if that1.AddressChoice == nil {
		if this.AddressChoice != nil {
			return false
		}
	} else if this.AddressChoice == nil {
		return false
	} else if !this.AddressChoice.Equal(that1.AddressChoice) {
		return false
	}
	if this.ApiServerPort != that1.ApiServerPort {
		return false
	}
	if this.IscsiAccessZone != that1.IscsiAccessZone {
		return false
	}
	if this.VolumePrefix != that1.VolumePrefix {
		return false
	}
	if this.BasePath != that1.BasePath {
		return false
	}
	return true
}
func (this *StorageDeviceDellIsilonF800Type_SecureNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceDellIsilonF800Type_SecureNetwork)
	if !ok {
		that2, ok := that.(StorageDeviceDellIsilonF800Type_SecureNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SecureNetwork.Equal(that1.SecureNetwork) {
		return false
	}
	return true
}
func (this *StorageDeviceDellIsilonF800Type_TrustedCaUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceDellIsilonF800Type_TrustedCaUrl)
	if !ok {
		that2, ok := that.(StorageDeviceDellIsilonF800Type_TrustedCaUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TrustedCaUrl != that1.TrustedCaUrl {
		return false
	}
	return true
}
func (this *StorageDeviceDellIsilonF800Type_ApiServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceDellIsilonF800Type_ApiServerName)
	if !ok {
		that2, ok := that.(StorageDeviceDellIsilonF800Type_ApiServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ApiServerName != that1.ApiServerName {
		return false
	}
	return true
}
func (this *StorageDeviceDellIsilonF800Type_ApiServerIpAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceDellIsilonF800Type_ApiServerIpAddress)
	if !ok {
		that2, ok := that.(StorageDeviceDellIsilonF800Type_ApiServerIpAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ApiServerIpAddress != that1.ApiServerIpAddress {
		return false
	}
	return true
}
func (this *StorageDeviceHPENimbusStorageAf40Type) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceHPENimbusStorageAf40Type)
	if !ok {
		that2, ok := that.(StorageDeviceHPENimbusStorageAf40Type)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StorageServerName != that1.StorageServerName {
		return false
	}
	if this.StorageServerIpAddress != that1.StorageServerIpAddress {
		return false
	}
	if this.ApiServerPort != that1.ApiServerPort {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if !this.Password.Equal(that1.Password) {
		return false
	}
	if this.PerfPolicy != that1.PerfPolicy {
		return false
	}
	if this.LimitIops != that1.LimitIops {
		return false
	}
	if this.LimitMbps != that1.LimitMbps {
		return false
	}
	return true
}
func (this *StorageDevicePureStorageServiceOrchestratorType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDevicePureStorageServiceOrchestratorType)
	if !ok {
		that2, ok := that.(StorageDevicePureStorageServiceOrchestratorType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClusterId != that1.ClusterId {
		return false
	}
	if this.EnableStorageTopology != that1.EnableStorageTopology {
		return false
	}
	if this.EnableStrictTopology != that1.EnableStrictTopology {
		return false
	}
	if !this.Arrays.Equal(that1.Arrays) {
		return false
	}
	return true
}
func (this *PsoArrayConfiguration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PsoArrayConfiguration)
	if !ok {
		that2, ok := that.(PsoArrayConfiguration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FlashArray.Equal(that1.FlashArray) {
		return false
	}
	if !this.FlashBlade.Equal(that1.FlashBlade) {
		return false
	}
	return true
}
func (this *FlashBladeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashBladeType)
	if !ok {
		that2, ok := that.(FlashBladeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EnableSnapshotDirectory != that1.EnableSnapshotDirectory {
		return false
	}
	if this.ExportRules != that1.ExportRules {
		return false
	}
	if len(this.FlashBlades) != len(that1.FlashBlades) {
		return false
	}
	for i := range this.FlashBlades {
		if !this.FlashBlades[i].Equal(that1.FlashBlades[i]) {
			return false
		}
	}
	return true
}
func (this *FlashBladeEndpoint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashBladeEndpoint)
	if !ok {
		that2, ok := that.(FlashBladeEndpoint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.MgmtEndpoint == nil {
		if this.MgmtEndpoint != nil {
			return false
		}
	} else if this.MgmtEndpoint == nil {
		return false
	} else if !this.MgmtEndpoint.Equal(that1.MgmtEndpoint) {
		return false
	}
	if !this.ApiToken.Equal(that1.ApiToken) {
		return false
	}
	if that1.NfsEndpoint == nil {
		if this.NfsEndpoint != nil {
			return false
		}
	} else if this.NfsEndpoint == nil {
		return false
	} else if !this.NfsEndpoint.Equal(that1.NfsEndpoint) {
		return false
	}
	if len(this.Lables) != len(that1.Lables) {
		return false
	}
	for i := range this.Lables {
		if this.Lables[i] != that1.Lables[i] {
			return false
		}
	}
	return true
}
func (this *FlashBladeEndpoint_MgmtIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashBladeEndpoint_MgmtIp)
	if !ok {
		that2, ok := that.(FlashBladeEndpoint_MgmtIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MgmtIp != that1.MgmtIp {
		return false
	}
	return true
}
func (this *FlashBladeEndpoint_MgmtDnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashBladeEndpoint_MgmtDnsName)
	if !ok {
		that2, ok := that.(FlashBladeEndpoint_MgmtDnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MgmtDnsName != that1.MgmtDnsName {
		return false
	}
	return true
}
func (this *FlashBladeEndpoint_NfsEndpointIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashBladeEndpoint_NfsEndpointIp)
	if !ok {
		that2, ok := that.(FlashBladeEndpoint_NfsEndpointIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NfsEndpointIp != that1.NfsEndpointIp {
		return false
	}
	return true
}
func (this *FlashBladeEndpoint_NfsEndpointDnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashBladeEndpoint_NfsEndpointDnsName)
	if !ok {
		that2, ok := that.(FlashBladeEndpoint_NfsEndpointDnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NfsEndpointDnsName != that1.NfsEndpointDnsName {
		return false
	}
	return true
}
func (this *FlashArrayType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashArrayType)
	if !ok {
		that2, ok := that.(FlashArrayType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SanType != that1.SanType {
		return false
	}
	if this.DefaultFsType != that1.DefaultFsType {
		return false
	}
	if this.DefaultFsOpt != that1.DefaultFsOpt {
		return false
	}
	if len(this.DefaultMountOpts) != len(that1.DefaultMountOpts) {
		return false
	}
	for i := range this.DefaultMountOpts {
		if this.DefaultMountOpts[i] != that1.DefaultMountOpts[i] {
			return false
		}
	}
	if this.DisablePreemptAttachments != that1.DisablePreemptAttachments {
		return false
	}
	if this.IscsiLoginTimeout != that1.IscsiLoginTimeout {
		return false
	}
	if len(this.FlashArrays) != len(that1.FlashArrays) {
		return false
	}
	for i := range this.FlashArrays {
		if !this.FlashArrays[i].Equal(that1.FlashArrays[i]) {
			return false
		}
	}
	return true
}
func (this *FlashArrayEndpoint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashArrayEndpoint)
	if !ok {
		that2, ok := that.(FlashArrayEndpoint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.MgmtEndpoint == nil {
		if this.MgmtEndpoint != nil {
			return false
		}
	} else if this.MgmtEndpoint == nil {
		return false
	} else if !this.MgmtEndpoint.Equal(that1.MgmtEndpoint) {
		return false
	}
	if !this.ApiToken.Equal(that1.ApiToken) {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	return true
}
func (this *FlashArrayEndpoint_MgmtIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashArrayEndpoint_MgmtIp)
	if !ok {
		that2, ok := that.(FlashArrayEndpoint_MgmtIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MgmtIp != that1.MgmtIp {
		return false
	}
	return true
}
func (this *FlashArrayEndpoint_MgmtDnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlashArrayEndpoint_MgmtDnsName)
	if !ok {
		that2, ok := that.(FlashArrayEndpoint_MgmtDnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MgmtDnsName != that1.MgmtDnsName {
		return false
	}
	return true
}
func (this *StorageDeviceNetappTridentType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappTridentType)
	if !ok {
		that2, ok := that.(StorageDeviceNetappTridentType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.BackendChoice == nil {
		if this.BackendChoice != nil {
			return false
		}
	} else if this.BackendChoice == nil {
		return false
	} else if !this.BackendChoice.Equal(that1.BackendChoice) {
		return false
	}
	return true
}
func (this *StorageDeviceNetappTridentType_NetappBackendOntapNas) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappTridentType_NetappBackendOntapNas)
	if !ok {
		that2, ok := that.(StorageDeviceNetappTridentType_NetappBackendOntapNas)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NetappBackendOntapNas.Equal(that1.NetappBackendOntapNas) {
		return false
	}
	return true
}
func (this *StorageDeviceNetappTridentType_NetappBackendOntapSan) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappTridentType_NetappBackendOntapSan)
	if !ok {
		that2, ok := that.(StorageDeviceNetappTridentType_NetappBackendOntapSan)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NetappBackendOntapSan.Equal(that1.NetappBackendOntapSan) {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapSanType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapSanType)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapSanType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StorageDriverName != that1.StorageDriverName {
		return false
	}
	if that1.ManagementLif == nil {
		if this.ManagementLif != nil {
			return false
		}
	} else if this.ManagementLif == nil {
		return false
	} else if !this.ManagementLif.Equal(that1.ManagementLif) {
		return false
	}
	if that1.DataLif == nil {
		if this.DataLif != nil {
			return false
		}
	} else if this.DataLif == nil {
		return false
	} else if !this.DataLif.Equal(that1.DataLif) {
		return false
	}
	if this.Svm != that1.Svm {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if !this.Password.Equal(that1.Password) {
		return false
	}
	if that1.ChapChoice == nil {
		if this.ChapChoice != nil {
			return false
		}
	} else if this.ChapChoice == nil {
		return false
	} else if !this.ChapChoice.Equal(that1.ChapChoice) {
		return false
	}
	if this.IgroupName != that1.IgroupName {
		return false
	}
	if this.StoragePrefix != that1.StoragePrefix {
		return false
	}
	if this.LimitAggregateUsage != that1.LimitAggregateUsage {
		return false
	}
	if this.LimitVolumeSize != that1.LimitVolumeSize {
		return false
	}
	if !this.VolumeDefaults.Equal(that1.VolumeDefaults) {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if this.Region != that1.Region {
		return false
	}
	if len(this.Storage) != len(that1.Storage) {
		return false
	}
	for i := range this.Storage {
		if !this.Storage[i].Equal(that1.Storage[i]) {
			return false
		}
	}
	if this.ClientCertificate != that1.ClientCertificate {
		return false
	}
	if !this.ClientPrivateKey.Equal(that1.ClientPrivateKey) {
		return false
	}
	if this.TrustedCaCertificate != that1.TrustedCaCertificate {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapSanType_ManagementLifIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapSanType_ManagementLifIp)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapSanType_ManagementLifIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ManagementLifIp != that1.ManagementLifIp {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ManagementLifDnsName != that1.ManagementLifDnsName {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapSanType_DataLifIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapSanType_DataLifIp)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapSanType_DataLifIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DataLifIp != that1.DataLifIp {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapSanType_DataLifDnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapSanType_DataLifDnsName)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapSanType_DataLifDnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DataLifDnsName != that1.DataLifDnsName {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapSanType_NoChap) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapSanType_NoChap)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapSanType_NoChap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoChap.Equal(that1.NoChap) {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapSanType_UseChap) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapSanType_UseChap)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapSanType_UseChap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseChap.Equal(that1.UseChap) {
		return false
	}
	return true
}
func (this *DeviceNetappBackendOntapSanChapType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeviceNetappBackendOntapSanChapType)
	if !ok {
		that2, ok := that.(DeviceNetappBackendOntapSanChapType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChapUsername != that1.ChapUsername {
		return false
	}
	if this.ChapTargetUsername != that1.ChapTargetUsername {
		return false
	}
	if !this.ChapInitiatorSecret.Equal(that1.ChapInitiatorSecret) {
		return false
	}
	if !this.ChapTargetInitiatorSecret.Equal(that1.ChapTargetInitiatorSecret) {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapNasType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapNasType)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapNasType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StorageDriverName != that1.StorageDriverName {
		return false
	}
	if this.BackendName != that1.BackendName {
		return false
	}
	if that1.ManagementLif == nil {
		if this.ManagementLif != nil {
			return false
		}
	} else if this.ManagementLif == nil {
		return false
	} else if !this.ManagementLif.Equal(that1.ManagementLif) {
		return false
	}
	if that1.DataLif == nil {
		if this.DataLif != nil {
			return false
		}
	} else if this.DataLif == nil {
		return false
	} else if !this.DataLif.Equal(that1.DataLif) {
		return false
	}
	if this.Svm != that1.Svm {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if !this.Password.Equal(that1.Password) {
		return false
	}
	if this.AutoExportPolicy != that1.AutoExportPolicy {
		return false
	}
	if !this.AutoExportCidrs.Equal(that1.AutoExportCidrs) {
		return false
	}
	if this.StoragePrefix != that1.StoragePrefix {
		return false
	}
	if this.LimitAggregateUsage != that1.LimitAggregateUsage {
		return false
	}
	if this.LimitVolumeSize != that1.LimitVolumeSize {
		return false
	}
	if this.NfsMountOptions != that1.NfsMountOptions {
		return false
	}
	if !this.VolumeDefaults.Equal(that1.VolumeDefaults) {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if this.Region != that1.Region {
		return false
	}
	if len(this.Storage) != len(that1.Storage) {
		return false
	}
	for i := range this.Storage {
		if !this.Storage[i].Equal(that1.Storage[i]) {
			return false
		}
	}
	if this.ClientCertificate != that1.ClientCertificate {
		return false
	}
	if !this.ClientPrivateKey.Equal(that1.ClientPrivateKey) {
		return false
	}
	if this.TrustedCaCertificate != that1.TrustedCaCertificate {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapNasType_ManagementLifIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapNasType_ManagementLifIp)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapNasType_ManagementLifIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ManagementLifIp != that1.ManagementLifIp {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ManagementLifDnsName != that1.ManagementLifDnsName {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapNasType_DataLifIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapNasType_DataLifIp)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapNasType_DataLifIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DataLifIp != that1.DataLifIp {
		return false
	}
	return true
}
func (this *StorageDeviceNetappBackendOntapNasType_DataLifDnsName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeviceNetappBackendOntapNasType_DataLifDnsName)
	if !ok {
		that2, ok := that.(StorageDeviceNetappBackendOntapNasType_DataLifDnsName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DataLifDnsName != that1.DataLifDnsName {
		return false
	}
	return true
}
func (this *OntapVolumeDefaults) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OntapVolumeDefaults)
	if !ok {
		that2, ok := that.(OntapVolumeDefaults)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SpaceReserve != that1.SpaceReserve {
		return false
	}
	if this.SnapshotPolicy != that1.SnapshotPolicy {
		return false
	}
	if this.SnapshotReserve != that1.SnapshotReserve {
		return false
	}
	if this.SplitOnClone != that1.SplitOnClone {
		return false
	}
	if this.Encryption != that1.Encryption {
		return false
	}
	if this.UnixPermissions != that1.UnixPermissions {
		return false
	}
	if this.SnapshotDir != that1.SnapshotDir {
		return false
	}
	if this.ExportPolicy != that1.ExportPolicy {
		return false
	}
	if this.SecurityStyle != that1.SecurityStyle {
		return false
	}
	if this.TieringPolicy != that1.TieringPolicy {
		return false
	}
	if that1.QosPolicyChoice == nil {
		if this.QosPolicyChoice != nil {
			return false
		}
	} else if this.QosPolicyChoice == nil {
		return false
	} else if !this.QosPolicyChoice.Equal(that1.QosPolicyChoice) {
		return false
	}
	return true
}
func (this *OntapVolumeDefaults_NoQos) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OntapVolumeDefaults_NoQos)
	if !ok {
		that2, ok := that.(OntapVolumeDefaults_NoQos)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoQos.Equal(that1.NoQos) {
		return false
	}
	return true
}
func (this *OntapVolumeDefaults_QosPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OntapVolumeDefaults_QosPolicy)
	if !ok {
		that2, ok := that.(OntapVolumeDefaults_QosPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.QosPolicy != that1.QosPolicy {
		return false
	}
	return true
}
func (this *OntapVolumeDefaults_AdaptiveQosPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OntapVolumeDefaults_AdaptiveQosPolicy)
	if !ok {
		that2, ok := that.(OntapVolumeDefaults_AdaptiveQosPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AdaptiveQosPolicy != that1.AdaptiveQosPolicy {
		return false
	}
	return true
}
func (this *OntapVirtualStoragePoolType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OntapVirtualStoragePoolType)
	if !ok {
		that2, ok := that.(OntapVirtualStoragePoolType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if this.Zone != that1.Zone {
		return false
	}
	if !this.VolumeDefaults.Equal(that1.VolumeDefaults) {
		return false
	}
	return true
}
func (this *FleetStorageDeviceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageDeviceType)
	if !ok {
		that2, ok := that.(FleetStorageDeviceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StorageDevice != that1.StorageDevice {
		return false
	}
	if that1.DeviceChoice == nil {
		if this.DeviceChoice != nil {
			return false
		}
	} else if this.DeviceChoice == nil {
		return false
	} else if !this.DeviceChoice.Equal(that1.DeviceChoice) {
		return false
	}
	if len(this.AdvancedAdvancedParameters) != len(that1.AdvancedAdvancedParameters) {
		return false
	}
	for i := range this.AdvancedAdvancedParameters {
		if this.AdvancedAdvancedParameters[i] != that1.AdvancedAdvancedParameters[i] {
			return false
		}
	}
	return true
}
func (this *FleetStorageDeviceType_NetappTrident) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageDeviceType_NetappTrident)
	if !ok {
		that2, ok := that.(FleetStorageDeviceType_NetappTrident)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NetappTrident.Equal(that1.NetappTrident) {
		return false
	}
	return true
}
func (this *FleetStorageDeviceType_PureServiceOrchestrator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageDeviceType_PureServiceOrchestrator)
	if !ok {
		that2, ok := that.(FleetStorageDeviceType_PureServiceOrchestrator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PureServiceOrchestrator.Equal(that1.PureServiceOrchestrator) {
		return false
	}
	return true
}
func (this *FleetStorageDeviceType_OpenebsEnterprise) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageDeviceType_OpenebsEnterprise)
	if !ok {
		that2, ok := that.(FleetStorageDeviceType_OpenebsEnterprise)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OpenebsEnterprise.Equal(that1.OpenebsEnterprise) {
		return false
	}
	return true
}
func (this *FleetStorageDeviceListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageDeviceListType)
	if !ok {
		that2, ok := that.(FleetStorageDeviceListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.StorageDevices) != len(that1.StorageDevices) {
		return false
	}
	for i := range this.StorageDevices {
		if !this.StorageDevices[i].Equal(that1.StorageDevices[i]) {
			return false
		}
	}
	return true
}
func (this *StorageClassDellIsilonF800Type) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageClassDellIsilonF800Type)
	if !ok {
		that2, ok := that.(StorageClassDellIsilonF800Type)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.HttpsChoice == nil {
		if this.HttpsChoice != nil {
			return false
		}
	} else if this.HttpsChoice == nil {
		return false
	} else if !this.HttpsChoice.Equal(that1.HttpsChoice) {
		return false
	}
	if this.IscsiAccessZone != that1.IscsiAccessZone {
		return false
	}
	if this.BasePath != that1.BasePath {
		return false
	}
	if this.RootClientEnable != that1.RootClientEnable {
		return false
	}
	return true
}
func (this *StorageClassDellIsilonF800Type_AzServiceName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageClassDellIsilonF800Type_AzServiceName)
	if !ok {
		that2, ok := that.(StorageClassDellIsilonF800Type_AzServiceName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AzServiceName != that1.AzServiceName {
		return false
	}
	return true
}
func (this *StorageClassDellIsilonF800Type_AzServiceIpAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageClassDellIsilonF800Type_AzServiceIpAddress)
	if !ok {
		that2, ok := that.(StorageClassDellIsilonF800Type_AzServiceIpAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AzServiceIpAddress != that1.AzServiceIpAddress {
		return false
	}
	return true
}
func (this *StorageClassHPENimbusStorageAf40Type) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageClassHPENimbusStorageAf40Type)
	if !ok {
		that2, ok := that.(StorageClassHPENimbusStorageAf40Type)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PerfPolicy != that1.PerfPolicy {
		return false
	}
	if this.LimitIops != that1.LimitIops {
		return false
	}
	if this.LimitMbps != that1.LimitMbps {
		return false
	}
	return true
}
func (this *StorageClassOpenebsEnterpriseType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageClassOpenebsEnterpriseType)
	if !ok {
		that2, ok := that.(StorageClassOpenebsEnterpriseType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.Replication != that1.Replication {
		return false
	}
	return true
}
func (this *StorageClassNetappTridentType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageClassNetappTridentType)
	if !ok {
		that2, ok := that.(StorageClassNetappTridentType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Selector) != len(that1.Selector) {
		return false
	}
	for i := range this.Selector {
		if this.Selector[i] != that1.Selector[i] {
			return false
		}
	}
	if this.StoragePools != that1.StoragePools {
		return false
	}
	return true
}
func (this *StorageClassPureServiceOrchestratorType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageClassPureServiceOrchestratorType)
	if !ok {
		that2, ok := that.(StorageClassPureServiceOrchestratorType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Backend != that1.Backend {
		return false
	}
	if this.IopsLimit != that1.IopsLimit {
		return false
	}
	if this.BandwidthLimit != that1.BandwidthLimit {
		return false
	}
	return true
}
func (this *FleetStorageClassType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageClassType)
	if !ok {
		that2, ok := that.(FleetStorageClassType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StorageDevice != that1.StorageDevice {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.DefaultStorageClass != that1.DefaultStorageClass {
		return false
	}
	if that1.DeviceChoice == nil {
		if this.DeviceChoice != nil {
			return false
		}
	} else if this.DeviceChoice == nil {
		return false
	} else if !this.DeviceChoice.Equal(that1.DeviceChoice) {
		return false
	}
	if this.ReclaimPolicy != that1.ReclaimPolicy {
		return false
	}
	if this.AllowVolumeExpansion != that1.AllowVolumeExpansion {
		return false
	}
	if len(this.AdvancedStorageParameters) != len(that1.AdvancedStorageParameters) {
		return false
	}
	for i := range this.AdvancedStorageParameters {
		if this.AdvancedStorageParameters[i] != that1.AdvancedStorageParameters[i] {
			return false
		}
	}
	if this.StorageClassName != that1.StorageClassName {
		return false
	}
	return true
}
func (this *FleetStorageClassType_NetappTrident) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageClassType_NetappTrident)
	if !ok {
		that2, ok := that.(FleetStorageClassType_NetappTrident)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NetappTrident.Equal(that1.NetappTrident) {
		return false
	}
	return true
}
func (this *FleetStorageClassType_PureServiceOrchestrator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageClassType_PureServiceOrchestrator)
	if !ok {
		that2, ok := that.(FleetStorageClassType_PureServiceOrchestrator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PureServiceOrchestrator.Equal(that1.PureServiceOrchestrator) {
		return false
	}
	return true
}
func (this *FleetStorageClassType_OpenebsEnterprise) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageClassType_OpenebsEnterprise)
	if !ok {
		that2, ok := that.(FleetStorageClassType_OpenebsEnterprise)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OpenebsEnterprise.Equal(that1.OpenebsEnterprise) {
		return false
	}
	return true
}
func (this *FleetStorageClassListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageClassListType)
	if !ok {
		that2, ok := that.(FleetStorageClassListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.StorageClasses) != len(that1.StorageClasses) {
		return false
	}
	for i := range this.StorageClasses {
		if !this.StorageClasses[i].Equal(that1.StorageClasses[i]) {
			return false
		}
	}
	return true
}
func (this *BondLacpType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BondLacpType)
	if !ok {
		that2, ok := that.(BondLacpType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Rate != that1.Rate {
		return false
	}
	return true
}
func (this *FleetBondDeviceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetBondDeviceType)
	if !ok {
		that2, ok := that.(FleetBondDeviceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Devices) != len(that1.Devices) {
		return false
	}
	for i := range this.Devices {
		if this.Devices[i] != that1.Devices[i] {
			return false
		}
	}
	if that1.LacpChoice == nil {
		if this.LacpChoice != nil {
			return false
		}
	} else if this.LacpChoice == nil {
		return false
	} else if !this.LacpChoice.Equal(that1.LacpChoice) {
		return false
	}
	if this.LinkPollingInterval != that1.LinkPollingInterval {
		return false
	}
	if this.LinkUpDelay != that1.LinkUpDelay {
		return false
	}
	return true
}
func (this *FleetBondDeviceType_Lacp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetBondDeviceType_Lacp)
	if !ok {
		that2, ok := that.(FleetBondDeviceType_Lacp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Lacp.Equal(that1.Lacp) {
		return false
	}
	return true
}
func (this *FleetBondDeviceType_ActiveBackup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetBondDeviceType_ActiveBackup)
	if !ok {
		that2, ok := that.(FleetBondDeviceType_ActiveBackup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ActiveBackup.Equal(that1.ActiveBackup) {
		return false
	}
	return true
}
func (this *FleetBondDevicesListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetBondDevicesListType)
	if !ok {
		that2, ok := that.(FleetBondDevicesListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.BondDevices) != len(that1.BondDevices) {
		return false
	}
	for i := range this.BondDevices {
		if !this.BondDevices[i].Equal(that1.BondDevices[i]) {
			return false
		}
	}
	return true
}
func (this *FleetStorageStaticRoutesListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStorageStaticRoutesListType)
	if !ok {
		that2, ok := that.(FleetStorageStaticRoutesListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.StorageRoutes) != len(that1.StorageRoutes) {
		return false
	}
	for i := range this.StorageRoutes {
		if !this.StorageRoutes[i].Equal(that1.StorageRoutes[i]) {
			return false
		}
	}
	return true
}
func (this *BGPConfiguration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BGPConfiguration)
	if !ok {
		that2, ok := that.(BGPConfiguration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BgpParameters.Equal(that1.BgpParameters) {
		return false
	}
	if len(this.Peers) != len(that1.Peers) {
		return false
	}
	for i := range this.Peers {
		if !this.Peers[i].Equal(that1.Peers[i]) {
			return false
		}
	}
	return true
}
func (this *LocalControlPlaneType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalControlPlaneType)
	if !ok {
		that2, ok := that.(LocalControlPlaneType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.NetworkChoice == nil {
		if this.NetworkChoice != nil {
			return false
		}
	} else if this.NetworkChoice == nil {
		return false
	} else if !this.NetworkChoice.Equal(that1.NetworkChoice) {
		return false
	}
	if !this.BgpConfig.Equal(that1.BgpConfig) {
		return false
	}
	return true
}
func (this *LocalControlPlaneType_InsideVn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalControlPlaneType_InsideVn)
	if !ok {
		that2, ok := that.(LocalControlPlaneType_InsideVn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InsideVn.Equal(that1.InsideVn) {
		return false
	}
	return true
}
func (this *LocalControlPlaneType_OutsideVn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalControlPlaneType_OutsideVn)
	if !ok {
		that2, ok := that.(LocalControlPlaneType_OutsideVn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OutsideVn.Equal(that1.OutsideVn) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FleetLabel != that1.FleetLabel {
		return false
	}
	if this.VolterraSoftwareVersion != that1.VolterraSoftwareVersion {
		return false
	}
	if len(this.Devices) != len(that1.Devices) {
		return false
	}
	for i := range this.Devices {
		if !this.Devices[i].Equal(that1.Devices[i]) {
			return false
		}
	}
	if len(this.NetworkConnectors) != len(that1.NetworkConnectors) {
		return false
	}
	for i := range this.NetworkConnectors {
		if !this.NetworkConnectors[i].Equal(that1.NetworkConnectors[i]) {
			return false
		}
	}
	if len(this.NetworkFirewall) != len(that1.NetworkFirewall) {
		return false
	}
	for i := range this.NetworkFirewall {
		if !this.NetworkFirewall[i].Equal(that1.NetworkFirewall[i]) {
			return false
		}
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	if len(this.OutsideVirtualNetwork) != len(that1.OutsideVirtualNetwork) {
		return false
	}
	for i := range this.OutsideVirtualNetwork {
		if !this.OutsideVirtualNetwork[i].Equal(that1.OutsideVirtualNetwork[i]) {
			return false
		}
	}
	if len(this.InsideVirtualNetwork) != len(that1.InsideVirtualNetwork) {
		return false
	}
	for i := range this.InsideVirtualNetwork {
		if !this.InsideVirtualNetwork[i].Equal(that1.InsideVirtualNetwork[i]) {
			return false
		}
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	if that1.BondChoice == nil {
		if this.BondChoice != nil {
			return false
		}
	} else if this.BondChoice == nil {
		return false
	} else if !this.BondChoice.Equal(that1.BondChoice) {
		return false
	}
	if that1.StorageInterfaceChoice == nil {
		if this.StorageInterfaceChoice != nil {
			return false
		}
	} else if this.StorageInterfaceChoice == nil {
		return false
	} else if !this.StorageInterfaceChoice.Equal(that1.StorageInterfaceChoice) {
		return false
	}
	if that1.StorageDeviceChoice == nil {
		if this.StorageDeviceChoice != nil {
			return false
		}
	} else if this.StorageDeviceChoice == nil {
		return false
	} else if !this.StorageDeviceChoice.Equal(that1.StorageDeviceChoice) {
		return false
	}
	if that1.StorageClassChoice == nil {
		if this.StorageClassChoice != nil {
			return false
		}
	} else if this.StorageClassChoice == nil {
		return false
	} else if !this.StorageClassChoice.Equal(that1.StorageClassChoice) {
		return false
	}
	if that1.DcClusterGroupChoice == nil {
		if this.DcClusterGroupChoice != nil {
			return false
		}
	} else if this.DcClusterGroupChoice == nil {
		return false
	} else if !this.DcClusterGroupChoice.Equal(that1.DcClusterGroupChoice) {
		return false
	}
	if that1.GpuChoice == nil {
		if this.GpuChoice != nil {
			return false
		}
	} else if this.GpuChoice == nil {
		return false
	} else if !this.GpuChoice.Equal(that1.GpuChoice) {
		return false
	}
	if this.EtcdClusterNetwork != that1.EtcdClusterNetwork {
		return false
	}
	if that1.StorageStaticRoutesChoice == nil {
		if this.StorageStaticRoutesChoice != nil {
			return false
		}
	} else if this.StorageStaticRoutesChoice == nil {
		return false
	} else if !this.StorageStaticRoutesChoice.Equal(that1.StorageStaticRoutesChoice) {
		return false
	}
	if this.EnableDefaultFleetConfigDownload != that1.EnableDefaultFleetConfigDownload {
		return false
	}
	if this.FleetType != that1.FleetType {
		return false
	}
	if len(this.SingleSite) != len(that1.SingleSite) {
		return false
	}
	for i := range this.SingleSite {
		if !this.SingleSite[i].Equal(that1.SingleSite[i]) {
			return false
		}
	}
	if that1.LogsReceiverChoice == nil {
		if this.LogsReceiverChoice != nil {
			return false
		}
	} else if this.LogsReceiverChoice == nil {
		return false
	} else if !this.LogsReceiverChoice.Equal(that1.LogsReceiverChoice) {
		return false
	}
	if that1.UsbPolicyChoice == nil {
		if this.UsbPolicyChoice != nil {
			return false
		}
	} else if this.UsbPolicyChoice == nil {
		return false
	} else if !this.UsbPolicyChoice.Equal(that1.UsbPolicyChoice) {
		return false
	}
	if !this.K8SCluster.Equal(that1.K8SCluster) {
		return false
	}
	if !this.LocalControlPlane.Equal(that1.LocalControlPlane) {
		return false
	}
	if !this.ViewInternal.Equal(that1.ViewInternal) {
		return false
	}
	return true
}
func (this *GlobalSpecType_InterfaceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_InterfaceList)
	if !ok {
		that2, ok := that.(GlobalSpecType_InterfaceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InterfaceList.Equal(that1.InterfaceList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DefaultInterfaces) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DefaultInterfaces)
	if !ok {
		that2, ok := that.(GlobalSpecType_DefaultInterfaces)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultInterfaces.Equal(that1.DefaultInterfaces) {
		return false
	}
	return true
}
func (this *GlobalSpecType_LegacyDevices) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_LegacyDevices)
	if !ok {
		that2, ok := that.(GlobalSpecType_LegacyDevices)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyDevices.Equal(that1.LegacyDevices) {
		return false
	}
	return true
}
func (this *GlobalSpecType_NoBondDevices) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_NoBondDevices)
	if !ok {
		that2, ok := that.(GlobalSpecType_NoBondDevices)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoBondDevices.Equal(that1.NoBondDevices) {
		return false
	}
	return true
}
func (this *GlobalSpecType_BondDeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_BondDeviceList)
	if !ok {
		that2, ok := that.(GlobalSpecType_BondDeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BondDeviceList.Equal(that1.BondDeviceList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_NoStorageInterfaces) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_NoStorageInterfaces)
	if !ok {
		that2, ok := that.(GlobalSpecType_NoStorageInterfaces)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageInterfaces.Equal(that1.NoStorageInterfaces) {
		return false
	}
	return true
}
func (this *GlobalSpecType_StorageInterfaceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_StorageInterfaceList)
	if !ok {
		that2, ok := that.(GlobalSpecType_StorageInterfaceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageInterfaceList.Equal(that1.StorageInterfaceList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_NoStorageDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_NoStorageDevice)
	if !ok {
		that2, ok := that.(GlobalSpecType_NoStorageDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageDevice.Equal(that1.NoStorageDevice) {
		return false
	}
	return true
}
func (this *GlobalSpecType_StorageDeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_StorageDeviceList)
	if !ok {
		that2, ok := that.(GlobalSpecType_StorageDeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageDeviceList.Equal(that1.StorageDeviceList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DefaultStorageClass) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DefaultStorageClass)
	if !ok {
		that2, ok := that.(GlobalSpecType_DefaultStorageClass)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultStorageClass.Equal(that1.DefaultStorageClass) {
		return false
	}
	return true
}
func (this *GlobalSpecType_StorageClassList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_StorageClassList)
	if !ok {
		that2, ok := that.(GlobalSpecType_StorageClassList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageClassList.Equal(that1.StorageClassList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_NoDcClusterGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_NoDcClusterGroup)
	if !ok {
		that2, ok := that.(GlobalSpecType_NoDcClusterGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoDcClusterGroup.Equal(that1.NoDcClusterGroup) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DcClusterGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DcClusterGroup)
	if !ok {
		that2, ok := that.(GlobalSpecType_DcClusterGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DcClusterGroup.Equal(that1.DcClusterGroup) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DcClusterGroupInside) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DcClusterGroupInside)
	if !ok {
		that2, ok := that.(GlobalSpecType_DcClusterGroupInside)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DcClusterGroupInside.Equal(that1.DcClusterGroupInside) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DisableGpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DisableGpu)
	if !ok {
		that2, ok := that.(GlobalSpecType_DisableGpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableGpu.Equal(that1.DisableGpu) {
		return false
	}
	return true
}
func (this *GlobalSpecType_EnableGpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_EnableGpu)
	if !ok {
		that2, ok := that.(GlobalSpecType_EnableGpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableGpu.Equal(that1.EnableGpu) {
		return false
	}
	return true
}
func (this *GlobalSpecType_NoStorageStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_NoStorageStaticRoutes)
	if !ok {
		that2, ok := that.(GlobalSpecType_NoStorageStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageStaticRoutes.Equal(that1.NoStorageStaticRoutes) {
		return false
	}
	return true
}
func (this *GlobalSpecType_StorageStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_StorageStaticRoutes)
	if !ok {
		that2, ok := that.(GlobalSpecType_StorageStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageStaticRoutes.Equal(that1.StorageStaticRoutes) {
		return false
	}
	return true
}
func (this *GlobalSpecType_LogsStreamingDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_LogsStreamingDisabled)
	if !ok {
		that2, ok := that.(GlobalSpecType_LogsStreamingDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogsStreamingDisabled.Equal(that1.LogsStreamingDisabled) {
		return false
	}
	return true
}
func (this *GlobalSpecType_LogReceiver) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_LogReceiver)
	if !ok {
		that2, ok := that.(GlobalSpecType_LogReceiver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogReceiver.Equal(that1.LogReceiver) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DenyAllUsb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DenyAllUsb)
	if !ok {
		that2, ok := that.(GlobalSpecType_DenyAllUsb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyAllUsb.Equal(that1.DenyAllUsb) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AllowAllUsb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AllowAllUsb)
	if !ok {
		that2, ok := that.(GlobalSpecType_AllowAllUsb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowAllUsb.Equal(that1.AllowAllUsb) {
		return false
	}
	return true
}
func (this *GlobalSpecType_UsbPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_UsbPolicy)
	if !ok {
		that2, ok := that.(GlobalSpecType_UsbPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UsbPolicy.Equal(that1.UsbPolicy) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FleetLabel != that1.FleetLabel {
		return false
	}
	if this.VolterraSoftwareVersion != that1.VolterraSoftwareVersion {
		return false
	}
	if len(this.NetworkConnectors) != len(that1.NetworkConnectors) {
		return false
	}
	for i := range this.NetworkConnectors {
		if !this.NetworkConnectors[i].Equal(that1.NetworkConnectors[i]) {
			return false
		}
	}
	if len(this.NetworkFirewall) != len(that1.NetworkFirewall) {
		return false
	}
	for i := range this.NetworkFirewall {
		if !this.NetworkFirewall[i].Equal(that1.NetworkFirewall[i]) {
			return false
		}
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	if len(this.OutsideVirtualNetwork) != len(that1.OutsideVirtualNetwork) {
		return false
	}
	for i := range this.OutsideVirtualNetwork {
		if !this.OutsideVirtualNetwork[i].Equal(that1.OutsideVirtualNetwork[i]) {
			return false
		}
	}
	if len(this.InsideVirtualNetwork) != len(that1.InsideVirtualNetwork) {
		return false
	}
	for i := range this.InsideVirtualNetwork {
		if !this.InsideVirtualNetwork[i].Equal(that1.InsideVirtualNetwork[i]) {
			return false
		}
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	if that1.BondChoice == nil {
		if this.BondChoice != nil {
			return false
		}
	} else if this.BondChoice == nil {
		return false
	} else if !this.BondChoice.Equal(that1.BondChoice) {
		return false
	}
	if that1.StorageInterfaceChoice == nil {
		if this.StorageInterfaceChoice != nil {
			return false
		}
	} else if this.StorageInterfaceChoice == nil {
		return false
	} else if !this.StorageInterfaceChoice.Equal(that1.StorageInterfaceChoice) {
		return false
	}
	if that1.StorageDeviceChoice == nil {
		if this.StorageDeviceChoice != nil {
			return false
		}
	} else if this.StorageDeviceChoice == nil {
		return false
	} else if !this.StorageDeviceChoice.Equal(that1.StorageDeviceChoice) {
		return false
	}
	if that1.StorageClassChoice == nil {
		if this.StorageClassChoice != nil {
			return false
		}
	} else if this.StorageClassChoice == nil {
		return false
	} else if !this.StorageClassChoice.Equal(that1.StorageClassChoice) {
		return false
	}
	if that1.DcClusterGroupChoice == nil {
		if this.DcClusterGroupChoice != nil {
			return false
		}
	} else if this.DcClusterGroupChoice == nil {
		return false
	} else if !this.DcClusterGroupChoice.Equal(that1.DcClusterGroupChoice) {
		return false
	}
	if that1.GpuChoice == nil {
		if this.GpuChoice != nil {
			return false
		}
	} else if this.GpuChoice == nil {
		return false
	} else if !this.GpuChoice.Equal(that1.GpuChoice) {
		return false
	}
	if that1.StorageStaticRoutesChoice == nil {
		if this.StorageStaticRoutesChoice != nil {
			return false
		}
	} else if this.StorageStaticRoutesChoice == nil {
		return false
	} else if !this.StorageStaticRoutesChoice.Equal(that1.StorageStaticRoutesChoice) {
		return false
	}
	if this.EnableDefaultFleetConfigDownload != that1.EnableDefaultFleetConfigDownload {
		return false
	}
	if that1.LogsReceiverChoice == nil {
		if this.LogsReceiverChoice != nil {
			return false
		}
	} else if this.LogsReceiverChoice == nil {
		return false
	} else if !this.LogsReceiverChoice.Equal(that1.LogsReceiverChoice) {
		return false
	}
	if that1.UsbPolicyChoice == nil {
		if this.UsbPolicyChoice != nil {
			return false
		}
	} else if this.UsbPolicyChoice == nil {
		return false
	} else if !this.UsbPolicyChoice.Equal(that1.UsbPolicyChoice) {
		return false
	}
	return true
}
func (this *CreateSpecType_InterfaceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_InterfaceList)
	if !ok {
		that2, ok := that.(CreateSpecType_InterfaceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InterfaceList.Equal(that1.InterfaceList) {
		return false
	}
	return true
}
func (this *CreateSpecType_DefaultConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DefaultConfig)
	if !ok {
		that2, ok := that.(CreateSpecType_DefaultConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultConfig.Equal(that1.DefaultConfig) {
		return false
	}
	return true
}
func (this *CreateSpecType_DeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DeviceList)
	if !ok {
		that2, ok := that.(CreateSpecType_DeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeviceList.Equal(that1.DeviceList) {
		return false
	}
	return true
}
func (this *CreateSpecType_NoBondDevices) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_NoBondDevices)
	if !ok {
		that2, ok := that.(CreateSpecType_NoBondDevices)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoBondDevices.Equal(that1.NoBondDevices) {
		return false
	}
	return true
}
func (this *CreateSpecType_BondDeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_BondDeviceList)
	if !ok {
		that2, ok := that.(CreateSpecType_BondDeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BondDeviceList.Equal(that1.BondDeviceList) {
		return false
	}
	return true
}
func (this *CreateSpecType_NoStorageInterfaces) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_NoStorageInterfaces)
	if !ok {
		that2, ok := that.(CreateSpecType_NoStorageInterfaces)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageInterfaces.Equal(that1.NoStorageInterfaces) {
		return false
	}
	return true
}
func (this *CreateSpecType_StorageInterfaceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_StorageInterfaceList)
	if !ok {
		that2, ok := that.(CreateSpecType_StorageInterfaceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageInterfaceList.Equal(that1.StorageInterfaceList) {
		return false
	}
	return true
}
func (this *CreateSpecType_NoStorageDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_NoStorageDevice)
	if !ok {
		that2, ok := that.(CreateSpecType_NoStorageDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageDevice.Equal(that1.NoStorageDevice) {
		return false
	}
	return true
}
func (this *CreateSpecType_StorageDeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_StorageDeviceList)
	if !ok {
		that2, ok := that.(CreateSpecType_StorageDeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageDeviceList.Equal(that1.StorageDeviceList) {
		return false
	}
	return true
}
func (this *CreateSpecType_DefaultStorageClass) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DefaultStorageClass)
	if !ok {
		that2, ok := that.(CreateSpecType_DefaultStorageClass)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultStorageClass.Equal(that1.DefaultStorageClass) {
		return false
	}
	return true
}
func (this *CreateSpecType_StorageClassList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_StorageClassList)
	if !ok {
		that2, ok := that.(CreateSpecType_StorageClassList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageClassList.Equal(that1.StorageClassList) {
		return false
	}
	return true
}
func (this *CreateSpecType_NoDcClusterGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_NoDcClusterGroup)
	if !ok {
		that2, ok := that.(CreateSpecType_NoDcClusterGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoDcClusterGroup.Equal(that1.NoDcClusterGroup) {
		return false
	}
	return true
}
func (this *CreateSpecType_DcClusterGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DcClusterGroup)
	if !ok {
		that2, ok := that.(CreateSpecType_DcClusterGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DcClusterGroup.Equal(that1.DcClusterGroup) {
		return false
	}
	return true
}
func (this *CreateSpecType_DcClusterGroupInside) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DcClusterGroupInside)
	if !ok {
		that2, ok := that.(CreateSpecType_DcClusterGroupInside)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DcClusterGroupInside.Equal(that1.DcClusterGroupInside) {
		return false
	}
	return true
}
func (this *CreateSpecType_DisableGpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DisableGpu)
	if !ok {
		that2, ok := that.(CreateSpecType_DisableGpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableGpu.Equal(that1.DisableGpu) {
		return false
	}
	return true
}
func (this *CreateSpecType_EnableGpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_EnableGpu)
	if !ok {
		that2, ok := that.(CreateSpecType_EnableGpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableGpu.Equal(that1.EnableGpu) {
		return false
	}
	return true
}
func (this *CreateSpecType_NoStorageStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_NoStorageStaticRoutes)
	if !ok {
		that2, ok := that.(CreateSpecType_NoStorageStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageStaticRoutes.Equal(that1.NoStorageStaticRoutes) {
		return false
	}
	return true
}
func (this *CreateSpecType_StorageStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_StorageStaticRoutes)
	if !ok {
		that2, ok := that.(CreateSpecType_StorageStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageStaticRoutes.Equal(that1.StorageStaticRoutes) {
		return false
	}
	return true
}
func (this *CreateSpecType_LogsStreamingDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_LogsStreamingDisabled)
	if !ok {
		that2, ok := that.(CreateSpecType_LogsStreamingDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogsStreamingDisabled.Equal(that1.LogsStreamingDisabled) {
		return false
	}
	return true
}
func (this *CreateSpecType_LogReceiver) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_LogReceiver)
	if !ok {
		that2, ok := that.(CreateSpecType_LogReceiver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogReceiver.Equal(that1.LogReceiver) {
		return false
	}
	return true
}
func (this *CreateSpecType_DenyAllUsb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DenyAllUsb)
	if !ok {
		that2, ok := that.(CreateSpecType_DenyAllUsb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyAllUsb.Equal(that1.DenyAllUsb) {
		return false
	}
	return true
}
func (this *CreateSpecType_AllowAllUsb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AllowAllUsb)
	if !ok {
		that2, ok := that.(CreateSpecType_AllowAllUsb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowAllUsb.Equal(that1.AllowAllUsb) {
		return false
	}
	return true
}
func (this *CreateSpecType_UsbPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_UsbPolicy)
	if !ok {
		that2, ok := that.(CreateSpecType_UsbPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UsbPolicy.Equal(that1.UsbPolicy) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VolterraSoftwareVersion != that1.VolterraSoftwareVersion {
		return false
	}
	if len(this.NetworkConnectors) != len(that1.NetworkConnectors) {
		return false
	}
	for i := range this.NetworkConnectors {
		if !this.NetworkConnectors[i].Equal(that1.NetworkConnectors[i]) {
			return false
		}
	}
	if len(this.NetworkFirewall) != len(that1.NetworkFirewall) {
		return false
	}
	for i := range this.NetworkFirewall {
		if !this.NetworkFirewall[i].Equal(that1.NetworkFirewall[i]) {
			return false
		}
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	if len(this.OutsideVirtualNetwork) != len(that1.OutsideVirtualNetwork) {
		return false
	}
	for i := range this.OutsideVirtualNetwork {
		if !this.OutsideVirtualNetwork[i].Equal(that1.OutsideVirtualNetwork[i]) {
			return false
		}
	}
	if len(this.InsideVirtualNetwork) != len(that1.InsideVirtualNetwork) {
		return false
	}
	for i := range this.InsideVirtualNetwork {
		if !this.InsideVirtualNetwork[i].Equal(that1.InsideVirtualNetwork[i]) {
			return false
		}
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	if that1.BondChoice == nil {
		if this.BondChoice != nil {
			return false
		}
	} else if this.BondChoice == nil {
		return false
	} else if !this.BondChoice.Equal(that1.BondChoice) {
		return false
	}
	if that1.StorageInterfaceChoice == nil {
		if this.StorageInterfaceChoice != nil {
			return false
		}
	} else if this.StorageInterfaceChoice == nil {
		return false
	} else if !this.StorageInterfaceChoice.Equal(that1.StorageInterfaceChoice) {
		return false
	}
	if that1.StorageDeviceChoice == nil {
		if this.StorageDeviceChoice != nil {
			return false
		}
	} else if this.StorageDeviceChoice == nil {
		return false
	} else if !this.StorageDeviceChoice.Equal(that1.StorageDeviceChoice) {
		return false
	}
	if that1.StorageClassChoice == nil {
		if this.StorageClassChoice != nil {
			return false
		}
	} else if this.StorageClassChoice == nil {
		return false
	} else if !this.StorageClassChoice.Equal(that1.StorageClassChoice) {
		return false
	}
	if that1.DcClusterGroupChoice == nil {
		if this.DcClusterGroupChoice != nil {
			return false
		}
	} else if this.DcClusterGroupChoice == nil {
		return false
	} else if !this.DcClusterGroupChoice.Equal(that1.DcClusterGroupChoice) {
		return false
	}
	if that1.GpuChoice == nil {
		if this.GpuChoice != nil {
			return false
		}
	} else if this.GpuChoice == nil {
		return false
	} else if !this.GpuChoice.Equal(that1.GpuChoice) {
		return false
	}
	if that1.StorageStaticRoutesChoice == nil {
		if this.StorageStaticRoutesChoice != nil {
			return false
		}
	} else if this.StorageStaticRoutesChoice == nil {
		return false
	} else if !this.StorageStaticRoutesChoice.Equal(that1.StorageStaticRoutesChoice) {
		return false
	}
	if this.EnableDefaultFleetConfigDownload != that1.EnableDefaultFleetConfigDownload {
		return false
	}
	if that1.LogsReceiverChoice == nil {
		if this.LogsReceiverChoice != nil {
			return false
		}
	} else if this.LogsReceiverChoice == nil {
		return false
	} else if !this.LogsReceiverChoice.Equal(that1.LogsReceiverChoice) {
		return false
	}
	if that1.UsbPolicyChoice == nil {
		if this.UsbPolicyChoice != nil {
			return false
		}
	} else if this.UsbPolicyChoice == nil {
		return false
	} else if !this.UsbPolicyChoice.Equal(that1.UsbPolicyChoice) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_InterfaceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_InterfaceList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_InterfaceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InterfaceList.Equal(that1.InterfaceList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DefaultConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DefaultConfig)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DefaultConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultConfig.Equal(that1.DefaultConfig) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DeviceList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeviceList.Equal(that1.DeviceList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_NoBondDevices) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_NoBondDevices)
	if !ok {
		that2, ok := that.(ReplaceSpecType_NoBondDevices)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoBondDevices.Equal(that1.NoBondDevices) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_BondDeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_BondDeviceList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_BondDeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BondDeviceList.Equal(that1.BondDeviceList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_NoStorageInterfaces) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_NoStorageInterfaces)
	if !ok {
		that2, ok := that.(ReplaceSpecType_NoStorageInterfaces)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageInterfaces.Equal(that1.NoStorageInterfaces) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_StorageInterfaceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_StorageInterfaceList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_StorageInterfaceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageInterfaceList.Equal(that1.StorageInterfaceList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_NoStorageDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_NoStorageDevice)
	if !ok {
		that2, ok := that.(ReplaceSpecType_NoStorageDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageDevice.Equal(that1.NoStorageDevice) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_StorageDeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_StorageDeviceList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_StorageDeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageDeviceList.Equal(that1.StorageDeviceList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DefaultStorageClass) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DefaultStorageClass)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DefaultStorageClass)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultStorageClass.Equal(that1.DefaultStorageClass) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_StorageClassList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_StorageClassList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_StorageClassList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageClassList.Equal(that1.StorageClassList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_NoDcClusterGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_NoDcClusterGroup)
	if !ok {
		that2, ok := that.(ReplaceSpecType_NoDcClusterGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoDcClusterGroup.Equal(that1.NoDcClusterGroup) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DcClusterGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DcClusterGroup)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DcClusterGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DcClusterGroup.Equal(that1.DcClusterGroup) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DcClusterGroupInside) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DcClusterGroupInside)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DcClusterGroupInside)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DcClusterGroupInside.Equal(that1.DcClusterGroupInside) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DisableGpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DisableGpu)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DisableGpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableGpu.Equal(that1.DisableGpu) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_EnableGpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_EnableGpu)
	if !ok {
		that2, ok := that.(ReplaceSpecType_EnableGpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableGpu.Equal(that1.EnableGpu) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_NoStorageStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_NoStorageStaticRoutes)
	if !ok {
		that2, ok := that.(ReplaceSpecType_NoStorageStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageStaticRoutes.Equal(that1.NoStorageStaticRoutes) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_StorageStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_StorageStaticRoutes)
	if !ok {
		that2, ok := that.(ReplaceSpecType_StorageStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageStaticRoutes.Equal(that1.StorageStaticRoutes) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_LogsStreamingDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_LogsStreamingDisabled)
	if !ok {
		that2, ok := that.(ReplaceSpecType_LogsStreamingDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogsStreamingDisabled.Equal(that1.LogsStreamingDisabled) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_LogReceiver) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_LogReceiver)
	if !ok {
		that2, ok := that.(ReplaceSpecType_LogReceiver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogReceiver.Equal(that1.LogReceiver) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DenyAllUsb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DenyAllUsb)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DenyAllUsb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyAllUsb.Equal(that1.DenyAllUsb) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AllowAllUsb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AllowAllUsb)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AllowAllUsb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowAllUsb.Equal(that1.AllowAllUsb) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_UsbPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_UsbPolicy)
	if !ok {
		that2, ok := that.(ReplaceSpecType_UsbPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UsbPolicy.Equal(that1.UsbPolicy) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FleetLabel != that1.FleetLabel {
		return false
	}
	if this.VolterraSoftwareVersion != that1.VolterraSoftwareVersion {
		return false
	}
	if len(this.NetworkConnectors) != len(that1.NetworkConnectors) {
		return false
	}
	for i := range this.NetworkConnectors {
		if !this.NetworkConnectors[i].Equal(that1.NetworkConnectors[i]) {
			return false
		}
	}
	if len(this.NetworkFirewall) != len(that1.NetworkFirewall) {
		return false
	}
	for i := range this.NetworkFirewall {
		if !this.NetworkFirewall[i].Equal(that1.NetworkFirewall[i]) {
			return false
		}
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	if len(this.OutsideVirtualNetwork) != len(that1.OutsideVirtualNetwork) {
		return false
	}
	for i := range this.OutsideVirtualNetwork {
		if !this.OutsideVirtualNetwork[i].Equal(that1.OutsideVirtualNetwork[i]) {
			return false
		}
	}
	if len(this.InsideVirtualNetwork) != len(that1.InsideVirtualNetwork) {
		return false
	}
	for i := range this.InsideVirtualNetwork {
		if !this.InsideVirtualNetwork[i].Equal(that1.InsideVirtualNetwork[i]) {
			return false
		}
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	if that1.BondChoice == nil {
		if this.BondChoice != nil {
			return false
		}
	} else if this.BondChoice == nil {
		return false
	} else if !this.BondChoice.Equal(that1.BondChoice) {
		return false
	}
	if that1.StorageInterfaceChoice == nil {
		if this.StorageInterfaceChoice != nil {
			return false
		}
	} else if this.StorageInterfaceChoice == nil {
		return false
	} else if !this.StorageInterfaceChoice.Equal(that1.StorageInterfaceChoice) {
		return false
	}
	if that1.StorageDeviceChoice == nil {
		if this.StorageDeviceChoice != nil {
			return false
		}
	} else if this.StorageDeviceChoice == nil {
		return false
	} else if !this.StorageDeviceChoice.Equal(that1.StorageDeviceChoice) {
		return false
	}
	if that1.StorageClassChoice == nil {
		if this.StorageClassChoice != nil {
			return false
		}
	} else if this.StorageClassChoice == nil {
		return false
	} else if !this.StorageClassChoice.Equal(that1.StorageClassChoice) {
		return false
	}
	if that1.DcClusterGroupChoice == nil {
		if this.DcClusterGroupChoice != nil {
			return false
		}
	} else if this.DcClusterGroupChoice == nil {
		return false
	} else if !this.DcClusterGroupChoice.Equal(that1.DcClusterGroupChoice) {
		return false
	}
	if that1.GpuChoice == nil {
		if this.GpuChoice != nil {
			return false
		}
	} else if this.GpuChoice == nil {
		return false
	} else if !this.GpuChoice.Equal(that1.GpuChoice) {
		return false
	}
	if that1.StorageStaticRoutesChoice == nil {
		if this.StorageStaticRoutesChoice != nil {
			return false
		}
	} else if this.StorageStaticRoutesChoice == nil {
		return false
	} else if !this.StorageStaticRoutesChoice.Equal(that1.StorageStaticRoutesChoice) {
		return false
	}
	if this.EnableDefaultFleetConfigDownload != that1.EnableDefaultFleetConfigDownload {
		return false
	}
	if that1.LogsReceiverChoice == nil {
		if this.LogsReceiverChoice != nil {
			return false
		}
	} else if this.LogsReceiverChoice == nil {
		return false
	} else if !this.LogsReceiverChoice.Equal(that1.LogsReceiverChoice) {
		return false
	}
	if that1.UsbPolicyChoice == nil {
		if this.UsbPolicyChoice != nil {
			return false
		}
	} else if this.UsbPolicyChoice == nil {
		return false
	} else if !this.UsbPolicyChoice.Equal(that1.UsbPolicyChoice) {
		return false
	}
	return true
}
func (this *GetSpecType_InterfaceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_InterfaceList)
	if !ok {
		that2, ok := that.(GetSpecType_InterfaceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InterfaceList.Equal(that1.InterfaceList) {
		return false
	}
	return true
}
func (this *GetSpecType_DefaultConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DefaultConfig)
	if !ok {
		that2, ok := that.(GetSpecType_DefaultConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultConfig.Equal(that1.DefaultConfig) {
		return false
	}
	return true
}
func (this *GetSpecType_DeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DeviceList)
	if !ok {
		that2, ok := that.(GetSpecType_DeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeviceList.Equal(that1.DeviceList) {
		return false
	}
	return true
}
func (this *GetSpecType_NoBondDevices) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_NoBondDevices)
	if !ok {
		that2, ok := that.(GetSpecType_NoBondDevices)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoBondDevices.Equal(that1.NoBondDevices) {
		return false
	}
	return true
}
func (this *GetSpecType_BondDeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_BondDeviceList)
	if !ok {
		that2, ok := that.(GetSpecType_BondDeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BondDeviceList.Equal(that1.BondDeviceList) {
		return false
	}
	return true
}
func (this *GetSpecType_NoStorageInterfaces) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_NoStorageInterfaces)
	if !ok {
		that2, ok := that.(GetSpecType_NoStorageInterfaces)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageInterfaces.Equal(that1.NoStorageInterfaces) {
		return false
	}
	return true
}
func (this *GetSpecType_StorageInterfaceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_StorageInterfaceList)
	if !ok {
		that2, ok := that.(GetSpecType_StorageInterfaceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageInterfaceList.Equal(that1.StorageInterfaceList) {
		return false
	}
	return true
}
func (this *GetSpecType_NoStorageDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_NoStorageDevice)
	if !ok {
		that2, ok := that.(GetSpecType_NoStorageDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageDevice.Equal(that1.NoStorageDevice) {
		return false
	}
	return true
}
func (this *GetSpecType_StorageDeviceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_StorageDeviceList)
	if !ok {
		that2, ok := that.(GetSpecType_StorageDeviceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageDeviceList.Equal(that1.StorageDeviceList) {
		return false
	}
	return true
}
func (this *GetSpecType_DefaultStorageClass) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DefaultStorageClass)
	if !ok {
		that2, ok := that.(GetSpecType_DefaultStorageClass)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultStorageClass.Equal(that1.DefaultStorageClass) {
		return false
	}
	return true
}
func (this *GetSpecType_StorageClassList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_StorageClassList)
	if !ok {
		that2, ok := that.(GetSpecType_StorageClassList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageClassList.Equal(that1.StorageClassList) {
		return false
	}
	return true
}
func (this *GetSpecType_NoDcClusterGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_NoDcClusterGroup)
	if !ok {
		that2, ok := that.(GetSpecType_NoDcClusterGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoDcClusterGroup.Equal(that1.NoDcClusterGroup) {
		return false
	}
	return true
}
func (this *GetSpecType_DcClusterGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DcClusterGroup)
	if !ok {
		that2, ok := that.(GetSpecType_DcClusterGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DcClusterGroup.Equal(that1.DcClusterGroup) {
		return false
	}
	return true
}
func (this *GetSpecType_DcClusterGroupInside) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DcClusterGroupInside)
	if !ok {
		that2, ok := that.(GetSpecType_DcClusterGroupInside)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DcClusterGroupInside.Equal(that1.DcClusterGroupInside) {
		return false
	}
	return true
}
func (this *GetSpecType_DisableGpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DisableGpu)
	if !ok {
		that2, ok := that.(GetSpecType_DisableGpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableGpu.Equal(that1.DisableGpu) {
		return false
	}
	return true
}
func (this *GetSpecType_EnableGpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_EnableGpu)
	if !ok {
		that2, ok := that.(GetSpecType_EnableGpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableGpu.Equal(that1.EnableGpu) {
		return false
	}
	return true
}
func (this *GetSpecType_NoStorageStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_NoStorageStaticRoutes)
	if !ok {
		that2, ok := that.(GetSpecType_NoStorageStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoStorageStaticRoutes.Equal(that1.NoStorageStaticRoutes) {
		return false
	}
	return true
}
func (this *GetSpecType_StorageStaticRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_StorageStaticRoutes)
	if !ok {
		that2, ok := that.(GetSpecType_StorageStaticRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageStaticRoutes.Equal(that1.StorageStaticRoutes) {
		return false
	}
	return true
}
func (this *GetSpecType_LogsStreamingDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_LogsStreamingDisabled)
	if !ok {
		that2, ok := that.(GetSpecType_LogsStreamingDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogsStreamingDisabled.Equal(that1.LogsStreamingDisabled) {
		return false
	}
	return true
}
func (this *GetSpecType_LogReceiver) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_LogReceiver)
	if !ok {
		that2, ok := that.(GetSpecType_LogReceiver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogReceiver.Equal(that1.LogReceiver) {
		return false
	}
	return true
}
func (this *GetSpecType_DenyAllUsb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DenyAllUsb)
	if !ok {
		that2, ok := that.(GetSpecType_DenyAllUsb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyAllUsb.Equal(that1.DenyAllUsb) {
		return false
	}
	return true
}
func (this *GetSpecType_AllowAllUsb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AllowAllUsb)
	if !ok {
		that2, ok := that.(GetSpecType_AllowAllUsb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowAllUsb.Equal(that1.AllowAllUsb) {
		return false
	}
	return true
}
func (this *GetSpecType_UsbPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_UsbPolicy)
	if !ok {
		that2, ok := that.(GetSpecType_UsbPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UsbPolicy.Equal(that1.UsbPolicy) {
		return false
	}
	return true
}
func (this *FleetStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStatus)
	if !ok {
		that2, ok := that.(FleetStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AvailableSoftwareVersion != that1.AvailableSoftwareVersion {
		return false
	}
	return true
}
func (this *NetworkingDeviceInstanceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&fleet.NetworkingDeviceInstanceType{")
	if this.Interface != nil {
		s = append(s, "Interface: "+fmt.Sprintf("%#v", this.Interface)+",\n")
	}
	s = append(s, "Use: "+fmt.Sprintf("%#v", this.Use)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GenericDeviceInstanceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&fleet.GenericDeviceInstanceType{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeviceInstanceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&fleet.DeviceInstanceType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Owner: "+fmt.Sprintf("%#v", this.Owner)+",\n")
	if this.DeviceInstance != nil {
		s = append(s, "DeviceInstance: "+fmt.Sprintf("%#v", this.DeviceInstance)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeviceInstanceType_NetworkDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.DeviceInstanceType_NetworkDevice{` +
		`NetworkDevice:` + fmt.Sprintf("%#v", this.NetworkDevice) + `}`}, ", ")
	return s
}
func (this *FleetInterfaceListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&fleet.FleetInterfaceListType{")
	if this.Interfaces != nil {
		s = append(s, "Interfaces: "+fmt.Sprintf("%#v", this.Interfaces)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FleetDeviceListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&fleet.FleetDeviceListType{")
	if this.Devices != nil {
		s = append(s, "Devices: "+fmt.Sprintf("%#v", this.Devices)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDeviceOpenebsEnterpriseType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&fleet.StorageDeviceOpenebsEnterpriseType{")
	if this.MayastorPools != nil {
		s = append(s, "MayastorPools: "+fmt.Sprintf("%#v", this.MayastorPools)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OpenebsMayastorPoolType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&fleet.OpenebsMayastorPoolType{")
	s = append(s, "PoolName: "+fmt.Sprintf("%#v", this.PoolName)+",\n")
	s = append(s, "Node: "+fmt.Sprintf("%#v", this.Node)+",\n")
	s = append(s, "PoolDiskDevices: "+fmt.Sprintf("%#v", this.PoolDiskDevices)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDeviceDellIsilonF800Type) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&fleet.StorageDeviceDellIsilonF800Type{")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	if this.Password != nil {
		s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	}
	if this.HttpsChoice != nil {
		s = append(s, "HttpsChoice: "+fmt.Sprintf("%#v", this.HttpsChoice)+",\n")
	}
	if this.AddressChoice != nil {
		s = append(s, "AddressChoice: "+fmt.Sprintf("%#v", this.AddressChoice)+",\n")
	}
	s = append(s, "ApiServerPort: "+fmt.Sprintf("%#v", this.ApiServerPort)+",\n")
	s = append(s, "IscsiAccessZone: "+fmt.Sprintf("%#v", this.IscsiAccessZone)+",\n")
	s = append(s, "VolumePrefix: "+fmt.Sprintf("%#v", this.VolumePrefix)+",\n")
	s = append(s, "BasePath: "+fmt.Sprintf("%#v", this.BasePath)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDeviceDellIsilonF800Type_SecureNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceDellIsilonF800Type_SecureNetwork{` +
		`SecureNetwork:` + fmt.Sprintf("%#v", this.SecureNetwork) + `}`}, ", ")
	return s
}
func (this *StorageDeviceDellIsilonF800Type_TrustedCaUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceDellIsilonF800Type_TrustedCaUrl{` +
		`TrustedCaUrl:` + fmt.Sprintf("%#v", this.TrustedCaUrl) + `}`}, ", ")
	return s
}
func (this *StorageDeviceDellIsilonF800Type_ApiServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceDellIsilonF800Type_ApiServerName{` +
		`ApiServerName:` + fmt.Sprintf("%#v", this.ApiServerName) + `}`}, ", ")
	return s
}
func (this *StorageDeviceDellIsilonF800Type_ApiServerIpAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceDellIsilonF800Type_ApiServerIpAddress{` +
		`ApiServerIpAddress:` + fmt.Sprintf("%#v", this.ApiServerIpAddress) + `}`}, ", ")
	return s
}
func (this *StorageDeviceHPENimbusStorageAf40Type) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&fleet.StorageDeviceHPENimbusStorageAf40Type{")
	s = append(s, "StorageServerName: "+fmt.Sprintf("%#v", this.StorageServerName)+",\n")
	s = append(s, "StorageServerIpAddress: "+fmt.Sprintf("%#v", this.StorageServerIpAddress)+",\n")
	s = append(s, "ApiServerPort: "+fmt.Sprintf("%#v", this.ApiServerPort)+",\n")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	if this.Password != nil {
		s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	}
	s = append(s, "PerfPolicy: "+fmt.Sprintf("%#v", this.PerfPolicy)+",\n")
	s = append(s, "LimitIops: "+fmt.Sprintf("%#v", this.LimitIops)+",\n")
	s = append(s, "LimitMbps: "+fmt.Sprintf("%#v", this.LimitMbps)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDevicePureStorageServiceOrchestratorType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&fleet.StorageDevicePureStorageServiceOrchestratorType{")
	s = append(s, "ClusterId: "+fmt.Sprintf("%#v", this.ClusterId)+",\n")
	s = append(s, "EnableStorageTopology: "+fmt.Sprintf("%#v", this.EnableStorageTopology)+",\n")
	s = append(s, "EnableStrictTopology: "+fmt.Sprintf("%#v", this.EnableStrictTopology)+",\n")
	if this.Arrays != nil {
		s = append(s, "Arrays: "+fmt.Sprintf("%#v", this.Arrays)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PsoArrayConfiguration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&fleet.PsoArrayConfiguration{")
	if this.FlashArray != nil {
		s = append(s, "FlashArray: "+fmt.Sprintf("%#v", this.FlashArray)+",\n")
	}
	if this.FlashBlade != nil {
		s = append(s, "FlashBlade: "+fmt.Sprintf("%#v", this.FlashBlade)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FlashBladeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&fleet.FlashBladeType{")
	s = append(s, "EnableSnapshotDirectory: "+fmt.Sprintf("%#v", this.EnableSnapshotDirectory)+",\n")
	s = append(s, "ExportRules: "+fmt.Sprintf("%#v", this.ExportRules)+",\n")
	if this.FlashBlades != nil {
		s = append(s, "FlashBlades: "+fmt.Sprintf("%#v", this.FlashBlades)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FlashBladeEndpoint) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&fleet.FlashBladeEndpoint{")
	if this.MgmtEndpoint != nil {
		s = append(s, "MgmtEndpoint: "+fmt.Sprintf("%#v", this.MgmtEndpoint)+",\n")
	}
	if this.ApiToken != nil {
		s = append(s, "ApiToken: "+fmt.Sprintf("%#v", this.ApiToken)+",\n")
	}
	if this.NfsEndpoint != nil {
		s = append(s, "NfsEndpoint: "+fmt.Sprintf("%#v", this.NfsEndpoint)+",\n")
	}
	keysForLables := make([]string, 0, len(this.Lables))
	for k, _ := range this.Lables {
		keysForLables = append(keysForLables, k)
	}
	sortkeys.Strings(keysForLables)
	mapStringForLables := "map[string]string{"
	for _, k := range keysForLables {
		mapStringForLables += fmt.Sprintf("%#v: %#v,", k, this.Lables[k])
	}
	mapStringForLables += "}"
	if this.Lables != nil {
		s = append(s, "Lables: "+mapStringForLables+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FlashBladeEndpoint_MgmtIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FlashBladeEndpoint_MgmtIp{` +
		`MgmtIp:` + fmt.Sprintf("%#v", this.MgmtIp) + `}`}, ", ")
	return s
}
func (this *FlashBladeEndpoint_MgmtDnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FlashBladeEndpoint_MgmtDnsName{` +
		`MgmtDnsName:` + fmt.Sprintf("%#v", this.MgmtDnsName) + `}`}, ", ")
	return s
}
func (this *FlashBladeEndpoint_NfsEndpointIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FlashBladeEndpoint_NfsEndpointIp{` +
		`NfsEndpointIp:` + fmt.Sprintf("%#v", this.NfsEndpointIp) + `}`}, ", ")
	return s
}
func (this *FlashBladeEndpoint_NfsEndpointDnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FlashBladeEndpoint_NfsEndpointDnsName{` +
		`NfsEndpointDnsName:` + fmt.Sprintf("%#v", this.NfsEndpointDnsName) + `}`}, ", ")
	return s
}
func (this *FlashArrayType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&fleet.FlashArrayType{")
	s = append(s, "SanType: "+fmt.Sprintf("%#v", this.SanType)+",\n")
	s = append(s, "DefaultFsType: "+fmt.Sprintf("%#v", this.DefaultFsType)+",\n")
	s = append(s, "DefaultFsOpt: "+fmt.Sprintf("%#v", this.DefaultFsOpt)+",\n")
	s = append(s, "DefaultMountOpts: "+fmt.Sprintf("%#v", this.DefaultMountOpts)+",\n")
	s = append(s, "DisablePreemptAttachments: "+fmt.Sprintf("%#v", this.DisablePreemptAttachments)+",\n")
	s = append(s, "IscsiLoginTimeout: "+fmt.Sprintf("%#v", this.IscsiLoginTimeout)+",\n")
	if this.FlashArrays != nil {
		s = append(s, "FlashArrays: "+fmt.Sprintf("%#v", this.FlashArrays)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FlashArrayEndpoint) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&fleet.FlashArrayEndpoint{")
	if this.MgmtEndpoint != nil {
		s = append(s, "MgmtEndpoint: "+fmt.Sprintf("%#v", this.MgmtEndpoint)+",\n")
	}
	if this.ApiToken != nil {
		s = append(s, "ApiToken: "+fmt.Sprintf("%#v", this.ApiToken)+",\n")
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FlashArrayEndpoint_MgmtIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FlashArrayEndpoint_MgmtIp{` +
		`MgmtIp:` + fmt.Sprintf("%#v", this.MgmtIp) + `}`}, ", ")
	return s
}
func (this *FlashArrayEndpoint_MgmtDnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FlashArrayEndpoint_MgmtDnsName{` +
		`MgmtDnsName:` + fmt.Sprintf("%#v", this.MgmtDnsName) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappTridentType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&fleet.StorageDeviceNetappTridentType{")
	if this.BackendChoice != nil {
		s = append(s, "BackendChoice: "+fmt.Sprintf("%#v", this.BackendChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDeviceNetappTridentType_NetappBackendOntapNas) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappTridentType_NetappBackendOntapNas{` +
		`NetappBackendOntapNas:` + fmt.Sprintf("%#v", this.NetappBackendOntapNas) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappTridentType_NetappBackendOntapSan) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappTridentType_NetappBackendOntapSan{` +
		`NetappBackendOntapSan:` + fmt.Sprintf("%#v", this.NetappBackendOntapSan) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 25)
	s = append(s, "&fleet.StorageDeviceNetappBackendOntapSanType{")
	s = append(s, "StorageDriverName: "+fmt.Sprintf("%#v", this.StorageDriverName)+",\n")
	if this.ManagementLif != nil {
		s = append(s, "ManagementLif: "+fmt.Sprintf("%#v", this.ManagementLif)+",\n")
	}
	if this.DataLif != nil {
		s = append(s, "DataLif: "+fmt.Sprintf("%#v", this.DataLif)+",\n")
	}
	s = append(s, "Svm: "+fmt.Sprintf("%#v", this.Svm)+",\n")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	if this.Password != nil {
		s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	}
	if this.ChapChoice != nil {
		s = append(s, "ChapChoice: "+fmt.Sprintf("%#v", this.ChapChoice)+",\n")
	}
	s = append(s, "IgroupName: "+fmt.Sprintf("%#v", this.IgroupName)+",\n")
	s = append(s, "StoragePrefix: "+fmt.Sprintf("%#v", this.StoragePrefix)+",\n")
	s = append(s, "LimitAggregateUsage: "+fmt.Sprintf("%#v", this.LimitAggregateUsage)+",\n")
	s = append(s, "LimitVolumeSize: "+fmt.Sprintf("%#v", this.LimitVolumeSize)+",\n")
	if this.VolumeDefaults != nil {
		s = append(s, "VolumeDefaults: "+fmt.Sprintf("%#v", this.VolumeDefaults)+",\n")
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	if this.Storage != nil {
		s = append(s, "Storage: "+fmt.Sprintf("%#v", this.Storage)+",\n")
	}
	s = append(s, "ClientCertificate: "+fmt.Sprintf("%#v", this.ClientCertificate)+",\n")
	if this.ClientPrivateKey != nil {
		s = append(s, "ClientPrivateKey: "+fmt.Sprintf("%#v", this.ClientPrivateKey)+",\n")
	}
	s = append(s, "TrustedCaCertificate: "+fmt.Sprintf("%#v", this.TrustedCaCertificate)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDeviceNetappBackendOntapSanType_ManagementLifIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapSanType_ManagementLifIp{` +
		`ManagementLifIp:` + fmt.Sprintf("%#v", this.ManagementLifIp) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName{` +
		`ManagementLifDnsName:` + fmt.Sprintf("%#v", this.ManagementLifDnsName) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_DataLifIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapSanType_DataLifIp{` +
		`DataLifIp:` + fmt.Sprintf("%#v", this.DataLifIp) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_DataLifDnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapSanType_DataLifDnsName{` +
		`DataLifDnsName:` + fmt.Sprintf("%#v", this.DataLifDnsName) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_NoChap) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapSanType_NoChap{` +
		`NoChap:` + fmt.Sprintf("%#v", this.NoChap) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_UseChap) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapSanType_UseChap{` +
		`UseChap:` + fmt.Sprintf("%#v", this.UseChap) + `}`}, ", ")
	return s
}
func (this *DeviceNetappBackendOntapSanChapType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&fleet.DeviceNetappBackendOntapSanChapType{")
	s = append(s, "ChapUsername: "+fmt.Sprintf("%#v", this.ChapUsername)+",\n")
	s = append(s, "ChapTargetUsername: "+fmt.Sprintf("%#v", this.ChapTargetUsername)+",\n")
	if this.ChapInitiatorSecret != nil {
		s = append(s, "ChapInitiatorSecret: "+fmt.Sprintf("%#v", this.ChapInitiatorSecret)+",\n")
	}
	if this.ChapTargetInitiatorSecret != nil {
		s = append(s, "ChapTargetInitiatorSecret: "+fmt.Sprintf("%#v", this.ChapTargetInitiatorSecret)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDeviceNetappBackendOntapNasType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 26)
	s = append(s, "&fleet.StorageDeviceNetappBackendOntapNasType{")
	s = append(s, "StorageDriverName: "+fmt.Sprintf("%#v", this.StorageDriverName)+",\n")
	s = append(s, "BackendName: "+fmt.Sprintf("%#v", this.BackendName)+",\n")
	if this.ManagementLif != nil {
		s = append(s, "ManagementLif: "+fmt.Sprintf("%#v", this.ManagementLif)+",\n")
	}
	if this.DataLif != nil {
		s = append(s, "DataLif: "+fmt.Sprintf("%#v", this.DataLif)+",\n")
	}
	s = append(s, "Svm: "+fmt.Sprintf("%#v", this.Svm)+",\n")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	if this.Password != nil {
		s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	}
	s = append(s, "AutoExportPolicy: "+fmt.Sprintf("%#v", this.AutoExportPolicy)+",\n")
	if this.AutoExportCidrs != nil {
		s = append(s, "AutoExportCidrs: "+fmt.Sprintf("%#v", this.AutoExportCidrs)+",\n")
	}
	s = append(s, "StoragePrefix: "+fmt.Sprintf("%#v", this.StoragePrefix)+",\n")
	s = append(s, "LimitAggregateUsage: "+fmt.Sprintf("%#v", this.LimitAggregateUsage)+",\n")
	s = append(s, "LimitVolumeSize: "+fmt.Sprintf("%#v", this.LimitVolumeSize)+",\n")
	s = append(s, "NfsMountOptions: "+fmt.Sprintf("%#v", this.NfsMountOptions)+",\n")
	if this.VolumeDefaults != nil {
		s = append(s, "VolumeDefaults: "+fmt.Sprintf("%#v", this.VolumeDefaults)+",\n")
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	if this.Storage != nil {
		s = append(s, "Storage: "+fmt.Sprintf("%#v", this.Storage)+",\n")
	}
	s = append(s, "ClientCertificate: "+fmt.Sprintf("%#v", this.ClientCertificate)+",\n")
	if this.ClientPrivateKey != nil {
		s = append(s, "ClientPrivateKey: "+fmt.Sprintf("%#v", this.ClientPrivateKey)+",\n")
	}
	s = append(s, "TrustedCaCertificate: "+fmt.Sprintf("%#v", this.TrustedCaCertificate)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDeviceNetappBackendOntapNasType_ManagementLifIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapNasType_ManagementLifIp{` +
		`ManagementLifIp:` + fmt.Sprintf("%#v", this.ManagementLifIp) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName{` +
		`ManagementLifDnsName:` + fmt.Sprintf("%#v", this.ManagementLifDnsName) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappBackendOntapNasType_DataLifIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapNasType_DataLifIp{` +
		`DataLifIp:` + fmt.Sprintf("%#v", this.DataLifIp) + `}`}, ", ")
	return s
}
func (this *StorageDeviceNetappBackendOntapNasType_DataLifDnsName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageDeviceNetappBackendOntapNasType_DataLifDnsName{` +
		`DataLifDnsName:` + fmt.Sprintf("%#v", this.DataLifDnsName) + `}`}, ", ")
	return s
}
func (this *OntapVolumeDefaults) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&fleet.OntapVolumeDefaults{")
	s = append(s, "SpaceReserve: "+fmt.Sprintf("%#v", this.SpaceReserve)+",\n")
	s = append(s, "SnapshotPolicy: "+fmt.Sprintf("%#v", this.SnapshotPolicy)+",\n")
	s = append(s, "SnapshotReserve: "+fmt.Sprintf("%#v", this.SnapshotReserve)+",\n")
	s = append(s, "SplitOnClone: "+fmt.Sprintf("%#v", this.SplitOnClone)+",\n")
	s = append(s, "Encryption: "+fmt.Sprintf("%#v", this.Encryption)+",\n")
	s = append(s, "UnixPermissions: "+fmt.Sprintf("%#v", this.UnixPermissions)+",\n")
	s = append(s, "SnapshotDir: "+fmt.Sprintf("%#v", this.SnapshotDir)+",\n")
	s = append(s, "ExportPolicy: "+fmt.Sprintf("%#v", this.ExportPolicy)+",\n")
	s = append(s, "SecurityStyle: "+fmt.Sprintf("%#v", this.SecurityStyle)+",\n")
	s = append(s, "TieringPolicy: "+fmt.Sprintf("%#v", this.TieringPolicy)+",\n")
	if this.QosPolicyChoice != nil {
		s = append(s, "QosPolicyChoice: "+fmt.Sprintf("%#v", this.QosPolicyChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OntapVolumeDefaults_NoQos) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.OntapVolumeDefaults_NoQos{` +
		`NoQos:` + fmt.Sprintf("%#v", this.NoQos) + `}`}, ", ")
	return s
}
func (this *OntapVolumeDefaults_QosPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.OntapVolumeDefaults_QosPolicy{` +
		`QosPolicy:` + fmt.Sprintf("%#v", this.QosPolicy) + `}`}, ", ")
	return s
}
func (this *OntapVolumeDefaults_AdaptiveQosPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.OntapVolumeDefaults_AdaptiveQosPolicy{` +
		`AdaptiveQosPolicy:` + fmt.Sprintf("%#v", this.AdaptiveQosPolicy) + `}`}, ", ")
	return s
}
func (this *OntapVirtualStoragePoolType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&fleet.OntapVirtualStoragePoolType{")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "Zone: "+fmt.Sprintf("%#v", this.Zone)+",\n")
	if this.VolumeDefaults != nil {
		s = append(s, "VolumeDefaults: "+fmt.Sprintf("%#v", this.VolumeDefaults)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FleetStorageDeviceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&fleet.FleetStorageDeviceType{")
	s = append(s, "StorageDevice: "+fmt.Sprintf("%#v", this.StorageDevice)+",\n")
	if this.DeviceChoice != nil {
		s = append(s, "DeviceChoice: "+fmt.Sprintf("%#v", this.DeviceChoice)+",\n")
	}
	keysForAdvancedAdvancedParameters := make([]string, 0, len(this.AdvancedAdvancedParameters))
	for k, _ := range this.AdvancedAdvancedParameters {
		keysForAdvancedAdvancedParameters = append(keysForAdvancedAdvancedParameters, k)
	}
	sortkeys.Strings(keysForAdvancedAdvancedParameters)
	mapStringForAdvancedAdvancedParameters := "map[string]string{"
	for _, k := range keysForAdvancedAdvancedParameters {
		mapStringForAdvancedAdvancedParameters += fmt.Sprintf("%#v: %#v,", k, this.AdvancedAdvancedParameters[k])
	}
	mapStringForAdvancedAdvancedParameters += "}"
	if this.AdvancedAdvancedParameters != nil {
		s = append(s, "AdvancedAdvancedParameters: "+mapStringForAdvancedAdvancedParameters+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FleetStorageDeviceType_NetappTrident) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FleetStorageDeviceType_NetappTrident{` +
		`NetappTrident:` + fmt.Sprintf("%#v", this.NetappTrident) + `}`}, ", ")
	return s
}
func (this *FleetStorageDeviceType_PureServiceOrchestrator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FleetStorageDeviceType_PureServiceOrchestrator{` +
		`PureServiceOrchestrator:` + fmt.Sprintf("%#v", this.PureServiceOrchestrator) + `}`}, ", ")
	return s
}
func (this *FleetStorageDeviceType_OpenebsEnterprise) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FleetStorageDeviceType_OpenebsEnterprise{` +
		`OpenebsEnterprise:` + fmt.Sprintf("%#v", this.OpenebsEnterprise) + `}`}, ", ")
	return s
}
func (this *FleetStorageDeviceListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&fleet.FleetStorageDeviceListType{")
	if this.StorageDevices != nil {
		s = append(s, "StorageDevices: "+fmt.Sprintf("%#v", this.StorageDevices)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageClassDellIsilonF800Type) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&fleet.StorageClassDellIsilonF800Type{")
	if this.HttpsChoice != nil {
		s = append(s, "HttpsChoice: "+fmt.Sprintf("%#v", this.HttpsChoice)+",\n")
	}
	s = append(s, "IscsiAccessZone: "+fmt.Sprintf("%#v", this.IscsiAccessZone)+",\n")
	s = append(s, "BasePath: "+fmt.Sprintf("%#v", this.BasePath)+",\n")
	s = append(s, "RootClientEnable: "+fmt.Sprintf("%#v", this.RootClientEnable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageClassDellIsilonF800Type_AzServiceName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageClassDellIsilonF800Type_AzServiceName{` +
		`AzServiceName:` + fmt.Sprintf("%#v", this.AzServiceName) + `}`}, ", ")
	return s
}
func (this *StorageClassDellIsilonF800Type_AzServiceIpAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.StorageClassDellIsilonF800Type_AzServiceIpAddress{` +
		`AzServiceIpAddress:` + fmt.Sprintf("%#v", this.AzServiceIpAddress) + `}`}, ", ")
	return s
}
func (this *StorageClassHPENimbusStorageAf40Type) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&fleet.StorageClassHPENimbusStorageAf40Type{")
	s = append(s, "PerfPolicy: "+fmt.Sprintf("%#v", this.PerfPolicy)+",\n")
	s = append(s, "LimitIops: "+fmt.Sprintf("%#v", this.LimitIops)+",\n")
	s = append(s, "LimitMbps: "+fmt.Sprintf("%#v", this.LimitMbps)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageClassOpenebsEnterpriseType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&fleet.StorageClassOpenebsEnterpriseType{")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "Replication: "+fmt.Sprintf("%#v", this.Replication)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageClassNetappTridentType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&fleet.StorageClassNetappTridentType{")
	keysForSelector := make([]string, 0, len(this.Selector))
	for k, _ := range this.Selector {
		keysForSelector = append(keysForSelector, k)
	}
	sortkeys.Strings(keysForSelector)
	mapStringForSelector := "map[string]string{"
	for _, k := range keysForSelector {
		mapStringForSelector += fmt.Sprintf("%#v: %#v,", k, this.Selector[k])
	}
	mapStringForSelector += "}"
	if this.Selector != nil {
		s = append(s, "Selector: "+mapStringForSelector+",\n")
	}
	s = append(s, "StoragePools: "+fmt.Sprintf("%#v", this.StoragePools)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageClassPureServiceOrchestratorType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&fleet.StorageClassPureServiceOrchestratorType{")
	s = append(s, "Backend: "+fmt.Sprintf("%#v", this.Backend)+",\n")
	s = append(s, "IopsLimit: "+fmt.Sprintf("%#v", this.IopsLimit)+",\n")
	s = append(s, "BandwidthLimit: "+fmt.Sprintf("%#v", this.BandwidthLimit)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FleetStorageClassType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&fleet.FleetStorageClassType{")
	s = append(s, "StorageDevice: "+fmt.Sprintf("%#v", this.StorageDevice)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "DefaultStorageClass: "+fmt.Sprintf("%#v", this.DefaultStorageClass)+",\n")
	if this.DeviceChoice != nil {
		s = append(s, "DeviceChoice: "+fmt.Sprintf("%#v", this.DeviceChoice)+",\n")
	}
	s = append(s, "ReclaimPolicy: "+fmt.Sprintf("%#v", this.ReclaimPolicy)+",\n")
	s = append(s, "AllowVolumeExpansion: "+fmt.Sprintf("%#v", this.AllowVolumeExpansion)+",\n")
	keysForAdvancedStorageParameters := make([]string, 0, len(this.AdvancedStorageParameters))
	for k, _ := range this.AdvancedStorageParameters {
		keysForAdvancedStorageParameters = append(keysForAdvancedStorageParameters, k)
	}
	sortkeys.Strings(keysForAdvancedStorageParameters)
	mapStringForAdvancedStorageParameters := "map[string]string{"
	for _, k := range keysForAdvancedStorageParameters {
		mapStringForAdvancedStorageParameters += fmt.Sprintf("%#v: %#v,", k, this.AdvancedStorageParameters[k])
	}
	mapStringForAdvancedStorageParameters += "}"
	if this.AdvancedStorageParameters != nil {
		s = append(s, "AdvancedStorageParameters: "+mapStringForAdvancedStorageParameters+",\n")
	}
	s = append(s, "StorageClassName: "+fmt.Sprintf("%#v", this.StorageClassName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FleetStorageClassType_NetappTrident) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FleetStorageClassType_NetappTrident{` +
		`NetappTrident:` + fmt.Sprintf("%#v", this.NetappTrident) + `}`}, ", ")
	return s
}
func (this *FleetStorageClassType_PureServiceOrchestrator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FleetStorageClassType_PureServiceOrchestrator{` +
		`PureServiceOrchestrator:` + fmt.Sprintf("%#v", this.PureServiceOrchestrator) + `}`}, ", ")
	return s
}
func (this *FleetStorageClassType_OpenebsEnterprise) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FleetStorageClassType_OpenebsEnterprise{` +
		`OpenebsEnterprise:` + fmt.Sprintf("%#v", this.OpenebsEnterprise) + `}`}, ", ")
	return s
}
func (this *FleetStorageClassListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&fleet.FleetStorageClassListType{")
	if this.StorageClasses != nil {
		s = append(s, "StorageClasses: "+fmt.Sprintf("%#v", this.StorageClasses)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BondLacpType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&fleet.BondLacpType{")
	s = append(s, "Rate: "+fmt.Sprintf("%#v", this.Rate)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FleetBondDeviceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&fleet.FleetBondDeviceType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Devices: "+fmt.Sprintf("%#v", this.Devices)+",\n")
	if this.LacpChoice != nil {
		s = append(s, "LacpChoice: "+fmt.Sprintf("%#v", this.LacpChoice)+",\n")
	}
	s = append(s, "LinkPollingInterval: "+fmt.Sprintf("%#v", this.LinkPollingInterval)+",\n")
	s = append(s, "LinkUpDelay: "+fmt.Sprintf("%#v", this.LinkUpDelay)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FleetBondDeviceType_Lacp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FleetBondDeviceType_Lacp{` +
		`Lacp:` + fmt.Sprintf("%#v", this.Lacp) + `}`}, ", ")
	return s
}
func (this *FleetBondDeviceType_ActiveBackup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.FleetBondDeviceType_ActiveBackup{` +
		`ActiveBackup:` + fmt.Sprintf("%#v", this.ActiveBackup) + `}`}, ", ")
	return s
}
func (this *FleetBondDevicesListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&fleet.FleetBondDevicesListType{")
	if this.BondDevices != nil {
		s = append(s, "BondDevices: "+fmt.Sprintf("%#v", this.BondDevices)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FleetStorageStaticRoutesListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&fleet.FleetStorageStaticRoutesListType{")
	if this.StorageRoutes != nil {
		s = append(s, "StorageRoutes: "+fmt.Sprintf("%#v", this.StorageRoutes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BGPConfiguration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&fleet.BGPConfiguration{")
	if this.BgpParameters != nil {
		s = append(s, "BgpParameters: "+fmt.Sprintf("%#v", this.BgpParameters)+",\n")
	}
	if this.Peers != nil {
		s = append(s, "Peers: "+fmt.Sprintf("%#v", this.Peers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LocalControlPlaneType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&fleet.LocalControlPlaneType{")
	if this.NetworkChoice != nil {
		s = append(s, "NetworkChoice: "+fmt.Sprintf("%#v", this.NetworkChoice)+",\n")
	}
	if this.BgpConfig != nil {
		s = append(s, "BgpConfig: "+fmt.Sprintf("%#v", this.BgpConfig)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LocalControlPlaneType_InsideVn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.LocalControlPlaneType_InsideVn{` +
		`InsideVn:` + fmt.Sprintf("%#v", this.InsideVn) + `}`}, ", ")
	return s
}
func (this *LocalControlPlaneType_OutsideVn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.LocalControlPlaneType_OutsideVn{` +
		`OutsideVn:` + fmt.Sprintf("%#v", this.OutsideVn) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 42)
	s = append(s, "&fleet.GlobalSpecType{")
	s = append(s, "FleetLabel: "+fmt.Sprintf("%#v", this.FleetLabel)+",\n")
	s = append(s, "VolterraSoftwareVersion: "+fmt.Sprintf("%#v", this.VolterraSoftwareVersion)+",\n")
	if this.Devices != nil {
		s = append(s, "Devices: "+fmt.Sprintf("%#v", this.Devices)+",\n")
	}
	if this.NetworkConnectors != nil {
		s = append(s, "NetworkConnectors: "+fmt.Sprintf("%#v", this.NetworkConnectors)+",\n")
	}
	if this.NetworkFirewall != nil {
		s = append(s, "NetworkFirewall: "+fmt.Sprintf("%#v", this.NetworkFirewall)+",\n")
	}
	s = append(s, "OperatingSystemVersion: "+fmt.Sprintf("%#v", this.OperatingSystemVersion)+",\n")
	if this.OutsideVirtualNetwork != nil {
		s = append(s, "OutsideVirtualNetwork: "+fmt.Sprintf("%#v", this.OutsideVirtualNetwork)+",\n")
	}
	if this.InsideVirtualNetwork != nil {
		s = append(s, "InsideVirtualNetwork: "+fmt.Sprintf("%#v", this.InsideVirtualNetwork)+",\n")
	}
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	if this.BondChoice != nil {
		s = append(s, "BondChoice: "+fmt.Sprintf("%#v", this.BondChoice)+",\n")
	}
	if this.StorageInterfaceChoice != nil {
		s = append(s, "StorageInterfaceChoice: "+fmt.Sprintf("%#v", this.StorageInterfaceChoice)+",\n")
	}
	if this.StorageDeviceChoice != nil {
		s = append(s, "StorageDeviceChoice: "+fmt.Sprintf("%#v", this.StorageDeviceChoice)+",\n")
	}
	if this.StorageClassChoice != nil {
		s = append(s, "StorageClassChoice: "+fmt.Sprintf("%#v", this.StorageClassChoice)+",\n")
	}
	if this.DcClusterGroupChoice != nil {
		s = append(s, "DcClusterGroupChoice: "+fmt.Sprintf("%#v", this.DcClusterGroupChoice)+",\n")
	}
	if this.GpuChoice != nil {
		s = append(s, "GpuChoice: "+fmt.Sprintf("%#v", this.GpuChoice)+",\n")
	}
	s = append(s, "EtcdClusterNetwork: "+fmt.Sprintf("%#v", this.EtcdClusterNetwork)+",\n")
	if this.StorageStaticRoutesChoice != nil {
		s = append(s, "StorageStaticRoutesChoice: "+fmt.Sprintf("%#v", this.StorageStaticRoutesChoice)+",\n")
	}
	s = append(s, "EnableDefaultFleetConfigDownload: "+fmt.Sprintf("%#v", this.EnableDefaultFleetConfigDownload)+",\n")
	s = append(s, "FleetType: "+fmt.Sprintf("%#v", this.FleetType)+",\n")
	if this.SingleSite != nil {
		s = append(s, "SingleSite: "+fmt.Sprintf("%#v", this.SingleSite)+",\n")
	}
	if this.LogsReceiverChoice != nil {
		s = append(s, "LogsReceiverChoice: "+fmt.Sprintf("%#v", this.LogsReceiverChoice)+",\n")
	}
	if this.UsbPolicyChoice != nil {
		s = append(s, "UsbPolicyChoice: "+fmt.Sprintf("%#v", this.UsbPolicyChoice)+",\n")
	}
	if this.K8SCluster != nil {
		s = append(s, "K8SCluster: "+fmt.Sprintf("%#v", this.K8SCluster)+",\n")
	}
	if this.LocalControlPlane != nil {
		s = append(s, "LocalControlPlane: "+fmt.Sprintf("%#v", this.LocalControlPlane)+",\n")
	}
	if this.ViewInternal != nil {
		s = append(s, "ViewInternal: "+fmt.Sprintf("%#v", this.ViewInternal)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_InterfaceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_InterfaceList{` +
		`InterfaceList:` + fmt.Sprintf("%#v", this.InterfaceList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DefaultInterfaces) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_DefaultInterfaces{` +
		`DefaultInterfaces:` + fmt.Sprintf("%#v", this.DefaultInterfaces) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_LegacyDevices) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_LegacyDevices{` +
		`LegacyDevices:` + fmt.Sprintf("%#v", this.LegacyDevices) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_NoBondDevices) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_NoBondDevices{` +
		`NoBondDevices:` + fmt.Sprintf("%#v", this.NoBondDevices) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_BondDeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_BondDeviceList{` +
		`BondDeviceList:` + fmt.Sprintf("%#v", this.BondDeviceList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_NoStorageInterfaces) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_NoStorageInterfaces{` +
		`NoStorageInterfaces:` + fmt.Sprintf("%#v", this.NoStorageInterfaces) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_StorageInterfaceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_StorageInterfaceList{` +
		`StorageInterfaceList:` + fmt.Sprintf("%#v", this.StorageInterfaceList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_NoStorageDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_NoStorageDevice{` +
		`NoStorageDevice:` + fmt.Sprintf("%#v", this.NoStorageDevice) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_StorageDeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_StorageDeviceList{` +
		`StorageDeviceList:` + fmt.Sprintf("%#v", this.StorageDeviceList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DefaultStorageClass) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_DefaultStorageClass{` +
		`DefaultStorageClass:` + fmt.Sprintf("%#v", this.DefaultStorageClass) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_StorageClassList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_StorageClassList{` +
		`StorageClassList:` + fmt.Sprintf("%#v", this.StorageClassList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_NoDcClusterGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_NoDcClusterGroup{` +
		`NoDcClusterGroup:` + fmt.Sprintf("%#v", this.NoDcClusterGroup) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DcClusterGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_DcClusterGroup{` +
		`DcClusterGroup:` + fmt.Sprintf("%#v", this.DcClusterGroup) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DcClusterGroupInside) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_DcClusterGroupInside{` +
		`DcClusterGroupInside:` + fmt.Sprintf("%#v", this.DcClusterGroupInside) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DisableGpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_DisableGpu{` +
		`DisableGpu:` + fmt.Sprintf("%#v", this.DisableGpu) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_EnableGpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_EnableGpu{` +
		`EnableGpu:` + fmt.Sprintf("%#v", this.EnableGpu) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_NoStorageStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_NoStorageStaticRoutes{` +
		`NoStorageStaticRoutes:` + fmt.Sprintf("%#v", this.NoStorageStaticRoutes) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_StorageStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_StorageStaticRoutes{` +
		`StorageStaticRoutes:` + fmt.Sprintf("%#v", this.StorageStaticRoutes) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_LogsStreamingDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_LogsStreamingDisabled{` +
		`LogsStreamingDisabled:` + fmt.Sprintf("%#v", this.LogsStreamingDisabled) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_LogReceiver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_LogReceiver{` +
		`LogReceiver:` + fmt.Sprintf("%#v", this.LogReceiver) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DenyAllUsb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_DenyAllUsb{` +
		`DenyAllUsb:` + fmt.Sprintf("%#v", this.DenyAllUsb) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AllowAllUsb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_AllowAllUsb{` +
		`AllowAllUsb:` + fmt.Sprintf("%#v", this.AllowAllUsb) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_UsbPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GlobalSpecType_UsbPolicy{` +
		`UsbPolicy:` + fmt.Sprintf("%#v", this.UsbPolicy) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 35)
	s = append(s, "&fleet.CreateSpecType{")
	s = append(s, "FleetLabel: "+fmt.Sprintf("%#v", this.FleetLabel)+",\n")
	s = append(s, "VolterraSoftwareVersion: "+fmt.Sprintf("%#v", this.VolterraSoftwareVersion)+",\n")
	if this.NetworkConnectors != nil {
		s = append(s, "NetworkConnectors: "+fmt.Sprintf("%#v", this.NetworkConnectors)+",\n")
	}
	if this.NetworkFirewall != nil {
		s = append(s, "NetworkFirewall: "+fmt.Sprintf("%#v", this.NetworkFirewall)+",\n")
	}
	s = append(s, "OperatingSystemVersion: "+fmt.Sprintf("%#v", this.OperatingSystemVersion)+",\n")
	if this.OutsideVirtualNetwork != nil {
		s = append(s, "OutsideVirtualNetwork: "+fmt.Sprintf("%#v", this.OutsideVirtualNetwork)+",\n")
	}
	if this.InsideVirtualNetwork != nil {
		s = append(s, "InsideVirtualNetwork: "+fmt.Sprintf("%#v", this.InsideVirtualNetwork)+",\n")
	}
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	if this.BondChoice != nil {
		s = append(s, "BondChoice: "+fmt.Sprintf("%#v", this.BondChoice)+",\n")
	}
	if this.StorageInterfaceChoice != nil {
		s = append(s, "StorageInterfaceChoice: "+fmt.Sprintf("%#v", this.StorageInterfaceChoice)+",\n")
	}
	if this.StorageDeviceChoice != nil {
		s = append(s, "StorageDeviceChoice: "+fmt.Sprintf("%#v", this.StorageDeviceChoice)+",\n")
	}
	if this.StorageClassChoice != nil {
		s = append(s, "StorageClassChoice: "+fmt.Sprintf("%#v", this.StorageClassChoice)+",\n")
	}
	if this.DcClusterGroupChoice != nil {
		s = append(s, "DcClusterGroupChoice: "+fmt.Sprintf("%#v", this.DcClusterGroupChoice)+",\n")
	}
	if this.GpuChoice != nil {
		s = append(s, "GpuChoice: "+fmt.Sprintf("%#v", this.GpuChoice)+",\n")
	}
	if this.StorageStaticRoutesChoice != nil {
		s = append(s, "StorageStaticRoutesChoice: "+fmt.Sprintf("%#v", this.StorageStaticRoutesChoice)+",\n")
	}
	s = append(s, "EnableDefaultFleetConfigDownload: "+fmt.Sprintf("%#v", this.EnableDefaultFleetConfigDownload)+",\n")
	if this.LogsReceiverChoice != nil {
		s = append(s, "LogsReceiverChoice: "+fmt.Sprintf("%#v", this.LogsReceiverChoice)+",\n")
	}
	if this.UsbPolicyChoice != nil {
		s = append(s, "UsbPolicyChoice: "+fmt.Sprintf("%#v", this.UsbPolicyChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_InterfaceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_InterfaceList{` +
		`InterfaceList:` + fmt.Sprintf("%#v", this.InterfaceList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DefaultConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_DefaultConfig{` +
		`DefaultConfig:` + fmt.Sprintf("%#v", this.DefaultConfig) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_DeviceList{` +
		`DeviceList:` + fmt.Sprintf("%#v", this.DeviceList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_NoBondDevices) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_NoBondDevices{` +
		`NoBondDevices:` + fmt.Sprintf("%#v", this.NoBondDevices) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_BondDeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_BondDeviceList{` +
		`BondDeviceList:` + fmt.Sprintf("%#v", this.BondDeviceList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_NoStorageInterfaces) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_NoStorageInterfaces{` +
		`NoStorageInterfaces:` + fmt.Sprintf("%#v", this.NoStorageInterfaces) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_StorageInterfaceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_StorageInterfaceList{` +
		`StorageInterfaceList:` + fmt.Sprintf("%#v", this.StorageInterfaceList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_NoStorageDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_NoStorageDevice{` +
		`NoStorageDevice:` + fmt.Sprintf("%#v", this.NoStorageDevice) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_StorageDeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_StorageDeviceList{` +
		`StorageDeviceList:` + fmt.Sprintf("%#v", this.StorageDeviceList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DefaultStorageClass) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_DefaultStorageClass{` +
		`DefaultStorageClass:` + fmt.Sprintf("%#v", this.DefaultStorageClass) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_StorageClassList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_StorageClassList{` +
		`StorageClassList:` + fmt.Sprintf("%#v", this.StorageClassList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_NoDcClusterGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_NoDcClusterGroup{` +
		`NoDcClusterGroup:` + fmt.Sprintf("%#v", this.NoDcClusterGroup) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DcClusterGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_DcClusterGroup{` +
		`DcClusterGroup:` + fmt.Sprintf("%#v", this.DcClusterGroup) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DcClusterGroupInside) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_DcClusterGroupInside{` +
		`DcClusterGroupInside:` + fmt.Sprintf("%#v", this.DcClusterGroupInside) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DisableGpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_DisableGpu{` +
		`DisableGpu:` + fmt.Sprintf("%#v", this.DisableGpu) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_EnableGpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_EnableGpu{` +
		`EnableGpu:` + fmt.Sprintf("%#v", this.EnableGpu) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_NoStorageStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_NoStorageStaticRoutes{` +
		`NoStorageStaticRoutes:` + fmt.Sprintf("%#v", this.NoStorageStaticRoutes) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_StorageStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_StorageStaticRoutes{` +
		`StorageStaticRoutes:` + fmt.Sprintf("%#v", this.StorageStaticRoutes) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_LogsStreamingDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_LogsStreamingDisabled{` +
		`LogsStreamingDisabled:` + fmt.Sprintf("%#v", this.LogsStreamingDisabled) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_LogReceiver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_LogReceiver{` +
		`LogReceiver:` + fmt.Sprintf("%#v", this.LogReceiver) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DenyAllUsb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_DenyAllUsb{` +
		`DenyAllUsb:` + fmt.Sprintf("%#v", this.DenyAllUsb) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AllowAllUsb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_AllowAllUsb{` +
		`AllowAllUsb:` + fmt.Sprintf("%#v", this.AllowAllUsb) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_UsbPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.CreateSpecType_UsbPolicy{` +
		`UsbPolicy:` + fmt.Sprintf("%#v", this.UsbPolicy) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 34)
	s = append(s, "&fleet.ReplaceSpecType{")
	s = append(s, "VolterraSoftwareVersion: "+fmt.Sprintf("%#v", this.VolterraSoftwareVersion)+",\n")
	if this.NetworkConnectors != nil {
		s = append(s, "NetworkConnectors: "+fmt.Sprintf("%#v", this.NetworkConnectors)+",\n")
	}
	if this.NetworkFirewall != nil {
		s = append(s, "NetworkFirewall: "+fmt.Sprintf("%#v", this.NetworkFirewall)+",\n")
	}
	s = append(s, "OperatingSystemVersion: "+fmt.Sprintf("%#v", this.OperatingSystemVersion)+",\n")
	if this.OutsideVirtualNetwork != nil {
		s = append(s, "OutsideVirtualNetwork: "+fmt.Sprintf("%#v", this.OutsideVirtualNetwork)+",\n")
	}
	if this.InsideVirtualNetwork != nil {
		s = append(s, "InsideVirtualNetwork: "+fmt.Sprintf("%#v", this.InsideVirtualNetwork)+",\n")
	}
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	if this.BondChoice != nil {
		s = append(s, "BondChoice: "+fmt.Sprintf("%#v", this.BondChoice)+",\n")
	}
	if this.StorageInterfaceChoice != nil {
		s = append(s, "StorageInterfaceChoice: "+fmt.Sprintf("%#v", this.StorageInterfaceChoice)+",\n")
	}
	if this.StorageDeviceChoice != nil {
		s = append(s, "StorageDeviceChoice: "+fmt.Sprintf("%#v", this.StorageDeviceChoice)+",\n")
	}
	if this.StorageClassChoice != nil {
		s = append(s, "StorageClassChoice: "+fmt.Sprintf("%#v", this.StorageClassChoice)+",\n")
	}
	if this.DcClusterGroupChoice != nil {
		s = append(s, "DcClusterGroupChoice: "+fmt.Sprintf("%#v", this.DcClusterGroupChoice)+",\n")
	}
	if this.GpuChoice != nil {
		s = append(s, "GpuChoice: "+fmt.Sprintf("%#v", this.GpuChoice)+",\n")
	}
	if this.StorageStaticRoutesChoice != nil {
		s = append(s, "StorageStaticRoutesChoice: "+fmt.Sprintf("%#v", this.StorageStaticRoutesChoice)+",\n")
	}
	s = append(s, "EnableDefaultFleetConfigDownload: "+fmt.Sprintf("%#v", this.EnableDefaultFleetConfigDownload)+",\n")
	if this.LogsReceiverChoice != nil {
		s = append(s, "LogsReceiverChoice: "+fmt.Sprintf("%#v", this.LogsReceiverChoice)+",\n")
	}
	if this.UsbPolicyChoice != nil {
		s = append(s, "UsbPolicyChoice: "+fmt.Sprintf("%#v", this.UsbPolicyChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_InterfaceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_InterfaceList{` +
		`InterfaceList:` + fmt.Sprintf("%#v", this.InterfaceList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DefaultConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_DefaultConfig{` +
		`DefaultConfig:` + fmt.Sprintf("%#v", this.DefaultConfig) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_DeviceList{` +
		`DeviceList:` + fmt.Sprintf("%#v", this.DeviceList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_NoBondDevices) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_NoBondDevices{` +
		`NoBondDevices:` + fmt.Sprintf("%#v", this.NoBondDevices) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_BondDeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_BondDeviceList{` +
		`BondDeviceList:` + fmt.Sprintf("%#v", this.BondDeviceList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_NoStorageInterfaces) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_NoStorageInterfaces{` +
		`NoStorageInterfaces:` + fmt.Sprintf("%#v", this.NoStorageInterfaces) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_StorageInterfaceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_StorageInterfaceList{` +
		`StorageInterfaceList:` + fmt.Sprintf("%#v", this.StorageInterfaceList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_NoStorageDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_NoStorageDevice{` +
		`NoStorageDevice:` + fmt.Sprintf("%#v", this.NoStorageDevice) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_StorageDeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_StorageDeviceList{` +
		`StorageDeviceList:` + fmt.Sprintf("%#v", this.StorageDeviceList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DefaultStorageClass) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_DefaultStorageClass{` +
		`DefaultStorageClass:` + fmt.Sprintf("%#v", this.DefaultStorageClass) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_StorageClassList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_StorageClassList{` +
		`StorageClassList:` + fmt.Sprintf("%#v", this.StorageClassList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_NoDcClusterGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_NoDcClusterGroup{` +
		`NoDcClusterGroup:` + fmt.Sprintf("%#v", this.NoDcClusterGroup) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DcClusterGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_DcClusterGroup{` +
		`DcClusterGroup:` + fmt.Sprintf("%#v", this.DcClusterGroup) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DcClusterGroupInside) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_DcClusterGroupInside{` +
		`DcClusterGroupInside:` + fmt.Sprintf("%#v", this.DcClusterGroupInside) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DisableGpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_DisableGpu{` +
		`DisableGpu:` + fmt.Sprintf("%#v", this.DisableGpu) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_EnableGpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_EnableGpu{` +
		`EnableGpu:` + fmt.Sprintf("%#v", this.EnableGpu) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_NoStorageStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_NoStorageStaticRoutes{` +
		`NoStorageStaticRoutes:` + fmt.Sprintf("%#v", this.NoStorageStaticRoutes) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_StorageStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_StorageStaticRoutes{` +
		`StorageStaticRoutes:` + fmt.Sprintf("%#v", this.StorageStaticRoutes) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_LogsStreamingDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_LogsStreamingDisabled{` +
		`LogsStreamingDisabled:` + fmt.Sprintf("%#v", this.LogsStreamingDisabled) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_LogReceiver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_LogReceiver{` +
		`LogReceiver:` + fmt.Sprintf("%#v", this.LogReceiver) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DenyAllUsb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_DenyAllUsb{` +
		`DenyAllUsb:` + fmt.Sprintf("%#v", this.DenyAllUsb) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AllowAllUsb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_AllowAllUsb{` +
		`AllowAllUsb:` + fmt.Sprintf("%#v", this.AllowAllUsb) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_UsbPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.ReplaceSpecType_UsbPolicy{` +
		`UsbPolicy:` + fmt.Sprintf("%#v", this.UsbPolicy) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 35)
	s = append(s, "&fleet.GetSpecType{")
	s = append(s, "FleetLabel: "+fmt.Sprintf("%#v", this.FleetLabel)+",\n")
	s = append(s, "VolterraSoftwareVersion: "+fmt.Sprintf("%#v", this.VolterraSoftwareVersion)+",\n")
	if this.NetworkConnectors != nil {
		s = append(s, "NetworkConnectors: "+fmt.Sprintf("%#v", this.NetworkConnectors)+",\n")
	}
	if this.NetworkFirewall != nil {
		s = append(s, "NetworkFirewall: "+fmt.Sprintf("%#v", this.NetworkFirewall)+",\n")
	}
	s = append(s, "OperatingSystemVersion: "+fmt.Sprintf("%#v", this.OperatingSystemVersion)+",\n")
	if this.OutsideVirtualNetwork != nil {
		s = append(s, "OutsideVirtualNetwork: "+fmt.Sprintf("%#v", this.OutsideVirtualNetwork)+",\n")
	}
	if this.InsideVirtualNetwork != nil {
		s = append(s, "InsideVirtualNetwork: "+fmt.Sprintf("%#v", this.InsideVirtualNetwork)+",\n")
	}
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	if this.BondChoice != nil {
		s = append(s, "BondChoice: "+fmt.Sprintf("%#v", this.BondChoice)+",\n")
	}
	if this.StorageInterfaceChoice != nil {
		s = append(s, "StorageInterfaceChoice: "+fmt.Sprintf("%#v", this.StorageInterfaceChoice)+",\n")
	}
	if this.StorageDeviceChoice != nil {
		s = append(s, "StorageDeviceChoice: "+fmt.Sprintf("%#v", this.StorageDeviceChoice)+",\n")
	}
	if this.StorageClassChoice != nil {
		s = append(s, "StorageClassChoice: "+fmt.Sprintf("%#v", this.StorageClassChoice)+",\n")
	}
	if this.DcClusterGroupChoice != nil {
		s = append(s, "DcClusterGroupChoice: "+fmt.Sprintf("%#v", this.DcClusterGroupChoice)+",\n")
	}
	if this.GpuChoice != nil {
		s = append(s, "GpuChoice: "+fmt.Sprintf("%#v", this.GpuChoice)+",\n")
	}
	if this.StorageStaticRoutesChoice != nil {
		s = append(s, "StorageStaticRoutesChoice: "+fmt.Sprintf("%#v", this.StorageStaticRoutesChoice)+",\n")
	}
	s = append(s, "EnableDefaultFleetConfigDownload: "+fmt.Sprintf("%#v", this.EnableDefaultFleetConfigDownload)+",\n")
	if this.LogsReceiverChoice != nil {
		s = append(s, "LogsReceiverChoice: "+fmt.Sprintf("%#v", this.LogsReceiverChoice)+",\n")
	}
	if this.UsbPolicyChoice != nil {
		s = append(s, "UsbPolicyChoice: "+fmt.Sprintf("%#v", this.UsbPolicyChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_InterfaceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_InterfaceList{` +
		`InterfaceList:` + fmt.Sprintf("%#v", this.InterfaceList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DefaultConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_DefaultConfig{` +
		`DefaultConfig:` + fmt.Sprintf("%#v", this.DefaultConfig) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_DeviceList{` +
		`DeviceList:` + fmt.Sprintf("%#v", this.DeviceList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_NoBondDevices) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_NoBondDevices{` +
		`NoBondDevices:` + fmt.Sprintf("%#v", this.NoBondDevices) + `}`}, ", ")
	return s
}
func (this *GetSpecType_BondDeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_BondDeviceList{` +
		`BondDeviceList:` + fmt.Sprintf("%#v", this.BondDeviceList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_NoStorageInterfaces) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_NoStorageInterfaces{` +
		`NoStorageInterfaces:` + fmt.Sprintf("%#v", this.NoStorageInterfaces) + `}`}, ", ")
	return s
}
func (this *GetSpecType_StorageInterfaceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_StorageInterfaceList{` +
		`StorageInterfaceList:` + fmt.Sprintf("%#v", this.StorageInterfaceList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_NoStorageDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_NoStorageDevice{` +
		`NoStorageDevice:` + fmt.Sprintf("%#v", this.NoStorageDevice) + `}`}, ", ")
	return s
}
func (this *GetSpecType_StorageDeviceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_StorageDeviceList{` +
		`StorageDeviceList:` + fmt.Sprintf("%#v", this.StorageDeviceList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DefaultStorageClass) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_DefaultStorageClass{` +
		`DefaultStorageClass:` + fmt.Sprintf("%#v", this.DefaultStorageClass) + `}`}, ", ")
	return s
}
func (this *GetSpecType_StorageClassList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_StorageClassList{` +
		`StorageClassList:` + fmt.Sprintf("%#v", this.StorageClassList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_NoDcClusterGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_NoDcClusterGroup{` +
		`NoDcClusterGroup:` + fmt.Sprintf("%#v", this.NoDcClusterGroup) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DcClusterGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_DcClusterGroup{` +
		`DcClusterGroup:` + fmt.Sprintf("%#v", this.DcClusterGroup) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DcClusterGroupInside) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_DcClusterGroupInside{` +
		`DcClusterGroupInside:` + fmt.Sprintf("%#v", this.DcClusterGroupInside) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DisableGpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_DisableGpu{` +
		`DisableGpu:` + fmt.Sprintf("%#v", this.DisableGpu) + `}`}, ", ")
	return s
}
func (this *GetSpecType_EnableGpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_EnableGpu{` +
		`EnableGpu:` + fmt.Sprintf("%#v", this.EnableGpu) + `}`}, ", ")
	return s
}
func (this *GetSpecType_NoStorageStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_NoStorageStaticRoutes{` +
		`NoStorageStaticRoutes:` + fmt.Sprintf("%#v", this.NoStorageStaticRoutes) + `}`}, ", ")
	return s
}
func (this *GetSpecType_StorageStaticRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_StorageStaticRoutes{` +
		`StorageStaticRoutes:` + fmt.Sprintf("%#v", this.StorageStaticRoutes) + `}`}, ", ")
	return s
}
func (this *GetSpecType_LogsStreamingDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_LogsStreamingDisabled{` +
		`LogsStreamingDisabled:` + fmt.Sprintf("%#v", this.LogsStreamingDisabled) + `}`}, ", ")
	return s
}
func (this *GetSpecType_LogReceiver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_LogReceiver{` +
		`LogReceiver:` + fmt.Sprintf("%#v", this.LogReceiver) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DenyAllUsb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_DenyAllUsb{` +
		`DenyAllUsb:` + fmt.Sprintf("%#v", this.DenyAllUsb) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AllowAllUsb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_AllowAllUsb{` +
		`AllowAllUsb:` + fmt.Sprintf("%#v", this.AllowAllUsb) + `}`}, ", ")
	return s
}
func (this *GetSpecType_UsbPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&fleet.GetSpecType_UsbPolicy{` +
		`UsbPolicy:` + fmt.Sprintf("%#v", this.UsbPolicy) + `}`}, ", ")
	return s
}
func (this *FleetStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&fleet.FleetStatus{")
	s = append(s, "AvailableSoftwareVersion: "+fmt.Sprintf("%#v", this.AvailableSoftwareVersion)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *NetworkingDeviceInstanceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkingDeviceInstanceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Interface) > 0 {
		for _, msg := range m.Interface {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Use != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Use))
	}
	return i, nil
}

func (m *GenericDeviceInstanceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenericDeviceInstanceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DeviceInstanceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceInstanceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Owner != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Owner))
	}
	if m.DeviceInstance != nil {
		nn1, err := m.DeviceInstance.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *DeviceInstanceType_NetworkDevice) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NetworkDevice != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NetworkDevice.Size()))
		n2, err := m.NetworkDevice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *FleetInterfaceListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetInterfaceListType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for _, msg := range m.Interfaces {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FleetDeviceListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetDeviceListType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Devices) > 0 {
		for _, msg := range m.Devices {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StorageDeviceOpenebsEnterpriseType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDeviceOpenebsEnterpriseType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MayastorPools) > 0 {
		for _, msg := range m.MayastorPools {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *OpenebsMayastorPoolType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenebsMayastorPoolType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PoolName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PoolName)))
		i += copy(dAtA[i:], m.PoolName)
	}
	if len(m.Node) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Node)))
		i += copy(dAtA[i:], m.Node)
	}
	if len(m.PoolDiskDevices) > 0 {
		for _, s := range m.PoolDiskDevices {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *StorageDeviceDellIsilonF800Type) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDeviceDellIsilonF800Type) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if m.Password != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Password.Size()))
		n3, err := m.Password.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.HttpsChoice != nil {
		nn4, err := m.HttpsChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	if m.AddressChoice != nil {
		nn5, err := m.AddressChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	if m.ApiServerPort != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ApiServerPort))
	}
	if len(m.IscsiAccessZone) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IscsiAccessZone)))
		i += copy(dAtA[i:], m.IscsiAccessZone)
	}
	if len(m.VolumePrefix) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VolumePrefix)))
		i += copy(dAtA[i:], m.VolumePrefix)
	}
	if len(m.BasePath) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BasePath)))
		i += copy(dAtA[i:], m.BasePath)
	}
	return i, nil
}

func (m *StorageDeviceDellIsilonF800Type_SecureNetwork) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SecureNetwork != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SecureNetwork.Size()))
		n6, err := m.SecureNetwork.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *StorageDeviceDellIsilonF800Type_TrustedCaUrl) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x2a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.TrustedCaUrl)))
	i += copy(dAtA[i:], m.TrustedCaUrl)
	return i, nil
}
func (m *StorageDeviceDellIsilonF800Type_ApiServerName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x3a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ApiServerName)))
	i += copy(dAtA[i:], m.ApiServerName)
	return i, nil
}
func (m *StorageDeviceDellIsilonF800Type_ApiServerIpAddress) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x42
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ApiServerIpAddress)))
	i += copy(dAtA[i:], m.ApiServerIpAddress)
	return i, nil
}
func (m *StorageDeviceHPENimbusStorageAf40Type) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDeviceHPENimbusStorageAf40Type) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StorageServerName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StorageServerName)))
		i += copy(dAtA[i:], m.StorageServerName)
	}
	if len(m.StorageServerIpAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StorageServerIpAddress)))
		i += copy(dAtA[i:], m.StorageServerIpAddress)
	}
	if m.ApiServerPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ApiServerPort))
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if m.Password != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Password.Size()))
		n7, err := m.Password.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.PerfPolicy) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PerfPolicy)))
		i += copy(dAtA[i:], m.PerfPolicy)
	}
	if m.LimitIops != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LimitIops))
	}
	if m.LimitMbps != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LimitMbps))
	}
	return i, nil
}

func (m *StorageDevicePureStorageServiceOrchestratorType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDevicePureStorageServiceOrchestratorType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterId)))
		i += copy(dAtA[i:], m.ClusterId)
	}
	if m.EnableStorageTopology {
		dAtA[i] = 0x10
		i++
		if m.EnableStorageTopology {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EnableStrictTopology {
		dAtA[i] = 0x18
		i++
		if m.EnableStrictTopology {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Arrays != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Arrays.Size()))
		n8, err := m.Arrays.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *PsoArrayConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PsoArrayConfiguration) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FlashArray != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.FlashArray.Size()))
		n9, err := m.FlashArray.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.FlashBlade != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.FlashBlade.Size()))
		n10, err := m.FlashBlade.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *FlashBladeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlashBladeType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EnableSnapshotDirectory {
		dAtA[i] = 0x8
		i++
		if m.EnableSnapshotDirectory {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ExportRules) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExportRules)))
		i += copy(dAtA[i:], m.ExportRules)
	}
	if len(m.FlashBlades) > 0 {
		for _, msg := range m.FlashBlades {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FlashBladeEndpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlashBladeEndpoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MgmtEndpoint != nil {
		nn11, err := m.MgmtEndpoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn11
	}
	if m.ApiToken != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ApiToken.Size()))
		n12, err := m.ApiToken.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.NfsEndpoint != nil {
		nn13, err := m.NfsEndpoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn13
	}
	if len(m.Lables) > 0 {
		keysForLables := make([]string, 0, len(m.Lables))
		for k, _ := range m.Lables {
			keysForLables = append(keysForLables, string(k))
		}
		sortkeys.Strings(keysForLables)
		for _, k := range keysForLables {
			dAtA[i] = 0x42
			i++
			v := m.Lables[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *FlashBladeEndpoint_MgmtIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.MgmtIp)))
	i += copy(dAtA[i:], m.MgmtIp)
	return i, nil
}
func (m *FlashBladeEndpoint_MgmtDnsName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.MgmtDnsName)))
	i += copy(dAtA[i:], m.MgmtDnsName)
	return i, nil
}
func (m *FlashBladeEndpoint_NfsEndpointIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x32
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.NfsEndpointIp)))
	i += copy(dAtA[i:], m.NfsEndpointIp)
	return i, nil
}
func (m *FlashBladeEndpoint_NfsEndpointDnsName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x3a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.NfsEndpointDnsName)))
	i += copy(dAtA[i:], m.NfsEndpointDnsName)
	return i, nil
}
func (m *FlashArrayType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlashArrayType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SanType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SanType)))
		i += copy(dAtA[i:], m.SanType)
	}
	if len(m.DefaultFsType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DefaultFsType)))
		i += copy(dAtA[i:], m.DefaultFsType)
	}
	if len(m.DefaultFsOpt) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DefaultFsOpt)))
		i += copy(dAtA[i:], m.DefaultFsOpt)
	}
	if len(m.DefaultMountOpts) > 0 {
		for _, s := range m.DefaultMountOpts {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.DisablePreemptAttachments {
		dAtA[i] = 0x28
		i++
		if m.DisablePreemptAttachments {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IscsiLoginTimeout != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IscsiLoginTimeout))
	}
	if len(m.FlashArrays) > 0 {
		for _, msg := range m.FlashArrays {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FlashArrayEndpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlashArrayEndpoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MgmtEndpoint != nil {
		nn14, err := m.MgmtEndpoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	if m.ApiToken != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ApiToken.Size()))
		n15, err := m.ApiToken.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k, _ := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		sortkeys.Strings(keysForLabels)
		for _, k := range keysForLabels {
			dAtA[i] = 0x2a
			i++
			v := m.Labels[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *FlashArrayEndpoint_MgmtIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.MgmtIp)))
	i += copy(dAtA[i:], m.MgmtIp)
	return i, nil
}
func (m *FlashArrayEndpoint_MgmtDnsName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.MgmtDnsName)))
	i += copy(dAtA[i:], m.MgmtDnsName)
	return i, nil
}
func (m *StorageDeviceNetappTridentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDeviceNetappTridentType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BackendChoice != nil {
		nn16, err := m.BackendChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn16
	}
	return i, nil
}

func (m *StorageDeviceNetappTridentType_NetappBackendOntapNas) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NetappBackendOntapNas != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NetappBackendOntapNas.Size()))
		n17, err := m.NetappBackendOntapNas.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *StorageDeviceNetappTridentType_NetappBackendOntapSan) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NetappBackendOntapSan != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NetappBackendOntapSan.Size()))
		n18, err := m.NetappBackendOntapSan.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *StorageDeviceNetappBackendOntapSanType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDeviceNetappBackendOntapSanType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StorageDriverName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StorageDriverName)))
		i += copy(dAtA[i:], m.StorageDriverName)
	}
	if m.ManagementLif != nil {
		nn19, err := m.ManagementLif.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn19
	}
	if m.DataLif != nil {
		nn20, err := m.DataLif.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn20
	}
	if len(m.Svm) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Svm)))
		i += copy(dAtA[i:], m.Svm)
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if m.Password != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Password.Size()))
		n21, err := m.Password.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.ChapChoice != nil {
		nn22, err := m.ChapChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn22
	}
	if len(m.IgroupName) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IgroupName)))
		i += copy(dAtA[i:], m.IgroupName)
	}
	if len(m.StoragePrefix) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StoragePrefix)))
		i += copy(dAtA[i:], m.StoragePrefix)
	}
	if m.LimitAggregateUsage != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LimitAggregateUsage))
	}
	if m.LimitVolumeSize != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LimitVolumeSize))
	}
	if m.VolumeDefaults != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VolumeDefaults.Size()))
		n23, err := m.VolumeDefaults.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k, _ := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		sortkeys.Strings(keysForLabels)
		for _, k := range keysForLabels {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			v := m.Labels[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Region) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	if len(m.Storage) > 0 {
		for _, msg := range m.Storage {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ClientCertificate) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientCertificate)))
		i += copy(dAtA[i:], m.ClientCertificate)
	}
	if m.ClientPrivateKey != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClientPrivateKey.Size()))
		n24, err := m.ClientPrivateKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if len(m.TrustedCaCertificate) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TrustedCaCertificate)))
		i += copy(dAtA[i:], m.TrustedCaCertificate)
	}
	return i, nil
}

func (m *StorageDeviceNetappBackendOntapSanType_ManagementLifIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x22
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ManagementLifIp)))
	i += copy(dAtA[i:], m.ManagementLifIp)
	return i, nil
}
func (m *StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x2a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ManagementLifDnsName)))
	i += copy(dAtA[i:], m.ManagementLifDnsName)
	return i, nil
}
func (m *StorageDeviceNetappBackendOntapSanType_DataLifIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x3a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DataLifIp)))
	i += copy(dAtA[i:], m.DataLifIp)
	return i, nil
}
func (m *StorageDeviceNetappBackendOntapSanType_DataLifDnsName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x42
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DataLifDnsName)))
	i += copy(dAtA[i:], m.DataLifDnsName)
	return i, nil
}
func (m *StorageDeviceNetappBackendOntapSanType_NoChap) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoChap != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoChap.Size()))
		n25, err := m.NoChap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *StorageDeviceNetappBackendOntapSanType_UseChap) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UseChap != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.UseChap.Size()))
		n26, err := m.UseChap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *DeviceNetappBackendOntapSanChapType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceNetappBackendOntapSanChapType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChapUsername) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ChapUsername)))
		i += copy(dAtA[i:], m.ChapUsername)
	}
	if len(m.ChapTargetUsername) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ChapTargetUsername)))
		i += copy(dAtA[i:], m.ChapTargetUsername)
	}
	if m.ChapInitiatorSecret != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ChapInitiatorSecret.Size()))
		n27, err := m.ChapInitiatorSecret.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.ChapTargetInitiatorSecret != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ChapTargetInitiatorSecret.Size()))
		n28, err := m.ChapTargetInitiatorSecret.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *StorageDeviceNetappBackendOntapNasType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDeviceNetappBackendOntapNasType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StorageDriverName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StorageDriverName)))
		i += copy(dAtA[i:], m.StorageDriverName)
	}
	if len(m.BackendName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BackendName)))
		i += copy(dAtA[i:], m.BackendName)
	}
	if m.ManagementLif != nil {
		nn29, err := m.ManagementLif.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn29
	}
	if m.DataLif != nil {
		nn30, err := m.DataLif.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn30
	}
	if len(m.Svm) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Svm)))
		i += copy(dAtA[i:], m.Svm)
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if m.Password != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Password.Size()))
		n31, err := m.Password.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.AutoExportPolicy {
		dAtA[i] = 0x60
		i++
		if m.AutoExportPolicy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AutoExportCidrs != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AutoExportCidrs.Size()))
		n32, err := m.AutoExportCidrs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if len(m.StoragePrefix) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StoragePrefix)))
		i += copy(dAtA[i:], m.StoragePrefix)
	}
	if len(m.LimitAggregateUsage) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LimitAggregateUsage)))
		i += copy(dAtA[i:], m.LimitAggregateUsage)
	}
	if len(m.LimitVolumeSize) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LimitVolumeSize)))
		i += copy(dAtA[i:], m.LimitVolumeSize)
	}
	if len(m.NfsMountOptions) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NfsMountOptions)))
		i += copy(dAtA[i:], m.NfsMountOptions)
	}
	if m.VolumeDefaults != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VolumeDefaults.Size()))
		n33, err := m.VolumeDefaults.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k, _ := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		sortkeys.Strings(keysForLabels)
		for _, k := range keysForLabels {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			v := m.Labels[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Region) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	if len(m.Storage) > 0 {
		for _, msg := range m.Storage {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ClientCertificate) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientCertificate)))
		i += copy(dAtA[i:], m.ClientCertificate)
	}
	if m.ClientPrivateKey != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ClientPrivateKey.Size()))
		n34, err := m.ClientPrivateKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if len(m.TrustedCaCertificate) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TrustedCaCertificate)))
		i += copy(dAtA[i:], m.TrustedCaCertificate)
	}
	return i, nil
}

func (m *StorageDeviceNetappBackendOntapNasType_ManagementLifIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x22
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ManagementLifIp)))
	i += copy(dAtA[i:], m.ManagementLifIp)
	return i, nil
}
func (m *StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x2a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ManagementLifDnsName)))
	i += copy(dAtA[i:], m.ManagementLifDnsName)
	return i, nil
}
func (m *StorageDeviceNetappBackendOntapNasType_DataLifIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x3a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DataLifIp)))
	i += copy(dAtA[i:], m.DataLifIp)
	return i, nil
}
func (m *StorageDeviceNetappBackendOntapNasType_DataLifDnsName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x42
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DataLifDnsName)))
	i += copy(dAtA[i:], m.DataLifDnsName)
	return i, nil
}
func (m *OntapVolumeDefaults) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OntapVolumeDefaults) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SpaceReserve) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SpaceReserve)))
		i += copy(dAtA[i:], m.SpaceReserve)
	}
	if len(m.SnapshotPolicy) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SnapshotPolicy)))
		i += copy(dAtA[i:], m.SnapshotPolicy)
	}
	if len(m.SnapshotReserve) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SnapshotReserve)))
		i += copy(dAtA[i:], m.SnapshotReserve)
	}
	if m.SplitOnClone {
		dAtA[i] = 0x20
		i++
		if m.SplitOnClone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Encryption {
		dAtA[i] = 0x28
		i++
		if m.Encryption {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UnixPermissions != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.UnixPermissions))
	}
	if m.SnapshotDir {
		dAtA[i] = 0x38
		i++
		if m.SnapshotDir {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ExportPolicy) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExportPolicy)))
		i += copy(dAtA[i:], m.ExportPolicy)
	}
	if len(m.SecurityStyle) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SecurityStyle)))
		i += copy(dAtA[i:], m.SecurityStyle)
	}
	if len(m.TieringPolicy) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TieringPolicy)))
		i += copy(dAtA[i:], m.TieringPolicy)
	}
	if m.QosPolicyChoice != nil {
		nn35, err := m.QosPolicyChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn35
	}
	return i, nil
}

func (m *OntapVolumeDefaults_NoQos) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoQos != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoQos.Size()))
		n36, err := m.NoQos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}
func (m *OntapVolumeDefaults_QosPolicy) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x6a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.QosPolicy)))
	i += copy(dAtA[i:], m.QosPolicy)
	return i, nil
}
func (m *OntapVolumeDefaults_AdaptiveQosPolicy) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x72
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.AdaptiveQosPolicy)))
	i += copy(dAtA[i:], m.AdaptiveQosPolicy)
	return i, nil
}
func (m *OntapVirtualStoragePoolType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OntapVirtualStoragePoolType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k, _ := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		sortkeys.Strings(keysForLabels)
		for _, k := range keysForLabels {
			dAtA[i] = 0xa
			i++
			v := m.Labels[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Zone) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Zone)))
		i += copy(dAtA[i:], m.Zone)
	}
	if m.VolumeDefaults != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.VolumeDefaults.Size()))
		n37, err := m.VolumeDefaults.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}

func (m *FleetStorageDeviceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetStorageDeviceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StorageDevice) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StorageDevice)))
		i += copy(dAtA[i:], m.StorageDevice)
	}
	if len(m.AdvancedAdvancedParameters) > 0 {
		keysForAdvancedAdvancedParameters := make([]string, 0, len(m.AdvancedAdvancedParameters))
		for k, _ := range m.AdvancedAdvancedParameters {
			keysForAdvancedAdvancedParameters = append(keysForAdvancedAdvancedParameters, string(k))
		}
		sortkeys.Strings(keysForAdvancedAdvancedParameters)
		for _, k := range keysForAdvancedAdvancedParameters {
			dAtA[i] = 0x2a
			i++
			v := m.AdvancedAdvancedParameters[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.DeviceChoice != nil {
		nn38, err := m.DeviceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn38
	}
	return i, nil
}

func (m *FleetStorageDeviceType_NetappTrident) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NetappTrident != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NetappTrident.Size()))
		n39, err := m.NetappTrident.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}
func (m *FleetStorageDeviceType_PureServiceOrchestrator) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PureServiceOrchestrator != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PureServiceOrchestrator.Size()))
		n40, err := m.PureServiceOrchestrator.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}
func (m *FleetStorageDeviceType_OpenebsEnterprise) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OpenebsEnterprise != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.OpenebsEnterprise.Size()))
		n41, err := m.OpenebsEnterprise.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}
func (m *FleetStorageDeviceListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetStorageDeviceListType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StorageDevices) > 0 {
		for _, msg := range m.StorageDevices {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StorageClassDellIsilonF800Type) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageClassDellIsilonF800Type) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HttpsChoice != nil {
		nn42, err := m.HttpsChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn42
	}
	if len(m.IscsiAccessZone) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IscsiAccessZone)))
		i += copy(dAtA[i:], m.IscsiAccessZone)
	}
	if len(m.BasePath) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BasePath)))
		i += copy(dAtA[i:], m.BasePath)
	}
	if m.RootClientEnable {
		dAtA[i] = 0x30
		i++
		if m.RootClientEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *StorageClassDellIsilonF800Type_AzServiceName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.AzServiceName)))
	i += copy(dAtA[i:], m.AzServiceName)
	return i, nil
}
func (m *StorageClassDellIsilonF800Type_AzServiceIpAddress) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.AzServiceIpAddress)))
	i += copy(dAtA[i:], m.AzServiceIpAddress)
	return i, nil
}
func (m *StorageClassHPENimbusStorageAf40Type) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageClassHPENimbusStorageAf40Type) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PerfPolicy) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PerfPolicy)))
		i += copy(dAtA[i:], m.PerfPolicy)
	}
	if m.LimitIops != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LimitIops))
	}
	if m.LimitMbps != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LimitMbps))
	}
	return i, nil
}

func (m *StorageClassOpenebsEnterpriseType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageClassOpenebsEnterpriseType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Protocol) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.Replication != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Replication))
	}
	return i, nil
}

func (m *StorageClassNetappTridentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageClassNetappTridentType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Selector) > 0 {
		keysForSelector := make([]string, 0, len(m.Selector))
		for k, _ := range m.Selector {
			keysForSelector = append(keysForSelector, string(k))
		}
		sortkeys.Strings(keysForSelector)
		for _, k := range keysForSelector {
			dAtA[i] = 0xa
			i++
			v := m.Selector[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.StoragePools) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StoragePools)))
		i += copy(dAtA[i:], m.StoragePools)
	}
	return i, nil
}

func (m *StorageClassPureServiceOrchestratorType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageClassPureServiceOrchestratorType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Backend) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Backend)))
		i += copy(dAtA[i:], m.Backend)
	}
	if m.IopsLimit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.IopsLimit))
	}
	if len(m.BandwidthLimit) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BandwidthLimit)))
		i += copy(dAtA[i:], m.BandwidthLimit)
	}
	return i, nil
}

func (m *FleetStorageClassType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetStorageClassType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StorageDevice) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StorageDevice)))
		i += copy(dAtA[i:], m.StorageDevice)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.DefaultStorageClass {
		dAtA[i] = 0x18
		i++
		if m.DefaultStorageClass {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AdvancedStorageParameters) > 0 {
		keysForAdvancedStorageParameters := make([]string, 0, len(m.AdvancedStorageParameters))
		for k, _ := range m.AdvancedStorageParameters {
			keysForAdvancedStorageParameters = append(keysForAdvancedStorageParameters, string(k))
		}
		sortkeys.Strings(keysForAdvancedStorageParameters)
		for _, k := range keysForAdvancedStorageParameters {
			dAtA[i] = 0x3a
			i++
			v := m.AdvancedStorageParameters[string(k)]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.StorageClassName) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StorageClassName)))
		i += copy(dAtA[i:], m.StorageClassName)
	}
	if m.DeviceChoice != nil {
		nn43, err := m.DeviceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn43
	}
	if len(m.ReclaimPolicy) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ReclaimPolicy)))
		i += copy(dAtA[i:], m.ReclaimPolicy)
	}
	if m.AllowVolumeExpansion {
		dAtA[i] = 0x68
		i++
		if m.AllowVolumeExpansion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FleetStorageClassType_NetappTrident) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NetappTrident != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NetappTrident.Size()))
		n44, err := m.NetappTrident.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	return i, nil
}
func (m *FleetStorageClassType_PureServiceOrchestrator) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PureServiceOrchestrator != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PureServiceOrchestrator.Size()))
		n45, err := m.PureServiceOrchestrator.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}
func (m *FleetStorageClassType_OpenebsEnterprise) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OpenebsEnterprise != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.OpenebsEnterprise.Size()))
		n46, err := m.OpenebsEnterprise.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	return i, nil
}
func (m *FleetStorageClassListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetStorageClassListType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StorageClasses) > 0 {
		for _, msg := range m.StorageClasses {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BondLacpType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BondLacpType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rate != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Rate))
	}
	return i, nil
}

func (m *FleetBondDeviceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetBondDeviceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Devices) > 0 {
		for _, s := range m.Devices {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.LacpChoice != nil {
		nn47, err := m.LacpChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn47
	}
	if m.LinkPollingInterval != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LinkPollingInterval))
	}
	if m.LinkUpDelay != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LinkUpDelay))
	}
	return i, nil
}

func (m *FleetBondDeviceType_Lacp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Lacp != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Lacp.Size()))
		n48, err := m.Lacp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}
func (m *FleetBondDeviceType_ActiveBackup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ActiveBackup != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ActiveBackup.Size()))
		n49, err := m.ActiveBackup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	return i, nil
}
func (m *FleetBondDevicesListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetBondDevicesListType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BondDevices) > 0 {
		for _, msg := range m.BondDevices {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FleetStorageStaticRoutesListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetStorageStaticRoutesListType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StorageRoutes) > 0 {
		for _, msg := range m.StorageRoutes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPConfiguration) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BgpParameters != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BgpParameters.Size()))
		n50, err := m.BgpParameters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if len(m.Peers) > 0 {
		for _, msg := range m.Peers {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LocalControlPlaneType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalControlPlaneType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NetworkChoice != nil {
		nn51, err := m.NetworkChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn51
	}
	if m.BgpConfig != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BgpConfig.Size()))
		n52, err := m.BgpConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	return i, nil
}

func (m *LocalControlPlaneType_InsideVn) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InsideVn != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.InsideVn.Size()))
		n53, err := m.InsideVn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	return i, nil
}
func (m *LocalControlPlaneType_OutsideVn) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OutsideVn != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.OutsideVn.Size()))
		n54, err := m.OutsideVn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	return i, nil
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FleetLabel) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FleetLabel)))
		i += copy(dAtA[i:], m.FleetLabel)
	}
	if len(m.VolterraSoftwareVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VolterraSoftwareVersion)))
		i += copy(dAtA[i:], m.VolterraSoftwareVersion)
	}
	if len(m.Devices) > 0 {
		for _, msg := range m.Devices {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NetworkConnectors) > 0 {
		for _, msg := range m.NetworkConnectors {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NetworkFirewall) > 0 {
		for _, msg := range m.NetworkFirewall {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OperatingSystemVersion) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
		i += copy(dAtA[i:], m.OperatingSystemVersion)
	}
	if len(m.OutsideVirtualNetwork) > 0 {
		for _, msg := range m.OutsideVirtualNetwork {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.InsideVirtualNetwork) > 0 {
		for _, msg := range m.InsideVirtualNetwork {
			dAtA[i] = 0x42
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.InterfaceChoice != nil {
		nn55, err := m.InterfaceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn55
	}
	if m.BondChoice != nil {
		nn56, err := m.BondChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn56
	}
	if m.StorageInterfaceChoice != nil {
		nn57, err := m.StorageInterfaceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn57
	}
	if m.StorageDeviceChoice != nil {
		nn58, err := m.StorageDeviceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn58
	}
	if m.StorageClassChoice != nil {
		nn59, err := m.StorageClassChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn59
	}
	if m.DcClusterGroupChoice != nil {
		nn60, err := m.DcClusterGroupChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn60
	}
	if m.GpuChoice != nil {
		nn61, err := m.GpuChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn61
	}
	if m.EtcdClusterNetwork != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EtcdClusterNetwork))
	}
	if m.StorageStaticRoutesChoice != nil {
		nn62, err := m.StorageStaticRoutesChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn62
	}
	if m.EnableDefaultFleetConfigDownload {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		if m.EnableDefaultFleetConfigDownload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FleetType != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.FleetType))
	}
	if len(m.SingleSite) > 0 {
		for _, msg := range m.SingleSite {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LogsReceiverChoice != nil {
		nn63, err := m.LogsReceiverChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn63
	}
	if m.UsbPolicyChoice != nil {
		nn64, err := m.UsbPolicyChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn64
	}
	if m.K8SCluster != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.K8SCluster.Size()))
		n65, err := m.K8SCluster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if m.LocalControlPlane != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LocalControlPlane.Size()))
		n66, err := m.LocalControlPlane.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.ViewInternal != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ViewInternal.Size()))
		n67, err := m.ViewInternal.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	return i, nil
}

func (m *GlobalSpecType_InterfaceList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InterfaceList != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.InterfaceList.Size()))
		n68, err := m.InterfaceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	return i, nil
}
func (m *GlobalSpecType_LegacyDevices) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LegacyDevices != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LegacyDevices.Size()))
		n69, err := m.LegacyDevices.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	return i, nil
}
func (m *GlobalSpecType_NoBondDevices) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoBondDevices != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoBondDevices.Size()))
		n70, err := m.NoBondDevices.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	return i, nil
}
func (m *GlobalSpecType_BondDeviceList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BondDeviceList != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BondDeviceList.Size()))
		n71, err := m.BondDeviceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	return i, nil
}
func (m *GlobalSpecType_NoStorageInterfaces) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoStorageInterfaces != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoStorageInterfaces.Size()))
		n72, err := m.NoStorageInterfaces.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	return i, nil
}
func (m *GlobalSpecType_StorageInterfaceList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StorageInterfaceList != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageInterfaceList.Size()))
		n73, err := m.StorageInterfaceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	return i, nil
}
func (m *GlobalSpecType_NoStorageDevice) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoStorageDevice != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoStorageDevice.Size()))
		n74, err := m.NoStorageDevice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	return i, nil
}
func (m *GlobalSpecType_StorageDeviceList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StorageDeviceList != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageDeviceList.Size()))
		n75, err := m.StorageDeviceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	return i, nil
}
func (m *GlobalSpecType_DefaultStorageClass) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DefaultStorageClass != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultStorageClass.Size()))
		n76, err := m.DefaultStorageClass.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	return i, nil
}
func (m *GlobalSpecType_StorageClassList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StorageClassList != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageClassList.Size()))
		n77, err := m.StorageClassList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	return i, nil
}
func (m *GlobalSpecType_NoDcClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoDcClusterGroup != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoDcClusterGroup.Size()))
		n78, err := m.NoDcClusterGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	return i, nil
}
func (m *GlobalSpecType_DcClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DcClusterGroup != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DcClusterGroup.Size()))
		n79, err := m.DcClusterGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	return i, nil
}
func (m *GlobalSpecType_DisableGpu) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DisableGpu != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DisableGpu.Size()))
		n80, err := m.DisableGpu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	return i, nil
}
func (m *GlobalSpecType_EnableGpu) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EnableGpu != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EnableGpu.Size()))
		n81, err := m.EnableGpu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	return i, nil
}
func (m *GlobalSpecType_NoStorageStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoStorageStaticRoutes != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoStorageStaticRoutes.Size()))
		n82, err := m.NoStorageStaticRoutes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	return i, nil
}
func (m *GlobalSpecType_StorageStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StorageStaticRoutes != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageStaticRoutes.Size()))
		n83, err := m.StorageStaticRoutes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	return i, nil
}
func (m *GlobalSpecType_DcClusterGroupInside) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DcClusterGroupInside != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DcClusterGroupInside.Size()))
		n84, err := m.DcClusterGroupInside.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n84
	}
	return i, nil
}
func (m *GlobalSpecType_DefaultInterfaces) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DefaultInterfaces != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultInterfaces.Size()))
		n85, err := m.DefaultInterfaces.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n85
	}
	return i, nil
}
func (m *GlobalSpecType_LogsStreamingDisabled) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogsStreamingDisabled != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LogsStreamingDisabled.Size()))
		n86, err := m.LogsStreamingDisabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n86
	}
	return i, nil
}
func (m *GlobalSpecType_LogReceiver) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogReceiver != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LogReceiver.Size()))
		n87, err := m.LogReceiver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n87
	}
	return i, nil
}
func (m *GlobalSpecType_DenyAllUsb) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DenyAllUsb != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DenyAllUsb.Size()))
		n88, err := m.DenyAllUsb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	return i, nil
}
func (m *GlobalSpecType_AllowAllUsb) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AllowAllUsb != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AllowAllUsb.Size()))
		n89, err := m.AllowAllUsb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n89
	}
	return i, nil
}
func (m *GlobalSpecType_UsbPolicy) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UsbPolicy != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.UsbPolicy.Size()))
		n90, err := m.UsbPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n90
	}
	return i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FleetLabel) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FleetLabel)))
		i += copy(dAtA[i:], m.FleetLabel)
	}
	if len(m.VolterraSoftwareVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VolterraSoftwareVersion)))
		i += copy(dAtA[i:], m.VolterraSoftwareVersion)
	}
	if len(m.NetworkConnectors) > 0 {
		for _, msg := range m.NetworkConnectors {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NetworkFirewall) > 0 {
		for _, msg := range m.NetworkFirewall {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OperatingSystemVersion) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
		i += copy(dAtA[i:], m.OperatingSystemVersion)
	}
	if len(m.OutsideVirtualNetwork) > 0 {
		for _, msg := range m.OutsideVirtualNetwork {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.InsideVirtualNetwork) > 0 {
		for _, msg := range m.InsideVirtualNetwork {
			dAtA[i] = 0x42
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.InterfaceChoice != nil {
		nn91, err := m.InterfaceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn91
	}
	if m.BondChoice != nil {
		nn92, err := m.BondChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn92
	}
	if m.StorageInterfaceChoice != nil {
		nn93, err := m.StorageInterfaceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn93
	}
	if m.StorageDeviceChoice != nil {
		nn94, err := m.StorageDeviceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn94
	}
	if m.StorageClassChoice != nil {
		nn95, err := m.StorageClassChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn95
	}
	if m.DcClusterGroupChoice != nil {
		nn96, err := m.DcClusterGroupChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn96
	}
	if m.GpuChoice != nil {
		nn97, err := m.GpuChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn97
	}
	if m.StorageStaticRoutesChoice != nil {
		nn98, err := m.StorageStaticRoutesChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn98
	}
	if m.EnableDefaultFleetConfigDownload {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		if m.EnableDefaultFleetConfigDownload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LogsReceiverChoice != nil {
		nn99, err := m.LogsReceiverChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn99
	}
	if m.UsbPolicyChoice != nil {
		nn100, err := m.UsbPolicyChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn100
	}
	return i, nil
}

func (m *CreateSpecType_InterfaceList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InterfaceList != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.InterfaceList.Size()))
		n101, err := m.InterfaceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n101
	}
	return i, nil
}
func (m *CreateSpecType_DeviceList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DeviceList != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DeviceList.Size()))
		n102, err := m.DeviceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n102
	}
	return i, nil
}
func (m *CreateSpecType_NoBondDevices) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoBondDevices != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoBondDevices.Size()))
		n103, err := m.NoBondDevices.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n103
	}
	return i, nil
}
func (m *CreateSpecType_BondDeviceList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BondDeviceList != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BondDeviceList.Size()))
		n104, err := m.BondDeviceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n104
	}
	return i, nil
}
func (m *CreateSpecType_NoStorageInterfaces) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoStorageInterfaces != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoStorageInterfaces.Size()))
		n105, err := m.NoStorageInterfaces.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n105
	}
	return i, nil
}
func (m *CreateSpecType_StorageInterfaceList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StorageInterfaceList != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageInterfaceList.Size()))
		n106, err := m.StorageInterfaceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n106
	}
	return i, nil
}
func (m *CreateSpecType_NoStorageDevice) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoStorageDevice != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoStorageDevice.Size()))
		n107, err := m.NoStorageDevice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n107
	}
	return i, nil
}
func (m *CreateSpecType_StorageDeviceList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StorageDeviceList != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageDeviceList.Size()))
		n108, err := m.StorageDeviceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n108
	}
	return i, nil
}
func (m *CreateSpecType_DefaultStorageClass) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DefaultStorageClass != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultStorageClass.Size()))
		n109, err := m.DefaultStorageClass.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n109
	}
	return i, nil
}
func (m *CreateSpecType_StorageClassList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StorageClassList != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageClassList.Size()))
		n110, err := m.StorageClassList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n110
	}
	return i, nil
}
func (m *CreateSpecType_NoDcClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoDcClusterGroup != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoDcClusterGroup.Size()))
		n111, err := m.NoDcClusterGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n111
	}
	return i, nil
}
func (m *CreateSpecType_DcClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DcClusterGroup != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DcClusterGroup.Size()))
		n112, err := m.DcClusterGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n112
	}
	return i, nil
}
func (m *CreateSpecType_DisableGpu) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DisableGpu != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DisableGpu.Size()))
		n113, err := m.DisableGpu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n113
	}
	return i, nil
}
func (m *CreateSpecType_EnableGpu) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EnableGpu != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EnableGpu.Size()))
		n114, err := m.EnableGpu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n114
	}
	return i, nil
}
func (m *CreateSpecType_NoStorageStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoStorageStaticRoutes != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoStorageStaticRoutes.Size()))
		n115, err := m.NoStorageStaticRoutes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n115
	}
	return i, nil
}
func (m *CreateSpecType_StorageStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StorageStaticRoutes != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageStaticRoutes.Size()))
		n116, err := m.StorageStaticRoutes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n116
	}
	return i, nil
}
func (m *CreateSpecType_DcClusterGroupInside) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DcClusterGroupInside != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DcClusterGroupInside.Size()))
		n117, err := m.DcClusterGroupInside.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n117
	}
	return i, nil
}
func (m *CreateSpecType_DefaultConfig) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DefaultConfig != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultConfig.Size()))
		n118, err := m.DefaultConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n118
	}
	return i, nil
}
func (m *CreateSpecType_LogsStreamingDisabled) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogsStreamingDisabled != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LogsStreamingDisabled.Size()))
		n119, err := m.LogsStreamingDisabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n119
	}
	return i, nil
}
func (m *CreateSpecType_LogReceiver) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogReceiver != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LogReceiver.Size()))
		n120, err := m.LogReceiver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n120
	}
	return i, nil
}
func (m *CreateSpecType_DenyAllUsb) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DenyAllUsb != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DenyAllUsb.Size()))
		n121, err := m.DenyAllUsb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n121
	}
	return i, nil
}
func (m *CreateSpecType_AllowAllUsb) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AllowAllUsb != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AllowAllUsb.Size()))
		n122, err := m.AllowAllUsb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n122
	}
	return i, nil
}
func (m *CreateSpecType_UsbPolicy) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UsbPolicy != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.UsbPolicy.Size()))
		n123, err := m.UsbPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n123
	}
	return i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VolterraSoftwareVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VolterraSoftwareVersion)))
		i += copy(dAtA[i:], m.VolterraSoftwareVersion)
	}
	if len(m.NetworkConnectors) > 0 {
		for _, msg := range m.NetworkConnectors {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NetworkFirewall) > 0 {
		for _, msg := range m.NetworkFirewall {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OperatingSystemVersion) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
		i += copy(dAtA[i:], m.OperatingSystemVersion)
	}
	if len(m.OutsideVirtualNetwork) > 0 {
		for _, msg := range m.OutsideVirtualNetwork {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.InsideVirtualNetwork) > 0 {
		for _, msg := range m.InsideVirtualNetwork {
			dAtA[i] = 0x42
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.InterfaceChoice != nil {
		nn124, err := m.InterfaceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn124
	}
	if m.BondChoice != nil {
		nn125, err := m.BondChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn125
	}
	if m.StorageInterfaceChoice != nil {
		nn126, err := m.StorageInterfaceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn126
	}
	if m.StorageDeviceChoice != nil {
		nn127, err := m.StorageDeviceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn127
	}
	if m.StorageClassChoice != nil {
		nn128, err := m.StorageClassChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn128
	}
	if m.DcClusterGroupChoice != nil {
		nn129, err := m.DcClusterGroupChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn129
	}
	if m.GpuChoice != nil {
		nn130, err := m.GpuChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn130
	}
	if m.StorageStaticRoutesChoice != nil {
		nn131, err := m.StorageStaticRoutesChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn131
	}
	if m.EnableDefaultFleetConfigDownload {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		if m.EnableDefaultFleetConfigDownload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LogsReceiverChoice != nil {
		nn132, err := m.LogsReceiverChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn132
	}
	if m.UsbPolicyChoice != nil {
		nn133, err := m.UsbPolicyChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn133
	}
	return i, nil
}

func (m *ReplaceSpecType_InterfaceList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InterfaceList != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.InterfaceList.Size()))
		n134, err := m.InterfaceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n134
	}
	return i, nil
}
func (m *ReplaceSpecType_DeviceList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DeviceList != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DeviceList.Size()))
		n135, err := m.DeviceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n135
	}
	return i, nil
}
func (m *ReplaceSpecType_NoBondDevices) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoBondDevices != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoBondDevices.Size()))
		n136, err := m.NoBondDevices.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n136
	}
	return i, nil
}
func (m *ReplaceSpecType_BondDeviceList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BondDeviceList != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BondDeviceList.Size()))
		n137, err := m.BondDeviceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n137
	}
	return i, nil
}
func (m *ReplaceSpecType_NoStorageInterfaces) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoStorageInterfaces != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoStorageInterfaces.Size()))
		n138, err := m.NoStorageInterfaces.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n138
	}
	return i, nil
}
func (m *ReplaceSpecType_StorageInterfaceList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StorageInterfaceList != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageInterfaceList.Size()))
		n139, err := m.StorageInterfaceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n139
	}
	return i, nil
}
func (m *ReplaceSpecType_NoStorageDevice) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoStorageDevice != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoStorageDevice.Size()))
		n140, err := m.NoStorageDevice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n140
	}
	return i, nil
}
func (m *ReplaceSpecType_StorageDeviceList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StorageDeviceList != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageDeviceList.Size()))
		n141, err := m.StorageDeviceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n141
	}
	return i, nil
}
func (m *ReplaceSpecType_DefaultStorageClass) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DefaultStorageClass != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultStorageClass.Size()))
		n142, err := m.DefaultStorageClass.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n142
	}
	return i, nil
}
func (m *ReplaceSpecType_StorageClassList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StorageClassList != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageClassList.Size()))
		n143, err := m.StorageClassList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n143
	}
	return i, nil
}
func (m *ReplaceSpecType_NoDcClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoDcClusterGroup != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoDcClusterGroup.Size()))
		n144, err := m.NoDcClusterGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n144
	}
	return i, nil
}
func (m *ReplaceSpecType_DcClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DcClusterGroup != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DcClusterGroup.Size()))
		n145, err := m.DcClusterGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n145
	}
	return i, nil
}
func (m *ReplaceSpecType_DisableGpu) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DisableGpu != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DisableGpu.Size()))
		n146, err := m.DisableGpu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n146
	}
	return i, nil
}
func (m *ReplaceSpecType_EnableGpu) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EnableGpu != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EnableGpu.Size()))
		n147, err := m.EnableGpu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n147
	}
	return i, nil
}
func (m *ReplaceSpecType_NoStorageStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoStorageStaticRoutes != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoStorageStaticRoutes.Size()))
		n148, err := m.NoStorageStaticRoutes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n148
	}
	return i, nil
}
func (m *ReplaceSpecType_StorageStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StorageStaticRoutes != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageStaticRoutes.Size()))
		n149, err := m.StorageStaticRoutes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n149
	}
	return i, nil
}
func (m *ReplaceSpecType_DcClusterGroupInside) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DcClusterGroupInside != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DcClusterGroupInside.Size()))
		n150, err := m.DcClusterGroupInside.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n150
	}
	return i, nil
}
func (m *ReplaceSpecType_DefaultConfig) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DefaultConfig != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultConfig.Size()))
		n151, err := m.DefaultConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n151
	}
	return i, nil
}
func (m *ReplaceSpecType_LogsStreamingDisabled) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogsStreamingDisabled != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LogsStreamingDisabled.Size()))
		n152, err := m.LogsStreamingDisabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n152
	}
	return i, nil
}
func (m *ReplaceSpecType_LogReceiver) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogReceiver != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LogReceiver.Size()))
		n153, err := m.LogReceiver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n153
	}
	return i, nil
}
func (m *ReplaceSpecType_DenyAllUsb) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DenyAllUsb != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DenyAllUsb.Size()))
		n154, err := m.DenyAllUsb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n154
	}
	return i, nil
}
func (m *ReplaceSpecType_AllowAllUsb) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AllowAllUsb != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AllowAllUsb.Size()))
		n155, err := m.AllowAllUsb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n155
	}
	return i, nil
}
func (m *ReplaceSpecType_UsbPolicy) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UsbPolicy != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.UsbPolicy.Size()))
		n156, err := m.UsbPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n156
	}
	return i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FleetLabel) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FleetLabel)))
		i += copy(dAtA[i:], m.FleetLabel)
	}
	if len(m.VolterraSoftwareVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VolterraSoftwareVersion)))
		i += copy(dAtA[i:], m.VolterraSoftwareVersion)
	}
	if len(m.NetworkConnectors) > 0 {
		for _, msg := range m.NetworkConnectors {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NetworkFirewall) > 0 {
		for _, msg := range m.NetworkFirewall {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OperatingSystemVersion) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
		i += copy(dAtA[i:], m.OperatingSystemVersion)
	}
	if len(m.OutsideVirtualNetwork) > 0 {
		for _, msg := range m.OutsideVirtualNetwork {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.InsideVirtualNetwork) > 0 {
		for _, msg := range m.InsideVirtualNetwork {
			dAtA[i] = 0x42
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.InterfaceChoice != nil {
		nn157, err := m.InterfaceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn157
	}
	if m.BondChoice != nil {
		nn158, err := m.BondChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn158
	}
	if m.StorageInterfaceChoice != nil {
		nn159, err := m.StorageInterfaceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn159
	}
	if m.StorageDeviceChoice != nil {
		nn160, err := m.StorageDeviceChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn160
	}
	if m.StorageClassChoice != nil {
		nn161, err := m.StorageClassChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn161
	}
	if m.DcClusterGroupChoice != nil {
		nn162, err := m.DcClusterGroupChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn162
	}
	if m.GpuChoice != nil {
		nn163, err := m.GpuChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn163
	}
	if m.StorageStaticRoutesChoice != nil {
		nn164, err := m.StorageStaticRoutesChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn164
	}
	if m.EnableDefaultFleetConfigDownload {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		if m.EnableDefaultFleetConfigDownload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LogsReceiverChoice != nil {
		nn165, err := m.LogsReceiverChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn165
	}
	if m.UsbPolicyChoice != nil {
		nn166, err := m.UsbPolicyChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn166
	}
	return i, nil
}

func (m *GetSpecType_InterfaceList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InterfaceList != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.InterfaceList.Size()))
		n167, err := m.InterfaceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n167
	}
	return i, nil
}
func (m *GetSpecType_DeviceList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DeviceList != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DeviceList.Size()))
		n168, err := m.DeviceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n168
	}
	return i, nil
}
func (m *GetSpecType_NoBondDevices) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoBondDevices != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoBondDevices.Size()))
		n169, err := m.NoBondDevices.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n169
	}
	return i, nil
}
func (m *GetSpecType_BondDeviceList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BondDeviceList != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BondDeviceList.Size()))
		n170, err := m.BondDeviceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n170
	}
	return i, nil
}
func (m *GetSpecType_NoStorageInterfaces) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoStorageInterfaces != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoStorageInterfaces.Size()))
		n171, err := m.NoStorageInterfaces.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n171
	}
	return i, nil
}
func (m *GetSpecType_StorageInterfaceList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StorageInterfaceList != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageInterfaceList.Size()))
		n172, err := m.StorageInterfaceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n172
	}
	return i, nil
}
func (m *GetSpecType_NoStorageDevice) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoStorageDevice != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoStorageDevice.Size()))
		n173, err := m.NoStorageDevice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n173
	}
	return i, nil
}
func (m *GetSpecType_StorageDeviceList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StorageDeviceList != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageDeviceList.Size()))
		n174, err := m.StorageDeviceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n174
	}
	return i, nil
}
func (m *GetSpecType_DefaultStorageClass) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DefaultStorageClass != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultStorageClass.Size()))
		n175, err := m.DefaultStorageClass.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n175
	}
	return i, nil
}
func (m *GetSpecType_StorageClassList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StorageClassList != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageClassList.Size()))
		n176, err := m.StorageClassList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n176
	}
	return i, nil
}
func (m *GetSpecType_NoDcClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoDcClusterGroup != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoDcClusterGroup.Size()))
		n177, err := m.NoDcClusterGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n177
	}
	return i, nil
}
func (m *GetSpecType_DcClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DcClusterGroup != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DcClusterGroup.Size()))
		n178, err := m.DcClusterGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n178
	}
	return i, nil
}
func (m *GetSpecType_DisableGpu) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DisableGpu != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DisableGpu.Size()))
		n179, err := m.DisableGpu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n179
	}
	return i, nil
}
func (m *GetSpecType_EnableGpu) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EnableGpu != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EnableGpu.Size()))
		n180, err := m.EnableGpu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n180
	}
	return i, nil
}
func (m *GetSpecType_NoStorageStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NoStorageStaticRoutes != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.NoStorageStaticRoutes.Size()))
		n181, err := m.NoStorageStaticRoutes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n181
	}
	return i, nil
}
func (m *GetSpecType_StorageStaticRoutes) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StorageStaticRoutes != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageStaticRoutes.Size()))
		n182, err := m.StorageStaticRoutes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n182
	}
	return i, nil
}
func (m *GetSpecType_DcClusterGroupInside) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DcClusterGroupInside != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DcClusterGroupInside.Size()))
		n183, err := m.DcClusterGroupInside.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n183
	}
	return i, nil
}
func (m *GetSpecType_DefaultConfig) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DefaultConfig != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultConfig.Size()))
		n184, err := m.DefaultConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n184
	}
	return i, nil
}
func (m *GetSpecType_LogsStreamingDisabled) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogsStreamingDisabled != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LogsStreamingDisabled.Size()))
		n185, err := m.LogsStreamingDisabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n185
	}
	return i, nil
}
func (m *GetSpecType_LogReceiver) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogReceiver != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.LogReceiver.Size()))
		n186, err := m.LogReceiver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n186
	}
	return i, nil
}
func (m *GetSpecType_DenyAllUsb) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DenyAllUsb != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.DenyAllUsb.Size()))
		n187, err := m.DenyAllUsb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n187
	}
	return i, nil
}
func (m *GetSpecType_AllowAllUsb) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AllowAllUsb != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.AllowAllUsb.Size()))
		n188, err := m.AllowAllUsb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n188
	}
	return i, nil
}
func (m *GetSpecType_UsbPolicy) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UsbPolicy != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.UsbPolicy.Size()))
		n189, err := m.UsbPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n189
	}
	return i, nil
}
func (m *FleetStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AvailableSoftwareVersion) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AvailableSoftwareVersion)))
		i += copy(dAtA[i:], m.AvailableSoftwareVersion)
	}
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NetworkingDeviceInstanceType) Size() (n int) {
	var l int
	_ = l
	if len(m.Interface) > 0 {
		for _, e := range m.Interface {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Use != 0 {
		n += 1 + sovTypes(uint64(m.Use))
	}
	return n
}

func (m *GenericDeviceInstanceType) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DeviceInstanceType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Owner != 0 {
		n += 1 + sovTypes(uint64(m.Owner))
	}
	if m.DeviceInstance != nil {
		n += m.DeviceInstance.Size()
	}
	return n
}

func (m *DeviceInstanceType_NetworkDevice) Size() (n int) {
	var l int
	_ = l
	if m.NetworkDevice != nil {
		l = m.NetworkDevice.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetInterfaceListType) Size() (n int) {
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for _, e := range m.Interfaces {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *FleetDeviceListType) Size() (n int) {
	var l int
	_ = l
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *StorageDeviceOpenebsEnterpriseType) Size() (n int) {
	var l int
	_ = l
	if len(m.MayastorPools) > 0 {
		for _, e := range m.MayastorPools {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *OpenebsMayastorPoolType) Size() (n int) {
	var l int
	_ = l
	l = len(m.PoolName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.PoolDiskDevices) > 0 {
		for _, s := range m.PoolDiskDevices {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *StorageDeviceDellIsilonF800Type) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Password != nil {
		l = m.Password.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HttpsChoice != nil {
		n += m.HttpsChoice.Size()
	}
	if m.AddressChoice != nil {
		n += m.AddressChoice.Size()
	}
	if m.ApiServerPort != 0 {
		n += 1 + sovTypes(uint64(m.ApiServerPort))
	}
	l = len(m.IscsiAccessZone)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VolumePrefix)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BasePath)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StorageDeviceDellIsilonF800Type_SecureNetwork) Size() (n int) {
	var l int
	_ = l
	if m.SecureNetwork != nil {
		l = m.SecureNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *StorageDeviceDellIsilonF800Type_TrustedCaUrl) Size() (n int) {
	var l int
	_ = l
	l = len(m.TrustedCaUrl)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceDellIsilonF800Type_ApiServerName) Size() (n int) {
	var l int
	_ = l
	l = len(m.ApiServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceDellIsilonF800Type_ApiServerIpAddress) Size() (n int) {
	var l int
	_ = l
	l = len(m.ApiServerIpAddress)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceHPENimbusStorageAf40Type) Size() (n int) {
	var l int
	_ = l
	l = len(m.StorageServerName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.StorageServerIpAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ApiServerPort != 0 {
		n += 1 + sovTypes(uint64(m.ApiServerPort))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Password != nil {
		l = m.Password.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PerfPolicy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LimitIops != 0 {
		n += 1 + sovTypes(uint64(m.LimitIops))
	}
	if m.LimitMbps != 0 {
		n += 1 + sovTypes(uint64(m.LimitMbps))
	}
	return n
}

func (m *StorageDevicePureStorageServiceOrchestratorType) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EnableStorageTopology {
		n += 2
	}
	if m.EnableStrictTopology {
		n += 2
	}
	if m.Arrays != nil {
		l = m.Arrays.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *PsoArrayConfiguration) Size() (n int) {
	var l int
	_ = l
	if m.FlashArray != nil {
		l = m.FlashArray.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.FlashBlade != nil {
		l = m.FlashBlade.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *FlashBladeType) Size() (n int) {
	var l int
	_ = l
	if m.EnableSnapshotDirectory {
		n += 2
	}
	l = len(m.ExportRules)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.FlashBlades) > 0 {
		for _, e := range m.FlashBlades {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *FlashBladeEndpoint) Size() (n int) {
	var l int
	_ = l
	if m.MgmtEndpoint != nil {
		n += m.MgmtEndpoint.Size()
	}
	if m.ApiToken != nil {
		l = m.ApiToken.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NfsEndpoint != nil {
		n += m.NfsEndpoint.Size()
	}
	if len(m.Lables) > 0 {
		for k, v := range m.Lables {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FlashBladeEndpoint_MgmtIp) Size() (n int) {
	var l int
	_ = l
	l = len(m.MgmtIp)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *FlashBladeEndpoint_MgmtDnsName) Size() (n int) {
	var l int
	_ = l
	l = len(m.MgmtDnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *FlashBladeEndpoint_NfsEndpointIp) Size() (n int) {
	var l int
	_ = l
	l = len(m.NfsEndpointIp)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *FlashBladeEndpoint_NfsEndpointDnsName) Size() (n int) {
	var l int
	_ = l
	l = len(m.NfsEndpointDnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *FlashArrayType) Size() (n int) {
	var l int
	_ = l
	l = len(m.SanType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DefaultFsType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DefaultFsOpt)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.DefaultMountOpts) > 0 {
		for _, s := range m.DefaultMountOpts {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DisablePreemptAttachments {
		n += 2
	}
	if m.IscsiLoginTimeout != 0 {
		n += 1 + sovTypes(uint64(m.IscsiLoginTimeout))
	}
	if len(m.FlashArrays) > 0 {
		for _, e := range m.FlashArrays {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *FlashArrayEndpoint) Size() (n int) {
	var l int
	_ = l
	if m.MgmtEndpoint != nil {
		n += m.MgmtEndpoint.Size()
	}
	if m.ApiToken != nil {
		l = m.ApiToken.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FlashArrayEndpoint_MgmtIp) Size() (n int) {
	var l int
	_ = l
	l = len(m.MgmtIp)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *FlashArrayEndpoint_MgmtDnsName) Size() (n int) {
	var l int
	_ = l
	l = len(m.MgmtDnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceNetappTridentType) Size() (n int) {
	var l int
	_ = l
	if m.BackendChoice != nil {
		n += m.BackendChoice.Size()
	}
	return n
}

func (m *StorageDeviceNetappTridentType_NetappBackendOntapNas) Size() (n int) {
	var l int
	_ = l
	if m.NetappBackendOntapNas != nil {
		l = m.NetappBackendOntapNas.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *StorageDeviceNetappTridentType_NetappBackendOntapSan) Size() (n int) {
	var l int
	_ = l
	if m.NetappBackendOntapSan != nil {
		l = m.NetappBackendOntapSan.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *StorageDeviceNetappBackendOntapSanType) Size() (n int) {
	var l int
	_ = l
	l = len(m.StorageDriverName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ManagementLif != nil {
		n += m.ManagementLif.Size()
	}
	if m.DataLif != nil {
		n += m.DataLif.Size()
	}
	l = len(m.Svm)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Password != nil {
		l = m.Password.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ChapChoice != nil {
		n += m.ChapChoice.Size()
	}
	l = len(m.IgroupName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.StoragePrefix)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.LimitAggregateUsage != 0 {
		n += 2 + sovTypes(uint64(m.LimitAggregateUsage))
	}
	if m.LimitVolumeSize != 0 {
		n += 2 + sovTypes(uint64(m.LimitVolumeSize))
	}
	if m.VolumeDefaults != nil {
		l = m.VolumeDefaults.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Region)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.Storage) > 0 {
		for _, e := range m.Storage {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.ClientCertificate)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ClientPrivateKey != nil {
		l = m.ClientPrivateKey.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.TrustedCaCertificate)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StorageDeviceNetappBackendOntapSanType_ManagementLifIp) Size() (n int) {
	var l int
	_ = l
	l = len(m.ManagementLifIp)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName) Size() (n int) {
	var l int
	_ = l
	l = len(m.ManagementLifDnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceNetappBackendOntapSanType_DataLifIp) Size() (n int) {
	var l int
	_ = l
	l = len(m.DataLifIp)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceNetappBackendOntapSanType_DataLifDnsName) Size() (n int) {
	var l int
	_ = l
	l = len(m.DataLifDnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceNetappBackendOntapSanType_NoChap) Size() (n int) {
	var l int
	_ = l
	if m.NoChap != nil {
		l = m.NoChap.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *StorageDeviceNetappBackendOntapSanType_UseChap) Size() (n int) {
	var l int
	_ = l
	if m.UseChap != nil {
		l = m.UseChap.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DeviceNetappBackendOntapSanChapType) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChapUsername)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ChapTargetUsername)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ChapInitiatorSecret != nil {
		l = m.ChapInitiatorSecret.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ChapTargetInitiatorSecret != nil {
		l = m.ChapTargetInitiatorSecret.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StorageDeviceNetappBackendOntapNasType) Size() (n int) {
	var l int
	_ = l
	l = len(m.StorageDriverName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BackendName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ManagementLif != nil {
		n += m.ManagementLif.Size()
	}
	if m.DataLif != nil {
		n += m.DataLif.Size()
	}
	l = len(m.Svm)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Password != nil {
		l = m.Password.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AutoExportPolicy {
		n += 2
	}
	if m.AutoExportCidrs != nil {
		l = m.AutoExportCidrs.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.StoragePrefix)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.LimitAggregateUsage)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.LimitVolumeSize)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.NfsMountOptions)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VolumeDefaults != nil {
		l = m.VolumeDefaults.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Region)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.Storage) > 0 {
		for _, e := range m.Storage {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.ClientCertificate)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ClientPrivateKey != nil {
		l = m.ClientPrivateKey.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.TrustedCaCertificate)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StorageDeviceNetappBackendOntapNasType_ManagementLifIp) Size() (n int) {
	var l int
	_ = l
	l = len(m.ManagementLifIp)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName) Size() (n int) {
	var l int
	_ = l
	l = len(m.ManagementLifDnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceNetappBackendOntapNasType_DataLifIp) Size() (n int) {
	var l int
	_ = l
	l = len(m.DataLifIp)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageDeviceNetappBackendOntapNasType_DataLifDnsName) Size() (n int) {
	var l int
	_ = l
	l = len(m.DataLifDnsName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *OntapVolumeDefaults) Size() (n int) {
	var l int
	_ = l
	l = len(m.SpaceReserve)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SnapshotPolicy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SnapshotReserve)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SplitOnClone {
		n += 2
	}
	if m.Encryption {
		n += 2
	}
	if m.UnixPermissions != 0 {
		n += 1 + sovTypes(uint64(m.UnixPermissions))
	}
	if m.SnapshotDir {
		n += 2
	}
	l = len(m.ExportPolicy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SecurityStyle)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TieringPolicy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.QosPolicyChoice != nil {
		n += m.QosPolicyChoice.Size()
	}
	return n
}

func (m *OntapVolumeDefaults_NoQos) Size() (n int) {
	var l int
	_ = l
	if m.NoQos != nil {
		l = m.NoQos.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *OntapVolumeDefaults_QosPolicy) Size() (n int) {
	var l int
	_ = l
	l = len(m.QosPolicy)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *OntapVolumeDefaults_AdaptiveQosPolicy) Size() (n int) {
	var l int
	_ = l
	l = len(m.AdaptiveQosPolicy)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *OntapVirtualStoragePoolType) Size() (n int) {
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VolumeDefaults != nil {
		l = m.VolumeDefaults.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *FleetStorageDeviceType) Size() (n int) {
	var l int
	_ = l
	l = len(m.StorageDevice)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AdvancedAdvancedParameters) > 0 {
		for k, v := range m.AdvancedAdvancedParameters {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.DeviceChoice != nil {
		n += m.DeviceChoice.Size()
	}
	return n
}

func (m *FleetStorageDeviceType_NetappTrident) Size() (n int) {
	var l int
	_ = l
	if m.NetappTrident != nil {
		l = m.NetappTrident.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetStorageDeviceType_PureServiceOrchestrator) Size() (n int) {
	var l int
	_ = l
	if m.PureServiceOrchestrator != nil {
		l = m.PureServiceOrchestrator.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetStorageDeviceType_OpenebsEnterprise) Size() (n int) {
	var l int
	_ = l
	if m.OpenebsEnterprise != nil {
		l = m.OpenebsEnterprise.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetStorageDeviceListType) Size() (n int) {
	var l int
	_ = l
	if len(m.StorageDevices) > 0 {
		for _, e := range m.StorageDevices {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *StorageClassDellIsilonF800Type) Size() (n int) {
	var l int
	_ = l
	if m.HttpsChoice != nil {
		n += m.HttpsChoice.Size()
	}
	l = len(m.IscsiAccessZone)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BasePath)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RootClientEnable {
		n += 2
	}
	return n
}

func (m *StorageClassDellIsilonF800Type_AzServiceName) Size() (n int) {
	var l int
	_ = l
	l = len(m.AzServiceName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageClassDellIsilonF800Type_AzServiceIpAddress) Size() (n int) {
	var l int
	_ = l
	l = len(m.AzServiceIpAddress)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *StorageClassHPENimbusStorageAf40Type) Size() (n int) {
	var l int
	_ = l
	l = len(m.PerfPolicy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LimitIops != 0 {
		n += 1 + sovTypes(uint64(m.LimitIops))
	}
	if m.LimitMbps != 0 {
		n += 1 + sovTypes(uint64(m.LimitMbps))
	}
	return n
}

func (m *StorageClassOpenebsEnterpriseType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Replication != 0 {
		n += 1 + sovTypes(uint64(m.Replication))
	}
	return n
}

func (m *StorageClassNetappTridentType) Size() (n int) {
	var l int
	_ = l
	if len(m.Selector) > 0 {
		for k, v := range m.Selector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.StoragePools)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StorageClassPureServiceOrchestratorType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Backend)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IopsLimit != 0 {
		n += 1 + sovTypes(uint64(m.IopsLimit))
	}
	l = len(m.BandwidthLimit)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *FleetStorageClassType) Size() (n int) {
	var l int
	_ = l
	l = len(m.StorageDevice)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DefaultStorageClass {
		n += 2
	}
	if len(m.AdvancedStorageParameters) > 0 {
		for k, v := range m.AdvancedStorageParameters {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.StorageClassName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DeviceChoice != nil {
		n += m.DeviceChoice.Size()
	}
	l = len(m.ReclaimPolicy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AllowVolumeExpansion {
		n += 2
	}
	return n
}

func (m *FleetStorageClassType_NetappTrident) Size() (n int) {
	var l int
	_ = l
	if m.NetappTrident != nil {
		l = m.NetappTrident.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetStorageClassType_PureServiceOrchestrator) Size() (n int) {
	var l int
	_ = l
	if m.PureServiceOrchestrator != nil {
		l = m.PureServiceOrchestrator.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetStorageClassType_OpenebsEnterprise) Size() (n int) {
	var l int
	_ = l
	if m.OpenebsEnterprise != nil {
		l = m.OpenebsEnterprise.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetStorageClassListType) Size() (n int) {
	var l int
	_ = l
	if len(m.StorageClasses) > 0 {
		for _, e := range m.StorageClasses {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *BondLacpType) Size() (n int) {
	var l int
	_ = l
	if m.Rate != 0 {
		n += 1 + sovTypes(uint64(m.Rate))
	}
	return n
}

func (m *FleetBondDeviceType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Devices) > 0 {
		for _, s := range m.Devices {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.LacpChoice != nil {
		n += m.LacpChoice.Size()
	}
	if m.LinkPollingInterval != 0 {
		n += 1 + sovTypes(uint64(m.LinkPollingInterval))
	}
	if m.LinkUpDelay != 0 {
		n += 1 + sovTypes(uint64(m.LinkUpDelay))
	}
	return n
}

func (m *FleetBondDeviceType_Lacp) Size() (n int) {
	var l int
	_ = l
	if m.Lacp != nil {
		l = m.Lacp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetBondDeviceType_ActiveBackup) Size() (n int) {
	var l int
	_ = l
	if m.ActiveBackup != nil {
		l = m.ActiveBackup.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetBondDevicesListType) Size() (n int) {
	var l int
	_ = l
	if len(m.BondDevices) > 0 {
		for _, e := range m.BondDevices {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *FleetStorageStaticRoutesListType) Size() (n int) {
	var l int
	_ = l
	if len(m.StorageRoutes) > 0 {
		for _, e := range m.StorageRoutes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *BGPConfiguration) Size() (n int) {
	var l int
	_ = l
	if m.BgpParameters != nil {
		l = m.BgpParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *LocalControlPlaneType) Size() (n int) {
	var l int
	_ = l
	if m.NetworkChoice != nil {
		n += m.NetworkChoice.Size()
	}
	if m.BgpConfig != nil {
		l = m.BgpConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *LocalControlPlaneType_InsideVn) Size() (n int) {
	var l int
	_ = l
	if m.InsideVn != nil {
		l = m.InsideVn.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LocalControlPlaneType_OutsideVn) Size() (n int) {
	var l int
	_ = l
	if m.OutsideVn != nil {
		l = m.OutsideVn.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType) Size() (n int) {
	var l int
	_ = l
	l = len(m.FleetLabel)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VolterraSoftwareVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.NetworkConnectors) > 0 {
		for _, e := range m.NetworkConnectors {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.NetworkFirewall) > 0 {
		for _, e := range m.NetworkFirewall {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.OperatingSystemVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.OutsideVirtualNetwork) > 0 {
		for _, e := range m.OutsideVirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.InsideVirtualNetwork) > 0 {
		for _, e := range m.InsideVirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	if m.BondChoice != nil {
		n += m.BondChoice.Size()
	}
	if m.StorageInterfaceChoice != nil {
		n += m.StorageInterfaceChoice.Size()
	}
	if m.StorageDeviceChoice != nil {
		n += m.StorageDeviceChoice.Size()
	}
	if m.StorageClassChoice != nil {
		n += m.StorageClassChoice.Size()
	}
	if m.DcClusterGroupChoice != nil {
		n += m.DcClusterGroupChoice.Size()
	}
	if m.GpuChoice != nil {
		n += m.GpuChoice.Size()
	}
	if m.EtcdClusterNetwork != 0 {
		n += 2 + sovTypes(uint64(m.EtcdClusterNetwork))
	}
	if m.StorageStaticRoutesChoice != nil {
		n += m.StorageStaticRoutesChoice.Size()
	}
	if m.EnableDefaultFleetConfigDownload {
		n += 3
	}
	if m.FleetType != 0 {
		n += 2 + sovTypes(uint64(m.FleetType))
	}
	if len(m.SingleSite) > 0 {
		for _, e := range m.SingleSite {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.LogsReceiverChoice != nil {
		n += m.LogsReceiverChoice.Size()
	}
	if m.UsbPolicyChoice != nil {
		n += m.UsbPolicyChoice.Size()
	}
	if m.K8SCluster != nil {
		l = m.K8SCluster.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.LocalControlPlane != nil {
		l = m.LocalControlPlane.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ViewInternal != nil {
		l = m.ViewInternal.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType_InterfaceList) Size() (n int) {
	var l int
	_ = l
	if m.InterfaceList != nil {
		l = m.InterfaceList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_LegacyDevices) Size() (n int) {
	var l int
	_ = l
	if m.LegacyDevices != nil {
		l = m.LegacyDevices.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_NoBondDevices) Size() (n int) {
	var l int
	_ = l
	if m.NoBondDevices != nil {
		l = m.NoBondDevices.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_BondDeviceList) Size() (n int) {
	var l int
	_ = l
	if m.BondDeviceList != nil {
		l = m.BondDeviceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_NoStorageInterfaces) Size() (n int) {
	var l int
	_ = l
	if m.NoStorageInterfaces != nil {
		l = m.NoStorageInterfaces.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_StorageInterfaceList) Size() (n int) {
	var l int
	_ = l
	if m.StorageInterfaceList != nil {
		l = m.StorageInterfaceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_NoStorageDevice) Size() (n int) {
	var l int
	_ = l
	if m.NoStorageDevice != nil {
		l = m.NoStorageDevice.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_StorageDeviceList) Size() (n int) {
	var l int
	_ = l
	if m.StorageDeviceList != nil {
		l = m.StorageDeviceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DefaultStorageClass) Size() (n int) {
	var l int
	_ = l
	if m.DefaultStorageClass != nil {
		l = m.DefaultStorageClass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_StorageClassList) Size() (n int) {
	var l int
	_ = l
	if m.StorageClassList != nil {
		l = m.StorageClassList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_NoDcClusterGroup) Size() (n int) {
	var l int
	_ = l
	if m.NoDcClusterGroup != nil {
		l = m.NoDcClusterGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DcClusterGroup) Size() (n int) {
	var l int
	_ = l
	if m.DcClusterGroup != nil {
		l = m.DcClusterGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DisableGpu) Size() (n int) {
	var l int
	_ = l
	if m.DisableGpu != nil {
		l = m.DisableGpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_EnableGpu) Size() (n int) {
	var l int
	_ = l
	if m.EnableGpu != nil {
		l = m.EnableGpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_NoStorageStaticRoutes) Size() (n int) {
	var l int
	_ = l
	if m.NoStorageStaticRoutes != nil {
		l = m.NoStorageStaticRoutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_StorageStaticRoutes) Size() (n int) {
	var l int
	_ = l
	if m.StorageStaticRoutes != nil {
		l = m.StorageStaticRoutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DcClusterGroupInside) Size() (n int) {
	var l int
	_ = l
	if m.DcClusterGroupInside != nil {
		l = m.DcClusterGroupInside.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DefaultInterfaces) Size() (n int) {
	var l int
	_ = l
	if m.DefaultInterfaces != nil {
		l = m.DefaultInterfaces.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_LogsStreamingDisabled) Size() (n int) {
	var l int
	_ = l
	if m.LogsStreamingDisabled != nil {
		l = m.LogsStreamingDisabled.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_LogReceiver) Size() (n int) {
	var l int
	_ = l
	if m.LogReceiver != nil {
		l = m.LogReceiver.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DenyAllUsb) Size() (n int) {
	var l int
	_ = l
	if m.DenyAllUsb != nil {
		l = m.DenyAllUsb.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AllowAllUsb) Size() (n int) {
	var l int
	_ = l
	if m.AllowAllUsb != nil {
		l = m.AllowAllUsb.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_UsbPolicy) Size() (n int) {
	var l int
	_ = l
	if m.UsbPolicy != nil {
		l = m.UsbPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	var l int
	_ = l
	l = len(m.FleetLabel)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VolterraSoftwareVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.NetworkConnectors) > 0 {
		for _, e := range m.NetworkConnectors {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.NetworkFirewall) > 0 {
		for _, e := range m.NetworkFirewall {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.OperatingSystemVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.OutsideVirtualNetwork) > 0 {
		for _, e := range m.OutsideVirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.InsideVirtualNetwork) > 0 {
		for _, e := range m.InsideVirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	if m.BondChoice != nil {
		n += m.BondChoice.Size()
	}
	if m.StorageInterfaceChoice != nil {
		n += m.StorageInterfaceChoice.Size()
	}
	if m.StorageDeviceChoice != nil {
		n += m.StorageDeviceChoice.Size()
	}
	if m.StorageClassChoice != nil {
		n += m.StorageClassChoice.Size()
	}
	if m.DcClusterGroupChoice != nil {
		n += m.DcClusterGroupChoice.Size()
	}
	if m.GpuChoice != nil {
		n += m.GpuChoice.Size()
	}
	if m.StorageStaticRoutesChoice != nil {
		n += m.StorageStaticRoutesChoice.Size()
	}
	if m.EnableDefaultFleetConfigDownload {
		n += 3
	}
	if m.LogsReceiverChoice != nil {
		n += m.LogsReceiverChoice.Size()
	}
	if m.UsbPolicyChoice != nil {
		n += m.UsbPolicyChoice.Size()
	}
	return n
}

func (m *CreateSpecType_InterfaceList) Size() (n int) {
	var l int
	_ = l
	if m.InterfaceList != nil {
		l = m.InterfaceList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DeviceList) Size() (n int) {
	var l int
	_ = l
	if m.DeviceList != nil {
		l = m.DeviceList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_NoBondDevices) Size() (n int) {
	var l int
	_ = l
	if m.NoBondDevices != nil {
		l = m.NoBondDevices.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_BondDeviceList) Size() (n int) {
	var l int
	_ = l
	if m.BondDeviceList != nil {
		l = m.BondDeviceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_NoStorageInterfaces) Size() (n int) {
	var l int
	_ = l
	if m.NoStorageInterfaces != nil {
		l = m.NoStorageInterfaces.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_StorageInterfaceList) Size() (n int) {
	var l int
	_ = l
	if m.StorageInterfaceList != nil {
		l = m.StorageInterfaceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_NoStorageDevice) Size() (n int) {
	var l int
	_ = l
	if m.NoStorageDevice != nil {
		l = m.NoStorageDevice.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_StorageDeviceList) Size() (n int) {
	var l int
	_ = l
	if m.StorageDeviceList != nil {
		l = m.StorageDeviceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DefaultStorageClass) Size() (n int) {
	var l int
	_ = l
	if m.DefaultStorageClass != nil {
		l = m.DefaultStorageClass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_StorageClassList) Size() (n int) {
	var l int
	_ = l
	if m.StorageClassList != nil {
		l = m.StorageClassList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_NoDcClusterGroup) Size() (n int) {
	var l int
	_ = l
	if m.NoDcClusterGroup != nil {
		l = m.NoDcClusterGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DcClusterGroup) Size() (n int) {
	var l int
	_ = l
	if m.DcClusterGroup != nil {
		l = m.DcClusterGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DisableGpu) Size() (n int) {
	var l int
	_ = l
	if m.DisableGpu != nil {
		l = m.DisableGpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_EnableGpu) Size() (n int) {
	var l int
	_ = l
	if m.EnableGpu != nil {
		l = m.EnableGpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_NoStorageStaticRoutes) Size() (n int) {
	var l int
	_ = l
	if m.NoStorageStaticRoutes != nil {
		l = m.NoStorageStaticRoutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_StorageStaticRoutes) Size() (n int) {
	var l int
	_ = l
	if m.StorageStaticRoutes != nil {
		l = m.StorageStaticRoutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DcClusterGroupInside) Size() (n int) {
	var l int
	_ = l
	if m.DcClusterGroupInside != nil {
		l = m.DcClusterGroupInside.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DefaultConfig) Size() (n int) {
	var l int
	_ = l
	if m.DefaultConfig != nil {
		l = m.DefaultConfig.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_LogsStreamingDisabled) Size() (n int) {
	var l int
	_ = l
	if m.LogsStreamingDisabled != nil {
		l = m.LogsStreamingDisabled.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_LogReceiver) Size() (n int) {
	var l int
	_ = l
	if m.LogReceiver != nil {
		l = m.LogReceiver.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DenyAllUsb) Size() (n int) {
	var l int
	_ = l
	if m.DenyAllUsb != nil {
		l = m.DenyAllUsb.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AllowAllUsb) Size() (n int) {
	var l int
	_ = l
	if m.AllowAllUsb != nil {
		l = m.AllowAllUsb.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_UsbPolicy) Size() (n int) {
	var l int
	_ = l
	if m.UsbPolicy != nil {
		l = m.UsbPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	var l int
	_ = l
	l = len(m.VolterraSoftwareVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.NetworkConnectors) > 0 {
		for _, e := range m.NetworkConnectors {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.NetworkFirewall) > 0 {
		for _, e := range m.NetworkFirewall {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.OperatingSystemVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.OutsideVirtualNetwork) > 0 {
		for _, e := range m.OutsideVirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.InsideVirtualNetwork) > 0 {
		for _, e := range m.InsideVirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	if m.BondChoice != nil {
		n += m.BondChoice.Size()
	}
	if m.StorageInterfaceChoice != nil {
		n += m.StorageInterfaceChoice.Size()
	}
	if m.StorageDeviceChoice != nil {
		n += m.StorageDeviceChoice.Size()
	}
	if m.StorageClassChoice != nil {
		n += m.StorageClassChoice.Size()
	}
	if m.DcClusterGroupChoice != nil {
		n += m.DcClusterGroupChoice.Size()
	}
	if m.GpuChoice != nil {
		n += m.GpuChoice.Size()
	}
	if m.StorageStaticRoutesChoice != nil {
		n += m.StorageStaticRoutesChoice.Size()
	}
	if m.EnableDefaultFleetConfigDownload {
		n += 3
	}
	if m.LogsReceiverChoice != nil {
		n += m.LogsReceiverChoice.Size()
	}
	if m.UsbPolicyChoice != nil {
		n += m.UsbPolicyChoice.Size()
	}
	return n
}

func (m *ReplaceSpecType_InterfaceList) Size() (n int) {
	var l int
	_ = l
	if m.InterfaceList != nil {
		l = m.InterfaceList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DeviceList) Size() (n int) {
	var l int
	_ = l
	if m.DeviceList != nil {
		l = m.DeviceList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_NoBondDevices) Size() (n int) {
	var l int
	_ = l
	if m.NoBondDevices != nil {
		l = m.NoBondDevices.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_BondDeviceList) Size() (n int) {
	var l int
	_ = l
	if m.BondDeviceList != nil {
		l = m.BondDeviceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_NoStorageInterfaces) Size() (n int) {
	var l int
	_ = l
	if m.NoStorageInterfaces != nil {
		l = m.NoStorageInterfaces.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_StorageInterfaceList) Size() (n int) {
	var l int
	_ = l
	if m.StorageInterfaceList != nil {
		l = m.StorageInterfaceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_NoStorageDevice) Size() (n int) {
	var l int
	_ = l
	if m.NoStorageDevice != nil {
		l = m.NoStorageDevice.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_StorageDeviceList) Size() (n int) {
	var l int
	_ = l
	if m.StorageDeviceList != nil {
		l = m.StorageDeviceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DefaultStorageClass) Size() (n int) {
	var l int
	_ = l
	if m.DefaultStorageClass != nil {
		l = m.DefaultStorageClass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_StorageClassList) Size() (n int) {
	var l int
	_ = l
	if m.StorageClassList != nil {
		l = m.StorageClassList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_NoDcClusterGroup) Size() (n int) {
	var l int
	_ = l
	if m.NoDcClusterGroup != nil {
		l = m.NoDcClusterGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DcClusterGroup) Size() (n int) {
	var l int
	_ = l
	if m.DcClusterGroup != nil {
		l = m.DcClusterGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DisableGpu) Size() (n int) {
	var l int
	_ = l
	if m.DisableGpu != nil {
		l = m.DisableGpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_EnableGpu) Size() (n int) {
	var l int
	_ = l
	if m.EnableGpu != nil {
		l = m.EnableGpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_NoStorageStaticRoutes) Size() (n int) {
	var l int
	_ = l
	if m.NoStorageStaticRoutes != nil {
		l = m.NoStorageStaticRoutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_StorageStaticRoutes) Size() (n int) {
	var l int
	_ = l
	if m.StorageStaticRoutes != nil {
		l = m.StorageStaticRoutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DcClusterGroupInside) Size() (n int) {
	var l int
	_ = l
	if m.DcClusterGroupInside != nil {
		l = m.DcClusterGroupInside.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DefaultConfig) Size() (n int) {
	var l int
	_ = l
	if m.DefaultConfig != nil {
		l = m.DefaultConfig.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_LogsStreamingDisabled) Size() (n int) {
	var l int
	_ = l
	if m.LogsStreamingDisabled != nil {
		l = m.LogsStreamingDisabled.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_LogReceiver) Size() (n int) {
	var l int
	_ = l
	if m.LogReceiver != nil {
		l = m.LogReceiver.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DenyAllUsb) Size() (n int) {
	var l int
	_ = l
	if m.DenyAllUsb != nil {
		l = m.DenyAllUsb.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AllowAllUsb) Size() (n int) {
	var l int
	_ = l
	if m.AllowAllUsb != nil {
		l = m.AllowAllUsb.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_UsbPolicy) Size() (n int) {
	var l int
	_ = l
	if m.UsbPolicy != nil {
		l = m.UsbPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	var l int
	_ = l
	l = len(m.FleetLabel)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VolterraSoftwareVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.NetworkConnectors) > 0 {
		for _, e := range m.NetworkConnectors {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.NetworkFirewall) > 0 {
		for _, e := range m.NetworkFirewall {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.OperatingSystemVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.OutsideVirtualNetwork) > 0 {
		for _, e := range m.OutsideVirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.InsideVirtualNetwork) > 0 {
		for _, e := range m.InsideVirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	if m.BondChoice != nil {
		n += m.BondChoice.Size()
	}
	if m.StorageInterfaceChoice != nil {
		n += m.StorageInterfaceChoice.Size()
	}
	if m.StorageDeviceChoice != nil {
		n += m.StorageDeviceChoice.Size()
	}
	if m.StorageClassChoice != nil {
		n += m.StorageClassChoice.Size()
	}
	if m.DcClusterGroupChoice != nil {
		n += m.DcClusterGroupChoice.Size()
	}
	if m.GpuChoice != nil {
		n += m.GpuChoice.Size()
	}
	if m.StorageStaticRoutesChoice != nil {
		n += m.StorageStaticRoutesChoice.Size()
	}
	if m.EnableDefaultFleetConfigDownload {
		n += 3
	}
	if m.LogsReceiverChoice != nil {
		n += m.LogsReceiverChoice.Size()
	}
	if m.UsbPolicyChoice != nil {
		n += m.UsbPolicyChoice.Size()
	}
	return n
}

func (m *GetSpecType_InterfaceList) Size() (n int) {
	var l int
	_ = l
	if m.InterfaceList != nil {
		l = m.InterfaceList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DeviceList) Size() (n int) {
	var l int
	_ = l
	if m.DeviceList != nil {
		l = m.DeviceList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_NoBondDevices) Size() (n int) {
	var l int
	_ = l
	if m.NoBondDevices != nil {
		l = m.NoBondDevices.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_BondDeviceList) Size() (n int) {
	var l int
	_ = l
	if m.BondDeviceList != nil {
		l = m.BondDeviceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_NoStorageInterfaces) Size() (n int) {
	var l int
	_ = l
	if m.NoStorageInterfaces != nil {
		l = m.NoStorageInterfaces.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_StorageInterfaceList) Size() (n int) {
	var l int
	_ = l
	if m.StorageInterfaceList != nil {
		l = m.StorageInterfaceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_NoStorageDevice) Size() (n int) {
	var l int
	_ = l
	if m.NoStorageDevice != nil {
		l = m.NoStorageDevice.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_StorageDeviceList) Size() (n int) {
	var l int
	_ = l
	if m.StorageDeviceList != nil {
		l = m.StorageDeviceList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DefaultStorageClass) Size() (n int) {
	var l int
	_ = l
	if m.DefaultStorageClass != nil {
		l = m.DefaultStorageClass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_StorageClassList) Size() (n int) {
	var l int
	_ = l
	if m.StorageClassList != nil {
		l = m.StorageClassList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_NoDcClusterGroup) Size() (n int) {
	var l int
	_ = l
	if m.NoDcClusterGroup != nil {
		l = m.NoDcClusterGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DcClusterGroup) Size() (n int) {
	var l int
	_ = l
	if m.DcClusterGroup != nil {
		l = m.DcClusterGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DisableGpu) Size() (n int) {
	var l int
	_ = l
	if m.DisableGpu != nil {
		l = m.DisableGpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_EnableGpu) Size() (n int) {
	var l int
	_ = l
	if m.EnableGpu != nil {
		l = m.EnableGpu.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_NoStorageStaticRoutes) Size() (n int) {
	var l int
	_ = l
	if m.NoStorageStaticRoutes != nil {
		l = m.NoStorageStaticRoutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_StorageStaticRoutes) Size() (n int) {
	var l int
	_ = l
	if m.StorageStaticRoutes != nil {
		l = m.StorageStaticRoutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DcClusterGroupInside) Size() (n int) {
	var l int
	_ = l
	if m.DcClusterGroupInside != nil {
		l = m.DcClusterGroupInside.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DefaultConfig) Size() (n int) {
	var l int
	_ = l
	if m.DefaultConfig != nil {
		l = m.DefaultConfig.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_LogsStreamingDisabled) Size() (n int) {
	var l int
	_ = l
	if m.LogsStreamingDisabled != nil {
		l = m.LogsStreamingDisabled.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_LogReceiver) Size() (n int) {
	var l int
	_ = l
	if m.LogReceiver != nil {
		l = m.LogReceiver.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DenyAllUsb) Size() (n int) {
	var l int
	_ = l
	if m.DenyAllUsb != nil {
		l = m.DenyAllUsb.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AllowAllUsb) Size() (n int) {
	var l int
	_ = l
	if m.AllowAllUsb != nil {
		l = m.AllowAllUsb.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_UsbPolicy) Size() (n int) {
	var l int
	_ = l
	if m.UsbPolicy != nil {
		l = m.UsbPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FleetStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.AvailableSoftwareVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *NetworkingDeviceInstanceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkingDeviceInstanceType{`,
		`Interface:` + strings.Replace(fmt.Sprintf("%v", this.Interface), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`Use:` + fmt.Sprintf("%v", this.Use) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GenericDeviceInstanceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GenericDeviceInstanceType{`,
		`}`,
	}, "")
	return s
}
func (this *DeviceInstanceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeviceInstanceType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Owner:` + fmt.Sprintf("%v", this.Owner) + `,`,
		`DeviceInstance:` + fmt.Sprintf("%v", this.DeviceInstance) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeviceInstanceType_NetworkDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeviceInstanceType_NetworkDevice{`,
		`NetworkDevice:` + strings.Replace(fmt.Sprintf("%v", this.NetworkDevice), "NetworkingDeviceInstanceType", "NetworkingDeviceInstanceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetInterfaceListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetInterfaceListType{`,
		`Interfaces:` + strings.Replace(fmt.Sprintf("%v", this.Interfaces), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetDeviceListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetDeviceListType{`,
		`Devices:` + strings.Replace(fmt.Sprintf("%v", this.Devices), "DeviceInstanceType", "DeviceInstanceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceOpenebsEnterpriseType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceOpenebsEnterpriseType{`,
		`MayastorPools:` + strings.Replace(fmt.Sprintf("%v", this.MayastorPools), "OpenebsMayastorPoolType", "OpenebsMayastorPoolType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OpenebsMayastorPoolType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OpenebsMayastorPoolType{`,
		`PoolName:` + fmt.Sprintf("%v", this.PoolName) + `,`,
		`Node:` + fmt.Sprintf("%v", this.Node) + `,`,
		`PoolDiskDevices:` + fmt.Sprintf("%v", this.PoolDiskDevices) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceDellIsilonF800Type) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceDellIsilonF800Type{`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`Password:` + strings.Replace(fmt.Sprintf("%v", this.Password), "SecretType", "ves_io_schema4.SecretType", 1) + `,`,
		`HttpsChoice:` + fmt.Sprintf("%v", this.HttpsChoice) + `,`,
		`AddressChoice:` + fmt.Sprintf("%v", this.AddressChoice) + `,`,
		`ApiServerPort:` + fmt.Sprintf("%v", this.ApiServerPort) + `,`,
		`IscsiAccessZone:` + fmt.Sprintf("%v", this.IscsiAccessZone) + `,`,
		`VolumePrefix:` + fmt.Sprintf("%v", this.VolumePrefix) + `,`,
		`BasePath:` + fmt.Sprintf("%v", this.BasePath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceDellIsilonF800Type_SecureNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceDellIsilonF800Type_SecureNetwork{`,
		`SecureNetwork:` + strings.Replace(fmt.Sprintf("%v", this.SecureNetwork), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceDellIsilonF800Type_TrustedCaUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceDellIsilonF800Type_TrustedCaUrl{`,
		`TrustedCaUrl:` + fmt.Sprintf("%v", this.TrustedCaUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceDellIsilonF800Type_ApiServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceDellIsilonF800Type_ApiServerName{`,
		`ApiServerName:` + fmt.Sprintf("%v", this.ApiServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceDellIsilonF800Type_ApiServerIpAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceDellIsilonF800Type_ApiServerIpAddress{`,
		`ApiServerIpAddress:` + fmt.Sprintf("%v", this.ApiServerIpAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceHPENimbusStorageAf40Type) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceHPENimbusStorageAf40Type{`,
		`StorageServerName:` + fmt.Sprintf("%v", this.StorageServerName) + `,`,
		`StorageServerIpAddress:` + fmt.Sprintf("%v", this.StorageServerIpAddress) + `,`,
		`ApiServerPort:` + fmt.Sprintf("%v", this.ApiServerPort) + `,`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`Password:` + strings.Replace(fmt.Sprintf("%v", this.Password), "SecretType", "ves_io_schema4.SecretType", 1) + `,`,
		`PerfPolicy:` + fmt.Sprintf("%v", this.PerfPolicy) + `,`,
		`LimitIops:` + fmt.Sprintf("%v", this.LimitIops) + `,`,
		`LimitMbps:` + fmt.Sprintf("%v", this.LimitMbps) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDevicePureStorageServiceOrchestratorType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDevicePureStorageServiceOrchestratorType{`,
		`ClusterId:` + fmt.Sprintf("%v", this.ClusterId) + `,`,
		`EnableStorageTopology:` + fmt.Sprintf("%v", this.EnableStorageTopology) + `,`,
		`EnableStrictTopology:` + fmt.Sprintf("%v", this.EnableStrictTopology) + `,`,
		`Arrays:` + strings.Replace(fmt.Sprintf("%v", this.Arrays), "PsoArrayConfiguration", "PsoArrayConfiguration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PsoArrayConfiguration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PsoArrayConfiguration{`,
		`FlashArray:` + strings.Replace(fmt.Sprintf("%v", this.FlashArray), "FlashArrayType", "FlashArrayType", 1) + `,`,
		`FlashBlade:` + strings.Replace(fmt.Sprintf("%v", this.FlashBlade), "FlashBladeType", "FlashBladeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashBladeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FlashBladeType{`,
		`EnableSnapshotDirectory:` + fmt.Sprintf("%v", this.EnableSnapshotDirectory) + `,`,
		`ExportRules:` + fmt.Sprintf("%v", this.ExportRules) + `,`,
		`FlashBlades:` + strings.Replace(fmt.Sprintf("%v", this.FlashBlades), "FlashBladeEndpoint", "FlashBladeEndpoint", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashBladeEndpoint) String() string {
	if this == nil {
		return "nil"
	}
	keysForLables := make([]string, 0, len(this.Lables))
	for k, _ := range this.Lables {
		keysForLables = append(keysForLables, k)
	}
	sortkeys.Strings(keysForLables)
	mapStringForLables := "map[string]string{"
	for _, k := range keysForLables {
		mapStringForLables += fmt.Sprintf("%v: %v,", k, this.Lables[k])
	}
	mapStringForLables += "}"
	s := strings.Join([]string{`&FlashBladeEndpoint{`,
		`MgmtEndpoint:` + fmt.Sprintf("%v", this.MgmtEndpoint) + `,`,
		`ApiToken:` + strings.Replace(fmt.Sprintf("%v", this.ApiToken), "SecretType", "ves_io_schema4.SecretType", 1) + `,`,
		`NfsEndpoint:` + fmt.Sprintf("%v", this.NfsEndpoint) + `,`,
		`Lables:` + mapStringForLables + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashBladeEndpoint_MgmtIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FlashBladeEndpoint_MgmtIp{`,
		`MgmtIp:` + fmt.Sprintf("%v", this.MgmtIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashBladeEndpoint_MgmtDnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FlashBladeEndpoint_MgmtDnsName{`,
		`MgmtDnsName:` + fmt.Sprintf("%v", this.MgmtDnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashBladeEndpoint_NfsEndpointIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FlashBladeEndpoint_NfsEndpointIp{`,
		`NfsEndpointIp:` + fmt.Sprintf("%v", this.NfsEndpointIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashBladeEndpoint_NfsEndpointDnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FlashBladeEndpoint_NfsEndpointDnsName{`,
		`NfsEndpointDnsName:` + fmt.Sprintf("%v", this.NfsEndpointDnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashArrayType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FlashArrayType{`,
		`SanType:` + fmt.Sprintf("%v", this.SanType) + `,`,
		`DefaultFsType:` + fmt.Sprintf("%v", this.DefaultFsType) + `,`,
		`DefaultFsOpt:` + fmt.Sprintf("%v", this.DefaultFsOpt) + `,`,
		`DefaultMountOpts:` + fmt.Sprintf("%v", this.DefaultMountOpts) + `,`,
		`DisablePreemptAttachments:` + fmt.Sprintf("%v", this.DisablePreemptAttachments) + `,`,
		`IscsiLoginTimeout:` + fmt.Sprintf("%v", this.IscsiLoginTimeout) + `,`,
		`FlashArrays:` + strings.Replace(fmt.Sprintf("%v", this.FlashArrays), "FlashArrayEndpoint", "FlashArrayEndpoint", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashArrayEndpoint) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&FlashArrayEndpoint{`,
		`MgmtEndpoint:` + fmt.Sprintf("%v", this.MgmtEndpoint) + `,`,
		`ApiToken:` + strings.Replace(fmt.Sprintf("%v", this.ApiToken), "SecretType", "ves_io_schema4.SecretType", 1) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashArrayEndpoint_MgmtIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FlashArrayEndpoint_MgmtIp{`,
		`MgmtIp:` + fmt.Sprintf("%v", this.MgmtIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlashArrayEndpoint_MgmtDnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FlashArrayEndpoint_MgmtDnsName{`,
		`MgmtDnsName:` + fmt.Sprintf("%v", this.MgmtDnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappTridentType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappTridentType{`,
		`BackendChoice:` + fmt.Sprintf("%v", this.BackendChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappTridentType_NetappBackendOntapNas) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappTridentType_NetappBackendOntapNas{`,
		`NetappBackendOntapNas:` + strings.Replace(fmt.Sprintf("%v", this.NetappBackendOntapNas), "StorageDeviceNetappBackendOntapNasType", "StorageDeviceNetappBackendOntapNasType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappTridentType_NetappBackendOntapSan) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappTridentType_NetappBackendOntapSan{`,
		`NetappBackendOntapSan:` + strings.Replace(fmt.Sprintf("%v", this.NetappBackendOntapSan), "StorageDeviceNetappBackendOntapSanType", "StorageDeviceNetappBackendOntapSanType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapSanType{`,
		`StorageDriverName:` + fmt.Sprintf("%v", this.StorageDriverName) + `,`,
		`ManagementLif:` + fmt.Sprintf("%v", this.ManagementLif) + `,`,
		`DataLif:` + fmt.Sprintf("%v", this.DataLif) + `,`,
		`Svm:` + fmt.Sprintf("%v", this.Svm) + `,`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`Password:` + strings.Replace(fmt.Sprintf("%v", this.Password), "SecretType", "ves_io_schema4.SecretType", 1) + `,`,
		`ChapChoice:` + fmt.Sprintf("%v", this.ChapChoice) + `,`,
		`IgroupName:` + fmt.Sprintf("%v", this.IgroupName) + `,`,
		`StoragePrefix:` + fmt.Sprintf("%v", this.StoragePrefix) + `,`,
		`LimitAggregateUsage:` + fmt.Sprintf("%v", this.LimitAggregateUsage) + `,`,
		`LimitVolumeSize:` + fmt.Sprintf("%v", this.LimitVolumeSize) + `,`,
		`VolumeDefaults:` + strings.Replace(fmt.Sprintf("%v", this.VolumeDefaults), "OntapVolumeDefaults", "OntapVolumeDefaults", 1) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`Storage:` + strings.Replace(fmt.Sprintf("%v", this.Storage), "OntapVirtualStoragePoolType", "OntapVirtualStoragePoolType", 1) + `,`,
		`ClientCertificate:` + fmt.Sprintf("%v", this.ClientCertificate) + `,`,
		`ClientPrivateKey:` + strings.Replace(fmt.Sprintf("%v", this.ClientPrivateKey), "SecretType", "ves_io_schema4.SecretType", 1) + `,`,
		`TrustedCaCertificate:` + fmt.Sprintf("%v", this.TrustedCaCertificate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_ManagementLifIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapSanType_ManagementLifIp{`,
		`ManagementLifIp:` + fmt.Sprintf("%v", this.ManagementLifIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName{`,
		`ManagementLifDnsName:` + fmt.Sprintf("%v", this.ManagementLifDnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_DataLifIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapSanType_DataLifIp{`,
		`DataLifIp:` + fmt.Sprintf("%v", this.DataLifIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_DataLifDnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapSanType_DataLifDnsName{`,
		`DataLifDnsName:` + fmt.Sprintf("%v", this.DataLifDnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_NoChap) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapSanType_NoChap{`,
		`NoChap:` + strings.Replace(fmt.Sprintf("%v", this.NoChap), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapSanType_UseChap) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapSanType_UseChap{`,
		`UseChap:` + strings.Replace(fmt.Sprintf("%v", this.UseChap), "DeviceNetappBackendOntapSanChapType", "DeviceNetappBackendOntapSanChapType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeviceNetappBackendOntapSanChapType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeviceNetappBackendOntapSanChapType{`,
		`ChapUsername:` + fmt.Sprintf("%v", this.ChapUsername) + `,`,
		`ChapTargetUsername:` + fmt.Sprintf("%v", this.ChapTargetUsername) + `,`,
		`ChapInitiatorSecret:` + strings.Replace(fmt.Sprintf("%v", this.ChapInitiatorSecret), "SecretType", "ves_io_schema4.SecretType", 1) + `,`,
		`ChapTargetInitiatorSecret:` + strings.Replace(fmt.Sprintf("%v", this.ChapTargetInitiatorSecret), "SecretType", "ves_io_schema4.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapNasType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapNasType{`,
		`StorageDriverName:` + fmt.Sprintf("%v", this.StorageDriverName) + `,`,
		`BackendName:` + fmt.Sprintf("%v", this.BackendName) + `,`,
		`ManagementLif:` + fmt.Sprintf("%v", this.ManagementLif) + `,`,
		`DataLif:` + fmt.Sprintf("%v", this.DataLif) + `,`,
		`Svm:` + fmt.Sprintf("%v", this.Svm) + `,`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`Password:` + strings.Replace(fmt.Sprintf("%v", this.Password), "SecretType", "ves_io_schema4.SecretType", 1) + `,`,
		`AutoExportPolicy:` + fmt.Sprintf("%v", this.AutoExportPolicy) + `,`,
		`AutoExportCidrs:` + strings.Replace(fmt.Sprintf("%v", this.AutoExportCidrs), "PrefixStringListType", "ves_io_schema_views.PrefixStringListType", 1) + `,`,
		`StoragePrefix:` + fmt.Sprintf("%v", this.StoragePrefix) + `,`,
		`LimitAggregateUsage:` + fmt.Sprintf("%v", this.LimitAggregateUsage) + `,`,
		`LimitVolumeSize:` + fmt.Sprintf("%v", this.LimitVolumeSize) + `,`,
		`NfsMountOptions:` + fmt.Sprintf("%v", this.NfsMountOptions) + `,`,
		`VolumeDefaults:` + strings.Replace(fmt.Sprintf("%v", this.VolumeDefaults), "OntapVolumeDefaults", "OntapVolumeDefaults", 1) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`Storage:` + strings.Replace(fmt.Sprintf("%v", this.Storage), "OntapVirtualStoragePoolType", "OntapVirtualStoragePoolType", 1) + `,`,
		`ClientCertificate:` + fmt.Sprintf("%v", this.ClientCertificate) + `,`,
		`ClientPrivateKey:` + strings.Replace(fmt.Sprintf("%v", this.ClientPrivateKey), "SecretType", "ves_io_schema4.SecretType", 1) + `,`,
		`TrustedCaCertificate:` + fmt.Sprintf("%v", this.TrustedCaCertificate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapNasType_ManagementLifIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapNasType_ManagementLifIp{`,
		`ManagementLifIp:` + fmt.Sprintf("%v", this.ManagementLifIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName{`,
		`ManagementLifDnsName:` + fmt.Sprintf("%v", this.ManagementLifDnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapNasType_DataLifIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapNasType_DataLifIp{`,
		`DataLifIp:` + fmt.Sprintf("%v", this.DataLifIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeviceNetappBackendOntapNasType_DataLifDnsName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeviceNetappBackendOntapNasType_DataLifDnsName{`,
		`DataLifDnsName:` + fmt.Sprintf("%v", this.DataLifDnsName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OntapVolumeDefaults) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OntapVolumeDefaults{`,
		`SpaceReserve:` + fmt.Sprintf("%v", this.SpaceReserve) + `,`,
		`SnapshotPolicy:` + fmt.Sprintf("%v", this.SnapshotPolicy) + `,`,
		`SnapshotReserve:` + fmt.Sprintf("%v", this.SnapshotReserve) + `,`,
		`SplitOnClone:` + fmt.Sprintf("%v", this.SplitOnClone) + `,`,
		`Encryption:` + fmt.Sprintf("%v", this.Encryption) + `,`,
		`UnixPermissions:` + fmt.Sprintf("%v", this.UnixPermissions) + `,`,
		`SnapshotDir:` + fmt.Sprintf("%v", this.SnapshotDir) + `,`,
		`ExportPolicy:` + fmt.Sprintf("%v", this.ExportPolicy) + `,`,
		`SecurityStyle:` + fmt.Sprintf("%v", this.SecurityStyle) + `,`,
		`TieringPolicy:` + fmt.Sprintf("%v", this.TieringPolicy) + `,`,
		`QosPolicyChoice:` + fmt.Sprintf("%v", this.QosPolicyChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OntapVolumeDefaults_NoQos) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OntapVolumeDefaults_NoQos{`,
		`NoQos:` + strings.Replace(fmt.Sprintf("%v", this.NoQos), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OntapVolumeDefaults_QosPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OntapVolumeDefaults_QosPolicy{`,
		`QosPolicy:` + fmt.Sprintf("%v", this.QosPolicy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OntapVolumeDefaults_AdaptiveQosPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OntapVolumeDefaults_AdaptiveQosPolicy{`,
		`AdaptiveQosPolicy:` + fmt.Sprintf("%v", this.AdaptiveQosPolicy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OntapVirtualStoragePoolType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&OntapVirtualStoragePoolType{`,
		`Labels:` + mapStringForLabels + `,`,
		`Zone:` + fmt.Sprintf("%v", this.Zone) + `,`,
		`VolumeDefaults:` + strings.Replace(fmt.Sprintf("%v", this.VolumeDefaults), "OntapVolumeDefaults", "OntapVolumeDefaults", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageDeviceType) String() string {
	if this == nil {
		return "nil"
	}
	keysForAdvancedAdvancedParameters := make([]string, 0, len(this.AdvancedAdvancedParameters))
	for k, _ := range this.AdvancedAdvancedParameters {
		keysForAdvancedAdvancedParameters = append(keysForAdvancedAdvancedParameters, k)
	}
	sortkeys.Strings(keysForAdvancedAdvancedParameters)
	mapStringForAdvancedAdvancedParameters := "map[string]string{"
	for _, k := range keysForAdvancedAdvancedParameters {
		mapStringForAdvancedAdvancedParameters += fmt.Sprintf("%v: %v,", k, this.AdvancedAdvancedParameters[k])
	}
	mapStringForAdvancedAdvancedParameters += "}"
	s := strings.Join([]string{`&FleetStorageDeviceType{`,
		`StorageDevice:` + fmt.Sprintf("%v", this.StorageDevice) + `,`,
		`AdvancedAdvancedParameters:` + mapStringForAdvancedAdvancedParameters + `,`,
		`DeviceChoice:` + fmt.Sprintf("%v", this.DeviceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageDeviceType_NetappTrident) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStorageDeviceType_NetappTrident{`,
		`NetappTrident:` + strings.Replace(fmt.Sprintf("%v", this.NetappTrident), "StorageDeviceNetappTridentType", "StorageDeviceNetappTridentType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageDeviceType_PureServiceOrchestrator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStorageDeviceType_PureServiceOrchestrator{`,
		`PureServiceOrchestrator:` + strings.Replace(fmt.Sprintf("%v", this.PureServiceOrchestrator), "StorageDevicePureStorageServiceOrchestratorType", "StorageDevicePureStorageServiceOrchestratorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageDeviceType_OpenebsEnterprise) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStorageDeviceType_OpenebsEnterprise{`,
		`OpenebsEnterprise:` + strings.Replace(fmt.Sprintf("%v", this.OpenebsEnterprise), "StorageDeviceOpenebsEnterpriseType", "StorageDeviceOpenebsEnterpriseType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageDeviceListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStorageDeviceListType{`,
		`StorageDevices:` + strings.Replace(fmt.Sprintf("%v", this.StorageDevices), "FleetStorageDeviceType", "FleetStorageDeviceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageClassDellIsilonF800Type) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageClassDellIsilonF800Type{`,
		`HttpsChoice:` + fmt.Sprintf("%v", this.HttpsChoice) + `,`,
		`IscsiAccessZone:` + fmt.Sprintf("%v", this.IscsiAccessZone) + `,`,
		`BasePath:` + fmt.Sprintf("%v", this.BasePath) + `,`,
		`RootClientEnable:` + fmt.Sprintf("%v", this.RootClientEnable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageClassDellIsilonF800Type_AzServiceName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageClassDellIsilonF800Type_AzServiceName{`,
		`AzServiceName:` + fmt.Sprintf("%v", this.AzServiceName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageClassDellIsilonF800Type_AzServiceIpAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageClassDellIsilonF800Type_AzServiceIpAddress{`,
		`AzServiceIpAddress:` + fmt.Sprintf("%v", this.AzServiceIpAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageClassHPENimbusStorageAf40Type) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageClassHPENimbusStorageAf40Type{`,
		`PerfPolicy:` + fmt.Sprintf("%v", this.PerfPolicy) + `,`,
		`LimitIops:` + fmt.Sprintf("%v", this.LimitIops) + `,`,
		`LimitMbps:` + fmt.Sprintf("%v", this.LimitMbps) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageClassOpenebsEnterpriseType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageClassOpenebsEnterpriseType{`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`Replication:` + fmt.Sprintf("%v", this.Replication) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageClassNetappTridentType) String() string {
	if this == nil {
		return "nil"
	}
	keysForSelector := make([]string, 0, len(this.Selector))
	for k, _ := range this.Selector {
		keysForSelector = append(keysForSelector, k)
	}
	sortkeys.Strings(keysForSelector)
	mapStringForSelector := "map[string]string{"
	for _, k := range keysForSelector {
		mapStringForSelector += fmt.Sprintf("%v: %v,", k, this.Selector[k])
	}
	mapStringForSelector += "}"
	s := strings.Join([]string{`&StorageClassNetappTridentType{`,
		`Selector:` + mapStringForSelector + `,`,
		`StoragePools:` + fmt.Sprintf("%v", this.StoragePools) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageClassPureServiceOrchestratorType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageClassPureServiceOrchestratorType{`,
		`Backend:` + fmt.Sprintf("%v", this.Backend) + `,`,
		`IopsLimit:` + fmt.Sprintf("%v", this.IopsLimit) + `,`,
		`BandwidthLimit:` + fmt.Sprintf("%v", this.BandwidthLimit) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageClassType) String() string {
	if this == nil {
		return "nil"
	}
	keysForAdvancedStorageParameters := make([]string, 0, len(this.AdvancedStorageParameters))
	for k, _ := range this.AdvancedStorageParameters {
		keysForAdvancedStorageParameters = append(keysForAdvancedStorageParameters, k)
	}
	sortkeys.Strings(keysForAdvancedStorageParameters)
	mapStringForAdvancedStorageParameters := "map[string]string{"
	for _, k := range keysForAdvancedStorageParameters {
		mapStringForAdvancedStorageParameters += fmt.Sprintf("%v: %v,", k, this.AdvancedStorageParameters[k])
	}
	mapStringForAdvancedStorageParameters += "}"
	s := strings.Join([]string{`&FleetStorageClassType{`,
		`StorageDevice:` + fmt.Sprintf("%v", this.StorageDevice) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`DefaultStorageClass:` + fmt.Sprintf("%v", this.DefaultStorageClass) + `,`,
		`AdvancedStorageParameters:` + mapStringForAdvancedStorageParameters + `,`,
		`StorageClassName:` + fmt.Sprintf("%v", this.StorageClassName) + `,`,
		`DeviceChoice:` + fmt.Sprintf("%v", this.DeviceChoice) + `,`,
		`ReclaimPolicy:` + fmt.Sprintf("%v", this.ReclaimPolicy) + `,`,
		`AllowVolumeExpansion:` + fmt.Sprintf("%v", this.AllowVolumeExpansion) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageClassType_NetappTrident) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStorageClassType_NetappTrident{`,
		`NetappTrident:` + strings.Replace(fmt.Sprintf("%v", this.NetappTrident), "StorageClassNetappTridentType", "StorageClassNetappTridentType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageClassType_PureServiceOrchestrator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStorageClassType_PureServiceOrchestrator{`,
		`PureServiceOrchestrator:` + strings.Replace(fmt.Sprintf("%v", this.PureServiceOrchestrator), "StorageClassPureServiceOrchestratorType", "StorageClassPureServiceOrchestratorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageClassType_OpenebsEnterprise) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStorageClassType_OpenebsEnterprise{`,
		`OpenebsEnterprise:` + strings.Replace(fmt.Sprintf("%v", this.OpenebsEnterprise), "StorageClassOpenebsEnterpriseType", "StorageClassOpenebsEnterpriseType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageClassListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStorageClassListType{`,
		`StorageClasses:` + strings.Replace(fmt.Sprintf("%v", this.StorageClasses), "FleetStorageClassType", "FleetStorageClassType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BondLacpType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BondLacpType{`,
		`Rate:` + fmt.Sprintf("%v", this.Rate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetBondDeviceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetBondDeviceType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Devices:` + fmt.Sprintf("%v", this.Devices) + `,`,
		`LacpChoice:` + fmt.Sprintf("%v", this.LacpChoice) + `,`,
		`LinkPollingInterval:` + fmt.Sprintf("%v", this.LinkPollingInterval) + `,`,
		`LinkUpDelay:` + fmt.Sprintf("%v", this.LinkUpDelay) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetBondDeviceType_Lacp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetBondDeviceType_Lacp{`,
		`Lacp:` + strings.Replace(fmt.Sprintf("%v", this.Lacp), "BondLacpType", "BondLacpType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetBondDeviceType_ActiveBackup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetBondDeviceType_ActiveBackup{`,
		`ActiveBackup:` + strings.Replace(fmt.Sprintf("%v", this.ActiveBackup), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetBondDevicesListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetBondDevicesListType{`,
		`BondDevices:` + strings.Replace(fmt.Sprintf("%v", this.BondDevices), "FleetBondDeviceType", "FleetBondDeviceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStorageStaticRoutesListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStorageStaticRoutesListType{`,
		`StorageRoutes:` + strings.Replace(fmt.Sprintf("%v", this.StorageRoutes), "StaticRouteType", "ves_io_schema4.StaticRouteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BGPConfiguration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BGPConfiguration{`,
		`BgpParameters:` + strings.Replace(fmt.Sprintf("%v", this.BgpParameters), "BgpParameters", "ves_io_schema_bgp.BgpParameters", 1) + `,`,
		`Peers:` + strings.Replace(fmt.Sprintf("%v", this.Peers), "Peer", "ves_io_schema_bgp.Peer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalControlPlaneType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalControlPlaneType{`,
		`NetworkChoice:` + fmt.Sprintf("%v", this.NetworkChoice) + `,`,
		`BgpConfig:` + strings.Replace(fmt.Sprintf("%v", this.BgpConfig), "BGPConfiguration", "BGPConfiguration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalControlPlaneType_InsideVn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalControlPlaneType_InsideVn{`,
		`InsideVn:` + strings.Replace(fmt.Sprintf("%v", this.InsideVn), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalControlPlaneType_OutsideVn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalControlPlaneType_OutsideVn{`,
		`OutsideVn:` + strings.Replace(fmt.Sprintf("%v", this.OutsideVn), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`FleetLabel:` + fmt.Sprintf("%v", this.FleetLabel) + `,`,
		`VolterraSoftwareVersion:` + fmt.Sprintf("%v", this.VolterraSoftwareVersion) + `,`,
		`Devices:` + strings.Replace(fmt.Sprintf("%v", this.Devices), "DeviceInstanceType", "DeviceInstanceType", 1) + `,`,
		`NetworkConnectors:` + strings.Replace(fmt.Sprintf("%v", this.NetworkConnectors), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`NetworkFirewall:` + strings.Replace(fmt.Sprintf("%v", this.NetworkFirewall), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`OutsideVirtualNetwork:` + strings.Replace(fmt.Sprintf("%v", this.OutsideVirtualNetwork), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`InsideVirtualNetwork:` + strings.Replace(fmt.Sprintf("%v", this.InsideVirtualNetwork), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`BondChoice:` + fmt.Sprintf("%v", this.BondChoice) + `,`,
		`StorageInterfaceChoice:` + fmt.Sprintf("%v", this.StorageInterfaceChoice) + `,`,
		`StorageDeviceChoice:` + fmt.Sprintf("%v", this.StorageDeviceChoice) + `,`,
		`StorageClassChoice:` + fmt.Sprintf("%v", this.StorageClassChoice) + `,`,
		`DcClusterGroupChoice:` + fmt.Sprintf("%v", this.DcClusterGroupChoice) + `,`,
		`GpuChoice:` + fmt.Sprintf("%v", this.GpuChoice) + `,`,
		`EtcdClusterNetwork:` + fmt.Sprintf("%v", this.EtcdClusterNetwork) + `,`,
		`StorageStaticRoutesChoice:` + fmt.Sprintf("%v", this.StorageStaticRoutesChoice) + `,`,
		`EnableDefaultFleetConfigDownload:` + fmt.Sprintf("%v", this.EnableDefaultFleetConfigDownload) + `,`,
		`FleetType:` + fmt.Sprintf("%v", this.FleetType) + `,`,
		`SingleSite:` + strings.Replace(fmt.Sprintf("%v", this.SingleSite), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`LogsReceiverChoice:` + fmt.Sprintf("%v", this.LogsReceiverChoice) + `,`,
		`UsbPolicyChoice:` + fmt.Sprintf("%v", this.UsbPolicyChoice) + `,`,
		`K8SCluster:` + strings.Replace(fmt.Sprintf("%v", this.K8SCluster), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`LocalControlPlane:` + strings.Replace(fmt.Sprintf("%v", this.LocalControlPlane), "LocalControlPlaneType", "LocalControlPlaneType", 1) + `,`,
		`ViewInternal:` + strings.Replace(fmt.Sprintf("%v", this.ViewInternal), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_InterfaceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_InterfaceList{`,
		`InterfaceList:` + strings.Replace(fmt.Sprintf("%v", this.InterfaceList), "FleetInterfaceListType", "FleetInterfaceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_LegacyDevices) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_LegacyDevices{`,
		`LegacyDevices:` + strings.Replace(fmt.Sprintf("%v", this.LegacyDevices), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_NoBondDevices) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_NoBondDevices{`,
		`NoBondDevices:` + strings.Replace(fmt.Sprintf("%v", this.NoBondDevices), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_BondDeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_BondDeviceList{`,
		`BondDeviceList:` + strings.Replace(fmt.Sprintf("%v", this.BondDeviceList), "FleetBondDevicesListType", "FleetBondDevicesListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_NoStorageInterfaces) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_NoStorageInterfaces{`,
		`NoStorageInterfaces:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageInterfaces), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_StorageInterfaceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_StorageInterfaceList{`,
		`StorageInterfaceList:` + strings.Replace(fmt.Sprintf("%v", this.StorageInterfaceList), "FleetInterfaceListType", "FleetInterfaceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_NoStorageDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_NoStorageDevice{`,
		`NoStorageDevice:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageDevice), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_StorageDeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_StorageDeviceList{`,
		`StorageDeviceList:` + strings.Replace(fmt.Sprintf("%v", this.StorageDeviceList), "FleetStorageDeviceListType", "FleetStorageDeviceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DefaultStorageClass) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DefaultStorageClass{`,
		`DefaultStorageClass:` + strings.Replace(fmt.Sprintf("%v", this.DefaultStorageClass), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_StorageClassList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_StorageClassList{`,
		`StorageClassList:` + strings.Replace(fmt.Sprintf("%v", this.StorageClassList), "FleetStorageClassListType", "FleetStorageClassListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_NoDcClusterGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_NoDcClusterGroup{`,
		`NoDcClusterGroup:` + strings.Replace(fmt.Sprintf("%v", this.NoDcClusterGroup), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DcClusterGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DcClusterGroup{`,
		`DcClusterGroup:` + strings.Replace(fmt.Sprintf("%v", this.DcClusterGroup), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DisableGpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DisableGpu{`,
		`DisableGpu:` + strings.Replace(fmt.Sprintf("%v", this.DisableGpu), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_EnableGpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_EnableGpu{`,
		`EnableGpu:` + strings.Replace(fmt.Sprintf("%v", this.EnableGpu), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_NoStorageStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_NoStorageStaticRoutes{`,
		`NoStorageStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageStaticRoutes), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_StorageStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_StorageStaticRoutes{`,
		`StorageStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.StorageStaticRoutes), "FleetStorageStaticRoutesListType", "FleetStorageStaticRoutesListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DcClusterGroupInside) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DcClusterGroupInside{`,
		`DcClusterGroupInside:` + strings.Replace(fmt.Sprintf("%v", this.DcClusterGroupInside), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DefaultInterfaces) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DefaultInterfaces{`,
		`DefaultInterfaces:` + strings.Replace(fmt.Sprintf("%v", this.DefaultInterfaces), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_LogsStreamingDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_LogsStreamingDisabled{`,
		`LogsStreamingDisabled:` + strings.Replace(fmt.Sprintf("%v", this.LogsStreamingDisabled), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_LogReceiver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_LogReceiver{`,
		`LogReceiver:` + strings.Replace(fmt.Sprintf("%v", this.LogReceiver), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DenyAllUsb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DenyAllUsb{`,
		`DenyAllUsb:` + strings.Replace(fmt.Sprintf("%v", this.DenyAllUsb), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AllowAllUsb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AllowAllUsb{`,
		`AllowAllUsb:` + strings.Replace(fmt.Sprintf("%v", this.AllowAllUsb), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_UsbPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_UsbPolicy{`,
		`UsbPolicy:` + strings.Replace(fmt.Sprintf("%v", this.UsbPolicy), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`FleetLabel:` + fmt.Sprintf("%v", this.FleetLabel) + `,`,
		`VolterraSoftwareVersion:` + fmt.Sprintf("%v", this.VolterraSoftwareVersion) + `,`,
		`NetworkConnectors:` + strings.Replace(fmt.Sprintf("%v", this.NetworkConnectors), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`NetworkFirewall:` + strings.Replace(fmt.Sprintf("%v", this.NetworkFirewall), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`OutsideVirtualNetwork:` + strings.Replace(fmt.Sprintf("%v", this.OutsideVirtualNetwork), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`InsideVirtualNetwork:` + strings.Replace(fmt.Sprintf("%v", this.InsideVirtualNetwork), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`BondChoice:` + fmt.Sprintf("%v", this.BondChoice) + `,`,
		`StorageInterfaceChoice:` + fmt.Sprintf("%v", this.StorageInterfaceChoice) + `,`,
		`StorageDeviceChoice:` + fmt.Sprintf("%v", this.StorageDeviceChoice) + `,`,
		`StorageClassChoice:` + fmt.Sprintf("%v", this.StorageClassChoice) + `,`,
		`DcClusterGroupChoice:` + fmt.Sprintf("%v", this.DcClusterGroupChoice) + `,`,
		`GpuChoice:` + fmt.Sprintf("%v", this.GpuChoice) + `,`,
		`StorageStaticRoutesChoice:` + fmt.Sprintf("%v", this.StorageStaticRoutesChoice) + `,`,
		`EnableDefaultFleetConfigDownload:` + fmt.Sprintf("%v", this.EnableDefaultFleetConfigDownload) + `,`,
		`LogsReceiverChoice:` + fmt.Sprintf("%v", this.LogsReceiverChoice) + `,`,
		`UsbPolicyChoice:` + fmt.Sprintf("%v", this.UsbPolicyChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_InterfaceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_InterfaceList{`,
		`InterfaceList:` + strings.Replace(fmt.Sprintf("%v", this.InterfaceList), "FleetInterfaceListType", "FleetInterfaceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DeviceList{`,
		`DeviceList:` + strings.Replace(fmt.Sprintf("%v", this.DeviceList), "FleetDeviceListType", "FleetDeviceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_NoBondDevices) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_NoBondDevices{`,
		`NoBondDevices:` + strings.Replace(fmt.Sprintf("%v", this.NoBondDevices), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_BondDeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_BondDeviceList{`,
		`BondDeviceList:` + strings.Replace(fmt.Sprintf("%v", this.BondDeviceList), "FleetBondDevicesListType", "FleetBondDevicesListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_NoStorageInterfaces) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_NoStorageInterfaces{`,
		`NoStorageInterfaces:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageInterfaces), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_StorageInterfaceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_StorageInterfaceList{`,
		`StorageInterfaceList:` + strings.Replace(fmt.Sprintf("%v", this.StorageInterfaceList), "FleetInterfaceListType", "FleetInterfaceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_NoStorageDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_NoStorageDevice{`,
		`NoStorageDevice:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageDevice), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_StorageDeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_StorageDeviceList{`,
		`StorageDeviceList:` + strings.Replace(fmt.Sprintf("%v", this.StorageDeviceList), "FleetStorageDeviceListType", "FleetStorageDeviceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DefaultStorageClass) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DefaultStorageClass{`,
		`DefaultStorageClass:` + strings.Replace(fmt.Sprintf("%v", this.DefaultStorageClass), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_StorageClassList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_StorageClassList{`,
		`StorageClassList:` + strings.Replace(fmt.Sprintf("%v", this.StorageClassList), "FleetStorageClassListType", "FleetStorageClassListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_NoDcClusterGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_NoDcClusterGroup{`,
		`NoDcClusterGroup:` + strings.Replace(fmt.Sprintf("%v", this.NoDcClusterGroup), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DcClusterGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DcClusterGroup{`,
		`DcClusterGroup:` + strings.Replace(fmt.Sprintf("%v", this.DcClusterGroup), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DisableGpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DisableGpu{`,
		`DisableGpu:` + strings.Replace(fmt.Sprintf("%v", this.DisableGpu), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_EnableGpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_EnableGpu{`,
		`EnableGpu:` + strings.Replace(fmt.Sprintf("%v", this.EnableGpu), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_NoStorageStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_NoStorageStaticRoutes{`,
		`NoStorageStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageStaticRoutes), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_StorageStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_StorageStaticRoutes{`,
		`StorageStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.StorageStaticRoutes), "FleetStorageStaticRoutesListType", "FleetStorageStaticRoutesListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DcClusterGroupInside) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DcClusterGroupInside{`,
		`DcClusterGroupInside:` + strings.Replace(fmt.Sprintf("%v", this.DcClusterGroupInside), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DefaultConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DefaultConfig{`,
		`DefaultConfig:` + strings.Replace(fmt.Sprintf("%v", this.DefaultConfig), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_LogsStreamingDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_LogsStreamingDisabled{`,
		`LogsStreamingDisabled:` + strings.Replace(fmt.Sprintf("%v", this.LogsStreamingDisabled), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_LogReceiver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_LogReceiver{`,
		`LogReceiver:` + strings.Replace(fmt.Sprintf("%v", this.LogReceiver), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DenyAllUsb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DenyAllUsb{`,
		`DenyAllUsb:` + strings.Replace(fmt.Sprintf("%v", this.DenyAllUsb), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AllowAllUsb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AllowAllUsb{`,
		`AllowAllUsb:` + strings.Replace(fmt.Sprintf("%v", this.AllowAllUsb), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_UsbPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_UsbPolicy{`,
		`UsbPolicy:` + strings.Replace(fmt.Sprintf("%v", this.UsbPolicy), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`VolterraSoftwareVersion:` + fmt.Sprintf("%v", this.VolterraSoftwareVersion) + `,`,
		`NetworkConnectors:` + strings.Replace(fmt.Sprintf("%v", this.NetworkConnectors), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`NetworkFirewall:` + strings.Replace(fmt.Sprintf("%v", this.NetworkFirewall), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`OutsideVirtualNetwork:` + strings.Replace(fmt.Sprintf("%v", this.OutsideVirtualNetwork), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`InsideVirtualNetwork:` + strings.Replace(fmt.Sprintf("%v", this.InsideVirtualNetwork), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`BondChoice:` + fmt.Sprintf("%v", this.BondChoice) + `,`,
		`StorageInterfaceChoice:` + fmt.Sprintf("%v", this.StorageInterfaceChoice) + `,`,
		`StorageDeviceChoice:` + fmt.Sprintf("%v", this.StorageDeviceChoice) + `,`,
		`StorageClassChoice:` + fmt.Sprintf("%v", this.StorageClassChoice) + `,`,
		`DcClusterGroupChoice:` + fmt.Sprintf("%v", this.DcClusterGroupChoice) + `,`,
		`GpuChoice:` + fmt.Sprintf("%v", this.GpuChoice) + `,`,
		`StorageStaticRoutesChoice:` + fmt.Sprintf("%v", this.StorageStaticRoutesChoice) + `,`,
		`EnableDefaultFleetConfigDownload:` + fmt.Sprintf("%v", this.EnableDefaultFleetConfigDownload) + `,`,
		`LogsReceiverChoice:` + fmt.Sprintf("%v", this.LogsReceiverChoice) + `,`,
		`UsbPolicyChoice:` + fmt.Sprintf("%v", this.UsbPolicyChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_InterfaceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_InterfaceList{`,
		`InterfaceList:` + strings.Replace(fmt.Sprintf("%v", this.InterfaceList), "FleetInterfaceListType", "FleetInterfaceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DeviceList{`,
		`DeviceList:` + strings.Replace(fmt.Sprintf("%v", this.DeviceList), "FleetDeviceListType", "FleetDeviceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_NoBondDevices) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_NoBondDevices{`,
		`NoBondDevices:` + strings.Replace(fmt.Sprintf("%v", this.NoBondDevices), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_BondDeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_BondDeviceList{`,
		`BondDeviceList:` + strings.Replace(fmt.Sprintf("%v", this.BondDeviceList), "FleetBondDevicesListType", "FleetBondDevicesListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_NoStorageInterfaces) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_NoStorageInterfaces{`,
		`NoStorageInterfaces:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageInterfaces), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_StorageInterfaceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_StorageInterfaceList{`,
		`StorageInterfaceList:` + strings.Replace(fmt.Sprintf("%v", this.StorageInterfaceList), "FleetInterfaceListType", "FleetInterfaceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_NoStorageDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_NoStorageDevice{`,
		`NoStorageDevice:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageDevice), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_StorageDeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_StorageDeviceList{`,
		`StorageDeviceList:` + strings.Replace(fmt.Sprintf("%v", this.StorageDeviceList), "FleetStorageDeviceListType", "FleetStorageDeviceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DefaultStorageClass) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DefaultStorageClass{`,
		`DefaultStorageClass:` + strings.Replace(fmt.Sprintf("%v", this.DefaultStorageClass), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_StorageClassList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_StorageClassList{`,
		`StorageClassList:` + strings.Replace(fmt.Sprintf("%v", this.StorageClassList), "FleetStorageClassListType", "FleetStorageClassListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_NoDcClusterGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_NoDcClusterGroup{`,
		`NoDcClusterGroup:` + strings.Replace(fmt.Sprintf("%v", this.NoDcClusterGroup), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DcClusterGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DcClusterGroup{`,
		`DcClusterGroup:` + strings.Replace(fmt.Sprintf("%v", this.DcClusterGroup), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DisableGpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DisableGpu{`,
		`DisableGpu:` + strings.Replace(fmt.Sprintf("%v", this.DisableGpu), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_EnableGpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_EnableGpu{`,
		`EnableGpu:` + strings.Replace(fmt.Sprintf("%v", this.EnableGpu), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_NoStorageStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_NoStorageStaticRoutes{`,
		`NoStorageStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageStaticRoutes), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_StorageStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_StorageStaticRoutes{`,
		`StorageStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.StorageStaticRoutes), "FleetStorageStaticRoutesListType", "FleetStorageStaticRoutesListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DcClusterGroupInside) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DcClusterGroupInside{`,
		`DcClusterGroupInside:` + strings.Replace(fmt.Sprintf("%v", this.DcClusterGroupInside), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DefaultConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DefaultConfig{`,
		`DefaultConfig:` + strings.Replace(fmt.Sprintf("%v", this.DefaultConfig), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_LogsStreamingDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_LogsStreamingDisabled{`,
		`LogsStreamingDisabled:` + strings.Replace(fmt.Sprintf("%v", this.LogsStreamingDisabled), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_LogReceiver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_LogReceiver{`,
		`LogReceiver:` + strings.Replace(fmt.Sprintf("%v", this.LogReceiver), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DenyAllUsb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DenyAllUsb{`,
		`DenyAllUsb:` + strings.Replace(fmt.Sprintf("%v", this.DenyAllUsb), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AllowAllUsb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AllowAllUsb{`,
		`AllowAllUsb:` + strings.Replace(fmt.Sprintf("%v", this.AllowAllUsb), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_UsbPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_UsbPolicy{`,
		`UsbPolicy:` + strings.Replace(fmt.Sprintf("%v", this.UsbPolicy), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`FleetLabel:` + fmt.Sprintf("%v", this.FleetLabel) + `,`,
		`VolterraSoftwareVersion:` + fmt.Sprintf("%v", this.VolterraSoftwareVersion) + `,`,
		`NetworkConnectors:` + strings.Replace(fmt.Sprintf("%v", this.NetworkConnectors), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`NetworkFirewall:` + strings.Replace(fmt.Sprintf("%v", this.NetworkFirewall), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`OutsideVirtualNetwork:` + strings.Replace(fmt.Sprintf("%v", this.OutsideVirtualNetwork), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`InsideVirtualNetwork:` + strings.Replace(fmt.Sprintf("%v", this.InsideVirtualNetwork), "ObjectRefType", "ves_io_schema4.ObjectRefType", 1) + `,`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`BondChoice:` + fmt.Sprintf("%v", this.BondChoice) + `,`,
		`StorageInterfaceChoice:` + fmt.Sprintf("%v", this.StorageInterfaceChoice) + `,`,
		`StorageDeviceChoice:` + fmt.Sprintf("%v", this.StorageDeviceChoice) + `,`,
		`StorageClassChoice:` + fmt.Sprintf("%v", this.StorageClassChoice) + `,`,
		`DcClusterGroupChoice:` + fmt.Sprintf("%v", this.DcClusterGroupChoice) + `,`,
		`GpuChoice:` + fmt.Sprintf("%v", this.GpuChoice) + `,`,
		`StorageStaticRoutesChoice:` + fmt.Sprintf("%v", this.StorageStaticRoutesChoice) + `,`,
		`EnableDefaultFleetConfigDownload:` + fmt.Sprintf("%v", this.EnableDefaultFleetConfigDownload) + `,`,
		`LogsReceiverChoice:` + fmt.Sprintf("%v", this.LogsReceiverChoice) + `,`,
		`UsbPolicyChoice:` + fmt.Sprintf("%v", this.UsbPolicyChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_InterfaceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_InterfaceList{`,
		`InterfaceList:` + strings.Replace(fmt.Sprintf("%v", this.InterfaceList), "FleetInterfaceListType", "FleetInterfaceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DeviceList{`,
		`DeviceList:` + strings.Replace(fmt.Sprintf("%v", this.DeviceList), "FleetDeviceListType", "FleetDeviceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_NoBondDevices) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_NoBondDevices{`,
		`NoBondDevices:` + strings.Replace(fmt.Sprintf("%v", this.NoBondDevices), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_BondDeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_BondDeviceList{`,
		`BondDeviceList:` + strings.Replace(fmt.Sprintf("%v", this.BondDeviceList), "FleetBondDevicesListType", "FleetBondDevicesListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_NoStorageInterfaces) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_NoStorageInterfaces{`,
		`NoStorageInterfaces:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageInterfaces), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_StorageInterfaceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_StorageInterfaceList{`,
		`StorageInterfaceList:` + strings.Replace(fmt.Sprintf("%v", this.StorageInterfaceList), "FleetInterfaceListType", "FleetInterfaceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_NoStorageDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_NoStorageDevice{`,
		`NoStorageDevice:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageDevice), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_StorageDeviceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_StorageDeviceList{`,
		`StorageDeviceList:` + strings.Replace(fmt.Sprintf("%v", this.StorageDeviceList), "FleetStorageDeviceListType", "FleetStorageDeviceListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DefaultStorageClass) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DefaultStorageClass{`,
		`DefaultStorageClass:` + strings.Replace(fmt.Sprintf("%v", this.DefaultStorageClass), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_StorageClassList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_StorageClassList{`,
		`StorageClassList:` + strings.Replace(fmt.Sprintf("%v", this.StorageClassList), "FleetStorageClassListType", "FleetStorageClassListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_NoDcClusterGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_NoDcClusterGroup{`,
		`NoDcClusterGroup:` + strings.Replace(fmt.Sprintf("%v", this.NoDcClusterGroup), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DcClusterGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DcClusterGroup{`,
		`DcClusterGroup:` + strings.Replace(fmt.Sprintf("%v", this.DcClusterGroup), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DisableGpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DisableGpu{`,
		`DisableGpu:` + strings.Replace(fmt.Sprintf("%v", this.DisableGpu), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_EnableGpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_EnableGpu{`,
		`EnableGpu:` + strings.Replace(fmt.Sprintf("%v", this.EnableGpu), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_NoStorageStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_NoStorageStaticRoutes{`,
		`NoStorageStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.NoStorageStaticRoutes), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_StorageStaticRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_StorageStaticRoutes{`,
		`StorageStaticRoutes:` + strings.Replace(fmt.Sprintf("%v", this.StorageStaticRoutes), "FleetStorageStaticRoutesListType", "FleetStorageStaticRoutesListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DcClusterGroupInside) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DcClusterGroupInside{`,
		`DcClusterGroupInside:` + strings.Replace(fmt.Sprintf("%v", this.DcClusterGroupInside), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DefaultConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DefaultConfig{`,
		`DefaultConfig:` + strings.Replace(fmt.Sprintf("%v", this.DefaultConfig), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_LogsStreamingDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_LogsStreamingDisabled{`,
		`LogsStreamingDisabled:` + strings.Replace(fmt.Sprintf("%v", this.LogsStreamingDisabled), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_LogReceiver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_LogReceiver{`,
		`LogReceiver:` + strings.Replace(fmt.Sprintf("%v", this.LogReceiver), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DenyAllUsb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DenyAllUsb{`,
		`DenyAllUsb:` + strings.Replace(fmt.Sprintf("%v", this.DenyAllUsb), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AllowAllUsb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AllowAllUsb{`,
		`AllowAllUsb:` + strings.Replace(fmt.Sprintf("%v", this.AllowAllUsb), "Empty", "ves_io_schema4.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_UsbPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_UsbPolicy{`,
		`UsbPolicy:` + strings.Replace(fmt.Sprintf("%v", this.UsbPolicy), "ObjectRefType", "ves_io_schema_views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStatus{`,
		`AvailableSoftwareVersion:` + fmt.Sprintf("%v", this.AvailableSoftwareVersion) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *NetworkingDeviceInstanceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkingDeviceInstanceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkingDeviceInstanceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interface = append(m.Interface, &ves_io_schema4.ObjectRefType{})
			if err := m.Interface[len(m.Interface)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Use", wireType)
			}
			m.Use = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Use |= (NetworkingDeviceInstanceUseType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenericDeviceInstanceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenericDeviceInstanceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenericDeviceInstanceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceInstanceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceInstanceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceInstanceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			m.Owner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Owner |= (DeviceOwnerType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NetworkingDeviceInstanceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeviceInstance = &DeviceInstanceType_NetworkDevice{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetInterfaceListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetInterfaceListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetInterfaceListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interfaces = append(m.Interfaces, &ves_io_schema_views.ObjectRefType{})
			if err := m.Interfaces[len(m.Interfaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetDeviceListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetDeviceListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetDeviceListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &DeviceInstanceType{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDeviceOpenebsEnterpriseType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDeviceOpenebsEnterpriseType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDeviceOpenebsEnterpriseType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MayastorPools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MayastorPools = append(m.MayastorPools, &OpenebsMayastorPoolType{})
			if err := m.MayastorPools[len(m.MayastorPools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenebsMayastorPoolType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenebsMayastorPoolType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenebsMayastorPoolType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolDiskDevices", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolDiskDevices = append(m.PoolDiskDevices, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDeviceDellIsilonF800Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDeviceDellIsilonF800Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDeviceDellIsilonF800Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Password == nil {
				m.Password = &ves_io_schema4.SecretType{}
			}
			if err := m.Password.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecureNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HttpsChoice = &StorageDeviceDellIsilonF800Type_SecureNetwork{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpsChoice = &StorageDeviceDellIsilonF800Type_TrustedCaUrl{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressChoice = &StorageDeviceDellIsilonF800Type_ApiServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiServerIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressChoice = &StorageDeviceDellIsilonF800Type_ApiServerIpAddress{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiServerPort", wireType)
			}
			m.ApiServerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiServerPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IscsiAccessZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IscsiAccessZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDeviceHPENimbusStorageAf40Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDeviceHPENimbusStorageAf40Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDeviceHPENimbusStorageAf40Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageServerIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageServerIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiServerPort", wireType)
			}
			m.ApiServerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiServerPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Password == nil {
				m.Password = &ves_io_schema4.SecretType{}
			}
			if err := m.Password.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerfPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PerfPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitIops", wireType)
			}
			m.LimitIops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitIops |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitMbps", wireType)
			}
			m.LimitMbps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitMbps |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDevicePureStorageServiceOrchestratorType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDevicePureStorageServiceOrchestratorType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDevicePureStorageServiceOrchestratorType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableStorageTopology", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableStorageTopology = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableStrictTopology", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableStrictTopology = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arrays", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arrays == nil {
				m.Arrays = &PsoArrayConfiguration{}
			}
			if err := m.Arrays.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PsoArrayConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PsoArrayConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PsoArrayConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlashArray", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlashArray == nil {
				m.FlashArray = &FlashArrayType{}
			}
			if err := m.FlashArray.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlashBlade", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlashBlade == nil {
				m.FlashBlade = &FlashBladeType{}
			}
			if err := m.FlashBlade.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlashBladeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlashBladeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlashBladeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSnapshotDirectory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableSnapshotDirectory = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportRules", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExportRules = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlashBlades", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlashBlades = append(m.FlashBlades, &FlashBladeEndpoint{})
			if err := m.FlashBlades[len(m.FlashBlades)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlashBladeEndpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlashBladeEndpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlashBladeEndpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MgmtEndpoint = &FlashBladeEndpoint_MgmtIp{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtDnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MgmtEndpoint = &FlashBladeEndpoint_MgmtDnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiToken == nil {
				m.ApiToken = &ves_io_schema4.SecretType{}
			}
			if err := m.ApiToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NfsEndpointIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NfsEndpoint = &FlashBladeEndpoint_NfsEndpointIp{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NfsEndpointDnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NfsEndpoint = &FlashBladeEndpoint_NfsEndpointDnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lables == nil {
				m.Lables = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Lables[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlashArrayType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlashArrayType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlashArrayType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SanType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SanType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFsType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultFsType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFsOpt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultFsOpt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultMountOpts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultMountOpts = append(m.DefaultMountOpts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisablePreemptAttachments", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisablePreemptAttachments = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IscsiLoginTimeout", wireType)
			}
			m.IscsiLoginTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IscsiLoginTimeout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlashArrays", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlashArrays = append(m.FlashArrays, &FlashArrayEndpoint{})
			if err := m.FlashArrays[len(m.FlashArrays)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlashArrayEndpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlashArrayEndpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlashArrayEndpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MgmtEndpoint = &FlashArrayEndpoint_MgmtIp{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtDnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MgmtEndpoint = &FlashArrayEndpoint_MgmtDnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiToken == nil {
				m.ApiToken = &ves_io_schema4.SecretType{}
			}
			if err := m.ApiToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDeviceNetappTridentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDeviceNetappTridentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDeviceNetappTridentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetappBackendOntapNas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageDeviceNetappBackendOntapNasType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BackendChoice = &StorageDeviceNetappTridentType_NetappBackendOntapNas{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetappBackendOntapSan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageDeviceNetappBackendOntapSanType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BackendChoice = &StorageDeviceNetappTridentType_NetappBackendOntapSan{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDeviceNetappBackendOntapSanType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDeviceNetappBackendOntapSanType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDeviceNetappBackendOntapSanType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDriverName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageDriverName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementLifIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagementLif = &StorageDeviceNetappBackendOntapSanType_ManagementLifIp{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementLifDnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagementLif = &StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLifIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataLif = &StorageDeviceNetappBackendOntapSanType_DataLifIp{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLifDnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataLif = &StorageDeviceNetappBackendOntapSanType_DataLifDnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Svm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Password == nil {
				m.Password = &ves_io_schema4.SecretType{}
			}
			if err := m.Password.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoChap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChapChoice = &StorageDeviceNetappBackendOntapSanType_NoChap{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseChap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeviceNetappBackendOntapSanChapType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChapChoice = &StorageDeviceNetappBackendOntapSanType_UseChap{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IgroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoragePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoragePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitAggregateUsage", wireType)
			}
			m.LimitAggregateUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitAggregateUsage |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitVolumeSize", wireType)
			}
			m.LimitVolumeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitVolumeSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeDefaults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeDefaults == nil {
				m.VolumeDefaults = &OntapVolumeDefaults{}
			}
			if err := m.VolumeDefaults.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storage = append(m.Storage, &OntapVirtualStoragePoolType{})
			if err := m.Storage[len(m.Storage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCertificate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientCertificate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientPrivateKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientPrivateKey == nil {
				m.ClientPrivateKey = &ves_io_schema4.SecretType{}
			}
			if err := m.ClientPrivateKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaCertificate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaCertificate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceNetappBackendOntapSanChapType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceNetappBackendOntapSanChapType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceNetappBackendOntapSanChapType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChapUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapTargetUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChapTargetUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapInitiatorSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChapInitiatorSecret == nil {
				m.ChapInitiatorSecret = &ves_io_schema4.SecretType{}
			}
			if err := m.ChapInitiatorSecret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapTargetInitiatorSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChapTargetInitiatorSecret == nil {
				m.ChapTargetInitiatorSecret = &ves_io_schema4.SecretType{}
			}
			if err := m.ChapTargetInitiatorSecret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDeviceNetappBackendOntapNasType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDeviceNetappBackendOntapNasType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDeviceNetappBackendOntapNasType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDriverName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageDriverName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackendName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackendName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementLifIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagementLif = &StorageDeviceNetappBackendOntapNasType_ManagementLifIp{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementLifDnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagementLif = &StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLifIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataLif = &StorageDeviceNetappBackendOntapNasType_DataLifIp{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLifDnsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataLif = &StorageDeviceNetappBackendOntapNasType_DataLifDnsName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Svm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Password == nil {
				m.Password = &ves_io_schema4.SecretType{}
			}
			if err := m.Password.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoExportPolicy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoExportPolicy = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoExportCidrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoExportCidrs == nil {
				m.AutoExportCidrs = &ves_io_schema_views.PrefixStringListType{}
			}
			if err := m.AutoExportCidrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoragePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoragePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitAggregateUsage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LimitAggregateUsage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitVolumeSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LimitVolumeSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NfsMountOptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NfsMountOptions = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeDefaults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeDefaults == nil {
				m.VolumeDefaults = &OntapVolumeDefaults{}
			}
			if err := m.VolumeDefaults.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storage = append(m.Storage, &OntapVirtualStoragePoolType{})
			if err := m.Storage[len(m.Storage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCertificate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientCertificate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientPrivateKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientPrivateKey == nil {
				m.ClientPrivateKey = &ves_io_schema4.SecretType{}
			}
			if err := m.ClientPrivateKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaCertificate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaCertificate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OntapVolumeDefaults) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OntapVolumeDefaults: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OntapVolumeDefaults: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceReserve", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceReserve = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotReserve", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotReserve = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitOnClone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SplitOnClone = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Encryption = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnixPermissions", wireType)
			}
			m.UnixPermissions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnixPermissions |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotDir", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SnapshotDir = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExportPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityStyle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityStyle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TieringPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TieringPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoQos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QosPolicyChoice = &OntapVolumeDefaults_NoQos{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QosPolicyChoice = &OntapVolumeDefaults_QosPolicy{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptiveQosPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QosPolicyChoice = &OntapVolumeDefaults_AdaptiveQosPolicy{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OntapVirtualStoragePoolType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OntapVirtualStoragePoolType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OntapVirtualStoragePoolType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeDefaults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeDefaults == nil {
				m.VolumeDefaults = &OntapVolumeDefaults{}
			}
			if err := m.VolumeDefaults.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetStorageDeviceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetStorageDeviceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetStorageDeviceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDevice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageDevice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvancedAdvancedParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdvancedAdvancedParameters == nil {
				m.AdvancedAdvancedParameters = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AdvancedAdvancedParameters[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetappTrident", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageDeviceNetappTridentType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeviceChoice = &FleetStorageDeviceType_NetappTrident{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PureServiceOrchestrator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageDevicePureStorageServiceOrchestratorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeviceChoice = &FleetStorageDeviceType_PureServiceOrchestrator{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenebsEnterprise", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageDeviceOpenebsEnterpriseType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeviceChoice = &FleetStorageDeviceType_OpenebsEnterprise{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetStorageDeviceListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetStorageDeviceListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetStorageDeviceListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageDevices = append(m.StorageDevices, &FleetStorageDeviceType{})
			if err := m.StorageDevices[len(m.StorageDevices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageClassDellIsilonF800Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageClassDellIsilonF800Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageClassDellIsilonF800Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpsChoice = &StorageClassDellIsilonF800Type_AzServiceName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzServiceIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpsChoice = &StorageClassDellIsilonF800Type_AzServiceIpAddress{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IscsiAccessZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IscsiAccessZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootClientEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RootClientEnable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageClassHPENimbusStorageAf40Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageClassHPENimbusStorageAf40Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageClassHPENimbusStorageAf40Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerfPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PerfPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitIops", wireType)
			}
			m.LimitIops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitIops |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitMbps", wireType)
			}
			m.LimitMbps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitMbps |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageClassOpenebsEnterpriseType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageClassOpenebsEnterpriseType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageClassOpenebsEnterpriseType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replication", wireType)
			}
			m.Replication = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Replication |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageClassNetappTridentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageClassNetappTridentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageClassNetappTridentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selector == nil {
				m.Selector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Selector[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoragePools", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoragePools = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageClassPureServiceOrchestratorType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageClassPureServiceOrchestratorType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageClassPureServiceOrchestratorType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backend", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Backend = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IopsLimit", wireType)
			}
			m.IopsLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IopsLimit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BandwidthLimit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BandwidthLimit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetStorageClassType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetStorageClassType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetStorageClassType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDevice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageDevice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultStorageClass", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultStorageClass = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvancedStorageParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdvancedStorageParameters == nil {
				m.AdvancedStorageParameters = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AdvancedStorageParameters[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetappTrident", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageClassNetappTridentType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeviceChoice = &FleetStorageClassType_NetappTrident{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PureServiceOrchestrator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageClassPureServiceOrchestratorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeviceChoice = &FleetStorageClassType_PureServiceOrchestrator{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenebsEnterprise", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageClassOpenebsEnterpriseType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeviceChoice = &FleetStorageClassType_OpenebsEnterprise{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReclaimPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReclaimPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowVolumeExpansion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowVolumeExpansion = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetStorageClassListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetStorageClassListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetStorageClassListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClasses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageClasses = append(m.StorageClasses, &FleetStorageClassType{})
			if err := m.StorageClasses[len(m.StorageClasses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BondLacpType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BondLacpType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BondLacpType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetBondDeviceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetBondDeviceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetBondDeviceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lacp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BondLacpType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LacpChoice = &FleetBondDeviceType_Lacp{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveBackup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LacpChoice = &FleetBondDeviceType_ActiveBackup{v}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkPollingInterval", wireType)
			}
			m.LinkPollingInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkPollingInterval |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkUpDelay", wireType)
			}
			m.LinkUpDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkUpDelay |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetBondDevicesListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetBondDevicesListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetBondDevicesListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondDevices = append(m.BondDevices, &FleetBondDeviceType{})
			if err := m.BondDevices[len(m.BondDevices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetStorageStaticRoutesListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetStorageStaticRoutesListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetStorageStaticRoutesListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageRoutes = append(m.StorageRoutes, &ves_io_schema4.StaticRouteType{})
			if err := m.StorageRoutes[len(m.StorageRoutes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BgpParameters == nil {
				m.BgpParameters = &ves_io_schema_bgp.BgpParameters{}
			}
			if err := m.BgpParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &ves_io_schema_bgp.Peer{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalControlPlaneType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalControlPlaneType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalControlPlaneType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &LocalControlPlaneType_InsideVn{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &LocalControlPlaneType_OutsideVn{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BgpConfig == nil {
				m.BgpConfig = &BGPConfiguration{}
			}
			if err := m.BgpConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FleetLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FleetLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolterraSoftwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &DeviceInstanceType{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkConnectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkConnectors = append(m.NetworkConnectors, &ves_io_schema4.ObjectRefType{})
			if err := m.NetworkConnectors[len(m.NetworkConnectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkFirewall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkFirewall = append(m.NetworkFirewall, &ves_io_schema4.ObjectRefType{})
			if err := m.NetworkFirewall[len(m.NetworkFirewall)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVirtualNetwork = append(m.OutsideVirtualNetwork, &ves_io_schema4.ObjectRefType{})
			if err := m.OutsideVirtualNetwork[len(m.OutsideVirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVirtualNetwork = append(m.InsideVirtualNetwork, &ves_io_schema4.ObjectRefType{})
			if err := m.InsideVirtualNetwork[len(m.InsideVirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetInterfaceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GlobalSpecType_InterfaceList{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GlobalSpecType_LegacyDevices{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoBondDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BondChoice = &GlobalSpecType_NoBondDevices{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetBondDevicesListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BondChoice = &GlobalSpecType_BondDeviceList{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageInterfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageInterfaceChoice = &GlobalSpecType_NoStorageInterfaces{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageInterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetInterfaceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageInterfaceChoice = &GlobalSpecType_StorageInterfaceList{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageDeviceChoice = &GlobalSpecType_NoStorageDevice{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageDeviceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageDeviceChoice = &GlobalSpecType_StorageDeviceList{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultStorageClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageClassChoice = &GlobalSpecType_DefaultStorageClass{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClassList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageClassListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageClassChoice = &GlobalSpecType_StorageClassList{v}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoDcClusterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &GlobalSpecType_NoDcClusterGroup{v}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &GlobalSpecType_DcClusterGroup{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableGpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &GlobalSpecType_DisableGpu{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableGpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &GlobalSpecType_EnableGpu{v}
			iNdEx = postIndex
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EtcdClusterNetwork", wireType)
			}
			m.EtcdClusterNetwork = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EtcdClusterNetwork |= (EtcdClusterNetworkType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageStaticRoutesChoice = &GlobalSpecType_NoStorageStaticRoutes{v}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageStaticRoutesListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageStaticRoutesChoice = &GlobalSpecType_StorageStaticRoutes{v}
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableDefaultFleetConfigDownload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableDefaultFleetConfigDownload = bool(v != 0)
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroupInside", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &GlobalSpecType_DcClusterGroupInside{v}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultInterfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GlobalSpecType_DefaultInterfaces{v}
			iNdEx = postIndex
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FleetType", wireType)
			}
			m.FleetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FleetType |= (FleetType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SingleSite = append(m.SingleSite, &ves_io_schema4.ObjectRefType{})
			if err := m.SingleSite[len(m.SingleSite)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsStreamingDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &GlobalSpecType_LogsStreamingDisabled{v}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogReceiver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &GlobalSpecType_LogReceiver{v}
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyAllUsb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &GlobalSpecType_DenyAllUsb{v}
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAllUsb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &GlobalSpecType_AllowAllUsb{v}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsbPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &GlobalSpecType_UsbPolicy{v}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K8SCluster == nil {
				m.K8SCluster = &ves_io_schema_views.ObjectRefType{}
			}
			if err := m.K8SCluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalControlPlane", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalControlPlane == nil {
				m.LocalControlPlane = &LocalControlPlaneType{}
			}
			if err := m.LocalControlPlane.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewInternal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ViewInternal == nil {
				m.ViewInternal = &ves_io_schema_views.ObjectRefType{}
			}
			if err := m.ViewInternal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FleetLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FleetLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolterraSoftwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkConnectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkConnectors = append(m.NetworkConnectors, &ves_io_schema4.ObjectRefType{})
			if err := m.NetworkConnectors[len(m.NetworkConnectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkFirewall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkFirewall = append(m.NetworkFirewall, &ves_io_schema4.ObjectRefType{})
			if err := m.NetworkFirewall[len(m.NetworkFirewall)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVirtualNetwork = append(m.OutsideVirtualNetwork, &ves_io_schema4.ObjectRefType{})
			if err := m.OutsideVirtualNetwork[len(m.OutsideVirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVirtualNetwork = append(m.InsideVirtualNetwork, &ves_io_schema4.ObjectRefType{})
			if err := m.InsideVirtualNetwork[len(m.InsideVirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetInterfaceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &CreateSpecType_InterfaceList{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetDeviceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &CreateSpecType_DeviceList{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoBondDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BondChoice = &CreateSpecType_NoBondDevices{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetBondDevicesListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BondChoice = &CreateSpecType_BondDeviceList{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageInterfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageInterfaceChoice = &CreateSpecType_NoStorageInterfaces{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageInterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetInterfaceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageInterfaceChoice = &CreateSpecType_StorageInterfaceList{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageDeviceChoice = &CreateSpecType_NoStorageDevice{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageDeviceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageDeviceChoice = &CreateSpecType_StorageDeviceList{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultStorageClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageClassChoice = &CreateSpecType_DefaultStorageClass{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClassList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageClassListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageClassChoice = &CreateSpecType_StorageClassList{v}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoDcClusterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &CreateSpecType_NoDcClusterGroup{v}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &CreateSpecType_DcClusterGroup{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableGpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &CreateSpecType_DisableGpu{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableGpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &CreateSpecType_EnableGpu{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageStaticRoutesChoice = &CreateSpecType_NoStorageStaticRoutes{v}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageStaticRoutesListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageStaticRoutesChoice = &CreateSpecType_StorageStaticRoutes{v}
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableDefaultFleetConfigDownload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableDefaultFleetConfigDownload = bool(v != 0)
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroupInside", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &CreateSpecType_DcClusterGroupInside{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &CreateSpecType_DefaultConfig{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsStreamingDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &CreateSpecType_LogsStreamingDisabled{v}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogReceiver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &CreateSpecType_LogReceiver{v}
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyAllUsb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &CreateSpecType_DenyAllUsb{v}
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAllUsb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &CreateSpecType_AllowAllUsb{v}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsbPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &CreateSpecType_UsbPolicy{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolterraSoftwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkConnectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkConnectors = append(m.NetworkConnectors, &ves_io_schema4.ObjectRefType{})
			if err := m.NetworkConnectors[len(m.NetworkConnectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkFirewall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkFirewall = append(m.NetworkFirewall, &ves_io_schema4.ObjectRefType{})
			if err := m.NetworkFirewall[len(m.NetworkFirewall)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVirtualNetwork = append(m.OutsideVirtualNetwork, &ves_io_schema4.ObjectRefType{})
			if err := m.OutsideVirtualNetwork[len(m.OutsideVirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVirtualNetwork = append(m.InsideVirtualNetwork, &ves_io_schema4.ObjectRefType{})
			if err := m.InsideVirtualNetwork[len(m.InsideVirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetInterfaceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &ReplaceSpecType_InterfaceList{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetDeviceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &ReplaceSpecType_DeviceList{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoBondDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BondChoice = &ReplaceSpecType_NoBondDevices{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetBondDevicesListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BondChoice = &ReplaceSpecType_BondDeviceList{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageInterfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageInterfaceChoice = &ReplaceSpecType_NoStorageInterfaces{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageInterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetInterfaceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageInterfaceChoice = &ReplaceSpecType_StorageInterfaceList{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageDeviceChoice = &ReplaceSpecType_NoStorageDevice{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageDeviceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageDeviceChoice = &ReplaceSpecType_StorageDeviceList{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultStorageClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageClassChoice = &ReplaceSpecType_DefaultStorageClass{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClassList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageClassListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageClassChoice = &ReplaceSpecType_StorageClassList{v}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoDcClusterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &ReplaceSpecType_NoDcClusterGroup{v}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &ReplaceSpecType_DcClusterGroup{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableGpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &ReplaceSpecType_DisableGpu{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableGpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &ReplaceSpecType_EnableGpu{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageStaticRoutesChoice = &ReplaceSpecType_NoStorageStaticRoutes{v}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageStaticRoutesListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageStaticRoutesChoice = &ReplaceSpecType_StorageStaticRoutes{v}
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableDefaultFleetConfigDownload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableDefaultFleetConfigDownload = bool(v != 0)
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroupInside", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &ReplaceSpecType_DcClusterGroupInside{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &ReplaceSpecType_DefaultConfig{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsStreamingDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &ReplaceSpecType_LogsStreamingDisabled{v}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogReceiver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &ReplaceSpecType_LogReceiver{v}
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyAllUsb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &ReplaceSpecType_DenyAllUsb{v}
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAllUsb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &ReplaceSpecType_AllowAllUsb{v}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsbPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &ReplaceSpecType_UsbPolicy{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FleetLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FleetLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolterraSoftwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkConnectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkConnectors = append(m.NetworkConnectors, &ves_io_schema4.ObjectRefType{})
			if err := m.NetworkConnectors[len(m.NetworkConnectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkFirewall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkFirewall = append(m.NetworkFirewall, &ves_io_schema4.ObjectRefType{})
			if err := m.NetworkFirewall[len(m.NetworkFirewall)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVirtualNetwork = append(m.OutsideVirtualNetwork, &ves_io_schema4.ObjectRefType{})
			if err := m.OutsideVirtualNetwork[len(m.OutsideVirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVirtualNetwork = append(m.InsideVirtualNetwork, &ves_io_schema4.ObjectRefType{})
			if err := m.InsideVirtualNetwork[len(m.InsideVirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetInterfaceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GetSpecType_InterfaceList{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetDeviceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GetSpecType_DeviceList{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoBondDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BondChoice = &GetSpecType_NoBondDevices{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetBondDevicesListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BondChoice = &GetSpecType_BondDeviceList{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageInterfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageInterfaceChoice = &GetSpecType_NoStorageInterfaces{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageInterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetInterfaceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageInterfaceChoice = &GetSpecType_StorageInterfaceList{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageDeviceChoice = &GetSpecType_NoStorageDevice{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDeviceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageDeviceListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageDeviceChoice = &GetSpecType_StorageDeviceList{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultStorageClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageClassChoice = &GetSpecType_DefaultStorageClass{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClassList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageClassListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageClassChoice = &GetSpecType_StorageClassList{v}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoDcClusterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &GetSpecType_NoDcClusterGroup{v}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &GetSpecType_DcClusterGroup{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableGpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &GetSpecType_DisableGpu{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableGpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GpuChoice = &GetSpecType_EnableGpu{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStorageStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageStaticRoutesChoice = &GetSpecType_NoStorageStaticRoutes{v}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageStaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FleetStorageStaticRoutesListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageStaticRoutesChoice = &GetSpecType_StorageStaticRoutes{v}
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableDefaultFleetConfigDownload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableDefaultFleetConfigDownload = bool(v != 0)
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcClusterGroupInside", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DcClusterGroupChoice = &GetSpecType_DcClusterGroupInside{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GetSpecType_DefaultConfig{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsStreamingDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &GetSpecType_LogsStreamingDisabled{v}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogReceiver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogsReceiverChoice = &GetSpecType_LogReceiver{v}
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyAllUsb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &GetSpecType_DenyAllUsb{v}
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAllUsb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema4.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &GetSpecType_AllowAllUsb{v}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsbPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ves_io_schema_views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UsbPolicyChoice = &GetSpecType_UsbPolicy{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailableSoftwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ves.io/schema/fleet/types.proto", fileDescriptorTypes) }
func init() { golang_proto.RegisterFile("ves.io/schema/fleet/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 7119 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7d, 0x5d, 0x6c, 0x1b, 0x4b,
	0x96, 0x9e, 0x8a, 0xa4, 0x24, 0xf2, 0x50, 0xfc, 0x51, 0xe9, 0x8f, 0x92, 0x6d, 0x99, 0xa6, 0x3d,
	0x73, 0x75, 0x65, 0xea, 0x87, 0xd4, 0xaf, 0x7d, 0xef, 0xf5, 0x5a, 0x94, 0x64, 0x5b, 0xb2, 0x2c,
	0x6b, 0x5b, 0xb2, 0x27, 0xb9, 0x33, 0x99, 0x4e, 0x8b, 0x2c, 0x51, 0xbd, 0x6e, 0x75, 0xf7, 0x74,
	0x37, 0x65, 0xeb, 0x06, 0x46, 0x2e, 0xfc, 0xb2, 0x89, 0x93, 0x05, 0x26, 0x3b, 0x41, 0x1e, 0x76,
	0x82, 0x60, 0x13, 0xe4, 0x61, 0xe1, 0x87, 0x24, 0x8f, 0xbb, 0x4b, 0x23, 0x30, 0x0c, 0x2c, 0x30,
	0xc8, 0xc3, 0x42, 0xc8, 0x43, 0x32, 0xb8, 0xd8, 0x87, 0x1d, 0xed, 0xcb, 0xe4, 0xbe, 0xec, 0x62,
	0x91, 0x87, 0x85, 0xf3, 0xb0, 0x41, 0x55, 0x57, 0x37, 0x9b, 0x54, 0x93, 0x92, 0xec, 0x9b, 0xc9,
	0xcc, 0x85, 0xfc, 0x40, 0x53, 0x55, 0xe7, 0x9c, 0x3a, 0x55, 0x75, 0xea, 0xd4, 0xf9, 0xaa, 0x4e,
	0x49, 0x70, 0x79, 0x9f, 0x98, 0xe3, 0xb2, 0x36, 0x61, 0x16, 0x77, 0xc9, 0x9e, 0x34, 0xb1, 0xa3,
	0x10, 0x62, 0x4d, 0x58, 0x07, 0x3a, 0x31, 0xc7, 0x75, 0x43, 0xb3, 0x34, 0xdc, 0x63, 0x13, 0x8c,
	0xdb, 0x04, 0xe3, 0x8c, 0x60, 0x68, 0xac, 0x2c, 0x5b, 0xbb, 0x95, 0xed, 0xf1, 0xa2, 0xb6, 0x37,
	0x51, 0xd6, 0xca, 0xda, 0x04, 0xa3, 0xdd, 0xae, 0xec, 0xb0, 0x9f, 0xd8, 0x0f, 0xec, 0x9b, 0x2d,
	0x63, 0xe8, 0x72, 0x59, 0xd3, 0xca, 0x0a, 0xa9, 0x51, 0x59, 0xf2, 0x1e, 0x31, 0x2d, 0x69, 0x4f,
	0xe7, 0x04, 0x97, 0xea, 0xb5, 0xd8, 0x2e, 0xeb, 0x5e, 0x1d, 0x86, 0x06, 0xea, 0xab, 0x55, 0x62,
	0xf1, 0x8a, 0x0b, 0xf5, 0x15, 0x9a, 0x6e, 0xc9, 0x9a, 0x6a, 0xfa, 0x0b, 0xd5, 0xf7, 0x2d, 0xd1,
	0x2b, 0x74, 0xb0, 0xbe, 0xda, 0x5b, 0x75, 0xb1, 0xbe, 0x6a, 0x5f, 0x52, 0xe4, 0x92, 0x64, 0x11,
	0x5e, 0x9b, 0x6e, 0xa8, 0x95, 0xc9, 0x53, 0xb1, 0xbe, 0xe5, 0xcb, 0xc7, 0x29, 0x4c, 0x6f, 0x03,
	0x99, 0xb7, 0x08, 0x2e, 0xae, 0x13, 0xeb, 0xa9, 0x66, 0x3c, 0x91, 0xd5, 0xf2, 0x12, 0xd9, 0x97,
	0x8b, 0x64, 0x45, 0x35, 0x2d, 0x49, 0x2d, 0x92, 0xad, 0x03, 0x9d, 0xe0, 0xcf, 0x21, 0x22, 0xab,
	0x16, 0x31, 0x76, 0xa4, 0x22, 0x49, 0x05, 0xd2, 0xc1, 0x91, 0x68, 0xfe, 0xe2, 0x78, 0xfd, 0x4c,
	0x3c, 0xdc, 0xfe, 0x1d, 0x52, 0xb4, 0x04, 0xb2, 0x43, 0x19, 0x0a, 0xc3, 0xaf, 0x9e, 0x77, 0xab,
	0xb6, 0x44, 0xd1, 0xe5, 0xfc, 0xd3, 0xff, 0xf5, 0x26, 0xd8, 0xfe, 0xfb, 0x28, 0x90, 0x44, 0x42,
	0x4d, 0x1c, 0xbe, 0x03, 0xc1, 0x8a, 0x49, 0x52, 0xc1, 0x34, 0x1a, 0x89, 0xe7, 0xa7, 0xc7, 0x7d,
	0xe6, 0x77, 0xbc, 0x99, 0x6e, 0x8f, 0x4c, 0xa6, 0x9e, 0x40, 0x05, 0x64, 0x2e, 0xc0, 0xe0, 0x5d,
	0xa2, 0x12, 0x43, 0x2e, 0x1e, 0xef, 0x40, 0xe6, 0xdf, 0x06, 0x00, 0xfb, 0xf4, 0x0b, 0x43, 0x48,
	0x95, 0xf6, 0x48, 0x0a, 0xa5, 0xd1, 0x48, 0x44, 0x60, 0xdf, 0xf1, 0x5d, 0x68, 0xd7, 0x9e, 0xaa,
	0xc4, 0xe0, 0x1a, 0x5d, 0xf3, 0xd5, 0xc8, 0x96, 0xf5, 0x90, 0xd2, 0xb1, 0xfe, 0x46, 0x69, 0xdf,
	0x3a, 0x5e, 0xa0, 0xe0, 0x10, 0x42, 0x82, 0xcd, 0x8f, 0x3f, 0x87, 0xb8, 0x33, 0x04, 0x25, 0x46,
	0x9e, 0x0a, 0xa5, 0xd1, 0x48, 0x34, 0x9f, 0x3b, 0x53, 0x1f, 0xa9, 0xf8, 0x7b, 0x6d, 0x42, 0x8c,
	0x8b, 0xb2, 0x2b, 0x6f, 0x5e, 0x7e, 0x5b, 0x45, 0x17, 0x60, 0x10, 0x7a, 0xed, 0x9f, 0xd3, 0x8b,
	0x9a, 0xba, 0x23, 0x97, 0x2b, 0x86, 0x44, 0xe7, 0x1d, 0xa3, 0x5c, 0x21, 0x0d, 0x09, 0xbb, 0x51,
	0x51, 0xe6, 0x82, 0x70, 0xec, 0x4d, 0x15, 0x85, 0x0e, 0xab, 0xa8, 0xfd, 0xa8, 0x8a, 0xd0, 0xf4,
	0x6a, 0x28, 0x1c, 0x48, 0x06, 0x57, 0x43, 0xe1, 0xf6, 0x64, 0x47, 0xe6, 0xc7, 0x08, 0xfa, 0xef,
	0x50, 0x35, 0x56, 0x9c, 0x69, 0x59, 0x93, 0x4d, 0x8b, 0x0d, 0xd1, 0x3e, 0x80, 0x3b, 0x57, 0x66,
	0x0a, 0xb1, 0xb9, 0xcf, 0x34, 0xf4, 0x80, 0x59, 0x54, 0x83, 0x05, 0xe4, 0x5b, 0x5a, 0x40, 0xda,
	0xf9, 0x16, 0x46, 0xce, 0xb7, 0x14, 0x12, 0x3c, 0x2d, 0x65, 0x54, 0xe8, 0x61, 0x1a, 0xd9, 0x1d,
	0x74, 0xd5, 0xf9, 0x1e, 0x74, 0xda, 0xfd, 0x32, 0x53, 0x41, 0xa6, 0xcb, 0x47, 0x2d, 0xe6, 0xc7,
	0x3b, 0x86, 0x85, 0x5e, 0xb7, 0xf1, 0xb0, 0xa7, 0x49, 0x47, 0x5a, 0xe6, 0x27, 0x08, 0x32, 0x9b,
	0x96, 0x66, 0x48, 0x65, 0xc2, 0x27, 0x57, 0x27, 0x2a, 0xd9, 0x36, 0x97, 0xa9, 0x4a, 0xba, 0x21,
	0xdb, 0xa6, 0x86, 0xf7, 0x20, 0xbe, 0x27, 0x1d, 0x48, 0xa6, 0xa5, 0x19, 0xa2, 0xae, 0x69, 0x8a,
	0x33, 0x24, 0x59, 0x5f, 0x35, 0xb8, 0x8c, 0x07, 0x9c, 0x63, 0x43, 0xd3, 0x14, 0xa6, 0x4b, 0xea,
	0xb0, 0x8a, 0xdc, 0x8e, 0x27, 0xf3, 0x1e, 0x7d, 0x62, 0x7b, 0x1e, 0x5a, 0x33, 0xf3, 0x9f, 0x10,
	0x0c, 0x34, 0x11, 0x82, 0x47, 0x20, 0x42, 0x35, 0x10, 0x6b, 0x16, 0xcc, 0xcd, 0xd0, 0xa0, 0x76,
	0x76, 0x5b, 0x08, 0xd3, 0xda, 0x75, 0x6a, 0xd2, 0x97, 0x20, 0xa4, 0x6a, 0x25, 0xba, 0x72, 0x29,
	0x51, 0x84, 0x12, 0x85, 0x8c, 0xc0, 0x2e, 0x12, 0x58, 0x31, 0x5e, 0x85, 0x6e, 0x26, 0xa8, 0x24,
	0x9b, 0x8e, 0xa9, 0xda, 0xa3, 0x1b, 0x29, 0x0c, 0xbb, 0x4a, 0x82, 0xef, 0x8c, 0x25, 0x28, 0xe3,
	0x92, 0x6c, 0x72, 0xbb, 0x34, 0x33, 0xff, 0xb5, 0x1d, 0x2e, 0xd7, 0x0d, 0xe3, 0x12, 0x51, 0x94,
	0x15, 0x53, 0x56, 0x34, 0xf5, 0xce, 0xfc, 0xe4, 0x24, 0x53, 0xfc, 0x16, 0x84, 0x2b, 0x26, 0x31,
	0x3c, 0x7a, 0x67, 0xfe, 0xae, 0x8a, 0x42, 0xff, 0xe1, 0x35, 0xea, 0xd8, 0x96, 0x4c, 0x32, 0x3b,
	0xcd, 0x1a, 0x30, 0x82, 0x23, 0x5f, 0x22, 0xfe, 0xed, 0xc7, 0x08, 0x09, 0x2e, 0x0f, 0xfe, 0x04,
	0xc2, 0xba, 0x64, 0x9a, 0x4f, 0x35, 0xa3, 0xc4, 0xba, 0x14, 0xcd, 0x0f, 0x36, 0x8c, 0xfe, 0x26,
	0x29, 0x1a, 0x84, 0x19, 0x4c, 0x81, 0x5a, 0x3c, 0x12, 0x5c, 0x06, 0xfc, 0x19, 0xc4, 0x4d, 0x52,
	0xac, 0x18, 0x44, 0xe4, 0xd6, 0xc9, 0x57, 0x65, 0x6f, 0x83, 0x88, 0xe5, 0x3d, 0xdd, 0x3a, 0xa0,
	0x0b, 0xcf, 0xa6, 0xe6, 0xcb, 0x13, 0x3f, 0x84, 0xb8, 0x65, 0x54, 0x4c, 0x8b, 0x94, 0xc4, 0xa2,
	0x24, 0x56, 0x0c, 0x25, 0xd5, 0xce, 0x7a, 0xf0, 0xd1, 0x9b, 0x2a, 0x42, 0xc7, 0x7b, 0xd1, 0x61,
	0x84, 0x46, 0xbe, 0xfc, 0x32, 0x5c, 0xeb, 0xc6, 0xbd, 0x36, 0xa1, 0x8b, 0x0b, 0x58, 0x94, 0x1e,
	0x19, 0x0a, 0x9e, 0x82, 0x84, 0xa4, 0xcb, 0xa2, 0x49, 0x8c, 0x7d, 0x62, 0xd8, 0x73, 0xd9, 0xd9,
	0x30, 0x4d, 0xf7, 0x90, 0x10, 0x93, 0x74, 0x79, 0x93, 0x91, 0xb0, 0x09, 0xbd, 0x05, 0x7d, 0x1e,
	0x26, 0x59, 0x17, 0xa5, 0x52, 0xc9, 0x20, 0xa6, 0x99, 0x0a, 0xd7, 0xb1, 0x3e, 0xa3, 0xac, 0xd8,
	0x65, 0x5d, 0xd1, 0x17, 0x6c, 0x32, 0x3c, 0x53, 0xd7, 0xa8, 0xae, 0x19, 0x56, 0x2a, 0x92, 0x46,
	0x23, 0xb1, 0x42, 0x8c, 0x72, 0x86, 0x47, 0x3b, 0x52, 0x7f, 0xff, 0xf7, 0xc1, 0x11, 0x6f, 0xb3,
	0x1b, 0x9a, 0x61, 0xe1, 0x59, 0xe8, 0x96, 0xcd, 0xa2, 0x29, 0x8b, 0x52, 0xb1, 0x48, 0x4c, 0x53,
	0xfc, 0x42, 0x53, 0x49, 0x0a, 0x58, 0x93, 0xc0, 0xbb, 0x98, 0xfa, 0x12, 0x09, 0x09, 0x46, 0xb4,
	0xc0, 0x68, 0x3e, 0xd7, 0x54, 0x82, 0xc7, 0x21, 0xb6, 0xaf, 0x29, 0x95, 0x3d, 0x22, 0xea, 0x06,
	0xd9, 0x91, 0x9f, 0xa5, 0xa2, 0x75, 0x6a, 0xa6, 0x6e, 0x0b, 0x5d, 0x76, 0xfd, 0x06, 0xab, 0xc6,
	0xa3, 0x10, 0xa1, 0x43, 0x28, 0xea, 0x92, 0xb5, 0x9b, 0xea, 0x62, 0xb4, 0xb6, 0x62, 0x46, 0x47,
	0xea, 0xcb, 0xc0, 0x1f, 0x07, 0x90, 0x10, 0xa6, 0xf5, 0x1b, 0x92, 0xb5, 0x5b, 0xb8, 0x0c, 0x5d,
	0xbb, 0x96, 0xa5, 0x9b, 0x62, 0x71, 0x57, 0x93, 0x8b, 0x04, 0x27, 0xb8, 0x97, 0x0b, 0x1e, 0x55,
	0x51, 0x70, 0x3a, 0x3b, 0x53, 0xb8, 0x02, 0x71, 0x3e, 0x3a, 0x5e, 0x92, 0xce, 0xc3, 0x2a, 0xea,
	0xa0, 0x24, 0x73, 0xd9, 0xf9, 0xd5, 0x50, 0x38, 0x98, 0x0c, 0xad, 0x86, 0xc2, 0x1d, 0xc9, 0xce,
	0xcc, 0xff, 0x0c, 0xc2, 0x77, 0xea, 0x0c, 0xf8, 0xde, 0xc6, 0xf2, 0xba, 0xbc, 0xb7, 0x5d, 0x31,
	0x79, 0xe9, 0xc2, 0xce, 0xb4, 0x6d, 0xc6, 0x37, 0xa0, 0xc7, 0xb4, 0x8b, 0xea, 0x66, 0x0f, 0x35,
	0x2e, 0xb2, 0x6e, 0x4e, 0xe5, 0x99, 0xbf, 0x25, 0x18, 0x6c, 0x60, 0xf5, 0xcc, 0x61, 0xa0, 0x61,
	0x0e, 0x85, 0xfe, 0x3a, 0x01, 0x2d, 0x67, 0x31, 0x78, 0x8a, 0x59, 0xf4, 0x2e, 0xbf, 0xd0, 0x07,
	0x2e, 0xbf, 0xf6, 0xb3, 0x2e, 0xbf, 0x09, 0x88, 0xea, 0xc4, 0xd8, 0x11, 0x75, 0x4d, 0x91, 0x8b,
	0x07, 0xa9, 0x0e, 0xd6, 0x7e, 0xfc, 0xef, 0xaa, 0xa8, 0xcd, 0x63, 0x40, 0x40, 0x49, 0x36, 0x18,
	0x05, 0xbe, 0x0a, 0xa0, 0xc8, 0x7b, 0xb2, 0x25, 0xca, 0x9a, 0x6e, 0xb2, 0xa5, 0x11, 0x2b, 0x84,
	0x28, 0xbd, 0x10, 0x61, 0xe5, 0x2b, 0x9a, 0x6e, 0xd6, 0x88, 0xf6, 0xb6, 0x75, 0x7b, 0x11, 0xd4,
	0x13, 0x3d, 0xd8, 0xd6, 0xcd, 0xcc, 0x1f, 0x07, 0x60, 0xa2, 0x6e, 0x66, 0x37, 0x2a, 0x06, 0xd9,
	0xac, 0x0d, 0x2d, 0xf5, 0xf9, 0x46, 0x71, 0x97, 0x98, 0x96, 0x21, 0x59, 0x1a, 0xdb, 0xd7, 0xf1,
	0x6f, 0x01, 0x14, 0x15, 0xba, 0x5a, 0x0d, 0x51, 0x2e, 0xf1, 0xa9, 0x4d, 0xf3, 0x85, 0x9d, 0x44,
	0xa9, 0x7e, 0xfa, 0x35, 0x69, 0xc4, 0xf3, 0x5d, 0x3f, 0xfc, 0xbe, 0x34, 0xf6, 0xc5, 0xe4, 0xd8,
	0x0d, 0xf1, 0x1f, 0x8d, 0x5e, 0x13, 0x22, 0x9c, 0x67, 0xa5, 0x84, 0x6f, 0xc3, 0x00, 0x51, 0xa5,
	0x6d, 0x85, 0x88, 0xce, 0x84, 0x5b, 0x9a, 0xae, 0x29, 0x5a, 0xf9, 0x80, 0xcd, 0x73, 0xb8, 0x10,
	0xe6, 0x8e, 0xa3, 0x4d, 0xe8, 0xb3, 0x09, 0xb9, 0x46, 0x5b, 0x9c, 0x0c, 0xdf, 0x82, 0x7e, 0x57,
	0x82, 0x21, 0x17, 0xad, 0x9a, 0x80, 0x60, 0x83, 0x80, 0x5e, 0x47, 0x00, 0x25, 0x73, 0xf9, 0x0b,
	0xd0, 0x21, 0x19, 0x86, 0x74, 0x60, 0x72, 0x47, 0x37, 0xea, 0xbb, 0x53, 0x6d, 0x98, 0xda, 0x02,
	0xa5, 0xaa, 0x0b, 0x24, 0x04, 0xce, 0x99, 0xf9, 0xcf, 0x08, 0xfa, 0x7c, 0x29, 0xf0, 0x2a, 0x44,
	0x77, 0x14, 0xc9, 0xdc, 0x15, 0x19, 0x25, 0x1b, 0xa1, 0x68, 0xfe, 0xaa, 0x6f, 0x13, 0x77, 0x28,
	0x1d, 0x13, 0xe1, 0xb1, 0x0c, 0xd8, 0x71, 0x4b, 0x6b, 0xb2, 0xb6, 0x15, 0x89, 0xef, 0x56, 0x2d,
	0x65, 0x15, 0x28, 0xd9, 0x31, 0x59, 0xac, 0x34, 0xf3, 0xb7, 0x08, 0xe2, 0xf5, 0x44, 0xf8, 0x36,
	0x0c, 0x3a, 0x03, 0xa9, 0x4a, 0xba, 0xb9, 0xab, 0x59, 0x62, 0x49, 0x36, 0x48, 0xd1, 0xd2, 0x0c,
	0x5b, 0xf1, 0x30, 0xb7, 0x19, 0x3e, 0x63, 0x9b, 0x9c, 0x6a, 0xc9, 0x21, 0xc2, 0x79, 0xe8, 0x22,
	0xcf, 0xe8, 0x3a, 0x13, 0x8d, 0x8a, 0x42, 0x9c, 0x95, 0x9a, 0x70, 0xac, 0xd7, 0xb6, 0x89, 0xbc,
	0x10, 0xb5, 0x89, 0x04, 0x4a, 0x83, 0x7f, 0x07, 0xba, 0x3c, 0x9d, 0x6a, 0x1d, 0xb5, 0xd4, 0x14,
	0x5e, 0x56, 0x4b, 0xba, 0x26, 0xab, 0x96, 0x67, 0x03, 0x0e, 0xfb, 0x6e, 0xc0, 0xd1, 0x5a, 0x9f,
	0xcd, 0xcc, 0xff, 0x68, 0x07, 0x7c, 0x5c, 0x06, 0x1e, 0x81, 0xce, 0xbd, 0xf2, 0x9e, 0x25, 0xca,
	0x3a, 0xd7, 0x38, 0xe6, 0x68, 0x1c, 0x32, 0x02, 0x3a, 0xdd, 0x92, 0x3a, 0x68, 0xfd, 0x8a, 0x8e,
	0x3f, 0x83, 0x18, 0xa3, 0x2c, 0xa9, 0xa6, 0xed, 0xcc, 0x82, 0x8c, 0x7e, 0xa0, 0x6e, 0x7d, 0x06,
	0x6a, 0x1b, 0x53, 0x9b, 0x10, 0xa5, 0xf4, 0x4b, 0xaa, 0xc9, 0xdc, 0xda, 0xa7, 0x10, 0xa1, 0x0e,
	0xc9, 0xd2, 0x9e, 0x10, 0x95, 0x5b, 0xdb, 0xc9, 0xae, 0x41, 0xd2, 0xe5, 0x2d, 0xca, 0x80, 0xe7,
	0x20, 0xa1, 0xee, 0x98, 0x22, 0xe1, 0x6a, 0x53, 0x75, 0x3b, 0xfc, 0xd4, 0x45, 0x42, 0x4c, 0xdd,
	0x31, 0x9d, 0xde, 0xad, 0xe8, 0x78, 0x0d, 0xfa, 0xea, 0x18, 0x5d, 0xed, 0x3b, 0x5b, 0x6b, 0x8f,
	0x04, 0xec, 0x11, 0xe4, 0x74, 0xe2, 0x77, 0x03, 0xd0, 0xa1, 0xd0, 0xf9, 0xa7, 0x8e, 0x84, 0xce,
	0xd5, 0xd4, 0x29, 0xe7, 0x6a, 0x7c, 0x8d, 0x71, 0x2d, 0xab, 0x96, 0x71, 0x50, 0xf8, 0x13, 0x36,
	0x49, 0x5d, 0x7f, 0x80, 0x22, 0x99, 0x4e, 0xa3, 0x3d, 0x89, 0x52, 0xdc, 0x99, 0xfe, 0x01, 0x0a,
	0x24, 0x7b, 0x9d, 0xaa, 0x51, 0xa7, 0xea, 0xe8, 0x2f, 0xff, 0x2c, 0xd8, 0xf3, 0xf2, 0x35, 0x4a,
	0xe0, 0xd8, 0xd7, 0x55, 0x14, 0x59, 0x93, 0xb6, 0x89, 0x92, 0x7e, 0x42, 0x0e, 0x3c, 0xe5, 0x47,
	0x6e, 0xf9, 0x7d, 0xbb, 0x1c, 0x5e, 0xbe, 0x46, 0x1d, 0x38, 0xf4, 0xb3, 0x2a, 0x6a, 0xa3, 0x3f,
	0x76, 0xbc, 0x7c, 0x4d, 0x4d, 0x83, 0x7e, 0xed, 0x7b, 0xf9, 0x1a, 0x75, 0x0f, 0x25, 0xbe, 0xae,
	0xa2, 0xa8, 0xcd, 0xb1, 0x2f, 0x29, 0x15, 0xe2, 0xa9, 0x39, 0x72, 0x6b, 0x1e, 0x3b, 0x35, 0x4c,
	0xda, 0x10, 0x93, 0x26, 0xf0, 0xee, 0x0f, 0xdd, 0x80, 0xa8, 0xa7, 0x4b, 0x38, 0x09, 0xc1, 0x27,
	0xe4, 0x80, 0x63, 0x25, 0xfa, 0x15, 0xf7, 0x42, 0x3b, 0x13, 0x6d, 0x9b, 0x95, 0x60, 0xff, 0x70,
	0x33, 0x30, 0x8f, 0x0a, 0x69, 0x6e, 0x48, 0xce, 0x9c, 0xb0, 0x3d, 0x37, 0x40, 0x27, 0x9c, 0xee,
	0xb9, 0xf9, 0xec, 0x14, 0xdd, 0xb7, 0xbd, 0x93, 0xc6, 0x08, 0x3a, 0x38, 0x3a, 0x09, 0xce, 0x66,
	0xe7, 0x56, 0x43, 0x61, 0x94, 0x0c, 0x70, 0x7c, 0xf2, 0xaf, 0x43, 0x7c, 0x35, 0xbb, 0xee, 0x03,
	0xdf, 0x84, 0xb0, 0x29, 0xa9, 0x0c, 0x42, 0x73, 0xbf, 0x7c, 0xf9, 0xab, 0x2a, 0x6a, 0x5f, 0xd9,
	0x5c, 0xdc, 0x5c, 0x71, 0x26, 0x3c, 0x66, 0x44, 0x05, 0xbb, 0x44, 0x08, 0xdc, 0x59, 0x14, 0x3a,
	0x4d, 0x49, 0x65, 0xbc, 0xcb, 0x14, 0x1c, 0xed, 0x48, 0x15, 0xc5, 0x12, 0x77, 0x4c, 0x5b, 0x84,
	0xbd, 0x30, 0x2e, 0x7d, 0x55, 0x45, 0xc1, 0x67, 0x3b, 0xa6, 0x57, 0x00, 0xfd, 0x59, 0x08, 0x91,
	0x67, 0xd6, 0xb4, 0x10, 0xe3, 0x5c, 0x77, 0x4c, 0x26, 0x66, 0x16, 0xe2, 0x1e, 0x31, 0x9a, 0x6e,
	0xf1, 0xe5, 0x92, 0x74, 0xd8, 0x9d, 0xe9, 0x15, 0xba, 0x5c, 0xc6, 0x87, 0xba, 0x85, 0xef, 0x00,
	0x76, 0xf8, 0xf6, 0xb4, 0x8a, 0x6a, 0x51, 0x56, 0xea, 0x9d, 0x69, 0xc0, 0x9d, 0x72, 0x8d, 0x95,
	0xae, 0xf9, 0x90, 0x67, 0xa5, 0x27, 0x39, 0xcf, 0x03, 0xca, 0xf2, 0x50, 0xb7, 0x4c, 0xbc, 0x04,
	0x17, 0x4a, 0xb2, 0xc9, 0x3c, 0x9a, 0x6e, 0x10, 0xb2, 0xa7, 0x5b, 0xa2, 0x64, 0x59, 0x52, 0x71,
	0x77, 0x8f, 0xa8, 0x96, 0xc9, 0xf6, 0x66, 0xc7, 0xa5, 0x0d, 0x72, 0xc2, 0x0d, 0x9b, 0x6e, 0xa1,
	0x46, 0x86, 0x1f, 0x40, 0x8f, 0x1d, 0xd4, 0x29, 0x5a, 0x59, 0x56, 0x45, 0x4b, 0xde, 0x23, 0x5a,
	0xc5, 0x62, 0x4b, 0xaf, 0x9d, 0x0d, 0x48, 0x20, 0x3f, 0x79, 0x54, 0x45, 0x21, 0x08, 0xe4, 0x27,
	0x5d, 0x4f, 0x37, 0x1a, 0x4a, 0x95, 0x46, 0x90, 0x60, 0x87, 0x83, 0x6b, 0x94, 0x71, 0xcb, 0xe6,
	0xab, 0xf9, 0x3b, 0xbe, 0xe9, 0x74, 0x9e, 0xe4, 0xef, 0xd8, 0x94, 0x9e, 0xd1, 0xdf, 0x2d, 0xd8,
	0xdb, 0xd2, 0x1f, 0x85, 0xb8, 0xbf, 0xab, 0x93, 0xf1, 0x9b, 0xe2, 0xef, 0xb8, 0xa3, 0x21, 0x0a,
	0x9d, 0xaa, 0x13, 0x1c, 0x4d, 0x5d, 0x07, 0xc7, 0xd9, 0xda, 0xfd, 0x96, 0x38, 0x1a, 0xa2, 0x38,
	0x8e, 0xc6, 0xe9, 0xd2, 0x37, 0xeb, 0x68, 0x6c, 0x3f, 0x92, 0xf9, 0x93, 0x00, 0x0c, 0xd7, 0x05,
	0x7f, 0xeb, 0xc4, 0x92, 0x74, 0x7d, 0xcb, 0x90, 0x4b, 0x44, 0x75, 0x4e, 0x3a, 0x52, 0x2a, 0x2b,
	0x14, 0xb7, 0xa5, 0xe2, 0x13, 0xa2, 0x96, 0x44, 0x4d, 0xb5, 0x24, 0x5d, 0x54, 0x25, 0x93, 0xc7,
	0x22, 0x9f, 0xf8, 0x4e, 0x90, 0x8f, 0xd8, 0x82, 0x2d, 0xe0, 0x21, 0xe5, 0x5f, 0x97, 0x4c, 0x7e,
	0x86, 0xd3, 0xa7, 0xfa, 0x55, 0x36, 0x6d, 0xd7, 0x94, 0x54, 0x66, 0x8f, 0xef, 0xd9, 0xee, 0xa6,
	0xed, 0xec, 0xfc, 0xdb, 0xdd, 0x94, 0x54, 0x0a, 0x8c, 0x9c, 0x06, 0x3d, 0xc0, 0xc8, 0x67, 0xec,
	0xfe, 0x55, 0x02, 0xbe, 0x7b, 0xba, 0xc6, 0xf0, 0x3f, 0xa9, 0x61, 0xa2, 0x92, 0x21, 0x37, 0x60,
	0xa2, 0xfb, 0x5f, 0x55, 0x51, 0x84, 0xf5, 0x6d, 0xcc, 0x94, 0x54, 0x67, 0x8d, 0xcd, 0x18, 0x53,
	0x42, 0xad, 0x54, 0xe8, 0x76, 0xbf, 0x8e, 0x91, 0xa2, 0xa6, 0x6a, 0x7b, 0x07, 0x42, 0x8f, 0x5d,
	0xa4, 0x4a, 0xe6, 0xd8, 0x8e, 0x42, 0x9e, 0x95, 0x0d, 0xad, 0xa2, 0xbb, 0xa8, 0x6a, 0x89, 0x35,
	0xb3, 0x6e, 0x03, 0x93, 0xee, 0x3d, 0x49, 0x95, 0xca, 0x84, 0x3a, 0x36, 0x51, 0x91, 0x77, 0xa8,
	0x07, 0x08, 0xf9, 0x7b, 0x80, 0x44, 0x8d, 0x72, 0x4d, 0xde, 0x59, 0xd1, 0xf1, 0x06, 0x0c, 0x34,
	0x30, 0xbb, 0x4e, 0xa1, 0xfd, 0x24, 0xa7, 0xd0, 0x5b, 0x27, 0xcc, 0xf1, 0x0e, 0x13, 0x10, 0x2d,
	0x49, 0x96, 0xe4, 0x28, 0xd2, 0xe9, 0x1f, 0xcb, 0x44, 0x28, 0x8d, 0xad, 0xc2, 0x12, 0x74, 0xbb,
	0x0c, 0x6e, 0xe3, 0xe1, 0x93, 0x62, 0x98, 0x38, 0x17, 0xe0, 0x34, 0x3b, 0x0c, 0x41, 0x73, 0x7f,
	0x8f, 0xe1, 0xf9, 0x48, 0xa1, 0xcb, 0xb3, 0x0d, 0x05, 0x04, 0x5a, 0x81, 0x47, 0x3c, 0xf0, 0x0f,
	0x7c, 0x88, 0xfc, 0x81, 0x5e, 0xf4, 0xec, 0x40, 0xaf, 0x53, 0xd5, 0xc4, 0xe2, 0xae, 0xa4, 0xa7,
	0x62, 0x2d, 0x0e, 0x58, 0x02, 0x42, 0x87, 0xaa, 0x2d, 0xee, 0x4a, 0x3a, 0x7e, 0xc4, 0xf4, 0xb2,
	0x39, 0xe2, 0x8c, 0x63, 0xbe, 0xc5, 0xd1, 0x9e, 0xaf, 0x09, 0x52, 0x39, 0xcc, 0xe6, 0x03, 0x42,
	0x67, 0xc5, 0x24, 0x4c, 0xec, 0x18, 0x44, 0x65, 0x66, 0x31, 0xf6, 0x70, 0x76, 0xfb, 0xf4, 0x18,
	0x6c, 0x02, 0x36, 0x7a, 0x37, 0x21, 0xee, 0x18, 0x30, 0x3f, 0xab, 0xc0, 0x8c, 0xa3, 0xc7, 0x41,
	0x59, 0xb5, 0x40, 0x7f, 0x43, 0x88, 0x71, 0x52, 0x7e, 0x6c, 0xb1, 0x0c, 0x7d, 0x36, 0x0a, 0x95,
	0xca, 0x65, 0x83, 0x94, 0x25, 0x8b, 0x88, 0x15, 0x53, 0x2a, 0x93, 0x54, 0x0f, 0x03, 0xa4, 0xdd,
	0x5e, 0x11, 0xa1, 0xd1, 0x40, 0xaa, 0x24, 0xf4, 0x30, 0xfa, 0x05, 0x87, 0xfc, 0x11, 0xa5, 0xc6,
	0xd3, 0xd0, 0x6d, 0x8b, 0xe1, 0x67, 0x26, 0xa6, 0xfc, 0x05, 0x49, 0xf5, 0xb2, 0xed, 0xb8, 0x86,
	0xf5, 0x12, 0x8c, 0xe4, 0x31, 0xa3, 0xd8, 0x94, 0xbf, 0x20, 0xf8, 0xfb, 0x90, 0xe0, 0xf4, 0x3c,
	0x4e, 0x30, 0x53, 0x7d, 0x6c, 0x14, 0x47, 0xfc, 0x4f, 0x26, 0xe9, 0x90, 0xd9, 0xec, 0x4b, 0x9c,
	0xde, 0x23, 0x3d, 0xbe, 0x5f, 0x57, 0x83, 0x7f, 0x5a, 0xdb, 0xaa, 0xfa, 0xd9, 0x56, 0x75, 0xf7,
	0x03, 0x3c, 0xd2, 0xb7, 0x6d, 0xfb, 0xc2, 0x17, 0xa1, 0xc3, 0x20, 0x65, 0x59, 0x53, 0x53, 0x03,
	0xcc, 0x56, 0xec, 0x90, 0x8b, 0x97, 0xe1, 0x7f, 0x0c, 0x9d, 0xdc, 0x4c, 0x52, 0x29, 0x36, 0x76,
	0x93, 0x2d, 0x26, 0x44, 0x36, 0xac, 0x8a, 0xa4, 0xf0, 0x71, 0x74, 0x8f, 0x8b, 0x9b, 0x1c, 0x5d,
	0x73, 0xb1, 0xf8, 0x33, 0xc0, 0x45, 0x45, 0xa6, 0x6e, 0xab, 0x48, 0x0c, 0x4b, 0xde, 0x91, 0x8b,
	0x92, 0x45, 0x52, 0x83, 0xee, 0xd1, 0x4a, 0xd0, 0x75, 0x1c, 0xb7, 0x85, 0x6e, 0x9b, 0x72, 0xb1,
	0x46, 0x88, 0x1f, 0xb8, 0xec, 0xba, 0x21, 0xef, 0x53, 0xab, 0xa5, 0xbb, 0xef, 0xd0, 0xe9, 0x16,
	0x7c, 0xd2, 0x66, 0xdd, 0xb0, 0x39, 0xef, 0x93, 0x03, 0xbc, 0x04, 0xfd, 0x9e, 0x13, 0x52, 0xaf,
	0x46, 0x17, 0x7c, 0x35, 0xea, 0x75, 0x8f, 0x43, 0x3d, 0x4a, 0x7d, 0x40, 0x48, 0x70, 0x53, 0x7b,
	0x5b, 0x45, 0x4f, 0xe0, 0x0e, 0x0c, 0xf1, 0x61, 0x4c, 0x73, 0x1b, 0x4c, 0x6f, 0x48, 0x86, 0xb4,
	0x47, 0x2c, 0x62, 0x98, 0x78, 0x24, 0x97, 0x9d, 0xca, 0xce, 0x66, 0x6f, 0x64, 0x73, 0x93, 0xd9,
	0x5c, 0x2e, 0x9b, 0xcb, 0x67, 0xf3, 0x33, 0xd9, 0xfc, 0x6c, 0x36, 0x3f, 0x97, 0xcd, 0xcd, 0x65,
	0x73, 0xf3, 0xd9, 0xdc, 0x8d, 0x6c, 0x7e, 0x32, 0x9b, 0xcf, 0xc1, 0x15, 0xe8, 0xe3, 0xb3, 0x92,
	0x76, 0xe4, 0xb1, 0xa3, 0x79, 0x1c, 0xce, 0xe7, 0xb3, 0xf9, 0xa9, 0x6c, 0x7e, 0x9a, 0x6e, 0xa4,
	0xf5, 0x5b, 0xc7, 0xf1, 0x43, 0xc8, 0x0b, 0x10, 0x76, 0x5c, 0xfb, 0xb1, 0xe3, 0xc7, 0x42, 0x1a,
	0xa2, 0xd4, 0xeb, 0x39, 0xbb, 0x30, 0xf5, 0x13, 0xb1, 0xc3, 0x2a, 0xea, 0x3a, 0xaa, 0xa2, 0xf6,
	0xdc, 0x54, 0x36, 0x37, 0xed, 0x3d, 0xa0, 0x5c, 0x0d, 0x85, 0xbb, 0x92, 0xb1, 0xcc, 0x5f, 0x07,
	0xe0, 0xea, 0x29, 0x3c, 0x21, 0xbe, 0x01, 0x31, 0x26, 0xbb, 0xe1, 0xc0, 0xbd, 0xd7, 0xeb, 0x8b,
	0x5c, 0x47, 0xd8, 0x45, 0x49, 0x1f, 0x39, 0xee, 0xff, 0x0e, 0xf4, 0x32, 0x56, 0x4b, 0x32, 0xca,
	0xc4, 0xaa, 0x49, 0x08, 0xb4, 0x90, 0x80, 0x29, 0xc7, 0x16, 0x63, 0x70, 0xe5, 0x7c, 0x1f, 0xfa,
	0x98, 0x1c, 0x59, 0x95, 0x2d, 0x59, 0xb2, 0x34, 0x43, 0x34, 0x99, 0x15, 0xf1, 0xe0, 0xa6, 0x85,
	0x89, 0x75, 0xd1, 0x36, 0x0e, 0x1d, 0xa7, 0xd4, 0x43, 0xa5, 0xac, 0x38, 0x42, 0x6c, 0x32, 0xbc,
	0x0b, 0x17, 0xbd, 0x4a, 0x1e, 0x6b, 0x23, 0x74, 0xb6, 0x36, 0x06, 0x6b, 0xfa, 0x37, 0xb4, 0x94,
	0xf9, 0x77, 0x27, 0x47, 0x41, 0x3c, 0xd4, 0x3b, 0x75, 0x14, 0xa4, 0x4a, 0xa6, 0x4f, 0x14, 0xa4,
	0x4a, 0xa6, 0x13, 0x05, 0xd1, 0x90, 0xe7, 0xac, 0x51, 0xd0, 0x2c, 0x74, 0x39, 0x61, 0x9d, 0x67,
	0xba, 0x7c, 0xf6, 0xaf, 0xbc, 0x10, 0xe5, 0x84, 0xe7, 0xd1, 0xd3, 0xaf, 0x5b, 0xf4, 0x34, 0x0b,
	0x58, 0xaa, 0x58, 0x9a, 0xc8, 0x8f, 0x1b, 0xf9, 0x69, 0x79, 0x57, 0xc3, 0x81, 0x6f, 0x92, 0xd2,
	0x2c, 0x33, 0x12, 0x7e, 0x5a, 0xfe, 0x08, 0xba, 0xbd, 0x7c, 0x45, 0xb9, 0x64, 0x98, 0x3c, 0xfe,
	0xfa, 0xd8, 0xf7, 0xd2, 0xd6, 0x0e, 0x5d, 0x36, 0x2d, 0x43, 0x56, 0xcb, 0xce, 0x25, 0xab, 0x90,
	0xa8, 0xc9, 0x5d, 0xa4, 0x12, 0xf0, 0xc4, 0xb1, 0xa8, 0x28, 0xce, 0xfa, 0x5e, 0x53, 0xa5, 0x21,
	0x14, 0xfa, 0xb4, 0x59, 0x28, 0x94, 0x68, 0xe0, 0x3b, 0x7d, 0x04, 0x94, 0x6c, 0xe0, 0x3c, 0x16,
	0x01, 0x4d, 0x43, 0xb7, 0xba, 0x63, 0xd6, 0x8e, 0x54, 0x64, 0x4d, 0x35, 0x79, 0xbc, 0xe7, 0xe1,
	0x52, 0x77, 0x4c, 0xe7, 0x04, 0x85, 0x12, 0xf8, 0xc5, 0x4d, 0xf8, 0xff, 0x45, 0xdc, 0xd4, 0xf3,
	0xfe, 0x71, 0x13, 0x77, 0x2b, 0xdf, 0xe2, 0xb8, 0xa9, 0xb7, 0x75, 0xdc, 0xd4, 0xf7, 0xab, 0x8c,
	0x9b, 0xfa, 0x3f, 0x2c, 0x6e, 0x1a, 0xf8, 0xe6, 0xe3, 0xa6, 0xd4, 0xaf, 0x26, 0x6e, 0x32, 0xde,
	0x56, 0x91, 0x0a, 0x2b, 0x2d, 0xe3, 0xa6, 0xeb, 0xc7, 0xe3, 0x26, 0x1e, 0x05, 0x65, 0x59, 0xa4,
	0x92, 0xcd, 0xcd, 0x64, 0x73, 0xb3, 0x76, 0x0c, 0xd5, 0x22, 0x74, 0x72, 0xa2, 0xab, 0x0f, 0x0d,
	0x9d, 0xea, 0x6e, 0x6e, 0x7f, 0xd2, 0x01, 0x3d, 0x3e, 0xcb, 0x13, 0x2f, 0x43, 0xcc, 0xd4, 0xa5,
	0x22, 0x11, 0x0d, 0xc2, 0xae, 0x4a, 0x9d, 0x6b, 0xbc, 0xaf, 0xaa, 0x28, 0xa4, 0x6a, 0x2a, 0x71,
	0x36, 0x87, 0x84, 0x11, 0x13, 0x58, 0x81, 0xd0, 0x6e, 0xed, 0xca, 0xc5, 0x27, 0x42, 0x17, 0x63,
	0x13, 0x6c, 0x2e, 0x3c, 0x06, 0x09, 0xf7, 0xde, 0x88, 0xfb, 0xe3, 0x80, 0xc7, 0x6c, 0xe3, 0x4e,
	0x25, 0xf7, 0xc4, 0x13, 0x90, 0x74, 0xc9, 0x9d, 0x86, 0x83, 0x1e, 0x7a, 0x57, 0x98, 0x23, 0x7f,
	0x14, 0xe2, 0xa6, 0xae, 0xc8, 0x96, 0xa8, 0xa9, 0x62, 0x51, 0xd1, 0x54, 0xfb, 0x72, 0xd6, 0x39,
	0xc0, 0xed, 0x62, 0x75, 0x0f, 0xd5, 0x45, 0x5a, 0x83, 0xaf, 0x01, 0x10, 0xb5, 0x68, 0x1c, 0x30,
	0x1f, 0x56, 0x77, 0xd0, 0xeb, 0x29, 0xc7, 0xf3, 0x90, 0xac, 0xa8, 0xf2, 0x33, 0x51, 0x27, 0xc6,
	0x9e, 0x6c, 0x9a, 0xcc, 0x1f, 0xda, 0xc7, 0xba, 0x74, 0xb5, 0xb7, 0x43, 0x70, 0x6e, 0x6e, 0xce,
	0xd6, 0x85, 0x92, 0x6d, 0xd4, 0xa8, 0xf0, 0x47, 0xd0, 0xe5, 0xbd, 0x23, 0x63, 0xbb, 0xaf, 0xd3,
	0x42, 0xd4, 0xac, 0xdd, 0x8b, 0xe1, 0x8f, 0x21, 0x56, 0xbf, 0x45, 0x85, 0x3d, 0x5d, 0xe4, 0x97,
	0x65, 0x7c, 0x40, 0x66, 0x78, 0xe2, 0x85, 0x6c, 0x1d, 0x88, 0xa6, 0x75, 0xa0, 0x10, 0xbe, 0xc9,
	0xc6, 0x8f, 0xaa, 0xa8, 0x03, 0x42, 0x54, 0x05, 0xbe, 0x93, 0x70, 0xaa, 0x4d, 0x4a, 0x84, 0xaf,
	0x43, 0xdc, 0x92, 0x09, 0xdd, 0x9e, 0x9c, 0x26, 0xc0, 0xd3, 0x44, 0x8c, 0xd7, 0xf1, 0x36, 0xc6,
	0xa0, 0x43, 0xd5, 0xc4, 0x1f, 0x69, 0x26, 0xdb, 0x2a, 0x9b, 0x27, 0x75, 0xb4, 0xab, 0xda, 0x6f,
	0x6b, 0x26, 0x1e, 0x03, 0xf8, 0x91, 0x66, 0x3a, 0x72, 0x63, 0xc7, 0xb6, 0x73, 0x1a, 0x9d, 0x44,
	0x7e, 0xa4, 0x99, 0x5c, 0xfa, 0x2d, 0xe8, 0x91, 0x4a, 0x92, 0x6e, 0xc9, 0xfb, 0x44, 0xf4, 0xf0,
	0xc5, 0x7d, 0xf9, 0xba, 0x1d, 0xd2, 0xdf, 0x76, 0xf8, 0x6f, 0xde, 0x7a, 0x5b, 0x45, 0x37, 0x61,
	0x1e, 0x2e, 0x39, 0x0b, 0xeb, 0xe1, 0xfa, 0xd6, 0xc2, 0x46, 0xda, 0x36, 0xd7, 0xb4, 0x6b, 0xaf,
	0x03, 0xb9, 0x6c, 0x3e, 0x3b, 0x95, 0x9d, 0xce, 0xce, 0x64, 0x67, 0xb3, 0x73, 0xd9, 0x79, 0x67,
	0xb5, 0x15, 0xc6, 0xa0, 0xbb, 0xd6, 0xac, 0x83, 0x16, 0x52, 0x6f, 0xaa, 0xa8, 0xeb, 0x67, 0x76,
	0x0c, 0x1b, 0x3d, 0xaa, 0xa2, 0x70, 0x2e, 0x9f, 0x75, 0x40, 0x43, 0x34, 0xd9, 0x95, 0xf9, 0x8b,
	0x20, 0x5c, 0x68, 0xe1, 0x23, 0xf1, 0x8f, 0x6b, 0x5b, 0x94, 0x9d, 0xc9, 0xf4, 0xe9, 0x59, 0xdd,
	0xec, 0xb7, 0x6e, 0x5f, 0xc2, 0x10, 0x62, 0x99, 0x2d, 0xb6, 0x87, 0x64, 0xdf, 0xfd, 0xc2, 0x84,
	0xe0, 0x37, 0x15, 0x26, 0x7c, 0x80, 0xd3, 0xce, 0xfc, 0x9f, 0x4e, 0x9e, 0xb9, 0x57, 0x17, 0x43,
	0xb0, 0x99, 0x9d, 0xac, 0x05, 0x6d, 0x3c, 0xff, 0x10, 0x35, 0xa6, 0xdd, 0x38, 0x51, 0x9b, 0xcd,
	0x85, 0x7f, 0x1a, 0x84, 0x8b, 0x52, 0x69, 0x5f, 0x52, 0x8b, 0xa4, 0x24, 0xba, 0x5f, 0x74, 0xd7,
	0xfd, 0xf3, 0x7b, 0x8a, 0xfb, 0x4d, 0xee, 0x29, 0xfc, 0xb4, 0x18, 0x5f, 0xe0, 0x62, 0x9c, 0xff,
	0x6b, 0x9b, 0x89, 0x6d, 0x30, 0xff, 0x22, 0xf0, 0x86, 0xe7, 0xc2, 0xf9, 0x1b, 0xcd, 0x6d, 0x5f,
	0xa3, 0x99, 0x78, 0xf9, 0x1a, 0x5d, 0xc7, 0x1f, 0x7f, 0x5d, 0x45, 0x4e, 0xb2, 0x4e, 0xba, 0xa8,
	0x48, 0xa6, 0x99, 0x36, 0x75, 0x52, 0xa4, 0x7b, 0x61, 0xda, 0xd5, 0x3a, 0x4d, 0xa3, 0x71, 0xca,
	0x93, 0x7a, 0xf9, 0x1a, 0xf5, 0x62, 0x7c, 0x54, 0x45, 0x71, 0x57, 0x89, 0xf4, 0x3a, 0xaf, 0x6c,
	0x6e, 0x55, 0xb7, 0x5e, 0xbe, 0x46, 0x37, 0x87, 0xe6, 0xbf, 0xae, 0xa2, 0xe9, 0x13, 0x9b, 0x62,
	0xf3, 0x92, 0xde, 0xd1, 0x8c, 0x74, 0x59, 0xde, 0x27, 0xaa, 0x63, 0xca, 0x83, 0x2f, 0x5f, 0xa3,
	0xbe, 0xa1, 0x9e, 0xa3, 0x2a, 0x4a, 0xd4, 0x5a, 0xf6, 0x35, 0xc1, 0x21, 0xa9, 0xe9, 0x70, 0xe1,
	0x1f, 0xb0, 0x7c, 0x52, 0x49, 0xd7, 0x45, 0xcb, 0xbe, 0xb5, 0x60, 0xce, 0xbc, 0xd9, 0xb5, 0x51,
	0xeb, 0xcb, 0x0e, 0x9e, 0x51, 0x5a, 0x2b, 0xc4, 0x2f, 0x10, 0x0c, 0xea, 0x15, 0xc3, 0x4e, 0x48,
	0x92, 0x8b, 0x44, 0xd4, 0x3c, 0xb9, 0x30, 0x6c, 0x03, 0x88, 0xe6, 0x97, 0x4e, 0x6e, 0xe9, 0xe4,
	0x9c, 0x9a, 0x7b, 0x6d, 0xc2, 0x00, 0x6d, 0xc8, 0xa7, 0x1a, 0xef, 0x02, 0xd6, 0xec, 0x6c, 0x47,
	0x91, 0xb8, 0x79, 0x97, 0x6c, 0x4f, 0x89, 0xe6, 0xe7, 0x4e, 0x6e, 0xdc, 0x37, 0x65, 0x93, 0xfa,
	0x62, 0xad, 0xb1, 0x62, 0xe8, 0x01, 0x5c, 0x3e, 0xc1, 0x32, 0xcf, 0x14, 0x3b, 0xfd, 0xd6, 0xdb,
	0x2a, 0xfa, 0x04, 0xd2, 0x30, 0xe8, 0x98, 0x08, 0xcf, 0xcb, 0xf5, 0x4c, 0x5f, 0x30, 0x97, 0xcd,
	0xc3, 0x00, 0x60, 0x9e, 0xa4, 0xec, 0xad, 0x42, 0x33, 0x85, 0x0c, 0xc4, 0x78, 0xbe, 0xae, 0xe7,
	0x14, 0x28, 0x7c, 0x58, 0x45, 0x01, 0xba, 0x55, 0xcf, 0x67, 0xed, 0x1b, 0x71, 0x3b, 0x63, 0xd7,
	0x0e, 0x79, 0x42, 0xc9, 0xf6, 0xcc, 0xbf, 0x44, 0x30, 0x74, 0x7c, 0xdd, 0xb9, 0xc9, 0xb2, 0x2a,
	0x24, 0xea, 0x3d, 0x80, 0xe3, 0xe3, 0xaf, 0x9f, 0x61, 0x05, 0x37, 0x24, 0xab, 0x7a, 0xaf, 0xa4,
	0xe3, 0x75, 0xee, 0xc3, 0xcc, 0xfc, 0x79, 0xed, 0x92, 0x6d, 0x91, 0x2e, 0x11, 0x9f, 0xdc, 0xcf,
	0x29, 0x48, 0x48, 0x5f, 0xb8, 0x36, 0xe6, 0x39, 0xa0, 0x88, 0x78, 0x8f, 0x04, 0x62, 0xd2, 0x17,
	0xdc, 0x3c, 0xdc, 0x74, 0xc7, 0x1a, 0x93, 0x27, 0x55, 0x2e, 0xd8, 0x98, 0xee, 0xd8, 0x26, 0x60,
	0x97, 0xb5, 0x96, 0x28, 0xe7, 0x9b, 0xb7, 0x18, 0x3a, 0x39, 0x6f, 0xb1, 0x2e, 0x0f, 0xb1, 0xbd,
	0x65, 0x1e, 0x22, 0xce, 0x02, 0x36, 0x34, 0xcd, 0x12, 0x39, 0x24, 0xb0, 0x53, 0x88, 0xd8, 0x0a,
	0x0d, 0x0b, 0x49, 0x5a, 0xb3, 0xc8, 0x2a, 0x96, 0x59, 0xb9, 0x6f, 0xd6, 0xa2, 0xcf, 0xcd, 0xdb,
	0xbf, 0x47, 0x70, 0xcd, 0x3b, 0xa0, 0x4d, 0x73, 0x11, 0x1b, 0xd2, 0xea, 0xd0, 0x19, 0xd3, 0xea,
	0x02, 0xa7, 0x49, 0xab, 0x0b, 0xfa, 0xa7, 0xd5, 0xbd, 0x40, 0x70, 0xc5, 0xab, 0xa3, 0x7f, 0xde,
	0xf4, 0x0c, 0x84, 0xd9, 0x5b, 0x83, 0xa2, 0xa6, 0x70, 0xed, 0x06, 0x59, 0xfc, 0xbd, 0xbf, 0xb7,
	0xe3, 0x68, 0x19, 0x36, 0x3a, 0x04, 0x56, 0x20, 0xb8, 0xa4, 0xf8, 0xbb, 0x10, 0x35, 0x88, 0xae,
	0x50, 0x6c, 0x43, 0x23, 0xdd, 0x00, 0x8b, 0x5e, 0x79, 0x1c, 0xea, 0xa9, 0xc8, 0xfc, 0x35, 0x82,
	0x4b, 0x5e, 0x25, 0x8e, 0xdf, 0xee, 0xfe, 0x00, 0xc2, 0x26, 0x51, 0x58, 0x22, 0x17, 0x5f, 0x04,
	0xb7, 0x5b, 0x39, 0x14, 0x7f, 0x29, 0xe3, 0x9b, 0x5c, 0x04, 0xf3, 0x10, 0x82, 0x2b, 0x11, 0x4f,
	0x41, 0xcc, 0x3d, 0x20, 0x61, 0x59, 0xe1, 0x01, 0x77, 0x06, 0x90, 0x3b, 0x03, 0x21, 0xa1, 0xcb,
	0xac, 0x85, 0x4e, 0xe6, 0xd0, 0x27, 0x10, 0xab, 0x93, 0x77, 0xa6, 0x8d, 0xff, 0x2f, 0x10, 0x7c,
	0xe4, 0xd5, 0x75, 0xc3, 0xdf, 0xa5, 0xb2, 0xbe, 0x7f, 0x02, 0x9d, 0xfc, 0xa4, 0x8f, 0x8f, 0xfd,
	0x95, 0xaf, 0xaa, 0xa8, 0x7d, 0x5b, 0xd1, 0x8a, 0x4f, 0xbc, 0xe0, 0xc7, 0x2e, 0x11, 0x42, 0x3b,
	0xb2, 0x42, 0x04, 0x87, 0x03, 0x7f, 0x0a, 0x40, 0x6d, 0x44, 0x64, 0x33, 0xce, 0x2d, 0xe5, 0xd2,
	0x57, 0x55, 0x84, 0x26, 0x29, 0x5f, 0xcf, 0x68, 0x77, 0x21, 0x31, 0x99, 0xcd, 0x4d, 0x4e, 0x8e,
	0xe5, 0x26, 0xf9, 0x3f, 0x21, 0x42, 0x19, 0xd6, 0x28, 0x3d, 0x9e, 0x85, 0xc4, 0xb6, 0xa4, 0x96,
	0x9e, 0xca, 0x25, 0x6b, 0x97, 0x8b, 0x08, 0x1e, 0x3b, 0xca, 0x4b, 0x75, 0x09, 0x71, 0x97, 0x8a,
	0xf1, 0x65, 0x7e, 0x0a, 0xd0, 0xe7, 0xf5, 0x47, 0xac, 0x8f, 0x4e, 0xd6, 0x8d, 0x6f, 0x58, 0xe3,
	0x4d, 0xc3, 0x63, 0xf9, 0xef, 0x0d, 0xc1, 0xcd, 0x24, 0x44, 0x4b, 0xc4, 0x2c, 0x1a, 0xb2, 0xee,
	0x9a, 0x52, 0xe3, 0x12, 0x09, 0x08, 0x5e, 0x12, 0x9c, 0x87, 0x3e, 0x27, 0x4f, 0xc7, 0x69, 0x91,
	0xed, 0xfc, 0x76, 0xe2, 0xa5, 0xd0, 0xc3, 0x2b, 0xbd, 0x1a, 0xe2, 0x9f, 0x04, 0xe1, 0x82, 0x1b,
	0x39, 0xb9, 0x26, 0x51, 0x8b, 0xa0, 0xec, 0x74, 0x98, 0x95, 0x13, 0xfd, 0xaf, 0xdb, 0x5f, 0x37,
	0x80, 0x72, 0xa2, 0xee, 0x86, 0xf8, 0xe9, 0x77, 0x03, 0xe7, 0xb1, 0x93, 0x1d, 0x3b, 0x0d, 0x4a,
	0xcd, 0x46, 0x0a, 0xcf, 0x03, 0xae, 0x9b, 0x41, 0xef, 0xe1, 0xb0, 0xb3, 0x03, 0xfc, 0x61, 0x00,
	0x09, 0x49, 0xd3, 0xbb, 0xfa, 0xed, 0xcb, 0x8b, 0xc6, 0xa0, 0x2b, 0xc2, 0xa2, 0x91, 0xfc, 0xd9,
	0x9d, 0xc7, 0xf1, 0x98, 0xeb, 0x8b, 0x56, 0x21, 0x17, 0xb0, 0x76, 0x3e, 0x3d, 0xb1, 0x9d, 0x16,
	0x0b, 0xbf, 0x55, 0xa8, 0x55, 0xf6, 0x0d, 0xb5, 0xec, 0x83, 0xea, 0xd9, 0x13, 0x1b, 0x3d, 0x7d,
	0xa4, 0x85, 0x97, 0x20, 0x6e, 0x90, 0xa2, 0x22, 0xc9, 0x7b, 0xde, 0x63, 0xec, 0x48, 0xe1, 0xd2,
	0x51, 0x15, 0x25, 0xa1, 0x63, 0x89, 0x28, 0xc4, 0x22, 0xd0, 0x21, 0x10, 0x4b, 0x92, 0x55, 0xc7,
	0x21, 0x24, 0x85, 0x18, 0x67, 0xe2, 0xfb, 0xd5, 0x4d, 0xe8, 0x97, 0x14, 0x45, 0x7b, 0xea, 0x1c,
	0x09, 0x93, 0x67, 0xba, 0xa4, 0x9a, 0x74, 0x21, 0xc7, 0x3c, 0x67, 0x13, 0xbd, 0x8c, 0xc6, 0xc6,
	0x5d, 0xcb, 0x0e, 0xc5, 0xd0, 0x1a, 0x0c, 0xb7, 0x5e, 0x44, 0x67, 0x0a, 0xf5, 0x56, 0xdf, 0x56,
	0xd1, 0x1d, 0xb8, 0x0e, 0x29, 0xc7, 0xa2, 0xd9, 0x80, 0x78, 0xc3, 0xb9, 0xc4, 0x7c, 0xd6, 0x81,
	0xf0, 0x0c, 0x8c, 0x37, 0x8b, 0xfa, 0xe6, 0x0a, 0xd7, 0x1a, 0xa3, 0xbe, 0x9e, 0x37, 0x55, 0x14,
	0x3d, 0xac, 0xa2, 0xd0, 0x51, 0x15, 0x75, 0xe6, 0x72, 0x0c, 0xfa, 0xdb, 0xb1, 0x9e, 0x9d, 0x09,
	0xc9, 0x8f, 0xba, 0x5e, 0x22, 0x18, 0x3c, 0xe6, 0x2d, 0xdc, 0xb0, 0x6f, 0xaf, 0x16, 0xf6, 0x31,
	0x6b, 0x77, 0xc3, 0xbe, 0xd1, 0xd3, 0xbb, 0x9d, 0x53, 0x44, 0x7d, 0x8b, 0xb6, 0xec, 0xcc, 0x0c,
	0x74, 0x15, 0x34, 0xb5, 0xb4, 0x26, 0x15, 0xed, 0x2b, 0xc7, 0xef, 0x40, 0xc8, 0x90, 0x2c, 0xdb,
	0x2d, 0xc7, 0x0a, 0xdd, 0x5f, 0x55, 0x51, 0x60, 0x6a, 0xd2, 0xc9, 0x1a, 0x1c, 0x1e, 0x41, 0x02,
	0xab, 0xce, 0xfc, 0x97, 0x10, 0x7f, 0xe1, 0x45, 0x99, 0x3d, 0xb0, 0xf5, 0x33, 0xef, 0x9b, 0xbc,
	0xc2, 0xc7, 0x47, 0x55, 0x74, 0x11, 0xda, 0xb7, 0x35, 0xb5, 0x34, 0x69, 0xff, 0x97, 0xb3, 0xff,
	0xcb, 0xdb, 0xff, 0x4d, 0xd5, 0xc0, 0xac, 0xfd, 0x7c, 0xef, 0xf7, 0x50, 0xed, 0x85, 0x58, 0x80,
	0xa5, 0x54, 0x9a, 0x47, 0x55, 0xb4, 0x08, 0x21, 0x62, 0xed, 0x4e, 0xb2, 0xcf, 0x1c, 0xfb, 0xcc,
	0xb3, 0xcf, 0x29, 0xf6, 0x39, 0xcd, 0x3e, 0x67, 0xd8, 0xe7, 0x2c, 0xfb, 0x9c, 0x63, 0x9f, 0xf3,
	0xec, 0xf3, 0x06, 0xb4, 0x53, 0x2e, 0xd6, 0x85, 0xc8, 0xef, 0xa3, 0x8e, 0x0c, 0x6b, 0xee, 0x84,
	0x3c, 0x45, 0x47, 0x07, 0x3c, 0x07, 0x21, 0x45, 0x2a, 0xea, 0xfc, 0x22, 0xf2, 0x8a, 0xef, 0x0c,
	0x78, 0x87, 0xef, 0x5e, 0x9b, 0xc0, 0x18, 0xf0, 0x27, 0x10, 0x93, 0x8a, 0xec, 0xac, 0x89, 0xee,
	0xc4, 0x15, 0x9d, 0xbf, 0xb5, 0x68, 0x76, 0xa4, 0xd5, 0x65, 0x13, 0x17, 0x18, 0x2d, 0x7e, 0x00,
	0x7d, 0x8a, 0xac, 0x3e, 0xa1, 0x2b, 0x4e, 0x91, 0xd5, 0xb2, 0xfd, 0x02, 0x6f, 0x5f, 0x52, 0x58,
	0x40, 0x1a, 0x2b, 0x0c, 0x52, 0xcc, 0x4d, 0xe3, 0x2f, 0xba, 0x67, 0x3b, 0x8f, 0x45, 0xfe, 0xd9,
	0x47, 0x23, 0xff, 0x3b, 0x28, 0xf4, 0x50, 0xbe, 0x0d, 0x9b, 0x6d, 0x85, 0x73, 0xe1, 0x1b, 0x10,
	0x63, 0xe2, 0x2a, 0xba, 0x58, 0x22, 0x8a, 0x74, 0xc0, 0xdf, 0x61, 0xf4, 0x71, 0x31, 0xc1, 0xbc,
	0x2d, 0xa5, 0x7d, 0x34, 0x98, 0xfa, 0x65, 0xa7, 0x10, 0xa5, 0xb4, 0x8f, 0xf4, 0x25, 0x4a, 0x79,
	0xf3, 0xda, 0xdb, 0x2a, 0x4a, 0xc3, 0x30, 0x0c, 0xd2, 0x4e, 0xa6, 0x9b, 0x3d, 0x57, 0x1c, 0x86,
	0x28, 0xed, 0x74, 0xb3, 0x47, 0x3c, 0x36, 0xe8, 0xc9, 0xfc, 0x47, 0x04, 0xa9, 0x06, 0x93, 0xa9,
	0x59, 0xbd, 0x06, 0x5d, 0xd4, 0x20, 0x1a, 0x90, 0xce, 0x48, 0x73, 0x93, 0xaf, 0xb7, 0xbb, 0x42,
	0xc6, 0xdf, 0xe0, 0xeb, 0xb3, 0x4f, 0xb7, 0x6b, 0x0d, 0xdf, 0x1c, 0x78, 0x5b, 0x45, 0x3d, 0xd0,
	0x6d, 0x5b, 0x3f, 0xef, 0x99, 0x89, 0x51, 0x2e, 0xf3, 0x7b, 0x08, 0xd2, 0xde, 0x45, 0xb5, 0x69,
	0x49, 0x96, 0x5c, 0x14, 0xb4, 0x8a, 0xe5, 0x51, 0x57, 0xae, 0x85, 0x31, 0x06, 0xab, 0xe1, 0x0a,
	0x0f, 0x37, 0xde, 0x1c, 0xd4, 0x98, 0x7d, 0xd4, 0xf4, 0x37, 0x3e, 0x27, 0xf2, 0xb1, 0x9b, 0xcc,
	0xfc, 0x1b, 0x04, 0xc9, 0xc2, 0xdd, 0x8d, 0xfa, 0x41, 0xbf, 0x0b, 0xf1, 0xed, 0xb2, 0xee, 0x0d,
	0x4d, 0xec, 0xb7, 0x1b, 0xe9, 0x86, 0xf6, 0xb7, 0xcb, 0xfa, 0x78, 0xa1, 0xac, 0xd7, 0xfc, 0x96,
	0x10, 0xdb, 0xf6, 0xfe, 0x88, 0x6f, 0x40, 0xbb, 0x4e, 0x28, 0xbf, 0xfd, 0x2e, 0x78, 0xc0, 0x87,
	0x7f, 0x83, 0x10, 0xa3, 0x00, 0x35, 0xa5, 0x05, 0x9b, 0x23, 0xf3, 0xb7, 0x08, 0xfa, 0xd6, 0xb4,
	0xa2, 0xa4, 0x2c, 0x6a, 0xaa, 0x65, 0x68, 0xca, 0x86, 0x22, 0xa9, 0x84, 0xc3, 0xc4, 0x88, 0xac,
	0x9a, 0x72, 0x89, 0x88, 0xfb, 0x2a, 0x4f, 0xbe, 0x6c, 0x66, 0xf8, 0x61, 0x9b, 0xf0, 0xb1, 0x8a,
	0x67, 0x00, 0xb4, 0x8a, 0xe5, 0x70, 0x05, 0x5b, 0x72, 0x45, 0x38, 0xe5, 0x63, 0x15, 0x2f, 0x01,
	0xd0, 0x91, 0x28, 0xb2, 0xe1, 0xe1, 0xeb, 0xf4, 0x3b, 0xfe, 0xeb, 0xb4, 0x61, 0x10, 0x85, 0xc8,
	0x76, 0x59, 0xb7, 0x4b, 0x0a, 0x57, 0x6a, 0xaf, 0x7d, 0x5b, 0x63, 0xba, 0x3f, 0xbf, 0x04, 0xf1,
	0xbb, 0x8a, 0xb6, 0x2d, 0x29, 0x9b, 0x3a, 0x29, 0xb2, 0xde, 0x5e, 0x87, 0x28, 0x6b, 0x40, 0x64,
	0x07, 0x90, 0xdc, 0xf3, 0x39, 0x71, 0xc9, 0xa1, 0xfd, 0xb2, 0x85, 0x10, 0x8b, 0x9d, 0x11, 0xe2,
	0x55, 0x18, 0xdc, 0xd7, 0x14, 0x8b, 0x18, 0x86, 0x24, 0x9a, 0xda, 0x8e, 0xf5, 0x54, 0x32, 0x88,
	0xb8, 0x4f, 0x0c, 0xb3, 0x79, 0x54, 0x3b, 0xe0, 0x30, 0x6c, 0x72, 0xfa, 0xc7, 0x36, 0x39, 0x7e,
	0xf0, 0xde, 0xaf, 0x69, 0xbd, 0xb3, 0xe9, 0xfa, 0xba, 0x27, 0x80, 0xdd, 0x31, 0xd0, 0x54, 0x95,
	0x21, 0x1b, 0x3b, 0xb1, 0xfd, 0x2c, 0xef, 0xc5, 0x5d, 0x56, 0x4f, 0x13, 0x4e, 0xe5, 0xa2, 0x2b,
	0x16, 0xef, 0x40, 0xd2, 0xe1, 0xd8, 0x91, 0x0d, 0xf2, 0x54, 0x52, 0x14, 0x7e, 0x3e, 0xd9, 0xba,
	0xa9, 0x4b, 0xaf, 0x9e, 0x1f, 0x63, 0xf4, 0xbc, 0x4c, 0x4f, 0xf0, 0xba, 0x3b, 0xbc, 0x0a, 0xdf,
	0x83, 0x94, 0xa6, 0x13, 0x3a, 0xe1, 0x6a, 0x59, 0x34, 0x0f, 0x4c, 0x8b, 0xec, 0xb9, 0xc3, 0xdd,
	0xe1, 0x3b, 0xdc, 0xfd, 0x2e, 0xfd, 0x26, 0x23, 0x77, 0x46, 0xdb, 0x80, 0x01, 0xd7, 0x3e, 0xed,
	0x93, 0x74, 0xf7, 0x0d, 0x6a, 0xe7, 0x29, 0x14, 0xbf, 0xf8, 0xea, 0x79, 0xa2, 0x81, 0xcf, 0xa3,
	0x77, 0x9f, 0x63, 0xd0, 0x36, 0x85, 0xf3, 0x5e, 0x55, 0x87, 0x7e, 0x67, 0x21, 0x35, 0x34, 0x19,
	0xfe, 0xe0, 0x26, 0x7b, 0xf9, 0xca, 0xab, 0x6f, 0x71, 0x0b, 0xe2, 0xee, 0x33, 0x6e, 0x51, 0x91,
	0x4d, 0x8b, 0x47, 0xb2, 0x2d, 0xce, 0x9c, 0x8e, 0xbd, 0x3a, 0xa7, 0xa1, 0xb2, 0xec, 0x2d, 0xc4,
	0x8b, 0x10, 0x57, 0x48, 0x59, 0x2a, 0x1e, 0xb8, 0xfe, 0x3d, 0xda, 0x7c, 0x7d, 0x17, 0x42, 0x74,
	0x63, 0xa2, 0x42, 0x6c, 0x1e, 0xc7, 0x37, 0xdf, 0x82, 0x84, 0xaa, 0x89, 0x75, 0xbb, 0x44, 0xb2,
	0x85, 0x97, 0x40, 0x42, 0x4c, 0xd5, 0x3c, 0x5b, 0x0d, 0xfe, 0x87, 0x90, 0xf4, 0x30, 0xdb, 0x9d,
	0xeb, 0x66, 0x02, 0xc6, 0x4e, 0xb3, 0xcd, 0xb8, 0xce, 0xff, 0x1e, 0x12, 0xe2, 0xb5, 0x9d, 0x84,
	0xf5, 0x6f, 0x15, 0xfa, 0x54, 0xcd, 0x05, 0x8c, 0x9e, 0x17, 0xf7, 0x3d, 0x2d, 0x93, 0x67, 0x7b,
	0x54, 0x8d, 0x6f, 0x32, 0xee, 0x18, 0x9a, 0xb8, 0x08, 0xfd, 0xc7, 0x04, 0xd9, 0xca, 0xf6, 0x9e,
	0x7d, 0x26, 0x02, 0x42, 0xaf, 0xd9, 0xd0, 0x02, 0x53, 0xb8, 0x00, 0xdd, 0x1e, 0x85, 0x39, 0x12,
	0xef, 0x6f, 0xa1, 0x6c, 0x50, 0x48, 0xb8, 0xca, 0x72, 0x48, 0x2e, 0x79, 0xf2, 0xa4, 0x3c, 0x43,
	0x6a, 0x5f, 0xa1, 0x4f, 0x9c, 0xf2, 0x8c, 0xd2, 0xd5, 0x34, 0x58, 0xcb, 0x86, 0xaa, 0x1b, 0x57,
	0x7f, 0x0c, 0x3f, 0xd8, 0x42, 0xd5, 0x90, 0x3f, 0xb6, 0xff, 0x61, 0x23, 0x8a, 0x64, 0xda, 0xda,
	0x89, 0x92, 0xe3, 0xa7, 0x0b, 0xad, 0x5d, 0x65, 0x43, 0xf5, 0x58, 0x93, 0xe9, 0x7a, 0x1f, 0x7a,
	0x54, 0x4d, 0x2c, 0x15, 0x45, 0xe7, 0xc9, 0x29, 0xcb, 0xf1, 0x4a, 0x5d, 0x3c, 0xd1, 0xd0, 0xdb,
	0x85, 0xa4, 0xaa, 0x2d, 0x15, 0x17, 0x6d, 0xb6, 0xbb, 0x94, 0x0b, 0x97, 0x21, 0x79, 0x4c, 0xd2,
	0x25, 0x26, 0xe9, 0x34, 0xbf, 0xbd, 0x61, 0xe0, 0xd5, 0xf3, 0x63, 0xec, 0xbc, 0xa9, 0x78, 0xa9,
	0xbe, 0xa1, 0xcf, 0x20, 0xea, 0xbc, 0x42, 0x2a, 0xeb, 0x95, 0xd4, 0xe5, 0x13, 0xb5, 0xed, 0x10,
	0x80, 0x33, 0xdc, 0xd5, 0x2b, 0xf8, 0x13, 0x00, 0xfe, 0x2a, 0x93, 0x72, 0xa7, 0x4f, 0xc1, 0x1d,
	0xb1, 0xe9, 0x29, 0xf3, 0x0e, 0xf4, 0x12, 0xab, 0x58, 0x72, 0xf5, 0x74, 0x7c, 0xdb, 0x15, 0xf6,
	0xab, 0x3b, 0xfc, 0xed, 0x7c, 0xd9, 0x2a, 0x96, 0x78, 0x07, 0xb8, 0xcb, 0x62, 0x3d, 0xee, 0xfc,
	0xf9, 0x73, 0xf4, 0xcb, 0x2a, 0x42, 0x02, 0x26, 0xc7, 0x08, 0xf0, 0x43, 0x48, 0x79, 0x8c, 0xdd,
	0x64, 0x21, 0x99, 0x13, 0xb6, 0x5d, 0x6d, 0x61, 0x48, 0x9d, 0x42, 0x9f, 0x6b, 0xf3, 0xde, 0x28,
	0x10, 0x3f, 0x81, 0x3e, 0x7f, 0x69, 0xd7, 0x98, 0xb4, 0x99, 0x13, 0xad, 0xc9, 0x2f, 0xa6, 0xbc,
	0xd7, 0x29, 0x38, 0xeb, 0xa9, 0xae, 0xb1, 0x2d, 0xb8, 0xc6, 0x87, 0xd8, 0x7d, 0xae, 0xc6, 0xa2,
	0x0d, 0x3b, 0xe2, 0x11, 0x4b, 0xda, 0x53, 0x55, 0xd1, 0xa4, 0x52, 0xea, 0x3b, 0x36, 0x92, 0xa6,
	0xc3, 0x2c, 0xa4, 0x6d, 0x0e, 0x7e, 0x45, 0xc9, 0x5a, 0xb6, 0x03, 0x9d, 0x25, 0x4e, 0x8d, 0x2d,
	0x18, 0x68, 0xb4, 0x10, 0xd1, 0xde, 0x10, 0x52, 0xdf, 0xfd, 0x26, 0xec, 0xac, 0xb7, 0xde, 0xce,
	0x56, 0x98, 0x68, 0xbc, 0x5c, 0x7b, 0x3b, 0xe7, 0x71, 0x92, 0x1f, 0xb5, 0x8c, 0xf5, 0xba, 0x39,
	0x87, 0xc7, 0x45, 0xde, 0x01, 0x3b, 0xa4, 0xb2, 0x1f, 0xff, 0x7d, 0xcc, 0xcc, 0x65, 0xb8, 0xf9,
	0xa0, 0xd7, 0x5b, 0x48, 0x64, 0xc7, 0x29, 0xc3, 0xdf, 0x83, 0xa8, 0x29, 0xab, 0x65, 0x85, 0x88,
	0xa6, 0x6c, 0x91, 0xd4, 0xe8, 0x29, 0xf6, 0xd4, 0xd4, 0xab, 0xe7, 0x21, 0x4a, 0xcc, 0xa5, 0x79,
	0xf6, 0x53, 0xb0, 0x45, 0x6d, 0xca, 0x16, 0xc1, 0x5b, 0x30, 0xa0, 0x68, 0x65, 0x53, 0x34, 0x2d,
	0x83, 0x48, 0x7b, 0x34, 0xf4, 0xe0, 0x6b, 0xa6, 0x94, 0xca, 0x9e, 0xb8, 0x46, 0xc2, 0x42, 0x1f,
	0x65, 0xde, 0x74, 0x78, 0x97, 0x38, 0x2b, 0xfe, 0x01, 0x74, 0x29, 0x5a, 0x59, 0x34, 0x48, 0x91,
	0xc8, 0xfb, 0xc4, 0x48, 0x8d, 0x9d, 0x7a, 0xa2, 0x7a, 0x5e, 0x3d, 0xaf, 0x63, 0xe5, 0xed, 0x44,
	0x15, 0xad, 0x2c, 0xf0, 0x22, 0x7c, 0x0b, 0xba, 0x4a, 0x44, 0x3d, 0x10, 0x25, 0x45, 0x11, 0x2b,
	0xe6, 0x76, 0x6a, 0xe2, 0x44, 0x45, 0x23, 0x02, 0x50, 0x8e, 0x05, 0x45, 0x79, 0x64, 0x6e, 0xe3,
	0xdb, 0x10, 0xb3, 0xcf, 0x78, 0x1c, 0x01, 0x93, 0xa7, 0x10, 0x10, 0x65, 0x2c, 0x5c, 0xc2, 0x63,
	0x80, 0x8a, 0xb9, 0xed, 0x9c, 0x33, 0xe5, 0x4e, 0xdd, 0xbb, 0xee, 0x57, 0xcf, 0x3d, 0x8c, 0x5c,
	0x72, 0xa4, 0x62, 0x6e, 0xf3, 0xd3, 0xa7, 0xcf, 0x21, 0xfa, 0x64, 0xde, 0x74, 0xcc, 0x34, 0x95,
	0x3f, 0xb5, 0xe0, 0xbe, 0x57, 0xcf, 0xbd, 0x9c, 0x8e, 0x05, 0xc1, 0x93, 0x79, 0x93, 0x1b, 0x37,
	0x2e, 0x42, 0x8f, 0x42, 0x31, 0x10, 0x5d, 0x8e, 0x14, 0x04, 0x89, 0x3a, 0x45, 0x41, 0xa9, 0xa9,
	0x16, 0x8f, 0xf5, 0x7d, 0x31, 0x53, 0xcd, 0x3e, 0xbb, 0x95, 0xc6, 0x7a, 0xfc, 0x43, 0x88, 0xb1,
	0x5f, 0x0c, 0xc5, 0xd6, 0x8c, 0x2a, 0x29, 0xa9, 0x5f, 0x76, 0x9e, 0xba, 0x0f, 0xbd, 0xaf, 0x9e,
	0xd7, 0x33, 0xb3, 0x46, 0xba, 0x68, 0xd1, 0x0a, 0x2f, 0x29, 0x8c, 0x40, 0xb2, 0x16, 0x6a, 0x70,
	0xfc, 0xd3, 0xfb, 0xa6, 0x8a, 0x3e, 0x3a, 0xac, 0xa2, 0xc8, 0x51, 0x15, 0x85, 0xa7, 0x9c, 0x24,
	0x96, 0x34, 0x30, 0x10, 0xed, 0xbd, 0xe6, 0x4c, 0x1e, 0x56, 0x51, 0x82, 0x25, 0xbb, 0xcf, 0x66,
	0x73, 0x73, 0x85, 0x31, 0x48, 0x1d, 0x0f, 0x5f, 0x3c, 0xe4, 0x3d, 0x87, 0x55, 0x84, 0x19, 0xf9,
	0x8d, 0x6c, 0x7e, 0xb2, 0x30, 0x5a, 0x73, 0xa5, 0xc7, 0x6f, 0x50, 0xfb, 0x0f, 0xab, 0xa8, 0x8f,
	0xd2, 0xb2, 0x34, 0xb5, 0xc2, 0xc7, 0xd0, 0x5b, 0xbf, 0x83, 0x7b, 0x48, 0x07, 0x0f, 0xab, 0x28,
	0xc5, 0x48, 0x67, 0xb2, 0xf9, 0xd9, 0xc2, 0xa4, 0x8f, 0x7b, 0xe3, 0xd4, 0x7d, 0x6f, 0xaa, 0xe8,
	0x22, 0x4f, 0xb9, 0xb9, 0xc0, 0x38, 0xe6, 0xb3, 0xf9, 0x1b, 0x85, 0xab, 0x00, 0x65, 0xbd, 0xe2,
	0x25, 0xba, 0xcc, 0x89, 0x86, 0x29, 0xd1, 0x54, 0x2e, 0x3b, 0x95, 0x2f, 0xe4, 0xe0, 0xa2, 0xaf,
	0xe3, 0xf7, 0x6a, 0x72, 0xf5, 0xb0, 0x8a, 0x32, 0x8c, 0x65, 0x26, 0x3b, 0x35, 0x5b, 0x18, 0x83,
	0x5e, 0xe6, 0x0a, 0x9c, 0xa5, 0xe7, 0x6d, 0x21, 0xcb, 0x5b, 0xb8, 0x4e, 0xc9, 0xa7, 0xa7, 0xb3,
	0xd3, 0x33, 0x85, 0x31, 0xe8, 0xae, 0x99, 0xb2, 0x37, 0x4b, 0x68, 0x82, 0xd3, 0x8e, 0xd3, 0xf9,
	0x98, 0x9e, 0xcb, 0x4e, 0xcf, 0x67, 0xa7, 0x6f, 0xac, 0x86, 0xc2, 0x91, 0x24, 0xac, 0x86, 0xc2,
	0x89, 0x64, 0x72, 0x35, 0x14, 0xc6, 0xc9, 0x9e, 0xd5, 0x50, 0xb8, 0x2f, 0xd9, 0xbf, 0x1a, 0x0a,
	0xa7, 0x92, 0x83, 0xab, 0xa1, 0xf0, 0x85, 0xe4, 0xc5, 0xd5, 0x50, 0x78, 0x38, 0x79, 0x79, 0x35,
	0x14, 0xce, 0x24, 0xaf, 0xae, 0x86, 0xc2, 0x23, 0xc9, 0x8f, 0x57, 0x43, 0xe1, 0xeb, 0xc9, 0xec,
	0x6a, 0x28, 0x3c, 0x9e, 0x9c, 0xc8, 0xfc, 0x6c, 0x10, 0xe2, 0x8b, 0x06, 0x91, 0x2c, 0xf2, 0x7e,
	0x80, 0xf6, 0xe6, 0x89, 0x80, 0xb6, 0x39, 0x80, 0x95, 0xde, 0x1b, 0x71, 0xf6, 0xfa, 0x21, 0x4e,
	0x3f, 0x9c, 0xf9, 0x83, 0xf7, 0xc4, 0x99, 0x3d, 0x3e, 0x38, 0xf3, 0x38, 0xba, 0x9c, 0x3f, 0x09,
	0x5d, 0x36, 0x45, 0x93, 0xbb, 0x1f, 0x86, 0x26, 0xf1, 0x71, 0x68, 0xd7, 0x0c, 0x43, 0xee, 0x7c,
	0x10, 0x86, 0xf4, 0x6b, 0xe8, 0xb4, 0xc8, 0x31, 0xf6, 0x0d, 0x20, 0xc7, 0xfb, 0x10, 0xf5, 0x82,
	0x8b, 0x78, 0x8b, 0xac, 0x2d, 0x9f, 0x5f, 0x38, 0x76, 0xaf, 0x8d, 0x6e, 0x51, 0x2e, 0x9c, 0x38,
	0x47, 0x90, 0xe7, 0x08, 0xf2, 0xd7, 0x18, 0x41, 0x2e, 0x9f, 0x19, 0x41, 0xfa, 0x62, 0xc7, 0xe2,
	0x07, 0x61, 0xc7, 0x1e, 0x9f, 0x98, 0xde, 0x07, 0x37, 0xce, 0x9d, 0x1a, 0x37, 0x36, 0x20, 0xc6,
	0x99, 0xd3, 0x22, 0xc6, 0x7a, 0xac, 0xf8, 0x9b, 0x8d, 0xe1, 0xd6, 0xcf, 0x82, 0xe1, 0x4e, 0x81,
	0xde, 0xf4, 0x6f, 0x02, 0xbd, 0x35, 0x99, 0x69, 0x7f, 0xe4, 0xf6, 0x59, 0xed, 0xb7, 0xa5, 0xf0,
	0xa3, 0xf6, 0x91, 0xd6, 0xbf, 0x78, 0x8f, 0x53, 0xdb, 0x8a, 0xe3, 0xf5, 0xf7, 0x02, 0x44, 0xcd,
	0xa1, 0xd0, 0x3f, 0x78, 0x6f, 0x28, 0x94, 0x68, 0x80, 0x42, 0x8d, 0x30, 0x68, 0xfe, 0xf4, 0x30,
	0xa8, 0x01, 0x00, 0xdd, 0x3c, 0x03, 0x00, 0x6a, 0x84, 0x3e, 0xc2, 0x7b, 0x42, 0x9f, 0x58, 0x1d,
	0xf4, 0xa9, 0x83, 0x3d, 0x37, 0xff, 0x3b, 0xfa, 0x6f, 0xb7, 0x1a, 0xee, 0x2a, 0xde, 0x56, 0xd1,
	0x6b, 0x04, 0x69, 0x7e, 0x75, 0xdb, 0x70, 0x91, 0x17, 0xc9, 0xb1, 0x7c, 0xf5, 0x7c, 0x76, 0x16,
	0x2e, 0x00, 0xe6, 0xdb, 0x7a, 0xda, 0xb3, 0xaf, 0xb4, 0xe7, 0x66, 0xb2, 0x39, 0x96, 0x05, 0xe9,
	0x54, 0x7a, 0x02, 0x2d, 0x34, 0x0d, 0x7d, 0x90, 0x74, 0x2a, 0xdc, 0x08, 0x09, 0xcd, 0xc0, 0x15,
	0xe8, 0x73, 0x2f, 0xdb, 0xeb, 0x1a, 0x0c, 0xe7, 0xe6, 0xb3, 0xf9, 0x5c, 0x36, 0x3f, 0x0d, 0x23,
	0xd0, 0xef, 0xdc, 0xf1, 0x37, 0xd0, 0xc4, 0xf3, 0x73, 0xd9, 0xa9, 0xc9, 0xec, 0xd4, 0x74, 0x76,
	0x7a, 0x2a, 0x3b, 0x3d, 0xdb, 0x14, 0xaa, 0x8c, 0xf0, 0x27, 0xb7, 0xe1, 0xe9, 0x49, 0x3b, 0x81,
	0xbe, 0x30, 0x5c, 0x0f, 0x55, 0x12, 0x2f, 0xde, 0x21, 0x6f, 0x41, 0x61, 0xbe, 0x05, 0x50, 0xb9,
	0xf8, 0xe2, 0x1d, 0x6a, 0x5a, 0x5b, 0xc8, 0x37, 0xc3, 0x2c, 0x83, 0x2f, 0xde, 0x21, 0xff, 0xaa,
	0xc2, 0x64, 0x13, 0xec, 0x92, 0x7a, 0xf1, 0x0e, 0xf9, 0xd6, 0x14, 0x66, 0x9b, 0x43, 0x98, 0x0b,
	0x2f, 0xde, 0xa1, 0x66, 0x95, 0x85, 0x8b, 0x75, 0x40, 0x26, 0xfe, 0xe2, 0x1d, 0xf2, 0xfc, 0x5c,
	0xb8, 0x7d, 0x02, 0x82, 0x49, 0xbf, 0x78, 0x87, 0x5a, 0x52, 0xd0, 0x9e, 0xf8, 0x02, 0x1a, 0xd6,
	0x13, 0xbf, 0x9a, 0xc2, 0xa8, 0x1f, 0xa6, 0xe9, 0x7b, 0xf1, 0x0e, 0x1d, 0x2f, 0xb6, 0xdf, 0x47,
	0x9f, 0x09, 0xd0, 0xd4, 0xa0, 0xcc, 0x1f, 0x0e, 0x42, 0x42, 0x20, 0xba, 0x22, 0x15, 0x6b, 0x58,
	0xe6, 0x1c, 0x9e, 0x9c, 0xc3, 0x93, 0x73, 0x78, 0x72, 0x0e, 0x4f, 0xce, 0xe1, 0xc9, 0x39, 0x3c,
	0x39, 0x87, 0x27, 0xe7, 0xf0, 0xe4, 0x1c, 0x9e, 0xfc, 0xba, 0xc0, 0x93, 0x43, 0x5f, 0x78, 0xf2,
	0xa7, 0x08, 0x86, 0xfd, 0xe1, 0x49, 0xe7, 0x39, 0x38, 0x39, 0x07, 0x27, 0xff, 0xbf, 0xc1, 0x89,
	0xfd, 0x4b, 0x6d, 0xdf, 0x1f, 0xa2, 0xfc, 0xd9, 0x20, 0x44, 0xef, 0x12, 0xeb, 0xfc, 0xaa, 0xe5,
	0x1c, 0xcb, 0x9c, 0x63, 0x99, 0x73, 0x2c, 0x73, 0x8e, 0x65, 0xce, 0xb1, 0xcc, 0x39, 0x96, 0x39,
	0xc7, 0x32, 0xe7, 0x58, 0xe6, 0xfc, 0xaa, 0xe5, 0x1c, 0xcd, 0x9c, 0xa3, 0x99, 0xdf, 0x98, 0xab,
	0x96, 0xfb, 0x10, 0xe5, 0x0e, 0x5a, 0xb2, 0x2a, 0x26, 0xfe, 0x14, 0x86, 0xa4, 0x7d, 0x49, 0x56,
	0xec, 0xbf, 0xcf, 0xd3, 0x08, 0x4d, 0xec, 0x87, 0xb9, 0x29, 0x97, 0xa2, 0x01, 0x9b, 0x8c, 0xfe,
	0x04, 0x41, 0xbf, 0x7f, 0x5e, 0x37, 0xbe, 0x0a, 0x97, 0x97, 0xb7, 0x16, 0x97, 0xc4, 0xc5, 0xb5,
	0x47, 0x9b, 0x5b, 0xcb, 0x82, 0xb8, 0xb9, 0xb2, 0xb5, 0x2c, 0xae, 0x3d, 0x5c, 0x5c, 0x58, 0x13,
	0xd7, 0x97, 0xb7, 0xbe, 0xf7, 0x50, 0xb8, 0x9f, 0x6c, 0xc3, 0xa3, 0xf0, 0xdd, 0x66, 0x44, 0x2b,
	0xeb, 0x9b, 0x2b, 0x4b, 0xcb, 0x2e, 0x2d, 0xc2, 0x23, 0x70, 0xed, 0x38, 0xed, 0x83, 0x85, 0xf5,
	0x85, 0xbb, 0xcb, 0x0f, 0x96, 0xd7, 0xb7, 0x5c, 0xca, 0xc0, 0xe8, 0x01, 0x24, 0x1a, 0xfe, 0x4e,
	0x24, 0x4e, 0x41, 0xef, 0xd2, 0xf2, 0xe3, 0x95, 0xc5, 0x65, 0xf1, 0xe1, 0xf7, 0xd6, 0x97, 0x05,
	0x71, 0x65, 0xfd, 0xf1, 0xc2, 0xda, 0xca, 0x52, 0xb2, 0x0d, 0xf7, 0x42, 0xb2, 0xae, 0xe6, 0xf1,
	0xb2, 0x90, 0x44, 0xf8, 0x32, 0x5c, 0xa8, 0x2f, 0xbd, 0x3f, 0xbf, 0x29, 0x52, 0xf1, 0xe2, 0xda,
	0xc3, 0x85, 0xa5, 0x64, 0x00, 0xf7, 0x41, 0x77, 0x1d, 0xc1, 0xbd, 0x87, 0x9b, 0x5b, 0xc9, 0xe0,
	0xe8, 0x04, 0x44, 0xdc, 0xc4, 0x65, 0xdc, 0x0d, 0xb1, 0x07, 0x8f, 0xd6, 0xb6, 0x56, 0x36, 0xd6,
	0x96, 0x99, 0xb6, 0xc9, 0x36, 0x9c, 0x80, 0xe8, 0xe6, 0xca, 0xfa, 0x5d, 0xa7, 0x00, 0x8d, 0xfe,
	0x73, 0x04, 0x97, 0x4f, 0xf8, 0x33, 0x9b, 0xf8, 0x0a, 0x5c, 0xe2, 0x9d, 0x13, 0x57, 0xd6, 0xb7,
	0x96, 0x85, 0x3b, 0x0b, 0x8b, 0xcb, 0xe2, 0xa3, 0xcd, 0x65, 0x51, 0x58, 0xbe, 0xfb, 0x68, 0x6d,
	0x41, 0x48, 0xb6, 0x35, 0x27, 0x79, 0xf8, 0x68, 0x8b, 0x8e, 0x63, 0x12, 0xe1, 0x34, 0x5c, 0xf4,
	0x27, 0xb1, 0x47, 0x3a, 0x19, 0x28, 0xfc, 0xd3, 0xc3, 0x5f, 0x0c, 0xb7, 0xfd, 0xfc, 0x17, 0xc3,
	0x6d, 0x7f, 0xf3, 0x8b, 0x61, 0xf4, 0xe5, 0xd1, 0x30, 0xfa, 0xa3, 0xa3, 0x61, 0xf4, 0xb3, 0xa3,
	0x61, 0x74, 0x78, 0x34, 0x8c, 0x7e, 0x7e, 0x34, 0x8c, 0xfe, 0xf2, 0x68, 0x18, 0xfd, 0xf2, 0x68,
	0xb8, 0xed, 0x6f, 0x8e, 0x86, 0xd1, 0x8f, 0xff, 0x6a, 0xb8, 0xed, 0xcd, 0x5f, 0x0d, 0xa3, 0xcf,
	0x57, 0xca, 0x9a, 0xfe, 0xa4, 0x3c, 0xee, 0xc0, 0xd7, 0xf1, 0x8a, 0x39, 0xc1, 0xbe, 0xec, 0x68,
	0xc6, 0xde, 0x98, 0x6e, 0x68, 0xfb, 0x72, 0x89, 0x18, 0x63, 0x4e, 0xf5, 0x84, 0xbe, 0x5d, 0xd6,
	0x26, 0xc8, 0x33, 0x8b, 0xff, 0x51, 0x54, 0xef, 0x1f, 0x9c, 0xdd, 0xee, 0x60, 0xbf, 0x7f, 0x64,
	0xea, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0xa0, 0x3f, 0xbc, 0x7e, 0x8e, 0x76, 0x00, 0x00,
}
